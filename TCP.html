<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79a0934536e1016ee74ae437d33707917284fa6992901c48108ebc468d46cd1da91c82d691352c71116380c2202de5e8610fbce296384b42f768d69d6e2bfe2211679daf94a573b14399e3444a79fe312a7e3902196dc9ec64f93d68a74d612621e9fc5a612887765dc58cf58ce4dd1f05fb5ef40b72d6de98a9efef5ce1dd2e41ff354283eb0b50a7c719c217eaf942c909123d15245b20456348f14d7f4f324fcf2a6cf2205dc79da7937b7ce97bdfede2306a400e8fff0325a85876f9ea63e91f92c496c15c5b392c9a0ec5d4c886ee36a3aff7ad2e5f14a46eeed10281fe85fe00ff858da797e04b1dae83930956ae752802ecb226cc0049b8a5bd7282254bb71e0571840c8b39cdbf4dbc46a62b2dd7291d7634d2d0fbdd9b6114d0ee74fd371b8bf9b339dac40ebaa64764d46546c0f236cbfc866b5354d39cd35fdbee638588c2f82c4d7573ac25056f4fe6787f9263984cca5491cf8dc4807a711286851bae1ca6e89f26876704d6a754b184261e8683c52d891e235924c0be462e40b3242d6bc84432a4f89ddcbebb579d0d6af58d3d14cac7a6d006c30be329ef6b66a632945d64bc2bdb44ad35dfeefed31f6b2a75d645c4c1e67e456ab313ad0f49be8a77a715fca4fe9b530def311c1ad33dab17bc477a307d3b3a5ec0127c05cb664a7a6393d1c5ec1b4f976bc1d4039f1c5ef5488e8ff8c23bdfb0f9a483f5bbc31b93facb0347ebfdcac37fb27e1fcaf61f8c1c8f59fb47d7dd65cbc325a983940d217a3f6b09677cf11135b380705d18860d458c39e3b814565d42d27f014c01c2376690b48677d5f8736a8a528b09e7460a8fb1693e92ad14b8ed181dbac09e730b77bb5e16328e8c3e9006e88294e4b447b8b1ae32126d01ccaef673c05825b909b225ba508ad06dac24a8ce9ee7c5f3e0d2dfb4062fc6fedbde5dac7e3095b8045f1f4203be2dbead5e115f6a3ad636975cf46ed3db0094ba1181b64c797b44a5a8f3e54177a5605d4088fbb6478814c035dc111ecf968bf3b92251e0bedc0fd3eafaad08ab85a656f45584a51b8a95dd3d0691d30d810654e5cdfb5538728069648f86ff8321b9c8525eba1d28a98afcd2f5d0ad70e91e55c26a84cadc49aaebb5fb9e8937a3e80ab1ea2e77092ad3023bdc545cbc5389006e1915d81445e793b5da1cbf45c84ade1c4a8b20a88703a95725d8d5ea1dc51e4d335fb9694141ed05d849610afc403f2b492019368d3998eb5f8bcbb89c8770551428de18b6b16f070c4bc98ae811c7152250b7583cf6cddd98471733a33029aa11f903151739c0377c06899828a6ae12402cf87e3f04d124b7b17256f419586d1656d04cfd9a5ac6a0dbf780cd84371a9ca8f21e06da6e27a0030a9a3b19e036c5ac7af6f9fe12ed4d785479c83e137986ae76cc773f9ea0b0745fa7b3fd465dec591d7d225d4ed0b405604e0844d956cd081371e845415c5f4dde2b126425b495e67aa7cd0bef1e3c8f4dd442f15df87636826400b80239fb9d2d79ed117159ff7660a566c2517d777f37a3f84dd6c79de679218b172fb0d7b867811a3ec43e33fc03be35de8f6656ebb7f53e2d4219c7b348c5e5a1d90639030b42b16a1c0305b038e27b00a98abad30726dd06b2e06e8289235a17389b51265d4f30b7ad8b22e3a48c2a79a08a76c9a3f5885ac37ad4f878b9a121ac36fb052718f1a2a0eaac3ce3593dd9062ba438b66aee06ddfeceef2d2ab1ba7ba8def10c2b745590cc6722d3bbc0e5dd28109944e5c0e535ca37d834826423eb81dd34d391638589bccad54b658eec2aed341c95f619bbd19b28f2a0daae1477e4fd33a7a2a04c73ee50d2cae8acad987a0af72f73d827aec3953e9c28641bcfaba827a3b68ab5b253f5501f6fe0506ba4f40e005e1c80898ac9fbfee31d060f6d968aa2fd1714a7ac477ff948664e250da339c6806470628c08c7191fa506f9dda838ea8b776d6bc69d72a3d59726f1e4b99bcba2b109190f9143ba9dcc7fbaa664a0d989019b28d429e41b51b1e4fdc5578f4ba9fbde547234e7c18c69731afaaff86a3fefd828affb96cc45f76905f8301bb0ec0357431c6e774f80455e9cab7aea25da3bcfd3207ed3c4dc8a6f17031d6890e25ed2ffc4089837bf8f5b8d91f5fbdbc28678726c3dbab94ceec04585fa2d0c06231e278527f6f11cbdb4b5cecad4137e19eff4ae8f3919e5d5907b6076caf4c90721473aa32f12135454c07d7c61283aa56855f8c1f9978980cea107398d58c29fc3e443aeaeb85305698b0468c26ecb8fd50dafe60b2d160d5e312daca1bcea7d21f96741a29d4913c8b418666299b914efbeec4353822a87e045fa5c44f7dc1b2759d0b1a8cdd465f8b927746a29ca7c31a860c902834dd4e2c3a8c9d1020c5c8b4ed0007582a6ad02296520eb49f2413997d822528f0e49e9795ec4708e8107c4be73c239ac6a8b1b5e261abf9ab1f23c9015203e12647a1a4ffb8e633c79f4662d0393d14fe566338f4d88693f1af1071b1f06a437c3412132286b1fbfb345edc65fa61cacbdd9f6b224af37dbae2c0047c140058ef6bcd5bf03dad4ed295bf6a76e169834048cce72a9ff525cea44784fb4904bf778e18f71775f1e39bed1105732d6b9236ea6cfb14c1f30fca15674715ffa89fa0e378b0ff28e2196039cd92540b3f5cbeb852bed51e5c2688a8aad449638de152e2ea7aeac802b8f5aa98e55296de8ae6ad0304fcc2b0609990c4057e185561bdb21ade07dab191bf498e4ea48118ffca27a728d5ab98bdb6d9f30cbbafcc7256a2ae4db3c3a1f20f24ca22bcf2bdd09e956e75bf2b9c5d16d04cd3140e19d7bb37aa257caf77a0952e508d1e5562e142454ecb8d5b7678f28f967d473fbb2c223183d763484916c1d9203bec1c59f149f9df9446366be2b46e213c3c1543436ee12ee31e9a72b1939895d0600bb75d21900d4ddadab1c33b209c1b9f76c0d83b4afbd4c8791748345af00804e6cca1ba2daf967ce959eff1662ae2fde94544f793d985b00a522981624e95cff43cc395caa0ebd1b94106497f3ab7ed0ec0b0c81b47f57c887fb4251645cec047eb7d35692e79851b10e973c76d20470df0428b32598fe6e79a981d02c637d8a055e7f11bed69ab51a1355e029b7fba452712154da6fd8d6f1345478b3ae0180428095e385db531dfa50d8dab59c9d13b5fc86db20054ce651fbc70fc2abacf91c451e9d1f5daf8865d79cb2f2c129e03c8a5955b727da28c641f021f40eaa07e9b00c76338e547d59649c8e988d411617fd0bdfa0552e69d6cda33681b26f52df2c8b264e830857dd8754455a7c77b47c1f43edd8829dd1f78f72ccabb4635b2f42f0d94673d106f652f61932ee26d139439aeef8fe283fa9f464b6071f612c8f8da3f6a01ba6ad75912a7bac767f7891fc92647e0765e78eb3586e7f4156bd30dfddce7a7184c0a4b81f942a0e72707bd6652f1b1a813f07507fc93b40605142ffbb846593de7207f4a74359135ac5cd77483a7f19e704b64279d37058dd098d79ee8aafcdcbdb328fdd938f7ead3acb83e0262d397203d0087eaa3bc30ed538e86a108cc55bb2c571eb96c3766000b88179ea9f4b0b37371c3ed4879a0c0bbe3f4da8f3c83de7e90ba3089c75e2fab61310f96d93fc026426d6b8eb979e567f42787f9cebe2a0d7c8e0e62dd3fdefdd677de1e8c33c031a5a0fd5a5904a423352d0c771341fc4a25699a1ce567ceb69586c3bb2bf6f72a813d8c9c053dad4bd9b06e6ef7a1ecc298f85e219d877bfb46ec43dd13b9f7f15679bbd6ee9e1f49fc5e8c17c40cf26bded1457eb0f77575ad840213f7cb208c0794fb3fdeb4fec8ce6a6449ede56036f95fb1ceb92af7619ed462ed8102fb08a5dbdb73be68e3065f6c51e7b83be2d9b78f9819b8c0ae140bc36f7df76b79e7b7dffa555bd74444618c7640f3da63ebac54662dd1638066484b184f12c7117f6970969c2cd69b6af4da97fdbd68c5a299909932b75c947163e8b9c48d94739e3edc34e63da046dc42e733fc87af8078a9d32b784288b8fdc6fcdf1a43ef30e23d501b19d3b34cb36978d964ce64600674f73c50d2110b7fd83279a9b645aa99a3532ae56ebfc70f54bd335e9ad02c78c66a38697b7c68f883cb4c871d5a5f0cff0d2cbd96d536925fbb5b7bc76a4506f65848e053ad0d7b3cb8fecbe6f80ee49a364322652d1265e422f04b63ee1c10d17a635cc20039de4cca6544a36762675817a7abad2cc8eb452e59398ac93ad37fb7ebc9d1a52acb6d0786980f5fe42d71fe1b0ef3ec830a02869e845a4e562973e7fc08e16240d85714a0a7b90393a9b761d55c0026940afa4bb08aef63183be05a0bc72d41785f342113d2d800858b578b4dbdc4516b60827e75eafad53593d7f118de92232fcb3535b4550fd6b2edff4245bc46c8612b1c7d74bb25ec977adfbacc0b1f058913f65f81a11616aab3e4ca79eecddcfe131f509c705ffac38f0499249e74b5b9695a48ff3cf7724a29fbd5f0285482cf6a55dec4660b2d3616a5723168ec502e00124b5d5e68c8980589b46a30b40403538ceb5170a8082fcc6920456677d6f75891726e2bd0c7e1a5bdddb093fb60d0cba5f90ef582490142fcedd3df54050144d99afa68d0a5a55ad5cbcc7baa4b4a2dbff32bfa6ff8ea82bbb84150be1e537d62e0dcbf79caae809d4124fc6e8a0879df30be0c39575a23e61632168efed14ee772e77d2861bc3d899b739af3628ad139625c71651f61b877a69ac3399a88ee93c70a96e0d521ecfdd2b1900a3ac537c22b3bfb0e72f2c965f4bfe052975eb08f8e1530f9bab10e702056db2c29c69bba52cac91a09875d2a1e25768d9be43f8d54d264ce47cd68ebbe68821134805b3f6485a59d5724c7769413efa289b0ba62e2c01c3bd18388775cb509c0231016f8c6e5526d8af45cdf7b09fa44906c2c34461815e6d25d06773ec8a1708042ef333b9cd3f8e12267f07e1f1fd687e8d84925867ef85edee4ba33cd105d4d03a336ac13eb353080276e0af65ef1b0e2748bb336639637213e1c6d17ff9bb63a3a18dbf6898c2e6b7b4a68857ef412ef14396c61dd16ec55255f6ddcd263e930b14e4079704978f96c297e3d7a321f47bfc5deeab43a5bbded6f6d6e5879dc384c4665d1c639701b92aab52454bec3004c7ad8734165c3853546c6bc89d6ede1a68889ffd2c61e695e0a90b1348313c60a654d590b10bc44328559d172fab5775e1b2db9f3ddacb8d2df7fe916c4428c206a058bd9d74b9b497c5652f457db3955544d318c23b2e4ccb7d6ab856ac034d2ead9ca7901b6b307cf7619f0de089c9998f45bcc3dbb1fc7413886e2a42bbc05029c9c504cc564fb08192287053b04852c1c6edb6cfa833ee0423320b87b933e082f9b9f30c30efbd31c591a45be6362891ab1f29aaa671ac0cd520fd8fcb5228f430c2f7af298eec35eaa7285e8a60e72ca93fefd35576a9c06f3f585c1b4e85badbd03b6182682205c8a96f02b7e455d8fa4d5fdc33943159b546f5336651216bc06cc68aaece8fffa43482326c541bd416bacefca359e5ed973b9c01f9fef3d0894dfbfb2792bbe6beb1a9b5d16d88834cd052a3a660891c083cd446f6c047f01a91fd317f2101448e7e795611750fd33e645098705f924d471432424afaa3381a7710b8eb98946fe94923b00ad4b5df86c71375f42f1cbecb03349fbc28e2c7ff2045b41820ac30195a39aab060c4adb909ff989e95cee3eb362fe7f43f1a86b6831418c3f16d39e014581b6f5d9c34d1215b05371f6761ee225a05b52d9f5a3f50ef868187a4ffcaa72de6cfbd23e8cc07951c3f27c3c41aca0e7f4d2a2448753cf9a499eb442a635b1720cd180b86025d0df6434a0b0b30fedbe2ab15a696fef6fd83673f9cdc573f8ab9b5063dfbdaa5dd59f8a47af489897b9a1323011a385eb4867acfaa3af9e472a8c4f7cb3ec9c560a3bcd5a9c467fd866d12296ba56b0a12344f38e5dab3d4c89596fa98eb6259518bce8a5a870ae9162e02a5803c11621cbebdcc3edceede149172e36f6354015b61a2659ff31bf1457c5de61a1de44fdf5d5cbbedddd73e40a7d5bbf6e1402920d223c3679da033e29bbfba4097558eda601e26880a03b41a4efdee1e9ea52222893a4b41cd9a3b3cd498d08caf341dad1256bdf41865c43cc15ba3927b65027430ce42743056943c9e60c0ebea9b1339be8ad790b982f64dc72e39a0bf5c1bc7551a08f9e234a6957169e8f70ef17fcdd3fae3dd325f0e4b7c682c0403a3f8d73ee13e740a9f26841cdda03bab36d3b52cdefbf1a47ab604ecd3576732e12b14ad16a60b3aa14b1658806ee7e0b462d0dca017459e5f7e99beac23b63032979b41b54fc3dff3d17788991bc767236fa1a3391d9178a3e5a3446a4ded68e0c921b1f050b3a06671e381619f0dde07f5f97a8e6c66feff2bb9fe3ce55386ec6c4b97b50d07478e23757c81efff4ee420b7bee1b8b24fd7b61f2190ed560c35c350ae02f8f54a79ee51bd8d071c1a17af96fae0df500d9dedbc00d74f7c0a5a77bbd2029e4f8026ac24fe279e5b8e776a2bb0e2c33113d42e612b4a9576c6b277c7513bb8bda9322afd3abc2e341c75d0cdc23eaabf342ee1af1303d380c31f8bf7f6f021511cbc8d8753c1d601b83e025396c92bb7648410e681b24cdb970ba0f524c1432a14e6986122bd644297a2c7ebb9bdbcf19c4b05a66be7389768a0467563d34788f22c508928e99c007b7c7ef7f466d749f45cf7275e43476a9b2e7f2f71dc5151a48410ca48d8804be0e5530218de884a5251a380a19283db30638bcdf3f9e4774e16f5c96afba774b39d57891b11528b470ebba09dff2e7015cec13d417d52457394f44ffaf67d3d3bf5893c4ff1cdf7150244b5c5f5980f8d8d08ca054b4a2dd522af96d9ac2176095fbee5a2f6ae182e927f25d8ecde6896df41817c454559ba942b9a275d0e911ea664ca3166bdb6e3d7ff7b24955ab06bb853b8c3791dfe994cdef0210f56a3260000ad684aed2236c481ef05b91cf226b21c2b5c3d24515b349b2e3b51856ed3be5b91cf55bc2901d0a279b22e3fa1b479b380f08f5676014ee3628fbdcd96ce6ef0dcc7b73ebdcea6a59545d233c3d2e4e8a8c9f138b14751c68928ce44dd89f0948a9b87261125a3792e4420dd200fdba740ae9ceeb1afbab187cfca067f26d40af08f861e469425e8800589a02cde970e864e23a482460682de4e9080e08e2595c6f6138ba259c321d303bf0c1ac0db0892c58e5c19945f27694f1f600b69d381bfce86aa7a625ac6f4cd6f8331f06a00c885f71202a4db233d76f6498590620b2d1b87134ce2bf8e85458e8159b6ee3af2ff9fb5348860e07fbaae23befbb6f0241d79502ebebb9410521d182716547f57b97ae6a7f4500474ec59a28eb8d5813c00927ce43a610f2ed9fedd7d21019a0b8e0304884a03261fe04f27ece3deeaf53a806108c8e1e2ec3434757914f94d76446fc48e95ec88f252e5121123c3098f967caa8ef9434c2a9e89d092748245387db973f7a4abfd66ec637ea5858f740a58781fa7774e183f00b3c4eac9f89eb6e027f6bddc6aa7baec3d365430cc4a22c02d517313e398b3896f1fef8f9335c7f4eabe78a779af82bac712bd7303591e4be93642764bb0a380e2e32564e077264cbfb65eaadbbe867e22cf5240e97ae72eaa7355c1af750d74f4072c2f52e84d43c939006a3ebfb2a7697a96425cf320439fec20b8650e90ff4fd63c41857ff93d6d2a0e1a1deb418b6c0c86ff0a2cc0c61959d61816bc7f63211617845d342fdfc316b2e21c1f587394edc45e4705e19e1021fe464d034e3c49a8ac1de9c758c532285f867edbaf63002692a0294d378efe516a695b012ad9edccee4df775234bd13c46c5efd46e73237c04890d1d93a9129bb6f3759b6bd388f16c06d63e6a3fe328601595d87fcbe5f0c8ac1476a65645f59e57688e9ff9dfe1ba29f0f42fa62135e3c5a1d02e0c036a3473d6d4ff5e72d1ae32e4d30885474a47f9782dfba591e64dbfb40d7127c5ca9e501280261f8e00845cdd033effddb8557d717f1a266b2682f1e995da11cfb9f6b8f43ca9e3a21cc2eeff75afb76e9f0f6739ba6c033ec6ef03736de684c1cce248a5ecb2c700e6b0f7fe2211705d20adbc1277cb95c81fe702eecddda3c2374e0a3098e1885093f435cae38dc926e0742a74706a81fce89c5dcc47f0f1e4721a710408b9a7e28fba697e5d8da98e1163f6a272bebf4f19e4fefdd912786f46a5ac91ecad5430ec5549af25eed10f3986d00495e9819f5c398e17db8fba4720f89b9ed9ab21bd77b9bd86294a6147b6d1a1c34b80dd27b9af717b09c1cbf1b6ab0fd5a967f71d51e635a7957edd3f39cfb1d3d0b923c4e304d5a8de8163a71827253db43e896c643496de8293d3f471fb60e5bbce2aea874f073e1ccb411fa19b0e5f2061ea9b4b2b44b27c3f77620c513ff2e7ff37e9a7727eee3614099fc5fff1b12698ce2caccd0bc2beeb081080ee9bb87fe3c7a3ffb1a310cd34822b2a64ec610d94f8b702372b7f286697af21ceae13b95db9e6e85638e3aedcd9b93c9c8d199fc1a56e7d33c772f42526a933a0091c75252593c27692c84dd4dd9aa35493794bf7a301fdb6372a2b075bdf7601cce8954d5dae61f0e39fc75161806fd4ad498dab216cb3a4e279773bbc311a2c29ec3443fdd1bdaaa182d3cf0f178dcdca27edaf709d6801f2d7385aeac8cb845aa59c941ea0e82144fb4f00859839ffb936050f9c301cfffff4c884cda280331afc412e412fd979d295b883964a8fe85cf67849bfd64ef7e854f351a8ca41e036fd7779193c4f6edb7863e19cd55f30965b60b181e64836a67e91f1a71da8b61f1308080c3d94445df45f50bab269574c479afa2b7082fd142ca41b981b3b6022f6929d30e56296b5edaf8ae9b0483d887348cc98ce25ac505eecbaf14e8b95a13b125b19e994216320247df499219dc33da5effd49e19155b4dc89138b27026a347fd5b45f18c66fa935b6ecb8fc88045795ee6edd66cc57f762a0d072114bfb41cb03edea017f2fa01077366841581256a1e14edd631010be622ec52d33130ef2a97f3b3553aa5d5007723216ac83d1b2e5b0dbcd40548fd96e11bdf9da7da539f38089014cfa65356457e9112a8b455f246297226d86bbb89feab3049b97c9c8d135ae259cb12d1d55cace2cfae7ae7e7e293ecc15a44b8983eb3028b43342da7963c0ba942ba76ca3e631270674d5706e864fd07a0654f279c10f3d54958f097337f7ed16643f0548ce3aeaa8920e0eac87b1efcdac41b86deedf3ed2d5805220d5c8e973997c5ee0ed26265ab1614d0ec53c167d9733e8157f19fca5f4586842ddeaf5224d29216fd5e76338e9f435b260605579972b5a53c3dd55c613fd5a2d788831f8e295d84133aa09e0da192ed4e9b628a95c50d15ee024068e0de20f9d7dbf74456303dd977e4cad14c8e14775f0804b76334d07a15ea4c1383a74a476667cfec01cc0f2cc7699688b1aed6a8fa114fbb29e1f8ab015967c091be3b75deb0c551b915e3a6d4f5911cf77243de26f9e3bfc89e04ad2a942dbed5d1816e8bdaf076cb26a84762cdda5298fd0fd714800e9151edb5d759e06d18e82679b4835d9813f9225dc87aee805ecb04291887961f0cf3d35273f44dc9e42b9e4a98c0ae22e9755f5854fc06b42a5fc0e4f78ab2321c634304654392697c4e557dc00d6e2e7000e9eaa89495687870f55ca7c902be0717354a68676e7ddf9f9f6f691fda59b16321a2349f106caff268ab19910151dae08c0974e5813589015d31fe8e135f896c914ffe44011aed471c6bc71d0e4ece24f135ee50c0b446271bb4d88422398e2b6332972b7bc5b79ca289865631e26f3518b568b7c53a253fa811495cc1842ce5a6affe11a7b9f44392e162c598b8d04a412e4ead15b9f75687f55b8decd4b549902c4fe5fbe6e37f67c38bd5d32a4c786bb4ad04230c60ec3648b173f0ffe48c717429e9bf89d03596b08b7f47beac476ba28630fc5ae1deec7cb25a24ee07b715d97a0258ecec3fe5f6bd271f474a2498aaa83350861c5f5d822205dccdb4a1752d749c9b3b640f4b51ce59a1d147ae9e7d143b2b3ec666b0e39679edb4cd461ef5de0f54229966839c6279e2e8e25022b4b4a9dccc0959e22a01f60e65c969f18d132a1d0beeb3c049c7b15dc3311a647c82c3b674fe6f11a5f0567c7be221a8c9b8c65947e9f27da4f9195507d2845cc97163d47e9e2617800556f9c8c143ada76a44e302b0b7d705320362f8c39e942e28d04c58147e14c7e732a672611dc8631bd6a3d53af868e921247d5fea10b626e1ff77973d3640afd7b565791ba769a58b5e9d2c78d0efa02d7b4354d15e19a7b6a8c3e5027e5435f6fec11dfc34feed410464b85e47c9900d79267a391b73488cf7100ff73fdbd868840318d53ca142a6b935ffcda48ac2506ba4bbeae6be5bed8f46c38061e57e7df84c2729bc80d6d76cd2c2b4e73788d123d776a1659837c266236aaf67a9efc232e44ca8aca7b52aab793a220dfb573ac80134f76eb4b63eea398d149d14e533211472d7a0beb77d3c4a681233dde75e6979149bd90b731992050b252b45bbe91f29ffc1a3fc96134404029043a19b27af2ef8ba52457ab6588c8d1a0814bc6fad61d35bf1447d780f3acb50d1b418ed415ced2e40ca983a15672af4d5f72c0d0ea6fdb1b3894cfc5bb2a997bb563ef5ad6da9a02d48de33f264c62086955701e130d53bd6f5c6b80be102be12d340ee653f939475684b47a277e5c25da8033531daa5b77341267695be7ed4d9c91a376cdbd0de379eb495aebac7f03145971c56172b2995019f2fdc3110718f8b82928da2a3734f190e700700de853f48e42437f869cc07ce917b5fbe2ddde5447fa668d41df2fe1c0420c8978af0547238b6574917c78fb60f0a46bb3753f99f95f4d4d48bdaeacd737bb7b425b88d3288e3b5dcc9df7e4632a0e2751b5b1781fdc761251e1da8a5e8366c72087167f48a2fbda5499a22493ee493783bb5d4c18146bbe7ef547034b82a52ca2ce723d9e483bbc0079bcd38552ff7a9553576acf18edd67cfe9253e90971d47fad2b241db7d47376a35a9fe6f24db98007fbd367b59edef924b9484a7b2e1a3844570c8ed3de6fb62957464cdf42b474172995c22161c53966bf0b58e88e630625a06b053db4ca887cbbf40658d1c83fac8fc2d4d43e84539196346fd5c20a5a1b4ad6de39dd4e13835260f5f9852d2caa3e35d761914619c07db9d83f035894b7eeca3a02d18867b91d145561c14331089f4dee0e077b376b8bc107ab2ac59bd20d686aefd2fc151210a66e65bf2e9b079b74cc8a4a5282f5d55f697a96fbcf40b33f6c11abf41ca37edffc9d668260c4ade1aa945fd78a398f93a1f11918c1a26480c4788a087d68feeabc4ff2abe2a7e44e1ebefe2af019b3db0369ba7737656f321730587271cbce025602bcbf50dfba2b12496c250ebff0c702f1ef577d532175a27f4a8a2b1697978bd4d1748569295083f31aab3c7bc2b61ea71568f53b9e8355fa815cad9910ff51ff60491d7a753f362fc7584184c65ff449209f9b5377ceeaa0f735d0ebbd2feaf48e02f9fed36bbee3f12b204f758887d50ed31827218b1b39c343ad805cee34f40629517f656b39abf6fc971762f36cf69efd757a481b3fa2f5ac17fddd543e69c19641bba651a595b668fdda42809082adf90e070baf2eea57ca750a4752b07cf279b59d615c8ddf7d9f300ac798f93d1bda7ce829fe4fb79447e7ff97b601fd180af654348af782ed2b313d8988a214bdfd23225637a52563f7522cab6ef81d0eb8145e7a00532a495435e21657701897eff265460089074b6c1df6da21d4642f2dde71bbf761f384c975393c189d8b7e430432b93a572847f39f682f57470bcb99102eba50435695107a73623e20b24f3900702614d2b81c9f394a43c6f9fc7305dd8a6a324665aaa5430087599309c6f36fc88d1935a8fd3d5fd35663ca48309b519726bdcf26e8c7d1d831be81281425b2e4dc8818ce0c97c65a212f1234a9ca5f28248a2699f5ff5a779514f04f11faa8db0e8beaa454135baa77b570516887fbfd5bbbeedd0637be7367264b57f07f00927272087d655823e871af08fd23231b7b6cfb0ff5b13ef2a11f33467fa60f9d228af130e44b7e5f453534991975ea38a20f9731902028ca23ed1894655a42ce6d2fcd221f0d6d8df53f1c87060a47360045ebc26f47f278744f6a460f190a6f071c9c34d6cffaa108ead66ff75797fd565bee44be804a5892ba19c16925409bc3b33ee69b2792b1a0897593bbe23d93c609c09759a4a614cd8e54c0623ef7f79d30eeb44230ab7ccba972617159ad8794c8053aa10b8984e9cdcfea78ae88a3872b7132723c621951bf0cd1d3f5269fd17de12234dd8a8133045e04be109310bd7dcc86399ff701834d1196f72008c40f962212670864f99eee214dd44cb8d610e3908e43d8bf270fed848845fbacd3d1740d4e286e93b379d14db815e66247ef830d00ddbb0092371b2fd39cc653ef6f2af1b22abe3ee76c5e8bfe5d6f2c0ea4d232cedd1beb4b7ffc723841baaa2af4d3bb8711f17f0f42bf582f597577f68a215fce7beb52caeb83149bb00247662487ce3303ba536d30a0cd802516defffdc2ff832dafc031866c9d6592a1ac26ce552cd96ac231f686c50dc0bd6c9750b0df1aca063f2b85a9f655e80fc6d828dae7a7ea5522fd1b09b731d2bf616a8c722dd0700cc227c7c83a1858aae2962af35bea09403f51a92ae5454bbd91ecb41ebf22cfccc250e87928d772858590aee7899fd09f0355d5b3e8a9dc2fef079857f232d504959394b85359eaf724506364ea8ce58e35d24ab6b420b6eae4a0cb4be52429aef48dedb360d4370809d03268765694507be6042176016ac9092643fb30e4941e9b48f7fef4f1b094b4a06d564ef503945cb03b6df249fdb88c6fdc869ddbf9833374a14edc6f16fdcd8d6b1233731154744409d8b9574a3b1a95b0ff4906818966ab593724296c566842a409dab95b6bb86a5488997417509fb16c1554ff1fe24ba38a456229cf6c1f1ac6e6fbecf3cfe3bd11b051812a1cd4beb75513835c9efc7316e6ec48675ce6398e56a9c9fdc62bd5ca0b372e3a0bf525867a0b6073abe297f8f0f2d11b8f22ea50255a87faa0aeec38b780d2d2f38d4f7b9ca10d71a72f02ca6beb198a41cb66a244d7f1abb42ebf93d0adfbb6305f9e6a3f1d5d9f5c09e4d720759dc16415762263f9b648abf2225bee7721399f7cc03cec4652298075afb5bcea6423b6b38ba50412e0304e60dea2fdd5e7e074ec7d8dad82aaacfc04e5f64129ec9fdb38281420be40b34343d13041bfa2121eb7f65072dadcc79d98f49d2cbe907ebc4c12869ca5a66b82c5b56375161546f484213abe3605ce4b3fbd15be7a9a2c8a5f0839cadeb7c71569e779c7afa747deb4391b82d78e3bc605e79185eddd0a5e74855e3a27381faf4fbfb3d987fae3a437dfdbd35a2badcdfb610c0a2bfb2c24c8200a581f7434c320b239058f52da387c28c657e93473d7bcac757e45cd7b3a503b292a1844cbba066aa38f367bb3970dfee58cecb23ca82cc23d4bcc417674dd8fdf5df387dd0acd22fc6733af074b2ab0204d5e565a0fe5b143a267583a7b1f395558ba228d06af52cda8d61865b29517401065738447dc0fd048be99ecfb4359e09bdb400a662574820f55fa5e1d88fc8d4f96821d8a48a0b482106dc1b40cd5b4797afeedc145cd14dec6057f7b93e139fb3070875d2e0fdfde15a8b21a7e77d56259b3d6b2b26994f1d653097d493959519265ca60b43378485f6b1bea98916ef2ab81d4bf1f4268749073251db19002357bffd5eba1a93dddb658b1c855adfdc138b8106cb8108bbec8304c0f6b813fe99189f4c5e83a944c088983108185436c6b174e3bfcdaf0e6ca2b5e1e443eacb3a4e355feca6a991c3d30e6cd13e74f09f76220efd0bf8b51e1563ec81f75d419cdeb9ce02875949e600210bc66c11933671a58a03283ef7c49d0653c6cfc2e7917035632dfdcf35c29adecdd3194de33d7e01de75c2981aabc6a1bf5c5bc66bd4dd69b3d1cf64c2ce002c623fcb81680d4b0f83163c432efd5a1e1c26976b3c5167603727989456776bcb10da6e0ac4a15230887b77c8406e442a4a4cbb83a48be63701fa2044a1fd8a7d37205fd4f6fedf064e71faf1262e3893df48ea239ad4f8779d568dd1faa60735ce37ebc7ea41a6208fd767bf44be734dcabfb33388765098a614e6760986c644f47fc2453b1cab39dd3654368d768b347b2d3c52789a19fb77b0bc590fbfa2f1bab93507ed87cd99f8e1ac790a0639d52b688120427306a56b36d709b56bdedfbb3682a44ff2ded171fc533d9be4bed7bd00e2dcb62be9a866a6d79ce2ae2910742717cc1e84115a00b73122db2651664efe42f0f8a4acb4ad7b83a6301982b4415bb32d36ba6e04748102b5c0b73db84c30438aae85952af3bb5063213ce24766719fe73c21cdf71df932677d24f953bfbe3a7300248806088f450a3f0d5ad5de32cc6cad407c4f6f2a83448b8b8d9667eea8f0ebeb39d487b57ad43b6891d336214323bbddd62aae81a3f0f6c33f43e12a1a1ddb2c4891f2fc8c1dc05f0176d447ef9484ce7b415839ac110d9d43657b2328b631e22ee20d5bcdf4169f19dea98a1d36fbe83238485669f2736fe1ae7dcea652f983d1388a0e89bd72b5ba67b6fbf988c3398a909cb35116386143de53f10e4568e051ca278b9fa7b8894a455e08848990ccfbbac5f9a4d3cee95af882e31f137af9d98743edd78ead01f54769b086347c40142d0f4f9f42989eff80de653dd11147c82c4007b4beaa7c737be8a02bd2b7b631d6e23b7677d0d981a4d121ef520b1ce2f93a9f6e0da56fbf412d52d78613288f58521","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
