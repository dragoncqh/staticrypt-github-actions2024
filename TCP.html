<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"322bcad90abdb58fef0cf775653654f8c1ea55786e9e347c190b70e5f14a7aea87d103c19bfbee3461dd06d6b2dde4b9a5134b45c3ffb0312aab4f597e1ace5503e45e3e42467c3d03a5c8cb54e81396323c1859aa10c9f0e7716e2dd95d99f6a5776d7fcfb2a01f6ef04c2e02b6b7c24288407fd8c81552bdc3f407890668d764398419fc666a3274d8af965947feac03a67a3f05ccf3238b19ea7e89be1c68b85e3c7db440db90d8376dbb3bca67d6e58632b1388ec5cf92738f329c2ccf6378eee06c6c00ed56f8b70c8545643434cba72ef3c1e01fcae5fac992670a57531a1747078437e3832d8d031d6c0e5fb8619f85e94c92fdf7aae586ce91bb64628f1384a718302c0077c3b693405e889a56b64eca6faab626fe97a8203a2398bb7097043a399bd152520539f51f4fe1e44c523bf55d04075f2223ad4c1a1e32cba2df5f97f922da36b6da6be52732c00dc3b5e466ce85b8e127e4a934b04ab3de1f367f7b79c2abc9ec0b029c131b37822a93333c072e3b426f69443b105af521f84ae2b01e362c5a8ff9867c21b3b612c64bc8f7e6ad6224997137844bc23161a52d887f734c2bcf409ce3b90dd9bdf59f4f8a4dbd0728dfeb97d8bfe5ce1cea9ab3a93a42744c49a9fe51f0a47ab810528bd773621782c6cbe803a56da270b4d092c845b10747462e347c8d13d652157919691db1b909a27662a14b4eca5dbd3536faea09a3498f890175318f2f3138e868a69318c93658667b1c600e889254dab0d9925d8873f29064c306a78ab9bd976660f807aae1e7a16ff7c7a667ec6bd30b1d52bef6ad2b58b62b8b3c8a59a104437cd58993c3fcfbbb3ab375e6bf42d2cd29d8702329586e79b02282201a6be9e9bea80a21f392ba762a75b6ddaec1022515fcec2b206aa25d2f837909c086f9f1adf10959358b2ffa5a359f53c172992ab06921c9e6361224ceea1b077870b835206c4333277f92805b2b88186f02621c0dea736e9772ab7bfc4d31ed99eaf188605d2b14ebd35f319bad8b697b4bb53c831dbe47bad832139273b8ad061771266aba8a2d5ab60e822611533fd772a16e242bfa79ee44e37b3bed5790ad1b987b73374b619034017c3f306723f34047150179b7cb12f3bb61327bdae7ce92280ea1fa29148b4dea1fd66d65b76a6e2ae9fc2d3ff10eabee2df9decf34d1707f6d6273ef43958380f0f63ed6ff6f81e268f3327826c08fdae9ea3478d75cf89a44f5d537c7681e3e373cef24429e6e4b893912c5a82771e6e320536dc023a597034d0e1c97da7fa66cd3e7cd4c6cf6868dc33c0aef6f57d0bd47f85b25f808804d1490ea447c10d6a56711ad9973709ecd53df4831885511a0233fe52cea0a7ca64c049da1488d55c2c6db6e5fcee414dca31b7ef258844ef01e87c971af9cf0493dedd60623e06a6df771bbc6209c893b421854caacdd7e6a7d0ed6fdcdffb0006f5dd9c1a5d24c98142a1e4fbff4e1ce445d3ab0f6d04d77d94f24a353462036225c5c04f2da3b19682fb0f8e27065a13439a27d9dbe682b7d23b6845c01602380901aec7d0ba94e9816902b758294a77d33aa868574da64b32d15bdb02ba523552ab8871f1241d09089dc6169834c9730626543ba03151a0379a493cec264786cd1983a2f80cdb47808272fc15d4e143949a7dec590c21a5f602ae480eabff490f7415ecc7b9adcb050200de646a29f49d612281fcf8d718a8b62c85b3f16834102bb511ca28c129c012cf10dc9988b09d1cecd912ac5d43f59772ffc83b67d0c94dfb157b2815cf4cc889322e2dafed3e7c15458863f22e3fced36d7b45f279d17a528e811f65b585be1248a7e6ba117c5ce0cbd869528a2c801e94c8a273668c16207766966a04c60e9615a8527be5cabc8e91f5185484bd909c76f4945e61cd17ad3b60519cbed92946615c633182d48e394e03203a0e01fe21491e5d970e4317c838d6f8e49caad81af95ffe36ec71f468a309b5bcd74ee5e015aba2d4f41c821df1754f62a709deeb1c69b0192342d81d4dfdf5502237547e4d0c5fd6c55f63dcb552de4880249d9054f61693d61699a8edab7db53f932cf0be6729934167aecb774aaca7dbde69bbfd7b84debac162972db566234cee358e617842307068f10367e0c2df76dd4e91af057e2ecde53616ed46319c9b0030718414315dee4e4ed6c0ae9580ee9c6264688fb1f86d2b74cbe804c7f925a80ddbccdc8886adb3f1693b9cbae6aa4e772a2fe2f0b8dd68454e11805e7e679d3fd439780e28e54de211e9b97a01bfd17d0d66a4c5566c6d39f826a5382acad52c177b2075f4ce3bcfdf25f11a0db6193ec82ab1a57c80757ecde5a0a0697587cc84a95113e64fc42f12a260f2fc1922435027750857ff9210762d35b50a09269c41de1457a8c824a36acb8b7a1ed14249512154eef96ae322c7f24e525082c9c4603b5f3deeae5d1f0f6fbd095d25919e4ab29c3b62fafe9e0cea2e8bd04bc81527404282794f159192c91e1033efcd7086736a3ba83644d00f56459ce37dfa1a2373f01159ebc2cd40e8ea8b25ed40374e772c08c22f967cd16a59d9cc4dde248c908a1655a74faeeee51dddcc309928ef384b0c68245e32d36a841506c8d06725c3b112588318706450edb14398edc1a0bf8e0b1dfc121f0d219fa1de0521b6784e3ac476ddec6c3e1d965666ccc2793b5e23ef4ec9aa31cf57221718393cf0856392e6784da5ef4bb3cbe2685d3c30642935eb2676ff6500732fa75bc5edcaef1fe9ea11e4dea309dd685e3072efa8b3e6e626be29f31a83694956a055072c9c190fbe5e61cca8321fd370c3310bf96a9a8bf5a39266ee2d1033799a2349b249b9334d27b3441936d9bb4947fcd7bd7c140381674ae0be52b11324cd642551b5781bae9535d8c8a351cea1c4a4281c658ab5d942e495b167e5fde26dee76915a028869ae7a93e558b23f1fe7c8414875776d26113241ef13c951cbd656fc39b62de1da59fe5debc24df986ada9f6cde4d902bc485cb3bed8a6962af16e9fa3de68c8765dd0453cee3b0e18d2e78a0f82459505a074c85b63a4cbad0eb07b59280eb0251abd01e3ea8d3b7755b2251f0edf828244984eae9054d78b516fe76670256e3336f5eddf006f61da99713fe9a13f91c9be4fd59f6f2dc86621bef17ff5196018f5b85e0e6d5fe0d61b5d53ac3c51d860d07fb0b945d59e18bb6bac34fb79b1b605cbd275ec4d66c4d9d1977fb7d4a7b460a35ec84d05e0b0efe5669ff4fbea31fe8e9df482aa61a437f27abd792d40dc5f515b31b112ccd31d95ade902a019d5ae36c2e989852d83e2a76a04cf574fd4116a77ca2dd86d5622d9354f45445c185f8fb4dc94a044c4c6028ed73ea6939064c7833e476ee5e2dafc53901cbc9945279cae013dfd96c947ee4fe2de4563a45cc17d2dc3031b8b8c7eeef8b8fafe7471c373548a3cd68f8f17dabcba4a57228ea88055698134388efc3bbd4122ae52ff7686e413bbbd022514b7acc9c2b0df697f8057c451c7e6dcf3dc45ad2f53fc0ef86283d38ca731820d4660583acecc4222542e584f209bb2f493b125c034eb62e35d3a9291d3f8045e9ce7ec935ef4f7d9c6079f1a6a8dab2ffafd707b39aed45df0e89b7515bc9f4bf7d03113487a7e30c003d431fd8989df09a57ef77bc1e49495446bb45c4179e29c203aebb5d2c4000b4c0f7230ac64bd5df807d53240c0486dfd445e5bb02e5113fc0225438ac4796584a34eda28ea0299f2295f95ccbf1f37e35d57dda1f248eb6f1b8be5b2f9fced35f550b904fa65e11d39c4b0532e81e5a794e5123a6c8756a058e25ddfd3eaeb669ffde1d7cf9d32ee2be50cd45b336f196fd40757228beefdc5d9e92ff0c588e3094299563d37902fe5c48017228f10f9a6d20dae4ff05a8637a5d9d2a532096e30988c05e20dea9798615476c879c318eaa8baacb87e86e4a5a745ff7b9f9cb072d8b22f6c99a5b7cda248fc803bed18a37300514aa8335bddd2ccacb325054d0fd7f4d46ea98123f80709d20656f89d43babd1686a0dc5d2a7129ad46c92bed94e98a7144a00746bf5cada2e395e6e3392c0a4d2551e11349c1d8037df49b7486625c9cc89dda1fbc7c13bd627a0d9e3e37e02330a27be39a731997d3d7368790ecddb2fe7b11ba07b64f21934d32ef4f0875fd298a7632ea833a8c53b3464d76678011a518cfa9af04e585e1a8c1fd6c34bd73218356be096af4fad1e61e7dd2d8c5435dd9b42b81f793e0d95a11a8a9f97bee02b9a46d84ed308c1e6190e11a500fd682f1b185adbd6044230d1da1fb95708604567139e9fc957ca9a670ef63230613bc5a52b189eab96ebdea9c9f1ea42216c47d3cb4bbfe22c1ba625efbec255d5e790bbc5da9373fb2a0ee9e6743019ff7692e1e914de1ed6ce662f97cce6b730c77cae4f2e04768fb4e5c7a125d5bf6ba41757a8cd1a85a40ee7d4e88fe8b3a37b7209d598d0fbafd195c8a73bf964ee2e5b80ff1d90ca37a041c54cff1a0379394eec1992831f19907da1427ec80c9a6e877c206aa0b9feaee2a2a30cd272b344053652033fbd1d7ddfb9d7b268fe90f00656ec78075719d5836259f3fad303f095ac5bd84e79e097da262a61962438c1f647d4fc7131376abeb0bff7cedcdba9fe45cf1c1fe65a103782c37dc50ae68d3a0a83c40411fe003137130fd82f1f7c3633197f917932b92f3399f7950d095f3d904c4a33cd21357d6587bdc8cab5e5dfd83c6da760fdae8b57fc3af7583401c1186e336c662e7e8cb1b038e3d3ec94e792f1c427edd4140565c91831d36fa0227d9597a015d71294a46aa1c9118b23e8af23cd1d8ead07583cc4b34718a85fbc0e8f204d48dcbe2dfa2c5e4490d9ab8acf12fae4fc71b1036f71adc390cf6cfb2fa11c612d0c5160319aa525204f991cf0b09ce5686989925e116dad8851559a1a83656d854c39d29b49abeee56050b0b8e250baa58200ec8cb285160a7a0cd978802b8a6f44bd63bbeb8a041db6525e5cb62064a36c2ee3156a3cd9f13e447351b5e5112188df8e3ec21a4e29400c6252ef202983429539563057a2a18f59fb35dfa106022493d504fad98914da5565165b30bb5e0a00a64873a5767220f33dcc8fb62e12d5bb9f6d2a86f2b26d73dde74bc4e007a6ce1471ebc503641ff1e5296d1eda649ceaff2f7cc1f8a46a5944006918d751039b93e132e158a8d41275b63ebd3bee084c8851682aced4315a3dcc4a9508a5b799ccbe5a1db2d765cab27e72ce52d3b6b0c2fcd0565942ca3361503776e99a3f8c903f2154d5a8160c995fb1beb35e078e5e1e7c43c74b57454c2e96feddc86f40432ce0e1b2c7a40cabe17ccef5099e63edd92c65bd68293af36fd5f5105d49bf3f5e1b396b3785354cc3d1bc62560bc4edd17738cd0a72a4f5137677860203a029777bb37cd056cfb5464632730472241472cf34083376900ccdfa8edd0b74536487d56c702c33e846b80a8adbb1033ac375a03c5c2056c92dac4f8d87dc4385565a626f5523b21113030e69a922656c2cd52e62b2a967584e943f6a1251a1ce47ffc825208884306c77a537fd516ac8141b1ab2b5abfac6fc32ee0d3c8bc27b8748f22128e130655eef168dfe719bcd9b44828a614ac9fa77f5c4bbd336c8f1879e17a7040a2f97f69dd2d565a5b85d84feb764e8a9e6cfc18e2461344f1fd34edc2344d2c3a2e28270df5a22919e93e5ce1e507f83a07d10f323550631cd2f7bdeb70c59e50f8d0cf43371e6589ddfee015e00eab5f2eea715ece0c825adb53556774877590d861228efc44dc8fdfb9694a854cfa8d8f540b5b4856908a1df26ed505310d1d41e9ca47b9f2bf0494a897e82d621e54e9fa8523d9178bc133bfee71c45fd17e48ed54d864855656c433d773a6c0f3f81b6992fc309347150a000c7b7d70e29387df33afa58deedf553e520efac3654c57efae492db1bb72fa945eaed9868268717724634949fc39c648ac7a7ae641efa65cdc7186b310f2eb944fe62c8676f80fb14f19f0ab65b4fdf9d87dc4312503c6b1782b8f01c4b8ae4cc66df74d4e7c395da31fbdd1239e8ddcc470a454797422d2b6774fec58e17a012af949697a3d96f7809f3657afc501b93601fb3285d845bed1f99badaeda6adb8595429eedce80cd5784a4d4289259bffa49fdaa36e86bca7e63fa33da0a069db3ba2ac5a3e70dcf369754adfcd24ff325a1affee78cd652a106b139ee02b8f68931d78861009249a075e0e5bb32fb6ccaed29047e887b17c71e0fd534c9c7e9b7ea34cc9117d23374d0738731f7bd67208214a4b3d5c7e318c613c9c50ee9f3992eafe93325812c8d30998948a7bc9916bc251e75b2b6782c620659192a61fb19552616f9287638fa38819abece187ca0b8c433486ba79a0950fd5fadc802dd3e697e684967f235cc29058a6398e03813ec1e4dcff438ed303a2eea01d7e2760454487790b6ac943cc3e18d3b8f4d257bd232596af31bc57da5923c58d9bd6eebad73555f85cb611b16c4a1b79f5a2255f039f5e831a8e435a5b9cb79ca9efbf3960d3df3aede57f6cc74b6eaf48316788182d9525163500cda0d5e4fcb9ebbc824f381f0b785934c7475c38694d8802c66e36d0a7ee21c5a27ff6819023f684e17b42f8978d1963c009cd10da295781b4e54a39283ca06eb402db3edf2869bcc6332f06369ca0eccc065c2bc0a5c615a6e153bfdf34fc7853626923a3cb2995dda00300c42c6e9c5a69d52101ce5faf9cf65f742428b8bb34d68d9410c35059441fe73cde10ca385f0805132539eb766fe8dd3e14a940641fe2560297ead7f1cd47fc85bd3fae0893023101aeb560030cefaffb4743330065a8837f5b22e4d79f6348ebb52f13edf55a58ced082ff2dd22676a0d077c486a80ff32138fe6da7513d196be4bda189d8f35e0bb1c85ff15f02665b0c854db40cc2ea18e4b29b1c4f17ff0ee2cc2fff78f4977a62cd7da4ba12e4be8077cdf9304512c3aa613c743c42e02dcc137016b782c12831693d65230fe0504e82767ff9a6bdc56afb51a7a15de1c34e02c1d9efdb7e4171fd1c017a47fcbc875034682df3fae950549f72b610b824d8e8c108e98913c662ab6cec3d814ee9169b93be8e6b29bd1bf71a0541c0c32d51c9ff17dd2342726ce1c0a640eeb8f409e0bbf60b659416ac3c9cfb04e2cf40c9efc0c1b37e4fbcaedc471f8574873648c234c8e525fc5cee08d25aabb05d8ab7a83263d327e3043084979f2a0cd6c0f98913036f6f98d34812f0153444fee59ddf848dc2127b3088bf47ffe0d7fb3e49bbb7f266a369647318ac7d25b784f026e4ee7cad03eb0f4d2ba3cbb677a68eec1db88e9e84d83fb21ed1b16a268d36f454c7469bf0170368cb865f1e21ff3d6fc6d33beb0d6fe003936f0a7339b9784582887945894434a96509420c5fb34b53e5347a9d175911711a04182ab7356c2d6240cf16433112a348db44a249a23fd4a4d74ff7cf60217bc648975a6f950a64842bb56698e004322f8add57cda61da1373cc48c439bd02e6f753e3dec82283a02bfbf5efcd9fc7326f1eb529749914f69606d315ce7a107a738f5b02401c981b04389b0f8b253779601cd42a878e94f455ce2c1379498e40a54770c5b11683f93cabec25ffa6c27d4ce98f26e7acec64f730b9897c0ba0ff2345ccbf16f88d8a6b96516b451007ff253537c1e73454eb70bf81804e68c0939380b68532fb643607012ee3e66053549b53a08073ca271aac40997fbd17aa2af27d8c32c0cdf0d79e3d1f3c24939e9fbe3945739e2e08fd51af985dd9b4028a3f1b17278ef7028499641578af56c8793d7d2bb592f75aa178ff9ec5c80d764839e70347943b029edd43dd65d9516cbe592f204d56938ece97c8f98b0fbf49dee910e5657a5bc9c492cc0384bd9a004bd1517d4311c8f6bd2312f9bde973181387f230a23c8b3590df60039b89e78819d45465405cd01f8e6753b8b63691016ef7671bfbfc3704aba4ee246d2ffc6db19838e96e52cd2165fa0a1c156723c2cc406d20c840dbe0884beb6508ace91df9c250dcef233a8348acd138bcf5f7c2761c2e95392ecaf6351722f82dbc86ebe7483f43de7a373c2b5e2191015010b371dfd38e64722620afb67828e92ed7210caa97fc7bf6735a3ce0fa2bba549efc153059f4825662189f9a8ef967c793c237dd53f78c4c6dad7948122cb06e954422917e39ee805d3324b99703f6b27fa054984b31549c6c159e6ec489f3e1d0b0af5b759fae116bbc1d8c40a38da025de740c85cedc21fc0ed777a893f34f65fd2ac865b5dd0380b913985c345df8d224d189ed16c472ec8793ee61f27c92c554ced7f7ffaea749b7c7c42e77d0b91d51f5c73f11d2f875c145f7c755c1c4e4bf6289c6c922ef6a8c75a03e1a06c1235ef85c3b32f58301332ecc9fc1e8102f155c1fb5d98faa0e6f4952d16525b811cd78924c9bb18ff2a43900fac35898916f16a086314f2288b844964fdeddde50b490eb96be6d232b35b1f2eb0dc41363e961f9b9f0280257f7d573b35bb20af6b2781bd446949d1f8eb37c86c47ba6b077b0fec92547d250a7449da54c7adcb8b7931683b667a23b5774e5b253f4a7b1360e35db5a6fcd20c108c833908030f7c921bc5abfb55c2f651f593aa9f5fb30fc1514f75e3020991c1ee5740a8a8a245d958295d4c80ad994b9a16422453d98854883eb41d2d274e4ee1807865fd4440d4f6dae605aa3d8f0d10f000d5a3fd26d486e82f348cf74d92906d24a6373aea58af0546ef3ec03435d4e8227fc36b2f6c1968b53d6abc717f81bcbf9c8fe4346dce7c8414bc06452ca4522c12af1560225f460d084f90d2fd20cb31a2806d3cc6946d18da2ea4f13550b878fc21cc1f8985453fa56f8139361832c1103da69f0354b29033693587390bacde54f179aa2d3f27b466b02bc27947d8d6527fb470458fd09e05037a4d65aaee63d953dfd13c151ccbea61c13b34b35da2a0fd67610fe87bc2d2a593e1b3f8f2a99e8d652620f9df95dd2f86e21c9c0e6da816f104e2743969a67816ed25ccdda06cd73e7f1b64436e6c89871fd24c08af70d7676b40005d98e3abe7ff0040d2a8d43dade422dac73009755dd0ff86a59dc239c004b89076631797f83b0e5772a1981cefdf995815e5f2a89a039cbd4dada19c4bf75198cc298fc2d7fc040b36a5a7cf0f5f4ed97f539f093dee90889714cb0f17135106ebf88b2c27bd064595ff7b730a5f9ec738df63be7cd0adefe8918f1e9383f67460bc647801d114586cd310deff404e4cd2fcfce3e561ca4f6b287bb1c4bf15532cee60c0258844d42609f5580a266ce848a50c7980b583ca0f6f9ee1b85ff04b547f16fe16f60cfb7fffe2c1ec9acbd76132c80c27af0569b4d88afea72879ca9657a523a408ee2e5239d0a02b3f1f88c1bde59fc18fd2a61bb70730703ea8d567dbd2d33476443bf53bd0bd06e829c7c838f9befad9a4c0d71621c1f51d67d2f803ea1fc062de652bbe399797455329de0e10ad0bacf4712bade7d4de07306a034c5c2aca48189ddca58d0b7c5287bf2d06b0e588929aa86f31ebe2c3185e0260697ffd8d40fa6b81781dc76c7de9dac52086d3e1a14a0be958e33dea1a08be18d5bd45370ad478ec368332e7f05ebb4356d661e614365d2a452909473579c32e4880f61a277842f59c0be509f6518e563ee4fb5ba01b634af2168adf8295f26ba1e9a3b29fd3ea83915d3849593d7a79334cbf0296cf1485cc95f400c364290aacd7720366324484d79ae0f871b003386653d1d62790b2fa0d561532fd078bef1f3aa7e86064bd382aeb0ba9cb19902fecb4578eb43c6a2c1565d3e4d40c0841138755e7520707317587cab257d827df66ebb26c64e2897b666ddd833ae5e53f4c019c5161247a8afbb4ee15ec19272f0f1e9ba04cd07e6a6afa464f65ba499eaf6c13aa44ecdacf28f85dda990638ea1e9396a564959b4881a4e25bea58051554d501105c5d043fa72b8c42f0083cfe690b1a285340fc08ded7e482d815b5a3361758ea44212acb3fdfdb9d842087e90597cc70630229f683a26618ac21818696ac6926a05297d487ba8ee0ab9b87269e2dc94eaffac1fe01c94baf9c1e5eecce965ae55be7cd576df50a73f2eba1e7a94886a93215efbaeec4f5d8bf58853e9381feb1726d5cbd18b048dfdaec054e1882d461b2f79f1fa3ee9f300b7bd5e7d44831825d5d7edc4a3499682925c6ec164dceefd54457b79b9181597c296e2928446a93871a1697656878be248b4dca1165703dc6624a3d346221b7dabc336869aa342a28d13c1b9c9d2c7e7ca3497da920855257bfc0c0639d826e2030465436b043750abacda6b533123feaa6346d67a54218f8bdb9caea65acdd1ba6651f30f2b271d557c9d1dcc11b8739f14f55fcd405a279b7253c11fd0d493d94c44e141f39a985b6c20a070fa6e55e5dc2ebf9fb91d9d14e1ec5be5beb6b7a55a89c959359c7dc61a9141d12576c7539005a4fb56cf384c72a8ccfd79204fc77f933503284a4915cfe9328ab1ff53f506bb72afb526e7a56714b1e829f47a2bf42ac38862a47c96f34a2140b499923702f7e8b463c903f7c9f6c1dbbc1e72cb6ef675b8e270ae31b6dfb1ebdac4dacc0b82a1f79fec7fed0af434260850f9df580a3e50d3ba36423fcf0e872ddccddc36034511ff636bd10680b73e557d3268f42db6b3bd4360cd2d533d7c0c3d91b072746733bcc239c58ad6948c5bf4a5dad3d05cac5b90cf8e9137839a6524ef78b94bfdc60c46e507c0be1406534c11831c92004132bb753f889ec0c3b3a255549a113b52fb4a422815abeecc8da6fc8764578c08a28b45f2e4526437f4565836dedd4a4e54d63f835681b70778d4fe85940bbdcc63728ff9ef90d2d0a66bd5cd629db9b15a819a04b007c88216a76d04d8e974a71a08fee9e340ceb59b771c5a2b03c6ca144850a918d6593aec2f0942d3b0ca12b5fc90bb66f1667afac01778a5dfcfebead231cfce881837ead3c233a3e45f760369826d1e226e0e1c7d5105b6384be1b59c02de201205f55f6b2600745b023fabf16af95d3466c8507167a7cc8204b1fe82b0ef0967f1d1b4c3840828b8d25f57c01302ff126581122802db44c04ac410d294d3d583e71c41f010851de544143ead910f2a4a16100453b0bd7698fdb61d12868ade4c5aca0d34b018d42305c5ca7aa4cb03ae8f7005046b8217f644fa349f9ffbb1c63e070314cd125e0a6368850270652418225a512251fab55df3d9f18816f1104737320bff1cb9f9055cb28b51178990af6eda89b69f37e0fd727bb04cda517dd816a96337df19a3441737cee4c34dd29de75fd7dafd2d2507d5cec260d35ad3c1043f70e7c0cef38312bb79e290000bd247434c2dffea33cd257cda70b8dac3f7854b3b925a3c90f8f3c2e9954600c8b0390b180e04bce0de23e28e937b84c39c696625a3b01ee99c0054e15c8feea62fd69c3ad51ae4f71d1ec7b7a2c0f562e76321e1e14c1513d408dc39b744c951682ed2da81eba1e383a14f3313240b936e909e861e426f0b650722dbca2bb5e9e61c8dd5da52c0e1364f8e9b20c319c835363763614d3bc8d8be2df099846936a3d58b10fb5d0c9a367822a7909eeab02c7e93948e519ecdaea37cc0d56900d6c20fe3988481ae8c3bbd587767ea682954d1b71f898939d025f204a394e675f44e8268a7a150940f00db5704ef37e79d46de00ecb6631002e517b096db06dbbd87bf8ea4a0fdc7fafea4f7c094a28e2dc96e44f5d6668e976b8a8a2bb28bcde85e084b7581191fb618bf4677809ca9f384a7bc1e94137faf5d65713ced27447307e7d32de846e201487c55ba2b67bc4afff64ccfd3db92dca2e8b823cee498aab13477243d51a49614ed6a55878182c2c4bd53a337d296f287ffa432e3f39c958404d9294d606bbff93fc51dc75b434402eb25a4890b3b42cca19720a4eeece46989ce884b047f611894a274e2a8dc4c7c5a60ba22c42cec780252375996d682f1adffc3e58d93593351cb73cc728369a9f384db282389fa75990f56a3d6e2874a41f16946e96e6297589ae4612fd60ba56a8d885c4713476f44c415db1941899670e52defadfd7db1496ef5de251775961bf7a640690b6ed09143dc8d15cf62bf5af392df6c245d7edcb776fccbcf844f3a9c266836dc9e705e770fd265c21a75ece3ebca29087fc3727527e702f478233718cf3a8f707b4809d9f335a3ddda95dd49b4cf23a23a3c66da44931b55e2a8f49388bd8d5edc96c3e068006656edb6e68792ed411cd5ac67327e2f4a169d77fcc5241011ebc04e0b578fd0da053f68b8f5b12a16bc512ec76f146ce6315827368700430d5521eef2d80b6762cba3900fd8cfd1b342e1d089d3292f4c6aa929d3913b02c817708b19417978b1faa5d661f7bd9e796ec9514263065f1b3d84f269458565f9482a3ac89b06faf9422899c87927d164b72496154bb13def96af269832f057c65373ae0ceea26ff50a77153861acf715badb95aebb545ebce098205be6a140f2fa20ff4fe2c7ae357918ac95188d85002b065e6a77d35b1516875f6b1bfc9a748adae8a4c683ee0fdda7e6a3fbc7f1f7a1c828bfac87567a916427ac956e409cb811282f5defd671d6ad64b38d4b3d815f4919d338c4a3ce36ddc92fb6e3a9e876d6ba4e4e035f1d284acaa5390e1fe1f20d4d33946ab0ccfbab4b28962b836f8ed9281d0addc9971b6923919df1e8611acffa15be84c2d8f221b105491e77d9f85f3897f89432f4a01aaf816b4122628d92ccc0226bd42b40282cc6b2fdde9e341cd1866baf2d7c05cbcaf383c7ce169ab7f64397dba251377bd18a86074dd1255d571a2041875d602eefd217386758926a3565d5e487c20247c3e6c99e2fa64a72f600c0034b70db1a0f2bbe584a19f23404e3e661ab089c3a1528c16086566afe8f4c9f52c5c2670fee7438094d954d5b29cff59b8e79992706b340db8dee35ff5f9fe4444b50e16ea9a795b4bfa2e0f2564ba892b6f7241a2fc5a051e7d292f90fd668ea0b2cfe389f63434cfd356b5caf6184bfd2dfcc18a3477692ba23a36e06923972b1ee5061ca8078941d6f17a8ab2844386e254986fc554549612457182fca778c0199cc780a18581f75ff3ea2027275ef8baaaa7989d2ac738e94b85d3d6acd5160d352e624c8696d92370636c237435eb863c2bc362fec8302a7eed8db11f9ad457ea9e5b818a3adb1e04c5890a0cbb466a31c34e773429b0efa2db6bb8932db4e016ecdc7180607c12b8df094e520d7148aedd2034b9db4352d533947b7a81a8d400559fadb4c8e5db1da845ca8978673710cd4507412a1829ce8442cf839604b38ce02f89e183a7cbe33ac78ca2227a8b342b22cea6fe69af92004e644bbe941dcf7f77fb675a25a688cacaf5c327e727f0173c62c7e15c6916d32675a57f47869f1abe91dbf007da00036623e8fc6bc0550309728af6be801580df4d905a0b2e9822982df96e0b2001df22019db476b0f2379ea134d8a932d4cab00ca8007495e87743d6e5df00b2e1eeecf9934e5f9661e45403472374070f1be51939932064fd15ac995318a6d54c087786b925efd84bdb35e63a3720a430ef2256e3549a8a0a60c9c0903472577a247743676fb70e0522bf04334927f40c450d6325c437fb7efa7b885dc19f7b86fcfdb67752819a8a3bc3ef8657c3949ba7513cd0b32fe246264963a7491c020938ee1ff2532f8f16ace30e0eefcafd03793d8dffc425dbbf8a527b4854cc92c5f4166bd4b106b05eab28820d3ffb23f1c828771bfe1e891239b415843fae8531b11f75f23037f008738934461d4844649e4b4cd17ed9d093e401ba89ba3f7ec62a1cc7b9909669364ff8ab7adbeecc5a8d15ddd0e1cf308d90ade52aefafcb9ab7216f3a6605b60976380c74ffc2c3a9565fb7756298b7baa375b4763f1484ad7b8e710b14b2c1bf3eaf3e9f86008e45de09291e1f1966f7afe6bd7fbc5bc2701db6c9c5776a214f74d5f5f0412775ccf4377678a111b775efcb733ad96844675edf8b2ae9d76005ef110dcb7efe6fe15a1348a96be7b961484b030f04a48f206e6b90357ec5d095d2c6071b7810180f07b53a7d4529374e28fdcf58f6aea4900e339f1fee7f60b7411777324f4b702660a491fd74679850931d99c3f8c1733c65a2f169ba7fbdffc5b2e928a68c594b2d95693b048fa723617b6666e30bc7df5040eb05880efdd24666f6eb6a74bbda4c2a1b76b36bae987161f0604f3197cea3b4c485ada3c01b7d4689feeb32771066809bc0dc5943a2e7881a067612cd6087bfe8042b41104dda42d8904bea9dc3b33fc567f819a3ec10421e2e8170162640dbe83d21163cd898c2ba9f874c64d0522ba1635770f741f530fe4d84a562528abcde8a2b12f1d197e651e7572b6a39c48a2619c74527b646facf0bb1650dd65fcff10b06c0b0892c2541949dd27730e45ec4a3819942c5ba23d9747d671a750fa4efeda9c7d798e814830ac897012522f21ac802ad579e769f4378bf7c698060b896d09df599a24590f8d96838b127421b8b2158a1e0882c9269d6d2a26a5e5d14de7bf1719e11832bd5452ff945d4ac3139dfe3e85ce8fcbdf848fb33ba22c9b5fa7024baf1c26f1e4f23b320577724908787c1a487aa63e9145a29fb8a71bd6b5ab4ac8aad2f634cb2162eceb5a6f4ea520ded4d898a012ea993348134cb929e7a2e8c5e9e0e61ede1c22cb8d24d8a2226722913bccfc78c4762210411bcb87f3b538b492ac91fed8835eebc738ff0ef4da89013ba52f70ed00c85283e8a57f70637f8fd45e4eb6d37abf4e147838a5834f6764ae8964568445f96ba675565e54302ab0c452f387839cf3b028617799be31dbedcd9d32f4dcffc3de1433ea116dd69a87d8414e5c3a648bd611b2bbacef946fc61b49d606cd20b784fe79f3bcebcfd66466434f2f8b3828a9f56ac3d9b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
