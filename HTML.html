<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce0116fe88c0cf07c7ce9cefccf29dc0ab94046aced7bd94632112e3004b3d5e7e08ca70ab92b456ab9d4c51c19727692d32a0a8de6078882c90e4c0e46c1e19c5427fc179d8ff567e6b28f3dadcdc65f1a230fb16ad039896e52a96b28d2266353ebd7b0710ae03647670d8e9d29657c2498149dc778ae14fcc29e61c4ecec6ff34fd9ef314758cfe8f5b86c6b5db7797ac7828d478d2ce763f7aa6baf53fdd6a0960354f3ca05ea8e95e2a9fae71939a3b1b1c6761c17dfd719a32e0506b82143aa6fb288ad9d8ba4d1248d87761ccc004ff248535b374cf8c9d2e4a0f469ee4b7eafab48b2f5c522e0f165798932fe1e3ebcfeeb7634924bdc4cffe9ab61f4723c82b4b49ab6c8c8555daeb0475cb6f01ea706e067b7f56557376e0378803869f56fa78a885ef6c20e5391aa7c5a9b48b5081e6b392660d3b2e3074782eb71a534eef730732dae2ad268a25d87ed11eb96848c28fd60f2bab42f229355f04b230e36bb41e1c1f6517c8f937d476c8607a71e41018f4bf16c6c3f18035747ae708440a03296cfcb991281b89957f3c7f33250c84b9597a1648003d01f894532c13ae3f1a08cf68d84fb48cdee7f3a3fa770aec798ef36d78de824c6b631cbde014bd9adc0c3db4b1852d10d8de813f58cdc853c276bad36ef6b8f2f0c44445815e1833a1d8ef011d17c937213df7d91a21484dfbeeb81aaa26475da94f955e99c1391f75a36e348f2f1bf2f5c6d897133255bc6c919137c8fbbc4a58b27e3ba674d717cba93bf22f85858903c8f3b00cd7062c53e45a9b28bb52b24287cfdc1e557e2272c0f903a12bc12ab577f5705a2ad895ee0bca536387569349c41fc7a2ad841de138129a0dc2c8e4402c5d05f15c73d3e317299797f21c40759d3b10c326cb3abdd16ab5fb54185c902c811f9e0607d5ddf41259f421d4c3bd75227d9c948dd308c423ce442605e7a67e9c44067848f9b199f74709e1afeb005e5be08de33316cc579c8fd19f5392498942c630e9f88ef11683f7d7a8593d3bb98b90e4780c05003bd866b064ccaff4d5ca0d3b45f231003db3e63f6b3eb621884b43727f8d3410b311c62ea93f5364f34aaac806a8bb621946408f2b4d2c12ae79727352b2a5bb331c891b93284152a114ef420e6e220f15dade7b1b02c2fcb19db6ebb0053ef1eee44450b424a2c6a6a1d65108148e09d25a456c37467c11cb53d523769ce1eccc55455b6a2cf61db0602920b6c261fde5882203855229af758d4e8adf4e92eb330666bd1231388ff91bda73e30b0f69365cd84fcf3f6cf8555cb9ba4bc1aff5ec5fab5e9f82aac27a0d11ec37923747ea236ebf12de658562f8ab87611cd10048bd5abb1a2178b622018f4a9ff7f37cb311e2c247cc359585164c9279341de84447e6b5d34e4c3ea55f606ffb34736514ba7e464df343f49a1f842a38db96428863c260a422bdfc124be81f84ea3ac40755ca023e09c3e1ace7fc1f4cdda6684df1b865246fa6fc65eb3f9c6949c39b60120784bb58a1ceb30bde8f5507e530e6cc11150e999baa8be956fcfc6e1737f907535ecd4a649b4011a511ade34234ab07dbe6a814455ff7529efe0b570abab78c996475f5bb44528712ef5b077f504221da4e5e2cbded18dde6c241e4c161112cf9df79b51d7b79ecd3015afe95d16a0651463bda65201e632f6cb9b8bdfa4cc1bcb0206cdb600fa81ea8d6f523d827f9dc6b8d453132d5471006ce48d7085c61ad931c4632ab96054b58b6bea6ce8d8eebd123b7dfb7c3336c21278e7156d342f9c43510aea09506d3d6149b17acb883ecf08c87d18a666e5d3836226395776e7e5870e1b7f3f7dec7e628837ed0ed7e4ebc09b134bcec6e649d94b4556e0b9459ddc654269eb675719986853a4ca7a740ff4e2e698ccab6d080b203db14e28955b792f14fe38938b333361cbd27951233ce648e3b28dfef800d34de6c9bb63d2264a422ae874b09badb13edc5d5cc35f9fa7ec00905014b0db23ccff38f64ea0985890c1091b0b3de864c737d5f409294c37eb1cb36af252111f6eed78ada09b251a02459b2f6e7689b7a6c19ef607b87cd2c16725e61d4dd98e6189939e691e49e31ce21f410b046febf89d0903872983c261530134079c9cc378c087670db250f3f7acd72aaa4c49b94028b9f887538dfc01c5a34c2c8ea7b2463a43e69afa2f71298d208d89b777ea17bab17bbec9692612f407421b1731d3a40879fe9d3cada038d1f83adc7bd1fe2b9ddc4f7049f4e0b43298266db293f1d41c7c67b7f49ee245985557aebe6e409c6cb546596bc7f98f18097123e5aa1bb6fb8e57bfd5b77beedefc86311394b7236ecc36310f7d4d865f76bc7e523b19ee9f8975e25bd4009ebc3f7b05c3b4788d5817c89b0602bcdea2c83bc8f8a4cef2c471988a2ec1da387b8c877216418a936b708c9429ba8b880473bb91b02630b54f33cb0289f7fd910d7dfc6e9d2fc033ed81491526ee94e4b822f21314be201954bfc263e4d19468438b2c2039ea888daf30cc8ce7501c3df5edb15dd8d58b86d75dffa6b77ff97e7d9ae49236aa7646515bec00a88cc1eb3a9546a4523a281a8ff715ab73f8afe8a97774ecad5267993a9f7723d657de6ae147df1b5ace68b353e19ae3894a6c07eab1c0e044bd28faf4249a823142ca1ea52722a3d8284722f9b9302cd0f09578944af632a9c15cc4568a4652d81388ece5fd89b3a6dcc6e9069634dd4b8bf05c2c263f3321d4d395dd1c3abc2e7a5fcd957bd231dbd6643639aeb6c6f6ce0016d257b2be591a461afc9ef82f8a741f4b332e384c29d20eff05fb40f69c174e7fb364ada72b091434253c2d7c2b3ae6950b19b243006d29618920e1082ff24cf2fbca022bcf7de0ca9f789208d84887141310fe6549292e2e9c1df33619bcbdea3a831cd9ba330a1c9c5f75f10a4c1e3358dbf00539ee2042d7aba1e356abef8ea3b0d101e41e28860f36c5f74e45c85a023fe2fae5610e58e474d3cafe6df175e78a84736e3f722fcada67a192e6397fc8162a1233f44e3c033998130f5577d5167cde95f9b466b1d7d49fa63bfed0bfdb03bfc34c7bb0c4bbc5aa77c7cbc1e915799f62b9cd0c0790aa409edc617e6902a9f75a6df6632b5bdc2f92213d3499068d2296b9cdfd54f311ff3e0a64a2ccdc2ee63b45b9b485afbb828f61f8f2cf7e8a0b2e839dfe7f7a4c502d5904542c1e2862b0895edb6613711c1bb454029a7d935b44db9ddcf72aa60e1826cbb824cdb8380fb076ffd988c1a941723737156dc83d32b00b7596e6774900dc262cd0e6030cc6fa3d37acfe4a77409eecc7ca36ac12145a4ad94e57a8918ccaab440a1ea473358139dffbb72629db06feeb48d5cd36689dc4ed29df509052488a9db172e2e7ae863bc6daf90f2c3fc7b8b7703d439297832ab2906877ded317c9eda958026d6829adc569817056947ad183f9bf51c82f0dd5306ae015f36e2287ccef775413cf5bd7f83db53e360b0b5045a4ef10d566ea800c96c1f277e809ec667f05f8eb9876dbfc5da1dec4be72203c558923c2cfe17ef95d362b4f8215ada87e3cb247615c8a20bff6bd7648f76e9ad66f6ab8e548d90b10f0dbd1f4837eeceadda73b22074ad47bcc3dcbb2fb4ba753faaaf59839ea0734dd5eed6aa032566ef49a7b1513b2b1576486de7f21bd5a0c299eab8c30a4f584cee18da87b10b88cff1cfc39dcd0b8b124add18d43d77c9bdaec8e70838306993752befce4cc1a7109efbda6a4931c47ebe4b818c02f752ec57cebaa18dedd863579f51acbde34d1e92fcc5c30ffd0862fad95003ea087b4e6552111ac936aeba887a4d5c961e89a814f5a4adf12599ff8d621d37157bc4d1e577fb38c4f87468a1dd841366795a512fdff05f5d3c24e194f39393a5dba8beae5ce1add9773fc85cebd188574cde9f7e6dc31d0665044df3a67d07ed63854771e6b998fbc026fcc939cdd9e08d35ace0281c009f1a676645b3d7ce44434380a8e709aec1f40250731f3eacbd93649831af83eccfc5a506e8720130d2bb4230d41f52a493eec816d8e77185058c078b88642f1ac230a5fc48aced2135b81ca9b31be79db9e9c74f73977b7c8af1bf5bb86032f2212e600a5ff623680180407b2e3ca99b26edc7423e1d6579e1444eb56c48fd86792d36154f67d06822b9c276f0a693018f95c1744179817079e65e8f29895d10141ee3e31c5cc1442c3289b34a9b1b4b4c15e977cf7efe0a5a7b6d9494710906b4d64b1d9b7e4bd70330f8c719ffd4c8fec33fb3d9f1298e8bfc559b85bbd7859861f94db8c0e4873c24de3f354c78691233469201a63d45e3f57fe0ef2f1dbd81570d232f60150c66495de0741760154c15e60bb2fb2981f3d77aa4b6df7306f263433eee0c6d072e271466d9cd21814a240ecbd59e3e28a7cb0b00caa582a4aa4ab0083c1187ed14c9c70766e949ff18953404e1c7b39bc4d19a2f8e0f61950cc008497203ad92489c737acfc79f213b560dba2ded0f3de25a8b3341f4bb1ae4323e1c76d947f3e11a4a7ac8ab1f5b26cbe4b7a875e03826e9285b5384852f66f7c5ba59cdc8856849c4a54c7fe28502c490df577e7aa792f853548f1bac984b868613a3f7e51b6e2d2be95b26268f8e99d49f7e1d043a0125956a9ec9e5f048030a4cab20dbf8f2dfec12cafcc16a9ad2bac6cf5e7ab39536f2c531b7901bd5786c31ea4eba11d12588c0a1073e6b1df03b669cf0019143e7a18087a926dfbf745aefc35531444872daf8f3ca1699105415e27b7995614a09720ffe90b8b3ae7dd6469c904b5f9a6a8882c8c315d3d179853f747960c40d5bf9ede33ce4f214b3ac5c6810e92365f6caf3a7e96722d2e2cecb407acb9cb11a5bd03362450ed20e52cdbd1b1cda293cabb4fbede70fe5aae0343dd9d6ba3bd36d912561efc0ec336389b65b0036283380e8fcab0974949e82240f164b636700fe30f11f89d99723cb32eb1b6d5b6b40ce08111a258a8270a68d4f2744fdc30dc0eec1e8ee64450e0e0e721961dcce97307d5714614b0c41ca44f787788934ecf24dc6eba06e65ab06fe945ed5892086eb9a8d0c86b051fc5fc740abe43e205a91760c20e0cd29312acdd29e871768f53899f0b9864ffaee382870d42795da4ac4a8f961bde0db73346829cedc000bd349468ecc92feba7c9fc0b2df56dd3b11ad818ec47d3afbbbc1f438067145a8b256ec59e6e74b72a35362ff08f8358135594ed23eb3097560be2e8381bfeb0a8891be7aff1848cb360e17d29b719aba2f5d01dee6ff7dfe3a933f68c4e4dea9f10a1c3fa49483f42ce2d0e0dabde1d2189d22d1992f0617107a835635107798286e026fba6b8d2abbe11e759b4691fd0c45067c4ce1cad7c21c709601263e1560314cb8d37720318484ef91c4e59c6915ad1823079433b1fce1c89b4eae0bb690c695b68b614705dd544edc48840ac3136cb3c7c9d73c246ec4d521f7a8b1aa795e1f1b27b92a47e3ae1c3adb923e849e03b955c9d2d66d289e6e653715a5ffc4563c15cb731ccd96330095742c149d8559a7b7c374deeb0c919106e286340ea3b1efb283b3f9b28328dafd29418e989cb5529a86a084bf82a7c4e9230bdcc6b14488ea079ee8ddf17bcb71f98e124224dc6b769250a4f2b226331a0ad4e3914b4ea118fbb6c6ea737347c1c22c574a73e1564e0dada9866792b82b53267b631d2edca42929f26acfd9faed01bceece6b2661f0ed07ee70837e01062f9fc89070a94727c09334082c35f0188aac4222f4173f9b9bf36a55d1db4ac90a0542a170c2ea949d7b0c9d48fa5f5d9592a2e65d1cd99d5bcc485427757dfd72cd2d51b7a0fb769cf79ac2c9b8f39b59385d88a6f238c042c0d7fae9fd7fc106070008f307cea30361d9bdbcfe788e280d059eecf713973471e584ba2598170098d3bd7fb39b738aa2520118a5f76c0146ac37d8901f757890f8141c79bcb89b6976e5c55dd5109e82f255f67b67d51685e98c03578fe69a796c835f4c64daabceb3308da0432cde2d381d3c6ef1bbbb56ac685f4809d8be42fe773690d6e3559c14c5b69cee61716754910b29b6bd90534feb99fbd0dc1652f9d47fad823cfa787614c2d64a0a3f5afc5cf3751650644a624838dcfcb505226c666df47111945d674895cca815faf0d562ee2a9a4d0141ef0e4bba62a9e1a1e1242d7248df0102d5d77b1fc3b4cd81b5696500d3132d5d95eb131522c4ab56f49c530674302a3c80e258d9c6c98279f398ba5a08cf3aab1ae3c05da8cf4e34087c2fb3eb44be118497bed0b2cc63b6e6c89f00d06acd8feeb6fb540fda7ef462aa9a2e331260b3fefb213f1e16844f256102547c645240fb01f0f608ea110e35cc834cd7a103725f3b908477ee33a94a5d74d54b1ded9bcc5f3438b2ee93ee6eb66d6ec95a5f3004801f0f920d872585d84768e5aa3ae2b610df3f71f0bd7fc728c6aca75cfc09f798dd7ef722c801a8164cf95887f5b4448936989b61dd4c3dcbea737a81208809f0f299f34143d0a25a5428321ccd5d9e49a917b4cdfd53f019261f5a02043dba9cb92b361745a6b517fcb06d3ca873d29e1a60093888986b59552f42aabaf42e96acc950ddd49aaee92d2cac3697f28b124cf84f94a1717c28b62dd177b8fd50aaa3b4980f19d9f6caecbbb64117d118169666811370225e4fdc04892d16c33d9117f87a61903241d7c856cf0e4f471e30d14ab0fd5b956a8d5d054dc18120178c35c42d72a6e8d2a09fda8250c25a97ec0300a7cd06bf0ea6741d03b4a9408a94ca2a45166561e469b9582aa1b48e6fd82fdf6245c5206904c4fd76a34206ebdaefa4494b88aa89c5bb160536ae808fbc3a2bed846f10459323272b6204b717b18bf4bec8520349d635950b16321c11d2f1b0c8acfb07ed14d50fe3e4cad0eab959d99695f3a305ef6579db3d8e02712e55a908a4e7f3e0adc5e64ad365b6adf2655a0ec9a244d0f61e5273530f896efd205bc4535a0340faf62ff529df3af21dc94d63da077fb48c7fed17bf962ecbc76791056ad5b137bed9ac22ea09bc2ee1adb136f8f0201ca66dbc76f599e359cb5e3b4ae4a99a4fc09ed14ba93996d81c7b7053a64f11bddd57f69440f8a6b5e0b5d8a5829e56aeb93774b3012614a468e099f88810cd42aed304a740c41406591c3f8174a863d2c48a4038094f84f8dad4b950f7cedbbb4dea477689f125871fb134b44abbaae9bd72691a0284ff718061cea73700851be7408c460d243f7b9247d9e18975ae560c5c5362bcd350027471b5b7f0541a44616cf942c0dde0fcfdbda3e910471a7e841e86bca765b16c7eaa70252a0913a6d8bfc70b371c160a460506af264bf3e4e3590874d6d1c398f866120aba73cef4f619e5a1f757e0373013b834f06d00b550323017b807aa4d2ce8594f15f3d40c0a487ed3ba82aac457b33176cbc0717bc63d6c2c8b919c8703defc010bcb15aa0bc245386a3fed4334e8031f34c5b830197f29fde5bb9aa8dd04581e2011f7e5cfd3012b814ee2de383a445b87db6e76336a4f0ced5c9f8348ad2106c63e9ce36ae6a3b2e25ad6dddfed6e60f3ec0268f4cfa379b92d1492d57e4ee3968c503eb79df2383eb5eb639961fe124f6ddcd4d2ece23a41d3cb63a6225069f39f7d5286121d479ccba25fbb1ce4756409f74fa61b0c1dad90b774304645d92c46b6c88dd07f257e079727a95624c0379b3615e9a55668cdae05a6e9fb93fa217f0a9f0b1b1610ab8b0dc15d05fe549992fbc920a808b083c5105c4be806373f229f042dabd3875ccdf0f55cb0b70178c27b73a37ec0e32e5c7a2111e26110546ceb84b76accb3f311cb4f4e9541c1f02a56937252d6b23c80fbb527e71c9ee9e5726c4939790a58bce375042cdd5b9f2b77c28d2d64a077da65b9f68523c4bd67d183d42cae2c0bc972c84f6ce1c3656f660b7dbf8ff6602ab91e5a604cdace26f291aa453b3997e3021ba295ff24428c19ea5445cc31cb03f3f0cf9bd0366f3b33ea95117e6130ecf30def606e848bf1af5c09ce4d8d5dcd00549f43a6f4e032305e7cdc63eb118f98f5b29fd591757fccd2053d042456db086aa686db282a08654e6c458e3764a61894e0045ba35e7309319da275a4b142561289f0cbe6492375689811783e03575d2867bec0029009e6a76ad12f8d96212990013e9ae21f65316f794e4aa69211250483a8c0f2a5c6e7ce07574598a6e1c9ea733dff2bbe7873ab2f4e4fd2a54177e308405eb70d171b5ebf8a65dff7be1511b15aa177b70bb4aad015a7f03148b6d01d992b112d2141e3080756e6fce2ce7a8f5c1b08720261b43d79bb81d1002b2d158d50b8f8752612feb6cc8bf8b63331c2dd26edaa68b8378c8fc1d9f00ec63e1f5eb27a0ef01b5085899e1c9ae750f85ddac67c1a2bf609647fa2e3dfa568830b3d1a21de730583690dae0c47773a5507357b6c45a13c271fb13df264af75ccc93dafcc46711a87ba9072cd00beac732b95f893b96d88ac268cdda30fb98a297c10a5b4db104e68d8cef3b195e9d07a3a0cc619469cf50a43a810fa60c01b486fcc2d39dbb9ab1fe53e53a3b1bf331b9aaeb6432dd5a47333edc4723b2dde7ed83b2b436819b27179cab6161191a14c02fde81a381cccb5138c66e160497c679cd8e6bcb18ed0265011e9d8cc8dcda8c47a2262163a24f34ada0f1670e06c734133069777a2f110857c92b5b1462cfed3515826e003dd412f97a7383d09624030c4c2947151a0c9a2c7f71ed0c1dc87416dfde8c276f2f63a72a70a2673797d9b3478d8603e7bafeff75d442500f991a5f6c3c1e417386972c2d3a05dc73a8f729e55fc08ae9ef4ce2181b17a6581571486f02180dc173dcd5c01b595b40133b86afb73f93dafbf1ef075a6edf3b7ce209b35a094d8930942c195593598b9a93c972cf33479c5d087008e812c1abb169b2408f1231da7856b80456394938953134f8c82b7d7658b6efa57bc3aa7a4fc06f1644e88fbca919d89c2c798540c8026d34fd12fd8af6167e25598e462e17d0921bfdb4f6fe781711e9f8990735f3a68d7a4b695e0a9d0c7aed6f2f30f78bc1612709a6c9d2bb2661648c513cb4afe2473b18bea158fdf03423ada41b1bec3237c02256a320dcc953dc6273a1f369735f9ec1b64d7ea5ff01086c7b300b3e9066f617088d8e8492767c5e6c08a498569f0371ba65f4798b5bdc7f4dd441633ac746a6250f5f9749c70836bd5c2d884b211ee97c508837c883658baf6b32b8a361db634f54797bc3b67e53af143faca1c6ecf9ff9291a3aeef3c16ba4c6b327e7669091099ac6e01ba7b6bcac00962140b48d618f0a8d1586ce814ecc5e81db3cd3af218c5757b492cc23842cb277fc94db0dced17ca0263ef55018184f2380ce1763ad41bc1ae7fca0fa0a4ea84e35bc16ed51ce050f750c401594ebd5748a8b1967ab8a111e394494f354b39b33d30340bb05906d0c706d8e914843900dce46353d19a55f21b404a803cf134ec473d4276394ddd9a0098308b810c38aa5a3270920cf8ff0b987df60eb99194615922226f9a99603bbd46c0d69b0aca9db956a432766fd8e90df45a7ecc0fa2d64b178e49d5c7574687f578413f5a6827e4b811ee1a94857bf63d5b02b42de598190be74e980014f853f111d71ae3bda4e0b14d345ddce26aad4afb4758c7af9318b6c28f0193d3063d940eda5f83c644460b571b4f1448be4b22556d36686075a9e9238162f761b6190eabfb3e8047ee09976b1fb3fa3027aa1aa66dd664f0fa6efad0b7226ace072fa0a331fcc58aa880f6ce8f3ff017b0d5f59482480482effca793e6a0ff37d4691057c9acf5888e6eec223bd01007ebebfef4ce69140d37eab05331e4350f57b1e0d79395fd40845a3336092d93f76eb80bea2af87f4be3954212e851809436339ed5ac8b448d0d6ae46f3614f4441aaf476efb8466ffb66ec450a83fa7133cf6d60e845af58429069c1ddaad85f3dd3951f1cf748cd530f249ed31b4a5751a7076bc40ea9a49f034ca1c5d528787c5084640a144ac7485e969b0c7b82b3e5daa414c74a807436fb87d5ce64a98dd6b31b675a9e4d314ee4df3d70cfa9c39530df9f85aa64dae9f9ccc7b0fcb7007961a71ee0c0d7aa194e081d7714a98af4f6e123b6815977dd811a0da65d4538908b050c9bd9a1f1dcc034d9204edbcaa40d60bda824aec4f0d663acc39a1bb4e5aa91cb1ed051fb074b4f7f00c1f3734c2e024559f4c0b2557706060baad95a638f16fdc63ae98dc0d003de5e4cfdd15c9d890860617a2134720de28c7116ea01056c7db6322b7f2a5c9ab2c76434c72131f51a1e475a01bb28ac13ebf6c7f32c3020c2df9307847c1027c650910195f8b0761b9f46e545e750c2a17b81376a7eb868de5bbba4c8dfe155a4642b2d18d6cb7397155b39769a6097c71d022fcc160ba5045dd87763231fb3f48e24ad2edd607f1996173a7c3be7c6d8d7284e63d959f138fa50b3a4774a5e740797daf97d22be4196f0ce51e8d403aef2872ab01c12067c4b7f1513205bfa5c67413e03fc37b14044e47dee1180aa4d39f561ccc6c13b4f77ff493863d5c7f473c5bedab9748c29dc88bc8d26f4037a8d3c0c8d42536462b9edc2b7a2156fa672eb179f27ad3a7dbf94a1d6488b7e202f30e652400659f702b8b4be3d21b72fd8889e90ee4f092bbb222b20c9bb0f174a5103edd105726f7e2aa28e5e4ba3263490cf1975eeb0f45a35910c5c69f5e1c5bc11aa363e9739de974ba688cde2ed8c3ea7ec925753442f8a61a10d0cb7ba33acf5fb6f33f80d2938e628f8172d2905a6af489c1572f36dca3a4cbf8757a91b6f1e87a140ccf465cf20509e5abc477b59fbbc434f26c47cd060c6bfc675476da935411de31900792c2acbb66ea0074c57eecb29101681ce5b9278682663e9b8f54e0a32aaf020e56da37c2b4ef014781cd19ccca6690b553fbb7f660933d0fadd1817b2b849e2aa210012a892d7d6049fd91847f382e1e4025b8351555bc5b3f3096b23154d68cfe249f368dbaf72dcc046ec601900bb1729cd968926765fb39b745e24fc9190c3badc8dc2547045432eb49a07c35e33350f17dc728c35b4653903a0e96fffd71cd9f63870663ab4994306c59029865d2effd1bb07b5e80a41d1bf26631c61c430939e77d3564039464c6574e8a6e37a85a82bf35df3d3cc8d0ac0bd33a95bede0a51656962277e734370cc29e43d26b664db0311fd6101d259fe3cd5cb1c2327ceacca09ef9d88477a97182854107738e132cea81e6a8b6f254833bc8dc5846fb9caf725630749b83f7bcb61c30540935b5e5280df83884760e886a01479028750a2fb318b57a28f2a3846cf14e285cd1bbfc0b657fd657f7daa0174a2567b9989affa819a12a167fecd3fd083dcd15bb05e6575b638c10f21c9967dbb4227d6d4afdf6a19a415362f275b83b722e7c29ebf9a8e354482a6ee30c9121d4697b7aeba306fdd07c1935e5af240352e232de7d482c5b794bacd1486a9b1d19b70e44514c84ffbe08ff0fe83fd7535c760d4789c1eb57cc3a6835c72cc13bde2e91a59c53a9d350e219a4e6ea84f69c1cee04e9c65d1be7b7eb965fe7999f568402020fb32e53cc46a735d7d8b6b313d1b8ea53007a8d96521d5b852fb48eed0c4745798c13ab13e55dd502267b482a48f8321237f6c5bcbf28e7c92fd00092d10f84cdcc3a0306523f90defc011ac1351d59f8d3100e85b8952ceac6702e5372913ff71466fedfb3418b8a89bfb06a402ded3f13649bcea148183fc12c036de3db4a74d3f44ab167b26ecb5f52785da046bd5fcc988b00de898305911abb93dca135a5c9da6dee8aaaf44249476fdd07ddaad39fb04411c1a0b38c17c0f51d5871799b94b234d48ccfbc3643d9d7a8b4c078654c26ae2af0b67cd28a724560999eac5934f9f9c7e5a2dfd38887536986ee393c145ad08aa2869cde3f47d4312ec3b64f875f0d07f7e12c7d9eeb21fd5d6ebf275a6cea2b17890b07692d0a25d7d0af994a7fa5b7dedc2db3f81cf5cf03ab200f5419932ebf939f4248e2f5b482bdb85fdab6f71b41de325e453c53fd75e0333d054cfb3db3eec4a16c8299cd4223034e060b66d9ae7c5cc3e21288e38cb86736b71ad70ba367bab8807b32ffe571d0caa8d84bff8bd67deaa57420dc232ff0365adeaac2c7f36c4eca3596badfeb1b19158af6bb9f1a1202389d3de5dd4723d0aa2e20d8cd6bc689f588f474eab63786a075c6b2e8381aaae9b15b10e07027e1d7842dc86dffb460882e7b121fa959a0d275c5eb6c0e4e23ccd05974dc7a39073bb13bda3f7efe140ae66d53f478dd461d74566de477901268ee71a8baef2ee355d4a5067fd4a2889dd5002faf38d476aa62d358762cc45a93964675ae69f8d454f802ddf48823dc831148f00dfd97a2aec8cdf3377293ed5640803e81d88df1ac1750f2528690b3a4d870879bfb464ba98558bde83eea77a977320640d9144110f4ab6ebfa62e140693ab9de0f771a5862440a135bca2bc3f2c4de4b9a52e5e35190a40afb986090f8c287e102b35d0c5e7c4202f8a442638014b2414dee31990c73a14241faa1126a2e75b2f898a0a0eaf7ea3fcbc02578c377c78f0ec9b590b8e396e814c38fad7bb054603bb81e4fe2ba23cdee702b97700cdce3564171c2bab6a764bfd91b3cf6f888b2956236ddf2ffd57d920289936931c849a6f58f2307ba67a4cd3b798862ee440f35fcaaba1968b0977cb39cf73ef193f2e40dd492e8bf1c0de215498ecbfc20cb04e0642734c8a1a6b060602643b805ee7744f2639d00f5cb21a27e510ca266e1ee8fda4b358646f42784d343af8053937a9e126bfc4f41ad2b33733dc0efb40a409a66b2a177e87a9be04064f7e6ad61fc52d58149c668a2c18444a1da57fbbd35ea3989d6168bc3500e7dc71a1f3e692ada1780b9558e56c20f15897b5bb20905800a72c3eb3031630e1c81e4fa20721e30df44e3c110925aa30dc486eb4cfcc8d77298790c90510c9a81bfb9d18a4a6b1c57b6fbf7c3760d5705cef246db2690c6f5df532e48a0878dea0b97657babd676fbb90b7d3ee74bca6637de5c2c66f19d45a11f37a9ef424603e9fd09a643c2158524ec8e657001b51390a1fb71a00cca359616a302afee8690ab3369d0a16c97b752a49e33da09cb878b79fa0ccd1ca4e7da80caca0602332014edd778817c49ce0c92b2656acca20d84f5b61eff8ef64e8e90a12ed78b2230f95ad57ca9cb64e08dea2b09f8ddad5a81222265ca483c9dcc9444f1e0b8f30ee08409f2dd6e0f421b47525495d050d1bb4c7c2d8bce90aab1b31f92d4064db39932ed8b1ca7b5b81201a6f61ea35b7480ffc6958f04fb664fdc2529f30c25f50822c1762fbfab9a2fb0cfcb0da739868c4a60f8ccb3c0c066864b93817ba0627b299c9c7d99d725b07a4b4f37e3e5808f1a705ab1cc46cb81bb76dab26b010b16d0d838fd6b45095a65e35119ba4c8c3f3271205ec1a93cb5436fb72e21e4537e76be01a5ad9e2fd3f78b449ceedf9aeb3bf645620c5c42c2de5be3e196d384318fcf6da02d877ca3c882846ad9cec106ef436e748e6a43989919e3325a197f558098bda57a75059cffb9a026ab04f1bfce69893de581c83a8a30e3412ec975737c49ec8928df91ebcca8389d5fd5ddd12fe63d572e42ec43e2696353d25d0b3eb75608d60b7161113a4236d29bb24ecc5d08fa3db0fd7bc73efb09d0c6f3f6261db40db826b0af5c7ffb4dff6fdd0f22bb0cdc287b2adac25bf414c7a9e0671e918caed7beec3d976b4a84f5969db7bee6d5bfd11b4554d3c3ad9c680bfdf8b8f06335a0ae771a3e012fe1d150f6f63d02f145c1d631b97be6b351e3b8eff70a1fd75e4bbc61972d514c780624fd8c0c96625c61ddb25b8514a1529bc3d27f12a3b9d72de0c2c38414a9175cbbf651756d7240b332db43ac9a525e9a0d13af715cff377b00d177a36d008e94788e2716f4fe54c664777e32c93913ca6cd9687e27cacedbfef8af6f189d19cd044c7afa2957be3faddbe8d2805d706c67bd6711cb586cddcfea1dc6ed05a6a6c16d2c090485e31fc8cbc1eb8376d7067edded5db0255395818d05ec78b8eb080e9a24b1e2fb5614a75c59ec1fee1ca4ce159e1af1139939f6756cb5fee01398f57f38855eaa30ba17dc3856b41d45b114f64315ff39ddf92ce9d6a38b1e18abb005b5946a73e726fa670afe486c03fb691b119d4995e659b27f355132445d88cd5e509ef0781308db6eff6c50346c27b8c2c81a720c98047a913e384e194776a15b08f8dc993ecb8f63178e5e19e6df646f4a3451f00d11f32eb16581e0e0fb6ac7a0127406f0d4b4ce3c11eb6cf4791d5d65632c3e6a09805853238768da62eaff0760a1a240fd1681d3276ab7949bd018ad5f04a93fc38bdd3792e7321eb53d874fc6db83d073d05ca35f9bb49b3cf9db7095296b18107c4f60872a622c8fd6467fe1400037b0c36a4ceca2f7fb4d528144abf0b44b6f526725139e12cde717a1a08bfe35d161e56c67bc408d98cfa0e12d0979994569ab66c81da478f67fc3d85940ab5ad007b0a0c6bb4e3de510b3e438fa05c5ab2c175dc56a2ba06ffa9ac45e5c5334c16544779cfe6311292a11705453afeeb02b298e42a54d38f4e5cd43a0c6723758033fecb6db1ac7661a56c773fa480ca9a4861d6875990a450cc47f97aeb69b2fb720f14f3591defb631f0dc9893a862aac805f81814864b37e0086e3adad08a76dda55ed16603d6db3c96557e9b338def54f146fb9f35cce1bde8e16ce53b5c42db7907fa6854cc30aa530067018db01e8bd754384fc9dcd2985759bb901013a36cd2813c545b09b86288fcfd97df5ee96c8332a2496cd98304d2992683738a0f6a7ce80f576d9f03e1058417c08725b251c1a37aff2efce435beda6f98e0bc4c32d384f27c32aa2f7112594d55a10e2016bd083831055aa63a5e6c45b37f91bceb1b567730668a6995132374ec923b7feac6e56546934bdc4a3eb9e5d4d4d3cee81351d82ef1678c6cbfc254221945f1e63be52d4aafbf16098f5761f5e459d5d8b583b32482a46174da56f6d2691cbb3187df3f8d3ad9b5c5729136aa299d9cfb5f1cfefac516bc7e3543836bdbf2ad49ed903512234f6f4f4dc552a447e13ac716adda4f789b4f6b606d0beb751e9e8e5daf2c82ee860f265f7822b86719beda7ecf7fc14d11e0a04fcd886c2ad269ab5b1a927e9cddfb59b7333afcf448e96daf3e1144de59b095128be30df17f4082210281508fe5c6bc851465566af165c7f0580bb99bb5e77d2429467a332ff020e19da66e556a7f49b13167369e56712c251be1834fe1d30a35ea7eacd91628df88d79ef2d24edeb8decb40f5fa3150b4f31359a9375417949e09b22910ccf6e0cb43200ec451eb5218a5a3e58b46ed5a96a3a4db0e4a6df88a752bbddb06946f7418cbaaa784433ad503a80cfdc73f426b44279ac59fd811870c48f661c184b61a72b8c8eaefde1cd449baab21bd4cf53c29d98d33fa3efe7efe5e0c26ecc77b68d5b88e4f627ed05ff0769e4dfbb8b046bb25cdaf753632214a8c6db65de4deebb62dcdcd1c4660877d5f080f41a0943a6f9b5c3ffd2690216999111c7bc779f17097443cccbbd81f51607e310006d8e42e0c2fb5c76f9c85d5eef24129207e724b27a77bcfec45e6568670a5c9e0881fd0acc6b730ba7e66aa81656a7caca6bf1c220d231b41f80b9d31c8435236d8fdaeb41383d7ac11a6f9dfd6fa34cff56f150e6bd2d38466203d03edb452441c7dd012eab3388f987570cd47cf8c18c0b34de02bd750af320f8d475434f47d547441c02db68258b3ca124c137b5306e1029e61c382dbf12da88592beb40e65cdccc5eff243aaf963fc98080d47e3128967efd5c9d84fa54afe22b0a4a43268c33585d5b0d72050576629c3323a6baee5751324e869e70e61f6d1eb90fd8ae8aaf736314426119f0ed49fb8c0ca2a7892a2eb4eac12da3324484d21946a9e83d0b15003955445bc0db029c6cb4fef58d5e685b31263185f228a4388dfa4093b4a1ebc4d4a3cfeba0f4e00cbf335a26be63bd6d1d548b889203472d774c5fa8d0229cd03c2422b2f12b6108e24e05a2bf5dc8a692d57b404ceca2be9ac6d8435d5ca5165f1a81984acc26f26ca1ab1f487239a5d14482721ea18f029f830f687471259eefbcb6792a4a6b59f9b981c220224a39e872cfa46481dbf97653c780cbd39af1f3e917c960003c5f32eef5dc066652db50fb3b0609f3d614f5910732979e9f6bf1593834cc19f2c428af7a92646fc72408e5c6aacd6a906f5b595e257c5d3e46ebbbb369b4454149f61265b7baf862d00a790a1b3b591bfb1d95a2ee7b9ee49be88a6a91ce3405d1ad18b4a783bd45541a2e4ad9bdff1401aab9611ab5e636131cb07adb86498b360086dead2c50de3ef1c410b00354c7814b5194cf7f4a4c1673b7c8ff702a4c77aeb1ff6b08d971118378da63ede7fe61910a5a4a18c71c4ed6c586ee437b89b3bf8a3050d3f0bb27cf9c2f81096b89a827893281dac2207878ad3be425262be277db5b8e5916edf93e9d25ce9583249d5d0770ccf8274e567fe59925a23343b66c0a8f6c12e7177fb328ce508a944c8b6a6bce3f2f396c9d0bf480bd542ef0c8773a1705f836bc9271f9f3e77e159182edc3e0fb9bfc468c4a77f31291ec7cccd16c0c5ed7c337c3cb5bff190ca3c360e3fc7005ce36e316327bd987607f0de2afba5dac2af5468a0d1fadf8c07d3bd10d7995553fb0b4e7555023dd4530ca889e78887c320b2f00fa475ce0ab21d07a2c24bbbe173c97c2729af3724eb8932cb3e4d5b0ed6bf6c753d8cefb31b4921bcccad277215cf8a644750e63b6f4008ec63e8046d3d7829f56214d10e56cebad6a15d5dfba09850a68471beb38309588d0797c2104e626ff43f8087aab08c4b2564f8f1db739641aced6c93371bb14544c6bbac93e35ab61fb01dd2af7a4ae2032c8fd97b0e7e7692aed6019a0402ece7a29a1a32f0b693a8e34d837ae56fe4469579f0ea5920c8ece3005280c6043dc8837b3fb20b9c78062c961775565c8d7dfc31ae955f107588582330d009f31fde40d95d37d10bca5540de52f4d9ef1c8e49bb0e320827f2e823ddc74650708c986f1a6f1d433d1278c3c84008399ee4074282a549629a54e837771f27f5ec66da0bf138b8622026b8291bd8cc66f6a817283a107ede491e20dbd3315d39bac3fcdab035840aea683088df852b467fad685cf62b89e11e55fec6afa0317bd3a980bd0d2e0553ece050ad16501ac8c6d9787130a5c4e2e096b775e554c305a37453fbe7793667a8a5e5cf6be423e92e3c860ce405ffd576cadda63b7689a8f556461e1fc46a1b61f6b74806d614f668065483d8962f1dbaa52184eb6def03110a9c8cf5691ee18748fb9a37fdf96dd5c3ac39f914e2773e31a7424b4f225402b24fa6b1e6075d4a8542e59676e73d250b212798b4d749a3edb79ad3fffbecca8c8a2a416d11f39765b2b582202a40f21729984578d3810968860b8e7a3df4639fbdb098f10a9df04f3a1a64311e071f76424476114df68a97d6e4fa9e0382b98d37adef619f3bb0ebd6a489783a2084dc5adcdd83661b6d63a45f6049d5832e4dd25c870094a449c06b561afde72f4ea56b23e9754fd23223d39989e3566045041869e0d424dcb196672fec9044f29ae100dc1b8e96334af0137b73e23304d1688c1cc2b8b3be6232fc98c76214508ef32a60d1b9648608929c88142a9aaaa1e7915cae89d49b5ca3a06ff130a493bb911663801bc185758c7dcdc2c25966083f2f04add6c24d51fab76b1733ac9a7833c99fa354058caa330dc1cd9b9499379795ba7de2edae45adf015be764381775e74e4cbb82970e69715a964f7aaf2b4542903b2b458b1bbf274524e1bed95b7f90030d21eadb4798a882576a9bc98fd98a34785c2452c4976a7a74125774176391ec79661ed150c1793ba6f9d951e33d1b476fe2babb3cfc3dfb389ecfb90564ae30398f41866500ba9be7dc135bbf2d3e284cb173a608e29a83b76e062e533e380c547e72a5156265661ea24837a568ba832c5be8165e6f6c3ad056569bc356a601278502131f45bb8c16f329709231f5009023252925fcf73c337aa679e2d642e01142794f925bf9b003957613bf2a780b66cff00ab0b42ad2d276c69b8ec5f87c57dae6ecbd84373752312210688b3ce96154d86ed31942f29d5e87d035d1ee01661ae2dae5eef0f5afbfccbb2686911fc9c245182c22b520bdd50ad06763169503ad1a75f9bb72dda0d0e835e1697a0eb887eb46cac1742b21cc74888993297b034ccb12361f6bb9dd0c6d15bbad7faa01f2bcdc44646540168bcbe0826c36558d27247d50157a0d14524470ae1ec46183a34f8b2d051ff88ef80f729e6243894f36b72f88b7f9cd913cc5cc9e1470a841a9376c0a077f1cb12e9356a60b6137006fb8847649f55b47a3f6d94bb4d1f966653f13bab200164fca9ea24dc30b8952cbdc9d8415d68ae0f96460a4e7c374b0ab1b1573b99b787d5cd6e7d6b542bb8777a655ac7326f841b1a7369745bd8f19033c2433bff50dedb86a8b125020a04694295827c2111f9bb293ded084a509a4bc311dca92e9f43d37d923ba1b1575bb9f3a2db736d20893c616d8b8e77b333d36818791e22393b7a874e859af474b6c3fbda6a1a92f9a16d7d92d85596038e6005ba6fb531522520d70ef03892a514612656c3a4f49ff888d9d1c7f832af73d1e42129c4cda60508428a0e4e20e174aa15c78b8f48b3a1902e1c0c05f40c6806d271c683625bff18be6863678773ccd8e8e5746b050dfe7896c84d9d49578134d2c765e68d8828e361b609b1adb065e7d6b050429784e8bb07403601249dd20582f571d2cd78e731dd497c870b34d901645d554e055f21b3c3d92eb34470c1692d01ce7370dffdfeeb399837544e985c8974dcb3dc1ffe66fdf4a0451b59b5e1ac791b8b8c94e9ee6218d20a6c83f267f45f5bd05a2b1fcbfe3def0358f8238976e729106fd9b80021735991b638603060442bfe68dabea48f581e499c38df66afacc78e54a432badbdd606fc7d117de044bca1e90d428a44b6a5f66efd72dc9bc5b41b44b820885662c7ca50b46ef3a257e3a955f0d4263c6c996fa69e287ee9369acfb0982f0f76eae8eeaa946409b7700cdb9a997c03cb8ba6b77e978e9c592633a10ae8d82a54010fbcacd42f250822db0ea467473051887071c79aeac2113288eb0f5e4683de2b8f83fedecd78b76674b3b814959299888c420f1d027ad6988c0edcd46bec0bede868b4dafed8a0952329d858fd378aac7df17b5095f86887b959a37cc363d74146667b8f14f0c0fd8822bd735680f0adcd2c62d6c285578fe9de66551178c3f7cdf89ec534837ba0fbd0b046d078ee1b636d633820266bfbdfef4402d7fd03b99cb2e404340277248d866f6e420dee91cfabc9c2589ed2506d032ac28b7edd8e945554d75c11adf148162ef90697bffb0f3da924b94842d7cfc5aee3b24a6ea0101c33daff6f2b2f667e10bde8e955f194f38f3d7a26527275221392872c8a035a789279c120e38e6b3afb11ec14b3ba8fb22963bf46fd92e717ed4e756daa7725280c04da0e76a96c175c513b9c62edb6efdb1cf121bc0cc07df14d62ae790a96c9dbaa1da4dc916a908f393e0fefcfe1d2db470164c98b24f3b65fafd2f28f4349cdefbacb313b1fd6c446e72a4b36c6c1be055a3fc7b38756313ad573838e676961940afc5e314ea87da5947c7f5e3e4c0242f2854014b8c4221fa7320af89008e425e030c4521029c7818278d9ac209c6f60de639187486d8fea965c0b2ba5c301d46d084900634d1a8d51d4282b47311103890df129c5cb0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
