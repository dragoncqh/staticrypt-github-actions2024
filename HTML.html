<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3cd5f03a9d5f79fc086b1e7a250891d2781bee129a41861c49e4c7fa2020356185fca0772dce7b07d12c66afaa65e7d5fcf9a7d6576a266f4c2638be6bbebe06f451e14150fbc5c5a84f2abd745577b443740e42941c7327b6c3dee4682f5d479db7d91d1d5137233223e5a9e1de0b5a9221efcc9ca791e6b04ee6977142e8cf082bee9714d33d4b8a90d4a7aaa05eb88b72ac5c185e488bf4a10a015303cee3bb5d39c6b83a0770c1c82e9e8a665e52b66ab6b572480570c6862e7089855753fdf2abb2634f0fe8b7f3d24e132fb997946d3791dd76b2056fd4eeb00e3f95851d6ce67a009dde4201bc38f57698e10bcf0f93c71056bdab9b19da5c7354ec30e0fcc1c15a5dd1e9e931dc00aa6a6ea443f502a3ea997d36746227ebae25d4c726c2aa859da605db21a586df644d6b008f7edf37614fc100bf9cfaaec80e60388904c0c56522e64e23c1ca42ba5d9c1c91c566eefde7804e4d47bf5fac621d0fcb972af1d4476993682f83919e47e032f8fdd2111800ffa3dd3075006ef96ca22d23a66074038028fe6e37d5a92d00fdd4177fd9dc8a6d5539491dab8025342f0cdfc23b4393bbc0ecce8c984597e5f48e20fdeadd9815c61d4b3dad3d40ea9f96fc6fce97063f7d22389421df85d98e8ec8dc3d402922f028639e5e88bf3e60a4ba5e093fa4a48e9ed03ca1395e09472c5023f6eb99acc1a7273efec28d66d69b019bee6960862d66e8f8cc259390d8bbfdb86f81b1f158e1ac6daa931b15fa04bf2c4db0725019e67909c2ecc4a05486bae89e979ea3d31d16ec6caa28f72d19c414b6f087decea3887f9df44d6fcad2da3814dbe5af26b6da3bd6eeb73a8357984b665e12b14635672d458edf08d5b79805ed269ca8f10b4a9992eb5252ed50c0454e8fddf5ff1e0510eae63c2c1e09d7c6db5576df1299b8bab864a2c1d31feddd4c32d3d4e76a8d39eed07d9771a70fa7d7a091c7ed3e056a0f704b1a25956c09e1f564b76465f055d37e1e6d389ae9f0725aac9a3f489f5244e2e502e6880466a3d7052dd394a6b964e64f23f9835c4ef0849391f19b3f797a2323ce9d8b041f7301f3e15fa852d972ebf983ca935d43068f442ce1a1e4ace39dfa7fb75451a218b80ad2df2446f7ae77b1495497122ba983683983d1dbf0b62ac3c57efe4f62db4d21ae49a7b45a36cc55eaf014aacc44731980969d4f855256dd1157764fe40091de50b2e3c294138aed99d746fa47c5daabff0964ad11040d7b0d5d5d32338e29733193208c63ac1a99d94ac8c948768eef22be306692165582d49becda81f056aed4edd344e72a774a84fed085d2bdf6f2c0cef7835e154f9972412d52c54941093a550caae8bbf55d284fe41824bd8c315b179b40c81f06192b9f12867deb4694799482ce6e95d0b2ae19eb27ac07bf5ce882d6b9a693cbbdaa57565aa82b016bdcfa66bf890bad8ef4ce0c3053b56c03eeacbcde0cbd446dea76ef88f1f2a9629329912e13151304db9ff704acc4cfe64a38968048aa53023bc5fa39290ae31351858b0de30b9cdbb1929c31740350db8764ee1b632776294c57d55be9e79869ce2a3f5532683bc60637c78f605c5f82ad00a3d52af8b83e78e9fe1e3d39a0dd8e237bf97a612a549d579d63aeacb06befdb766901737fd3a9bb6fdce9930b1410e6dfd74db18d490612c6baa6d3def414b8b12fa53984a740b3e20e8a9f7d4681b20862180e655c07ea43ec60c01277656cdfbd067521668e0beac4818da84b85d4d4076b6ed17fd93c05003188ff344d05f7c7a8d9cdb9ea3fe103c0bcde07ae08005a2234175c7ae78cdd02c2b66c9df5d9ff89c068cd1b6296b39d269abfdf23849a12da8dd27e9a2b35e6dc7d05f39a10448aa508718bd95bd8c86e2895d75112c8ffcea6205e781059468dcee19c6fa128b74fa4a21c28be49feebbc7c2944bd56d095c861aedef901ba3b94e9f500b54347b43a41b18758c1309a2cc4d3160f7f0a341e21312d3985d5732ce78e3b1567e40e2c58a93f3a002c95de43a56c10746a6b3887eac91ca365f79b8570c61bcdd46111cee3e1b593b3af6e22df010edc95f8327104f412453c76f2e934661296edf5455bd71170e349466139c828bfe8026e85d24a7d7892f1786e43189e2962cac209c4c6802994fa470a0f3ae4edcc14b3ae4f73853ef0a2844e82f5e29c0ca5e1b44126b8ecd7d62a1d735b01516965c664bed5ac54f26fbac3e09c3106232f5233c6e8957340a3d0b43693098f6a339f5dfbb3996ce55a2b4b45fea79829af65ff41f22d592c875e298b9dd4f077a3645b6be97d8c1d82de6296117be45f74bfa346e5a7db8c3b0d282435bc6789d114608cfd139b465589b4c7ff9a109f3c1ff0878db5c0a23e124b89d9839e77cc357732759358f419716429c49c0f801c0c7f10c3cad90996c73368aaedaa15359d82b5b2893f73b86e6772525a296cca5851ad68afc0e429004b63aa617b6aaee2b520bf8a277c1a3dea9ad9a09f1863fa1411b192e358279f24e665a93f0ff0abd52739a36e55d233a5f70c729cad3c55f3e6fb364aef5cf0cd019a2ae41433743ff3281d2af257bbfffa0a107d008cc897f13e3b99cddb6c0891096131939a6d2b56bef9406f80c0468651b4e812d56a78164045f98830f343b60d1a1e006bff13fb1041bc3e84e01efbf85b19f991c6f7441b3705419882098b50ec3b407d15ccde2ed8adddbd9b8ca9e709a8680793b3f3da425035e160a2fbf41119a9a68ac598a4fec0deb1256806cd4df9fdec218d0d25527b7a64804815244324afb696bff3233ff921a43154e7d7c17bea5346a5e7519e227468212caadb6a5cfd5e2e20aa53ca37c6be96c6eb21a53aeac1e632ca2e28a2b8429ff1f412afb00aaf5b8dcdbd9456529c40c41143d4eb6ac4739f3f00073b17dfb4bb68683ed3f9866e0490af3330dc07800b501dc456c3cb70da43c128664738f83567e331e25472bed4c762339d8990277f9baafd5903b8a7722a6f449d28e61b7832c98fc9b0f966e480732b13cad3d267e3a6cee7264a28583553f9622b1b7d2de6101e38aae1963fc580ad2dfa98b4b83b2047d17205f27832cffe96265e5cba4356984d5e3dc706803b6fdcdfec064937322f09dd9f8c061c86fee31ab9909a37f80568de344efe03020563c63f01703b80115ea0c3eaf401176266eeda1fc2e3779a96b10b8b324fe7606f1bd6a4baf49eb6ac07ce485ba835dd28392ba8307b16bc82f32a4781342e99cc5b94a950a9ecaf438f64a552b32d414471ebcfd758fa5467381df8d460c2a08777fcccdb855120c27ab79f1b51b71cf1c23ed4e02334808eefc275502b94358d82e707aa5cd0a25d0d2a371c76442175214d4e8927c65c29e1fac89563ca05e392f72429d3c199c26cd1376a22452eba4c75b027acd8211bff36a24467880375b5a563527c270e31af73ed133075cafb94d300eb51d624b5afd84c0ba9d305dc526424633048ede366c53599d20ef33e1ce5feea36f8b0e529619bdc1d5363883a9534b13191975970c91ee4ae70180324f3461e6461c62a357c56dc012cfbd9c15e2eef99b1f5a997e6b81ea6e936aaf94fb46292d1476ba2755ef938ee116d4f9b7c9432a76f8d2ee16e1964807f7f924f2312f7a34772e911f991381f2c7e6300b6670b0f67581e4d25b72a2472bbde65e7e6e98fca6f99e3b889b689e998eb20e6a2e8ae5bf33d4e15d9babda6b3ca36ca5c31a987b64ea641d7f8cd6998e741d29c53abe14a1d241a7bd1ce3de118392e4434a68c785475735ed5681d16a23b14b4d8b063ab098686e777a6d36ae3d2ce9df87536e00c1f17cb463e435d70ec3f14d88d2613cadc74a8b5d75e40539ae002ca05cd1bb8455b21c0c665d10970053366e603372ad0a352de07ec6b43c15d5aa0528bad0c95190ec7274cf2a37230b7d5da8cef812edceb15b4e1fcf604b22d71b9ccd0f1a528d54e61ccd36ab49abe5ab81c3203220f4d71e42933568fba1bc1978f16c93d5ae56150bea9f1249428837b031e1f4e5e5245002994b4d799ab45eb5d0c714a76c90cc278a722fbd087954d18005dd11b7ad8e636b5af8d493d55b18de700e40082a59c1572ffcc44e4e4a3ec196e2147d46758d674d93846a297375eb3eb343f59157fb251ae00c09118ffe9151f8d0483fbf3b790144ac68a09e2a3eb847b5d4748eff09c0b58c46f8db524a51a492a9cd7dbb659f5f3f719d986c4d75707bce99be7fe068253584b364baa2e8fc0e5f6f78e42e54318aad70f684e2d3ec9e6f2958f6cc74c9f7ec6bde0b7fe6d8cba2d1d433d54aec397b70912dce8b81e2ebe446a98e67df0894eabcbce26f8acf07af2237a76da7a120253789b751dac4f3888a3511e3ad7989ce30ac79eb1bf42bafe6fec8a0f05146c28ea4bdc1eff53035c454dcbcd0a0156cdd89d7f53ccd398f7f281b62ba9cd84a3564834173fee4132b457f04a43d81966ec7290ac430dc200119a7af8120022d6cdcd6135e20965bceea265fafb8acf8f4a24f6530817a2ec267cb6d5a04388c86930a5c664c206e129cc27c3684a2a99928f3dd9aac759ce81610dd41343114f228b80027d94c55e6f5fc65adedc3b2b6673737c46b8febeab215e4e926ee51c0a66aa2ecaa8433b7ef145edc7e5b6d09795e1009012eed0e1556135005488a7e017d23735cd051b7b97c75cb39ce7a6a872ea7c4609de32ead8d83f708acabb268f638b22e99ced7537a18afed3874a6f231bb75e9e8c9172915f52b1605485efa6e7c0797f918d5232d6d3bfad1c9a7e94a67c087ad02d3c8f25d774448d4c091b51bd9f3cf6d2afd584d68ea3add07559ee5bd4542a1feb37f55ce1d546322f9f95a4eb6a8a8b3858df4233ef6fe67ff75ef1b372b36681d4ef22dcb24f0c33f952c6f7e86b43971f46f4578e219d7919ef470f864ca2b1f190e86dd9d4a21ac7c647b1e2c58f1ba071d7d7c67be84f1a7e05619d5f255827e567d26c1c695f3ea78b54ef72162aad63800d696105fc541bab57cf4bfda33d7a3c3c0c6ff5f5cd19b2a56882d4772f1440b6ab7916a4cb2fef2bec930f66b49b2cdebfe101062d2fc58778c2eb551db30c28f298422a1affef442859a9c9156e4230bd2c2a4e9c7e2c52d237f2be2728568bb328b8a4e20aeed86a6dc8739bcd515f2baf5bdf3dce854202beb5eb88edf360a2ce293cd3c44f0293c16041e2f02586c0d8633150ae6abb92a85c6f3655b37173a4e9db28423b8d3f5cdc5b00cf0c4acb3def4f49ecc7fe6b7024ce64fdba7ed1de3988554a88906a34d0a213f677dac5d767f613c0b62459a556616a9d5a9a3314e2723db8dfedb0272a92af3afc2729e1355be6bfb6a9e4e929997e8ca657a37771078326f53bcc1fafaba671e4c663e0eafdc7cdaac84a8c93f4ab73e10a15952a13243e2d3417040fc0ca67d1c3fd76e73ab2a671cee9b5a4927786828fed01e1ea4b77b6da222b930712d5c765f6c4a765382a62fd1624dfacfe7ef1286adef4b895dcb78d0e003dc39205cc808dac1b55910b152cfbf28793524454524d89d1c369ad25ca0c965f6736fbc3b7e4f1b1fd812c09c46facb87715ab5297f6d904f0a46107bd99a16a68835ac798615bbb126c3e2518eb9eec4d07915768839dee33ff25d3c574fa4c180cb501e3cbc6ac615b471532acb7cf8555e170dba38735c4174a181737942438a727c7c1cb15d3722054796624dc298257aa2a2066e1b54ffd4863f95bda269dbf63f5fafd27e660abcb9d73d9a677dc0aeda4a44172dd2119282f807cfb555e9e3c2758a815b536750425135de63f385ec88590ed7d260017532c4ae13a30418349bc0a5a1391c46ae91d08e9172df654889ec7bea48ada6cb72a674d579c30f0ef7860f1467732a3eb775a65132a6d52d6316efa7aa33418e4f705ab9a1e8ef476f0a3387aa9a565ddc739de8968059930b3ed82f49e89b201e2090faad43993b74ed38c797ddc44270861eb5292648ac7b43a57ba3f4356ee9358964e674bf4f2ed2eb954f51289863cd007ffb6dd3c5dba374b329e2ce988a35b92afbd4648a13d481bfee0156f0392da2abbd2e9355e460efc7f74cd7fd18fb496914db39972cc3b02eafb24e5b29c380f7556c0572d61adbbda1705cf93b688391795487d4ba89a87ed91308af7f060ce65d695888bd90fbd6c0aee7c8dca22312d9782e512db8edda15b09d2bee1a48605bb432f3621d00d81811e354edc76e9c36b34afc549608f92a637405fe3dffe369216caa83abb613a96c4d209aa433c61e48a2af13a4ca414f5c1cb80efef65dc96d4fa90243052b29057547f89b59ade8933d04e5804db6ee0ccf9ac34b2cb2bd43cd900071dbe22f882aaa63cf4cbdafe67e7a2f5cd712cadf3528ae80f683070e2b4033f297ac716b236a9e5cda78be6faa8e6975a1be3b429b37ab11b5fa2dce2fd64db93c7c6bbd5fd49989a968e88842dd3efd11fd030e514e16b7a49103beed661bdffa5f72d4ae4f35cf3da61aedf932a3e0493becf4b6673ecf5d6ce563ccd325781a628227027cd3eaa40a40b175ec5fe55dc5d7d218ba1d6b213a89e95f4962fef44676e588474f0e6fa5d5d8a484561d9647f3bd8887b720c7ecbd491cffec4180b9cf271f706e6408b997f4b7e8677bb212554d765180d7000080cacaf6f363e8266af588f77414e5456cef7a5af3ec3ac5b70a7dce10411db14bb827811262b21d16fdd68c2243da595710b9ca2b724e11b27061316d478f21b4819b5eb4e410f09f8b27609cba5e740cce12e421337d8f45db78ab0d0ba84df8c6bf6d06f2df22b4c90ce6ae433105b45b8aec95378e842e4efde74517d26966f45806a2127db20f5e5181961147e0222601ce12e43c0740399b0dc7a06f79ff987c83fc8123a4ad68adfb8cafddc68719106b4532c6893dfbb2780c0be69bcedcbe5c5ed104b3f44df7e7aefec7997e6c0eed631363e75fb87d668739f0076db89ba9d1706a51f906ffed95bc8573c3caa782a94f884df3c08c7f17196ceaef32ccc40f122e89f04f36114701768ed601482dcdc9d276b151fc1c8f5faa5d95e613e95ec99767d228bfba61a71d3ca7a58a073f57ffbfedb3af544fc6f9433e350c4b4798aa6deba4c92ed458dfc6563979cec2ea9162b171003c58b151b7d9c7da0fece7cf31b9ab938c9c9c403533ddc52dc05cc2a2a28ab607f8fffbd425d6fe9436c2d41d48628467be5f82c71a68e53c7953ccc56d39148101e9256ceed6b0574ebc518969c7897dc88d82291d5a9a33719969930e11780644565dcb66dcd9cbb947fe0c3d82fd7467c2491115094b926f7f20ffb3adff31e7ea3cf4d54725e6a0db7748ddfd62890bd454cf4b9601129c12538744c68ff0eda5f5a267356363eda118c35a5a6bfbaa674be0e4bb7f5be9680f85c83d5b7f9fd3bd0fa43d73ecb50fa224eb3ab0cbbd5093a8817494764019946794693ab79f2df54c998bf7373d402e97b1df6cb1b3590448e9ab9b6c8fdea5e70ea7b2f019dc07ec171188505797a705a280ac2255aaa74d092de7aad6f219335adcc8163667dea6eef988d01f0fc375cc741e841041ce9abce8a546dfbc32a877b3763bba155bb861c04ed22db87e184b660695fd97ac9f2b592fa885e9b19815391c6232d6557d925e3974b648837df8a38f7cdfd26867fd0a0fac9e2b56e3dde0bb45ac98092e9df244780bc026a35f14e36cf649588e7cf0b6679afe0acb875750c59d4afa31fef64c5961c57f4d6d1666492ad97cb88f671cd3c70aff8d245089b30808b40fc804ef1c1146320629113aa68d95c4ac00aeadeb514230c9c8b4ddcd8052ecc3a9f44f166002b7bb7fa59b772739f56dc6647a2e522ed5cb80de70b93cf9db45bd631207b5ec95881ede9dcd2ac4db7eb137fbae595b5669fcae05904737504f42d69c733134415cb64c50cc27aa2fd08efcbc833bc9a702297fe40ec40f271093d83b83cdc9fa233f23411f992a49fe4b0bc770ca752863f5cecfbf0e4654e1e1af2a9bb494575dc896d045969ad6510d427e76236aed861d6d1da774071008d1ab277dc73b3b27c66ef1004d4e7da1e6cb9508cd0d164d50191089b1cae597f0387c05dc66570bcdb4dfb10fc2b93e0d04e92d8c5d7dfe4834e0c8b728ae3e52bff24ea0a597dbb674fab98d98b8d96d13d2720cdf0268a4622c153b6771fe665128819a15a8b40335d689064ee063180017de28defa56f5f6fe45084e53dbba303c4ab1ec672ecc4d162773aec3cc6ef39cb3235c9b067ca68f606d7b7dd797ec7e4dc79efb4854062160f59e03a0100a494c5935afd1731620aa3bf7fe42d88013701dc2aae4ff2423ddb89822a7c60cecab1f3d84e89f0be5f0689f4e149f6bb314382c8292af94ad90c52cd0c0048678628e1731fd2754cb3155c8263aa592d92a9aadff3e9f316cc68eb401ffe785cade7cae6624a511e0a00d7ef4182d69cb0df97727619cc1086f4ce8dbd2dde8970386b60ff5fc2e36de8dc485426dc2f01fccce678f1b738b5a049bd2498fbacf015d574ae3ebab31032d9fc945175d6cc0b504d8b83102831456be660b771d0ed4e05ad0adc9f65a7251f7fd67be498ab6adbb567e9d48ea0348934aa6e2b4751a99c9e9d4093e09759b3837303dc32eb3db31842ebca60b89d27365121dbaa767ffb97acdc7f8dccd316b2ab05a20086eae19d7813d00641ab5d44897b20e5a568944d1a632161a386f49c3507396fc812316d29e27371f48b0285ee1e1f0348628c541558ef99087fc9d28134a7f6e68b7588693c45642576242694e4d7ca69819d6701bb4fd26d2a413feade6d9b5f82876dd82a891d9215ceab6fe08927b1e3ffb7e816766f600fe5b2569551330057ae19631b14978fdd44342472cf69e34bd91c45a144baa668fdbf9c14e0c39384bf4ae9c0629acfd8a03456f8699408f2025c2320f5f759929e7b8d95be8d6fa51c4287005a825ceb4702527cfcddbfeb873eb0ad868830ab500d369a658d314882d63a60b92010eb1ba72bf4babec70f36b3fdb58aa1af5c7400bc72ea54677b67e4bbf017e0f0055ee836b7f1b0b8358deb56e387de3046a3d3da775069f9c6db0993a1a1a859ab74d4e5163535b7a98856532f53bd68c9b109808e5dddcc9871b29a3fd30449f9b92a87bc52f42ab8574bf459a8dfe1e46af1265ad797f363e128c538e8fc94fcdde8d024ad12bfae36815a2395a9e7f44f29c0064f60eff5363be4e3ec0acb5520dafcf1b184e9d413097953a9223a9432d37ebc6d4d7d853f7103d0f732060051205e96bdb85ce023ca0aadd426044c5b9e16f8ff6039363029ca79922f0430d1908b4a9001565bb2ab685def52c26cbc092c8ac0914ca5a378d075cd6372b875e97280285c3588391e8de3df59161ec44c0b7ee0f06fd8d1faffbab4cf3b89b673fded39cfb82e55a96fc33ffabd3f1845109d8de1274f9642c593c9774da7964af84132a2adf7cfeb831c9ec4c9a5c0fa2310e635198a2e4c348c23e0ff81885758441dd9229acbd6c9bd2c4958659c5f9ebabf120ffc20c13a8cc21fc9620e06c9e573ffbef5ef761cb5066c11c9213688625f0ed68c3739f241b5d624c3af39894c66505612d386f1d429941f21bfa1bfa122c69e6f07e1852c273af566ae4a5ef490ea07f1fdb88ade16635fa299b726d0bbb1e943e3ab864d7c961576820c877a0e8739534deac8a165d0e42882874399f94a6be4a4308c72dc2d8d55fad924c790124c1e7ab906f107833278452177a9a5bcd0713e8c3824884aa872098533f8cef4edef64132478f3f6f2afe2f53446e4c26d350e36087fa294fd155675d04e26da36f7fc45667e32253051a8a220a1a227acfd20b5cd2795e368557cfca46323c7e5aa1c8806601282ca79c298bc4e60dd896bb323d41927fe6d54fa937150a6934172bbf61fd132acacd56fd2f89393f7243032ec0085565ec6674aff892bfc05adfaa8960f1c9430b483dbbeb5cb52d3eeda46179d11693668f2d6e83efa46b2b79e4d461b3e261582724f13b7fae7ef08a4fa4b4beaafb1bd8fd09a60996984065d5471d6c32c72f9541637045cb5a7992b45200230013212a062091a44355352372eb0690681b84a1c4ddfc11a3f9474815754eebdede73221051c56e93734e2b6c389d6a3bbf374ae1382d81378566a5dcff8b9bd075119894f1e93afda4b5046c919a516f8aaf57ee012da1f6c71f6021ddf61f573a9c26d1147c1cd08eb302515a70a1e50ad21b12ee73b39602005949479d761ea608f0da416520a4e56b3fc33c1538a389ede801e18150f3bd0caf65795736e8122d016357bacfe306fcb5979abe4cf66f6020315f1abae0ea48958949f21dc46014d07af3de3baf4a93de00580e416c3882341d4e060b316a87b901f2d2ca113df476ea36bf829a8d5ae54dcee06c763b74ab9394b4c17136650aa3436d2d4560f62140d86d340224426c261cb421f593a1bb1485bf7819033fa702e9c9333d623be3487f586c0a70519bed8379ea3d031c0d4ab5075fc58e9eebf2302e15b525c3185e299c508b46aac1a15c6ce644c9acfd78b4709be23ed5c30bc6d45712b993d44cb0197ca2c5f683fb4b235549763d4ca299ea5ec95eb7353bd90a6ed67b7e594aa5a3d925405341c24a7b61177ee793f1dbe848faf72bead3759d0d3962a41b805d8de0f2135a81c7f2fe4a1df95e2ee5946aa5019397bf30498d436223d4aa2de4f4fdf924fef14e4b139b3b9140537ab4a771f29a29d4051c17418544ec093443be52b8cad90724e0096747727d2a2cae90f5bc6e029f2ec16f251488d11814ed53d20d2db1cd134f5dac05b377a59f099886399d28cb946fc637864b2e1236b8c461923260300f7856b6db298916ec2ea7d089de6687ebc160c87a84b9f28b027e3ccd7c813e61f6333aac47b50de68d666749a40b232aaba3048a4e1b20d9cc96c4f7b158356752c4088c86dd7b53ac8ca70b8b0b7c82cf1488751a9c5d724f0a04354eaf0736455a4e06e65a2ce3ef5732ce607cd8d88b1cc1fa6a9895615c65f60ae664bb147142b548fa7ce3a084d5ecde36f7b852f3999a10c48a4130826df92f7ffec699bbee14fa666719b9ad73961d63d573d1ef7a77eaac9c3ac6e437873eea1a44ee20c1c1361231e43c0ecb8ab7f58aad763f4aa20f9b222c4ae8eb3e73347472f20c96944db4a5055188c104e3df34563dfb7ed064cec056c6820241e8cfc6a5e372e3b2f536d8c274b4930e7e71e1059c068b5d2c2f157906a21edbb1c7e881edc5fa31eefa4674d9ea6bc0cf46d903269b34f1a49245743f6042d3dcb3e755128e5d72ddbe75b4602d00fcd7dcd7cd36c7db452f4d993b3495ac7d22396d3af162da91b89957d857fe4994583904d4802de0e502f09e72febfc086089a0863454c344e8e07263bef4892779d79718a29e4aad3129659ea436d86cfcd82e65b9cc0a6c14ef0ab3cd1c4ee57867c519bc37136d72ee8d1815ada168af16901e971e449882f60a26b9d30fba7df7a4e97e97c96eb5c3543f4aee56f0e9614a3a8df588421636d8d22f91fd13630c4d86476f551d49a9bb13d21e50b76e1612bc832480c9359db8b2949041ea3dade52935cfb0990f23d55e7e6a771be070f4cb174c4a718973786017d22f857eb056b23670ed91e0285b22f71495d72df8e991ce9b02849ac9852940ebc9f858701a6a9d903e4486993748c650ead66ca4dee86f75d3e9624ae4b003e53bef7ea2db7b34f5007350fe72f868a23c683b581996ba76e2e560deeae46fa51d58ca2833ec3633d4805cd4feeecac52a9c6986cbd58edf9dca0ef92f8421c70f0ab7ad7d9f1d31ea482e922a3abdc7c9248cd6f78d9ab61b75dada1a0af3ed8d755fac0e0e962c40676acb6e453b86b8b5be2932b7ba301b0182376cb9a274e286f53a7e91321c6acad9c99d023a77d1b3a87495b8ad78543a4b127f75fa351669977f5b0de95eb7e216fc44d2f78a97b5fafa896c335b1a70d18e7f6718dce66295d472efec318e943f58fd1039b27162102d3e13b1ef9b3e6517ae5dbc88061627effe7be07d854bd510e93daf15e0ca55b67792165a73982b83363173b54138092c7d6f169529d1a7d831a526eb83c8af15d3d377f052326bacf4e9c8b2bf008800d8f1ed3816aa66a31b89010972cc10b34ade3dd2a3ad236ec68802763d32dd516e4e1be710a2f6ee9032a1120dd0df29feb0b1de16afc19cdeda32be908dbafe7e58d444d98905fb7cecfcd3cef7158fba4509c46abd2f6ca421e03271280b1ecf305e37bce4a98fea3b4a84f99ba122a186286d7dfd53633ae757d62786d8c0d8716a7663ea34d80957a878f8e6323dc38a6bf289e172206622e8ff5c602687771b168c727a1769fcba2e91ca142c7cad1cf88e959ecc391c63466f3ff05a71019ef11a36d50b52886f19b51158d8006bf0afec259b394be7b421eaac00b48b985bcfa701e70461ab036b50ff598618e54462c636ec54aac7912891a54da31ae35ec6a88068181a456d6bb34b7102c917b76df4550c411fce3552f2de84f09f45ceef63d1e34a64f0cd228e83383fd8f431d9ac455490cedeee914fa76979052d3d12cdda80d5fff3045f9476b0ccf487ac3963f94ba327922be5cd205a893a1c8f89ed2ef4ef9373bcec97c410992bdd8afeb2176a8087aa789fdcd55e9b5376295608d844b7a607a426648a941a4549a043759ec5a3589b42de8ed9bc98dec84ed06a1054feadb7a25aab053460ea40717f96851a27027ae7085ce7880995cd9ec4a62d20605859f515f1df56c798f5616c535c70b8cdf698e1d905c86bf93ee9c17d55112d6b96a9e14d74190203b2e5a1d02d8df05ec50b462c7bfeb916940b3414bd5cc255fa69278a5f27abc30521a44d323b685c22ae469025307b7935711690b5db700e818501a79e4660187f18386037683644d0f7770e14c9052106d3c12ba894db296f7d36c7b77018ba87d5a795c2c787ba486b621f73ca9aed3f03d9c20fba2792e6e5f4a2b075cf9506e25f52423c584ddd50ce27dfdeb71cb53cbfb7cbabaa2c8d604e637eca44d4f50517ecd02034addb223d305fdba47f56f35959fd5b32baca073fdcb5e725d46c7f137bec645a431058e4410e8b3861b51fe4e000865a74692f1d0cea7685531c18721efa56fcc5d1b1d084fa02f203aa53d58f77822ce91262bf53f1da42f4950899961bdd456ec2f788e1cad0437178f4a203b1fbc10178f6cbf1df90cfbb7da993b629997b149ce2ce7847c966b5b2d1d90ff35e8de19ae080473ea6611bc92bff7aeabc428db949eacdcccea3b6f92aac9704c6a8a939ba30a0763aca1f6a67636f7e752a14100783bdb545fcd4f6f7e61f29a4e37091571245cad0d64008a5ca44fd14af37d237f6fc695a9938670c84b3352aaf1e61e1ae64bfc7b3e201524f2a98340a4abfc480ae44ebfc0bad236b6541dd80887c9c9a5a76f581abe9de3ba1ff2ceee0ef781d53faceae9f65c0830ac83847c51594ebf9300893d8efa0d84c6bc136b1b4b01364361d1784dd00bc6db70d7ad0fd0bbe6c33437fe4ebeeb10db069cd747d826e1d1536b2085c9751efa58cd0ddb4cb676fde0e368c82705cd558fbcb9b72e8f68957a90a483f9e1b79cfca1c793b9be48aa8b7e8c39d1a43c0942939361f6f7517aa19b3e8b51378e57dc72bc511b255e5d9a4c49377249d0b7e31c4577c4f07bfd66035e7dc96ffd996b0bcf97b9cd9b374d18554c66376d36ff7250e31c6e110fef251d9597fd0f3057be68ec75660516f1337c9c33e924468bdfd3e2dcc36e04b184f6494e5b5312cd2a3da522a286d628c83a1e0f3cbe97c07a7fc6a1124a70ff6833323e91741c3e81737805ae7586a83d5d7272af4016b6938ce785538f9d3879344c6d97260bc5e83112d7a2bf42f261e8d6bfb7c801d2361384ebf56c35f40a143de0db3ad6b789f98ea0e7535a106f4efa6a60b7033ff0bd91f56f98ed71338a697a76b471e0883913fe25ae66618d252b49ca689f8483ef427c17a1aaecd9c7bb06dd48fc1bf742bbf834fef3ef0500c4e4e3cdf3f1ee12dedc400a63976865710e4f0ff27c12c58224c2c3d404cdaf6c82e71b43ed13177820c25208ef460b7459d29f378391a7d3f735b5ca214b5e5edde6afab261bb30c46ddcbbd1258ac259b87f1c15ea6d8a6a1edfc05bd0d0af63c624f663caacbb88c123c5b0932c4030b38801c9211b06ccb887167f11a4b1c433e57a1aaec17c44088f97f5a602802a117a96fcfd81ba64d2462f2241827d11d47056efa1f655ff3c0f3ee3f95e9d1fed43c812b4e3a9748109efd76915b708c0cd8d536ee27d56d0cab526068b6381f9b3ba91ee832a30800f7c798a96838ec5281f4d846d59979730a5234c0523d9c8580f4ec92c708f1bf7669c96c31a9693f03c1f1cf4e30071bcc477e8cde5f4ac95c12fa0f5f68be0bc2d6005044bf0450b21cda26e2f898eedf05c3f830fb173db7c1e8a11a409aa9f287af96e970361f003b5c66fd5ab0b9b48bbf04eaa366dd6f4040ed255ab7341a0b3d93ac57a846a932de307f9373e49802ad56adb2de7a3605a341fa78838f2f56336cb5b5406e55e6759c3bbd493f61ac91ef768170319868a8ab4ba35bc2e8075a3b288877b6f6179b8569e732061d6221af53d6afc4dc39c2df43ad5750910513865a72f82bd39789a134aba58e279bca577222133416f15ff34d9d49d38164efacf89e795a55ed067c45826b5226fb672a6c2ea62f532fdf963f676917ae475b59b00c2d5475a06d734dea50e47e484a0c0a252bcdeada8cf9236ec4b7a1cd6d727666c0a256fa1ede82c7cf6b23fe80b7f3a11517096e338621d3b27e498d0c2b04e8ef3ab34e9ba5f7931213131e4bad1a03a4edb8ffa9b250d3e0d8ed79ac9d4c0f877bc83a816a579070b39b128b68362cb3876f1bc54f11342bb2423c11aa275ef1f2e13478c0de028848d7877219a4ad8c061391890ae6d027718542ee9c286a1461d7ce00b64d2057cb300488eb29c8f84c8f264177dffc2dfb70f797d69eed5f3a30c5842d53176329f83674b151bc3398429126e56a88a16ec7683487dde7071766673a976ed00f59afb37e50ab5e1a5e2dc5d3471254504471823b5e3230ebd283947e0cc32939a68027e64ee49cc2806500a850bc4b9dd6b06c699092ba68dbde09f04c5161cd25be1507ac990b6df6ea84244e10a883e92da73bc9392e70f508bab347f4dc7bfc63628d472d5bd2c2df26c414021bd59728d5f9d6502c8069d3ea59db5f3530a2794e2ff800046f8bcc97d4fe36dae7989c56895168e6ec2e8ff5833fe329939bfc608cf8a2c5edfc796363e34ee4c734321af355fab86dcb882974de3771f8003290c537de1f5ffa9892a746b5d970a347492c2e395725a23a6e63809f5faa679dc54f7307b62b887fa51ae10242ecdf6cf8ebb86544ed09419b9c5c19b800b3e63d854770204eeeb1a1725e4703f553bd78d2b985ed8a7d3f026d47b240a53f31fd7e6286e88ee94f3dfa3200293f7f8e4a62690883b2eb2885512cc8f1568e1a0e9ed9e39c7800aecf475f89b7680873fbe85b6b53ce36a77e0b6ecd7adc713dfd03bb6fd042a791af166e9323f7bc86eff3aefa26a8386ededfec17b016679357d6351bf0c910a7fe8384c76c6e8abbbf7e44d0acd8bbb308e76aedbbbb86c2cc3689b54c01250857ceffe7ae728ff394493c55035a0b9e3a8f6da93d557bd66eeb52388acd2a6fca746a26bfa28259092c7ea21a70e16e223bbeedd8e68ba068a9765c230b6b4dfa1340b0d37cf20dd97b191befc63170d8ce67cc02589e9006b54c576a7d8785161b3cad608bc8c94462fe4a8a7144080d62d8bb118a679a707df5ec24067a257d9097a7580876c2d2a79523b1db24ed0f8b0b7a8afbabfb546ffc915d71cd0d69eaa992000f714a8d596e948c791c75a2e6d4e85dd66bc59c10526ed86ccca21c6b0098715282e9cd540b5a38808b268c0e79d01805978926fe8e27977f24600c8979ed2458f0425c7883879e300fa0632c6f71e9ac321bb2d41ab40cf0440001de3b479fd6c6c536f27a01d27ffbfd15f174e039ffddc1219d1ff4a2ad8e2fcb1b89bedd7601e471786b08d468bdd297b6b3136cf914cbd33ad0c1eba5424a55918fcdaf8e24c403d3d1e10cc1468a3cc9543c088edf5e67835efb7d2e147d5072c51332f3f36f0ed0ed9da0dcc4a89a9e3c3b8257dc8788501a37f24990e03205cd721c0cdb105018c2025fb69d1b280b39dbe517e17d523b03cf5cc4e5908241d97cb85ca83d35dbce9fc6d7980b32b0efc4c423ae07e2e6a6705274ee8a9d1b8055ec59a6a4ca620bae57c1a3e64c350f88f6f5ea98efb92de2021567f0bdb0462bde37f596aceaa63bb5bbfaf1f6e9a0a3c5de1a13a6d9b3f99a96f550c186ac54774bc43b40a5a9f7b48db0ce3e9d6019dd7d60f13f924356493772a2c6477b6c29c285e74377c13f2f539dee13184c94215220dbdcffa0800313ab5f4d6646f7b1833ad7761f694d5e17724ed6cccf225d0b64f77041742ab998b9085ce5bd84b22ca4a030923a0a0e142204406ddc1a5ec34d1b534700dcda6d9fa80e75536607eaef1754d9d2bcd79e1f80f309faa9eb723929d4cadead3fff0115b7ef3f643f47903a6baec11810c73a322ce8c8424b6bd3ce9a03f5e2958031b7ba93570ffd9f4ad56799c4b3ff22e4e5133c239e1054a3c8a41122abb2ba4f0426c209c899484923577fb42e6baa5fff2c165d1408aa2dbf6ea713d5ce2bc5510ef7979f4bbd92361ac298c2157c706a435449665d5a17dfc9a1fad2e235c53edb046cf8079ff304218e815b64bc88d4e82581cc93671a0a622d1c3c9bb0e39d5415db5b441ab98c70fd4a31f2403aa87e5cf30dc67e1638cf9fca68458294ed090dc5130efbe99f4e25b03eb2ceecd956390b6f4b929d44e7ebfecb620ea6bc7ff69acfa2ac02f50023377392a5b321ea8b7e648b54d84bcea19d2c237735f1ec5619c01634837ec621a622d370485933f7c0d7bb35120cf716d8a880d583a0e6324be21a154246148ab8d35202d40dde881fa5fa06a2f643da5f460eb3545a5c9c891d0534968b0ab0b2fa71132bbfbf84a549142457018de6a831441be86ecf4a157359653b9d67f7de372c52ebe99e075083f414212730ceaf1ee4a48ff5fbfe62cf500112a4092ef256d001ce634335b14430a157049270215ce9687046d265246762531e80934e70a9a08647b5e785ce923ca581d0018d74186bcea68d602e02a62996c22d38494bd6cfbd8614cc40ffc2daeb5a938153d18a9e6715cce2ff170ce23e9f19af1bc0374058f08c1aa162362a296a20483c763c8c0a4086f00248edf5c16f2ea4a6351c66a967d28f764d839e178ed1df982ac09f1a04b2558cf365a34fe0fcafa588b0646db39a6a5d1780c91bf3d4cbc0a25fbd02e0b37a67b72d9eab523674c513796875fa2c9819bde0493d95343f06b146ed91f8682c815bde7af6869ca4e86cf76dc485ecde8d92c808a92c2491476b99472fbda32077b0a82dd924f54e8a441907936708cc0389ea5923adc27832992b06952cca3bebdfc0130289a437d9f68e4a1145cd74a3e1b63e08aab41829b0ce4d1dcd0b5e3e8d960517c6ec75dc1dbcc9180c20f33da552d7f6cc0b3e9a12806065ca974ead79495c667ae8c497a5c6afde4c96d8a5238f0f031872f89fbbbbaa1f5d221dbe071a111a4924d97f335c315d9416986a7763c1a93e1d87f98ac5cc7b9e3bedc503333388c2c29ea087b5a002b16c52f409880beaec9ef161019c275c7e078ca0ce04bcc0ffe1482e5ecdd9173e1395cc1cba6ee74abbbc6b9a8f65acda1cfd1e2e36d0b7caea427ed82febf9f6119042ff3622b281ca7fecfb99bee3306e916d943dd1459c86b2d563c4c7afb2f5c06cab112b265d40612484b3461be958d2f7c0621db159ed7624434cbdc31dc2586b978e69b3c9c30d41e2d06c2a31fbc92dc843d1f9f5ee1685b13d82fbbe1c048e408def2486271f7d1d7b1e240783f67615d977e742a92f20296076e7949835034c5d5e6a5e8005a1e5f37b26cf4fbb70addd2f2dbfb091d002420de6c7366667b83b2d9fdd7e8300bb7209f0ee82b4b858714b9734d7f10c8d0c99d2d74ec85952c4ddc7f79b2100f179ec3d3ebb5f689076496da5554c86bbed8cd19e31e801a359805bff8723c8a75353b106705c7b5cce00c7db9e2bb9062777918551042a924e46eb99edefeb51ce96aaeccc638bf5ef08f30a393e409decfa4164685e9545fc085a488bb2d044da2ce2c7432f8723e78538f2afa82e651397cacefb58385268b96cd7de51519c477d6416b736ec28771ea11addd4070026edc3c032b6610c9040f7c53589ac69d5553370a333cf87c88f62e8ff0a1a98d79ce034de02032e2af6fdb34f08575b8e4302a99267cb80a1f944303ff0cc923424e73fad42c7bb37c56fab05e0ac28aa3105bdb785924b6ae6894c7d8de9ad66cdd8c422a7f0554a81cad06dbad5b1769f8249136cd045c8b7db1d670f0d38d0559b349baf00016c00eb6b51a91e4633575fce8ffb9ac37be5f5532ad40c678da3beac9db2816c35e281ade67fde67ef7e847d2f194e3c53d66954e336695efc142c4aa83385b67d60a23fba8005f22fc6e6dab1dd5c164abad420a23e73c55d065a252f72eb698a37a660362d511bd6c10c18653b28355025f20a6567a077fd2552e669985710797a77243067a006c0838b40e61ebc4dec908c0d368c5dc0dc962895635afd18535e22971e04f16ae1e187fc703faa3b62f8301521b4d18879111f0e3b69591a08980c969e46ddd86e8131ecdf0eda033e60c77c88f44d442670ac97b54d69dd4ae4ca9ccfd3b3c319c634a6e9c2f54de4cd5adbf5e38a4029e5fa2ccb6347eb991de6fb50bf59eeaf974b7ebd414d11d13f27bfc645aeb28582f00c81000ba0bb47cd3d76df354605047eb9b352c3b9665cc1acc97351bb725006f53a3698b090abfc8183cc5af4f7c140799e6ca2ffade8b813f44279a862b872df2c1b8aefd08979e3208a1b4dd1abbe376140d56765da77c7a6edb0ed21b59095e0b70d391e951b2212c0938c45b217f7c70d72decbacd9ad3dc426ae34019f46278e6b648a82ce31db91e43ead0489fecdcef4643da91834806eacc372903b4c00745d5826189cbf96aa34939165f58054a98f2184d18b1934be89880cb7c420364bd9d5f3aac90b220e3b98a07967b75939d8291908e8313c6a470e4a683a6f1b2a64abda7980047ffab073ade698b0a4e906690cf17b68160fdc5326cc20b5cd90258e1e18bed57303ecf9a1262fbf02d0305501bec0aeb53e079385fb2e7415ec4edc91022d5d4cc29180af8e9d57946fa7ed314a7cfc71f7174678b187c02167a948f77802a169ff7296e4d282a378fb7c7fff229238a52df0137f8ac26748658ba6b010376d6481954b45a8938035a70e9ac771494bc44758329b8d9c4d960f928f78d7532bb4a9f2e4f60cea30bb2b08e4513f5e1d1d23b85e68a6c012f7597ef34d5a35e10ab0cc44b0d554369a2967b4076586701340c48ccd78ebba4702401d6562ce2ab4b21d55d40133c3173494e8573c677c7c1fee2bb4b2bb8214abffba17e0aa50c17fb40ccbf7cce45a2f26d2e85396d7aed1ff7da8958f5920ef9311f482077acccf5cf811f0a33b95b7bfc00975948506d660a24ac6d4e583a249d77b77316afc3b2aaa71dc75f439c2820a355029041e3f09112d1eb8aa50e9d1916b47d0fa31b3c4a6fa382d19fab29a5663707b032c7cd6f90f19f46f68d775a70f32c61a81cabb433552169463b2be797816869f1380312e831a09ca1af6be3ab19ee466509d8088184ccb5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
