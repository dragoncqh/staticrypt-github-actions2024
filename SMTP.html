<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a8a01d203307a39fa736e7476137a2288e3da678f4051dece50a8565bc2fb9399f1d80f66be530ab4fea4c2a6c8ff1641ca8b7242fb63d6afb476ad1d7232ea048fb8eb898e7c9e1446b805154f2e3d7dfe748db63ba46b685fecc9b661388c05ac28805d032e9e2a848c6d3b94aaa8e337305756818afe985dafeccd366b09b79bfeaa193ac34502a80a8f853e95715b7c0d77591e5c610adc52d4ba6cbf1134c365f13163b6941d13d2e9b4b82ab8aa943a69ef48cef24ce8d6818eb602fb6ee0d4c5e4b60fd70f96a29ab9eacc1a8655169a07b7f9bfb8ea1f80aa24562ed9896d0cc6a2a09b7a550e5f8ba711e1559db02859b33f45d44ef6ad26fe71c9c0b4eee03439d252ca40fa56e695dadcca2e2beb66d59b7af0cffc90900331e8dbaf74a536c4e14e1a422f40af6a9fe48098a2afad4cfc04ac4de351dcdbe0bde9dfee9cd083c2bb34516aa0afd078a468d779f7a76ad48664d2dba44ad9434b95c4a53c4a797d72bf365a246cfa02e10c943f80eab0b002d7fd2f614c1f83d1f780c3d713788cbde3109697ff518a8a50d3c412c7ec23baccafb07bf255194044919f42126fad5c5548228acad2c192216e53c3093005e8fd1f0a982bb269316572957403551832e9ecc622c11aafc90b9d12c529bc6e3092d037daf30c211f5080a856a7bd78ab561beba5c822227e1951b67c3cf8781f0378c5940355649151eff2ffa891aac49ef62404106f0aca7df34207e689b6f39842ef0daa1640f606ff54ce445ca602aa346b201efcc984bd6be90ef912afe5b91e446ae4583390dfae9243494ce5fceacda3933dcaf497865a35c8b190dd091f69e6ab211972bf9816e4f51d7be097e80caf58c7736761e1f18d2c0e7b658c032bd25b4685ad82c34ed0166906bc74f8b674381d271e24f3d50ab2887e6c08d8aef2eb6fd0ff32c8225b457efd6a40a782d535cfc8f7d0002b41c2a49d69fb1ad6a559bbc8bcf30b34c6d6c9806196c818faf07b2771778d94b54cbed1cd8c0a871002160053c97bcace411174a35124d10af7e92982eacadeefb544ba6470ffc42107ea82b8054e22e1fd85a31a2af72dbcb3a888f4f0dd43fadfe569c8a566ddf4536637a5548ac93e8e47b87a1a86f5756492f9a8c9363bb75ff63755995e5ac3c147af3bcec2b7044ccee08f0939eee8a9784171e354dbc0eee700591a302e73f76749aaf3ee1d41b1b0989285aefa0a70925334315e4ec6a16504ab5df9ff3977b8d030cebf51b716231abed94b6a95a3af17b8ee90d8faee1e80f81ce96ad918d83bd2a80b5401f33eb43bedb10a9356348e194df1e12be87b80dbe040d05300de55be90e81bdb4fddefdca8c9a49722502d763064cb7e995bc18f410c2eefe6403d3a533fc47575521ad4eeaebb566b1e7ac825e1cb0f71bb5839bc2c958278981db454bdb1fa481180345e732bb7fbf71026ee11a43f811840cab36a49bb3ebcbed2f85ba9c527574011fe628e6eecd1d1c3adc659b1d4c8031b2e19682e228e5304e41869a962cb0413d7fe6f009bdbc4ebdf87c9e3c7c8e6418ef36f1a610d25ba72916a5162e24481fa1b8b509153ca6fac42fd1d8086b51e9e61ea3b5c73e23fc379e4d9fad86c6f82a078d99dfe9d3be8c2bb049ca6a2586db9792a4a7d607e7fbd23b32263993cf9d5eb81a8fe7da42cccb089b1bfdaea0d7611c058ce084fc59346715f7dca49bc7e4c39fc9628de206bc54f8daea0d7e512e00afec1c0bf92b9ba277cae4d760848b93d3e55205eac34b000fbb81821ae9b3597b30c321c555dc9f4b8202ab8f5366bc76f9f3c4f71fa91dbc434fa7b33d296c57a744706742ad4e68f4f98f6989a68631df63787b97908fd7aa70a730f955f86ab9ab707f94b8f66b9a2c3086addec3effca2a6fe9b72dca1906ea7e8430218b19c2c808fa8196c8826a5472a0a05a64320fc7a00f8108a4c7b302fe2c00958863fa3053b5e1cd973e6d17d719a067eb69e87c36d4498e21067e2e3f9468860e7dc922117b42a8c6c0dc21e191c6eaea99b518f0fe744aadfbe50f99c27c6f05a697146c777a9c9a14d8e0155101c53bd932b59834ab2a8ea313a6f9c97fc1f86e16e7b949cf45e9e5790fc535a74dd7078a88c9427ee3ba8d1115a234e8a28714d06932a2a00da26aaf523578f8ecbf7a9c16f99da69fa3e00154955c6a92483d788eb49543f02ca484f1cca306511ca49484ad47cbf6844ee1b468a8ed2c95b8984c311e1c9115fd18b97bfc0d6dcb7e72c0eeee550b24c5b62c86661f5886b1da32a68ef6a6ae2dd9a9546f478f047079fd0372e508146246e8abfdd07dae40157f6031ae3e937097801f0e199d64d5d53f7aaa4d6db79c27aef9f8df74be68001f7f968380e68ed2e46858217437664905c3d225d4bd632331924b231129b3526a2b02bf8a99f832f803c39f11ce3eb27bbe611c6640f94edf2a556365bf2f68be5a9d1dc77e38d7d33bb32a34537a692d4f04682bce0bc32ed052358058b870b47464b1956a60aaf0a1591e9c0654b701c2ac0ccb365e8774f76e98efb8c59ddc3c93b52c1404be1c41abad17d57ab50639c4f5fd2e281e5813ed01c99b623f4fd80bdc6a668a85f412e05f825debc3f77c014ca789ad4a8a220ed91e6f56414d7736b94e86ad33e65ee73eb26b89b9813fb310ccd46403b857cfb554c9115d9a6e7729787f18a08595cdcbdaa984ce96bd258a85d323e028a689fc0a478a3bc6a2e52d743137ae04677d64e05ae0e32810fcc12c58e9dc1ae1265433eb07c6f4d57ae845d998f7b84d8e495468cb7c183e3f07c8e9710c7095bc592dc49630e6cdc78d0b739ad0e31d6c4fbf04a7405acd4dfebd3a98205ecabcf5b963d1fe67aa6c9afd356c237c7838542aae0a20c3fa9a6adc7ae0c4c672b26100cdae0342f9d2f3b001c38e1a925465eb5eb11c8c21fbf03cb560f24a37e095099050ede67cc1a5478ed919d8a9309f22c15b8e50084682c46acc9d57ac2c68b88255dcdd5b385500ad2dbecec47e1452caac6fed8d6578ab1b0d1adc0360292efe4323a9fb934c1f3387209af230ffe6d846e98f0efb156040a5e58050ac9ec4b61af8353b9e49bd15181437eabac763e1c3d0fab8e7eae2dde9acea8b367eb718ef6aab38eb7034db5ec6058a7a64198d5935e8e853cbbe09237ea3024ff046029d04e21bb6b65ad7d90dcc15ea91ffe0d0d286d2925f9534e451bffb645252c6c07c1f17d9d537d0c9ec0ab36a3e5b8a455ef757d2f2260c73c7260aec40b57ed95bdd29adaf1e2154bae19177af8710fc4d5c8ccc6cf1cecc2c9b9100454a774ca390e7b4fedc1c79eb6076345e60a9eaa076d0594dcd11493a35041d764bef3c6f9cb79b26e12e0e84e5806ac98937c28086a9ee9e6dc0c607ccd1f60c9b43baa6d625657394a935d4f1af82c6ed6e6328877e81ff9c48207d5e019de8526ebbc1ec5a41054bdc108973d6e81dd9a40f63d6eae98859daad84c65daf8f46216342278234776d4a30cf2992b6f22889e1a4939c6e75de57601640e1d5623ce8a31ebcc7fb115faa524b86f436d298ae6404bba72dfba7764a6faf9d759307ae342dce1d5759935b36ee7951e492529b7b5a457fb94f8c3f84232d32b5e9aed4685a49b76e57ae440ee38162dffd6eb2ce809bbe93362cf2302c42531f955183b232169caab68d89ddb90da3931f1f64f65b44517e50d01aa8f76c1cdbacaf86c684a4d4d3f271bf7fb8768568711f9744da504e9d7fee6725c539f9ac8dc7a4d48e3e03d1c4a3222b6896ee5f4966d6d5fb1d85cd1fb4d48f030a67ed6afab4d20c40625c56696a4fe96bedf620be12fb09a86ba7bd879613e08f3a928e67b4f9e28bb5aebe22ae27775a36f43f4906ab6bbb8ca6641f659bd10d831c43a911286672150160c7a30265d20327c5842b314fee92b4a9645dcf13cd161f46217b5df7ca60c88eda4819f37a2fc6274f91390c0037788e07ff70b8e6e1c81d8b9c9ccf64efc2cee4d0fc6b799f042321731731a27f3e181150fe06055bf3321f9730a20296598b6e601b7351ee106d7a2875b936695bc59ecda9b28addb5ea835277aa6f1322cd76ce31187fb9d8fd6c19deac17864bee330cada612ad29d9ffab2054fb910574281db63da28699e9cb4e320c3498e66fcc3c809365c294b58fde3cf79085f6cbdfa5419e576cf875e0dffbe4faf53763ecbb3dbe2d5cecaf8fc4e70d2ed5205f52f51dad53bb0b14d209349414b039e8b6373ac07eb2d13c961dacb9be79499e57dd6a259fdc4ce83b45a718d7e1efe4e01a0eebb3f4b02d8a0aad3c5f2256881026a13bd5ce76b8c25bea9c647798e3d57c7c71ecb6d0c32b0fafc3a43d17ec614216c97c314a3001b451e9ae98a059308ccc4b5b58307a8dace89c384fb75218eae73b0e6c885a2041bb20d03a76449f900398f0fa2a5d2a6cd9f107d42578f670ba498d441c42a24d00e940a51d77356bd92fd30f5bca020810dc16c63a422800c8668246136da935c31905aa76f4f88a8dc633e764722e23d828cbc2ee9299634f6e0e4dd5dfe5f43bccb1a4d9687a24b4b4cfe66ab39e790e864f88a75638ea6b523c7c642a30f9d1f6f7451fa82e0859f57fecaa6c504d0a63043a0816ee7614a26b341dd8be9d8bc4d08984b2a9b8e39fa2d604436fed53989b1178a23c1e88d12acb1e4238967240b10a7691d261036688e5cd19fd9f026620f8f692f4a9254a9873724120b60eed8d3a61ad704f162ea5d96aaebff4d46aff1c7535979944396dd96bb4fe64b2df1affece66e67a615f262d14c2feafd51e160bbcfc151fd275c1aa25a2fb3546d4f77998eb67a3c9f8cebe1e9c79c883fc7afb43c609463d58fa75424710682f6266fdebb9302f7bf742aee303718c459f8bbd4bc8463b8d4ca071a34cf71c096983347c1f2144203de80cffe899435ccb796b6f503f2bf66434446ab0d032c1966f30495618cfa588e65ed2024b8ed817601b30c170ee74f4838afd61d01166e987f2b0a65b04106e598e2aa586afe4dc0b5137ed262388c5eab2ffa9c001ab2172d70483647ac627bbc6f9a868f72bc90f117e5f7d781687a041c2cf4f3e0c9147c52c43dbd2d50cba7e3cc42b6e4c1917fe32cdd0bf7adb9e715c7956924ae6e14b9f5454952b5bf925086392768f5b3b91b9104ffe19eab3c321a2643a4eb6db89f892d4b4f1050ac65093918f7be16884b166ee678c82a3e64306cda7b5e27a2a01815b8246e86bca355d6d62100c809b54d06028235bcf2fdb1e3d2efc33f5b5040b7d6683f28f2b8ece2b88ab76760bfc95cefadff434d6115ca53815501f5be6022ef30b335d395f245f2accdeeb434207d393e52012ab748b026a82f4cd45aab354a0b93945d80b073cf82271fa639fb182710e8898be9db1c5eec933944f99e10771350849cd80f2a9b1dcabb260e1bdb3b4b08e3db8640b608f794cfb5e728066bf49eabccb11983c1bf1d6d0fc64e6db9d7570a36193aa8e9175ab889d42759e59a601d078f9626b0b3c8dceb93fe2821665dad7612890b9bddda537997322d90e4261ed78305a08e24be74130528174bfd93851f71916a335ef8c126683fd67fa6c6f6b17a0d1d9ea4e4027751b455a03378044be6d3572eb7c0f05713948c135095cb2434a573facd3c707fc1ae3d810b89eeefd24f19f686d29c218cd13561c112143f095df0d496b26e3334793563a1ef31701ab8b5fd3562fc697f3855f82b2f56dba7548fc2ac92a3f5e386b96be59a3f8a8d3bd547824c69a6bb2335c7afe7b0d91011d049c2f307c51e268f759942ad95e9317be246668c42c03873725ce1059477aaf08dec5ed9a08ce1461d2b387e1f45e212a010d4310002074195afe67c6edb0cf23eca777f9ebf8461e586a05f2f9cab314c6dfeb283299eb6dd58a7795b31f4925b9569af9ff1e546ba4942b405adac41b10e50d4d05edfab098a23ed4b5694d4bdf34bff2d375005485df3d1cd264663da3a6bdf77101fe24fb84da57c589b58191c82be2ea74666b7a2af1d2f4dd40a4453e6dc7cc6d9368340c8d6f1db90985a8462387b66cb0600aace71fc68209166d5a48709b5734b62ebe6e1afc7358ede2a5e1652d63de487999b165e3c5a6cf6b57d0b2778b9225c66c75c93dae93add786fceb82dfa6e3e4f98bb5cba55e3d4c0a38927e4ab953b7a2566a6702086cc3842fdb231b94b768fdedf614148042f978706198572ee6c65d7c7ad553a970da92d61b7ea724b5f96940b3819d91fe2b149161be9408a46c43881d4ac3279686b5a1b74386029fe078c881b8d7310f4618e0ddefbb41878eb8c7e4cde3bef50a2c3f74f14843c1bd24ab69aa65762295dc521a1225f20a260ea5bf532ba4ed9064941c07f24a9b7b9f44aadd61955333843de478696f5f85205d41224407f33a9ad44e0897a4c1d87a66ec70bf1a1564c6d7a37538ef8c852f38375280b3d96e93f77fc1c3df344f7b4a73a75cb2e7c6f289d38375fd63dd721d1c6557205699e6de123c401435dada6567c5a3d613ea8e6285925ac87003eebcc2ca8b10164ecb53501d55131d397c5b364e84d8e03a37c43edf4914f9dc53d2ea138b461204274a307bffff588c1e664f8dce7ab0c47b4f82ba557361dfd983a5c84976f5f4b21207031c71a3e2ee2bfd0b87249aa7feea3c89fdc5a53500faac22d8c9943488284655663f0e189dd60f9a5d0b14c3d409baf6d0d818fba9b99a8594c3083630c1d5b5c539d99c92a614233536e5784a7ed2d0df8a57e3f30f66a10fde5fc819ad63b699d158869e8705e9c46e0d6b57b029b57f600f9b46701ffec20ca8ad7d932b7b3a517a4686d8b0f1975f3084811b00c6bb5a952d7fa902b5f795cd7b04b6f854c8f5005f729a1c0c5062936994b88616c50dd6711a93e30f8f9d6b711bf599cbd5eba17894abcd9160399407a4dce4b8a96ce79fe745b3866b3aa7d9d008780c4640c11233a33490534d0048c0a97be002ec12961225facd6aaece1fd4dc98f645fcc2f2faa8aa34a4cf29ef93f708263b113d6965a3683878c699675d56b112feb21c7eafe8e5a2c37a0f71260961747f0bd6bd01584c0e68314e4673166160942bcab2953c54eeca8adc28338c7328faf4adddb84d07275f9046f8e7ed442b0e63cbbdc7ef3ee7eaa27fefd5f0a996f6f21d065405f0ae31101a25d462031a080d743fcb446324a9c4472aed097656e26ee8f85b6a7ea16b9b7b317f4220ad39949db473d591c1e5881304b5cb39310b9fa96bc87139d7840dfc0615281931d17883d75ee55e7dec6ae36e6ba168888d9ba6d8d4dddce238694b90a2760fba48d1eaae070ba4a3ce9110b866ac56595716903a15c0006366704b47577de53dc51cc340b320db91330f3f9a29422570001fae6f665485e937cd212924fd117c4324e2a5cfa37352142b50576bc273fc9ab2af52e02e9f6af9fc2935c8e330e2335a40e9d8b96f5af2ae594c4b88a7e55e88d81c18331732ed14da66a387dddb7d303f03066d7f15a47d2511229443ce8af49d1c12d8b07fa365453fefce92263c514dbe9ba54dcf91fcba651b83bad3fa2ba31b20f06ce0a1559e4f7f0c84b4d9753e57878c611df86bfa183455b21468fa17998f263c7c701266319895bab5e01999a61de236f1479c7d7db522a572dd7a9c5757e41c7171a35e94a0f1bc82f7b09044797dbbd16524cd7eda7c267ac916fdcd087a22a282ddafe6f85185a853bd3a29ae6aa93b6f8476721cbd2ab16015dd27bd511b0bf9ed329ff3a95de88c973686ec9e916647c7cf5c5281e3d35539d7c51c116fe720eb7df501ce90fd1c2f99a9002e8cad22e2f439e2c6d4b6fbdf0d06aaac7b6ab33d391c99be5103fcfab5c911554b10282d31bd3d3bd01b368c64a6002d90883fd9baccb278ce88f2e2c33c2dca57dbb71015c87e295e1aadce7be80d72b022a5258e71a65989bc446743782898fe577ff79450224465765037d4f01850d599348fe8921427c5ad2913f056cbd58aae8be9997baba255f4098d5f0f5912253d035fd2c69a3ee41d62f5552941d017b635c7165bb26b115849aaaa48119f562a097fb780871190ad819659dbda9da7be13e3c14ac41a3c4087747b98b0b9d8907db8ccf1c2b666fca131604ad34fad59aab544404670d6dbf391272f2ec2562bf942ff79f81e5ffb94c16a09e6aa63332b1e869b6b00d7956c7dcea8fe8005437d2097b706cd0ef778764d7bbd8ee5c041d97651c67b5e3fbdb5ffbf75a901477cec5b3126154be83aab5f492fa4250528d078b2ddf506387f04c3e7ef23298b9f0a5b50f704172cf31bdb88536b0e88039d8187a4369abefb905f0cf10cb18c1e89d5b49aee64075998cdfdd25bc6be71da7d107624476c0cea9c033d89da10ed5d3f99279906b9aabbf9b99369826a4e70a666b2496a245a579116fcf95c7d09254c99eef12236e6f4e1b36a7af15933a407e26847ab6cb021816287a456c335d2ebf0f51d2c1aca99df7935b7a0188bbfe2776a2d02f8bcffbe859d2fe51b33721889c48e9df2d02e30d2bc928e59111ce14b36ea2aa9db0c469d84642d6aafe8d32a5cf3190f244129106a8689ff61dc1ec03836e46f76396ce4121935cd9245014a2a96e43194553b2367274d2ffd0f0c3fa42c78310df9fcba36da3073e2a15bf0f496b74e746b94f3614cb216fbeb6df06368a5643bbb1127184ddc42130d5d95071e6154941e8f88c0bdc0f11a025240d14084f70afb603b6b303fb3bf7d66204f383b516df3af1bf0fd16ca5a1c830ab392a1cb58a97a99bd8fcca47148018a68da35b0b1c6d0738894e4d5af146a9c9777d2b1b23d221098e30e074f4a7334ea444a2c2fe5880ddbb105a445cf3df7a7a7a0d84a536473f7ca31fa1251fe6979d7ff455ebf10fe835713ac7f6f392f9fc4f4624743b2a085adf73b6e79ad0c67afa200c052dd8334e822cb136a9af2c752f634343f34309a19c3e9de2adb9ccf2b10fac48665f4d3e92c58ae8aaacddd8d94baa1d1bf051e1ad1874f6c6777a0df9fd2a3f45fabff721002a07322d22d636e08b82eafe7c79e3477feef440854b93a01563b516b57c2a28f42a7bdb3fe4dd1cf1b50a4080cb9b777109ea32d38c0d20a943fe958ba1e4bceeab6e5254b1c71f4143ce0934040edeb661326a0b85aa305f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
