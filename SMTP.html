<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd4e51efcc6c2dbf7ae0195db14cea12c3e57ad32698ff6bcf66ce0c75c43915bae04e25048510d357e7860821b1932870a96db705a137a7cb13c7404b8fc6490bc638bd601c2e10a49eb11f8f016f4ddaae2323e38b4f6e852e0e6c70444d68382cf26eabbe4ddc9a0f3a1ccf7eafbac4efdb622f32c8f47e13da393a3f5b06aec1ac6680b7a1ddac986daf50860d2746d1f924442b29e7625b0f61b124575c3b8312ecbc6db8e194a2a06c9d6a2247450f7c0eb1e65ff05ba1a7058971ea80310aef9a2fc1f045d1b7d884a21b4345322b215d670b3aaceca985b148b6538f14b50ab63b6e4144eba4abda29709f79acbae340e54cb96df61aa8571883a2c08a5d4453c6e33845b9f8088f4447d94ed1d60d8a099a769345452b02b7082f0c2841fd9e75d2188a0cc452a73031e75653470c4f06019010126eedbd10e4359defcb70bcced54b7e1fee83bba66399cd71ab7922d0422c3d8a45d89de878e0477c2df1910c8a5521955fa5def78cffcbb0a0ad615b0b867c45636ae865516f81938818058e44861b840c4bb2db3649d0b47266c28b57d2a1485b69da2bfb3035164453d75d9321698c537a33692de05e92a73ece4cee815f951c8225f742da82821bd360a73f1c2dc0167bbdc9f26a65db015f3e4b37dd1cacf8c0922939f29c36090ce3d3a88f5125a05d6225ec9b3d7ecc26c6346ed9929adf54d620a2dae595dadeeaff1412503ed3862527a323c13356957cf81d7c4df5352ae651efa618390aaa3baa96143b01e22e4fc8354fffd840a8fb7c9086a9c548366cdc414c5bc2fbafae9aef9cd178711c3248094286ede4a227fe773e67b5e45c7f0928f75a0caf92fa64c1f873afe816deafc267ba592a57e72ed90295f4046b01b049e537229d0828f1732d9e85d2dd1d034b7c7109b0078866b4dee7539b44433d0565d768ec6d586ae728d879c52054a4fa3ff2c9bc0bcd162f32c3d3a103eaf7d719fae93e4a346945ba8e33f477be35bca9517d4334a1f0ecdb3c5c882bf5639ef26cfed880e9edcce4cef1873bb064df66b6e6fa1c528c6f370ec9020aad9edfb3b766b124801ef2bd046ef0276dc33091cdb300e5c2cfc27fcc7ea7a849eea4ef495630310dca6168c7cf4264969a5f3fa743bd88096610e581e0e78a20d81c71a80b1b7a933ada574d80588c44e9095412003a2d07defc9767e27bae63eaeb27f39d1bd05092eeaa3a27ce801affd4de9d4b47a46d8bff087de3abaf5d61e9ba98f151e7ab95274d6e3f5b7cb95a6bdbc0fd3c6ec9947ce4484e8ab433b05d2a44f7130b7bd1cbc8971f3f440a273b80d3c7cd91a2880fd914662fd54d79777752f58ab64d353fd075f0d0e1105f65fa4f2c2fe7c86e3eac5f71a9a425b9e5fb794d399a2e0d2624f247f227489f0f79b0d0fa502957a6cb432990b71f2fd97193131ba18ad5efcea055df48b43c827b8d45b4b1a0ce2b3b5baf9a8dff9846c28901617c7133cc19b1500a3fd480d02ff66a0919e57c33cdfdf3eb1c315dd3934497ecb824e9b503234a3466b41866d3a4ec9c13e6c5edf8f41c9d99daf0051cc5a1f55d7e60a196be209d85af0e05586b2913e67bce9f9bc933cf5b2612af348a0d181af3b474dac51864fd6da99f85f028b5e9466d9166146ff9d71b170469488e7aecfaf112425a2302223e985f8b8aa9b924535a472beead0eb04e63fef9a23fd78e62187f84d4900d422d63b38f53c52973710909aecd52cf583bf35ea8fa7265d10f02fcef630c4e6096b9bbf168263155bfaf175ea959a5fb9f21ea1b37acbe21e7554a9aa19fb49967fd27560280a08889fa046c829f7593f910d0df3318957f7e968de8a0238b0f91392e42a3e094c6a2c7996b76527748f39ac79631b7d64cbe83c8ed6e8eec71807f4b19fd7646407fc0c87a0e51d66c63b9dc8c1f316ca7fa7f504e519a28cbf78d7a49d1c9d07a23eed3a387fb5cef868b631fb1a888b6b649e443c20f5c51266a0e4f3df3ec80612a733290bf3c2db97f1e9f2b82fed5b847342f7c71869ad60ace02e6fcc5c431b7264245f85d36a35fb25b2903755264ed1290119372f74f163a1f3a9b7207d3010b300af122f5ea1e48f01747dc3d4d818e49d12adf1fdb9aba8d2272459fd7978328dc7de9345162dbaa61b61dde11fa60ca9376bcebff90be8ec7bff69c324f01f990e396fc93336babf2a9e654d8414e6dea4baabdb30864c0b6663ffc097de8c104a670b9636a9d35b3bea0c89f791caf1748da81174b96d9d2037e3960ddb9892da73bfabded767ae5dcc9075e25183820238f0d00d01d69902b90e677ba656686fb3e2731063fa009ba00c1270afb3b71c724ae66e55a3115dc4d97ee98c73c5c52bd9989bdbdbf68132b805df2ddff4e288330b2e4eec3149805e6fdc0c461d07807ebaa060f98e800f2577c2827f1df107cc247fc0750a8deaf1b7a14a9aa6ff4c7865108fa5d36c5e5edef07acbdb3e21ca4fec5a5beba5021e063e772fb7c0e2aa2ff18fa42e0b8bfdb5360b8af679c0198dd4430111c98c05ea449e4845c39067b92e756ec3c7e3ce84dc28875633021a84ba43af1a8331b951a185ee23c479d005269cc33f6f6ba26d710666b832187406879a8329915202dfbe3a8db7840c29688e5f2331b9288469948aec8b029d6b21c37ed62e3549d4e9539b02c0c97821eb3c72f0dbc7d42b8f7dda93adb7a094685a0286bd3679e6a3738b61222c04662a538a0c144c35ecd354f6beb8343bd776c90178d3902427bf184b46098a5008f15402379260b94887dea43d0f2cdacb66cea15c5858d0b0d8d03e68f7b58068e2c776823cb9732f4a7f327efe801b1fef41caedc4d5246b217fb483143570c9992864bea9690018d11ffdd222418a0e49a4dc7f0054442c19c7ea49cb6b6e3270b97f30eae266f26444c73f3338cdaef5126aa4b6ce259c647110013f0aa4bfa16e5963d688145fd12295b040d3a17c639e57dd1d47cf08bfc80951c740d32eea3f57dffe2329d3ac2d36fbe082d5f974f2a6ff7246187f26921df8e4d0591914b2ff23addb0161890bc721a92d66a89ed0d55ba81c457b9355b15f82844b57b926fe1d8a7684685baf9a19070aad42a756162503023ae85fdbe4c6ad7d0c20211a051868b64a1047b727ad3fb9ca358d01d70f29b32a55df6db5010f38caaecd085b1b32216e3b0fc4b4a041ec8d7ff91c2d6acedae775965557d55a47c9f362a3b93af7962139cdddf9cfa347d84fd95e9ed2a5c4a7b6d629bf70eec4de3a6e9ad460de9c488360d67e88f1ab18d4d2a1bfb5d126e7282fd7b83249efa3ceca2c818e2e93492ab6f33e136839a54744f5ffdef7a6cbf52f5b5683fcf81eb9effe38e522aa4cd97f3b43e0b32f0606ac71d672d5b7663fab9e7246cd53a6f4c895eaf7b3668160f02f5569ab2c33a5c03ff010b963fa9270b231a2adcae2516f533d83ffc071200f8b4c79b467803e65839513f3363d0801405bf1b7de0601abb3113c95214ec2b7a9a812b3f5f3f03a559e6d3dab040a25b58ce8ae606e7f0d6b692b28e516fe0dec7c68985c3c0319abe3d741c54a1026ff1c8ddf244f396c0794dae2a19a85e7b537a8f00046aacbb6669b2d00cd1d63cd3accb2babbd493fb553f7f003af35fac1eddd98f30bcee2294fccf1740fc32c408ea214847480466db571b214fa55a14ec6e82d8abab6897740fe9df3539484212f26445200bbc3b511f834078ccfe8d1f7b1750b8f84744bf04ceaa4c0faadd397dfd5ba4a1c8e282916eda2bcf8660a0b120da5c908e0575d4ce48535650114446af9cd9b30177dd0a8161f72ffe96cc68926469b8a0e9ffd382f306bfb0fd3ec2b1451f9702ff763b135d1a583a3df690ab0c179c509e33073d5ac60ec1a41fe0e6bddb1fab86ae17a5a1e2fcec39c86e552dc5ec0f27becb35fa2a6c799d81ad4f0d1677756ff78b5e4cb03232b04a226ac1948f4cca97dbe115966219388d8bc56d5542d01f0d5443d414bcfc8b5d6f5261eb4a7d636b143f171bfc8d685f1b5997bc8a420898bb38b4c23a9880769fa3d6710b92ecab12346a55dd98cd969f74591585cbb0708d1060b0effaad91f7f2a5dd0263a9efcee2e25a61ae2633f44db55b1bba245fa0676233c1647d287bc4f35d40b6f972cfa63777e390dc9d8337361289a0d71ef9d29359ff8b59579dbeeb40e7523ab77d9892c4f92859b819b13b53862dc4f872ecd8acf9f490f15c81a9b7870226114a42596e6e1ae89c58f5c9d8bfba2eab44b67ea7c1008f969aa7e5f7fd7b01c503b5cf9112d9276457268e7d785d773f5fec10ec1bac1065a9e8cf91707150e658db8ad7dfe12e0132560b61e76a228d8abb2b884eec92d6303f6515a3de87c0a918f4f42de2282f748b1068809ee468449992f83bb6b249688121846633132de0bc9c28b1281f43c6d9925389d37d4da6e5a30a0c095668c72734f36a47a5bba7ffaa68024526cf9c50cc3ed54c77bddd527f02e2658441a5a93075ad0b126cf7f16a30b6f4bd23b6dbf2897eb7095409ae10b65ec9faf135302b173e2d2c8b5e30c6996b2dd93897e0405b88b0ea84311f79954b800acf4e474e691806faa943d9c237103aba2536d96b020f2f50f35f8b924a9cc8db2479eba69d4ccd7c4e31d2995411877e4a04eb343e05bce179cfbd28b0f82f209dca06e0348cd364a82d4f319ead6765c860ef49ceecd31d6476b9721c0314669defd0dd0d2afeebe841d165ff6ddd558b82ef86974696262af8f136502c649580e66c540be2d71ab6a50eae5808d5d6d05f11b871d0efbfb9eccd2e06b78af0d7ab94760ec71ff21051db00eaa495f5495e0de712cf056480aeb1218ce0903a3f4b41b0ab0b46a71a49b932744289486874f78368c603f808e09fba0dc14a314f02b92a48474c01ea809542d5f0feef1be9fa846d91305bc81155c18a56d34dff67e3a798025558198e21e9e0bf29a96d698c1d4132a2b07e1deac319d00a218ade26ab259b71aab5f2a0a92c340477b89bf3842bdcddfe048dbf91f752084523c1ece0b6a779f7cfeee63989ff3edf815f07219d3cc034f36d55f8a8bfaaaedd8a685893362aff08de7766b049c29f05ee291e5adec75376fa128884b46106cf814280c445fe04c9c3801acc8f88e2b9bbf2f19a4460cb407a457e5c50d58cb35af8be6d227447bc05973a493bac9a13d9d2b028b1258f41ff1b01ecbc0b0a676b5095ec1bccaef669340d57a803544b5c72cc26b6f33ac018776f2a92a44c19d3c1ec905c5b98bc9c98ed68b0975349f6c48a0b014503eb7ad68d290ddfc22841299b71156cca1c2e91a8c41d2651524ca816e23a6cfece771476b73c55f57e67d3ea6e7d7f23fa32a5cc0af9b3821d4599aa922e1722fb524715503e7756a3554b81fbf45f9eab80d3c4f1209e40fc4cc2ec687feb0331997660723bb8c1f2d9ef3bc712d7f289aee8e19cc5efd00a6764b383a221971eee41b89f85bab31f0dcc560282de90d8d6f0868bd2609a5f3784dc3e120e2b10423bbf732f767326e637a244c3e5112aefe7aa4b863e98f23d1e91e988cab547f9d74771394635726799e63f67e37ffd7413e51e8ca6935f3205b1de354246b435cfae7549ee5e820bdbdc1045529112ab8ca99e6051bb35709860c26c8bdc3958eb3dc5fc5e5a76fb8e02c81fb98100fa2eb6283e3127bed131ac2fe79dfeb1cf7698bb8d85896726e4a193f997afc7321609637ee6d1f4e477cc8b6184c8eca672d6d28b47f212bbaa1cfc58298cba8ea62165b96d110f131fe2992021df52b6deb026ac91ab4c05d548083be387787bbd89ba4d21962d1ad23fcb39350b3dc10d867567eadf0a6fb436eea183b2992791df17757e45c24c9dae72fe25795fdc7066b1337311f3363fbcec326f24d166095a01db5c8eb4ff1c26529c78bb4a763ee3c62ca73f550b32213f4f2b8bbdb6b9da10affe3cefd9d488b854566de7e0842d16044697b721985033fd9ec5864d83cbf18850e00ae581818fc11bbc2715a69099854b8dbe91ad186d6ce7b17596852e490d5c55da6fae3081d63990b35689f16eb75c407b62c88b72172e67095b32d9ebdd37522ce7e8c4b46d64e5013f146e5777c96fe442329937fa9c967e8e29912002cf04c6df2c352fd3cdbd23c91f68ae7f5a9cd4d9f18c61be1eace688419b38b6fe68f3ec4a3f163bf3dbd9c3e3559818ed47144b98d3c030fc11c85303ab67445dc7c1795cfafa92fd73c1b72efa7148a4b1e3e4a28cdad8995cb5bf0734bc02b9a9528b32a8fc05cc394899b2af990670996dd70ca864573968c3b24aed3cd1c6587b06a8013773701ecf363a0ed42e64723d37aac4c4873b62fd7110ef2a5c653368678c61b779220e2143bda9bff17bf2405e70ba2e83aa0bcd188856217f51d11e303538b570e90c6fe7412640907303c7bc81c83171f7b4be9ca983cf5261479bd505c26cf354fb8e5847fd9745429408f4bf7e6362aab02c30ba069ca52483b95fd10ae360245155907fe0b00ec87edc2f4486cc93735539777e88d840fcc53197eeffe94368567763676146a275d5932be575d423c8042a4c5e6f5f75214441385664dfbf1c42379f31f8726ba4726a2d2087760b685c6fb81fc5286b73673566c97141c9b1930eb341f19e0275998bc38a0470860efdd1d5008235f624eda21e41029bab6767a0dc70484851fc2e79a0b7dcf3263204e8cb3378c0325348451f588fd10db4f42d710a3b1c83665bbd7c77eeb5aa6e08570b723e6782279066dea86abac33deed96a729fbd861ea2f58a28e73ccd7fed8d4c877be3c243ca8a6cfbca01ffdc4480c1eba1f78863e9906f57184ed2ee76892dd0fd79b05c996b1ddb07f039701c24955e79fd1cd1bc702a722318a432f4288cc78ee83f298e67ba5405bd2c9a041e6eed28ec164c8942fca1c3d4c388966030170657270639d5953daa32ff92f7c0810c03a5f9c9470943b6988ae3c9964c61bc1915544644cda7e232f127895a4e8a2b9983d10e1a8f0e69e68d8936e93f9dc72b23cf48fb181331a996b32de2fbad120744403f67e8cee0aa5576773e058fe0da250e2296a8610a60d37f6afc5b633db5706cf5f84a2ebcd8d5cdc7912703e7f0f986c6f8e2e77de74064cc66af596d89ebe644e8c026ecaebe39a44081f75558f5820d2ba1ca5571d72126ac4f051e550f6055707e735a4cd55e869e58fffde3d9862beb020b15fc9ab308330a39d89bafc1901a92ba12de8cd2e6fe41142143bf0e00833e7cf8febcadc81053215b6eb9872867c42cf5c3f8a6686037e12a0ae85b078d1076edabdfea9270ee9df04e2f921dc6e0683897041ced3a0be4a1442bd9ed0527853d204d526e55737438c7fadda665e7193969536a2525756bebfdd1354b0ec79199592500a8a9f2bc08f3e83a10f2b75246f1216e77b1a2069f0a8e7647eceae7ee20eaea8b69d5dbea01139529687c4e0f97ab121f27594d77ab51daf9d6f4772e500a0b34ce52bae4266e1afb7e4cbf3070149822c9f349bcdb1ec309c24ae09254447eafbf63ac4ff484db92eb33e614f902d158eb88f1b497bb1c1b8c351f584f2a323a84d82636efc2f39b1873cd73bca20679ab7c765b9e46437fddb41b7c765e29adfb94713abfbf32e5c60edde3fbc3f82b3781ff17866221e6e31b975e878da1bcf3a340779498c792c5ad518b253471538d9661f355e6add83c31651828fe7156112c1cd4333ed17bd32cf1f1b0bfabae4df8cbc16a82c3d4863a0b3640f95b4bd6b5adeedda81b97560d928cdabd1dda14b5ff9d17e195beefafaed6902fe977df91e6e38e4d0973bfc21b0867ce98379c9ab6371179701e36de4a7fd9fabf323b25cc9d373b3c746d8e1d224493d6e914aad9d751ddc8ed11486012f9ca65232a3d89061dc9e5f9dc88402a9d7387b2f312abd23290baae38ac64bf8a2730f87548fbcfc2421165464ac4fe10a5c1d5dba38d8b302edb73fe1b1f261ad8312449a3311907e7cdc5595febe9a02e653e227c6a7cb0ff80a8c7acd31328d60cb136f10063253686f4e1b89a605a02ab666a70f35952ef4ac4beb4787326c5d802fd69ad48442fb02d55b4ca592287e6b0aebf3247ce1c463690d8b1745e53cf3a97edefddee84a07069db8ebb5d9c7d65ac717c228d4a2761f4fe347ea5f7b8234f49dc1e40e82d9d31aa89417d5e6b3a6400878e627efcbf8628ff4d680d73d59db70d58e5a0edcfb3ff9ec8fe518f7d82b4b444d9d32efcccdf687bf757d64d5ac49393ea32aca1c699f34d167dc04299086a22dd57076fb5b1d6eeb650ddca55b2479626e772334a1124f66367138d4a3941b41378aac0ff2dc174fc2a36bff744f734d525a929b0653b7616eee79e1c7a5fc81f2ef011ea9d1637ccaa91944fbf9b839c43586a220af70d01a1220013b4b4d9d12ba190c92dbbadcc1255ec0a2716bc17ddb767fe7fae3c1cdd9fca401fd6f379c778fa5bc3dde2891c752fda922e09d1d702978cc2a122745eebd9ed9f75bec87d7ccffd12b7b7ef7b45810610d0553dccf19fdf114eb2f512603b22d5653d16726ac0313af77d5421b42c62b24643d4904099a9a9797748050f94ad32899962f256e3d70756407576b483fa898fae6c898ab8ac612420e052ea55fb804ca70c62e9caf0aeae4574e86698d68578627d8f9ce3fdae4d065269045add522bec5f87c19e9b62fbc5f4816da8b6098163e925ce1735b70114b4efb20fa200e5d3b630393ad42967380d2b8b53d71068ac7016dd50f4c8927603a512aecdb72eaa05ece4772e7d3c4166aaa96cdd793688957d7fbbd6e7eab14476f23dcdab3976e2b0c8542139551db406b8c089e909e43edb7e204b976190b0f2c0a8f056f95de5d8b85477862ad5de7b7ac7b43635042679dc7740bac9a68ad71bdf205116e5fc4a613a683a180893bf18cb4c3a3830b59ec9258681235134de8a02d545905e9d22a64f92878839d644b2ae3f1c8994ccf5e7002aecae2bce357396072e26fb992ebe0a3ea1055de04884878639e23ffef966ecebab3905dd7be5bd66de27a5044285587d10d60e1090941a6a355a1861302fea9552ccceaf402412d6b4986cd522ab5d7bab9762bd22f92e0001119c41bc9143435f6c386f2deb34b79f96c186678524833053163268c9546e2ff2f65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
