<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55a633c9f1130e25de52f6fb5c9d8d2ae7c487aea43de0395a3306620856c2e8518448a6328d3155d5a329d4f118f01cc556867df959ca23a44aea7710d61c1f859d970bbe5958ba0c141f4579e12bf797bda25b6424d7f4e4d125483feb5a3a496bc8caf54be08ab792d0c4b9b9db28f2b1fb77ceb4b8469b47d461899df5cccb393b66c5a6dfdf9b900d21cd9dda6b9b0e1efc4a0ec601a9c97ccced358f51bb2732272bb69e867aeceeb9b97cdf78b86d3747438c7bfb52f2fe36869b865ffacec3282532b25fada04d2afb79810a7fd71a19bb119eceedc7428bd9d130d3b6f67f08372dbeca394644b0915cbecb15a664cf471f2e1c380bad192a76239e1d697956eb4ebf140a0a88bf9303ade4918297b77fe80f9364fb37d6153deefb656e5b243c2ead42f1faf8b24cfed1362c9964e1992b75856af4ff6776b03c207b0ffc87925c1d1d1bcbcd8b59a9b3d5af30d159c2275109ce1bd959a8b9b8a2d7dedeb984388dad082d6b2f7fe973f1392e5abc86dff4b07c40b2dcdc3c3d7fde82df21ded3b35609bc62ecd8783b5e8811ea9e034fff58e1cfff26c59d33e11500435b9baf5e2b4ca2c64f3df4ada8a63eb01df0308aef43155ff4f4f8f80c67d409b9c7b10e21dfe7f1d88a51c3f34a0f8d0a236aaae254568b994d6649bdd42e66f60be540d6423f314f629329a7acfd418a39af2fd40e612c8019e3cc4545a740e38aa90e9a434487b7ef24f0a1802772d38eb45abbc354ee4aa8dd8c36333cf8c4adfbfe9762493b61814d750b76ebc7ff5f0622b1855dc015422f157c3972e9fea259172a71ab6dd05cdb31995b8f43c0ba317fe6cfaf1907ef6feb4aeee8ff435cd779f2cc2ae097c03f626268b208c606f1b1c6d64ba4de93c27569590891a157bc50efde5b26ef7b1fdce778899fcee2ab5bbba38dbb2251083bdae57c8eadcce52def541e934f294d53e11b78e047d00ed618b44ee46a56711a2f31b40f161b6681aca21c3903688b28c404a8194419b1ff321e8e60d84b6fb914c251cc81f0d88c64ec330f23e1e198edafcea8d1476d131d8f5a28127812320ab66f7b1af63d7d480de18e076c0e87fe625f6213979f8d88edd0ecdb009c26a0468ac6bce1b77b88362e63da379ffbec5af121398db0283279a71d24604d329ed57dd1d250775ab00807a0c384b5e251bb7e572259f865b0a6988383b6a32fb0d3354840291dce291c08e88d59edc0b815567fe0cbd81a6178cc3478db804d41aeda5ccd613c8b6334c05e0efd66817474b04e1b9b04e8cf99fe5d897d273829f52fce5f61b26c6a2cc9ac0d50d9fc108bda8c60d801d2eaae83ae60b9ac647bad67be06a1cf37765b1643cf9e5e8a5092b27f932aaa4ee6f4819883b5e7461e1da16a232e5a01f18ff712c755acc3c51923a93f06ba0a0dcd339c95c5f1a00047b03752eaf80511ba4351ebda285b004e317d74fbcfdbd4d869b8902172916d39c89025ab7d56b3bf60295388651bbca54102bd1c2023d4185d05231fc1da11ceeb034d57ced20d968af51fb0618b410e126f2fa453789e2cf2c842725d73f1e69e4a3520a6b6445fd8e1583ebca25aa84e447e2eb86cca81f4e7d898500983771a8e6ff4c13a7f03cb9e9ea66dcf043fb41226bf6bce2d2f542bbab028429f7170b24f41be3caaf22ef3de05b4664e5ca1fff63d112a6410b5aef2ba992e3b6348ed8068e57de699e9dc022675e929563bd48afd0409014c427396e2b373e1aedc140a409492b50b13a40ea1bae5391a2e6a39f919cae746e31b7b2bd8f3b269bf1b9c8508d863114e7e613adb236e2e84486a13795ce306f9e422a9a37cade0f430f7f665909c0de3dd6588cc72824dbfba38d834c2c14b7a24f2472839828226ca75c1a0fe0110bd736ed6599ed754cc799858576441c0b60ba73cc8c4573344fd6322890f6c6aac38c365d7270b948ee7ca142c04c313fec2e3fca7031bc07f66a40fe6c620dd37fb51c6a21bec0adae941a123ca4d565f3dc4da294e4ba33f232728bba471f0f844fb7c83c15e3fa37d54a60d681c008d082e25be0241f202fd54cbddb0bace84e0df58a5f0d39edc252746fbd9bc53979af34cf0858c42b2187280ed54c2fd6ea2ca4774a194489a9c7c4f30c5770d724dc2be36bcfd70c30f5c1ac2b49eb0dfda590a728f220f912081a54f7ea5bea4c1794aaa69c7be9184a95c624c0410b8773aa095590b822cf3c68631a5cb5a816c93362147f1e5e748432d78562aef4f95c514d2d43d63db36aead98455a7417419ab06dea0a51e0b843fbbd493ec68bc9af6a3b6688a048fa3680c6810a2b4c06b66f9885ab5bb068ced2644d99d72087f96c26fe4df7520eaa9cd3c43bb4b965604663bd8a42895ee204ec83418d4541d74285c4db92cde2aba74a6de0aaeb9276942ddfa81f4e384eba671cad7109e07a175cfe4ebd0574c4b55ee7194403b746971f3e3de9958a5f25c6d72d693704e0563d7e23918c791fc12164c49f2faba37daaf05032b33cfdc9dbf835c66ada6e69446e9290d42521721a8fd34a7a90ce32028920940bb78b2c6f5da7c4c63ca52a479c21a83ade5350cea62c32c127f08fc2a5be29490d098590cdff4af750d6a95359d6dbba5d1e8dbd211546607949b1ba2d67cdcd0954351df87cdb69f07017842369b000ff137651cb368bfdb0a5f4c96c44ddbca5cd155c169827326e7d75a3d5f8e07e9b49e1f3128ccc9280156f58f5eb617e215edb6b7683217b153da408cec9fac00a1bba54399bb0299b7823529d4ec45303f93fb667e64c9a19e173789040001962079b4c8d02e6db7141969f5e3ac3d5dd1f6a92962325174eb0efb998c234c92fa49921c23c4a1c205bf8eb79933d0474f10c9ad73b4db51fef668022de09a6b9c8f07ea3b51a06d79c0cde66d4e952082c1a28cfb47f022156de2dee771bba3fcda92755e2e92d865f464d8a7d24a89be4a5c8a457e00eaa111c128731d94ef178c33b1409b3298bd1acc67b3f3bf5b12e4d9d6f0b5eb6b6e1d7659839f79926d95a6d3b841a1f9c20a66a55d796b956ad16ed765137b6c7b1296ed05701a843854c8fa052edd5b6166cb611b70b9223fd2ccd7ec19c10023a975d4e3bf0e69735b798da2a02e80bb36a92e84e8f24305714de4cc6adb809b945a874fa66d383c6f9dd760465cf9bfaa0537c45a04f3ce8120854688df62625d2422c902e8d3fa98385c48d14db5a8fadf9b0effb0c5109bd859173bfe06afac965fdbb8e362ed5edc74110dab137ee15a32e8d00eee7899e111ccf2b721ed84bf9fc40eba7d5976f86598683f725b613a150c7a93b0d6b62dee03e3cea732815d85974be02d2527ebd676595c5d8d95f7441e0b49c8c03d58d2e0f284c26e8979cd6d681e27ba38106afc031fbe528a26d8438deb67c635bd5601f6a6a758f24b202e8d0e2ab746166edf82e01a4d27ec86586ff17345b4801dff8142b12fa351a48a2e5f384e4c38c1cd66c08a969006a3ca3902401c21fa7c267c1259e1dade69aa3d69362ab80b8871ff8a9d28ce82b295df316478bb5ae27bbbf814277652a613875a46333e8ce78ea01da0054ec1379f3127e2b6d950a88975a1ca6fa2b05779544266efba2a305ecc5035d6a3cfa4964aa1956f4be84aed300aed0a8f55e7a3b1429147d21765a548ef4a654dd1d1dd27567686e2194f8bf0e40ef04aa8d0ab4066fcccf0c17186fe4a79839d5eb7431b88bd393b98c4c8f9fe0a959d3fa4dca931b1a8d9c6235fdd5d4416153ba4871b7447b21a8879ef7f81df55b0fba25aaff2e4eaac10e0b0905c588267f4de64c94fe1491da7c106b99a262f2ffe1e944d4fff81e712fe273ab6f8214c6836215617082c90503f5dbc15d15fd59770c8d9f697eeb34c1b2a8daca71be6bb717016e53ac1760b76fea3430e7bb894f92533cefe45cdedeee052fe9d0eeacd44fc1d32b821020668da26bb2327ca3e67b9acf84746cc10a1cbf3695c88bfb7a54b50a58b06552b7f992962f1d88cc5a7d6b7c73462eed476024adddadb10d9aa78b426a7d2f60f3c75e6b175b008ab26037482a5a6d2c067a5610c2c5d28fcae5a75532f38cb0d7a0f93b37c910894a5992b88f19229ac929c9b63648ddd6f1b903ea61fed400b5907d4138391e2eba0a80db730fc50136d556c2b537fc27b155482cbf3ef143172fe52418ae08a8976437d22283065d3d88e7b2d733acdc616ca7a75df1611fe2ee58c2a038b8df233bb15b5c3578d16c0b4352d0b06eda609284485ca964c9ea91fb088c0e13ae34f18933e8276fe579261365527ae9b015443a7df1f22ebba80e3bb5b0638bef783b54c1bd3609c40e00629fc4f40d4a3d99853fa702df71fd87623d3f6d26c222ecc7760d0ecd239ff8209c2971bfbc7bd4d496c94fe40ebd3316cf7c7f4a122d05e6b39a7ede3f6e197049cc8daa32654b95195ea80a0189b377437bedb450e2719e4ccd2b4a32f556a96b7386cbd7e0000292cfda51d5efd94be98b9043bc2619975ec7406cd935da18ec6f6acf2768f8be8b4acaf360d74ff1301c317b8558c42c78a5cf5a818f5d2ba0d9bf039b2db2b010049d6fd4fc68a173b25d07544054d37519941f615dc3e7a5dcbc7417781e6dac2c4b2b06523d7d863fe0ff8fb0011711e021f26cd390caf6a103765e49e2eeb3ba2baa54795f3daf5ee2ece9839877b59d4358fc9aa6c46c4e93d91756a04d7c9e34588e989243537eae9aca997f7f4b160745f33fe0f520e0348f908791c753408bdae0389f9ff143eecbe61dae7e56e284b4f6ba80c07cad2372f33ae1c24db84158597e06116efb4ae40f4ec5bec70ee2d5e68b15f97037ebf56ef2fc6539e4799b5a17c5b50a36cb2534adf3334731ac5fdf0fcda3c338ba8e5c56b6176bdf4a6ac1f14fa05b87e1b7bfe05a5d38e20b61ab086fdd5d253580d66898a6d4507266ed1773ab73f4cc1f8ffc6c35fd3424e3c4165aea779d6ec59e493605f48e34a4aea582e352ef015c2f6c2f7fc95ff68b86738622ca89bf36ecb90ca6746d2598b29f3fbc3cdc2dd1dd94592f8627e61d152e54f49d0b522522496ad708c5ee5512894654d087af748d98631ebd06d955970c69f8d812ae0fec3dd18191dde6f7d3da2923045fe70dbf0e9359894862216c83fbe2e815f0ba1ba83c2f13bcff61cf1ccb05adf8551c88794bf7cb94b0a60ce5976696348f83e644b1af94e6bdb8fb79f2fa1df86b1ac87d8a51f9f5d95fb06a2c3cdcf2103dc9ad4d249000216eb15da3f7ce1e367a819c3b8a6ad4ad82d310db1f5f3b762d12883887e13bc7df197c51abf4834eaafaaa47bcf08b6af5ccd9aeb85e865e06ee5f86816e0364e11397886bedaf4b2ebbe92658095c51d58715551a2f42351663ac24c4cbfc9ba44cb91d1adc221901d48cab7507d95f2b84562abdb38437bb0aec699d2f990a488b7a64ff97e9b09799aa6dda830a525d30daa6f67fb082e435046bd7cf057a5b62ae50e1ea9db9fbdf78e30c33fab3d6156b4762917dd0a1122eb69d8a773fd4a08130e3ff187c1a34338d299edcfbc58155fa5db5b164061210919ac7f26f2bcfb4ed3f562baac70da0959ce8eb029f4e2babeac60a032e6c8702a0774440708390c00c19d93012c9531ac8fc90bb08810cc6929e099ad02e0cca382109f4ae58f963ea65f728ef4ea2899bb2ac889f0e8aad227d5a6af7b287b8d52e688162afc0ad25d8ccb4a6676cf3078c9f3bacf6d460a82dd1dd99172e2cbe4f25515c10520f23fb3a5787fda643eb6528de464dc706aa2492011dd4d0b661cafaee5a0cab471db82dab91b62e348be959bc63ea7c24e3df6c32d1351453ecd875bb8bbd26836dfd6f6229d184c54fdcbda3b25ecfdd36dc7a5e5345e060257551112194a80ff5a9a740fd7526e8f7df841cb9d6362a948aecc5a0ae14ead351e2a01b3c30315cc3b413adc1612468942b3876ebb8f60c51c8e24bf53e9e69ada757f11cfd5f45bde04f7c7ed57a3cc64199cf43a6ef28a2874a3fe5553909e93952633bf770dbd00408b94be1b8189af71368ed91b7c2fbd8f3476165a55369d6163caf46e06602eb494f2953b52e1655ff31c61754d11dbe8e0ef7a27ffd30ba9ab6c139b42d33891ea847e1da25a12b6d2f0d5b5b9e7dfe7531f83cb5c7a0c3be30c5312112da3e57288e9c46ea51a8b78779c710cfd677e5ae6630178e261090c5121e612546e50b6468290429c6652826fcafc7b3b50cd73b5b7f3fef724d886f395c8f316a8471545d9752a6b415a9da48eec259bbb61fcac019555588a7c6779aab5c3585b1d991cbab0c6557a8f1ccd9f359256692d7a7ee3145b0c5963dbf394bda529d212145bcd3976ce510fdddbc6764e15940df45696e80369225c9002e374072d021dc34bbe60e7505abd3973c17714373ae88234700255baa2021af377f6b32080e1482399698572becd48665b025a0c63923083f329f3c46abcf7e50aef3e46bb77d06bcd1521674f3f7b57974f8f468dfdb7a421cc238505202b6700d74566bb139ea8bbcc40708a3b4af5f8df2729aef29326a46d4485a1ecaec35c97a945283a0ecc3f6a797d09f308d2f26ed62648d67f6ae1bb7d9d7bca79f6676ee2480d54f52fbe260d5b8b94c816109a7d284f9fe4e110dde470bbae12ac313545a7fbd1ddd3e3cb2f625c89cb5b1ecb84b54c2a785ad10aa9a9be976601aa1d8753eabaf379dd5a3b9c8def8df7b79efb613c9cc0f3c99b0e5e5f66f6f16fff3620968bc023233eb1efd3c96c8772e99d5848e9f2ce93eadb73126e069a90f8092e57de22b4300da96c65d763a7a232a77ef7d8b81fa62398f696f6fd01dcd4e61017f81967e261c2ef00db29441520754a0798f823b204319a73ee9640f94dcde5defb97aa775cbf22d42a852a477cadf55999b033d576d82c83d7cbe86fccc6ff9ecf2071b4e56e90ed7142dcbba0c1d81ee4ed4c52b942ef9165c2e074c030b5966f133da93b70e729eea10d06920b8744fbca197bef1da616db3d845d0cc163931b705a2e0236244c5523a7c3bfc738a9faa84c101ab4ab93a9233b52fe0c4634727ad467830fad3a7df1c7dcb89f5bd2ea81e5e22264a3866c101fe0ca689890a576f0afe0f4a48537bcf25b3b71a2addc666f64a6b009977d3437e3c0b7df910132888474ef0ea2468270705e7c4045045322e415edc94edfd7fd2004d5f4c1a6f45b13ffb534512065ca84bc9413ed189d3edaea8b56ef9402002784accb17f9c23351b186da775075cf5f5014da562d6acb8ac40d1b541cb116b5bf2e2e3c8a2617848f0f94b6ff44fedc597d1579b9e17163d50173749c9fcc4b7b541d3e635d599d2e281f85429735c85cb69c61c755cf8cd3c4a6d5b9ffa2b3c8d3ef3f9226024ff49d4fcdc580aef166de867514ba94b5d08ed06ef529565634dad5af40f4a05a9a102df6b622ffa07a3775d215ebec6c57851cf01679e0973e878ef02c93e2e0fb1474f1424d083ce0e78d1664fa7c7525fb847b0a5fb27667b4822e8cd796af49c53d6e11f058195ab685506134aabd8495edb055cfb37f623df3f85d7d0b6d0bccdd8e6e4916ecdc313eeddacb62432e7baae0662d38d16602014e9515d9a7dcdd2491a84c7748d29d2a6bc8f08811449518ab7315b5403807864935f0e14a7717a76fa1c66bccd3234df213c357aa65a6462339dd1755c7816050908367ec34b06368c4260291fc6560df1ce80da11d08cb4704fddd97ce3b6150c4f12e55c62a876a1e73b2717f590c4f2e566e0ba69732f2faed41a9cb98e591567dfc65d74bb1ae2c8f9b859ec322f96d49021f90f76a94228f84b462b93313aed270964980e9b07c62ded2aaaa9c913713830a0bdfb2fa02b17c0b2536d7337db8ce5a20ca5b0d6c1461fc0f8795bfa4ee7904f8b54be808d88fe277d91659b38e5124583482fd8aa9274e264cc0d4c76c4e27980815edf82a2852da77e94d2559832d85cba9f954a61cb94f6d40c6dcab88b8ab406fe01ce89f252ae5ab5c86743b6816f6360c1be68f4a57f50bd7cac6dfb6ee6ffdba3a2e7ac7d890d40fd0bc6be7bb1fb89abb93a1f9e58038605e1db9a5f8a73c51e3e86d455bd6a8ae5c2fa0ec1f2180f4bfb16c1b39a4e853a5d08dad2fa06ab42c96d1a8868309e1634dc56c7bf44df9a0de53302ae6ad88bde4a208c6a9907d00055bd5645b2e89ad6508b3df1a9be7f2436cf564e38b92e0ea610936d10434a0530cc3544f51ac2c7764dcc48a5ffc9eaff1ad58663c5bcc5e68b3079060f251f88cdad9f86e77df932f6fd6efc67054e1c7eafa35293e831907419a366d6649c491c58b6fff7eb08e42f5edcbc97aeeddef64afa8e7cb4b21ab3896840fc1d586b910568815a09f9b68efb56df93514577cf4919ef3020c48ba1608cbd67bec7d27b1ec5085a009c784c7b9feb93fd5a3956eb69f91feffbddbccf4606919fc96f7507f112e12e26de162ec26560a8507620a0ee6422a09c67ec6eda7ad0f4f305851c39bc78e2e5f750fe8f0ff0191f967895991626c4ee4f12db7c5f7e9bd3134fe7218f6dc7b7074ac63dbe598cdc531caaf48bd4c886e0396fb49c455caada1268eae982f9c917b64cd20b1e8c89a5f45978c177d32e826b62df48bd9861650a5b34cbaac98d685bbd8ea1c75ff322386cc869f9b0475a73dc9e6ddf4c89c135e5bc7ab53c6961c94d294c708eb07a1aaed2f83116166c3ed564761341dd005175da4a85fcc19926b2b3e2b19842019625ef97a9a3de25bb3ed8a69313f4e84498ee06ab4382842491afc5dcc3d37061112287177b4b178d4c2b371265f0b51f66c2c435948d3369413af281c65805cd0e0b973433cf4c60e5a1fdca5c449cd20a938e1f6baeed0973cfd00abffe4eff135a0592f0dc5f7a7e266895cd9f96b8dede45ce9d06ec561e9327d657a0022c6a2d15e4b63c2cbd825d3c411aaf4302881a665782917e96872ed690574b4312850de85a05d4f0d49d1a52f1f9226a375237951007965da89e8d9ff582c6dcb7ed9553d6cc46480d785242d8dffefdedfd0e4b01ba0c2c40362f8f55264b192c94885dd687ee2b2b97616aa5132730012d3624ea8313bafb308b06bb8d0a658d41fd00951e8bfa88d7a2f7feae9616a1623f75fca15403b9a75a912f8974e72d003d179af6a1f619b96171799e2301f9bc1e6902cb1ca3d8bc16fd416bf07f0f84a7096dfdbb8d9e04eeb977432faa95d5075b6aed7ab00cfb0c66252670e8ccdaa43d77f34a6c77f289196e953e6534d9767b84f257d9f26017eb6e0b1c2db493054fac20d65c1d8a8e48dc9e4d290991ef0ef927df4d4b6ae9862d15defb175e3b46a202086e7533f84cfba7054e8cef8c3077d4e44f21479aac6cd51001c57f9f3777e56c8058cb536e36ea298f12a71f309afa27e06060a97dfa44623b786fa014e740d385458763c8b091d9799f298b5312d8cef3f0118e8b191e6f0fdc20d56204fc2fdeec8a8effd1d768a08d9552df03149c975b2060308978d0fc8f97c7c395b68250bc3835b57328fa097608b35826d66b335d827a04142ca9377de70c43d6e89e94a576f30a8a885a62a8bc03f76bc85fd6376f7c9cebfa54563207458df4550bec96679f220a5bbddc024e39b2309d12d77a1ba4c96001458303b2aeda3d2f55b32cbea10d8157f004c86de46b0c88a012de715aafdb3752f129c1f6a314fc7c29dd6f0fae17f61acb60f6a95fde033e601fb96998d2a6b7e9114ab482eefb29d2fac198696ec14bf49a0a930bcedeec996c28b1b37091faa32214d7412e6144dc665c3f2b2a25744fd807cf5108ac014b34d8170bf055eaaa9ea44f8891e844a262d5a208655afdb823eb0305b755ef773eea890f4accf4d95f48a3c3b1c376f86483b2642a5d0522214d52a0764701888d05fb8b0fed26db59011a24a782d225d195af4748275c4e2d8119a961580efd1d88572d4184043c5610234562d851786cd141c1fb19818b3d705c88d7d637d3a62af221cac436f8958ce95ea75ddbf40c8f06cb8ccf1c8d3f5372b8cb7f60291ffb330311bddadebb22b331756a6fb8d84d6de4bef8096ea59ced64b72db3d27c40ffd4e83844e9e751a96406337848f6899229c9e64f750466ec5b727d224235ca2af9a2da0cec13fe9590d99e86f78d31ba3885e6d9c4d0c9e9da83d54caccb0348b875141b5bcad69cfa55ba13b800915cf0b07918f0031d99211e614d27aca4d8b3fa29ea7387ec8ee07938f45ababf2b4ccd5ce2b0b80021f20bb58cab43b62a73876bff09350d301f51305ea673fb13d31aa31b75e878c1668ebbe03385855525a8162d6dab595cf1510995fca7995327189e5e0918ef13cf6cf16e01d12b80d9ca07737246aaf6350d2e1b676ffa7267c8b4adad2a1e1920d083b5b4b5c17438b71c082ad88c82af39061a4e1c3f3799ab0ba726575eb9724485d45dbd7f221e0cef31e6516c157f66ca4134497ce429135973e7f1d3c7732048d1a9e88e1c2252ab6a53e9e1db1b2a549c6eedcc142b8d516bd5892639ee6b31c948533cf6d1fce51e415a8000621c7ddb9e600dbf9828800ef1029fcba5278d5f5b0c63ee1bdfb58b1c0420fece9f5891881e8e59ef5d6aff2adf868fb7b47a98047868ab47d278d70b0b82101ce148de024ef09133dfdd1d3e2c69d75f1d09ab0bfaaac3c85014131703840ccb1535144f2520439be26eb2923c97435fab2c25216321a286a4b952264e1ef581ed4c4491a03689a4fa2f809292b6f327871ddb135a2b2ec933c11848c27e70957f72a4fd2de3b0bca685335ff0b2e29d31f99357037de3967a4ebf789d1c9e5d49b2a683435232cf414ed9c2c88caad4aa30205259bcac4925cc9fea8e64aaf1b3e572e5f9c7d8dafa01ef8fcf24119660e75a1c4ea87a7c9c0de489f818c6ea2666148d8600053c95ec477f143213afe28da6649b83c1a40d5e5db66246807574cee570afc514c1ddc721c4a49851cd2fa2a0922f9fbd27e2712838a0bd5706ae39e1de75aa3cd0b257270cb3bc2f5b0df7c90aeba6560d8ff3ce51b9f2aeea9a96932c5765705a34ef6c39c6b4b0e7cf99f230a1ec7ef1cfce7859630b5451cfada7e19df378f1eb7d562738959e4ab0b7c2f7307f9c825147c501f310405cf5dc3ce37bb3a0230f55b1bc9901dc49ebe438584721c7842c0732815e25efcce717c571896a40938d8bacdcc96e03b6f8eb4377a7b85aa464e31b8f8be60ad9164f807bf7d57851b9d84d31460550e0236bb1a8ae689dc04b2de4bf6d8489d1aa47cdb0ba511ad604ea4069f531cdfbd92b131766fc36da89b1fd6ff23e844362d9370d534f7101427daf4458d95082a3506f4a914dc622e25fe6b9564e3af5aebb6e5b8fb55e5f0e79002b53280a3b8c91164ae2369de8182006a14f393f9b9a20fbab5ee3ecc8710114aa4e52078a4cae6ef03aa49ac62d1bdb2f2b5a01201e0a63fc144f96931cd70a410be6f37f7a1bd5e3e26c1af02d41d3a4bfdfc95519ec9ab7a9ce9b9ffd087324d07b0783b2965628554eee5b78ea1f1870c05924259de64b63871a1a1c9fade4323a6c6703a06bebdf4154d1d3ff196e1685447ccbabfeeb0464207ac8bb8137f4ef35dd123e55452b7d253b81f35138dca5904557f46f245128277bbabaeb2eee4fd2dcafdd778567dd60d3434911816fb8a41284b5e9f4a9428230447fbdafdb9f7367c9aabc5e2cab8995e391d6b73ff15a884a1a011887bb35974c3fccce4dfab61cfc4a26135125170c38ab3ebcf43664a8ecc4e7fce2ec3897ae499a67e6fd93c35f6b8e730a56e82aed54e55d2bf38b82e7f36724012101249c8815d5a58f501918776eca2c965061f6d6ac1bcb8109aecd219e3af5ae673ac7b3c6691416c2e41e0af531c71b10a0b41eb683baa772520c6cab9bfb4ef882b9490271b326efda531db88475497bca754b97a9e70c8c0693642958d42c6012b8813b04aeb01046b110684e03f7d941ef4776f56ae959142a5c1263a92cf8c2c476aa6e227b09807c36cd94289b10fd5fbde39d451cf7bc479663821c69792a78bd6c3f7bc466e8a1a3a6b0c47ece0899480da107637c4fa4f9480cb2f48da6badb695891983aef9441545139c41ec3bb3cfc8d6d3ac1959d750ba3d34363f740da558297732f8ac796834c8d4808d106c992bbb2dfeae4039660ca9f2248065600f895a2529aed1c8b8e430bde71a54fe2ac0e2644cdebd2e1d3b6b4ac8dea2257a5c539b887e739bff81e299b7912ab2b40e69feac5d4c0839025c6761bd732efd374c4ed0a9ef1e38234828027a98e9706150d1fb9fe4fefb3334b1c0843f1dd32c1757f7443f387cb9c6bd5574788558973a35c6a0171a70d3a2f5d4700e6da13c2fbfd49ee524708d32d89d1a97cd0cff377760d69f8248234b14332ebfbdcaaa0b0b3181213746218f5a296e42ce238a8b30c45a4b0a7543dc55d9dda75b385fa25164a2179f073acc1b560f0df59afa890da9273531dc61898f6716d3980ea952fd3bbd401f221ca990560eeddc5bc29d2f7a20c6ef55df9e3410d69e009ced37d5520810d2219140ca99d9b1428504661415af49a20f1b33f7b381d6b6d5df958dd82f8d66c03f98618b697ccc9b95543abc53dcf278d6784ed75b10204cdf225dcecd3e8122c8b433c6d32a685c2f7cc63db47f5648d6564d27051003692a3f391769b0cdd9061bf02abd9bf7ba08fd7af06a7dad5ef85007e89a5badf17698500bae0f39a831cadbfcba9f33057d728e27b230991faa9ed48ef3fbfdad9dff5bef1899a7a20b546c92d04b0135d508421e0e8d772f95c578c634cbac7de7535f5df7c1034fd1e6d4a6b606b69eb72985a1b816cdb683f206c324469fc776e8835e4b9afb0d8bb81bd7565871787fe349420313d0d5797b578d1a6d5ec2899905b68fa8d5150858de76115cbf850fd1169296f347ac4a067b1292223243038881391a15046beb2c04da2870b1923ce7708a585e885187acd489d23e09a0a2fc525af4a0c5ac42dda85e00cf73e32145cead8cad9a12fe7127e51db32d4faf522be8048c98a9bd766b175d6e08ac39bcee15d58bbe092c2e4b76823069b204afb7259d6649c36c12316e49e240808d34aefaa1bf6c09b89263c8038931590ae11f2769ad5a3219379b9dfac4aa58f5167294000ceb4b588c4fb544bcebf9d5e80e21141a5a324dd88a12e841e9841f71e7481a7d59100b88464dbf05d7007261db12699f97baf5f329c0f105b32f8d9bfd60e03a6bd4089dbc6941b44aba7903bdb10468af99970d4eac202e6b4f0c5891251170e2a0c21d0eae866204f3a0c257be3f3c857e163dc037098c186c5d259f6e8bf7da506f6cfb23a3eb965b59c99c5babdfcf504e07c135ab58e2881e4064f655bc0dd1f133dc607e3a0445681c2b27b0369a403ae89bd698e49fe6a542f4a9bcdc369e229a10ed6f6ba16a72a79006b54d08e696d0b70ea51c90c81cd54be5dc00ec3041c7cc2ae2cbfb74fd4b298dfb600e42152c5f474997a8504e09681de2f0d5f75b01014d259d579ab42886a09b87e90ed4343753f152149f81393134aeea990c54a1ba3d65e58f460c27b5669a5f582b8e57f900d445193aa2fe6857acdcb1cbb3f581dc917a309ef010fe23a9e809c65117e653e33419ef0bdb593e4bf8013216912e29567a22e5cf6b3df888b3d8b5c49834338218c0b984d809b3a5aae74f9aaab54ae2feccebb397f2c98484828c9c2921ab6299999f808b34284eb6822ac94349acd57aa17b8fc9c0d0dacded0804f5ff8372de1f146b48663a59f7cbe2a337ff9a06c7044a07e28f523b80c1120e1af5c62478cac75c5f1836d2ea90068ab5fa681667fa07cab568854c270e9ecf7ac7fab2e3a44c7ad5e619b6a5c66ca6d520a87f2f75330bae82ba65dc4bf9e05c8456027b2ac8f9a71f042a5e88cd597f09735f3f31a269150b24b6ffd3aa236ff751dea3b7c9e995e8b6f051bf6e56b7100583735131c5ecda2642f1f252e79179908f94ff927b9f54416e5efa3bb20384b8cc84b13339d896503ff8322893f9ebc30bee4f8924540ef3a2173548ab826ba52ecda1848f81fb1f5c5fe8413926516fb27fdb80e8dde7433d251b9a9b087977949b80a69cc1f2f5eab6f63ba2a0f55857b14c21d9fae8c17b8c3b211c721bca83537a742a9872168c8a0053d4d1c32057b29ec32e7e15a5e5518af08dc91cef0ff48a060a9e252e6074eb8dd1b5e89068349445a393275b1690146e517b124b6e76cc1268dc74482960a8347fffb76287d9c1ffa5a1b5782fb5c17d32da1f9cda8c51e3335cb85989c6e80c1d12c7d0c2487aac0036420a120214e05d391cf00b89a53d91b8b4d14e117abff9bde2d835d679128c9cf453af4504589761888fd72994e99ada38174cb8be12e901530144ccb9b5a339ed0464d6897415743a421c8adb78aa5dc81077b5e482aca5c58aa2661a33c6741e95164f1af6e78f895748e702cb4b028bfe82b5cfc7ea5fe72604af3f24e3c9e0c66f69d828a83fd92b76ee55eb45f90650eacb10e91cd63b5920cf2dc5404115dc90614d6e5b883bd32f84b3beff30ccceeab577e8019f702977ffe94d42893599ff37782747de7b60cc301f28a3387e89f4684e39be88cc0cc94b528c04db5e80c0516dde68e9c3b6ce021df45fe0818e47f5423e858b641edb39ea2bef472aa50fd0e197f73cfb2038eab70da9cc80b57e681d2d2774596b643fa1f905f46cf4ac98324cbf81d08d11f8cbe547e96543282e17a56c2a71692c85487b9697dcf45a0ccc19376761958f1a75770c56eda2f791db4c9c22e37bf4e98cf81fe5b0c736bf99dc0c6ee8de91820807c670648963cf59e198408db2dffb5ab94e51e91a56bd1ed2f4567a1e4f3748d5ae671c91382b446cfe04cc84f4b9713e4579a5c08710d994a54a95fe702a20c5e2858780b323ee932da1ae809c3b853578a2d7fdda4f813d0570e13e29fc13df581fa8c2f84d8c88a6f46505e100ffaa788127c180a0ce297e43cdb7f04a09c8fab2b9494cd5456a75f1c3b814d949de1a9d258413e55f41a6f6e80fc1991546f52053be637a1055c075af11507decfb7a27cb7e185046dd90b4febe3cdb3dee5deb55c5b70d8f416e11da16b9c31fdf0481131c4fd356369fde490b705a4f2ad75924fc1a0e261db4ea88d41c9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
