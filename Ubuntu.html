<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fb360774a0c52309d78e9a453ab636bb3a19b8d263f135e2216f2694dccdba3616f835db1c39252d022b992a1c4a412ecb5c3b4bbce03598719b0362a2ce607b5edee5adbe5386e4caee1c5f696b2ae70ff2941183e527ddd31a4d9ada61bab28efa83a7bcb68b8310b595ae47f7ee30379bd84241b43d8fd19561be3829c650b19e80816f94b1c95ea3f72ad19fc6cb77da8f6e9a391aa7979e5e5bf5ef7d00ef958b2e9bad1698f20bb2609feb79961485b6cd41130e6fbe074ee452ed5c35fa9e2617b56c77b01362571aefdc21f391f1e6ad86f55ebcaea49e0e51cb33eedc7c2b88a982a77190e85200028370d649ffb8a26084d5ccf29f2fc030bcbd0c5c88a4901646f98f633a69a5b6e27c01df3e598441e99082cd499759fa692651368daccad4d7334e006d482cb552eed1a3e669012066004c3013f6c82983173d7056279a5fd5bcf9299acf1aca29b8e8baace09dd6d0d5cdf4b401733cebdb811c343fc34a467f2aa46fde024574b9d25c5d98e8f2c00e59bd13e622ac79ab78cfd4616355bc811d426d7d6a3789f68a536970c34a44a0826cc4ceae412de911a3f62ba3a7856e098a103e9ed747fbde04398a839245b8cba5c8399f296ec001a14adc2a7eec6808d2227a5eb384e900346d29137998949631fbc1a1890b6e3edba887cae3518dae5d1557f2b7239730deaca7ab64f7ef60b3afc482e6ba6880ee9a659cb4535681c83f487bde1157f9f40a7824203078738942a3b4d6839b11ca3404c2fd63b86d52edb911f61400a587eb782330799534e6220bc9656fd4dae5b4fc6169d1f282630986e275d3ae2e1a303916f9bc2905c0cbdc297e2b68f7e479d57d7f78674573b0388f7f6be308165b44659931deee6adbf9bb6453eb4501430e8ddb4d5d6a80fe6143ed38a940ca122db0222c57648eb731cf0cbe2e045aa13f2d0e2af8e6b4ee21d137cda2614295489c64ce6b3e01502b6de12bc3a25c507d81f721dc71fe8b28e9b5fc000d923e90607819dd2bc27f0998876da9c80be41e67264ab815f8bdb2ddd002908a80d1a38bdc93f0f7a829b8bfc8b04912878f62f6ec41d9e304d50c6423a2c11fb50a93e03d9d708d4c229a76b962742ba6960c79dc1c06dc3e6d7580851e37b156f77b17f6999bed7850eafb2f94a613c7f59792dcefcd73d47a336962e9ea20b97f209f92e956b771ce93f476b338d94e6ae92cd69a948cfc4a27cd8b847177dbdb78273116e507e147202f350a5280f597c9b4ea416019e55be29dc2294434c407753fe4e7b41f72b30268461ea2cb1305d5b618c8c3e562db6312f33f7869a99913f56156a6fa055f7c8ad74ad00856e201b05a6492877b039189e72af18829ee80da434242ed17a2e9242e3316a36523be3d65c1d23f98c1882895d05b69fb6aa6033236f472065c50b165f5ba3fdeb98c22fd87d2422825512865d2a51c7e21af1fb65810a00dc31cae6691a4cc8abd0b934347fc97a3b797f1dbab559440aad783adbfb6c6b0a187590e9f13473ef74d5daa420ad1d8e3b987759f2f0154b064a31b029809e719b7cc715b6502cdf71a63d25811bfc942283b7196da6d7ee17d570d3674cea56e56647e1f307436dbe7462b3ba293953a7125ab7086b1bd8fa390199951a86a7587c1223e44aca700cf178414e769e4016aaabf5ce7a72dd914835b43dd5a992180bdf4778ad706d23e6d78e4d3841c9504a767bef5c8654047c93c0f74339ec5ddf69d5b36cbaf1067431b8dbd27b935772e63b29c393bf390028ca987b679f673361209e184f6364b59a4b7aaa56b43972bcc0cb2a177f97fde923eebd806cd701154e008d5f5b0ae74b404ee44b5766b1d8f9c4d781ad926d3317e76d8f08e8b58e36921489c0fbc1a607a4a8d5d9f5cd67207a6c95473ba7b25f35b2111b3161d5e7418d3d604f8a5d5233ffa5723666772700fc7cc1f63cc5f6174cb602f9d2f71007254d97f97a8a7af9d02d12e4ae6e164ec9d0636e4cb00217f679b3d7f786a65604b4f0dfeeb065627160d734c3688d7910d4ef71a759d28ee1b4b7d26617bf3160ca0383c1b9ff925c5c109b0a585c50edcaa81e7d554af4275fc87cb7a7f5e6a3afcd9ac62ffa4a99ada4fef6095e782cf285e2bf0c028e7b623daadce0159f8893e0889d7e9a824be2880c3645716f4659d74a49bcac4e82fff95db6a42068de14d218d66adb0fd889ee1accdd4eecf5c320dde55f88dfdc9eb3c845427eadbfa94a5e1498028c735a15e7e249ba2654b2487ebd0cbbf453804997560cf83ec355f2e0a39f3d8da8571220ac6351e42a92c1b85741764fdc734b2dd35116deb080a35036a6a3ba6a3e3ea8402fe4123c3c264bb8122ac09af4c914a048039b92b3e1b060f1a78f55c31e7c3aee00a2eef6b9b84ec538275d4a51504c8703e451d438a81feca59ce5687ccbd74583af9914230b6455c01142f2376462c71d3a366f1a5727c5fd1da79a8ce2f043ed528db8b53d00b1475a478fbe433167d11ef365e034aa5455ab7e79a3b104866c17de88df723d450c524a0f82b3dade9d4ca8da38d826c03f0e9ee039b66175ad35fdc9760eaab43f426c1446b9f2793661b8524c89b3d31b144f019469e406832dda4f730575669d54be45726516088ef6cd323381705e5cc7017fe29326ee65294616bb9f5086cb64895e7069314521a25e708d5adae05c95c575a0a10f45cddf6e9a60998980eda8a1b6b2c53324374d1684d59e7fecea39dbbca7cd050a27511405d124f995143233b5c5d45b20b0c1487d31650d4110a7b2b42e90b830531d28ac7f20e5192a5d491e7fd13ffbcb6408e6f67c7b20f2fd927aa3160ae8df4ec5fc30b91409c5cc90aa0812e6d5f2e3c010072ab0e073fbcf349051877386244c7997b018724b2b42da739e157c0794804bcfc8c286d90da698f305b17841924c10ba0a98374ffd1e6c10c75b18f6b19ebbe90be33eb73d3f5dee0f713fea6f78f2512f22611983e5f98ce2d8624344eb6fcc7651a13a1000412817f4ec399d9ed89e779a3eaca07cd311057e9ff9bcd78f3199f1e538a33cc9a2ecfd896a1a7a6fcd0e2a39d2e209e0e75463b5a19e6e9f34a76ef0792870123e76987db4c90af48c8bac01fc8e86e4d12470975bf441d30d1f0be84ba4f6d835c6c796e2959c02bc0090b0af722fcad45dc5eb313947afc00ee46a8919906e698da28780a9814295ac29f05609ecc19bb7c5eb9a5f31839c68221752a26982400849f5ec47d39103ff2194a3c965ebc45f300361d77bea1a469b7d51eccc4739e057de319b571f5894e4e6412135c8e472f48891c7d3caa2e5032d1124a7238a1b32bb8e0505b6daf992e0ccdc0d53392dfd19b9bca1bb6a56cad231d888cd7b28e4af82240e6f80415de5ae2351dd3c166ce07011d554ab254f448da84839993a0bf5a3aaefd2b1581531a4293d1d8e443bf332ca620615772b6c50d6dd67dc6de15967e653f2d6946893939c3b70797decbdef085ae908f7b90aa9bee7e7d4955dcd9f61fa8753efaea9f6527d975114d01ae3e842746a3198b25d61a9b8352b8dcbee8bcb32e72bc5ccae220032c7d27cb7ded66eb00d737019b8252b1bede8eb91cb23608a62bd72af85a8bbde1933fa0df4eed0b022ce3acca3b68d548738c31f4556d8cb6354f629438128592b449775989bf0e782342e7c6e9f6fa87ace1acb8b2311b82eff70b9b14912c207e7aca60ecbd5c750af8b5b2dfc3839b4b328c96989686a57efb6939119db81d02e2c75e0819a5946df9bda67878ccd5a340586b6a9956a7c86e13f6fdc0c31ff32bd4d19b5ff7dd00385b27714995150054ee67aeba1b853a7a1441c924720210f611e85defabef40318e344a2a50aaf0655daf3169829733244d312d408c2fefc03266e5e70b74098e1fee2e51d505223f674a6bb2cb72d87bf55e7217922089cd89e2aa88526899a0faae5fad6e6053d3f0143f60eb429e12bc70ee03c29f64941bee7f4833c67bb266a725b316e6a36223f2ee8962acaf0f68300d6b1f96b84a767eaea3ea04bcb52c20a51fc4b8adf8bb06347dd41cdb30897c54365f92cf9a512feb365101a347843e8b1586697966e8cc099f932c4c9855a3047fba26cee79d9fb628bfc050802a45597ae62c5f22034331d7feb0cb649316e40299bb8d034c3585e5baba3a225adb5f51e48d54f8721c54b9be3e642cadaf7e59cbb35bc00b53ce51eb98e9113fb670d08c77aa9f9df1c97c149167448957846721e5118085467ed938f773d23af26d9328966cf9a9328fc563bbf5ffd12bf52b87496b3f2698197719090ca15806894bd8e3028cf6f24b8a163f60aaeac36b69cc97440cde4edb5ce7642cc127ef6aada9db384c8ab93b807d6682d6ec1769c0d1ddefe5a927967877903612cc4c359e1c8b38e5f87d955b684678aad1393a1413ace21c18d7f9c7e9986c8a3aae2a88ea1c30efe8016811e17bd9085107e7126eb64208f6bafc02721cff300dce4f2ad349480151659f358ff0454850430b47aaf09e7aed77bf910c7d4f1e7d601f2ec514c36770bdff20a21b86cb24c14dd9d56bea6af8f8c49574b28e911ef69ef4b025500783f810e1e05f13a4b1442f925362b29950821bdafbd8a4ff6678f021bddc55b8d0cd0a0f0fb2dd9703cec63f6f4a8c32c7a582a572fae4fc7a77898e36b1d3dc0f018f51fc13f33e4dec152aef8d5ac4be0cf1b8d43e11869bcd4f73c2abaa5c78af44a3868b861560b43ddb9beab97bbdcbd3d6084fa5b5224f2901d3bded48882ee76d9a4dfaaeb6506bd068a4e2a4af3caba39e260c5158e1d33bad1a6a19313ef80ae25639a7ce5fc8a4eb4d37fdb06467632465ff9904a3c7839eef2640c09d9c2506adf3e03cbfa1c3eb0b24f1a2d6240c74b746279d977732cce2cfa7685154025769764da97e6f29f15e5c83e6157cc9a6b0f348fcf317ba8bde965f2291425f4a5d8b1ed33b81af2743ed3b5bd4fa866cc4801f213b4569aed42e5e5074d28fe1c6c312141786fa7ce5132f2b236c584b947f7b56e15c3930e225c9b38f74fb7f345d137149b5e109db9e01562d7fc0ed2d20d9806e1a2c26160a85b97b11ad36b6514ee119b4402f815a1925aae6c5d2d3be3e1e75f03d6d5a36c70f2a936090030e39ba7c6011d3ca5c8c8f4390bbf0b69cfa1702e14010a534c591458dbeabd6d960ddcd9d3af939d0caf73b639dbef964d76bdd93a5d14b2627a10d229176d401c0277059d538e7911ffa3c1961ab57909db3c83ac3d3fda97fc1cc49213c824ee224d2f65833752c6642798045bf7c358388db22b4c78d6b320b847239a66f8a7cac0d193bcd79b4bccc29730e7e0d08fa85339972fc490b1b53d7b50c48d61392db547868f6fe3c7e8631c0b1ddebf14bc542f8bfbf1fd46c13ee07b69a1489961b2b2669e494f78654a77719f5621e8e1bd02a64ce8630e7d51ad2e352a2067205018d32f8e9e71e05e751312bb9668d56a92609621199c7e99b1e6e4df075db634ac853f23fd4f0a534195d31c5853be019a8a9e9a29cd813480d9c16bf107e9ea45aaaf792cc198ac221192d5252608324c5d304a877d772d0eca2bc2e67cab5510286ba6725acc27db2c78366da1a2d66b5fd1162bfb4fc79fb147f391e091f7d5747ccccbecc7a79d28a56b2753bd7e938f3164c4185517f1eb614be13fb13375cbbf97d5295340648e01a719bf0d529e447bbcc5725155f9475394c12162eea15df1e8831a3a5f2560ba3d17a4b7fa1d0f1cc1bbb2784825728314ef385093a2dba45f743619159d9b93e4d848f88bda930fa172debb7b4abe6ce027359b0ccfbe6ebf73c4766dbe1447a4594546c756b8dace065680e378eb2f5d01abee3b676e674866f660bdc1f3073046653f7e687180fb7ebc835931712fabf4bce644fac250a1826e39fbd6e4fad53cc19de5665f2ce8d9aa49c197fec64de43088bc53e5546f0a67733d8e849726e4d76cab6a1ecc1fdb8e534441c8303fbd31d46e4b7a4539804b433baf749c22c83e8175e0ede5e07b2626d35925cc0eca67da45cb7b714f600a8a90640fcb97af1c57b1009fb792a7269925b5bad9c699eb7a9208f5e2b91afea1b0e254ff0395ad571944e98cbee1930256287970d298a59fe8672b1ed8176a8a1dbff90bc1c432dd00fb3566bd35796e9691b975bb2fd2b2bc8d5a44ef22d20a72ffc6091ea0c80d233eade13b05befa72e0d30573622be76f4bcc2f366d118f9cc4c58ec25556140f3094768477bf3660ce85880cbb64c7b49e40c0fbd38d20643018bcdec5bfcb86ea260f9b591cca15954af0b7a7ae6e10dc689fd769904c059fbf7bb877641f9af4d6f62d0112b3ae9aa6eaa872e64eb69472fa6532dbd74284e96d6f3644ab18d60b474fceae38513bb7f14bbdbde4299429eca919dc61014fc07fdce24085e735998ce05ed7332d7fa2c3a1b68b9d428161da1d2105a296e0e7703edcdc7769b883ebf32e247403208fb77675fcfc1be2878b434029b876e4c0f42cd1ed7d939f61a6c9d226a5e3f9d31399bf7f684cf918d8f0df2d6c0c686fd88445dc09d83cc4a59a1ee567b8d6c9090ff9f47d2e5b7f3f242f1ab664ddc09bca537cad999349dbddd54ad119c705e1defb54ae484785a4faa458306a35d5829cc255714c8eec7038e770a674381c24d51cd4ddb050acab211a088c2bd64c5a1139abd3be6190b70a77be0f5a6e2a414846900577d2bf51e487874170f3432d66f71f3dcbfea93b6b4ee09356abf278fcf75b9b04606b402249315acbada4992cab6d029d6ce49acfddd7d59274722d330989e2643003423d95284777b5bc4f118003bc968625075fdd73e5134d21e6255ec81a247d860ee049b6205396a13fa6998ce3d788372cbcb586c2d5ca8d1709d4e5d9cf01e1f2035b6fb61120568be89c9647a8e64417fcaafb4feed51828bf92b8cb908afe9cee0f455576c988e530b4b93f7e0681c489c89d4c7b0ef76a8d972b8373797d8355baba9958932093cff6298d8cdeecd701a91b807c19422bb00a17ad22c58f987cf36750c9fcec4b3c24e897a5bc50f9167c2d737ed35b3901840c77452bc94b47f0726e9c62ca145f6a909683d99c5f45ce7d17e827c30ffd9bb5458b08579eb6ba0d7bdfe3a0dd663702145eadb7ab564ebde74c757120ade3988a7dd864330438931e637f0c30da6673ecde280f8942a0089c3c6e2f9abe6940aec73a15bea08faacc44534324def6967653248a05be7e262453581046a6d092ee730a8dfa72b8dfd0c62da23f45331db3130eebb7e4f107c9a1a405d713690ba7f5fcafadb32b36f525ceabb0bd7c6692a04c678c006d687cae6a55fb249f733b8eb1bf07cb2a6b6685daee33f512286e500db8af8f433d98d435c4ff3e2034be8245b6d75df221537795b4786dbf02d079136e2cabccc6f256578d6d741f5c1f9c1705c9e739291e059007f7c046070aeea7b3d34d37d8b255b29010fa6aeaf1c846dae421a9f7af91fe65ce0f055753d276967e6e90bfc6bfbcf917def171bab8b516f99fd626c31039e2cb8edac419703f579a535412bbf1d50e955439b4540362a13554c126f36eddd764825683943ff095f2a4b246a71013ef47051deb6ec6d84fa69764a72abc20b5f7d672edab8277bf1c387c28e889d9c658049a57e6a7a58d08063b63cadc6b81d1a73694602ed19a751a843835a0ea619a8b2ce788c4ddf1c9ece0eb6af445ec0b4cea0402128af84d4f6a50c4d928a3d7857d1e5996b8c031ef7a873c897d6e54308f98fdd911781f69095e0a4cdfe03733ce7ad030dbed43eae28ae1601bc5e5bb97543f3c14ea0f381d2be638f4e05b53fbcf3555badaa35bb02571de642e675774d898fd4d94e4cb56f6385011847e091a7b165797604bc091aa9e702bc01d5f2da1c8e0e21f29c9ed24365172046f5678a294ffc3a35bc62aa44cc3b041ed5d90fd48e97f3300d7fa377ceb2dad665e936be64688a52f9541638c30a3059ab01780f4495c4d0218858509dd27b6e343d3af900224aee96d8c746a31c1dd5cedd006cb1b0d267357669bcfbadc9542d0957d384c7f315c0f9084cde4a58a7f060295ef96ca0e2290ab5aa38faed55f795507b664d0ec58f4cfe96dd7bb60e0ff529b5f350eb948da63933c36099e483d304bd99c9e95e47ec1c0f5bbfff9fff0293faa7fe023fd0d3fdfba26554d45ffdabff4b3153670bde27533ead79c2767a79729a954b08061f4a82f7d26f521b573176ea45891523ffe029943388d498522082e11ffa811f1433f38aa4e71d9c30cdf1a511e54adddf1d873fa01a27d08144e4cde539e7de20070365db6b45471199f8339d48a5c89b7ceea9f1b01ebbbbd2178993c833ee5471efd489c28e95a5c394a4aeff9195e5ee0154e634233ce589f674709fd9188c049ad98feb1ab3d45fcc65c3450a3a57b8d1aae59ee2ff7ffb04469ff69510392460c1cb11a1558bdcda6fba8e027caf0a8b6c2adbcd4ae79c7f3d7b75d8d96f2688caa83d37e51bf456c6745f6a83861b31db407ae74438a1a645a64b9683981f423e03b5641ac5961dda23126094f9177e012e1443564f66b7e453da71438d1957db767739210280faa27df24e805c0bac4b746dd8752906cf65850afee8ef315ceca6ace710fb08f7e9b43ac68871b3bdcc21ad7733dd25ec87b907452a3e0aa60117e5aca2e8077206e441c9cb28401b7b126c7e9d843ee3a59309366f7de9e36e54e364c16da7ed50dcf74cbb4ba5a7c033bd139d6b3e5c5c5023269bca0d60d867bac83efb9c811827c315cfca8e4152b4f38e5a05c1eff03d80bd6a426bbb88e218cbee39b4cc4f7dc9026bb28bd440483228e52156ab0e0944b1bd94b85864e32721fea70192d4fe5689d1478830215a436cffa729f1caec314b80e73faa77cb6144bb24869c891ee6873fab700321bba456d8cd92ced26789795a0cd9d5e1c53984215bfc37589aee263433ecba80bb1422ac06d22649dae6435f55837815a04372e650169c70a87e841496882f0f98bea82818e25210146bd7e1658709f80bc8d724c4d354e2a9e0c7f2ab634e4e1df9e1b2a0eb5cbf64bb773c1fe1f396d2720ef1760903be27925c0c887b8a80ae4aa0d4925f616cd8ce4ff46a886c8ada499e4627902d6d9bc2a9b8b7333d8d407e71af4ec9ba4070e42187b0117e5c2287b177b3bb7bdaebbcf78437256e92efc4ed2e69b8fe9575eb72300dab280797935c5532aa1814a18067393b0dd4737df871c0215c0a3d2c84962c9efa6448601affca0390729f1801f7c075fed9b5f2f044e22e6025fcc518baae2acc30eb6db62abb86db77018b9b97312abb173da827083d79671b413a2767bbfd5c2d7c9b2e4d152c9077260e3dd60d847a0ea74ecc8731ad58ee9ee22e6692eff63a60b8f42d04ee1fa842e696008c79d3174b488dfd705bb964aca071f67e457e9494ae2f8f15d12864de472386696a070bc16b1bcd77070fcf345bfd418f6491a33621aee9f3c90b234eb240b9d3d0049f42e57553db6f5a2f936ef2ba6a856f676503536b529034f82f0f2c7fbb248b5de61b8686d176b1d829011791487c08e9afadc7130092ad498e3e2512a35b75865f8c86c9fb80e41819ea7ded77f34f39cde982f0793ad413032cd558f3b7edcb805022ae232f1e181e5689ba4f6df9a12b9670d3f191ee39e99aab720876a691e3c8593c3d0f6daaf041b4d30647ca6c1f77c1eb1e79ba30b6b01aa828b079581d66ad9964913e2541cf9ac3164b24754f59b29fc4eb9c993b9e376364b248f4b84434d225a4b2977977ea3c5e162f344adb5af9c0dc726af2f92f1cd8d4e44465b2bed748fd235ba110a77b05f0e30978a2375cd82610afc5a101f8f0667e46f191057cfc82fa506aaf6f22d1c6fc21b62e08964980db5bad8a5aafae2ee98894587cf4657bacaaa255e43ed6a9271f67c0df9c54445d57541fc858acef0131e969eadd99ae6773baa4f0e941097af740c528f6ea7a52b0274fc628404fcf9201b37f2172322a40698abaa6981266bad11007e941a4d73e9631d3631f716b2a3c71860932204393ec26b03a0b811a3ed3b97e17f7fc96ebd945fa300717d1257072448a555bb6475dbb8524aae06853cfd884f1c01f8d84dbb3a8f9cb2ee72224cac8f4ecaf526d1b8ef09eebd2ef6d27e236eea0eb048f548ca22c9758fb0dab2bbde214ee57b917b8b15ad9d5acabc68a32c28e837871c10b0ec80d25d31a6db314bbe72ce1e2866e2a2cb15d06dbd11a875439d182cbf11f06eaf3f3eaf4a6d23268808b6f50ce99e63d459f289aeb8321612cb62d0a12ef010fe9c1224536b8b72c6d3366fe3c73e157479ba59e5f025af69be1deeb5add256cd4a16f856dda509c08aa1b5f32ac84094e6ff08225937180b3e020e04b75685294214f259e92bcd7d1ece86db38468c4147d21e46b3bb9490af515b5d38316cd1e5ad5b465556850ba5c437b259030901819448c39b31c7d40ddb074739c5638fcfa2b52461c01d8c78121cd5ae3cfda7535c9d89da76a5904ec1726f2fc9d0cb8998a94aba27d744928b3ccfe054eb563e2e338cbf011e3c565de7fba2429e11094f2b17ba623e830bac7981b43286747c8499fb7708682b8110ce8e2c0c7a6dc9cd3bdbe2a1ea3301c5e27d696cbec1d198a23dbb6faeea00a4b1bf9e908b36bcc3f128e25a9aada1f2282a5bb0b2fbd9cf005fa56cb0aed44ea21523ac5220730c8f597128848654af5a9d2cb2f9edbc49624ebb4b9c4513f72217989023abe54ee1d9571190d07509c2fffd7f6cd19ccadf9fbe2652aa3f6d42021b40747ad598e74e512eaf16c2f51568ef8a2e0b7a88f326aed1124f954dcd90bdeb000c5a90aecf0bbdd47d55fc5f80f2f9d7894cfa132837cf8e0a5b3fd7c426762181e316fb0efb9187a280ad935c7236c59e360025c941cbf2759f2dd5011b915acb989df42f644582a5ae0b6b1c5337643ec22da117aca5b9266c2c33900335c5fa85fc5c631d1bbf0c513b68227b9cb531ccc916677e18387ce558629f058d6852d8813d1eff82a023b01326ccae338584ac4954d62ce675d1163ef8cb85c023987c7ab49ea0a4d5554f7b5ca01c2165477e3305893d4312f9af1766ff33b347c182d47ad6691fe727167ffe04010d9b833a482e0eea36c5477ff32f4464815692f821eec5eb20f00a1cdd112d1efac97f5c19bb25560e75448a771b77de5e209ae573a341a5a42949dfcff94458b755aae3474b26ffeab371fc4070b09e768f8b2c4791302dab54620edd2b399779523e9d78b89b552b1e4e92e4a13153728b6b15ee8c38c002daefc93dcdac673f31bfd8927695b20b85ce5cdd5ff7bb6a905017521b64aa8622a5aa1cc84129f4b7dfdd3f97cb600953b7827fbf2775ed5082edf6b6fc8db616b90937a93a11f1216c712300dc31b8f842f8fa37752effa7fc379c74948bacaa28d048f0eb2f8f107c9aec4a00b5e745961343f99a87093247f977910aa267c35e9e594c1ad2c1ee2eea5c73865e60af103991686c0788fc1f9c738cb49dc00224b0aa9e4d0f075542f0843e3282603edd426c3de860d4f4509b6d02590c87b7c2bd3f5dd256263a6412c5c949a9d05f42d201109fa54ecbfc36119eb9febc042bb19061511adc27cc37b2a7109afbbcdb6457c5a482bab18c71966e69599870ef580d38c7c48a0cb805d39944634c7e6e1146c32882a789d2844b0bc8f9b681aa01982dc937e413eda98c58cbc9b41b8e66202ba9449f9656d251b7eaeb1ee3ddd5fd241587eaf94d82ad41899d91a67034de5fb0a2bdbc83c4622b81bc89a693eca13e3b8765f1c792d45fdb1959058fbc7e2f82bc1d1784666e8f12af224e84dc94458722d598a26deb78bbf20a32d4359149f305d6961132a7681fb67068f78025bea7a0b3a2f09a9da66836436cc5bd5b34af7482ab948a8bf5d22d729d38164387321f371b021a8546a545417d7f6e54d5f0bac331f6f9b5cb8ce2f9a7d6c1a0232b6a6316bd37c9a60b4fdbaf422e38bc0b132b2003e3f1deb7582fc98fde6d98b88aa3ffefc8aad9305dbc2984466c345d251d63506f47f4d817751e882bf567c2007f3b3b9acb7a9fe035f368459c2d856487712d76c9369423f9fe5c6642bbd48fef605db90a8eb4e1d0dfbf3bfa92f6671ad4833c6f38cbdcc8624af74a8304d11d606c40c3919c30e2c33303d12c5fa30e7073b46bfa7dafdc59483a3879b704fed3237b6369853f346404af01489b9feeba61a5b0909fa00198a080e20e6ee69a0cc49c6a2025062732e9923f3aa0c1fd5eab6b922c8dc95002bbcf458f93de7d32d3bbb7b14878983e039448bfb8985a16b4fd71e0b9b50bb56b2dd7a1530fd7759aaaea5eddfb0c1cff9a67012b0ac4a30b44dbe99a828b42519caf90701658c836b0bf51e9d6e3c5db0e1027ee128ba0dbb3da584abfe0205f45cff18fe8d1b688371242bd351a440321c5be6cd3a93ea1b62dc8655dba1f78753a2c641145803cc475063d9670809522dca004ee8e0d2b9f470d36250ec20cf7b0e70788d4faa9894d11f6d924522ee3fad2d2edd626591e87a970bf1372c358bc5690b7e93922547a8e0407d02241f85755e3ad4545662f91cf12581d52d5530ca6cf15f603c3ae3052fb1322e7269c8eb2a425c075e1448e353d05448209f8a701ed784c058987e94d12e756b4ce85d7ab37fe64d39a5f8fb5453087e06b95188173bf3cf19135d54d67676315a5a3753fad670722f981517b29d298bc3fe0c70fac68b5465ba3055ba6d810e565f1b3039e089edd104da3bd6946d75d2d2a4260d7c2049c8b4b4e3f07ba9145ff9bdaee3c4c513e377150066195ac2a546ba8859aee5a13f511ba5d259202568d67aacc7c87d110b3508efb18070fd94ac4ba4e910b86e722f76b169640f07d80073fb85ff73d115c0bf16942465bb95c270d1c079d61dbbef654bd1a8a8c456cc68097e677e90ea086c93af358edc2073e893d7429925202190a440ebb1614254f8e1ffd55d2025883304625d6dddf87381a457d4bd34f3434f6769125f00f67ba230b106a1a7459f79240e6698f420aa0595cf8112971d44c190a36babf068f7aedf1b57c4d37f9c2bb398c4248070ae3b3c157ee2450c920a2dce15d39a78792e5d92928cddf7861f87984aece621f15dda3bf8096007fab074f1349ffa56456b04f0025714abfc0101896b2f2a619cf67b8f00684f1e18cb8c1023e747e96964d8aeccc07d40e6fa564c43169915012edd773eab601aab8cdb789449561c3df5377e29d2ec4848dfd7c826f068e6c78ce74fb2e682e57aabd65b1773140c6a1a12ae58473dec638c8ad8c73f44f17487ca122a811cc1e2145a63da36ad2be3bb93db8b74f87c66c033598c97a326ce7ea03431990b9898814aa5c7cabbf15a98d497ca901e7eb94adc1198b7b7d8af1e3215fb9f6bc87872d18c2ffbe42e7aa7e80a4800fe4ba3bf0b8d135db7e5f541f8123f407efa34094c0dee7969f858f930badeaeb31d690e0415d6dfda37950205758f4f65b77470290274bd327aef4fb26d232a02d2bd168375e5523f8fe073caf0f40be3ee6995b68b36a9e9666e08ed0453dee691ed7d1c6c35f61814d8c47d9cdceb72f4889bf931b30013fc88f6d51b9d1824d91918e6f6a69db2d6bc57ec5fa7fa82d250d24518207fb3873a472e2957d921878b29202abcf9f651b49120f5c0c06026b97af4b130cfd65420cb1efe36352b7cc863b65862537060deaedce1b2a8dccc458a58cdcdc74390c78477f00e5e99ec73276b84dcd9de16bd782bccc7eaf6ee2987b70c457deb4d59a0a14a53bcff3cd3c616810329511553f909e5a5a9e02674975383222ac7d5918927d5095b6f3d7df68282925baa8fd8f057088c9b072a01d8dae2ffe4f308b397b6d917af97402cc8657b4f69d045e336e86840a67f5f03ed26d1da2e42137c7f0af7d40a18713172766c0ffb3cdb5fb85f2dd2dbaa8270a2ba4eb83f7d1cec2c3f1bd41b3a33393c0087255928484bd9ee1d25addba178ea686ab03048aef5c9ceca11d7193fa467ba6f058a5a670a74dc91b4eaf2f94519f5e517c416ac26fa3ef654db1cc356343c1a9de6866994578401ed8229b7744d89961dc28508e92eb89137c047c05ad161954fa311cec05ae5c907f075e529a1998b89b65a89f137748ce6a2b4fedef49b237d532a5ca0240df6c8d0de8a8986c66dd60350ded9ff1d7526702606ae2635c23b53cef77fd261fe0616f7b8186b38e15bd18eae52b8ff6b148f2de01bfb8aef9316c49ced54644bbb234d3e7418df44a37f9859b30ec654531fb685f781cc2066fd90e61fbaeb3670e5d529ec60c38bf82a0bea944d92d3bbe4979b330aed9c256b3aa8a616c3be287461188a3d4a59ef9cb6b9730848fb975bd8cecaa206a5afa1a0307f6d3f3fd3ab09452d9f0b72e021a5497e99307adcf310d079378d3cf7c8907f899a487c79be5cee97df8c20d5711cef0fff3fe124ae2066183a020414f1015ec3a8f3965ac6f3e7f434e62bbb1bd3bd38126bd1cdb9b6912cccb21d5b6ad0f198017dfd0779875151892f782a4a3c52ac323d65d2da5cb4fb829c19691daf314290b51534d0cc21597637cb3181972cae4a1825ee34ec3d0a24e1d1d1cbbbfb99e8cab901f367faecf48cd8e88ec02f838c8851b8aeb697a7c6b4b1847e8587bb9accc146b1f95673e40058b599dfb13c04f50fe70243779785a351c473f75bc0d98e31785644ee8ed2b2fd16eff33346b880e907750186cb58bd0d7087c1905be6b520e86407ac8e0bd4c610c58e1a7e450c7886f5430b942e52a294234fbc54eee4bffc3403bfd343a6fb7dbf34a0294c05842cd3c0c3f9aece41c74973e208ff9634b40a9481af508b8dc2d49f4e7356b428ce55e2f46aa93e024af42fd43ad50e1b5c041ceb0c9f3d5c9105204069cbb3e048bf516aa16858a99374715b26a8728663c958f8f09dd47556e48565e67fce0b8e5b5b66e05e517fb52695300d283ac93f4ea73109f41fd2058a5242425ebf9d746edb3e0516bb37a958f433655c170c3c5e707fa31fd3d3f7a2d2d59eb6d03f0f19683fbdc45b8dcff1fff9b77710e75c6e9fe264ae1f40a19ad3e3b34f2fd6111ab527b2f42c231fdc1f84750df43ad2488b3f9dbfc8e2c28ee152d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
