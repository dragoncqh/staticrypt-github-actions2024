<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b667a14a2f9d03952b902c73ac7ea7dd1caade1260f4452105d77f7b048d0e80c27855e1d7f8d84fc4ed3afc8749ea976a71bbabb1004a401925fc0ac86b8286587e7fa99e83f56b9bd66e8a14b2a76b9b1ffe943852ab86ce16abe6813b65192ccb5fd440e180fdce06243b13667699cd68330c911194d54cb38d5f1cf3f59a731d92f389154fe193b7c600944ae006f540b5016e260f15b544e73deb4833dcb6d621fad1a745466eefa9f71c837e4f52c8fdf417a87a9870b3dbadb032dbba0fe9f0553a23d596fa363f45632a8dfe530443a514a1a7b0408841bea22f9bcd3aeba5ee0fee2b534e999baf12d08607d6d50c6d244f9a41d7c34847e137f3f8af2a0bfc5b4b6c2899ea514d1e85c18e36a80dab7c1efc6b67a25f697436e8e0646e4f6df4680e80ee976734fbbc37b9a648c0cc69ad40e00db4537bdcd77580890a0a2f26ef34bf6d63c9f133502643ebc97410239fd7a31d54fa0ac1aac8974e216af9a761038e15711092a2b8929a3a5cb4f6d1e46f713cf79f9ad3d8f70bd71e5eed4cda0cfc6da210b7b3fdf75dd669d9d0ebf48c6e5841254aafd90c926e6c8b77cac71aac813ec7c8cfc90bbf4ff1be23024d7f060d58d47da43cde4fd0184770bf849d20443040f179ca29efc553a1a7417d8c7de6db4d9bdcbcbaf9e5b36a92538c22aabd081776997d69975599bbe50c4c743476284a4e23a601316316dd8cae59ad3d509a7937fe99bf97a1b60242b1b9f2e0a95b19ce3d34618e0f623e1e2b662ef427804b1d80c3b889b7b7f10dbe171be327663b66f3a3c3c334e3d576e63a7ffd094809098269b76596219d9e7fc477d2c1d230eb9706ab43de66bb0ea9d2981cbec3b4864f6925bda959061ca07cd259b8b4488ca05934c490d9150fc13e1958b4ba56d2a7d79caf3d64f466b4fac0b9f5ec2f7582b7836bd9c99aeaef7a748ece530005cb594f8d5c5179e15f3704b8a829e54d0a930b7e035d3e52ff86d81d366978eabd1709d5d92998a5165df3fa3f008789ef201e92c43c1a58c5225f281deeb836bc5197752056e6e5205806212ced7c1ae2b3f69841a4cf27e0c54744cd803441f47295d8fe18872396c0150612363001f4d90ef7121cd5f9baa132eb446ddcdee2637c91731159ba136ca1fb21884816759ea3ea8d2e3944ab84dbbc83e1b255b41de33ae15fa3e8c194d9a5ab7c9747316e7a77baf4a9635d3004203368f997e77dd068ac3b7e0b2614e67c2938def536b130258c643a5d9d5de79b6d00b8e8d680904b2e925dbd3f4ff80d8077bc19ef6a8d210872a6bfd61236bca2280ad2f9db0faac3fb19f7a681a01849cf8f3d17483dc5a8a92051b3c71f12b29c35843a763ba3c8f89d2f8bcb1c1392ed2c8fd0f4ee7f8b91540f910b9ff21676288e5f0c0b6a963da44e07801aa34fc9d4f23f5751064f5e9102795bef3a37780a6b37504b38fcccf09bf0f34c410c1a15f7a9b4547bdf5b3051e264502983918dbab2fea577b09d7b73f07f2ed498e83229cb9c84e2b8a896c05ade5ddaed358f179322e0314afc1daabadf094f7f41c42784e3a0c22b35243fe7185d0c2db96d3b1752b21b9f7f5a8337a7af9bada7d645cff4041cbe4c19f7fee7b271756532b48adc20cecb4f8f4e0ef40df010d3b5c2fed5bd145b59a293befae5d1e9fe3002fb2a834b03b28b95202f3debc7c5b399dfbb91c96c0ff107e9d8192b1422b1900a13abba49602424b5029f9706558c683e7cffabaf18ec601d9207c65ab96fe6aee28158f28faa11034562057d6b78bb2008dbb367a3565ccaf8270c97075c18491683448581061ba6bde60f4a430a739eca1d7ad632068a2e7820e07d3518ceee7c9a155f719fc19df1aa4bfc6224f0fbbfe112de460ca98e02fe6368da7496e1b8710ea39cd075997bd6072cfc21066bb54a2ef7f14018e4a71852a940ecda17df864a4af8ff6cf4205c349cc5344c0f165e3ff8b38b237268aa9ab43ab23c9a289861098cb4289290486860b6e8768cbe9f05ccc7e674fa19119f485166724c8fb2226d58dbc18f88289fb41132144f81ab27814e755c517c6b25401b099257b14bc0b335a10e75562faff33a995739a92df0dd3c383c74f32620868510a15c33a59d5fe531247e78170da7ca93009fb5e0060a1dbbd8770ad8e2f8596c5791a7bd3a41b62894aa57660d3703117d3ab8025b39ac43870b08a1ca6f8b37933b585a86f1d06728d65a24d241fae0954eb8e9243a6bad611662098c14df1914db732d34b380f913ef999120e2a5bf259f7a49cab2d577ea5b67df913b7004615629db3e7d92b754c93141a3ba71ea3718309fc19c928cf9e4ce94f9c8e66f170d633e411304afc026f7bfa3b4466a5ed41c47367693b9bd95dcfec82615c485bdcc62b30a1fa45b3c44d020207d03db91b4c59711ed793933932ed19dc58896a089b0efb6e511529848830616f81ae60b8c093c54b577b6c25dee34d04fa951cdaea12727c047e949799058aa40abe555e62919085646ed3f80b243a67a65f842d68fcd9e47100ee4464d15456f407e06104fce668b1ca102f351146e8febee3e45bbceef2347a9c7512aa8c3a186f16d6bd7c2ce117dc5d9d30b0450c5dd94e8a7993dc94d5ec42d2f6292c6da37fc1297e57045d84cb65d212f6a123e3d66250f0a7cf5c79caacb03594971b3e5d95cc310fea3f4851f78479f191e5df83fefc6b5c4ec997a4133014a2f9f1f45a338ecee76cfd7d05d46bac85dba9598f826780b5f9fe927052f31bce7bd65395bd07c2817c7c94c1b2d85e648618964f263dcd27a5a842f957a8ae941e2eac66e59e9a1bd20d633b72ee0f8e90efa2a97fb62635d6212a4416c08eea5bac15bbd5e8676093699692de544ccb76309b956a2be0b6435cc328c426828c5ba26baa84f501411eb68850f04e89eadf33902d716ba60e516d873f1ed91ee05e90fdd8962e595c4afc2e34e05a35066cbc669945809d9441bb1cc8e9cbfab4deed52e4cda46ba04c06b1441df35b0b45da2e99f7b4e8d8882d85a617959ce7a7a4aa477800025d72aa4d364d1d328a77b0be6b1a9a96b0329c06c52a0db8ac9c5c3d9062401593c80791b821ebbcdc2129c3dcb1a904d455d763e38e8fcaf5fe6fcf8b7827f2e553a22deb72b6d20b5a060ab67782d01783af9c7f5e30304761bd63ed1bbe45d4dd4654fec8b4c7ddb4dda78bf403af4abde6d7e9581fe2e83b7d13bb0c986f9084f207faaf7122bdb62b942296c45c716bdbfb3e779a1db25d71ab295865d5a2801fa717f151e1cc94e0a0231705759064d11b81aa2b05aa2d6a4551985d903d73d23b90eb2f2667a0963681ff3ef084db8d16b951c7e4da0e4200fc24481851831ffc923cf7d124d204a04fbc33c1722dc83868f10ce5aacf2df2c23e57efa9b346a769ba7a4831e060e0d62f0ec8e960de135d5656066ea5ae970c74468b6fb97ec50e015a8cb343b85f488dd166e7234cd95c15a6c4157ddbac3f709e7355a990c125724a4bd542db96c79ba6e746ae796768cebb8aa27bd758b613b23dd6bf6cc5d4be891bfb140f7790688a2364dbbd68b90a8e0b6c07173bf04d8e5a3a7b8ca837810e589ae950e8dd34dbdd9110ce33628f969ce8dffbf9f52650c8f5e12cae0a876e709874e43ad3046c12e823075037f63bf0808f718b81e778414c6e9dcea7467498dceaa257c7380f3b4d10a56c91bbe524e9bf438411ee43a9e9fbcd63b59713fc7f80f3c4435d9afc6ab9bc944f40ecd41b4242826b7e4612da45a9768a3ad08f73ddc60c6e7cca9646ff6eb79af45a813e6fe0ee45cad3c521e5c7e5cf3ade52f1fd7d6f7c1bd66e50296942a763cad360e4a5052a5c72750d61db0da162debc9d81cf4dae56cd3f69a4db7a378cb38207d8d5f6b1b5eac71985837fa0917e3679dd35e796d8c61ccc75b8da1cef18d308fa3f8d05351e2bd005bb896209a356c55e9afd33c218d9c11755f8267f5145d5c3cac2906ab7edda8e7e8f6477185d7f3def65a461a3d3a8c92b52982acda42de1e06d2ff00ae5e75839856f8a319ceb3dd5c91bf9d0526ada202b236d1ae11abdd7bfe2b6691d66b54c8d5e312c10befddb476da3cc0025fb415c053490b24f6a97235e61756778edc58b8f50f595a3720a8b08495a5ec9ba2f38793aeeceff41fe12989e4dab96b693d335c9193c600ecc682564d3b35c323255c5063c07741553aa50a8332f5a6bb64ed93e71628d6f499a8ac9dae25a722ccbcfeb4e7bd2065fe73a6223410af93002924255503d679d024df477fd0b633867098b971af9af5d00c3be6a8e36b324cafcde8d8340888b8802f268602d2bc8319f519f886283b72a05881d1b67688f81b8261d365757a037b1f695fb8cae31e141466d1daad5ad0a9e38a62ec3ba81f62b3f6beeeb2a74d243743b0ad8ce23f69a67ccd79ad92d95c30ce22b61a0e4c7ccfb9470db56dd5091e32d2b63d3d7ad9f3880e7b703968837cec3e39b8be8cf962d8800ef53082b39bdc0a859d41890aed045c671bf797f031ceb9140e64bf249eb8eaa180afc89649b9afc5d24ad22b0c2dc602547c944a0485945f3557a64f2ee009a02c256ccd01b59f5a7c629db7fe1ec1e659be79b9787f4eb5e67f7b814f907f3f83f1d4f4aec6488d94c6ccbcc52382a9e09b8e4c89dc00cf2af8cce1672bd1a3a052dcc2fe65536b59f92a1bd0140dac5c913a5ff8506b12eabf0f67c16c8b40c0bc38810f95db0f04bcf0cd2e34542e8b25b14eb844d76ee5a3d6b7e3027f18d60919846ee9128fac7d09a145be0ae204020afdeb648dc6c3931e2effac2a3129db007ccb0fcdaa3fa95bf84e9ba59a9b113dec66aba5f1f60b1b561e0a13f7d71ec7a4bd4489a6617872a56fa1254e9215506b72bf134712b6f21cebd51c4a53c6c651ed6b2dbb7711e21f7552aa79eade5e6bcd465856278384c2c2249a74ad62afdbb96c15687e5e133860efd0a59edeb41d1afe9d6bfd73d94bff7c12125ceb249a5f83e6571d243d337653584926d7c4485fce13ce0a518d2b2d9dc91fc64de7dddc70ba2c11924adc436d2866541ae859d728b56a137799985dbaff40c14a188f5be0f98cb0d1eae9b8534b52eb5063610309150c2c0cd8e2fee155b5795ef96d8f4322a88584860dda9d4cb90a0e11b4ac9dcd1a15846ec5499436c329a04b4d50526d9d5e21ea6a18e935ac96e782943aca3f8bcf961f400667837222646f969fa848e8b14266d98213833acfaed69fe1c691dbe6fecf30bc9e4fac0e477d50b86f8e5a8572e2684bb6770c785e107698628d12fce9d7dcdc57a842e9c5b440c1a15ff1405e79532b19b48a0021c04a6f539e47fa96abeb3d3fcd7b2fdae4e3577cf09b79cea8d19886c34d3ab69b9369baed61215f1f02c45e652b43179908b6c8213897ba960540456573a3e4b5319212764cc78034d1667a8c7db2b375d1182e810a98a450faafcaba873fe70f59b0cbcd1da69cd4be97171cd2a0adbf7fc8e7814de3add1e03635e44df08699b613b7c33d60d2a9c3f8ab341dd404383f1d9ac7a06fac6c58cb13bab0a3de001745ed03ccae85c74d31a1526b306b82bd2013df4f2c3f0fe3c6bad7e29b26c4e1f79f8547493d4c6cfc05c3fa6490b4e29dd8f3fc3b20bf50a1f11a5e3267066909b9f58ea8e8b3111b4761c28b7b7438ee54f6db22bb9c0b49616ab3d11fdeaaf1dcb97ad841d0c02d60362f945c73f1a54824824bf48f77de8e63cf33a7d9b83bf612d0504fc20e5e576cd96edcff191d1b4910a8ef1d485a43d5cf960fb4b42fecb6c8cfbbe71d0335fe442f6c356a12399b7dc5f863993dc87929159de55104cfc6bcbb1503f9d1cf878c7cdce00b27d143b87fa26ed23ec37573cbbc2f8a3f30e2260f30c7335ed60d3e22ac178281e6fab00bb7a07ca06da01d5b9a99e0eefe525bea28dde1ba902692fdddf63f8ef4af745b49db24101619f4975c1c94dc3047100b82567dc5090c2845b909b8a5fa95c61014dec7b154d9d6139c6131315a71dcc43c0c21b88498a15f744a932d863846072530f3abde72e18fe607bffa3a4b2224f3f3b43cb16b71a1dc9376daa88a2f91370889ab7bdeaa8ebbd7c2dd9790a696382ec2d06fd35fea10a487f9e7b4295f89295d274521f1cc2410d58d82b9f9241427d7f9a2e6d7a5e7d093b30057a81d7830f29a082223cb883146afe413bcfdc136ee335a55b4da3d6188fc5d6aecf6e81db0a16244fef9b369e4832f0b963a4672b0050acbecd862f6e567c10a0936b3670970dce7b55fa4a3f51834a2e4dab3d6efe70024500aa7b28f6f837a9171049c69700f59537a4f10a100de3cfdf0a3c5ec282e5c0c1b883d55b581a01eaf6478e42b6964f29500fad64d09c7613625817b4ba05f67e23aed0b5c802a3940f9875daa5f284393212b2bae951dca611b896af5021351bf7273282306e0c67a5de363b6f7b42fd55766ba5acb1126f7e2624285c398abe6cf6e3a66a7f69164d71ea37b5fa6bf9d36bdfb86522fc2a4e5db6c1bad642ced99b5334e6141c0e945581847086033a43a73180b88f0a51d970a43804c888eaace044cccdc44cfa412e5b3eabe463f39305233a0d2fa8bc2bcdad45d2e879bcd99cbf92541f1828423bef31a3cb5d554721b5a9039e50f2a3793c71d0e5f8c241cdc128fe930b74e30e22e1baba8959ed3d878062b84bbc714ceb92f672451044c07d018f457061d8460de25bee9a119d7abe4f46f22c587298442c9ac8aae8a8c9ace2ab1ff084353b48718dec05a5e5085301c64106b62acc87628d36a56baf0c4f3efdaf487d2ca19531729483c3881b8689885ec67a696a3f4b4da8e9d006483d7beaa70aca477d4be24b1170d4658174fd44631dba0927d162355462663656a91553185bdbb579c3be5879e9587d5fe22c585969fbf2dab8fd1aa3ea76fe028934d41a1b35dd54f84b1571208e70b23a822908714647c896b5ce84fc430fc09afcd25468b888eae2552a11d13af1e0a5f067a9ad0ec7048bf62fd3a60be771ff2e17bcf6dbb4d806333cd7ea4297bd57c580efb8675663751bfbba8d422bb45ea6b2fe1d81aa79ad8e48e057fdfd0fb23a56d08e3a82d36262202e4435ea23fee8320f82608526b258cbab3e525ad3ceba25cb1ead471c42fd07bbcf618740fbb2a87f778119a3b25a6872c09432481ea290baa233080621533399b0205d3d3edde88c01e8a25a70ad8171de77a316114fcfde280c64e4fbcabe6c92f4c69c26672e71d7e0a0183c06721a3768c18fc43df9882912f6ebc8ebfe832be4de37e77349e8a496ead95c20722798b981f79dbc23c9c776bb80a55be8e03a6da7c46bf5a3a443bb66427528f627d3219c14a1006faefc25819a79fb94a4961f6e8a0ccf5f3113d036e9898a4be6d78c33dce8db66e7a46fb5edb691200b00900bfc67ef6528baf4d2c27c365eb92a05f9b2223646131eb091d27e9a7fe2fd856d53ac7043a2421e2458b53b4de90be88e46f441f894f3b1c0216f54f206486e6a700c5dabb4a036867787a454a3e945da984cf63cf8b06e729c5b6f41b35ca77ac69f3b89a7e6f81a3be921e5e94f9628e1ee099f01c67029ece68bbf5d1696ddfb2b2284d74a87750eccade9ede236fcf31bdf1b09915f77199e85b566e9574ce5c9a2e3e21ec64bf1d72eb904b56148e090f32a9da491d483a1220bce89fa21e98e42126f2e8ec3add5f34f98d36493a249470f91619a637febc36c8be1b0fbe14f6867414812333d71edb0b957d70824b315178098334213e0fe4e95c60b5501d4cd56b8efd3270362a9757f0dab89575e39eb09beca7367ecebb510c3588e150429f5a2bed9d2aa4ae902f45f46e8491e0542cad614ca011ebe6b455144d88df4a9b6f51aa8e3ae4b897807b79e26129e8d9b172185fb341d5806b4b5db67dc9e28f2ba5ff20b5391c4b94b42d6d3fad7897b797c538236350e665d2201d7905760d6a9a616c5b3a63ca2b8ebe5022a896cd82ef3715c3d7a7473098c1f11304c3530c7b4e727ad1cebb80135c304225d4a308afc5d8da384886e60c061fc2a633ef4cae8ccd70e3115a1401ae9c45a91b934d9ce2ce55d3c920a671ee2e997c41b048a999bf3134a27437c8a7c89c10f8a95d102f33591e1509bc40898b30d600f2e37b2cca7b9ceeda2f85bdc0cf09c65d82d6225bbb837f45c048bffd624c482b6bc5ff8d622142f4f80aae6532cdbd97a750a973bdc2efc6797c88f563abd90be933979490dfd8b5130f3a459418d14cb8539f4fb4bda8ccb79ca545eaf4a118612eb9fd8c23d0e53d29684328e348e4e22244b77f2d0463db5654b7fcc60186219bf614b6c97936740e10518a8fa1b08fac82b5f56147a030a70f759bde37efc8966ae5cdb3fc5a138ab7f72aaca4a1834ca07c66d45074e9aa0861599569e749c171bf0af3a50177e7098f582dc5f79cb2f752094d1b7ee55e89a5b19afa57dce986bc86e2433a18ef92b12c5a5bdad14289004bb436859a414db7dedb08cd15583272db27a681fb3b734ab86f1ead5720ca7614b190a61b85b4dd0bd572f9051f121a48bb63e84995cb72dc939ab5da37b9e68e379d4d5120b4326284ff2242c6a4218505658e053f1c9c24b2eafc1804dad0660a97f9b5f42313777743ffd751a1a23ce94f9b0ae5e8816a2101c903f039cb47d935b1553af024b6b367fb1b13b48ec511d75da0a12dde648e6647ceaa906a8eb79e2e45dfa736ce4b3a7598711091f0b0721144f2a66a2f6936005546941ad85712ebe82411fa66b06ccdbaa4b2c5a8890d35c0d2165da055b7f0f7fe713f0f750312285c86722a5ba390257fd39ad0e6687776a43b2ad2635abd7d58f8c78890462cac1c349699260992bd75cfa4e94c30f0d0a1106b9ce08028690a44d8dbd9482131564652728aefa509ae330ac63d41d23e940eaadb5e04679f09f49297fd5e8ef4ec24d2748987f340eff41cb99cd17edae3666d0fbb95ce0165e5984f129bd0a44f3f799f9a5229f2030d7af73ced1b6c071af9eb5f0c3709d4c04e5abe6ff352cefc06c22f240cf1867c2d4cbcff274fe1b711d7eb0578b02d530b76362de11a7e0a2f81ff53b9109bd84bb12cf55fe769fa80de505670b0f5fa95cdf52609031e30e545a9a52e2d633f77aa07c4a91bdb478c902d6480d63651f84560333ffc1f1e4ff093e92504778ac0ad6f0e331523f0b631d44155ac3463a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
