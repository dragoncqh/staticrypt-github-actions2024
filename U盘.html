<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7cfeb59144321efabdebe217fa9a9fc11c784c0b23584833436db248e1bc836260ce84a624d269c4f63355a519f05cac45b02422edaebf8c940cbafe05ce8e3db12bf7f99034a157714a1f116af055ab28b41167cb4e60dfec7c2e38201338c5b341812274de1b5f567615375c78917a8149a8a0b81b849216305b25153d404f1acf342d09ba250e18fc2aae37b2667b04163e240cc7d4f35a587c055281529f964155c56814dacce50d1139a302a57b49eb70144ead4857bd17369f83eda04629cfbe83197e0bac8e090bcf22423cf1c47b2af2df52b1776aa3947165b6869fbdc389a8b2adcc5d69332e43e445ee5648ed58f01bc476015b34b2069d8af24b04d233236fd4f2ede9fd8f9b318809cec6e36297aa0e55e250aa2710034a8c4b4756f013d6154b89e25d19a14b6c91129067472fa7ebd3d1612fd5cfcbaa87666e707126a2685dc2a23650ca23f4c7892bb355692d0292c270c64f375d030f8e8760b9762825fb69b24fbb3c3bae06b7df18b71d7ea06866b21fcea8d37a59be8828bb70f505c6cdb5e17c69812ace00733e5c24610cfcbb99188f2bf7b332dfa0a9a0ea1df36abf59e0fbb08597a27542ebaa2e8311f4a0bede42b3c77e5d4d30edd9b611bcb1058c94efbfc5791ffbdf9ee6f3b25e57672a77d2035054be13033b07d251345e0d4c90482526c4e9cd647fc3b0403b05976f4affb7f975e4ce0ef4175d76b5653bf157f3e53b267e9e536fa9448697cfdef0d0ba94520f3a7d724510ee99ca858bccdcae45a5a3bcbc2096bfeab10c8732724178ab0305708a4650e1e4d9924bbab220701fd9d173d2ece47135a7669800be401cd3473aa4e3506b393c9adaaae897c0542bc9760ec9f8ef3b8de9662ab9f056e0667ae696e6bb8b23c63191c370a3b87b292dd14f5f788477759923cf31016837d01c394a2474e62ff5b14e6f8a0f062fc258e854d88cc78b0873bafb9757cf5661410c092622a6c9187c0573b6e3d84d23a622184d0bcb2f920ac7b248db485ffb075eb757baede6d2d1320643bfe12729743b447a49723f0484060c4b23885c190028d14da1d0b362c9617ad9f9afc392939d6013ba3038be63dd651c109337631e0d9323cc78fb742ccbc8cd4bd3e1b68682baa3a2ddfc086725ac3d2e52eb2a6ff939d63398ecaf2759dbbc96e875946780ead7d93bd2dd954e072c3a8f197fd5cdb86dd4721e8bacbdd94d9acc81cfd42afa9185e587389b85994e11dea5670cc87f8463a3c9180d600657bb52c0106c3d576127820b29c0f86ab2b1f9efcc0a3f996e11cd7c5d83a17423dbab85a980f5f0b9567577a6a7f8bce0aa802b9785a2c4c426317dd7ea35dc8b3e9ad6a45dd4536757a58f7cfda4e1db834771ba93ba6e474ab22d2e7630f9c762b9b16ab31536e34117723f998c4fca0acde817521a0c33aa28753a18faa04133ec5321e2e998465dedfe404d626483ccf6a1bfb10533e40a0a6c20f924c0b4c92081f9fc066317022d6ef66d7ddba787fed9b6c20153104adaaf4fc2296f2ed88c3608f0b111e09236c8fbd49968280fabb7962662615de0a951041cb35109dd013e0d2058473e7678659fa039e365404b75076c9463fbd4a2e9dad58800e7e1d912702774add1d836dd5842fb512b538df59dd81cf87d05e69a51c84419a33d34b1beafcd6242b269e250cc09ab1bb7ba163cc96bda0c0b91ac51589c8a1ea906879b5ba4c7c2d3947f1ec6597bdc1c232357449ce1094802676da0809feda3e2770ae42fb9e67f0b0a72b0f02100f69ad2bfd1cbb6294145a7e142f2f44c44d57c3aed59fd827f8515f3fe0dc16dac26ec6e4779174294436fc0ff4d738936a8f32520c8f8240e999838203b6dd4307a7b6531161e9102722d86911c20894fec015cfb0b3f1f48f92e5b5492ac508169dc9284e4cdf3f00ae01012788696fb93fd2f99f3af411f6d68aa73e1c705155b38b56025d11b37aea4fc1a3494b5f2c5668200c34906ab96bba7ea7cb52d10298325bbfd9d4a99589102eb47064a53a50f5493bec7c934e58996b5a2a6985626530d5d22dfd6d1a198fc2f650bcf06981b728ebab35c49884acd78801642be61e23a05c02302c628dce39547e80415a830cfb91fa01311a1ac01d895f558562073f77ca371ea5214355092985adda444f57065f62fed061b4f8abe927baa0d301923114cdf5511205fe42380c0f00da09e94855625b86597d55d6bdffa44e042607f915a3f812f77be87b92ced31bf6ffafc78f1a7689cb1294727b5c8ef9c1741653efb4e5a43c737e5eb4f29cd21a40fa97a30abf76dab8179d89b3e9e62a588c2f7d977b6b9f6c07df3d8216106faffba4435d4624230ea1204659f456cbf900e23e445d3406fff3b4fd24a6e9316c14a896ea205d42c6f5966aa9f95c476a3a173fcde904a8317161e6da4eebc96a3a9d4946919faa9a3fdd8135d4e94fb1616626b01bd086818331d90e1781edd808044f3a0cdce378ed7d51bdeaa8d54974051a49ee48ea189cc360ea1ed2d57ffdcbe3f40580f786d96be3bdcfa9508bd1991e28714674130c55c423348df824d3d2208aafb0a581182979dd364652d142041e989ec927f67ee89e83796f6673ff2adb1a3ddca5fc18c99bfef97def9b99f9d64321f6db5e926aac5b08c93f4e8f7e18dcf56c102e2e6fc976464b57ba5aa02f2a35b8833982b0884488c7cab73aa7755ca9dac154c35fcb8b848bad9100e11f9ab5a21d1053c48b5a6bb7deba01c23f9d5fd6083e730d049f635c04dbc90c9266506c2fd3941423516fd3f9f4eb97e4d0738ba305388d0f8d293725d76e32655fee00393111c3a77836efba72d75014c6285151c9a250c3ee9264ddbe2cbafbc13ca0a0b6d689728bec1ccdc2692c1231319b12b8fb3e5ccc2c940f98d2380e5ffa904323bf976e6e0ab3192f41756a586f7f3e61a6a123b8a677f5a7e5209c26d44d4c710a067c9d5589526ddae8f6e6bdc603dc5624b66f5ec8ce81333478bb28f181bbfaaa84be9e7682aacfa450142eee679dbd42ef7dae42ad42f8d18d8f8486817545db8f5bd92b1d99dcb8bf6b7f6503446c966493c122c4cfa376ab2c5d1ce8f7816ae03d6fea2c7448981887d064eafa7f3629440f7548d89891a20cba33be7739c0c18893539ab82ced59b20c726af98e12a9e8fd865da597b0cda23d22758692d8254a275e70ae9f8e64c0c43ba15c3b8363af73eb27c0ec6f6ddc08b2827ea90ee01c3d1c1a0c589d43f42f47f126c457923c0c8735794fdfa53699285721264abd6dd71926c83b6dbd7f52292d4abc03651f9769f5556be16a22f308b28b538767d64fae282b9a2acaf0bd366c7614812eed83bebd1627a039cb3fe1365e719c9cffa1c271aba21ef3ee2ffe852cec22f66c7f5e7298088ad527941a603000fb9d75a84ada2b55946e880cdbc38afb397b8fbc87b0746208d197475a06f0aa3a855120dd06433ac27cf5939ed1ad8bf6f6398d58d2b0593afdc627dc2e74f4462ffad9eba734d9f23fca52c6cf58d572cf8ff9e74ca148e8b414b8b86b604deccaa6ab661c917bebb0a9abc7b5bdff4c91a860ce8a96c7c0492a0bb1a208ea89b6159663e50d4005c858cc2ef84a79b20cc8216b04ff46a18f2d7ea61dea786e0c41087c9a2996d74f89bdf549dc0e33f6585bf6b7e2d3a8d5b9a146f55468910a4950089887e35d259bbe93c2924e7127a844b5299b5097d05d27f9bceeeffdd5deff78436284f833343560e8630ed16b8dc98bbf6a87f6306305ac62163d46562beaec62a3d657dcd8daad19d0a101805b0aa5010e7c99d65921f1580b7ee53b31f5cd771d72ccd10651b23d13f4a66865f3790175e1e10b8a7b9d16076884dc0dfc07048b4d8cfcc6d8c758806e8ea5e6d347ae747af927ac4898588d391c7f86d14e3813786f3be6688a811dc100f904a03454e8c60398e9290cca70e13b6eae86ae4d87f7dd1bcd925b75f2a216e9b32b7a2988381eefe502020f2ad77bf1858eaf670a5899acea135fff76fe12f50e50be93653cd46afb97eb1afd9d9b122a323bac0a240c4b417c7bd2914d3440446b5cd738b3e321d0a8e4ba75a657c7ca5dd666658d7b9e9c2206b37ddd28a1bdbac4850f034cab9452531c17781ee7e540afefe90cb16419ea7f5052a4189ef174052cec4eb16470cc1e16c129378b04979af73811b76a68535bd6f793c8db7a4a9b0a25e129641e230cf8401d7d8cecf5adea5c28bd8c2386fa41d2184690b8dd288ca4f50023420c76eaf19de878e3903eb17e0cc3523eb41f7c102030cd0d00518dcfd41d6aa99f942993d5821802a5cdd917ee582cf685bf9b31a611fcfb68111ed387a36b5fbaa211a1d14fc62d40cbd332e701096863e1f889f83951c65cb1db2eb5503bad6d2fa757fd6366d2ce1c93aecd06cd19a37dff374b7438f786ce28a2b8013117cb7fdcd0313ce24f240c46ca7b0ac428ccd0a365b3c185e55d4031a3648ec444976d854dce7e470a70745f987e11af36cf0ea6186614636781da6859f007389a1333233878cfeeed5d54d2287124708df2a44ad4b6556cba94b77d2b54e89798184420b1e82c48660efbec6a128033ed4afe0aff05fb39e66909fbc5df1b2859cfd7edbe90cb3dd1cdda894a7eb4893d50a361e84d500589da82be4aaf7199ab9bba718b7ba7ed1f19fedcfe612fafc6e6779631d24446e8c0b570fb472fad2f9cd5e8aa9b4bc12093422080817039a0873a390b80cde10a55f682c04691c15bd556c19a22ab54b8192ecb7109c2624b4512c935913a512a3928bd30658607a18f05114e8a87f38490fe5dd10595765a97f92db6c4fdfe61f59a4a0bdb83d4887a1c1ca1ca3992e9869e5cf0b17018e4e303c5727a585a194b3a58d0aeeee93bd36c03dd7a357be78ee2a54daf4ed3591560e4f3c78182aa24834f573fde129022d3a8fc533de72d4b20645aca5a1c9c3be245b95f610a86189ee8f9fd093c5738c07db6a6218b0cb7a11a236c7cf952735fd308d50f95c0924b569b63bfe8d84de20a14049d69607e3cbcd1ec54fd27941e2de586b3a227731a60ae85e41fd0bc1379340f017bf388d4f4e203f32573ed56a3a9bc66c56da3c64bafdc8c783565691165517f1c47c79f28b39f0da3c27f37e6024998963d1e9e065304514718cbb4866adfe8b811e3a2f8f2e83e313de70c5e45e6e63a8457173b716ba0753b6635d495fde24578cd26564b309c1c5f81813cd87260c2040848fb17298f324079ba7ca5bd363f896b1c03781640bc21f8ff49c6495f2fe297c97b4f788521c1955a17bb69c8ef0576c014fb12e54bf42a94bd46e9b446dda96c1a00be42c8540d9eb56a12719af06b7e058c5679d52f5a3cf29fcdc8a60db5439d5261aef4d4340aa03b969016f42da254f8b6544ff9a342138d7a0d0b88019a6a4f4b9984818ebc8659117c56e779f6a7cba5835ff3b22c77fc959c1bd5f99b43806bf183c4e334bd5d71303361bf30d7909924a2fba8fddd145a0c33b5540dd99fd1928cd68fe1a2167f183161cbe01e0b82ade0259fd0c546c14f89020ae5505d17d64a96fcc8c306b4190870104bac27d93c8dfb0e31032decd8fdab9bd3fb0c32ff649e586acc589fbd04c9341a6a0aca06b53fa4310812d0ac3bc2b4697a0568d08efa123390f2c1965f26b45256f021b42581268e1063fb417a236900020d20ada246ebf04800de28c2021b16c50a0b826d22916ca8d38fe82e4d30aad4384d20151e16e46b404d7b4a19a88504c1ef53307cf53ca5a79338a053e2bdb6c2310848519b23e7360602744c7310ed6110e4fdf33a24b9b21b2850c8bce4fdfcc2504aff588d9217cf767b1a76b59c5b3795dd6a0b60f50d607223b4ec00faa3eb3a3ea003e40039c758d758c305a2e29fe3aace667865fc2aff3ff91b095040ecea372f4d05f37df7d183ea900da6eca0048c6ef6dca133278036b37c843f65c66e073a7e5bc6291fa11b8e8deb879bf57af3b5d637f5c2c467638b4789948a487fc7992ae3d97feee4eed7991593600e603a56e22e354eb307fdeabd3a187ebf364fd6b0e9864fb2113594d7361c9a3fa1effc7ef914c1b666324413415d2ccf5b21c0c67e4516fbc8dadb30940ce659a7a9b41a008a3ed9588e286a72e4ce9ebf3706c6436d45ec4f0bea14c4fbcbc20e1e34a2dddb66dca383a39d5dfbc41dbe3b598a85c296d9406643c2b86b197d6e6ff3364ee5ac7c833361e8ce3bc0fb4a151b83192c7420981d633427df4969bddb8d19d2bbf715f60ec4194af0a625520b97c3d92eb38d0d1630bb5a4367d5db8d2cf0af86b973aa41aa9957b85d1646ad2449d70fac93fa90e250998e49ae7ee4ef3ae66ac45e348b51cd85d0684f5be6dfa4cf345d4959cdc9af3860b6d0eb5617d2250c38d056e02cefd045288e02338c64d99ae026d5aa546e88d3684947b699c96bc030091bc82083973e24044be4ee9b28dd86abe45d1e1c22cc1610b6ec0846071f6fbedc7a5ee69098adfaa16a87edc451d1ee1a61df7a18b830635a7d0771a08a9f65cc29e3370798b54355d576a9bc2a02b844e831c0edae7078b3763c614738906a7b1056d50d48f27999b1b4739dfe21ff6d49bcbaf40aeab391ff10ad7e1eea0278f88c8827220c3b00beee0570fcfa86c5db6ed74d3fce920c518073e36740f53c0b303cb3b32a10cc014dc931c0dab749445a9b1aeded66bf0e1968e239e1b1ab1c64c4ec1350688263de6d05eae3f34a97d1b513f9d85f212ddc6d133fc91ae515bb800f960dd65d4c544fbf5917ba9bd6fca9f47390e17b2af3882d87087c1c1e8d52e741f061e97af208d30327e9c1086d226e8794ded8c22e2ef31d3e7dd76e9b69da042669ffef3617b7787df52d752dc3f0ead8b4c08e89e07e8dfdd0f39e417abae8c06d893f84dbe6fcd522d3f8e215369afa7f1a1a22a89a750758fa408af44d046ba9cac24fd0d7062eee79f4ba3d7bdcc4fe5c1623ec0ef8376f411a0a3d78abe7f3948f51acb538e91d16dbbb7b542335d5e0db9ba8b7a00fa5b4e07e29c4ad9922863f63e9ee060d094d3a9b52249027292b035c08a50b3133e70009833a46a101abdd76d4089ec2087ca99db5dc652dab2c0d2313fa9d09c3689322b4d67bd8993ac6458f64287495036d03237e996ae1fbf7d52f11a02b8cac0077cb7be017d48e1c747cfdfbe5e9b9ee25c3d64293fa51967b1aa059b79d32e3f82d4f3ce5d9ac45fd95f639a4208dd06ec3d6cbd6cf850d987ef906291e348fa151fa68daddba29fe7f1755ec7d03fefc3c31f68fda5f72a4c11cd4bee65ccedd296377a5296cd1e18ae217e37fb0275656c6a2a480075aebf59713ba372b82c4cf24135afefd34edfa49202f50eb3875743ef751b25915bc79527bf5b993b9a536b8ac145bf20ec0fefbca6b5da76518bdb92083230757dee54d0de726dd1d79af32ca71af2e9cceec2a0f6e97170b7f62d36edd37a011b10fadf01276328fac2976ddeef5c95ebf97cd5108b3028fbd73888c4f84fcfd983d8c59d4a80ac4d1716ebe1d068806696cd2453aab88579a824b6d6c94e594e74ed1d2af935ca86f92c6092215153cdcc10114d0f066df8c72efbd3641b69b204c9c4a8150a3fb6e2992a8d9d79a2b94bf2be7623c20431c2417a3954fe5c5bc2fca73cb7badec827be3572378471b242025a5e26e49374c7cd9dee1c808cf257bc3e56bceb4d5dddfe7e010e283ab1dbc32ded7b26512bcb4e1358783b18ae552bf69838979c061e9aab796a1d141159712d2e18aecb7dea988f71796612eac1b1873949879d3880133a6d44ea22c0366462656b56b22554830000a268e9b95bb4b449661fa276ead5aa095bcd69201ca41ddb051e91334d0cc213e84d200a2f91e1eae63988b638d5189a1944d12128dae2efe6c609303eebcdbbe4f3231fd5e5be3ae9add2662bfbe11fcc092826e33e5d485f22949b25b51aa96b20840bf453b666a5a7bdb8affae87547028cbb6a60ea266fcdc9ff94412d2546d583f0976041b7f6b0a84dc171d4c93967d8b3dc425cf4589842268f1a8cf8b638703e1777014c8391e25e4e2d529eed2a06171177a242b6a2614b3563a88a90eb2b1fbb322a2d471bfd29794de25cc3b7b10606063748d32201ffe62f95747570fe751deb826294f219c38f2ded9593936a7cb903c1c96b001e67124cee69a4f87b1069a93e7d430e1c5c53dff8358799bf49be6a5f5033e39fedf05cd65d983d8e52299efa4d3d44610c92c1717af183dc1b74ad175f1d58b9128e3a643a5431ec6452ba70fdd85a5f752a0bdbb334b9a576277302d0fcbad27c3d8cbf74959a7103283b8ea19de93557f7f78dbb8c3a66adb3dc77f9b75f1d6287cac6956b5ff2be3042015cb3b9b8b0cc5c8f60d690b2efea4eb2f6f46c245e4ec8926908bfd0684029cf54b3bbc4d35a39435f915cc5ddf798bd8cedc38d349279972831534916c8de655d9d1d8e9298936755d7bafd96e247b42d1f9b6dd668000b58132f1b2a1a1895089be318e48b36a90daa9734ba2b8330a791bb7cd27ec7c58bbc030587b29062989da8408053334383a144ec7be4b90ce34f0460726c5909a08ba6a487110a3117e593f5358642849f9db81b0b0092b1496133500ca0a94b4ac593ba3a5b4ca349b66aa548925556cd617adac02f923fef988fa3587cbec8b04404ef59b17bbdc2e7f26c824b6e44706b1900b4b374e496e4b9633bb8056355cc38c6383471c1eabadf00a6b0e101b1778675e123777c0bf04726cc4891817f0d3c3d864b7b3fb1ca830b9bef820646eb888d5323c683e9296eeeb78dc86a03e6d1b883fc26e1f2db14f65fdadb6e400a3d00e98487c9683adc9d16754ddbf2160f57fdcfdeaf9df1fb708b84a54059fae73a5ec612263d8b5da4f05fb0c502c0da90da60a324d338a37c7adbf07d6e8ecce22ceda0f9b50c8ba8dfc4773f05800e834f1dce7b200d75f086e0a880feb73a1d6b4cc57e6a067f8c0c1c1f77f9f438b929361fa1244bc03896b8fced50e80aa6bb5204cd7faaed30a8c8eb0834c958d03892726b23fe567a6a4577b5c73a7271ae4448de1ee8c5ff987c425456ef990b455a7cad20a77f22ea22b61fda56ea348f1a55ed5180676bc1c312d92b9c0f9348f00cc34c172b5088ab48a50b8a28606164bf0d27f910239017a0442c7e2a70ff6052dd44a3aaf8fdb1e877d2acff8f8feab9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
