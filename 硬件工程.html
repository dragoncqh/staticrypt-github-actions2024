<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8591298d3edbe6806ee26bc23e9725b70766a84b6fadf21a17d0aa1b7b06fa62d7f35dbf7c859acbb80a68bb7c8f2e94ece7aef93f6f96869ff49efac977e1e1c629f94de709c8f9dc6115eb6967f6421a08a828c1da0bd6011b8aafe66947aa0fb012d72e1aac208b29eb6814f73288ba8737bb0f46f3db4162c288b39240b0ca4577a573ec763cfe9f31e63742b2d71c22e2054e95cb45f82f5e0076d0ce9a8544d2ce615cd21f17de168ddc95256efad7ac9de179766ed2e984a446c81688483c1a4d5bd468415a782b707d90cfc32ee6bac71a91461f20cc8a8e266d413cf51435bdf6de330ccd27100300afd6f11197d329d9069dfbca4777afc8caf3ee4067748e797a7889ee8fa50c04c1ff7073c796a291beab13ef81fb11a234b78d70a63f07bed759ff27e591ddc5937e08fecd313a7f4b6c8f31ff7a709e9adee0e77834994480d82ba5a8c7da6f647ff2788a4092d703376535dfcd49d93795c6b7bf7c1e3369f67abfc623c3838bc5d5fae9c4686a50539c2ad577b7ca0a383c1b40999b09afdbef5f649f7972c29ccbd8e662f2099df822e9e9389c886a659cee6d83ec81dd9518bac6848c626d18548d8082b23307d98e770dbfd1b7783e47b73974c26aa1a217cee9ec344f22aae2430a64bfabd6c67493e6d846d3666d13254162362e5ab654063fc24825a2dcfef1a0c4e7a78363cecbcdedd96bef4d502f21bd99f51d60fadc50b740387f5325ac73c2046eba95dce3d21321db21fb681921e787042131ebf0282b270aa99d4d2bbcfd2adaf91a66c5fdd3f5e0c293193f2d6e6794ec5ebd5c1527897604eb356a70e32a9e3f4667949ffcc19b0b56e9fda4cc89aad2bd4be24ddda18baed76a09d978f682e86f770f7d458151f2bc78bda6c475ac0a815813a4786a05ebc4c9aff49818252f92c1b39ff48ce92ba535acfe01a3fbf26760e8df1c5b95ca2c990607e76a8954e69f13d530e6e4cad7675fe1b140fec2961f958f674cb4d514bcab7e43f55caf998580ac82027632429550deb3ad07a4ab9ee866a36358e9f627c491b291a769c7c7f18c9ccf4683dbcd033d59dd329b56a9050652bb5d4abe74c28391a9648f4e12e0338e5f0d3d56d5c0587a345f884542c704e84056fd00aab50d9377f53d563d1b31585480ee31df65d62b814eda10dc9c282276f5c900d022d1d89ad8bd395924ad12390f03c58b9d5ee7705ab9ed9075ad303f64f7ebb9235a67c0b2b10155f7872b3a2887f4193e5062fb455c47fe25d23d6fc1a0503d8da4090de3a021ac4b62727e22f06103c90dbd9e568c64027b25057861fc52a04202a38c502e9740c2fd55c60ad7d1fe9837f637fe6d19d345c894ec7e35d71dfbb875ed60118e5239d4ed78d596a1ac0cb77c532e5cb1650e8ac608902dfe3f03ad81ae33b446a24186cfe48dea0979dda3f0e12c92a4712b6cf335e282d5f1ee0c8cd4641d21f6f274f50b30276cab6d611487653b39a1fc1c2f1a0ec98bf29b12852cf0474a32553a4daead26c897fc048b0603d69aac4eaa192b3e72f7e6ec2340946a320e172e51488193ad956953a033063acc70b7cbcc613094f0bcbd222b0649c66a775e1b3d801698b990e39bd8abfd1370d6b82129e4c31ecb2ac65f23be5aa8d3d422ac5b52e09f00fb61b895f4c16c3bb266b66c7b8a87fec2603e8dbb9e5305cf0b0ec97b8ef8cebb787d93cd34f94b6f23ff1993bd767aee5fdc94ec54f22dafff03c17d35f6f8d56c7d8526b496df60a17315feac94f41fd4880d15794df0dbc892f86450d944689ac6305a0856dff3d498a1cdf9a27088646c6f7879850ac90412f4eeb2a7d1663d807cc576bc42087d88262fda532d87c60684484b822719a750eaf776783da423317305fb08cc1671f12d7c0f5499a6c59502fee26c569e49381fa21f409ce364e4c8fbbb131a5fc09b1fe7e768edc61a892461354db48394ea0a8ed06dd459741742a4332cdfde9babb6e1f8fb43621b179922331518b519fce0c0a4416fa220f6ed379565387b854e59363e4e7f362cca2d9b3b5e587392d0b78a5c91682b48438dbde4251b88d9b0f67190bf36483d9eaf512ab003bb81beacbf0693595621175d2f64e68b85ab28277cec90dccce2696bc3a24935247b1ed2a580a3284ba33c591f8893496cab14b76d0b9ae4b9efe54c024bc10b15a773ae78aaf4b5cfa22292bbac3fd8c732d06d9c890b85fd8a9f7dfc007c301fb260f2e74418cc2f3ac39e37b62b06f53e3345ac1193864fed921c1145366bddbe6b998993b2049904428812295bd6222bbfaa9cf58adfb4773c6eae8eeaac49fda9cb1941c86fab29de9f8c33aa0c6cbb066c4736d2e00d53bd70218a9e86f7a29d92286c08b86c0e72ee5a0d045b5c6c7cfa29e1df9e40cefd9a181cff4c4c05c484f2b2309541637e47907ef146c9677b22995f0b088a8e9315fef0349d74a80336eaa32fa6034ccfe075abc5bcb8dc366dc3bad57e25e219be43da6d91d976c818850109e3d7870336cfb91d8d57cc3e76d26453694b3c37679d294118f7207bcd05d9687c7e5d507a0cca3a62d3d595c690ae0b6c45e2775bb32d343d093bb5836cafab6d526cc9430ab202be67c4c2ca8f9fb8e1138a6d35d82a01dd19e0da1432dde8522ec7a1d9d3bb5233992601d394c625173ccccb04cfafd34d18171d84c84d275258ab5984293b479341b6495f3a80f33c3a10e9c4b32cc35492a6ee83685944367a01737f86b519fdbba38331c1a0185bf632634cb2a98ae53ffef7098da2452d90bcb5c17e8ec9cbf4e9cdb6f40476bc1a98972443f218f4691f1ba72a690a172a010c29c933b6292c3142470d2f97b0ea3ad8364f68413bde172fe71a4eee13aff0e16a5ff45703704a1395570d71e8385b188bd3a5d7ba99fb7286a79aac5bfda650e21d2e7385024b9654854e27281bfa71b8bcbae75d548c675745ea14a306da0dd427f3f7bb88e7d4d359c167e23afdeedad641a0412ffccfb1b4e0906ad427ccf93254137f31c095482838e13b43252b2afd504a5ae49f1a7f6278c8ba663c151ea476689bd6e9fb15e45f7284f5e223adc25ff8c43cf6c7066d73921bef1d219f2361b8591b68cdcfcd477f244cc3de9f7299dbb9149f144f83146baafce7d7b6a7258d7d0fbd25de90f8edc1e25c6eec83fbd6ef1135b6faf4959454a2d5cbe02a74747185b46cf97bb73c61bef808dd07249e743b7b969e9f7110e1314a8fdd17fbd9f8ed9b8b09f309ea10ae5508fcca82cee3f45f7a5f1e4bbc1575834f0d384ead271043e1f2a79408bad631fb7cf8d70db19d51beeee552d2fce6fb791b3c5a7026ac512568c96426ca93c1fca658ef072cc17485a83798c600967b0c1d47b8f7e82abc5b7ad42cf9d3f0676bf5cebc61ca6138ab56430eec20970682d535d49b3e55855e1e99225ed392ff5c47a96d5cad9d78797c8fb30e41e5dead7cf563bc3abaad6b5d75115fd2ce22aec7c3c4dbdd5d9a8a1fa2cecad0413706809d08e92d26ad05318755e24b679b4b1e5b6394533e9cfcdc62d11a16f4e5ec439b35f78705636cef25d4c634bf2410c61ecd1f29290e1f150796129c1ab6fc6dd6a90e85f1bdf361cf4f70df63e827b9fd0e34ca00e0e879b28e60a51d2ccbd0e0f51149c72ffa4a9a22e6bfeb76beced3aebc9d3c46e198655e5b9a2d9ad7ad8a1174b12bb4ee7c7844aa59a43743837a646fbfb7fa6b75c1fa1f6c71b80e82eca0375020fcf5a58cbcbc2d5eca9a989e6a3d9fe2decad0bdaf0becde88ddd8728d64345e15d68efd7f59a800bab9de25e92501cd147dda566e0f7435f516fbeb9defe6d21638a808e823424323d298c6a5394b18b0c3463f69bd8726ab6fcf0e2940e56941a2ae9669918f2ab7f4d34fdc64f3fd799f7b94bc608ec95ccd66860f17366734d895eaa351b89304c5ed7239e3f2134aa7b2c00091a5a43e186eadcf0db8da503b6b08433404a07bbe4ec8e7bc4d803eedf47e88e35e90d1323d30aefde696ade19f8db0db22665e9e921b9d2de125817ae5f26cd8c45178d01345f3e19d2b0d0e4c862eb62c3766997d4ada35eaf746b0d8a94a3aa72ed9e0e135b77367139602b4c24cef00de84287d691aece2565e9537289485db4593e87c15cd717e1171185c4b2b3948626ac324a574868f00b15651387f5faeb0249edf6fa3b3324cc4928ee33593056eac612aee94cd1f07c77b7b9972c4941235d0461b1845d94add643b0bb8fb7d2ae5ad64c68ca3e7a89b0d8b9c50bc9cea0b5a42888234c914816cabb19e55aa10c6198598bd616a2ab99c81bc9296a698980e7170f61c20f178810af25181f9c152a48c790ff9d7c901c06fa15d0e4a7606260a88266509e46f7d20b908274a1bae894d1a1de59857f26d223741b4a57db47234fcd0909296f623e07fd4035d045b7fe35bc304325f1d2b5918b67aade0f63b15fba55ebffb93c3b6acbb2985c0c8f8c0c6b1799ae59c0392507ceb3c0ae433930a79cfe9ce80c75721ae6d06f7dde6655eb9fcff4c61fa426f962fe150033e34bdb7ab8c8c9e2f224e0d9aa8809355b34dc84c8472d240471b2a27ca65aa79377dbf54da64393def6d9d46b51079c83b7c7e4d3f99f5eb165a5a271e14234f18feea959d8807f164bcaa54ea462272408adaa4b3507adcc57f8557433c9c9a6a4ce426f84088aee0542366c6d03394c5f30a09fe4494efc8a2938cf07c1019a767a7ee6af2d6046490aaab41d81429f8feb9ee43f9169e91608eda590b5f1721d294c513572ea2fd877bbc651b381c26139fb1b469dc0d27601661255ac47de72b67a68f47445d032e42ffe9d4a41668099f112513e3d0dd836ddbd13107db0e46d2544c867aab8468cfdaf2fa87cd1fa258e0135f0d8daccdff765fd6ca32f178c7940d18f53623d8b878eaedc5b9b1357f57f385296d1df07ab6bbc5b2bb3d4146ea06c9f6e138f1912088111ccdf27559b8a3a84290d2b80a80ab6c76ad779ea550d807830c9caddd956d01b5eb7d9a8f0919295714ed572ffe607f37ee24d35ff0e0643af42dae12f775224c2836a9d62e4ea25bfef8af40d2b55b475c02afc40e2136b0b15407bffb1e012a8266e1e42a9f14f69106c0023d7c0d39623dc33ec70e991a3bf89f173efbd7d880553b0f9857c0bb64a2443a0b578828b24cbe50ef3abc43475a3b082fad239077378b8b38c2cd505e1a52b30f47f36efba4433302e5c1d2f9c6c4c1f5a0b65517306abc0eec282db3d3e7b1b8d72d659f1b6c07603293d42a3d7fa6b49629220cb9cbedf35e3cb2f10bd0922b72c8365f0fc20486754ff52f9ba5b3e31d94636b5016091b7b962b59fbb350d0c372c2d7a47d2838ccd71b77be8c39b35bd8a9145bf81d7737af77b19549aec01ea4fd63d48a1613779610f348eb797db868f6d324799866e8182332162017168307bf88c9f5170eae8f7b884615e966663c67dc5705ff0df1cfed7635d266f9097b0cbf80198f91f5c700407bb39e1eec0bd16d729f698f833c7812b7a97b90f7b1e02e01cfb4bf5f136d5397042e7bb0356d9073a4427d9b09565efe52ab2b3e0cae1461e565ec2b73e98a3e02c10a2959f82726bc78ffdb20e7c260eef43616af143ad475c4b013477d3766cdeacab0b430cb47d7f8ba34b038c58fef57e205f9c924e580db790d34ac03d3eaa4605cf765e51d89a8f830c4d8421515bdeabe303af7a2010524e59cff96effa240d0696166a634a17be6371d65b7fa3fe8a1e0de35b605dc9cc646b328f6de220315f7ab37de5c6518420e3e766f2a2d71b87bfc78a1d0b3818ce995e77eeb37e224b93a5330394b6105b18b21a7cbaca3a418ca85d2a4fceb3749a83a43e4acf57a182660ee5602d9373e546f661cf5aa676fdd7e0154aeaa4d0906d0f8ca48e75c7eea6b3b8ee91ee41a45aaca6e2554ebe227ca677579fd03a86fe9cb4c083c9a0b4acf8ff37a5bd1257d03318ccc0250d8b3ea6d060558aa976d5055e0b1cb54015633502c6ea1225bcd8c7b96d6bdd4a69361ac21f71dfc15b196617252bc5e7045c918e2bfd5fd40e5aef9d2be02e91da07a3c32ddba18a10eb1b4fcc676ab4d9e773e15178031830479b035213f880d254042cb93961e6f1132c9ee084650fbca5423d3f9df5ca7316662214bb1ef704571a97f4a64fdab0faa5adfa515b39c9396f747db31b78984714dafb4f4b62208412de9beece002116912960a360e083a64b28b5b0022393cb2816ce52fd093e14c987128c06956f3ba299ea328983401d73cbbbd8ae2c85476ef3d5381002859d3f56fceccb84f984d614c07a413bd83845e3710edb91a2c460f503dca2f93b3b35cfbb1f0a75ac245298e196c9c9aa2bcbafc392260f61c4575c95afe8267a84a31acfb3ccac994ee6cf68a8154af8758f548076a78b4377eb02d238cb89b27d1613e1c4d440bac9da37f5553909f8694f1aed5e931be4970daa00c4710854347c45e3af4b35ec18d8aa6ba69a00cb6cc1b20f0a884a678ac3687174116c2fdc2a2677728f968a6f04b73cfe274d6b206df1e5c12c79c72435d808cb34957e5569d4312fd80349628d81b7ccf8c75c1df6d14fc7cf3ee5f6938442057c925053b74addb9baed89527981502210a2e5210010947cd9f319781acd37709ccb3f486d60e37b92efc615c3ac5c08d101c44a80cb3ffdf90ffecf9f377a076dd209fe0b969da95cbb27795502517f86258ca2cadbff962a40dc48bcf7e99ce94806d0d1fe281e4f92c78e1730b30be482c63c11080b87f3ba0e7ed06989f72ec6f22a892b3faf787e221d2d5b3a2e849654a10f4eea75ccf58b86c60ba1167c8c20da2f65c0d6f576ef6922659009ef5b6f9fc6bb30516518c606e53c59c46e9db56f0be63a2e9037f73f24825e59b3c9313bc98ab3fc2f880aada03cea3705e682dc5ac47af06aa81789d6a87a8b4974e954c3553c76bc5db856b3f2f5098afb10b2ea2dc177fe63f6a06b35ca1e40820e74ead9f6939042ab7b75be7e808804f33de2c3df3a98cb1dc4dfe7168c5c8787f4718c834b5fa30d4171fca1063eabd41323068f06817c8b73df60e4a79d4a32af1c6d0ab11d1d59a441b966f107cea26a4ed03f43f7e3210c1b48067e04e6cd085580f84a9eeb0ca68b6dfef82b2283bd0da08597fc01c8cf465e5804a03c3e5381c7d7775401ef6fe5656e435d434bee84e40945113e504fae3c9d3e75694c6370c0f195c2953e0b3c956553af7d2bd8796333cb3d6f6d8d4c1167b0c2034dda2181aeea1d5982bda605b585dbecbcf296c085da772beb734c9140bd3740616fde7a90ef30ae3846a444755f1c74daf7dac98b506c9636f672202e69856354783aab0b47ebe63af9aa16c42d974e3f5d3ac75980ceea201066b68569f2a84b69395150c4a7ff39d9d3d7d29b3d1f02db99a417162f8ff414e1b682e7c9a00040711a188ed6c274ee5bb857a3124f658f3b590ac4bd0c19f71666fc71e98020a734327aac73e3faf13bf2627b10fe20a865c6d5f7836db608dc9f5168affcb9dace986aaf155926756c9653c4b1e913e1bd85e31c5952b7cc98e9f5c7196a586af3aed3751e54fe4de72229118b8a013f3eb79446a743ba6d6e5e9e8a8edfd9ad8cbb24f9db7a94b7c8680a9ca14aebf61514c34d79526a6adea44a9aa17f2ccd12aef12c89174f4edfac414d68f5c81417671ca96123bd60e75eacb4ebc944385e12efbdc6486e81f3295b4a9fa2bb96a10c19082d50a878c66a53fcd86e9595c1992ad9fa9ed3254dfe0221e36fdcc4ffed67ab51edd0f8c1162375dd35bf7bc95630eb9936b1fd95fe8e7dc86f061db85ee2297b481b1bcf579fd9184dd7e1738fc661cc16401abdbbcbb41929b3496d3bdf3cad6db9b4632c8d3c46f1867d484abc74a17f01caf65d0ce9efcdf86ed524ace4c3f21482f941511e79080a18f57ddeeeab6f5bd1d1990e6d8b4e8ed7b1bb137282a0fe8e2ce7ce4b033e0077df5df20d9e25493db9040c5c5453189455225dc758d9d60e3dbe9d1d031dcfc44854e0c05ebac74c980ae50415fc8ce9ddf52a6160c8e6784d1de85870674c966cf8be9a263c78efa8d799d45a5f1372ad44ab59f096c991921a7821164b196e1bad3fbae438ec7e273b32200bbc4d630ca7175a8ee5bc8cc97ef52f1cb9f8fd8d4b794ed5b1469cbc40a2f9581fda1d943f67fb600cd197d4d55777d8bd3a4f183fc058f8fc3f11d175d3058efd7606a265e19edb8f8891220bad70e9952b16d07e1ad3930065f3b12101de9a6d40cd4866227b8fe2c15adf6e2090fa7d0ba68588efd3930e65c829f81321433eef21ad70cf1c74e922b7494dcac6a5c4bd1c7893b77fa22daebcfe26effcc9dc5c0706df446a308302d0cf3ac72d63780e23d8176eb0d5e54a441524ddace62bb3a91ca1e9328baa7bf1bbeab4b29764614dfcc36523295aebc04c9cd639451644a777161cc75092760ee5b4efe9522b4695b09ae14816563a4acf972121eca4fe19d6c549e84d15fd7d84acb99303abc4b3e0f654cdd913c0e739eef7104ef603c6060e81ee32de8d1ac396582c2959631ca3fc6003b1f77a7586b47460fd510adbba3b99d140c44425860b3542f940d3658d8aade7fc68444b4d54fae627022d844418a68862b781849f18cc4b01b227b82c34045d5f778b9ab3d3cc20942ad6cd0ba3824580576c13e30bce265b89a481985be4181597733129fe577b75b492afbe1c59f7c2282687d91283540452c9e001982f0bbad876b6806ac269d883f65e8140dbce19d91a483ad6daf16be7052e4bcc667aa16054d3499d1eaf6bd35f2c550ceaf4f4b425632e9e9d3adb83ec3d8db45bab97140144ecdc51db52d4e4e0d0fadd9b365c1b7b3535c78ee57d4e49aa7eba9aa00146894496cd6ca4d6fad54a44bd09321e5c5d872c695c96b1e512a1d647be7e0788a8cd4cbc615aa02d13a88179ea4007eef581b78ba20414ebe7cda5cc58fb9d95c43e319b7a6800ed9465ea19cade2fdceef4bce85645dd0e3a3da939791067b5734c7f72a74786348f12ac92050f08acac7839b609d8626ffdedd3c57777c3d0a68bd49b3d4a008e2a71d6b0365a8e3f558baeab361a99e81beb5ccddd04e3a613d25efea7e18a598d4be6a88f93bf9623e8895ed4274c1bd81d3657b172fb0c40621692a43f2f941a1db4d770e2b963a9cdafe112ab96b60be7b92dce11cbada891c297ca090ee85ae437ddac43b0e9cc3d197fdb14e6ed7d76ef3e9c0ab122da17f5c1b5f5ca4f39b0ca111920b374cc039b82fb0af1e8d5f97ad9c0a741675e0eb13fc37ac845a28a0f7fb2a5025518f71fd639f925046ff24aeef8f022238fba44bacfdcca7e9e6ffd9300414ab1def4b288d72f6b571e148d47d951af02833f8d3504890cfdde1dffe9f46240d17228f92a8cba93edabbd2c7b345975381843116cf1ba1b69e9009b3b624dd73eff15c1278ffdea4597503b2e94d71b51f61cd4c897fb33fe9216c0180ba95d0980b280b0836cc6a496714b1fe068353d7a0cc59731ce5564618ac4dbcffcedda19df578949a19b3f2899d313a40748a47887b4249e0cf2f64aadb4501a604ab938e9decd3a27f6022b0be164137fbd954d1921331183200458e0db3226b34cdc51581a36ce258b7fb26d938442ea55ecda78cf22dccc7979f49ea7fbc76cbce57f41ae7ef0b043b19227247bff6805027f644223e521608813cc4e49dd9dfc4d6fcd96a217f0345e70a6a3167a6d72626fb8ddcb0eedbb44f2516b4d516e9ea690095151367fc44d6f77d53f599a7b632b83d715dce65e02686c5992f8edcaaafff0eb9b538b0a1746c76fb3317ebc084e3da61fd093ccb32a00b60325134846b77442c534e12eee6957f5b3067c3979a72521795bf788ed83022a5701ac5467608dbe6a0ee73767c12a880a400f82d6b84870671dd3b59b777f311d445d9d0341f895e13fcd2c53dd022dc18408ba18e80e6b6f26bb291ebaf5429be3e05b2566b4e7483f680d8c47a813fed9f1b5b438692b3a97aa8d82902d106756344df4e5ac7ec06aa69255381d322f3d2883833feb7375d07539c5687c94ec8619162b00d11fa5d31d476a848829e0f3d9d66ae5a98a66cc56c7d568e08d02cf6fa0f24bf184e8b402e219d3bb9fcd38f6c9034b10bccebd3752429b399b5bf118ec611ab038987a580e92a601ea78c9de38e02ffd995d54ceba76001169687d8d4e71ecff6311183ca432354fdb759eb852d307e0e8d33c52c0c6339fada61155729a53239dff585bb5074bf6557ce57eaa24cbdd7ca6c0d801ac82bfd64c6bbd2416ef5df12e37ad0e8a2e70406634edf3d205621000efa0b9dc93433abc8441553952deb94ee91127df619e6b56e08397d10270a6ef6c30d9d9fc970f74b62f2f18edca6d2f74f5733bc4a473694f95b90183627ef5515e4b8b365681cf93e5026c2eb316781093c275ff793d0b78f52689c19df1848a5f3490c4afa521803cf4f22269549c942d666e1cb424a7634ed356bd19af73e7b27170b3a5f6cce9300687d68502be6953a9292677c31ff974f70d0881315d51bc488170f7ba7d988d6fe94058055cf7a86afbc86032d3cfbcd58f9d33c69b80013f9b72f85ae70d6abad8fc365f124b8f6c12fdf1456e8febcf71634bb4eb3831f99ea368e49972708f237eafee8c2a3554c229acebe217e2c62c742d628a6f4d0c59d078949fe17a21dfcf90ffcddcd1205d0968cafba293650f46439bf04fdd5c7fbab5950f378d9ea700a41dfb4c23d33bfd20dfca327deaf8fad24c0dc915b436336f922dc591b3ea9f8cf831d9d2068267fe2d2f728ec75f03a6198be6492d8831208cba0cfb6257a44ee068ad9eef494bc72878374df1113bd60c41c51751155fd137d56a49f3263a20afa2b1bd1b104656f7ae5d9cd89fc6cec2c58e578e3390eebcfa29fbaa258f35a7a38cac0c1eb529fdb9f0d167ff23c9033b9da9901681628280831aa3e052abedcd00980008e27a00d7a4a668bf27f1488c7786ad33dee65cfc1ec9cf58b876ab4d784640ea678d81b9ce5f416dac2ca07eccc815bac619658ae03243e9b09a556afcb0268da0c9369045b919b87b5cd510a542d6b712deffb9086e54b50952a546f68fd8b8724cdab232d0b7023268d168a5dbdfcdc4e81946370a9508616d9744f5b7742b25b151bd83af5deb9ede75e34727498026717c1568e5b41f84088a7b21e1ee3253aef8989c9d7e07b996dde7c8113cfc731890f94f91b54a47f3acb772f8e128cbc830a12acb4675cecf486225467f3061642e5d078b0b4520e2603679d57a25d1caa9f4552ce09452ac6dde6efe132a12c074c33538bcf10b75f13b6de38a58d0ff06d0ea9de044e57c9d82b73e5eeff777014d8c821a32b6ed8fdda6007a81c040f61fff8e8ab8231f615a9fd76d56762f965c9ac7fed5492092704ad344082831a38259dda27ffca2fbb626cb556292a08fd546e04d0d814bf64f73513b02698afedb20642abb6e912d1db4f70eb35708482805d19adf5aa5ff5b1a6536ca06d594d7187961a78d53a39db57f9ed64bdbbe05e254df6afb29becd01793a573777a7f4f53df7e6bea0d602ba930b54afae2e7e003f19b08fcca8b135e546e4680620ef45b7969c1a15256e0bebc02ddbea6eb03e2d1b415478f6df46af43707d0400fbea29dd1542072deff3bc7b56bf5a4795e7f1e68e6b33c14f44c048df8732b461f6877e687342c87e19d1bc4850ecd676824aa738e89821d765eec6e36edce711665f6ca20e8f52355e461f594cba86b90e6a1867c5d1280935f6403cbf836c31f367bcc93e191ed0d5cbc863424d5a79edc4f7df4864a338b2b294fafd80d6abcd3a8e7dc35a09b5958cf92811e6ea32c8f821eae29342fe851623fe8d6a5f104d27e8b145a24e95129bf4b2690ee75e46543f326b2c45aff47b10e0886ef7538aca10f3d9368218e1dd98d552c7652f8800f715fcb3279a888b0aba72ff1f34dac5154a8c178c6d5e88ccba90ea1196f8bfbfd690214b8b87734d75288ca0d6d6712b2e48a9dee232be0e8f52a625f352b0fb6707ff24e668c286e6d3270abea8d1592a1a2e52fb258e7a37cf0a41258a8723508829d143d83d87403d809201d79105cb5f73943906ffcd129d0ecb8fa161e7ebf0a87d0e34cc3eb3e98c20ee9b15936f9618f9f32bf4d4fecdd42e9935fe561ed054a60ab00c767bbfd1eb3162169131190902431aa60159c73fb97389b5aabbc1f77d083773955fc5a4430c5ef42531a5907288306d46e0930dbbf3f9f62d694a9c282f864748863fc35e5a00ac8309f131a2ba6d02bad37ab2896ea458eb51a67e88a61bbe58c90c72d63a5a023509a9881e890e096c0d6730437b7622602f0aa32b4d2403bcae3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
