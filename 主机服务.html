<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7ce2b7078f9a14033b0748bfb19e2de9f5ab9719370b42ef69ef0a68ee094acf0e62d5db77c98887b8a30e2f4296ca2cd1d506337a381b916656fdb91c516bfba7778920706e85093b199e33ba926a6c42b712ab7c8beee634baaba4e2fed242805f4048416797f223ad80a7c064f748cc24b50a87b62ef441644a4b697de557cbb73421c95a41d84df35c114319a0322e665132e76811b2ee60d8a53d39a0730f8e126bbe4b9144eade7c594f37adc0d2f6adbf127ceda1cd31b905bf891e0a9fc3c606f549347fec278ce75380c33849e39611ef7ce97a1bbed561eb7d7612857e7ce212b91fc95e2c8668f1f876b339e2dc6afc2466520862a94d783e2f5098a4036ab95952695e73ffd62acaf5edaa6821c0f263158fa51d2fa2000e96bcaff961f609991cebe84c0d2c08955170d6fa9b6a8624dabfdb71e16faca78f36c6ddc9ae3e6a626fe473e2604a26abdbad98aeee6e3a598e631285e46e4f91d10b8f06ce595ea19c01d176aa1ab3e7c1f90731824b20dffab3a99ac0bb69e14f59f2524a694ff165547aa02658fa83c49bbad6ee379caf66069c3d7755144b7376bffca7ee3175efeeab816ebb3240e56087c1d46bd677b9cc3c73109013f400a46512f96a399e832c325f1ffc9cdca88b8082e3bf7fd93a0986eb559fc36d22ea14f6a03e54b52f44dfa26d6c8cbc6c3efe797377a48a19aa20b83022877b2d401e25a0cc33ac86475b51e5c747f45ded507573c3729a769265e484d63cc55e3d245508004d46161a1d10e2525c25877462e0837b8f65bc58b28f3ecf25f8d222ccb5ff7e52476f35a66232ac49390cd86239ee5561eccd86858de0ec3e85c718d7210e43d9b40bca37a3868c8d54f652e936661b5b712331b49f66a81a6b7a015af01927ad362b6530238b235959ef704dc52ab4de68e5134ae905d6f47c9c5dfa8f5c998d29e2d1791f66e66b78ba1b52c6324218cf5acfda62f80767b93a9421fc2f141218a39047edf1b5c4256356d88c5fe53e77dcc2f5f91dc13c07809b6ebd90615b69779b6404dc9876105c9ac31386ca5e0d455fd9227e1b5b9f4cf56ab4f62beb967a742d0bc52e5782555e7abfa5183d10aece6e3338b1a7981b51edaaff62d14ba7dd4fea206987cce3fcc87e68b1707d0f5906f13a01c94ce1d00c0174057d8508c868e943c4849f832d798f798a448757ec8800f3c785dec28c30b695d9751b530e8d2b2637c6bd2c04490eda62f94fd90c83b8ae4e8a033c5a28394199e85cf5a78ec8badbf80de8082e90c8af9e49daaee5e478af843c0672d694441dbf7ba165ed7259e740eb81c69ab6d612061baa1815a83c98f253f6736efaa4c5c41f9ff3c4830a66abe504c5a03413113453e477f8c28e4b183797e6f9f356adfa7535bb725da49e37e2e586d822f4c4a9596597610eee3df4570f0b2ccdb66592d92cf9365113599cfcc654ab310fb14e900cdc95c69ff25004a2f404886671571abcf100d1dfd25a1c3542ccf2b6c39cc8811234c179f7d00628a36201f9134c76458925d1b5c8be365b852a6dc6eb38ca50f7d6ffae93edbb4c89cdd6bf6fea92bb48410631e9ac0e982d5c8af16df1b7469b4c281b96ed6f25a64ee18ddb57d3045c79410cb26f22e9c48a0027d784c5daa53a6d6625016d4c2c431a5c345794037058487d393a8a1e126628da6917e976293a308d545184e294c882cad174ae4eaa106721a9fdfaac4e8c7353ca2d6c63fdfb37049a12f498385296d42b694e8a526cd0d8cea816d3acb41cb9c2f41272fe0553856520b97aa5daf42bfbd7c918192160af7479d872c0645589db586b4d530fae63d03db7ee2055b38614f669b3ca7a84764684c97665886a09672a564384d978373219d207e83a50636a0ae1dfe81f9133ff1e08071ba871b6c08259dbce0fe4012f25fc47fe24d46e2701bc2e2faa4894e834abee98b113fdc081548d917a1b1d29fe786dd03a87f65d6fb4aa6536960935680bf0e9531ff3d1e259cd3a8166ef36181430b410ca14650ece92f29df26fdc655bbacab2b7a993bfe4fb3867f41da00287c022b593480f9246ee63958764a602b28fbbc40e1d586cd5c29ec5a19e275dd57469d936e4d2df94182f1ab9c08c8e5e834e6a254f08399e87cddb417e0f7f24dbcd39a547afe4371e42ba4b95b47ede105b49af42278804d54ccf96bf78dc94f5a8fba81221607d06e9f613664862465a2886bae6ed586d7aa17ab87e0890c3c53e81055985ad8ced7eedf255039ba275bdaadfad3ee7e3a067cede4fe8895b1d9f392cf1f0ee82262aaab36592a9254f678b741a51cb609f04599694719ebd9bed89306a7b3903107cbd98c8d114fea75925b67049104114b161d5c6d6c2e3ae86f690708387db0f2953668b970801bb441235678f7c4de13de7a298c44103c62b3a41f5d9a01f0539bb6b74805e1e7ea170b8a71bd418166d93640bf4fac490c404ea3b3faf0b42c880aaebbe378279fd5c88635da79a04ca4e2494a678b3cb65503a5947a17f98f6b866b0cf9f8661369f4ab56ec8ce68a95fedca70e5dfa343fce1cb24d3d8bde85c4ba65dc20a4a2d8a5fe9528fb42875db4446512cabb698bb6fdb7af88c8127febd13bde9bf93c5944097e67499bba387832f63b0b0e9815ac195f0fcab862b043f3fc181b5fab0e3f519d618d79823e3e3f86dfca0286967905a617c7b769e08e54b8c4c88d42b96c6f8dc4548fd95fda16a0185e1810440a40c2fff9c6604fc17ac08eb2aa6b3dbd2e1b12677e52232986339322d81d58b2fe5834a1833f7ee598ba99065d05f2be71ac83af880aa1c5b6138bafd4051a8347dacf867ea5dca6f0fee29b5bfce8f3a623a08c6714c2ee418604023f1cac6cd642a0a748fedf70f4a0d58af473f89a3339ccaff57858fcdd37ad61bf89a3c9cc49436c4bde0195cef95f62c4016fbf17bd0c3563ea3d9969e3ca3d3e8ea154ba0d9091e40a6d184c86641d6b71bc51e6a70fc333a5306d4357c12891cfb73659cb81f3bbf34517b810551baedd67dd3c92c5553ab87acba696b4dc63f53fd62e4d46b2e849699199bb92ec04c88cb62b339d563b62d7e82c758abc7d65b6d0d0a659ff13aaabbd4e943288e5788209b08006ce27750179284220471013d45317fb78b6285055152d02901e108c21bf6ba8329c759c6147c7151077600c4af86403e22d4e661bc6fdf6ba0131ad9dae04fbe7159c13fedf183dbcb7f2eeb18f17837e8d466eee33b799e17d08be8674866fb9b2df75fe1d0bb2415b9f08a1b72418e6cef9447b0d254e5e892303dc610e5631ef441a0c42c939127f1800b9cdd699f14b20b8ee2bed1ecc26ff3a518978504c3568789ebbe476e2cb08e24e2263815925adb44da6dfec716f1f0bc0d52718c98a7d30c002616465d9383e2c28d685b29abc663ccbf8ef91fb583d5bf992f1a1254b684a79e65f191f68228b569dfb1837d11bfd00107ac3c3531917980f2336dc20d315804324288783a162e02eeb05f9eea1a8afbea501ccc9e05475ca3309eecdfc7655344aea4e6190cc92ce3d23c0b78dbae0edf321f1c2a14bf430580550e76e5fb2de502c332f1d64e2a3911e330efd81a269a16bd93e55f1a2cd4176ad3bf4e32c9630a4c8c4df5d04d3e90431edfc8f40d572d36b424381dc5faa920269d432d519c7c3f2b9403ae7ce1a575570d678a50ac64101a29f3ce00b7c1c6309cbf12fd6d791aabfa16df5bdf1a3694f4f3af2469373d3b1cc25ecd3cf31684307091279cc2ad3f00d4db1fd30bb9963b172b5434a4204d31d9316804da1e8405f5a36f3fa3fa4a4823a3c24f282370ff48974d4088a564e56e7ed53a0ddd47e2bcbc82ca8adc8f0f51df673f600ee5aa48848c85bdd1896aabd60f62119bab8d93e66cdb9b4a31127490f93d337b6747afd846e451557ee5f9aa9a44f8394dd0ab50707ab76923ae1678376b7ef52a95ef2f56f60439361262773ff75c935b445579575ee51e3b8060d5ed92a10b84a04a22ae24597606a316a43f485e9a2ed7fa122fc4e8cbe1bae6f362b577a5e3d52254d2eb0ed702bcf5a1c4d8e79f09b49ac217eae5af5367b9e9accbe2c07dc4b58984dc507fe3f375fc87b0efd74825da2dfa2e61adcdd8b5be4547278820ddcae841da874f95f44560ea152b07178728756206ade739290e17a2accbb6bbcad0f069d3e588223afa71e84f23f4fb5b33987e3372a81ea8e863ad126dc903b32cb82b068d2ac2a9a0f13c6fc6aa22664b67ccd69c98253ce06c319d53d9aaf57fb49f70ac92b60eca0bdf3d6f6124ac2b2c3f13bbba3aca155e76e499ac387d2b5fdb1f112554fe3c2e5a0d8e9915b88b63a19eb53db5ce8be25319031aadd893eaafb626985638dd124cb77938f292bfdde44bb396bd113eb4a04621791ab961e61958fee68b8eac24a3abda42eb3a213b8a786f0fded36ae7792b543f4489e793d96a83f07676c8f354ee42e1ada304315f011714ddbfab873083d27d820fb5e33eb796f05a0d625b0dc4e94be09e52be3aa8e85801d2aa7b150c680c7b827cdd4e33758a81741f578c65cbf67629782d9d29361b6609c888beb85c5c5aca9d29c8492dc64023959dba4db72471c2688833d7d59ee9e7e67a50ca86c05c883b9f75327dca7e81e508303738423d96d2340d45b5b4c55a03183597db0d21392b63fcf5238015c3178f9827a3c8f03a3c8cb60719312f3172cd3892974e8d6ceabeb2675f7a277c89ea6ab31e720e5e49d63f38d9302b157c7a90b7765e5336ec896e72b0c73f5a08155afda339ac476a664a0938a76e7dcacaaa29918e26e85573cdf7c8bc13a5095374d37aea97321c2e08812c3bc3c032c7b513a8733536d08f52c4476549bc1e080b271e7b9e16813206f6ef73c5b5f5df101b89de422d8b8619b4d054e7e425a9c5dd9262cec5d691987c4574f81d167f455006261947d604b2be59891063e78429a7d2a0d610288e719534195b7da7f3b5378e567be7d03286b65c7f482dc6a50d3bec6a614c894230f720f015daf4e76e8b10b43db3fb8feeb4fd974f2e224651f1e5fc0aa49d789d50c6bf6854fa03b230f73435d2a11c0dd19a12c328e671edf0818008be089438b71eb60dcceb211782ff0be4018bb4ed473c279da2a06ee25827d3860e192e0f24b837773a420f725eb76f3bb6c014e5b8a484c8917e9206ee10070219fb31143ad29cfeba11772400786837a09594438784f0701226022bc0d066e87df0a26068a98dc74f5362028bb798c03a4544174ed2cfda958c90cc691ef93f682f4996aa6fc285c39a021634670880ebf075af157bd8b4a7e0e9f15e8dcfc87760f1b053bebd4a17ea8fbf2f19121300741e0244e6d69a24056751e2fd85e71d1e3f9df0a1b8f654b91f6f1220d27dbf35377f7a1854f49b46b92ba56c54b00ff5cbb35983bdde1af0ba5b584ec828d06f0291238a615c85d3191783fe886b1d49c5f5fd0953e9e052a18dcc6787e74cf8962d5503b4d4a884dda66c1c67256063a667fa90521318c45d6378d149c9e0891bac8c012e61ca62c9e801fb402c1d4f82e54767e5d8a78f58d0ea01f4e3c5680adde308906fcca9974a9c114512a6a911a640e4a338b911296959ec2172910782ed53ecf5dbb11d9bd42a27bde820ce161a65ff1d1c0d9058043bfa8812044dbf00a4deb33cfa29065b5ff8cb6c40cd5a3cbcccec8d8cb17db05fb47c97e532807fb451240b0fc36a32acfe1357b2517e973b29d69166402f2cd0f039a122978dc0e7ca9f361b1908cae224f308d7bdfb4b975f21122f6d72e6fda5e6841e839051ba97e375452ae44b039178d727de8a8588cde1d45cc37ebc670603e7405ec29ecfedced1ea3d0d122ff5a8156ddce0e49f6bb235fcae16c15599ed9ec72a98cf764b1697bb6ea6142eaa61f8658566daec2559dcd81586b22c71b4c8abea12ea4b67d6cd781c75c848af5dc0f59d71fb3ddab09c4eb33c18501bbc7d5f3bf4fa9a12049a9c8ce96a7017b8c9000805a62048db98160d3c27b7b8780e1ab52b1c5c0d955e8329fd35d4beb56a63249d0fc7c3df7d4cda94daab92b41dfa80f73e31a908ea7205b100da5484315fecfe3c596b12eba5c765d0d431f511b04efa90aef6c95e8c38042d94c9a55e4ab95ab21c19c2b7b1f9da6fe0514e62cb7f7ac18c6d3625e9612223981f2fe4cf877d60fcfb241addc4f270385b4ee68855859140e21288c6823654e4993cc1f752379d8db279726ec40896d055b875a777adf462fd39e60eb267984cb0a61e2d9c414791decb1ec6ac0115ada22a80fc2ac6c74b7169ee5a6f39bfcb84ec4ce9be192e382b912006351bfde9e2ee20ce1214ea2deddd6af6bce8b5b4f6434bb4d81e1def2a45de0c05d2aee3692cea9392bb4d8c64c3f98d96b9e390799b426f08ad9b243dc0d11b6e1faf5ae86b88e57e0d35cd86842d2998108421aafbf14d4fb81d1107c22338b88d81a5a6e27216fe49b6364320150e54953921a16e21ba1d3992b3a1ec926fceef4a07b81d5ca992a5791d5311c8a4a53f798da0eca8d4519d7cabe8423b84ba2e68d93a83e810c7df07559be41799b85a42c18458d176f1d331ff7738c4f89388ca20b381ad16d4b48226b730f49f7b2593021a35ccd1fbebbfae646d53d644a6805cb807374cc65ee87d87c3524d740ac89794a40aae75ab4e214c8937baf75681695892b357bc360bb62f11cbd1f56d8921937287fbcb3ffc440610da23db40f1024dd7db702a8204d5525318835e75d584953dc69e2937764b4e1e2aa3542306e1e1c1249dee821cadd595e4b73c30afdf124f40fa6f5ed1a3e58d17185c2e7f9b3b47392dcf57ba93230804d8035430d55bf6361c3621da74237cd91528b9a849d6625a102fd36ec0d770ec664be9d7f7d55fe8a68992abe08eba0aece51fd2f4a4ddbf56c2581e6327ca7f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
