<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e2483fed72d5dfffc3fe41aea1f94791ee371d32ae3950cacc37d8b56d7c545d16f881209273bd7f22c110be5cd0277ce557f06e9345935e27b09670cc5ce3c8b1620bf29cdd4443aba27661b1e664ff3c79888866fac05e144bc1c66286cfd0d69b908bcbcb5072e827d54a75cc7ad97ffca2bf39d286ae05cc6c469aeaa44d1b5634af71c1709ab1739274d5a3034cade1088b4cb1cb648e484d9f1c7df623329d8297144880aec503f3ff1eea58a99801fec2416af83ceeec87ffaf5567ec67316639f18f4dede452923bbfd03212122689fecbc74449562c73b7398992cefc6a448763d42301abe5a6fd5ebb7385edf66b2ab800001d3beb632dd9d67d370c075c045ca018d686bcb488721117164e2b4f7587000cfba66561fc4ec5515feec6b7a6ac7c0b50a13ca364a4e1375db241174ab2b561324b21428285d50fbc1cf55a721635f9a8adaf4ed7b4d4f1f4aa24c59c8ec2b276891057205ecc800d6c011b91a573a863351ac10897f61514c68a481a77a0e82348ab8bcb5262ebc0888f165442194ce02a66cf51fd138393d2be86b13db690368ebf546ee08c00a858cce3b13a647d6ec7e9d223b598970fce9208e09bb90f3461e17dde4f9720188c26dce2f40338d561a636115dd9fcc1000df147eafb485e37b94496cff2502f14a62cbb9e4bbea02e39d1ec9c701669d1b01529d715bf1c9f30661259919abf10f3df69acb4dd3930d88e1e131936b87913bccb924b24ff472349dd1170206ed746d8307e0eda6be24cb5f6ca65a921bad7ff40c4e792422788e24969b586ed878a9f3909371aa8c97639f889cc038564ee013b10d559ea313a8af2371326f0eb242382a7fe768f25d037e0e88291c9f91aa6081ebb0bbe63f2278ea6cdf3d996ddd668d96e4b67b3eb8074671a28d90dcb7563919fa007ab211a508f172f97d4ea32645078789acf3d93e863cb3c66167d4fad4d24895a60d48b26d1f813bc790e9c5c5a57e6d35b6d6b1b4b4ac86f155d4d143025ee69fd8ed27596a2725e20b25f1a4b9482e6d1700a4b87f0483666f86e69e63c3841c147f2949b8a6529e27c49c612eb2342a9fb6e96ab12ae3ac96bb36121b221561310ebbd3201e51544c2c951c714966dcde6118b8414e45c1866c66bd1faaddcf434ee82830f3ce729bc4920aba3db85622899a7f547a04b56f7536bdb900fbbce682e196af9d021f1a332f19acd1dbefaaa6b74829c65cef5a4a5efeb56bf3bb075dfdb01c9b19096f99b00a75e9f3a7cf3f322cc73f09fa0e526a58f81800f4bef1391905ce99b5cb7ec56735f7a849215248d5af9c79dfe0d8bed144b12c88969100a0450e02431040021834e8e6efdc6e55ce5948921931bfc8accb5afe5be4ebd91ff11a484aa46eb45ab816c443d974bb1e45ef371aac10b009eb0a9746e12f7a3f02a740254ebaa8229fc35575a08ec042a7bf9498c337de0f955303ee033e162022c1420cbc547749e9280c2ae78ae16e85af6e0c61a3ab24c87288b8d60145a89e84cb788bf96d8311a36a337249ae8938dba92b9fb0de1c75a70eb2a71cce3c030522a0e133c49b64fc28d8729b2fa6c8120fee9d4bd30756891804dc88246cc132de1f73f44c0ee103403bae300233d6883c1e76da681db0c8a5dbe1c488241be99f28457ec523125d917e58feaba942ef52c25177f53be0d995cc40d842fee47691495e5cb204af65d0ce816bce83ddfe0ee28c25857195ab4d16b084a3aad6f4ce1af438bdbed2dd43a55be05147e0150fefcada1c98b4c08504bd837c15be1a835b339bc467bae55d7f3aa56ad6d8c9e794542689ffffd90b7482a65447e0a3f5544e8ee1035a99396620fc9025d89b3cc75272320ab224246b7fb5f1b1130e472383de50e14f9929e094ea5235d873758907e72538f59131c754cc8ea63ecd5eaffae369c3310e18ad686ec2aba3446db0ef0282d349d664a3351dbaf15c0ee786831325a70f9d5de465361db49bdd7400980ff57ac220142d55e99be14792fd48b1f3ab3a085af6b6a8dbe9c6627ff11fa8bc797e11d3bce77c6f4da5359dea0d1f7fc6c7a1d0b33bcd5d5a6bfc73eba904334b79c683d6da39ea142efdd04281745e98e3f5b3e1bee7c743b48a00699e2a89d7ead7b23d5a48b0ac34ea00e974208ba4fc8949c7e06fdade50bb7e2a12769909d88a31977aaa393bae7a7c22d8d680fe602336c980bffc67991fd7ca03eefa56fa168a91002e5912a24e382ad7644c26985bd1098ed1b1b7a63c08fa26600bc1b4e073c421839fad6a6b0b406fad1af28124b6650d54c9b8bf1969633d82d1f8acbb7bc97d1d60db6027b3d614680db807e9a465eb8d115d0bedb9d652ffaaf0b27ca4239c49a76717a8653a3d86d878ea9e28c22c16794457ea973ac7e347362173fb684c16e372079d4e18e9105ed96b62e6d2d9a7b6729c61c43337d5b81db68ff23a8e66c26dc826bcfded6c10e26f21422913fa67331017e2b1180a9d2c8f9f8defad7a82cc82f9e4662644ed635d571fd9a18190a916fb49026dbdac2e67382d1c4977e3ea35e2d9e536815c992baf123c32d7123b06b522f1903c7061f68d2f4d331c1cfbaee8c8ff2f6613a774b2bb994c0ed3a9bfc7096f9ee3a406b32ba6d03b0edc12249079b4496b470b30ee08dbea5b795b86b2132c04f483b0b1cf84d653a491c3a5415306b371984ac5eed9fc318e02b7e51825b39928681fa1ca582556dfc68b449b77b371d1b3f564ebfd49610600476a2425f1a75bf5480355fbd5096619527cb767b7e1177df286560b93230608b09da8da63293715444bd4d3d1359212c01297dafaff74c5515c12a8fe0f38f4fcac0109dee6f130e305a9a85a8bf6bbc98e1faae1f3e8c5051f5ce438a96f66eae98e7c27c15ef21635aaa2637d6674bc7018dfb5c976596b181092bb82c8fad1303644fa5d5bdd0a901cc21a7cb1845567c7b0c82bb4cc35ee51c0089991833ad400335dab168388f587eef93230a39f942c462de2706b9133e29f436996fcf5e87e340017b1c2f182cca6c9c43597bb5c550dd568181741d5c3a2cc41bbf72ef242395357e36fbf9ada44455ac8c0601234e27ee92cfff9a3dabee2f9f3be099fa1f41f058cd503ea17704fe4bd18db1fb44eece344e79ce6be22578155c6223040cbbde04bc0be53aa93e67dcff81bea88dcd1f6e7f48672e9310d8a907b7f74d69a32044c39e7fe7db23097e9052dd97145bf887ad8af2cf663fc2a69183171c3b0b4ba8ff3c648ca8103815a08babe6f4af07af87ae5f143b6e2e96e8327f6f02327fea1b7219bb77eef2b70bebe10a082fbf4ecba5c78f4f0fa6ed9f6f4c2b8a8c7f8173f1e6ecfe1ab5ed07a8ae1e8739cd82724fd3ac0246600cb195eafbc27c634f673a0abe1090e416775e9516d915794c3538ff82744f3b10a79f6a0d592f07f04ed0f17bd6b2049e98bdac518486d02c61daef5f0b874278b7f5b3464850febceaad48a26403f80296ec8ab91ecda795d01dee03216838714bd08f448d2712b6cc16be6f0b23c2f9e24cb78c7bbf067aad6178e4f78336442601ecbf53928dba409eefc8dc2e90699e151413ee554a5644c08e6818b6db34a4c41deb896656d7abc6f194b3518d3acfb278ba623850bd82fc8ead2f287f8ae6bfb0f27e9bd6a55928dd069bbfb6e9d3b94c18b142862482d01a0f1fae2e20ad451437b49ee12fe375c744bbd7af2e61e5786324370b8b59a9a7a0267e2c6fe1fd9844beec12ae3ded82737a24f54f3d4dc4ef06bbcb874c6ecce90cc65e5bee2afee1049154575f1f4eb7e791cf9a703606c37dcddfbf21d051c7a062aa45c8f24f9f6605605e3450de98810fdcf4671bec631c1067beaf350f26aa440221eb6e913e61de266850162af1c09f65c4fc5114ca1c0161a642977e820c8ae3b251b614ce40adddfda0d8e830e4b73d930c4ecbab8bae19f04abae6d7140d7997af9cc5af67e18044efa200823a96dd9fcc967c20710ece4d63c7e6e4e248a55789156c360912a4eedfabfd5e82260e701a47519293a57b3e5d4736e4d51294d4dac529e8932558347a4325a70ae5ef683937b0b5367f0fdae6875886dfa7df1d9bc6b152d519b2f011a5c4abb20cad6e29799e92b1f15dbc22012d128234f669556e3632c60247bf94a959b58b8beaedf0964f13bbfc84dfc5d3576bb7c83026932155ddc0b6ae7a78d248d95a23d2a7e9a34c8d230bb96e754c18a45dccb7bd778c9abf3995ad2cd64bbd643361414ce547035a054215189730539c33c1bc6395a682007843fb5cf9eff92ac80e8f93b7debbdeb519cdf060ded150d7eff2c5b0f668b91102a68baf829b27694a41caf8d284051882c3eabe0b65a986de073add3efd98977d6a8d5127ae9b066ec6fddaac2b3703283fc0c65dcb5828aa7505bb32a9e4cdcba71d3147011ce88f012e03a562bef64a7cce15664418af540071dbd05158d16c04d38dc117af7fc843f55415edf203e3513adc7d7f5a989d9ac4f3237961fa3220e6bb19a9b33bdd7df13e3d7bcb291755d2c8122d7dbe3b042c470ade51a88ecaee5767e01b34dd8c492604706e71313b4f9460186c6bc4ec2e0122134a08b506fa59a8d3a3595ba59a2a34554edfce282aeb83c788b4f2ae942624513fee1fbee782c9b9a600cc7b9eecfa5a486732daec474e8ffffdfa2b05a66eb7b859f34d6ca3f403ebaaf82e736ce0eab56ef52a3564d21c0da12404914b7838a008ad3740c8aa48ea2f32d52174f98db87452a11af0410fad30937b6cbe75e380d9c300f908bdfcac9524907c58227e6dca276ce4dc469c4535abda5bd9b71a2a210f89855d8e7bea6c149e86e079a7f824ea6468deb07a95eb5fffd9b1387cf885e4ffd48965b1e78b47623af705b29a9de5cb04b7ce928dbb1950a46d8fd5139620d9149187956cd2d703e6d5f26c3da944fd43cd4b8bfdf51759190bca175c77d8bf56661c5dfb77cc8386f7d6f56c7e550b8f2627cbed741cafbdd30ddf643e024b3245cd2016281517babbb4e28395c5a261a2c5d208dad85641b0910a6086b9d44dd913458cccfbf23f4f450847f08d072242370c085a6ef62971eda174331189074f678f216db41323cbce1b13a28f195fcfdd3a3a640eef18305da95f8ea448f7164bfb8fd1d20e86c5cc18c8cbd5523aad2daed0f90b2eddba7eeccb714fb784348681136f78f128a19bc2bd048a6c7cb8b96530d836aa3efaae874e212c9db418782bf4391b257cd9d1a518eafc9102b5799811e4d2936e981b9e1682cc31cb32fe801f970833a3c524bfd7949f55d50b10dcbaab14046038f6f1afdb20380e74dcf23dc485b7cfef2671329ab30c9fdfb967e3fec56c8aec34b95fd1d58dfb548f4cd703bda7a90f21159fb606a3c729e9feb68aca381fb229f2f7067431c639b6b65150ad79151c50056e56488eac9a882c898aadd0788530375a322cb15587341ad3433dfc159c5a3b7ea5c019b7a10823599a3dc6039538696e7d1aca8fb9dfce4c6eaad17bf9da576b65ef10f8d080a7f5e4ab3e4fa2cc4e2c0269002aec2ad20e2bf8994fac5f8604ed1bc389d6799e754d6f9c3823c58da9eb6dec1e569b4e133f24227853d1805c2e7402f4145f634e031d45c6e5b1640564e17bb250ed6e183b5c577d3b699dad817d08d6408bf5d20bb533979fd24d57e73409f3906dec075a6614ca385591ffce79735b761436ea766082b906e8bb87eaa57d3a32b05199c995eca918e65b0b6082cdbd416baf5d6c504d14684703c0d585f4b352f5ddcb5ebecb98c47de25b3d255be948d15fc5632157c59c34a9bac46ee24708f85de1189efccdd914c521dd6e261da5ffd4ce414f3361a605c031495d1e9f3d1b90e3e421d366d034a928fd751ea8dd203aef279fa1853ffa755d801e5f8474341e35136c2217b1a9055f3d40d7db8fdb94e9ecfdaaae7646652fe5b39e544fda3dbdc04e39eac491e9c10207d10386ec2bbaa9e6f71684756e507181c8dc86d0588c7aa176eee44a94f062e2e19c42afdb9e0b9896dd8ee27373233fdad7c7903b01fd63ec8dd4c89cef5614b06de28bde570cd69d7d160bf1fdc46792233e45731038cc6200a611546777f9bf6234a5a456d7856fe7e0b6d9b3295b38b2f203276ee2ac8b769a77518f10b7fc0e69d577501e9ee66ff40c4147acaf167eb354db89b95d556325348b970f44d416da02e47f99f5c9ba2616259a2981118ef6844f74ff27d1c5f8553222a8874af782eac125044a9524657834b0d7f88df8dbb90c2d7fcb730ec168bae8b5668733b68d8c8b7f48a901308c1bba329a117e450816b1fa0394c6b8f281b889269f4fd9dbacea676aa34364d2e9ce8cb21fcd0942c3305e7288a965b401b8530a20b6044cca3786225c1f356d57d5708ff0a8c1efb5271a8a3b72febf8cea5e4cf8cf7fb4738e105f09d74ae465b0598156296fa11d910b3986036ffaa1b2bba59538536e3ec7eb1a2c143424e4e61dcd23dd1f5aeb128273543900d3e21eb6bb043580dd7be7630faa18b8480bf16b0cea560a6e6027099e133aeb5a50c3dc1bafcf3a2521b247fcfaf222691900b7b7b716a843c757656a32c1dbfffd5e07d6bbba4ec4ab9af4ba39f8a79617a624a90d13fad9ac03e77555735453c97bc37f80cad4a42632d5521773e7252a436400be0d38c72db2a1168c18b40dbff9c9e8e35f658fa63edd66eda594d11862ea7641c42f620ecc5760d9d674043af8cfd312cc62e931b98031f36c011c1ca9bd4327f222c049d35b795c8c30c4db71ee65dcc39a3a976ac63413aae4e897cfd9b4121bddb96f23f386e44217e7db6f8662a6ccfd53ab0ca23875ded7b7cca09481adb33b0afc03441f109e099706898d6d5d40132a3c27dacbc1e3f78113f96e40d5dd6c3e4f9a91429ffd419e497ae02a1b9189e4ff7f13b50d4966de729aa3dde1d78c99712d73599d15fa6fb7b27d8354af97f065cef121947f2e239a3dbc779e0ad461b0cbcaa66ffed2abb37ea898af447c485816bd283ede2a834f1fc1ebcd237cc1d8629dffac19a47e34503fdfbac4eaa65ca425b7caf378876685d49edf1a1b2056e5c27b4cbf429afa78978f4a1ad8dc7762560691c7e443ffd7ff409cbbd06b4c7ae0bcd58b77bb39c0fef83032ace22ffcd8a9a03832a7459e6f0cd883b66b2441e0ec0604c5fb1a0b18f323489ff8b051fdb76de32ba3674b95d4fc417f90c4622494168933f41c83aaf1fac15d26c279b553c4515d5b39deca326bd28b695ef9f5c4ebcafa11c20d119e7591c89db08ca784230bb394abd179fba8c6fed17af248d70451097baf31937aea506a0d459a21089a48a061f615d6b8fac2f58746cc07d79eb0c3783afd327857b2533030343a87cb4fe6e088c076d8e67143456e41c1cd4458b025a28d285e900f5e4cc06bceab111c87daa92d284aa07b77182fbdb31c54f042e0d55539cc94732413e64718fa81ddcc3be46c9a207f53082b0d9ab7ae1e2324f6dd2b756b7c6a352eb9593bcb856d2f092bfabd63aeb638d2bb034e7ce4080bce740380c72b89ea8944f833d3adc9fbf699f323400b0cf381a198a1360996155766f026ff2a69eea5bf78fdd3e09b6ab70c16fc8f114ba036f982f9025166002c23a97769c762671d55e50bb32ec7a8ccfe35ddc8f817165db7615888d1d7880f12d13ee37d1ae4b1179955562dff095c9d7536fa3ee1938acd8fd6276811c456b03ac422cabd018c830a3970f04f50082f65a40382fe9e0d483a59216d336ee763ecfa7ad142ad08080c25e5f6c64cf916e829c97c8ac717e0d550f3eb4aa3eb60eb016347e0c187b5078598082d0ed51272751bd726cf9bdb43a98d267859591b1c25ac827b4876b8d61326cdcf8213ad7732efe466d792ada582d467f7bd2fe5999a8f28aa1aaf373e7bb65db40e7b1ae6db9b040fc69ce997fab7ef4eed745210fc334139b3332627471d2422151844e24e0258bcd328325e68dd8a668dbf96c7b5848f080ea3dcddde242946ff87a7bb5fc3fbe38c69b8cb13f343a225eb54854f659f1cfb734d76f594ccb0a4186a7a2d65c8e71fa977b80ee7ae051cba7762d185182f312a5178cd2c721884b7c7378622f0c3518890c02004dffdfc4d11165d0d84b0c75f0352654f2f69536555d6364f874cbc458f27cf4be48e6f11f63e3f76bd7ba89415c3cc364b3608593c3db3f0a859ca043446600d46e004fe06205b1fe552bdb9444cabc1be5b652352ba1f1c697777c78ed79b8978d91436850668c59a8a54fcadc199d18267a960e7625c6fe82b4162bcd0c758a57d0d049fa9db470fc4d1a298ad5a0f9e53ec42d66c8576ba7e284fa3f669222f36c262e4a4495989f534758c73f23e4d3b19afb486ed1c07160e99ff7ee872363eb511b1d04da726e21715e97e9d3172ef1d0f95b536c03f267afb37397e305999a270b33eda9aefbda21c3a047414b620cc01d5c22ba1db7f157972f7d1ca1cbfc5775035a08bf4faaeb838b2fdd6399fc55b7ccaa1eef9f7e8b33eab5b47e93fca9a344faabdf64f27c8707c892af271fd34721c36e52a5e1173f15abc2f30bdeee2b6fc7f48180f71881198f16a37df3de740db912e5cd2afdab8ed9255a466bd143f2e38f3c1651e242b94a438dd514e64c25cb6f492da5d607aaed060166d6d181844eeb3e33c8b1a26f13bd7db6ac4b74d5ca4a04f7832b38b18b7c6f490eeb415ea0fa5a7ceb77004ab3beaa9b7a5de76f5122ff8fca73e0aaabe2bcf311d88e16c342300b2deed444a6363037da247fa43ff36248aead05ea4aca7e8dd023badb8b2ce07e976b3a766511f78fb96559cdb31b89df736c9d72b70e1fe3888441108151745425a22cbf56fe6defa86fe932ee0856a6590d9263e450c40ee618c90f1074fadfaa0bd21ada9c157c798f9c6df35414d1f6b88850cf3ed32f056807e9af16ee37d6c906f41fb7c257e777bb2cb3c5e8f499b8afc683704b50ce79673e145380daf07cbb7c278d07f54be055d5659e1d5b907ced65fa52569f4932d9a91144f3f788d5924b38514067b2e75cb39c822fb10a20cf0941cdea3acb2c1c3f5c7ba369a24d1f6e484befdb037e2996212d19ca2eafae4a40745e460a6528847dd15faecf23cdb2142bb52d933dcbef15ecbabc2f617ff306074ef50abf4c19ec55d1392f75234275523744e782ef43ad6bf13113cd565da6f942f3ea974a00a9fffae6b8d03812af38563a7fe78f003b1dd2137c9422cb8e964293e614e9eb94204a8e7850f1fa58c3029a313cf8a03c2945f025afad785a394f7ac5167e38306310b79818f13c74ddda19871c87030bf765097b013442852b6a904c89b900dc7d3b4cdc34e464538e01f16c5369fd3ed4f41616e117c4b5739eeda5ed68e5a9fb2230b848476e6b0861a0094b4236c949908133f53681030c71e6ab1129425d31df9660c48bf7f40331e9cfe68157d153dd6412b70f506bc700e85ca24bca487429e6e6c73f564158dc3969f45f32318127166928099d8511f205790e3e1c32d6fe3b55bc5319adc2dff50515cac83d035d41b632a43886b5c69d3a18f0709807ff201d54b8153de9593cb7d1fd0012c567736a8254083f27aa1ad51354ed08e558170aac1bfce130b6ec24d8e69630fb53ee08f79af9e0df8b02252fbc9212bb5135c74eef6c624329d5514ae91f52a2ea3be56fe812f73a9eb642ce4176346ccebeffe53df05048ff47db85b9ffe1d7186e1b00f1d7476bbc820f37803250ef050fb638dd4b4c98e587b4b1bdaba01f8e0111f5a55a6c3e9cdd6e543d36bcc991e40f04e56bdd04e0af6b840cd1e357c4f2b01c11b7b4ecc98f8ac7cfa339a1756f6331df32c027ac524256a2b8e9094dbaba47fe31c74813a67ffacc916ad530f40e3c7aee07845ee0aac32414c2896ba8771b72ac897011f7d8759fd33ef69133f87093e3bf6452f9f676dfd6d00f545ebef637d1f89f4987804105534bf6c87c6fdf96b0d9ef2cc2ec7febfd1508d9a2c427601c0cad45c24ab9e6cccc3310ac3050d74a8527f51c10b6255bd74d67f8f19237a3c35420f5b059cab64a9c54aa56c7ad46ed65b9f6838db1112d4383c50902491d8d0a7b8fe7cc7f4742205edf8584079ea0b61ce0541c7f266c64ad519357fa08642839ae0fe2e34a9a98053898c954431725fca5b4676163c47df2d95bab0cedcfa5d2529a6af38ec8b68c38f2308a05d1d5786f832e22d89499152883d026adf2bc7414155a9c7865a2f601d6f1711a2d94118a125ecd4d53938bedd1aed1303c8e4f03f8c9da55eae034ca17d7c927c839c522dfb3a5b458248f0065dd7c6a9d09aa70c23edc471edc3373ae1f28f254f0eb4d3d513c7f0d1eb2fca1cedecefd198ae6d470411f54792ddff1c26e397bb925f7539ba0ba041ee2355c776175afceeaaa60844311bafdbda0d3869ce2e2779df5b7834a89fc8c5947b1a3cc76e5624ef31a24b45ce666dd9b454671d6d6e133926a6a597b511d2580086630d43c4f2fd3ef7abf7209e1a5bff67c41aa6fc9dfac2d2a09a828540a94ad71028b4816dfd3fc8866a1557f8a75bf12b0ade6209a8a39c475dbe0968ae9ecee648d565303133c2be0c454d570d74c75df0328f0984ca8f91f110c111b36d333cac103d5fa57ebd0a0e92109f91c513165e20821c8ddeac93ec620304f44fcbe20b761943c9a44cd0b71eaaecd60071c3e24e84ee9ba3fc7bd16f7e07efaa52ae31364719eb8e4b44bf2c330c2bdf3af83064377b4a748b4ae6fc92776fa64f588723ab1badaa609d24ef19d53ef9bcf06179c35750124d9a471d4460c22239b1579f14bfd7b8ad4a53bab5ebd3d9e61f98cfd08afa4c0917f225e93a280eecac67910a7b6ced612d9825b5b3575cd428390c61dea1298f6219b59f6b23f82c586532ceedb64e79caa51a53b3f32f2a460c0cf5b04dc83b913f844cdbf7cde619048a07a16f2920e0858e3a69840dddb5ae458e5c93a6f2765150c5a8fb8b6da488e41df92303419d33a97218bd8402ce2211e046894f538f2a06c7dc05a245cf0e4fc78038a88c0c0bdee2ec1990ebbcab6d1029d52a024326da4ca201edae5a6df21521bcabf4579a5729e61866a8df3e887966dcc6b9afc4095bb9f94d0c9892373013113f2fa0b263b1f5f5f602f5af636a195836ef814a4cb605310b841acc11349485df1ff7cb0c8e1406ec908e46969002d846b6c752adf1180bd477737f267a40181446540e5b01355c2c5f580d3a62e6b47445d64f8adcf88878cf33c658185b43a6c0e014b54aad626f4a260b12c7c11de85debe9097d7e3f1803d14632d5795c16db25a8110a3475412042d9746102cf6603ca2f41218ac1c45b57566156eb1b246dc9f81428825c473c20bc5111115c0af75024e66a8006f7cc6f6a3956c8b07f604463ed4242d5b6b592ed3294c2a7e7499a4b71e9b7bfb1290e8a79ef75474f304e316547a2c29143d4ac4de9358c7b5f475c2e4f9074bb377a7d2534fb6616a34d5a446035e0b62bbb035a10c46c34bef3b7ab413322731f5905ca364092babdd3d37d82edea7664b29a646acac14519c7cede84ccf77ff823f3566ae2ce7fef248ca5b99c394d4ee8f5e68afe2d7c422a1e56f3eb5bd254b7988c39faa620639f7cc0d81e524926d81ff02dfd2c7a0925b3aeaf4e220dcc57b8da220437115d41f87c2902d877caddcd677f4c6e1ea04460eb73c0439431f7a8e88aafb8a2edb5c8619a5a5ef0632d635461eeb5a68bbed7ac9ff28240d1e7838789916e336f0cd64413928f7e6565552dcc737f054865cbe07525a9670bdca4ec362d8501ae04f240c5ba1b9fddf28b4a2673422326b5fa4551268a403838e964af6a55049157cf5e9780bc4d05882a9e30a3484c6d97db9733dbc4254a33a2bb1142bede6b40bfeca7a8d8cba8e2a79a7f38c88c0dd1ead25d0b2a78cb1bf3f170985b8983ecf0c921f02605bd93dc786527f36098353c2397c8c3e491e32d3df6ce8bd2d45c13bad82f9dc8ada934534174270694e46f7c22395a01c77e08b7ae6ace732d098d598be888152bc29d1c4cb44d490a4de724cf6c7b9b9c52eaa70723ff7b1c88ed4bb46053cb744d4e11d42d44eb64d174d1a928364f161e01773a6da0b361517968e739c78ff86cbb48f9b4e068028c9ad29c511ea7093d132f7100bd493d33d82f5e65078a572cafa06f9b999fda4f4d3575a056c4dcbcf1b8b4ba75966391723b1373b3457a049fc92832687c1529dcc84799ed1d3c2d8e624fdc97bf951cc47cc57ecc987e57620376caabc886be398446ad08d64d87f86f3e5f22345299885f17c706839908c92e5009818c29bf0ec74696be48e53f0b5d1a93f78b68253967edbd73b760d57da8dc22483b3e81a2a755e219ac3dff00d660eb18618b817796f06d221c1cf91002390b3525010931ddd5ba83956d2a417c12a96ea261ffedd1f9049c3417382337bdfe724541b9db071ca46a7738271d31e0a17d0c5d0ea6e39ffd3d58e89b16b1aecba5d29ae9d5e854800e1912b881121e8bee8be152dcc1e71ca0b61cb95fc03ad0fc1915f2e7e774e932ef80db1c50a1173b9bb6100c354be77cd22e79ba31e5364bd8d453de7bb63ff2e5bb9b115eb18661b6a979bdb6f09b4e999afdff6309a2606ab0e95cae2370cef8a610353cd9fec4cdb959ef032116632f16a43afb51fc82af8b3293d012ca04d8b77462266dc0013fbcbf65b6965c7669304399bcc7a104b9383722a232dbabb6983117b1f95b49516ee5f8c9096dcb804fddeacafb7d861a193a1f01885da9d22d1a57ea155cabe9e703d8befd3e95566e504686dd7a3957862b1befbf06dc7e48625dc7157e3622c116372a0082e53f38765c5b2fa4e9c8300f4372132817b43d011d46f45b5c4ce482fb18dfa9c0cddcd6e50851bb39fe5499e93c2e48a7a5f050e3598ff79a35e32add9e06999116020adad427863bb3d556ce9b1c3a9ff1dadd225cc57306d7e1058c4f0955f8ae124d668ea7a84ba77e03eb23fe7a0658a997fb3f52a1245e7e6bd8e8106cc866b71c77af13baf10042e1369eedaab78e3733fdabea8a862e0398331dd4eca8cbcbeff0d6eb1a52c47951ea5179dcce9de323150249919b121c5ceef8ad5af36b4604be30d7ed3738cfd8e1fbd4b471f5e8c436ae95deec358c6a5e47d658c9e15789ba26304eabd66f1ac71079ac93b7922eb961b6643edf1a309697717914e27b81191c67338bb124c03dd60a77cd360cc3e3320b911dd4e9e5aeb7d293bf6ce001b7566f88250f33b6362f5cde055704fb5871e8bf1ce551e79a4470a40510422b547dbec0dcfb53a3f468c269a4bd7f8400fd94ad1c77407de2c0817d1654c63ff9a866ef3f4969bd1eadafe50ad08c6f55d5d5e26e2a9a9a49be3352ffc7b06b76be685fafd640c0379a5e24660c53f4d422694dc4b357357c8645a828256a1035e19a637458efdba0de37e52accb744dc207744ff5195fdd8259df8ef8173cabd148da089eaea730a990498e1474f76b91842a3f93442277f30b157f16f69a864cec085af378712baff0f1d1c22e3fb9d7c5f751f85e0f413d387fea15c876a042598d2828b37584f5c2b437db49646639c5742389eb4d3c0c6e610b9945511c68536031283a62356a9d6fd745a3b00d8bcefc2a5e2331a45e701d82eeac489cf487b777c22487e43995ac07311cb9ac0a7ea8dc8d0539198740e02094d3bb84eff82f51647167c9714670b384409d0bc4b9e424e8dcfd4ff21d6ad7918b6c0e8c646304c0b260cdf6760aaa660a4fe1dcd7180d111b76f2dcdafd4d539a93893596a5cdada4fbe486fdafa9555ceb957e9695a4d1b68a8e26af34db39ae800b83df48340089325ac6836623485185378264194d048bfcd26af3780b7420f193d23763ea0cb47a42ca4ea5caae38db99b74a2cf6b52610ef30ec183a67f4a392dd269949bfb0eb44b70b71f830cef161bc732d54174e0c6fa7ef353f6a898deb8c05af8fd1be696c416b3a8e87ed5ad87dbbcb76f7fce60e35b5762dfbc37c8b7a6a206fbca411774c86dcfadf7ecf17c1e1fd7a77daa53d0eb4af36263962ec97e10ebe22fec1cc3aae12805e3f7a15dfd665aaf6746b7a9a5af8b8c834211010c6542e80ccaab0409043f563fcfad1c74326dc5e9c1bd2c7d99a5994a081df492e319345aa14b1686863276ade6186e9ba5d04cc27b92e6e1af8c35a8a3160b89f4cb9c99b89d2d964007d8a341be56f4721a3a2827b1c7eabcbed1300bed55535f120c2debc5953c3948f4b3e714f14ea3923a1eabd6891f3235b609034d79627013fe2712cda3e36a43769555655a9bd58e34f7324351e2de7fe00b056219704887a5fb4a5ea496465bf1514dcbb156eef6ce2cf3c832b7431e5a807f09f64f48836fe242cbae8670b0523ced79559b24564442cd6f09c9645dfbf5d55e250735bd48223f158e107771830f875088176f70a84b610f58506a6855c32a4e5233857dc96c8aa655d13b30ba12021fdb9278521fbaa631858f1a58325a1af73221e9587a0d8ef21b6f88b4cb36f2ef6e6b1f25e1fe036a3da34fb4ff1c5f5272f15db6362732c446469379ecc4afc81afd8183e9296fff8c2ff76846652395cf1f65bec41bb516928b389654179aedbe948e9a59c3164034f2957c74600d3110eea11a1849fb452bcfc99f39d942e4c8792ea4f522305d6cb5e4c99ce09f663fe0a0ded88e414b516920beadfaea933010f9691591f5148d4b9b07492495e95cdf924477cf0510f129a7cfe7ca20455c155a9c6b0c50ca1badc36ac6bfa52b2c1c68b320d8cd5e69c5181d300e09e9f74d19bde731af00e26a40c12346944baaae2dbdbb2bb12ddb38deaee0ecc371645c91b5de572ea7fc9cab6255f86c880b5002c7ef9777d4b6bd18d34209de7c3b6a982b04081c07fe4b8676095f391bc6728a411bed2ff665ee094e4dd57579f55c102c61fd52a0dff52b93a8af0284ffc8c87ba0d931321575de04643b5c2dd0f358a269c6c83237335c5e0b3921673e957f11aa8339f8b653454c4e46207f25f553d9032bc63b9e69800280d12426f91b0eaa0d6c4617609676614f02929d50de7d7aee6ddf596a77df5ca095eca62fe4690da582ffddc2beb522b686ceb8cf7ba70e04d511740ab8fcc51dbc6ce7b2e2e651dee22732215ae237001cc24b6bdd8e802274e2524cebf499d82c4a67e17d3a4b31a2c853e7b20b2c020d41076466262482ff9f07ba5c2a82e429401093b87fd1979f0255cad6faabbb7272b45731ace7bafe5c2c17a29682ba6a366fdddc2d9e15cf293f828bece0a98b80c2564712b94d70df472da4ab0ee9ca11ac6511d94d9ccd21ae7cd446ab1d1fa5f05ee9bbfc3c7edc93fba0ee5f7eb9f7c949c058b7604a79480ca74ba45db661ea494723ba555286e7fac2f14a0255f3ba7618a74e5a9bed1f8824df07cc47675abfcf79c8ff4e06663e11675b30c4a9d0c5ff94951441b9c2e70230230ef8fc069e1abf6cb4b65395baac996551cfe84ea805ec93a0a93e2a219c3100e634fee3fc18a9abbfbace955026ace0c727c5cc308042a4850719c850a0cbde63dcb7a20660256e440913262223f47dc8f32f0eebd15e386782d892ab3b869a3c90213b42a11d1715bde50970c4e525981705c2af6a4a137341afe3368fe8b46e7686d4d787dad03d056cc481a816ae6931a60e7f0c2110115ce6da008a9c50ebf42e13ffc21e7cea9a643d2f6485cb3e02d9823a0c528709ce3a05c4747012d04e4783fa8794e41e535b78a4e8c38afd9356675c31f4a7fc1b656f7f379f5b92508452a0087e257204aaa4c1f539bc6e854a390883b00dcef5c204c4d2e3cd528f7eaf8f370be5eebdecb9ef681e7effdb030385fc6910b333ff54dc24344d26e4137a7f07bc64b4e4a8d02631cdcbbd6145b757f53dd3a4c084fe76794b63b995bd27d1d39a67e50fcb93d661565325df6a662f630e0df9fd5bffc097cff3298720d6778bfdb144f2c4b6614c92b4d7f319bf66cb2f525181d4d05e58965c48f663fb3130f69652d349ecb085204142d26e22b706bff5b96918f17ca87d34f678899e2ff7e2ef1baf4a3eb8526bfd608ad22991c7823c2f33c33ec0eaeaa2070b56738ac9a3304de813bf30f442fabccedd2d90dd0845aaa2479079d452ce675f18ad6114a0099ab00048b8e7c6aaa7b117f3967b1e6b0e883b2edcd2f0fb63659e440679b955b339b821a77832e9d42e82d749a2a15c2f265166d07db81dcdb633405d74ff0f343521209a95dc6da094aca970ab32b59c0958daf6bdfab361b7d51394d3a9b8c1e0cce0ad4f82edfac03ab00bc8a27d3a0b89ba5a620c37397565b65b88eb641d6f7daec4468172608e1c0d80507daf82fad9d48ffde70d44cec4e0bbf948fb5bf32b8a88905490d6fa6d80bce4bb5b7a622214bd485b9e07a4bea07f3db543343bf92a61c9dd4fdfa49378d299875b5f2f46c7f9f8dd514c0a719941c9f303577c9d4be5dcd92798b9dd5e3ac1358c605fe87af4e43b45255c5d1502be93986f8a45b77791c44c56ba1f966786dbd4609315ecebfac78e6e4e9b693de89b978f5774ae75aefb92eb112cc427cd55a6b556020031a7a604c247c6679b1f20c578ef6b98fdfc994d6a6516639e6eed89addc7c0ffe8a930a6cc8dbf3bccfe6c553e856c549571dd6c54ece22008271a31bf27e94502e60bdda488dd157a85606badca46827bc9e239bedfbdff2fe6bf885c92e824dfe0de4aa77b695fe210f6b670d18478e7785a65328177354071566e33ed5936b48db5c8bf753749d5d1b79deea8765fd3e567c59e7652f454d404e1584595e93d0d4c0c4675c8062349bf21faa054148f69190497154aa3e229462ecfb4b055cbb0afe3773d03a84d67bc3847b33d368ea3c653e74740019135acd7b70e62356474d3e097a10a9f5525b3f18bb6e2c272c8d410340246c7335a4d8b75ebfc2e5ffb535bc60cf8bd213947c0b3a05fcde954c5b348b7594691848b97bfdb8173142ae1a13edbb4732da98f09911df6c749b26a394a7a73d1c3a3929e956376ffb4e5f9687055e3c440356c4d5a3e92c95705b4bb4e04dd1ba8248109fc694232b760ace83d7740ea4a276fd3c32ca2adbc2edebcf3ec14809fbfe75339616afc3ffeb14a1e4280853ade4e04394b0b157da6fd57e75387c54eda5246e7cc93579edf05da2ccefd561bf1754e105b928472f625a3b25b8308a0404ad8bd01eb5fa9df17dc4e3867beb9de290a1a4146bd2f3d59f40f670f126da3693e2d9a1f03d3f4bf0ab21d82215ff9409e8264b5ffe0a6522b391d73081e2baca2cfbae7adee9fc189a0a61f670cde70888df6bfaed48dab718f2d5ef50df2ee5e022760737a2d283b303520f34ecda149b08111c05d6e0b0a94d23bfcd19b459ca67706e834ae197165bbb3c7ca75026c8c8721484af6222758fe0364f9d7026d0855e9113d4bbdbeb38abad12f18c0ddd6950ec8e7a06c26cbda9a40df1e5b09293ac8e6f9a4f8803dee891d4d5a4dc698ed49aba3a7507d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
