<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f67cab94fc525db350f3cbc0b08a7925a7c220d26b30692ea32377a37211e11e6b04a77d6274b0f4b852d1dcdd2768af0209d262e37f806168ec79f62cf138946769df7a07ab4d1ed4adc891b06691c08f6280a69135f8233e2da0921797d6e45a75a02f0a2226a3b9788b48f465b8dea9b212dd1ba637601294e0112ae02aa244c139ddd65d7808744168ac8df0aa6bef9b22428e2a13481140f1bdfc9464476a00ce6467cdfc513d06e59c82abd9f520eccf157bf12ba9b291f6acbb9b919a660adc39f5b3bdbebe4bed9107b128ff5f84443d037b4203f5d461560f902772b843aff101018fbabbf54c3187e0e7c7411954281d542eb221c79295d748ce0c7936c572aafe74e364ca10e4e6373ac06ed578025177be72446b79d93dbb04b43a9909f4cd00c6c25ff631cac7d4081b160a34ff0dec4106326934b791874ae865a92bdbb54f494f385fc47bc6ac65b3e6ac02d57de60e48bbb56edc23b879968e36390b4fb4090191236902bba111a6df141a7c899e772acea38ae7e711add326b7738f360fdd618c4cca443a10fa254b6e221fda96729737caa5a693b3e9b804e36e862b9127831e75cf6660ecff9f0d60ea83e354ef46d7573825a17915abd9a6cfe1283d08af412660a674a6608498a9015573c27f42d3b659dedf114597b0113e9dea88fbbddd79d37a1b823cd541ff1cc17295996d93e663fd003c7d4bfa08989d2c229fbb0a358df81c19e1c6ffc16fb714aa6981f4a19b9058cc234b8e62cb2e771968b494f2bdae32eabedd4d9225092d2626d590fa89625b003e0c08d9a1fed78b93b613c2bfc7fadc189151bfd3fe73cc73e6d68699f22369e3db9d2f57013cabc301140a0780609f24ea0a091602ae60c836d23f4ff4e8826ccbf903f50a123b8b4f7488b47f8bc38ce47f8b5fce6da12a17316b12483f1f758b539bca0c5f9b6cd09a4d801718c86ef138b53c54f76919119f5ec876d244deb5846008ebeaa847e61578ca9b3d7038b1619b47eca7e6dc16d41c92436b7db9a6630a948b040cf703fe3beb794865da9c07c9ecac31057c21f5e13d4773cb5443cc7e655dddcfe1e65d1d65be13b3dd1b850e46dceac717b8bc19929178ed8a6de6d30c086911691368c4508953a1cb8d150159a15f5a434aac3160e56d76f290d3d6fc7af6b9092a734d9cafcb5aafbc0d6af44d66bfb02190177c89a03d15775199406ce51fd381b8b379270106c7dfb43fd9f2e67bfedb5ba0e012ec2fae8e7192cf57754754787d89be5705db459a1c5139e0da12abbd5e566510c7b80f744cd76b9530330ddc2a7275f0f6df41e151384f8a90be8f591b4cb4c30441edf9a836be7c99f554c1ad8a0b93bb43fb2ddbc8907161eb4e310ecf1a94cc7a1cbd8d9d836d5f1053ff70ef5750f72d7ae2636cc7e7e130ecfcdf3a211e52f36aa0e75805838520da82cc7fb2753f2968e8cef02e3393c2e42a367dd3ea5f7af260232afa39af67a2ec736271263e296282698f05bcb9f842a2d21df709bdfad0d0bf13cc4ca98070182b8a8b1fe6581c868c2157edd0e18e2d200a7510fd1851f2c4d43e9dabe483413b731597032e6a009fdb7d14eff11b78c3d15722023931916bab7afcda5aaedfd71003afd1fdd3190d8e78506a67d1131dde32dc9f975bd86addb3605c4655490ce9da4c12f7c8c5761cbe7313eca6d1f3ebf9ab1d60a2fb7180abdd56cc6a37c7897befbf0ffa53770d5b8a71761aad9290ca805cb5b58452b4372b73fb2998c73688503bb0fdabcb1eb7793def9ed9c2f27ccd057799f578f31091a4c34154cf6003b553f10308a0465015b5bdce340c74b0350260c811dcf858b9aa1a83a02e1fec258e89b84b1077862f095cf6cffaa2e1dff622a743c01ed6a90dd164a7f7f6036ca2ee4895e59127c738fb3300f48b0fac7449615b3fa0a6ba00f04db79d2289fe4e44860ec37bfc8199cfd5a46467ed32b7791e82f69ddd178dcf04cfca0071a9c1f84f558663e00019267d66403c9c8e33c451a3a590fbfe6a6c73c5316695782aa79f0b6a224ba1af8a1ccc91a746c4ce07b9fcb99391a6b03a52ee5b9ffe324c7440f6993a974ecd963fb96fe5413ba33a97b94855cbdb78078a47651bf24137e2685655e32b000499a9c64ee0130c24b0d7f7a782dee9db1d2de2e4e5bf11d6425f53f754b7429d8ede464215aa6ab427c1e00ea9cfee1482a9de8b0b22735b7e610ad6aedd3f8797577bfec3e30d6a9806059033d0f680dc070abf08488ba127d59067646d3dbd3ca27f976032cce7f4b2c081e98c25c71bea6b16cc3b814a9a44ac460927e776ffad389ac35ee26829cb6593bc0946ade863b2788770799b08b6c292bc856989e1c445ef623471c91c0b8ea4e76864b8c8274f072695cd6b51e088e446fb803e683642bdf3e2bf8f8c9b7af603a05eae9b0ec2d9eeddd22d6c7996f744c9d151e2c4221340c92c52b2c22f68c7eb512e82140ec13b9d055d5c5e757b54e7d829373339850930809ccce961ffefd135263c5c908746deaee061ee4a6f178abede431dbb45506a3774d6059b7bceedb51f930b904f3c6de2bfe4613648acfa540dc57ee249c0c31cfef352c53106a5697a0230225ee473a17ab1bffac8e2745add61613af8927b01cf905f611b974984e1c9a18355d782af6d5e9d36a5a2f7ed525cf0f4e62975c0607c50b5ba619d2f224400ef36e204c82dbf1ea4b59d7ae0660612b8d0c68b5ae58f813f29774e57ac8a77483a466cf942cc6b3c1b7e49c5c1cea5cbeb22bd3c783cbc01f3100c1dde937b2f459c7bce0679f265665c7c0915280813573ceea3f38f6800867985167f6e8b7629a89d2aede53d4f2fb8e6507e8d62c79f6a79f115bb71029296eb2bedec0809033d2bfc228fc61b42a8a0ff816e022d852c3bd0e55628952b91fbfdca2b3aa1b77cd331a798f48354f1d821c5a0bac7155de1074dd90dceac1688f5a36cfa597b0fe35e3b465c7e9b986758d3fdbae26374cbf7b7db4e92546320778955dadff4bc48a78750c7fb08ef29bdab5de7bfef57c88b6952e0d58d483614a4241ddf8c070ed4d70c57e400b8853b48d0c5f8895e7f2c70171ffe813a6d0d5de620246d7b6035c0dedb0cb9ac6c6da027eb3d799d2b45df4da90a0e866562a56683cf04c9b754f2dc9a822e6334755dc69a43be013e3d26aa8a67e72b5727ee7301179b7ffde9fb63d1bd8e4cd693d63a70835d2ca504f9832c197930706be46248f5c775089739c96ce2bbc183a29cbc31a4aa07c24fb7477eb733a977724a864286268e0b6d38315fb94f16d667791abd73f449863b76458e37380fb60c225b2c0ab4d4482a3152c9aedbb53751ed2c5364e8952666396496f664fbace18efa019d47cd8a49bd87dd4a89e54751660811e26a48cdbdeaaea31e6c8ccec3501fcca3160fa06c48103db8c78dee16c73b151ce8dfb976476bc7a670300f38b6efa1b9617c8b30838896136d7be4a3c32ce01fcc1642cc276de351bd15f54cfdc7ec0b356facd5398368a4a5915aa700f3ec4380d748b57327722dd8da36517b9e981fb52ac1668a3978f3e5e35a470a387a46b12cdde11a864de0dc3a2ff391ab46f2f8b47a0bd56adbd8b53905b4d9ede051c795117198741e147ae9f0be4b0328d9e1a4142eb9d68f0ba05a2518da0f0658c2a3c4126c2bbe238848cff83d94d07fa9e962304efb172fc557147bf45ff597749e2c91259fee28bcbb1c2eed21cbbd47be59cbbdae8e489fe54d99fe722ef38a179863fab71136ea09b799c7a2f9a057e0f6eb44995b6fca2cb9f209587918726a717ee41b7ccad494744e770d34d7a76ca9375f92eabff262e381466ff5b3074190fabc5f20c78323114aeeb0ec642bf89c9bdb6dc084d46b7bd9722487ce8c8072aeec4fab87e28a9ed6cfee54f34637bb5978429f5c5ea7ab8e488365ff446dbcc9b56f3861234d6c5a9224f389f9900618e67ca90045cdf01ce516dddbe769b738f07641a9e75a310ca30b34d65f666ec87a2c9beadbcae0f6de28b67d1c11de2173bb607a5db3f8a8bd7f15d51131d8e0a7dcc76b6b2f84f5d99dfc13e2c5b12bb6716f9d0ed5bf611e7ea2fca011ba3bc3433ea5f0cb04ec859441e539950b711148836d818eed23b7a153cf406a66558240f216d5d367ccc1b5b8b1abeab405649f72f085ea639db7cb2a54182eb74b8f0686ff034ae64fd5e83e47354d7c4b47650c763adbba3fbf50cf954a181fb3e622860352e1dca560e66a5f48685bee7c1186ecc042c56cef478f93ed1dd584a2451882ba9f081b6c9d926f8725542ae7e91ce6829cea33044ee4b9e64556dec925c0486486ec06519d6cf64171b250a9597fa3732b9d8294bb3a8a61c368c7546d6fd2f8a609dc692e42f32f126da0420b9f95aba341be589976e42b86b4821b2e8270f8d684112bfa5df59ef3eb5158cc82d8fe1ef5ada09f3a1f0c229701df64eb2262578c13fd78e2c79808cda15b957fd1b35ca84527f528bbc3fa1370965c283a2da72dea38809583aca0eb88c0f697c04257618d91628697b1a89f2ea90a0c5be91210133feae1ad5c17cf808184019196d5810469d81de584c33c7e761a7b0749e5b5144a9a1f9d56ef950d1673a92a01788db0799f1f3534a457ff107ce0ab322dd9e80325a90e50f3e3f0ffbf767ec205084753a8d772a13c7868cd9d2fcc09812f103addfa2c10c907dba25179dd2a416c1de67a8881df293e5abc44767f88aaa644b9fdbd5234a1b72a4f1ba92ae612299719583ebe8be73e97472f31f9855cdc0bbe35cdd5173e8ab8320aca2b2230eedab571a72410f40acd4e2ce2f8c2e5191bf93df70b3ec8b5e7bb764125f3a17e06b70c0e6324fe288075f84f3d9ea5f889d257f0cc169d3beb1c5e66a90c09bb1bc000707b52613a0717c9965d97bf40a4aab81ae8c7ea4b0f1405e23b26c5995999a7dbf141277ebee4a1e15df837aacbd3a821b4c56874c5f298c24b14f1bc64fa49f3d0b4467c2d547f123184caba442c71452a64cf049326121d639ec556697dd169ffba99d6e5afc71f3cf09ac95d6eee9d33172c5d2ce06d66c2aad650d8f326f55873cc283a6540096b0664397a90fd002002e1a42c87a561b5b3b29d0c12874cebb74a025954554276ec82f3ba231fa6f177dc8a18d0c035a1c0bf790dca7ea775f2379b1a9f7eaf97f407cb2365834ee5a32df713967b3698c8d942ea51054814caec5d2f5cb6a2efc13812cf0b94f634e5e72818ff2ad3ed727387e2a635303baf7670e5631a262cc2fd3c578c0fde145bbef9a51473732165b6dc0fc5010f3c2147ce03f803a91abcae48a44856415c318781f334733a76942e7bd2f1df345d176ad5147198e183f742a6e670403e325eca1ba845156479aa3fee753c9b044df2575dfc8afea36ae62f8ccd966bce2d17f979482b7d4c81ce8bd7feec194f8cc08ac741251eed9a9f5fe7c1411f3f00b4c56e892cb84d00a371f5a7371aa6176a2855573163f5881aeafa71cca16be49f3ae2da34153c29279d31ff1183ce2de46227848148d33497483201198ee15873715450eb3f8a74a1cbf3c3fe3c38e658e8f387cb4963cd4a38e481e6524351fadf1d3880c13ba4fac1a768f2c8b949dd3832b0892a19c93ae56fd54798c6f747e814c701a8968125381585901bb6b2a810a34097e4dba7d7dc76a58588809d8988fd3a6d6128e9b993cccc64ca00db9c1b3247581753dca7139e7cea0782f040ca22fb37fd33808c7000820136a45067ffa09f3b573c7c0aa2f289d6fac157768c7c9c213f44d0f073cbdb23efa88311022489e494fa430ebd1bf6480719b677264eb061c48776005150863c88b98cd86ba2535820ba8d3f9b7cefaf54f922383098b52b4f9252da77a5f2cc0266262f6d01b33b1fd9871c6ddb088bfeeb0fd31b2cf3ca7d15c556dfa7bd074db25b7c084cd77c2e6fa5d7a5681541d1884620d72b724e1788b02f502ddd33eedd7f5e0a9e9cbd1c0a847cbdecf6cf15fe71aa7d141febd35bc084ed3feac434005b5cd90dbc91a2d10d670c0cbdc52e859d3eca602665dc4add2c317a8b3794ea73791114e579d9a1fc72995d9a165681e33afca8ca40b54c7704b6f354d73488a433aa1949e01392a8553cada6abacaada736a7b1bd9fef0da32ec35e87d09f4b390c717ed7dd3542dbc4545fcc195c0b39533c65a6f3f4921cd973a7e14ccc545758d956c1d092ff0cca92d1faf50d6fe0880f0d9f66806cd6bbea85f373aa64ff80c8473caa815d73d01ea677b2659f81c9619bb52e2dd212e3d98fc89422674ed271dc97ba8ae813f4c185f13da76fb8533d454ce8755c1aadc33f70abd12aa282a79eb845044619a7a391f0c8700a44f5c95679b77d6b4dbd04a2ae733788a48a1ba1e749ddedd4947d20c81440a0da018e7f08e870161cbd2aa597401e3ce257c8dcd1abce6d53e0e4734980dc019d7ded87ddaf2437bef4ad92ce9eaac21da85dcf329be9ec3f0f47a3fc323e29238ce0ddd738a8a01384f0c8774773ca25be655b57912a2afade8c501b157739ff311531234e86f8f1355837ebed6f7244afa225aefe1a9a9335374a276601e071aeae4844efb8850e2b9c582fd07f94fd6389ae6e5a83214cf0ba23c55a4dddfa63638b9454efa28565f274c9b7b13a6dac7927ded9adff9a2cf9bebd9d29b7371a569b0cda43d876d5b1ee66d313b4a21ad476a6bf235af05e70a82c929ec7eb993eed7693dac583e07e0a07c6559a4725895f6b4301140bb2d80788c5a07a3318c3dfb770d7d64338163bbdcb81ad7331298268f677bdf3e29de19fc8f4a74351d7c0ec797dd8a652b8d7ca906221878935cbd74eab87f029494747042cdd20c30e6f8b3a578680442013cc2f8302648952bd19109739acabe09884e83c0c87128f42d24009d3108b410e69d31b059dc27e273b331da4844dba3985e2922c452f9393140d729cc40c6a66e5e7e2c67b5bf0bcc7655d00bb16ff6a1643f2ad61b7a2fee2183290d1fa15f1760e271f589d092f722e61b1d607543b2d597dbe938aad9cc211f8c8eab09eae4131283892ced05080bf1c04dd4f87034b3a753250919d0185be2706d2b1fc0a3ed8b98f5375d770cbe09c6527d94ac144353f60b46b04223f436288565dcb4fc6d7a8cc2dfe744d596c8adebff532827bbe36ecf802c734ba0d2bf794f439514f762d2e573006908cc5649d99b2f8c0903ac98ea4b4bc3abc26c46f7a0f273c0982764e2c69c78c7566e33788121f11f335bad4b1d16e3fa58c807b9ca28c1356beca7af6c59f45160037efc6292966536296a45a00e1c805d084d40597b715e587fb16322f51baa47c21e703fa5f28ece0420acfb184545030e10a9e334ef691c8e325ab44b686d9f027e908e603262e5fd597d3dcbb36613fc4f61529c171e3cb7bccfb981a102007d9e9e7a3bd9c5b2ce96bd532668e5e102c2116398da0b8ffb3326ae22cc367410704a5b8d75a3cdb67ab7489fb17e5558d5e78b9165bf00a57986794a07ef7165fbbd487c2a9060c9fb141f1fbcd378f1843d439c5509776419081456af56b1f19aa804476b42fafadf4b34fa894981d47654bb0ad1c5ba395bb6d573daf89c0470ef54a0ab73e245a7447eeabafd427b308f5e347d090be463d08536026f29979c1995180c038e3cbf7ed291e28efe600cbad8aa2462134a74e05c2d3c26e974ace6ccecff59e85be0e67fd1ed3158c33885355659ae303320b9fba772e24a459971f64c8042075b3ea0fa89884395df46918af0e3276ca7597e30bafe33a75b3daa89b58dbbe02c16ab15da60177cf2db90a0a0dc47edd8d2c400558d5cee1459c7ef754f2f74fc93d788e6cb603c9b8e2725040d529147625b58c0cd25a3bb2bbce75d0328237fdbbbe08d6286d07d3d5bbc75379530f8707fddd977db4a52ba7fc3b0b6c4ad78ba560dbe9ed69475653d34426614a7f970c059837ab8c739fa7820c5ac4e634d630ad93eda676f6ee56c310e1e733b4dd2f18e2316fabd6a92116d260e46b0d393eb4ee9a403c7ce59e6901fb037dc4a4707e8944f8f98b7bfd93c36dba5bc74a74081ad910dfa1b25bc9e2cf4c1608d4901944e9c8622beb569201b173119d5678eb247caf8211d6bf40ffff05be1a97a0a4401dafd77148f8e6b064d4aec762bc185b3644be610a4b47ed12b9fc1354c96901037a531bc6e84be98f902bcb14ec7a0ee0959136b2d83e0e0a5a983a544f32c93616efb0ba8dc387e5946ead5f193a7f8d578185cc40959f886012ac7c340d378a1216981d92e6d79ab272c7dec64a01a20ae1a3907834a4b8ddffcd2743ab0142e82656887e88b121b8d8246b7ee8e0e79bebee5168d10116c03e4bcf1d16c60d4047a83df26c6aa0330c9c7e3fb297af613058cf3ddbcc1f65afbafcd4597f42644fb7c7bd6f6ac98cd7e03926b77af47b256ba06e15e4273963a10dbdb719f85b31d68dc5bc073780ca7c8abc53d324830c0fab07a7d5e6bae2f873ac9e99dff52d872053243b1504ac9a8b943d80b9b727d265583ce56b5e726be3a07c1bee868d60adf80975ab6f2e8bb113c03343e050e7af8d5402e269afd33a18dacc96ab45691793f0e1f9323dc5073873c28f6ef28a653b2f405b04cd9fea4b1d3e63e391e716fb76d27e9993636d390bf4a97f11c69511bc8be3eb7dd52e9281fe5f99faf23eda6e5efe3f80e6b321799d852caedb31050729f8a233d90887aadc4c9bd2b9a81e29614ba098db57740cd527c38c605495aaa35cc4a972f16cb8a5492c775fc41893e219b1d914357bf1b41546c01b3b50bcb2e5fbff2f6a39f39c2d1cd13b2c6c407589fe597fe75a20c7eaa11d898bd3c8b69a6e7ccf520af066ac7fcae97c0fa33ed4facd37ad48c516b80368d4146173b320f0410dca7b5a5f1044acf6f62692ff8b782db9d364b7878c5730e3b7c615d00b83e693ce4f101dcffee1429747f9f2f78f5c3546f652ae32133eba55321b34d195146f2cd0bfccbb14b25962ae89a5a3944ba0679d3a2fe13dc54380aa24c0a35b6349f6ebea26290d293c933e5c48ebca982fc49231381f2084c8738ce2166eec9f7e0e0363b8121ea93b3fba3ee72bcf2bf6af8234863429d730963160f49228cb74b8a24bc9a06b7acfcf7df89c49e6aa4dd1000e674b40ea38348af1aea4c6d3cdb582bfd547c2484757033c23e03685ad957b5043bca44c5f4d801dea17a91bb051642d5ffd8812c6d82424acb54157990bb75f6227c9bb164852e68c5f644662ad769b81effb16b44203305a65f3c05661cfef8124dab3db0acd2c89af184708e6fd015b7d96b86f55c7adc6f068dc178447fcbbab245e83f14217c6719fa404ae630b3bd3ef5c10dfb990bb329b4f097921dfba508be9b58cd9d5c38c476b0727ffe28c428ae81025da0f6148dd9d99234595980c2953837821a04e81d0841aeb086fc1243f8a9675b42957b3f005fd6db2f2353629a484163b868279a61bec7364273c08fe7fbd5deaf0072e2d1beb580191f736e643609f919606b24dafdf7d7b5bc93da508f7850f12ca15c72e33f2e005edaf1c84c1db5cb23244cc33476c82ebba35fb41d721cc258b21c5b6450771057379d1a3992778eb6c7a0aa462f7dbe05e7354e30adb11f5d2c52f4c68b462fff6970316bd881eb082156905f58032c2cfb4316589c64c5e2157cbf0adf559dfc3471d74eede1fd1d04939d0e5acbeb5db2e278fd8d83294a6588294e10a4a4a6d9ad72bb70a948b32d0c72864be1a943d96a766ff08e63382bd2bf5c49e204d1e709c15d3149fb62237e6deeb1fd18664e6f8c327df71e16f7d5e0bc70970e789ca24c18cabd70b9ca9e7ef825093b16ebfbcd2e51fc57f399d9e0b941386b01540b4be67f28b9ebe372675b4befb9596369cb95a0484fd25f4054e526d661aa4836f42fa25057549165a77ec233fce21cc53703e552afa3899b0d91510865212a10fb04f62448ba2b8c1af17ed4a29e94dffc0d89864c7cda0cd2d45b9aabc50fe617933d70ecc6635643cc9a73dea0db5a0bda49a9f723913c040a57b25c8d7ad908bf41ae3eb99ad44ffa8c586728e43c087e2901758c9db26f206ac96900a3a3a46e278e9deb131e9c2f0f84999130bfc18db8003e8d050471176f1a7f8bed57ccc70eb1631bce7466a42c30529ccec2b997e28b765e4fb3ccf5e2ea8a515cd915e585742df6286e77460dbaf8fa25c4bdfe9846fc95cd1c746d23e3f3bdd638647c79b246458c6995885a0d4cd8eb156e56ab3efc5c116d19443bd83ef453133102935562cf524525a3b4a28f00b16eff5698c627cb8ad5a1ff7d2622b6cd9433b0a6729a70021fb5d37706df249df921709d2c331fb03acdb1ec7aaeb4cd81210ff9779dfc76e16ba3b3da443b54e8c5cfb3dca10489a47c5d0201220ca4d177b7d32413985b32166a2a5dbedaf84b858db637f6c5352d52aa2398da4f5e158e21a3e42f0b445222d335dd1f3a4fbc33e9c2473f081ea6d1a8179cbacf4f4239698992e161aac72c0068e8853896a3040ad86b8cb8315c50e0b48ee9783329378ea31d2c5feabe3c56780e60f12231fba846daea52b1583385db597cd5811ffd88fb95dc0716c9e65b44be5a82fd73d3ac514ae7bc26fea7e8333038f48ffddfb73d980486175c4acad7a26954e7090a50a0a53351647cb9ead7cdddb7f4f0c86e2cf1ba53067c25ff485da27fcfb3e4bd67e61f16da278a09db0de8270fc14774e7440a4dc476d57bd03f724a2a5b073f1c91f6120f78ba994ef16851b7a4c10dc3d809820cddbcf729a3e5ca1ab0b89fd9cb02dd8d1aa266806eb7bbc46f6f792d8649a4a6d653e39686f188c555bad0b9d00adb2de2e0f54153535c9599027f6aade633662116dcd834ca9ed9b524686add312f08dfa414814d7f9257b4b2403627ba0e2078a5f291d800d560eec99a2721249fdd622c6a2766d98fac2c84f0717ab76f37a9915064773a06d306b55de3f29d6baa0f2ffe9e5c15c7228a40974a03c1668c3a7679c3595f5714d3c21b9665382c8c6e22c00e65631ae5dd9fbe4b96c419b74822adb66424ef8769b4e567471c95912819ff0f530756f790ed75529e4edc2e6f498f774819fc5df1e8c03cf1eb9082e61459a17f8beb5b57ed35a9ccffdcd6c9694c731b7b51a94dac020d3de42ed9540c8d98203576da90401abc8df5a063d84983cdcbb7265cca61c0c1fc285634db5569eee3bcfd518bfd094fa23ae45bd32b54521b1b279d062bdc63bc6fa3eb793d4894df3642135d99d567a92e0adcc074b0e2319710a2c79c659f97e390612284d8d6bfead41cfe3814b0701bbd807bed2928154c5b20f43db46e8bdecdbc600e32c821ff7eef9aae2021d8f5bd9e6abb3ca5b5acb7b06993277ff6b6b8f8645c13a5c1262903977867aec12bdd631c0bc123530df0fe8c5b9e89a367f9b44e0822a6b655338270813157467c4f265d3956a0b844eafcdd53c1c6257cfe79338af9ef65732d4130d93dc3b53c573b5d02043b2e332fd04385a6c1d6f2bb884552a940b678c939eff783a7a7022d35631f57b61e3887ed74129b0005524dd59a29789f1dd15225207ecfa916cc0146a418484b2bc5a04d343e5eb5996699b4c60986d55e0797c1342e8cb764cbfcea2fe6e636d2f0aac8a0ce9205bcc38fd43af2f468487022509859d9ace37d760c4cea66fccc1fa6b951066b8ce1fa0ddb8538f4dc1b659c45985eacb8c94f179cc33a16045a883f0e62ad8bacc560fce653e1cee99fd46b205ff7830cc75703eb95b172b5835a0dc3f7f7f1064cf4e3ed2722e47d70e9f4cb5ba4dd0ac2c60699e3c0295f7e2ab46be2f186a451a42118dd572367cf98112e9cc2deb7a8c82836843f74f21dcd1af865784167a140be591b7bba358048d2a6ee7e89a86441fdd9cf91d5c5a592cc49a92b5b8615c9ebf09c96a557d1c5f76e388165219b71bbc09bd42b7e39336f5e2f54ebe30b26f277278bc63719e8eedac04b7d644247b956dddca2cd69f4d296489679499ff76fad32d3bb3fc9174201f5e678dc8a032af6c5fe27dfc79d5aa37f246cc0bfa383ac20c1b70a74603f3c153eddd4818a8d371a56273b9f556756ec8f65ff8708bc2337759d5089d3b4436543c0e7345975bb9892d03fe5644ed925f50ab33327605cca8ecfcd058f031e0fb3da9a5f34cc923b5179c7bbcec02c59e83e66c6e4761595f77b4c8bee102513c451677df9f37cce0734ed103c873c7ba2a468f51f5258fa62f06fbbdd0e53e6c52ddbb44bcfad7871dee6bdde2ee79e4af424aacf6563f227892e0bea11aa6f14639ba0ab519d0102a8d43952c243420ddf829f0bf65bd742f3b3cb61c40d146821bdce40099bb9e2bcaf2bcf4562834a7eef1399905ab271608a6e7be231c8d2d5be5031dc61470a0c03fd2adf81f7520426de27fb0b91f2be70fdf51c99b884b9dcd4ea20e9c43f8185a3e741caff87566214e375a30ba295b821e01fdc7a3cb6925eb936b5a30d1140f2f66874d432843f838687b47bead9d68a9c09e41217fdb0fce597247acb7a5f426c0c06db3986a1e0255384f68dc5c6ca26b0f869a578edde350a3b5680cb5d2d75b2a3162477e179996621a54d773a04ec1ced8f234ea4467e2ecaeb75336f7c041246652452e9417c34eb9dca5d56993671a26ad394ba85d5be5d0e65ffc7872d6df9f502733c12dc667639577f0f1bff63d0c81f8d075d95c7366281f8356a5cf184ea2096c8d09a3e6419bf31e221629cfe7690cd5a634aad6ecf43e4278e0c1d4ecef0fcdb86c269d22f17c1153585bcac56bd9c0b5ca6350ac89f684b55bc83191ce48fea02ed12fcea586a7d1bcfa707484a90eeb2834a64b72e6c21595d68ddeaf20abcf79688c30299a2ddcaf89c9f0cd488d812b4952e58dad3c75e335cf5906e075c2cb0225cd5d9ed42c993a157966c694e95c990c74ccdf42437aa533f2b88d33d407b555a6db406a795db97511d56f533befff30fe25d1c76609e8e75055bfa891c58f4aa903ac7e043f26666cd90947ae3004895709ecb927c5ebe0a9c130459fe3eff683e0afd3ca20e788b9b36183b032de178385f314963ca19e274f432e83842cb4a2857d06af9eba9c03c3c2bd44aa01cdf9245c6a682c0f588afa1560555c40f2d10c6e7e2c8179c1effab61dcfe18cc9f343c5157b351ee65743086cb5fe6301a84edba962941fa5e96139a512d9cbed14064fb33ad0605d3c96e1b25168f5f167aa518412cada0b17188ce2cfa138d2247aa816d6e7f895dac535779175619b37d3806232f70abd81aaceef935154b9d7e848444dff363f9895d5b657fc1ebf92ee1d0c9e1fe8daebafba3be20f8a21961287ad0b6ee6095710edad65784c774654412d9981fac336bf2aa3a5bac2344fc1137b1bf4216a9fdbd2d5f29c94c1c7868e33b7cf45713b28ad922b7ac368635358a603e97f16e1efd8b9b4aeec8bfb99a0afef45047c041b02773b61bcf3e882c37bc54d33583452ba31d55c336edb3a2b3b9ecba8aac828a2e74862b16504782a10c4e5424ba010521eca2905d9035f5b6dcf9214acabb78c1caee9d2f525e4b1d9697f80ed596b0b4de0172b60566944f4065522800e664782961908e3ef10db78a29b2cec621c6e4e230f747c4a2d58f7173bd2c10253fdb054313a0078d94a412a36f1f35c00df28c6a4a089e99d1d24aec94e6e2ecf7bd74d3e5158ad4da51d0cdfc8ddb3ad41de9a61189f7381e6ad6ee0aca34806c4484703a3408944af54de68b741ce70dffc3e30a065e0039b8d7bd1deac6c8811bd1b3d41683f58f587d627fc8bf7edf16eb8dc0648ee60c013d394c8e7a675e71f248e9bce89c503343e8ec8c00d6974d1c95f2087b8ca110c7da8c3095e6eb9f42c6fb6ff9051ef6fee27f734a5d0c035ccee3a4989d94710e43e439befb69fda4802cf50323db2b8f4dd04b656bfe9cd2335ee69d005882c6da3d735bc970a4ca916dc942d93aa52dd07d7e175852f402e0b6fe5e9060a0708d9eec7b72b8926714bea6906f8e9962196b0a321ea6f1800c2c70e96bb089b7b94f078ddca74cdc59a037ad47c4780e0bdbebe443b41c202f5b50a5239ff8f9fb182dfc60b3f6bf59ec9306db17af3b74541f0aebc8ed9ce2c1fff7fc740224cfa51376d3d2675d80c48b5e13cf7b01b002fbf0ed65bf3a741c0f99d124ea9a96e3199ad048fe1eaf223e307f42c36ccbbdec3226b0369d243af520b6998fa7b641c46a3fcd30b31325e342631e7418c7a4ab56ca8fd55afca71af7f6cead6f8a0e84ff192dc0640501419ff39a1fafafef7001e4aa8c88e2f409fe6c365fd436b760307d18498fdcdcbe069a5d9ded6783d94ae475e9efeb736f0c80ec635d774f73755bb39927166cc99e5be7aef919416f796f6937ffcc6e840dd9617ac1796e48ac2b5f9d3b63afb5ebe1780410403c8b9a566daef927baac602681fcf268f273f504f30320bc1b5566a63f44986d8348370b2c5064f5390cc09843757e5b838662e61301e08ebb9759a54eef2b9a5125e088ee066cc3e70754e1c6277a7009fd5f0f1d98b55438164d5b36edea3096b1197c1c537525450f6ca362628da5746252193a1ea3bc6ef8d91f6221494009d68a0203f9b71cb947699dea19b807434570b062f82cf3827f6d5542ee5616962e48b8aa92ad59a038ac565b80197a17b3d5b7af6a33dfa4e1282fd9291c1b84f6fade4d545c40165f38eb400cbc0295cf3e536237c5185e256c81441e2f2f9ab5b8f9cb5245a0334080f791110802390b439f04074cf8843f5cf742a7980cebb17470fa82ea0b339c7eb353e5c966d7f1c359e83979fa13b25296791b27007770f20bbfff47eb82b929dbf3d2094b61fd76dac79dd7ef6a85910366ccb390c0cb022def9ddb50109fa3b2ff1857512e8de082180a5c99bc249a3f45372922a69c6b2905d0850819d79a3e417fe5c26280b3512a5f11fe539ab688f191de115e92e21713c152997ed5dbd794bfa892d10592fd29146851c63934eefeb157d8ded02759d5112fe87e8002d46bd8f126bd1c9dcb84ced8a849579923b97a801d188e704d0af9a64aeba5ebf02bddcef6071435533a1273299352e9f37106c818732718332db5e750d23559ddf3b16f15b95c632fcde5f2863096304cd3a7b528ddc584ad40a446d604c008a327a5b108e2a13f9acae6502dfdfdc21290e162486976b36848a382876e2273d128f285340d497d0b493f3a7c56869fe764eeb5ea46a16eed75c5b7f6dc4ba2ea1a9a729504a3c72cbc70168e8db8c3b040ff6570fe0d17c377b720be662d8c4ce3f42bce3de97fc9c821c32ac8a6e8d19711ee3e8a2b86e2a573e9dc6b174554b953aa1b2c77636e5892c8e9682e2c0d2563dfc064755c2892c74a58376086f5524853265079a5bcb5b01582d817f3b4eea4a294f4dc2a058cea731e708b43ce2c664bd3af6df9eb6e53d41d207e8f21fb6e30b6c6d5fa71e6157aa32b19274cf77af717861db4049039a682c0171db942e5735f3da159e8f28ecda2c2d76042eb092416a923bed061a990e35f2e8070a20ee81d59d028802b3f79ce60ae2441d18fcef6ea27e41ce3ba6ad9538167a7f212791105e96ac32db7e8fedbb3ffc4be97848f2e01508c891e121acccaf023fef8a6505b7e514e8d959417a0234f4174c58c8f3343d1cc3fe46020a07a6c3ca87e10bcdcd01fd4d0704598ebc5c8cad099ebe97979742786d66ee441c9c95e3a4cb2fd4732267d9cc887b58fd9ba88c665137ab53a49a58036e32ebcfa5c432ec64ad66d0792808db85e9d12cd6bbd674c74e84dc0015b5cb9105664e95faba99361a45a50de67888d229d59aa6ccd728cf0c31fbac28e4c96f87e3e07808058260bf5e53d41d7c93074dfa6564a794fcd01f351d4eb71e2d1b76af13e2ca9a06add9fc9ad3d6c4eea1e55a86eb9f39b0271f724d6a7dc0bc4ec0c8cd4cd81c0fd251fe6071971adfb53567fcd561dc1a86bef162773661ca77a0c62dbdb37b4563c762d4a72624d9fd2b45472ccaa1ec7267a03c0209129a8fb4c26bf3265724d04ecb4223948daed44d900aa1ec42433de9597dc2bb9d708fd6099f2c0e0fdcf01da69d9d9afbbd1b0a1a5c273468b79c37a18876fc1b282495d825e27e8c2fe67c0d7c4b5d9c255a9d3d9c195f64c355acb50583bc2ceafbd55faea55a6757aa4f6f5f9629c84f057ba046e8e841f19f854ba305d42901e3e07f4df48ac24b9fca80abc64d40798bfce7e908cd1f721406a4e21e07bd94b73609686448b860a585bc5b3d4233fd8b2a9dfdbea65e35e6e393cbcbc052d0a94433961640a703df676d5b77f2f4dc1ca9a1a2bf76e05e9e7f62fc50f6aa7e4fd1612595ebafee31a032e2ae56c65ea38d63f6b1334aeba7cd1d001bd1a0ff804ab9edec6e74b67eff33a7a3365e69cc8bd41d23ac2082ae7b8b951da96571e926f88ddf4538a9b12e6389d269a4de7c88b52e34de5570365c4044089fbed49b351af9e942b339451bead4ef19d5c27a778dd0287d7c24c1aee7f94d5ed976a07ebfe8ba3e714baebb40b28af0c02d981f3ce59e0a4c2d3d59e48541bea72ef0f9973b8c25f5933a65deac6662dfbb31dc7cc1573b32573947efd006a620db871cacb2ad813a01e3278df7482bdf2128ca4eb5c9d434257506756525720caa5f3fc310508c1ad926f6b0f9cc747e82e3372d338765110ee803a0bd72aba449a1bf32ef060a6a7868d1e69e07f8a76250a0a620fb9e55cbe43d77a2d09c4c01f3fe1f1c559bb2c75a4dda9aadae48cd7cfd01f37cf05bb1509b7deae9d9c45555f8ea53dd9ce749dc2d527ba37caf5552599818fd5c29262450522adb3d0acba1d8bf0b58ac913e097318be743d14f4aa4fd0df54ccb05848f6f7c655d0ad114704cc8575df0447ec4192c69b7d15972135dcce60f744e17818831b01fb898946b92f2ed513524e1f9b6eadd026dc70150cce667c7f6f0deaace8bae5e9cf07ae3f05a174a8f9f1dfd7a81f0523d928dab6f52faebb619cde02a3a23d0eb3de2cf5ec40e31add11846260cffdaf4770b4d46eae6c1438cc017878b25d401988fcf6fc7b8fd55632b9bfc4967d641551a199c2dd0952f9cfe107739b8a481243bf6a4d034e9f848ff4b980ed87877ff8a61a63355d0d8a4b90c515e2190fd69d58e068c74188ad64866b2e5344fdac73a4daa8df56feab14edfd6447fcd1f7caa15f3d2a20a1296dcd046f85cef08639769df3ce5573332917321205773cf43c5615fc12aa4f28d6a78196730f55a63b647b2b7ceaa29507f1c28c3430b73be88fd8dc12bed1a2d674f0ec5d3a232f054bd1684a0d70172eaf22ab7bfed18432a9225fb59ac301a66ab7f04751b760b54ef2256ca81dc2e77428fdf828e28507419cac89ea187e76a30b30db2d7f0a29a5cfaebd9d26a7c4ca917250d3fff8153334bb1e4aba9c0b316edcc412c85cac6760c8f8f49bfd4cf2e062491ab8f4d9f280e1b2cde438a7aac94ad5c170f7dad4694008353b6441df8c93bfbaffdc69c8a238e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
