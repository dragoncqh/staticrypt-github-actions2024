<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51eb381d37c99959c362cc52231f0186898d48dc1e32e9eb2fbfe920ffe8648a534c47f01845a54038cda1f94d918f706eec099b2a32e0cdd83f283ad879245598b687d1d69bd087fd5acde579e9ec19e91677fd75d4c4391ea0a27e153a8624799f26b2cf644c4821b2d785c56cb2f6ecb36f4e8ce77e0a5601f9ad4608fd68e64572cfbf3613851382767e4c0db761fd3d730278534a1f7a860ab5d5bbe3d439554b05c279e2058905ad056aacaeda140d18c6d73c51870ca9e9356b6a85a1cb1ccec6fd46d6a1767084e0f14a6b2113dde6d1037bf6c53e8751b71870294c46e1408c306ec84fcc14731f89a5aab2a98b7e29ef2b3bc1dae33fdbcfd5ef218fe8644e3849af1e548f6608ae140f579b90cda6a174d3d2c2b8f27e1d08396ee895ec455d727a8dc9312052d065ac17455d5cf9354e6c79bfd5ba00036b49bda77ad493d4e4cae549ab7b5f11c2f7f4ea761ce82de66d36cc0acdaa38eebaa9c8838a1942f997041bf934e383a12210c0437b328a97b73a6d068235d5ec5d6c1c5838dbd9035b8c8b2e2a3255447c3c679ff3e80fe97640a39078341687f06144111b70d9b1ff157dbdbee25c2ebe3157e9489d5362e89cbae4ff5d14ae7bbde6b4fcddd1f50423078d63522801e3bb02462516adf75a0e94af1f800df537e13c942aba9aee0e3bba3ae7d8deac59a813e35b1fcf744bf14ff62fe0b337bad70ed89958dcd6179abf3eb6f6da07ab100efaa4c6f6221e2470a1d6e4b267d0a1dc201ca6331a44f5f9d10f9de1dd703668a6053baac762688622fddd2d239ef21dde6a9abedc85e24052c44835653b3d4d0917ed3318588eabf8fe9f07eca69015c66cfab95116b1c4ab0729cc7ef19a1e4177633413b99a7bd504e3329f9416ba6e827acee0b131204d0a674c5c658fe6a736fa965b5f691496c978260565474b3e140d78e32ca683fd8bb71bed05ad64d6607653ca9fe15b4608a9b2dc5346c7ce7442dbbbfe1cbfc781c3c7783e7cf378e146307626b998cb5198382229db5cba177bcd56021595f628c2313b81f95b5a766907cd8c3b8cb43c462be3b2f41fcf6db4bcaba5c4d6434bf372915ced0d8972789e056f8236effab2c7df5ffb49e061ffc4853bb7446d40557d07d51d1ca2f35e6587b9757e909773cee3fe65f8213ed9812b5003a316ca9a3172d75c4bd8e2d7b14cf7d15bbb9caeeceec877e7f8085f915885db64b72cbf2a6e8a9aa5cadf5a94e0c24d3a585abf5ac52210d1dea32975cb4be871bf08a5c32f1b910b84a0220c0659d1f43b31ecb6c3951c7c99927841aaa5a55fc21e57c4a95a39161e21427f99731cadbfe81ef7b0ab19413f38f94e7aa229c8c789a034fdbffc3cec4bc695440f0614537f7d370dd6763d48c62dcbba18a059307f9cfe97a62549b692bc10d33695fe0179cef57eb654e248a7728f8a2c753dbb6d619595ec0b1f6835a7a097e4f3a8b5e46ef99f1bcc35b95c9b0382854461fcf82e314215bcaa089c5c5cf62958c6040859fcecf70cb5770df3b62d6b609f48098a3ec0f1fa502559ba529d1def99e0a5508f92127d8ff3ebd60081eeff2183674a750d7db0332a339d7c180249b3c19fe6dc4404dd599859c939feb215c3ceb74ed2dec4cb7115cbbfd2ced5821a1ef82485c31e4a4eb5c829cbc10f4c1286eb02ce9f844b5138240c6e8794081addba6daf3e7d7ce2ad2b50e6026cbee8ea1c94933ea63cfc39b406c7f25b9048807618e4ee660327e6dd2a9c7f94b94d925ebb392461343c8921884a05f115e17968bbb25f7d853ee2fc5da479d87f13bd426b1b2ec6d2ef7b58ffcc9f8164fdfe866a81030a1a65a3caae3276c26ad19ff60ce82f4024b9deeea70fb98773ddaac1631882ed9b316fb83cc5795f7a8882589ea53562237e90f53afedc30dc662a9557410bdee92ddc70815274d03d539aa3e6a4b91497a77c035a1d67d28f473ecbd14844009980c5c7fe051f356f5f81e195ffddd1c1c024b11062c954fbc2a1ecf7d95eefd5da903ef4b9c16747aae5acd34c612a51102541a3ed2de273e73213d70f90f8b670acb18bb7874512461c1117ce913089222d9f4cb50cd720bedf1a2d36c0d80349775634923fbcbf3c9b94f332cf7bc9f5cbc50bce90d90e8c453fb64f901deea537d25ad060068ecae98857cb134dd26650ed0ce3a119ac0314f6af75075490848b3e6c7de133b0e657a20f3d14cda3bdb5a979a7e7c20123e25f2cf340fb7b51e1df05bdc215efd48c3b3dbd48dec80b6996d262f5fe3de7aad8512f296fd868df9dddb9b0883c00728721849dc784800c227bfd9d3e4dcc43c083870cf09fc720b1aea3791aa81458d63b5ab4a09ad68fb2eaaf8f042d3e3da1869aca33bf2c1dc3ebb7bba49ca16c771c640bc90bb912739b8f1862f39925ae42fa89fdaacba16cc9afb5bd2bec1ab87e8b28553b05385d058b77e8e6d955d053935670e7e0d3ee2dd81b9cbb3ac0e80728cba4c345aceb29934ae4bb03620c6f27e890890452494ff80abf6e82e141581a1741383791765e23d94fa2379059a0785b23473f6b150fa1c30015d0bd84063860a652455150f11702bb4f7342b2109ae7bd78788089f11e9dee1c99d93304e85daf5671d854c96ecab2107b7226e6199295a884560b4e052dac0e67875bb4eb3af1958d033e6cb57bed62025d2278761ac8a4d06b89e329f37c4ebe03415abb660a14474f0fbb6c89ce85bb27fd4747528c4cd14d304fd6709fa2b655f7be5a98b51fa5c80c160c93484a2c06259388c7a644b8957c65a25910b1e6b452ae0dd1998c09e03a3b2a78804a4fab8b233250f4b91bc81a4c52ef4d7a75a4f3c4d2d5b678c389f4376257d2d3ccc22c6d3ccfdc175f57d209bcb7570230c62669a2bd9324b93f6ea08a90807373b71a1451b912edda8287c461c4066970edf5ab74bc877276103910c06029018712e7758d5749edf5277160abdfdf45d239b300db25152b7b8d1bfe81f62492a55005061e33e710bf1dd06b2d91934a63f3ddfca92a5ffd2754e109f425056dd897ae3d458185e23fc9ca82d1d58d1a02345b8a794dd0c970693a9e96a447020bc0e04b3bf704b3b403a3ec7391d233217e93f8105b80cc53e45c4304524a2ef8a4048834f437b2e07374928e18c9812a60c09a1c40d604ca38d5d1f16b2588ef4fb008162fc739167d5756de649759fd4d2e9fe2847e1825bd35da77abba048927ca8ddebed4ab981e3da1fb22d33538e53f0d1c2b1b16baa13c13b86462f2f30033de85a78fbba19fb7aea3a5e69e138ace46431f2fc8b1054c7b13f6edd540a5d07db21ecabe81303b709a7fa8f33be8c535d47fd8b575999552389b5b9abc7719ae6adbcf6e55fe5190c060018f793c55cb9c754af1932c4f107c6901e3a37b4b2c0d75e4653c1ff23dc7767154c30ed152012bb4c2b953e02b966f3212661bedd6469c6e37ea8bf987ed152b5a2cbdae5964e5d8294dc25381a7475958cc71f6e5e7823b99c12902149114e4e48b8997041058299a46a7b28c1bd448175f289606cf8cd52678b38994e25f99517f2ebaf262119de3664643dafc212ab798de16cc8c9bf25df5aad1255753a93e936cfc4dff54f8e0322b7bc4ed0c73328c565e2126fd35a0cde331102cc0d7910c1bc36ad4dff49bb4427008f843c7733b0654b07c361cfab031e4e96d5c901e32b6811d02e501fa0f1a66f67f9683c529ce2a933034e2e9fae6a445e4e4212ad0d9ba1eee24b66b7c98a5b7d4d1d71a8c1a41c2901e4eaebebc89169a8a136924814a1ec4685649e128f59c8b1a94fd9b102929c553501157763bebe0f5052885a96de22b214f3dfe09436a8161366448ae74499492a71a41c86ba8ecdee512e4c559611d71a9e5fa01f9c25ead5d1115c67bfc6e777a49a77c14b1dbcc18bed386f14a68fbf6e3cd4e6f84cd3a0946d78eddefd6b07277928be15408bac073fb7853b8a81dcd08751a7178938819718dd4c5eae114c37884d99bfe49bb07d8ac45eeb137cab4c607ec1a70d4b728bf90496a337debc18872ef7f57c10299a4650c997fc8ed1c716adf681203b0b9cccd282d15f112161e973035b3d788193e7339a28073d79ff3f98b39e3fda108141d3c7e8bcf651294c0077e3c457277d3a18eb79a655f6e1a71e5e5a3d08df1bd38fa865bf5c2f5c95d4550d49cdbfbdae78744e4630db18f68ab7b808ff8500b6ea96a9d7a100054496e17f6e3ff913dcad94fbc8b718634b431777e15ac5243813712b77fa2f53277b7e3e9f1c8ec7eae08f373106719368bdf0d137a1a6ae7f3c459f55dc302f1a0c1f46f3a2451d47c60dbe5faab837d3ce2422b465c57f7e3abcf7e5c3d594e8aec9c921d90d30ab87a2bac79d2fece85ded685d19f29e1d429bbadf474fc4ec515e7ca8d9e4f79fc072891ea7d5513b76254848426cbf9f675ea08f2dad7573daab97351d04508bff749d00ae92ffb829259e278943f9c4c9479e20764fc47f94f181e039f672eeed4f6508567402624dee31138adc9f9a8fd3f160ccf8cccb1ae2e559b2e9c86437f366eb5ada0cba8c93a2fa431a0fb1609aea6c7c30adbff15c50e122a347b93313b05e4a23883bb1abf0631c444b329a8e75a1febb196b78b3b4e17e15ddc5407e9a499b84a22f7527bbb6ac73ae5d94dba50b8641329ea9a15bff15ecf82fab3560cec6de227ba5ca97ee4bf7b6628af262a90a68cbc54639a19212bb3902311e01e45d1891dd4e04db713e4984d27287432d533717847a746df088f85e87b4cd785112dd22eb719d89f366e079aa90d3317f6efc69f2a232ebb6832f71d8b6101013b410e6d2fdb7eef1a0729097651f1f7c041ec53e8e1a62ea25ebd0fc5e0ba6a104bc984da0d757fc11a4ef32a3f4ddbd726c550e4823282461069678e294251d6be6aba6dbf82ac06eb49c490a5fd1f1233144fa0f1d71043d8cecbca1214b31f5fdb5c0d72a3b4a0812e0e7d5001e775072984187822b805e939f246378d3a2b8242d9b5ae49797b8b28860a4d59abb14c0b1e92a59b3e8d330ff54c4545ce6aeb282c0ee12a63fa68515d4f18a83bfc0a894b641c15b030af038fe52538f25e6d48c1d8329ffdf44daeb0ec7a9c9345b15f7610c072cac4068c5d11fc17f0a67f47b5c0500368b59ff21ab03f0b75f5e81204b5c8fc4fcad85c5430e369a7f0d0e1225f14644de2f735389aa8a79edf8dd4e7e04a28c5289c769f5ee0371aaf56852aed83ef951b7716a877cdb6e8f3a5693167af21f2ee5945bac17ee91151e5184d7c5b34b53f7906bdafbc6b5fc34bbfb695ebb2aa4229d56fe0acdbcde66e885c5da2f3163119bb41d6a4928189f49b543a13fdc2f860bfda8f04be0c02f6b40e602ad81550f631ddd18d31b2701f8960f960f654242ce98e177962f1db86eaacc620770d48f24e536d4c534c862ac2a528ef0391dbbbf1fd85639422608077fc3423d826bef33c1a1a9aa11172ea347f6a34aa56adf683b74fe244a727437222d1168533e5ed29d636c5c3a13da71d4f2bd5db36c96f928287948a6ab4612f4c94b58285deeb3c345ca0a58a3aa283c3ea553071afcacd5b579e06d97e05b5ce3ea84d9f53984a4379ee0c23c608d72ebd4b371f2d8a2fe566858c869cb65cbd5cefa536f7f3f518ebc04d868ccd0fb438dbd3309ee0fa150a275a6f7f4b973ff11d2d4d19f3dd7313b572075c673d18728d46b3ec41b3952d42fea1b973af13957c46577e851066a5747c2b760468e34ad6324c8f74a5c99a672d4c454263aac29009b4e5c6b39f93f9e6c3c786640ddd4f9e76fc52d84576672aea28ffe441d2a29af4d1ceb0ee178819c8fc8a6323d657269e26990a384108fd6d3c125f3dc6664d540d94d9cf890b78f7332a41ba0a8a78678ad528b3d4560c1adde045eb22250eb8a8632a328754c7a779520b4691fa950e66039e5af092249d17622eaef4a3e9dd7863191ae4405461485e63c22cd731c69b9c90fa52b33909cb133cb995aad94fc764cf456f2059084a7ef854cb8628e744022aa1852dc7d01193fe8736ae9d48551f43b23182d512ae02825fea0fd9ed606a9af0ef68df1c4d1032a7244300291f49c21f1d42ee5aa480986a05680160128a8eca6fda2504e7125433e8baf8deb4519f25e77e0f7ef66bbfd1a1b1b565013e6edd818a71fb1d829e8297494e6c4fdc7c505795b4c156ffad94e1a309d1acc37173778cfb3d541bb62df195d2509ccb30baf6f7158bbb059ce0971bf67c856d1be18b773d1bb2a9ac919c5512cd8cca4670ccf095fa76d4aaa9a25cc6ff50ff92f7ba51f8258e0b4f8b5885804e3c9d86fe522115183d58ca0c1c4f6cf39d9f5fbafb516b25098571982713d8ce44fb34547a47632fff64fb5a120bb002cc274ed2af65fc1fd9d9a185e83b62e3760c942133c68ad07bf1d1c84263c1312a1d9a4577533b51f0eb12444d8f038d9142b11d43b43c053a925f853f90d06cdd854765e1779eaa4d56b2839e21f81caf38f0fb46662aa596b4bacd6ae6b0143e09edbc39a782831a641c62a22b6b9916512a005b93d5069ac64742f51821cae81a754eb248a108b1528d642ebec2d44ccddcb1c56a29117d39b3c8b2850be29dc15d69ac715b9bbf125326c2bfa96356ba78dec1fe651203afa9afbe03c006edce67d8b6ddc05a0324dbc4c9c5473e873f0f8c8b5166079355ca615ee6479037bd2393b3e28edccef3643a2b93335a3fca87a26850766cf3bb2be3ad66d21082371c53c35afac8beca46c488e03eec08e166f9c76832be3173df4966fa9adde6df8ff847da5c167a2f8d6799933a2e136d92f4774f273d8e0416a034bc41b41a82a0dc2098fe376d8a8e14c062a2d20b7517cc49c9faad02cead4514785e2956c8c7a9ed285c6de6c1f3ba58984b653f33aa24c310041aa00d07cc9a1b5a6a64cdab2c84d603df4fdc338d3d4eef0c0299c4d99b9b674af3698bb919753462d264ca7ad4655529f659749ae936ca99db4b14464459267d6c976c2d8be72e03c24e04a70c69935abb6a2fc3a95d141a73e500f41a5ae1d8b3368e5fdd26d3be866783e41bb0991495edc5cbd33bc3523dbebd0446afd0d80aaa999f05676857cea3dd53a63f2262e3e02358ada070f7cf878bd91cf2bff040b8bd6d7fbd08b75f9cb0b09f8db87a1ceb9b818a4c7829977eef63418fa8675f5cf056b03635d484a823598a26683ff5df2dbd0628a13f649d57be0e1577e8c1ab67a6104fef962401dd1cf75533e64a522afc66b914a053beebcf90dfe3ed3e034a212c5b5c35ff022961c2be161dbfbceacc07b923737dc1cd1fc7bfc277c7b2ad3a78d884ed4c9d7b85fe94138c892acd12c5fb1d7105f78f2f2949769374fd800fee6466ddd13478eff0b9cead756133543af39d14cb56b7264a6d0a46be50712a297ae64ca8a35c4c89d596b1af961f0f09319d5d3559ec7f517f193cdee584820c7db82e6313259ec2dbb54535c8926f32002da3f0cb9852c3dfd37410c9f37040eb164c83968d376ccb6916bd1acaca7eb2eaaa89181bd9f6a7b45bb63e0b25a018c1792a55fc37f030fb3ac6dd302ced9e62a453e0d4115ef98c02fc2119f9f67fd3126b3049461eb2ab35d0e50f80ade9b912e96ff1aff38780e6434585b9b17cc9d04a3bf68cc190658bd8f77300ab05133af40ddeed573b6ce804631e2ae2cf8ba5175cd7e2716f03a8979a1db2ba316ba5f0072967fde10832cc5bc835c51f99e9d85b7b4872362777000c22b72d85e5ecdec58f18dba02d8dc5e825beb26326091712f445ee41997fde9ce1fe5a88fd73a94aaccffe338afe530c69de57b5c76876f7c87d14db302c5eb80e5ce91a377453560d2a36610091298466339f11e4fde2b8639e488ba763e4b7ea32bec0dc9546aa2efa16219037b910273d68483238ec3e34562c58c1aa82a0673ef1841de1bae127a12da543cd829481f0ece7e37ffa3eaa58ffc59ecd6433868a606eeff6f861994deecf869a1e0828f5aa176d122965029b8c81e796d42ede6d13b06b023e66d1cb1036b8f70829e06f2a61060f5ad18e7cd9d98f3bea7a90efaba67d094f299f8aa05305d5ed93a0877a0fadd711115ffba2ce7afe04946898d8f3f08b13de4aa25a9fa938fdde5ea54edd792a54a54bca894e776cb48cee112c9bdfee28ce0c0722a2ec12195c78a06d2a58ca181aa8d0d6e1be207c13d4a1d128a1a1880e8dd0f1b36acaf1521a81be43ccd7e7b1c81857fde06d2f3c3e00c1633d6fca801a74a1ae3e8e608d6895106e73c085d226014ef91982ff346b1996eada01dfc886b8c3130806f351d03342b6498e5d36b5e3e36367231d50436e7cdd06f00cb13a79835aa90c7e18ec49ccdeeedb77f07ef8b0f160d5210f7ce678c09881e5e5a36f36e5e87508bd65858092c6c87845ece5e6289e4c92b49782ee04463d39d86bb49fd3b093e12b9bb32fa1807001de64c4ff1060341ecb899ee1f93bb1d4cdc0025b28a568897c4d539a1b9607b7689a18af4edb624ac7f37332cf3e9fd1bddb95b54b322a3995a8083f25ab067422d052a4b76c7480b93268dd22eb85290f8b29eae360e191a2e62a922223f6a8d30debd356353e58cf6babd332b1d0f8cc0a6cbe5ee10a532111f61546ee69127920f6ed5cf5c8425153d879fab4dcfc5fe067cbc9e16f75b84ee92690b78181007f7c92cba1693f4a696c1bf31840734a6acd57faf2fc4e0452898672335128c04dcd210e3139cbcea8f1193aa39d57019c58d3538d8cba646042ef64ba8c3bb0c9d64cc9fb6b6fd26efc7767ca13e18dcf24dbeaa09cec4cd236f6eb8c1989643956e11184ad67aa86cadcc2a8bc4fb92613d486925ed130c225c1375743f49a6dec2eaff9a749dac863319c22e7b248d583e2b784cdcbe72ab2ab2692c47a0f5a0693a0e17817c9ac05c094c8c399ca3a0b1c38e9da2f8e121b2d6126fdd7317ba77fbec6096442b8cb9cb749c48ac7300383d4716b32da8f5abbd33f278b826805096306e0536beac45c82fb24a5659df74c82247aef6eb02860691cd84f9b819280cbeb32e5b20f14891a2a1ee18404d5be4fd3be26477f6e6ce9ac1bcd32bfe018513b0246f31e2d5c3874c6b7a0d67362cc9bb84e6ce2e4e6be6030294b7568e99129029595c7ccb7da0c611c9673111251b8669e029bf753b4e32893f6880d1075dc8a0c5f6a79b617bb71f0aeabfd26c34df4bf0044aff6bf449847e06044e927f3f33f60337af046b9c79103d3a19bf4d5eae49ddb0f9326bff9985ee27107dda95c66ca3073a9f50b094c571777dcba47ab6df3bf5b561dcbd0fa243f56f28291ca91063bf605333e6af07366368c6659131f63ee7b7cf327d83305c5cfd63d69408511d0cf87e320dee3690a873f21f3af6baeb3084ba96d613d53543c17373f9b8656e70e8d27ed1ec886fe4242410af35c13b271dc959de7214f7beb0dc5eca3259df104648efa4eb3fc6597d806eb2936d18f593d88b549ece1effa790b08813f8d9a63124ff860818a77b30bb66473f1d71eb3b6fd82c780740aebd90137a247e90e0184118e3de5befa6229098a8a61ab903f883e2f308ca7ba7459f7760b172c9e6caa9c2d888417d669747c350216333a798597bd62ed9a32642ef109a0b31900ca558a5419ccec484648cef43b1b919e7667f0e5727b709f8008f151f2545be3a026a13f51a97cf277c892de03bafb47dc46cf3e56fc4a8ea17aa46572365909cd0e8b4efa9a7d313854ef8e96c48e7e052585baaf5f3d5c5a2544bd905eafff8f64b238f1561dd1bf2491ba8dfa1620c2837c8d898f425ce734d3d3614c160d9e9bbc59ba065e48fa2a83a62d2792cc0870c6f8a4d549deaa058b970249e832f1e91d828b9ed49c4a97f4bcc3c9fadcea74e565e06abb0f5ede1803dd3a895340099feabe9960dc2edb0f8340d9a7a03ba02bdd7617c4f9d9d8da3740a8e1605525318606f156b3d0eda6946fd83be1cbcd7e4a19fba12fec0d21f0d02bac9285afddc5f1d3bec9f927aada0e20c8cbd8a5c0a5e6bb6e34be1716f15e45fe5a5e96849486057fc3cba7e84cb3913ffebc7e647187c4f762de20f27eb1be089fc5a5e386e423ea242b4e5f6beb99263b70c6b3dd64953686c9216e78d0476e7d879802577d4b33ebb7ba7751ddfe9f4a0b6323e27a403a7e637d032733c2d218725b9a04d27b2f6b0cafb110a1b4e716825566bd596a3cd2e093966f3ca2caeae24460964fe73f6709f407a361129e29f8882bb23623ec026b8608046dce3e9bbdc4430a71f03b42b3920a7c365f4615ee222140ac34b243f8327179e7efd6d8a6d9791469e5bd24abbab88dc363ae06f745b4f0ac2ecc31acb1b1942eb1e76354ea99de8c6afa038d15f62112027d0d6d772924523c730e2f6b1cd7a1ba73995033548909a98c30b2de2375cb2c26d8a27ad4f97a8a8ece7bf94972f6a3c5ee7f4ee1456bbd6a2a1d143e78e9f29757eddc625ded540d181cbc79e1688f0b795e5fbe6e47733d4b1069eeb6db342025764f318cefa13bce606f7b513fe0cd199b57e0d0be2135b022fe58fdf9e2718a55b4fda7845eb21a7242abc3587beeb58975305f2f6968b5b8b5b1dde7886c7ab695804b3b45a7ed43a75176f59b4bfe5f317c9a391c99d0b403b4f0f8cb92b8798047f193c38cf338a7c73b1349e9d4a21be381f0735b289c341a050574bfa69fa8fb257c38448b9f2e37de8ec12f0203db480ade3e13729e9c46540c9107cf9191bc7414af7b6b3a33eee283ac3e2e0e1b914e356f33dddd08fc2c0a9b3a3eebd819b3daf84f4c5499ba87a7118f7ff1b529f64489d732d897089bbd22b28abdcb5c68422254c6bb518479b00451f1f5b1ac087d2725b24e1601c4697697e3e2e3f5dd94bc457e3382790c8030a4a984f1252c6c8804d929582fa15bcc07ce9e0ed6f1eb3d018db4f562e0f6515749be21298d83208997476026f2d955288d210ecd8fdf6728841c877869191a58b1e20f144f908ee74404d6a16788527df2f2d04a6ddd2c7ffc5cf9c1c04d63099c269daa94d232e55411e6147a1b5e6eeefe9597702900bd3b6cf84d030d913f452e41a59505ec05d9ca3137100ac87942fe49205d3aaf7713ab08285fb1adf6cae8d3ae4c4c536d27b7749566dc07f43ea168e77866ea9927540f8b5927c7c44ab6f9ff743719dcd9aba917b602b0090075cc03d63a938c17835ea94f511a0d4db18c7c92b257005dd95fd3c9805b0a0a1f38b1c0177d1359e220c5d8afdd09ef084e063f999749e3f9b97b7308171f7df2ad9dedac1371a68a47d418424e7e8975f1f30c15af4103db1b3062e839e1bceffe076d9d37655ccf6b553a484dc2584c36ac3dec00e795fe58f8276bcc0e6e9cf482dac43698e7f370d8b7c0980876c8dc93f572b9d9a7c56f6e6aab239c5225568087446249e0d4083e014202326942e36259210b3701cf5bfa98c49a7fa30c42008550069147e056f08f5e1ecaf92decb65fefed67ed3419340d9897eacc5a8e645bd33d1b8eb00acc09ff0f142fd37179d36a6ce7daa68446acb58b495d2a9f0600fc56f018d8ff24e759e73d3c0c822658b115bbc9d058819dabba6ef138448c5eb512cd119dbb331b62aef4745f4d59ee79a1e1caed2445a374629c647cfd7f5a4d63669109cc848cc9a56c1a1bba113073232b5bbcaa7906ec37ffaabdcb2b00818b2d8f62472494094f3167936a98989bfc66b930f743b2e87e6f1fdf15cbd2897c9ae37b2040fe977152320fccee3485b4442918779816977c283788ab6a262cfbce7f67776ea1a70341f0d95c8bd00afd2f354979d37f0a1f30a505a83d2afa4d5cea01469fbd0773a1bd19a11f7f364efa276d1519dc14bdb88162088ad3de7d8a46bb992cbdb374de538a009f9f3dc88c87a1b1c1f74f59a38bf0a318a0d8055863aa3496f994011191cc13bf3d63beb91fdb082595315757fdd30213699003861b5d4c0348f47af6ca59218568fcdea91795e7c816595b224a71c36d67fdad3753a5f9c76c4fa973e2f0c46cbfcc22429e8c91be047fb9cafcd89febdf75a996ac21357c2741a197a15b75fdfb9375d3b1b959db3e580ebd04bcc89a11d1c85919b764cafb3ae77e5980990482c8cd5c7fbc1f25f0cc7b0ddd9c2c2cfcde200f90a7cc97f9c0d4bf0e7ee24fc401365fb27b703610345a10b74464d7b31adccdd988052e53aa19f895f51105a3cf4cccac1b8c478dc477342a95d85982ac1280bb3fc54a948824793554be3709cbe68e23377cef3283fcb80072b4b1159936d891fff9798e951f7d290e7047b718fdd487389afef787710907402f3605604de64c08c46fd90834e921ca29432b44c3db7363975de3840e8d0781d5eb958f71a842ab775a755d527921c157b405cf7c54bdd04607c3edf919f53ad58695ed82cbc83a86bdb820d2192a56587a66bb96cf9b4ef1a3d4b8ee11b7bdfde4141a43cc6e1f9cdcc04ccba61d8e3e2feb65a8d422a6be710e2603ae9d87d8b4317387b597feec62cab736a5018cd73ab35fa5f029478024571bd5213d095ce37f0557a335da8e1ce3f2ee1f5f9d25f031f1ccc0dec10caefb6870bc9930efe233dcbc1b665f2b2b6f74f7fa12d24912e43040251a88f586ae24c6372b50a8690fcab275c30d23d26c037d4cf15999cf5ceb5a5b3ba37af7b8deae33ae048cbbf6c5741d6fdf4a0bd15a897b6e4e9d559143ffc883171fe5de89a5b1d3b05f104630c8a75e92b272cf7a808497b4e70c91ad31334bf6ee9b05323d3a02cfe6d86a6d12eb1e9c791383807ecd7963dc129d149df4f2a92bf0bdc1d3d81c8b775d6abd837c54b931bba922793e8c79890e0fa037a53dd55025134be80a6fd282748ced486a2b7b7acb1f6e0e6c6f918fdc35e0c55466813e040124b189f2bb54305b3175b1c014d347f0b089f2d823e1dfcd1e4595066be2a829d2f667937dc8dd21bc23e948a2750f545272085fac0cde9a4db4b5e53bb6111ff0a4be61239dee5a19edbfd06e77614578f5838e2d623d64da4a88e9825dad7e6036a7ff82a793794a3fb792219d68b9ad9d9bb4ac9f858aea6a87561fe1588736633444a4a75c31668d4018543318de17e9eb6dd54318e49e5bb193cb1b95fce6b60369ff9e0692d6af188bdd584e7c13228e6c4ca7bb48b4f26ee5f2b0bfdbd0b6faade717fa83ff2619ff27932ca4cbc107c94e1288129f5fcb5ca1c0d26eff993f58b2ef867e2989f16be9285f96ab2c7940667c65f272ca1400388974cccaf80b31c3a4cd477c809b83a6fd18b95bc90258242ba348c4c79f69c78ee078d21357993083cef9ea5fb7d031f829a8f14783f9a835d309dd78fa30fab151737e0b9aa176fc3d12d468599b481c446c2a408920ea25f3a995900d78f03053f3cdfeb50371f4760c04075dc1045664c42de59eab9843faee60a068dac769f77b8a24c78d56be2b9b1f9d5ff9958d3e7283628907c5494612988296a5de75af57fc7720977c043cffa7503289c5cb0ab2121f332ee435a87788b7718f687622e234b01688c64584e9a983257fc178c7861fa594c15efd13fafc9713badfc84b0028472512b6e7b3690cf66a6d9b4287131ef6edd30d982c0dc4198e4cb5523381a3d87df66e20e3d926ab4d458500498a3501c62c731142dcaac59c92440d2c321bbb977910e2c237a993a535f353642dc8a6edc1ab8f382e9ece5e96af8e9f24d3eeb039a53e578d2f4efb243be0147b1ff5b3a351564b1b585fabe226609ab4b6686a8ec9a69636758d4c1341f1af880097e7518178fb740ffecd222d19a0b57134d10b9a9d337733c3d92071744c44dfd5b307af34c8f16c95f79ee37c43fe554724fe7b67120007f433cefef98bbb9904912c967355f95e9cf57d3026f65d78c551479fb04ca3fbce3a816e1da6799479af2b570cf7903c180e971f1cc59d08bb47aad103eb43ce2116c5c76a6e2851b775afb34a32ef2e515d0feb63c99e3bab1472db35d0c8e9a27f8a345e4c3e1a62c65bae1ca575f3c69e65406d4d409fec70a754d38d2fde04a91feeaba7cce33818166d1e88915cf1b63f6b88afe8eac176a34878970cff7ab5e07fc8856733db85e8d31415cbdcb1fedb740f246668c6bbff6e300c11a71be66171cd2240070ddd48e8e82426c9bd1d1fb0547cc23c910b9e8b6f4532cdb24d046064caea180abb1c6f6c7d81b26f3a01eb8550cd51637e83f4cbf78b2a98a0587b28d1cffeb0d1b0ee2f0f739669874e2f8191578831fea5b8f07e133a83d1f68b98d8d7b2e69f76117812e15713cff7fffe21bae67fca67d49a5f6bf5bdae841b574fd4f3f83da9e78a5cf81181587bdfd9c1a3fe1feed24d569b23441406345861f16e0063abfc61c7b0acbf546af50f4d81b05b4a5497023ea09cbbe3d565bdd943ea05df7c1a78dc432f786c8b20fbf537576bcced29389540ac4d03e54e036fc589ee63fa12875255fedd478f74b34ec3fa35174644f285c91e4a5843073126fd223a38db1d311c54404995b2d86ad7a308cbc552bff6201f7a9e6af4a933495b916ec7af3ee405ec810318de5bca08fccc3633a8463977e511c038645b3bfd1930867fde069b807c235567068a297d48c1f98ced4f78","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
