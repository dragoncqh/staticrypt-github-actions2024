<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3e165124f55c1a74db748b5e4f2d0da4eeba3bd06920046ed18ccb51ca032869777ed47486eb52515db630f4ab437419fd0f9f40ee284d6f6f08b708f9fe28450f7e3d4319bb9ab78391995dd3e955e8c94931fca66ced4e610a8d0641bf9164853f990fc3732affce4535f4425a2e217c23f8376a3fa023f354675d2054325d232dda72e7daffccca3da3152b44dffbcabd496d5978b4a3e5d0ca4a36eb4d4ee24296379ffa691f23e06b704b9d0e8bd14d62478170904569765f9ff5007b767a56f36549e47b02823d1bf24a2e9028e79bf6ef3656bebfd1c32ce7ea6650083d83cbb2115dce75cf7657b5d4781625a2c1a00b6cb1a1975c54ffc0e272a21f95753a63b9bc16ff0910bcebe463f51c51e5c6a64c483e4e5f24eb0d784ea01fe91a46419132c88ec5009106c60c15539cb7f13a56f091a2c085524a231414e2036f48b39c46991aec04823ba429e1dcc5e32e2ae42afd198a9ac39b6f115e3a5979b4dcf1a944fe7bc8e1a9fdf0172cbe6a9eb9c2c251aaf58827e9add4b65f7a15a0671d50f7b4beeb3e84215bfaaa72fd8d3fe64d465d3aa3003a9b33ffed92a2a57f1d456522110182ba5311129d342ad42e52614e90256d12a50f9a4173dd6f5538aa351fce6631bfcc789360a666856e00496ddf765f6ea48d8048963f0d9ed58425bc7188fc746e6316bd2a9aba63d8d70be231d6e4631d3de570003085538c84b50f10b86dd6e45e1a8d5daf40c017fbbd726cc95ec67e8e834bbfe8a116dcbab65201b27611fa84bae331caddab5d1b437cead7ab15169ff9716144c8dc385c77f1c3af647df13a3a0c129f8ae5e8937bafa0477e769c2a906e4acdce4faf4a640920122f7a5bdf0f2663adb1c6006bc7876fedfb22103dc8908b18edbbfa228d0bfcbe4433cc77830156680bb9c44a789460f8aad92cf5a1aadeaed1d9434622b8a78dcde93ab38712fac5d2bb750f20c137d6ee4d7a30a9e6496495454d5df5b903c6172afbdb66778342ffadd2ce4b4c15a579ebc6624cf216f423ca57148f5de9a11f28d9135a69890e96865666b12385f73af14432b8d907b9e1c253f677bc23b1b4b98fabbfe8c97d0f3e1b07b8f20fa3ab193a6d9841fc6016f83299b4ba88fc34afce705189634fae4b0668d79e503dcc9ad4d94210a55fa258d8d19ad59c01b7ace542a5f3a42af8dc8e53b0047e5323d09454e67e99a94059d3bb9913c10e86dd2fd81f6bc7c1b7bc62c95ab11b583d81e8d29224577cc199984513bdcf47fbfc116eace0904b17c30dbb15a2f6a3298ae823799d1835cc759a03f21a8afc982d178fd90550b3f803df95de82c4e2b258bf41fc6a6aa1bf0563aca6ad1251f133397c4890d392f56f02aed57986a2836780f5fae5dc573d27eb446364285bc112b5b1d8290a7da3a1b390ba6720368bfda395d45677006219b032b9aaff13fad830681ee4650eea71f9fe5096ea138d87438ca12834f24f779aad07705acdcba128136178cbeaab2942bcb7b2d12047bfce27dee1dfb6ec27d2c6f2003bf3066aae61b306729c4250487d8c4181c13dd3b89dccdcb92250371a2d94d41e68ff11f84078ffc8f546efcc3820b447a1a0610dfa4d4fe23c570096ba83e31bb4be2d5bd2d62e32073b217777d72402ce3b1a9ccb0df898dca2c1db1b5a7146c783bc1bf3910a418f72cb72557a3ea62f99c491769b8e5ccd6f02cb483fa32ca28ae11af193f33fed1e860a9a2c60ae41eb05dbcbb2a06e12599b3c827d50b0ba748d09d90f9cc5375f3cab5d69ff3f5311bc6ef67f83066e2a800bf12689c0b5026e6498da2261ec44cf479cc6bd71ad7bfa1b50932a616a058979002a03471f7147d0af0cceac6c6357888b2f8a69f0999a22f9bb7ae0102f8bff7d6615a73fa029b71be2c5ce26a2b2c1449883fc2eecca87d593e9f5f7dd9c2d93b71b60520a53bbc73825ebee6a29744f6f14abdf4f8225465b9504ce8e9ecfc273dea3f1f1f52d18b94a91acc26e99185de535b13903c2cbeb8aaa869d4d9211f8cd1e1afe66623cb3fe14670ef45c4da4b9de646bb5c81927c97049fccb52c383a4eede4aa7e30e793b069fe4c62b0f085157d3516e66d7cbf5f1db1f431342139613ed51c608848eec3ef3fcfbd5308b47fad5b061f0cef1cea72f82812280dc588a34ec04c74ddb9d88516041a64bfb811995fb7221f30236c6da30cdb1f9803da0fd2451057e6e2efae15239da365df78e16418bda52456e4d32ecf8b9f3e03c107124baed5a14fe0ec405b9282e851398005ea287fd3e5f8306c2c5dfaa6296f3cb1223a03aa89c964c945fc98fc62fc2ff1bbdab1476786b1e9e59a860477debd62003c922fa9f7eefdadbc1a479711e8271e553995a07712318fab8f25f0e943b215ba660240e72ed038fbc7544e6ffbff6976ffbbcebf94b3c9af95cf44fe46d86c845b4372df18da35bef58dac550a7b4267662d1de55a2c9d7b01b536565ff16517fced82bd5bcd7ea03219e19b9d468806ed52103ed1b366f450a27d6eb3f401d3c2dab7b86039b9f8e668e0446f3fda1292423c2b341b60a449a4406a05ddb2aba9352a36fe36c3710b826ea3db734982864d6cb9507fd5331924d5f2201099c2f86dd76ad8ded4bc11dc65d1c0d475e0dee9186fd7d35fe904dce2f80b3450dc20583388cda2542b7c35f1413344d88e58e27cfc496a7af006c99b2211665056fc7b85c00e28feb766799874228c9ead42db000af908349eadc5ae8f5d615afd810abb7b5a6c8ffd21eb97d428003c0b9659a94df2de2648d14d285afd67b2f6045523fdd734614ab8a6d2ed3b19843e0ab75aeec13bca3e3d3d2dee067ccd77b7e7964645cda16bbab58ccd35fb43050202eda1e3d07ae4091e8ab70c220e64b213a05a751857a3856f487050321135f7f8371fb4bffc857cdd4b55c65733c34dd65ce1505558dded86027d6d478529bc8169549a610327efdc3cf44cd6d6853bc3d34655b283ceec311f657b4c7d8d23a637f1c23a7a36f74c8a15ac5b2ea34e91f8966bbd9762d11ee278b25bd3741ab39ccee6ccba1fdde9338b74209931ed48a72e57f38bf85f49272d95f3827b16aa26532faacec1ebe212a5b3072ab5f06d9257e33c51897f8ff6de220f96a985cdc2b43b40a9bc7cc1beb6ace44d300752a6273e0e6db305468baf9e68e05f427006ed3a5cfc0f5c5211c786858e8d6289e4cd80579193f45fdeb30af2ddafbb18d3a75b00c30ea4c2aedb646653dabe2dc599e4355dad312a2436f3c6d8e2dc676dcfbf8e8b3f28d0eb80fd08d1f230199e02c2390f07f40415c47cb1a831bd41b23852e80d79bc365bddd864e095ef62c01f599320c505e304eab4b88c82f1ad7d6733532a1bf3d280a17b6a36627aa91ef9c46849df6d28ecdacd1f1b7919736aba5d05aaaee6cac20f39d5de0b66d76760aee3e1793281afa78ee94e31564dccc6aad877f8f3b67e8dd4a4cea756cd227126b4c8c63acd50e31894df2dd25fd78bd86960d885fbe717c60cbc5f8163cd150b4f90063743b306109609e435224c9ede9bd44509e77801a8e66ab730c0f7dfc34b3e73891f926ae84f3bc67a3e8cb1b12a6bc9248d6584ecbf442ed88714827a9819595df811b0f29eebfaf97bd3895de38b42caea22fb69cca504f1c122ef4dc6649feb38c63d6e6e175a65351554370d8026acc722652efcfa80ef09a3d5b16e771546e8c9d784b7188cc9354610c485c3b1885fa1b25c61f231897be2c0f362a45b2c0b96c26177690f955545587f3397520f99adf96b365312b48471e91a8b784623b4006ead5a90e903ec39b59e3f5b3c9c0ea3959285ad1729b5e44556e1f669d9be1e2db260252f79550be7bfe3430f85953ffdc64f65afc4d6ef095659f7fd763a4d82121b072557e38a163bd370b097e033f3ae6fdd0fa30a1000da3ef4168c9d8a646ed11ec1caf56c637f6c60f4371d95742d4de820cb8cdfdddcb009fc06107c552b91fe80784041d89106e64ebb19edb4344f39d5cfaec9e131ed611aea5ede7575eb8158197b82c8d4be7d0e45b08634f620ceda35f557d3e2b3137ba450759a290f440ae9a653953ec4c368f6555a682eb6f413dd09f340e2b2f2366c0176ee84e68e60d3eee1186bb2b734df80936b979ffc7acbdd12a7eafa2fc08151cc9cb59d3a2bc99387f0fa55d53ad6738c85b982220672b46aa769dc7afaca31a381c23a940addf66da197ca2c62c38d30bf3f281b8fd1c86ee614a7e85f1562e127426fc88cfc0115e63d9364fc389d476f5af9a206ae1642aff0e484a6c13248aa93c46aba5fd37e00de0196852533a50e5d52ca8056d3c8fe00572c7f2eeb4e1791dbb8d50c617db9cdc3374d15daac56bdc1c663fa773407ab8c99b5b6e638ab5605329e5899ade4b03011cec080350c4b586f5ac957e7b413ab406e021ee26369f497c2218862d677eb015f33e19d66c3a569fd0624c92053e1c2e4602d96e3b7027a586f82025fe0a8c6f8594c7a71b0a4d31d8d6b80af97a54ce27a9576d1f5b42d33ac31ec93b56f1fc3035e41a108343ade09e97823150c5d9ed20bdb259555df0c09623aa4af720237ccb71ca922586d07837a069b6e4314ac4892938b1c4c00b536ebbabb740e96fca278d858da01ed20bd8c3b2281483fa96d9ac72a8d101bcd9f37e6cd18b76408227b0eb146f7afa48290acac4558c7b3ae9314ff6181fa114b7b93f4f21a695fb2da86cb10b5c23242adc009de9b8531304414b7dc0546ee3ecfa070a68bd25e8e48848aa00592005eac5f28bb7b1c3ad540b0b66425d2220afc3d190802c452ee91224f71dd6f1cefdde3a3c3f8e517d0a9551f3c2cf86c79777fc1a075643c9d13ed292dd9a97006dbdf674d751325e171b0ab5e818c6b47ac2284c00e30341c21734d35955d354ede3c7004bdc6a5ed23110170e00ebd3faac7a48ac5c43449209d3845db5dcc8bc1b1e19ee8973fd1a5d0c807a059f8624e9920196bdbf478b390e8cac46892a693e4b9d1ca4ba95d6775de3fcb1e159ec5d4b3aae5a08e79540885257fabf6d774dbfa9678203580976445ed45551ffb2798edabcf21b71e1fd6edf9b63ff28d4781e9260a377e983e901ba9e96a5c241604f292468b84a2024aadb6e911325f8a8e8f59e2d2c0389ff755a80c7d48f5dafaa189a1640d5becf107d45c044723ef6a38e1a5af8f3d9cb126c18fcf2f683b8a4547ba17e4526b008d0b35750548983b3ee5cfd857886802184055db6c663a2b3ef1903d55664538ab822eb2dfc0290050e19612e97a5990190435b056a008e32ed4fa89684af2217bed264e85b1f97ced3e9aca8d21e550198069b8b3c68a48fc17470d64960683aabcc31b4814574b3ec7049afdc12bcebc998b573e1eff5888e906631e2877f49ca06649c3495e884edca3c99a24ce21a11ec779042616dcfa933b53d332c7664a72eff8bd61942ba8323b1d3309f9312402a934aa5ff24eadaf3ae648e5b0c4033e7eaff1c2fbc5bc27dd8b5643b391cb0c1276182fee95a25f8aecef708a15d0e7bb3f11343b063f02e979c6f352dc483c222544e38ce3c067011b125536db00801282695c4b8c3a2cf3804bbc2193e9d8e49f9cad339220f9a67371394ded8df51ac2aca45f38630d757d2a55cac5e0d7eb07705dbca9d0d7532decbc1564a96d4b2b0dc8c5f3b6acba0ac1721160d13fd3ba59985dd4f78b9af95c009aff1f653f0b59fc0e5aec09ed47d5781b6682074c0a0593a12648900ac142d7b0987cfdb70d1f62106feba20dcd5aa62798789645780679a99d3a4fda834a10928d89b3a4f4ac0729a2503485ebfb2b43fe0dd172a6f6f338ed489647728e9769edd84f6ea2989035d11fc52a7d4df64a3fd1c67393ade19140fcbd24c5d5a68a4b0ddff7031abd6ddb50049d8b456f1fa6ab5fae48d3fbf2b158e7404090357c5f1c55d658597fd5d2999d2c6df87101ca9eca522910194fd616de5b400cc8818e690d86eb58511a20057c622490ace256bc94ab73a4c950aba2879c45e40f6974b717c0ff0bd58758016832a02be7f2248770d5a1150cbec55dd935497c8d84ccbd41f2caae20773aa568e5882a54920b5e683b25827c8b95968aeaf3a3a42359ac576df64807332e85ca60045244be708326143d5a65633661bfd5c106a02c6a1f63942f51421b2db520dc69e9a34aa05e1315d72d608d07c69915f4d283b8e19f279d81bdddbdcd0cc77362dd1c99095b8aefaaa628f94dbdf9e0981720fbc33487b60a1447dda95b420493148f61cce057ad7246eac68688ffa08f3c0ab68114307390aa6769740b00583e4d043408f760d6e840087f1c79404cc50e4264769c361e3022b93851e44b3cd9b76367815e14c406e0b71ab8d15ce693c5c8ea0359406a72152f45e2a2a902f226365d61ef522d6698d9873cc1937e5ea474da3a2af1075e2d5328ea3099d85e80880a5f1e3c39771f2c503d87666d5b6406e0944bf848a2bb06ada63ad1c63be0fd5ff6a099ebf2265747e9aa730ad5eac5020763e645bd990c82b240149d01cd8930fd97ff2173564b743c6f1a3526a445b46154310faa8065e8422d270847484634807c184521e6e465ec2639d8be7e0e2a8bba3d744dfc754ffa60b3d0b3574f4cf1b50d6f8650ec41c922a42e1b0588d5d558d6d37d92d08a84f42fe6da36f13b6fa0d17749bd3b094132af6af9fbb7c47ea2d795b11f18a8c87c5a7b26cc169c4fdc0f13532d6c306b88ce79526832d7d3b2c38dd734d82dabe41e0433da838868d6f65574f33b32f4e0e256561330c78ed2f8b5e8c42b5a7944cdc1c5796f7408dcca6e170965a598f6f22954abc7aca340f6a531595fb708164cfc1a2b9fd83b35036eac96bed14408c84e8bf5b41610d695058ec2fcb98d49487d85f1854242bae628136aeea6439fbdd4c7d085a93b2bef9edd7dd0167c89fd4ccb14bd9c78531be4d1302052661c4f67d19c4ace5ca3284647f48a8b5615496320dd91f3c509f02b4481187ed4e027efaf62041cf9de510fa00d4975659d9e2643400d2b3598f0cb6b8c28e1d29d7cabefa5b2aac33ae63e7b7c1ad979e0551b28527179d42ae782c5c8776bb80bc332b44965aeeff17ff0a4e8e469fa5c5dfa769dbe3004bac51d2504cf98dedc08ae8e42ddda6b9a46571fccd34c14fe733feb5d38f75e69fd72904933ca991a239c48d66612b764c0e1667b77add2577ac9aa0eeb5780876492327d505b915204de19d4edd83b81b37f708d80dcd65b845a61d0ee31d896edfb383d228fae3d9e6e9bb155d8081fd16160f2e63067775befe441c4af0f9fe6ec9e48f336804d80b266073136405869b980838eacaf3172c5f5be8be34ffe7905f782936ed7bc76ef367307283683f4c3b285b72653cc8f2956326cc458d3f89b9783567639f6db9829a9538a19d02e7eda2c2417622acf6c07ca3cf4ff77f53df0a49a79059f96aaca55a4af2ebd270253dc26badd3108db6c652c48c8d6e5642f2ca82586f9bc26244df6ebf5681f7de3d528d27a0889105c4331bc402566d21d01bab5b828836d50df6d31611a06c7dca8a9df0f1d328286f906f3bb13e2bcfe4a6dea9fe929b5d42ac1dd5bff66e4aae6295d673a1422990b37ee5662ecf7d8da91eae786b82933b20535bf23f1fedb94d6284a71fcf3662f2c959040cd52a1bc44ba1519e7aa0e6245fa046ee78918e8c10ff8c19e3153a5a1b41ee062a8394011a4be7a705725b4bc584d6577300376a6a19fff04ee53da813d8224952e8ddcc3a6bd410f1064c49967d33ea362ea5bf032f45e624b2bc80b6dffc485cb70fd06c8ce3fc36ec4fb3a8feb1190e9193cb478ee45bbc0def916014968d10f98b6c2e30115a5c8cb7f81100b9e90a9cf7066369f834faae14a6044ca41cee5f0a173fdc65751afe06c45f09decb2d02f62f279befaee746249600fc9b84efa10ff25d9da8e7ed5416ded456e36380817ba74dcf08f6e45ae7d02b37b6116efb02ea11ed7278fd3d5b171a2ce789080b1ce31b5b230db519a4484a8cfc7415c9fcbf0d6826e8a69a1fbeb1d893ba5ec220386b88dcbcf745f3898b85d290e674dc6e36152733577ea17f639adbb88f9b983b1adadd476b3d673acf8854352cb13e22b12595da9fddffcc2c36efd3b89690b1ab091349f47c6b02de7bc1edfa52011750ec21a1f82fd1bf288f7518e1daa697d2a688b822265d2b0323a33581073624fa491556afcf7aa69c3132c5076e54840be633293767be55f1f1ccf755899bed5bfcd52292ccfba98498ce6ddf48fd4fc5a235e2640f2b4619921e0b24ecd518a9fc8a8ee9453c4ab2bddd1bc090b9e0c97f09cd3a03393f21ea99532606be6ae8222d7ca9865ba95e254fb94a3e0796eee32a1ece8f8e427a4ae448d8e03ba23bd833395cc4023f65015729b78cca7de11226bbb24a31625ad5eef4415f50407e16412963d91d8f5f277ac2a0747c053a4ee34db2654113cd2127410dc8344b597802b958e6ee3e444979db9408a22454af6c751262b283d7f6a8dfceb030f3a6d73c85c8ae1b68f44b9d8b66a9263495a2af9f97d5fb582419506fd43af075b206cf325d227f6fa5a3e85a13baf363082840b8923afe547af71b460b08f7ac13f8c2b6e7a789ee352d723bd6d9c06f288d6bdecbcbad360bc65394bd3c9c9fdfcdd04cbf4dbe29b6175560c6cacb5d371e2c16aa5fd61624de7949e7b6879b109c847e07de837e86f75d38daaa60b5cc6fe0ddc31e5a609cf1b3deb2b36cc5a89be37377cc3b89a1bd8ecb82163f958c122e0a2905b545d992262dad9cdaa36f6218d2fa18519d8e1e1edddd63b2cc9126e3c4b7d827e99c3e22e8787fbd1ec175b55273a01982f132b973084a666ea5019114c26c05c0c1be0884142f1cfeec4e8e1f655ceb9e210d19cb0dd8f2d1331513b0e693847fed5272d74558ba6eb8899563a3ba40095c3b19a52b72f00675c591002f2d68173b4f7d99686543cf3172d110a548e8a56398d31e6614d59ac1fbc9fd98d844731449bfaaf20ef9172092225e7185a536b75a78673d6e9347e19146f49b61184c49c5a80ac86eb30cbdccc992350193a42e5893a9ccadcfa15faa00e02ba2db97a55b1f04c37ec77e9650b76b5af65d4e4910803c1a47ca7b63c616d447f049d7fd35780d0b59fc9c7b12f448015c4aed85890108f37ee47eb60aeb730624524303e60df2f1e7590d127bfb198a2e6a4cff293b2805405d2d1e3152affd530edc8bc83c45a437825b7db8980094c0627028d9d93e4193c1362fe8d6a7b3373e60dd5b9fabb398f5416a788a30cb2bda12e151a3ef74ecd41652dc9cd4d15cda263c59c2086520ae262305388519b613d8ae522e6bb8649b593fedfaa9bb7ab663d0e6bbf558b13a6f3ceaf2cdfc27623d65b8ae8027bfd5da085de8ddd541fdd3d57d2bd9045912650fef80710f6343ad533fb7a76d21e9a42598e8d378f98d2637c8ff0a3bcdfff86519cf21612051d5c3e266b0d27d0cbd7724fa43aef4883cf9487f8087175e0081c48119544ab120b4489dc0c7f54a67de267a898a17e9a27716acd5aac6556b049735290d5f8913a60fb97638c365c3e364e51cc3b2cfd947e870b2b3aa3b065cd366d676aa6d17d07df1e478f495e38385349cb81714a99b4b315d24635d17f3ac35372ba2f065cb17086a3011fea38e7541995d6326dd02195848541f860f82352856394677432258605d2cdc86f3a00828424e071b97bdd4567f103b91117e8494049d4564ce5ffc94a26da385aad8058c0a8336efc0617031aefe4973c6f13a7106bec19b7bc70fca1e16fd9cd42b7df1e9bf5165d9e683d80ad667217dea1040966876ef6c695b3646bd4af7cb97d6a6422020d32d64621e8f184bd86328ca073efadec146458402d3df1ffbef421db25f2727d7379a5975f5c38abc96e47a58306742d604e5f9fadb53986ff9e462bc61ec0a305b81e66183ff8b3fec9c455e45dc1a81f43618e31bc522490d279724921e44b55c24721ed499479e43338d4faa45880bcf10f60e62179cd6a2a54eb5678c0b33c7885d2b03f2d91789e911e75b31f24bf66dcd749b86af2ffc25e121bbd8c0001bed097612195e03a80774c13c4ab118fab1c8b863a4c7d9bef1182c9ecf9b071280bbeda71e38b63d655fa551cc4af1f3c73818407a1c6f9140603be13524ff3c16214d0677b333f4e25c65b8fa04fdb86a09e850c2776b48dbf7c54e971cabaee23a743a491c0f3a7b22b75846b429c82b953c79e5bb19f990016d06d46387b3f19ec8c94babc15265e285e8d783c74bda7f366a8ed0122a9f45056228f3ff0af5c179104a6b56e982aa54e71853511a81ec149fcd945f95404d8e7e4a41856e3b811e3d7f6344494a96cee2c935c193b5c46907ee744ee641a7e146757660a64291ff954dbcbe32d6e019f161b4f983bc83867c0d0d3e243b39850773b5731f32db8e307a2690e82fb1b2db69ca6b93d0f4de226753b5b2033eda2e061262dd3ef27f28312da290f2f2cc20acf4439c5dc72bcbbfbf6024145cf1be9669fd370f38ce7015e661b3bb317f86d32b0128d35cf82b9dbb35f8e43abbed79c7e43342dd92efbcebc819740943c18457ece78b6b658c0283d68ee167317fa4aa88589fe8983c08263d4acd69baeb697e0134c2b289e93a7386a9ebfe2533eeb84dfab952d083fcb657f978bc7e65668c2e57d56c0834e9b27eefa2fce93acdf4d097e58a07d315cf18ae995c4bf8781564f6f1552e2c5e78b3e77074aa973b561f076b65092cf5332d754e157db3e83db6429b6561627eba4033ce035490899cd3caf1f735c0a35bc22fa8adc2d0ad3c0dfc46a41b433f666a1188e3cc38e0946e58d2703d2b01026544f6834b2f45384c5ef2360a13bac400a23c0f30dc44fddea62d9d6164e9095f1e3d614e0a0e9815196084c448344b588c847bd86f8367eedb02f2d803b8107923fdf88b2bf2358d3c3e0356edc4f863efde7639052abaa8dd28cef8761681371d42043fc6e91323d296c38d8270bfb298d0955a51ed89b99775c2b6b175c8b1ffdecb235f80f866117784fb1e211ed9d75e19a2b65880bf35f6d4f77188bd5dfa1ab94eec98cfedea372ca7117a44805e39bcb09ebe5baf05fee486e6c5b6333f4872061f061f546e04ff8434c9fdba2ce492e2ea7966302af542d30b69f346fd8bd806c88fb9f4f3ccb575ffd2c9170c2a4af86631a74a5b4fa0f3e8a6d5d46b33285ff6f22468070725e39431c7ac6f4f1893b761ec2d83365f50c9fcafa1b96d18b5641611e36ac595f22eaf27804e38ee2057dde612021f050bded156944e724f0f4566b566a166403896b6eb341ad2fa809afd65fc93262b808c6962edeb6e11e038c642d0808bb2265d9a4c991f2e0960801520b0b15dc11815bf78f75746816f1cc0ab8e1bdbbb4f3922be1cdb68c6f3f155aa11d6da6ae742cc575f17147732a5eee9977a9d8e83d94fcdfc70f5040005d4854c526e979be68418e9a6f5333a8174893751e4df65933a7315b12bfcc0d4c04ea05b270345e1987cfc4c26c4e42aa2e023a702531adf761fa0fd6eac2fd91fe90ab624fc8caabe91d172f052d3690e4530c35060507de6e7ced22c936eef1d26ab67ee9026374974a7a21e550b9883bee1153d34339831702c5dc5746677d9d362c55dd1c0495c2900a53894d66582ab39b00412b8898d35fd0a5a6521b106bada7bd878a95221682b2eafb640ca6928d5c0d1da6f1f0415bc1f4a615685a245f2442443d5fc69c05c9e79ff51be6311395b158e0f0b033386aa2672db845323a5bacd4eebd176dc0e446c9a7a5865c8d29d270e5f85baac7d79e453b70ba4cf573fd7a5b64ab1768cbc745488e77d3fd8829c2afa1f3b860bc07889383b25975c69ed28539dfe14e8343513ca5f9c0346541cae38f55a09afd4e69ac1b99dae87144149a3c933ab5e1243cf4b4fb1d7adf0f5cf319f75552db9644b3d4c07875d9d816c10c7952a2cf9a81937cdbe04fe82664c85ccdd683cd3efe7ac6a3171595daab47a3ba9b20793bec6924cf9248ab56544ee36bdc6570a6abe9339f64d418fc487a227e1f38bf74aa468a1b8434357cdf3cc48a46cebaf6b75f20b9092c44fab18910c50f9a46e211471ac462efa8675594a04621437371a25d2b75f63c877aeed57264ce958153cd153bddefeb8a879b643e6abd4365c75a8de0e8bcca1ba8012a0b74cfcc9053ce72b84f4f84b3cc22ac2df390730d2a88a8691a76e65bd3ea5395035f32c7584789ffc1feb3dffa050ca32fc2c548a5f67aeb258e40e28fc7ccf10f9806a31f60188247c83317c2ccb2c0d279e75373ca3932d97bb0f6f5299578afbfa5462f53de8799f1329d879e1ab3327bda45a66097fae4def937694558073d69e65018728ce464a641ee947f35a9213e7f71b31a7dfd19effa2d44b1d442c367d70025f26f91b8e37d457b0c864f5b58a4e9072628b19b3481795c38651a8a9852d3f23bfb1d0ba4329647c9eeff42c5061237ca4da918e0a9abfac531f884b89e05993e7cd750e1e575c2c1b99d09691e157cdb9f509d49a284db7a6431ceb5acd881a0eccd2a1ca3d6362cdd48a3741e7c263e3440c8f1d357720badeffb377b9b09190d0ae4a5ff2f80fa2f7d9f6018d9518bee5791c061f78918e8029d3342c461402c6599c09e8ec7a98d57e617a04161c737a8662bbc825a2284c691a55f84082613a0fe5784dda8d5d2ea083ba2ff85343bbbfe67ca62e18829685d40a8063ee690ea43ad01d17e34bd7fc5d9bf47e5be64ac63b54cb093dc678dc602e4a49dac2aafcb41d7e9ecd7fb381016d4f461b4624dad20ac839eae7da250f3dc756fbf6cd3554f4a7edacbef53fe50db605387aedaa07f614fdeef5ca099c503eaa8f53b8d528c483be0656e2d0a9806533c655ff6451ead67f8f11302850930456bedce31e736ffae6c723314591243134fe94bfa0fc6314db482333e3ec9e036029c17ab044f4bc5f937a239d4049784b2dffa0fa7e92c35b31876d0bc0735ea285927d24ba4f6b09c5ba56615367a0cb193f4dce76a8735d0fdfe4fe82472e184bb2ce77f4c12f7fedad18d32f2df8d424e4bab4e3bc933d2f026beb03f263a9e1e8026de235f4936823864c671e8856a64b9f05eb58fd2375bf12cdeaa6341de2ae3370ceb93f360345a9c60f833300b2e248eafa91e52088f33c4fbde4f56cfa0493dac5927697a387d8d48f4a67bdd110ec327e025797c1036fc5207a9861593437bbef50e217ba782ace3765ad40c3c084887f415399254ef01ca7c7bc6cf911fb7827496252a712845dfe9a7d0f92257032b0499d91d0b69e11650a50986ab566e9a33b4867857b9975e25c2cf6e0dbba44234772b2bc80c8593842b1f04b954738d6d47da4e30ec640d97db4d84b1f96b15dd2d6cef7534cccdffdad47835ce839359058a84b2e6faa45179e5cf4de98df63ecee241f87def38138b5d46c14b214f51051a0895794a9ac2b912c853825770544b2c06906da570d9169fc743055ac69cbadfb4839b07a50c99589dd8ee770d91f5bc116b2bb2aa372e8a611b05783e0161f31836012dafe38d40b3b5cbc8d8355306952cdbbe6413e4c9e84bba092306d86e4ac0b1844bb2ca2370c2b09cfbdd7e7063d05541e8679ebfa4ff3fff14569d5aafad113ba61914f159f71e34b4382daac2444761c034518a202f10ca5f685d32340b80d47698376e65e1a7bcd372c6b119907bb099ea9ba93bdc29919efae0a0c19a10a21d6fd2273b4a8226deeb0eedb5b93c200585dc66bd5af7653b489cabb3d73ecfc495943a6e885bc4c4e47d8a0db7815e0acbeb79539abf42f733c4df45ce21af9e2a3af03f805240b5008fa740bd0756e71130a8818b376a718f1610a8a8da741ef4d2d845115cfd02fce6022a44e99bad9178103cbb8cea31fb79452699054e29f716b498cf46421825c5dc1a0e0ce04b82ab1a8bbb7e32eab59ab0ed227f811d23f38b5450c52c7cda7534264a44637aa2b4f29ded140331deb560ca3f8737be66d8191944b08009b0635432dc756a35c2dc7b571cf6ea4d7e23866fff9da2e0d0095285a636551a788312783e20d6951476e3317bd5c8ad951e697237c50d067b372a80bce55e5ee95b3804025e09081215c8240fa8731191bf47fa79529fa44b18e634caf80941b5ba7bd0db14c1f0e4439056cca8010b9359196713e137ce16a2de3cc7a07427c9962cf5496069179c395dc6d40f5335ce0fd94fee72eb9be9038c213ec58b66bd2c8111deab2edb6c82129ddb36871c920d362cd50fd62df5811a401edccdb9191f02df7f669acfad761c8e385e3c0a9624aa34563d1bd6e2b648afe6ba48c2881fa54f107e0ddd19704dcb5d81914b141e24a2cb859b4c35669610b7d0d99580e93647b4b1e77651a6406383451edf82820857f48031dc37e429753a86ffb35f6cfdbcdbc1c2d5db828771015bed91e97701b6b6e62a704da666b9acc3c79982983dff3823e47f17c5feddb336973873a97d04ae91e5e696b12a698b966a748847c4683e7514bb2cc6f9ce49592be7961329044f5e510cc22ed8db73d76ab2bea62796e38e753c793ffcc578b19c35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
