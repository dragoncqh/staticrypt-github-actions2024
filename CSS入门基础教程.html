<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a647369b9ccc060def2d779f8806eb24e9ba15771cdb54b63e1c6f002b5ea0931d6f3ede2837c27bb777c0067fb9e1abbc293e43fee2f7f038b4408f409f8b3c46118f4163d0fed799f774cebca2ccd510d441fffe6fa6eab0d1208118c168e6291c17f162aff97d53518263ee73a1b4936a70aa50491c56bad2a3bee2dc874a74b717a0bd217c20fd1301dcad0990a5fe235fd79e744781a8650bae0d67006df0c918d409aa6161ddc09e5d254ac86406cd668bdbeba9da8e6e3151eb1b105a6f9afe42c0dffdcd0471d80d79c73f55d371dd0147bf9461233d03fb268f878206b9edf05bd034b73f0fb47c1ec15962b688e42372b19d7a56d0693bdfc3499c1e99d51866e42f65bfee67270ebf68788cb1d02f36cb1ba8224d0067edc36e69bbd8c62417a9b69f938323fcc8526ee9e076c618520dcd4c25f254d448fae8f4ea3dcb2b8390c57ac5fe4ca73e956b5979682fd4b2b441be3d3d1161628340abb8371c624aadb6817fd5bee42acbf7e8d09f04b23a934f72e5590564778df1377abacbd0cbd3188987bfb3f648def43e9b790fe28060c1dff0a0245b532f08b509a3c1df5f4477973e92fcfc4192346a84eae74d64ee0212dc88b56ea7fd8d5c94c1315979e48e4762bda75f92bbc392b6c4f6faa97f54cc2c42cec1aa80d55d121914fc30b3e4f1c1de07fdc9a6a2644b568e49d8b09bda7746d395689c94ddf81f233aafbe9b2e94af7df7a5f124cfe79a035d7d7351a129b0e54d5222393a3883138afb33aa4c55bca1cd13e1e2527d4bf57cb41ce734ea9ab8e5b90053e244057d912a33851cfcc927d98b90ac3e3435eea3c8007f9e1729ada9367c94952f9efc79201f52a613fcbded523c3b0d7f883c4d6fa923d25fd85e62ca934b07c41d41bc002c45333f60ad2c1495c7a2705eea54d15262d73d4764b828b16c455fa01a23ff8f2cc0c64f6e27e8613292e0deee8eac92c3bb146040480a6786a2710b5a71aa8b557b81f83cb42c1ab195f87d1cee8d6dd3ad20fe0b7c1062eae38ea12312e78e58c4b2ac6a61c6fabbbe07838015accdc5f3d67c200d94d67481f667463fb09a9e7b7a68109800dffbdb7e323d732e12371478639ce0bc3fa6c24b8a7367f4a7564c01ae0b6f832b92970a26d7ed855d70aa41aa3a3615f66df0a7f74d67b510a89245c3418c4de54a2f419aa95307777b3dd20e1274994d38a7d0d2008f5da6807cbc80e1f5a68745d1fea635ec1f910a0c087ec21542b71bcdb65006b1736d7b2d17d6a7bc9bae1a979e6f5b5e19d14601a485916f7bcfd88c0ad2e494a600a22099347b3a83e93e44c020e5bbbc7ef4d525f3cfc4ef00810b7422e25b36208e477febf08ed30595079cfe4193e3e0a0edc87aa9cf887adc6b5031847835fc8e74ca8849f7228ced4f7dd27250e6c60c78e0bf054a74d0bc2888249baabef3d3d38799b681a4afe079f302d81b28886fba55fcc29980ecd79f37e314beee24a18908b3b4f78cb076db5a587b945aaed1ee04bcbbb469c9f4105b704f4414943379f75873fb6c98a3870cdad65ae1045b376ad74341bb1767fbb14fe8c1bca711cb0325cee47377206a50f940cef1415fca7e49729b3f96e58a8cd871f0d557278eb75c60b2c78a9def135de33f6403445c67c8ce5841af7f8d531abc4a3dd137ca654a1b8ca24c38c793ffa70e784fb18e7fdcf45d43388da3e645b46edfe0533898cf4bede50723cea006b627fcbb2676878cc87ee7601cf3cb3678ec195171231dbb7fb28803529dc03c7fdf588ae76e5ac31c554030323d2cd2f240e51fed91f03859b0f72b9fd6dcad9727dcc85acae6fa3a6fb16d14494e3e327795c4dc41c88e3d9327d3c79d5b51ebc6ef7b9094781a8624eaae46b3ac2435995fbed884fd730f0190cda0e8f4095f57107183cb73537786c21e9cd034f2735b5f6aabe4cbd0bc73afe216896ecf73dd91ac122a880c9783e3a2df345d8f431949277ac13da641dcd9e83461b8e52432e2c3f02d5c56f9e48e83281cc0999c71cce9cea94ca3b5322b100ff1c4cdc9c34fc2bc71782f5d8177fac19001cc40e40b250c0078bef4f0352616159d682db23a6a87b1aec84b96015b0903529ed6d8c35a022800927875439e3efac1339e764d707dbd4b366e303aa7e8ed802896d3dc12ce754a70f4435d9aad444314b1546e8aedae033bc5f53583332277aaad1eb7b61e18609765fa5931420265db5c6bd107e08d35270e8334d8e858cede00d95e236309fc0479dcec36571400a8fd084c8c33dd5e05a96879fb9d4c51b3fe1b93a62537d5f87a65266b0c712acd99da52475f72487449ad74a3b13358510dcac807332e4a4e8f81d262c931db6e58ad04319c390abfe443dd5c5608e1cf8fd4f971663e9938ee64380e229e8c0345d0eb6534bf5a5d62b35544e55143d5450ab8bcb90b6cee0ac80c759fcff54c320561a6c390cf8fbdc32d61a8ab154430e67859ac3b56b808a752ef1cabe2024b2c6a19e8a9b30ade6a0a91c1aa2396a7258a0c3b77bc294294c8c1d43aa83a1c0c8e4f9b6d27cd2b93081aa145a95a3840ac715914b97ea5f002d5b2db995a046ca992178430c6e7fdf0925cfe5c70396dafd001288ab8d241f02432034be4645d6ee8d5bfac68f6516fd993af43cb8502d95ec2b27ff1fefb08b11490cfd9dfa6010f16ca6b8176873c981a7953cd3603f16724e7d70b8caf715dfc046950ce05d3572e083e5d5c4ef999992bc249ea0f430a2110843d97fd6a5ee527eabd8c9643373271cd36514f3e93798538155b4d0277b2692852e3b15e29bfeb08a6c176d8958d86ef31a1e0a1a2c987878e90c053d8ba885e98da6794e178eb5e3875e38803848820630bfa6670e6d8e543135914186346563c1cff6e2aee11c8cb22e7f337da3c90553f7f4414cc1f1f05de3406c6525c9c11c18db77775621232ff5745df655c1097d1a1a18d5378ed7454b5b927b0ad49832d4fbd070847fdbecfc10adaf5813e13e3609b94460ebe19f4d4a4c075d1f674ba9d17f89f09ff93827fddefa7029fb1a1b2fc07c28c17b9ef85d5c8532ba152dbf4d174d25d748442cf800ca1c6380694acfba0b976c3472214dd5da2b468935ad60bde8d2e99c3515679a8449d198ddbf7c2e0dfe8843a6b5b6da64bd8a4d83939cf505b4a3a5f79d1d285175655e294530cd4707c6cee527d0477a626e557aaaf96404c8bee22aba2d29ce6edeb85cf677e8a87d334a1dbf3efce1546f6e075b6a7802542251163610f2941412107ec24f2908e6f1f75c4986a04ed338f24fea53e786dae691cc97ccb58c9cdec43bdde60b8d68985d64a5328f59b0a650529134e8967b2dbc093b164a45c1c4ae363b413fe52f77ed3a75417465ab61ec66feb1b2baa89ad91a63f9b431da526f423276b1c8220e46d925c4b44f2c2486341de8e09cc817c98b4601c6a5ee43abeb8f14bd04e6def2bd63eec629aee8bcaeb44c6c9587566ff1ec39c4b9c8d61fe9a58a78be27b6f25448da80230c0435db83c6da25aa2c154cb7265c559e4f1e12fd069dd78c8f8e54e933536b86fa7fd621dee8647073b1fa7316d01b64ae374051fd22466be64ed94245ac122b3ffc0f0a33781b158c4cce66f2768394d846131504cdb59b40f6985303379de55501ee2e3cfd04a0ed49df531ec64bc13300696a6ac4aca8f8130e00b4c445d1b4ee3b0ab830e95772421f21caf85d47bc457abee6021e701d6033cd18b20a80d34060c5f88b00012dd3e1c2315ad68362e67ab7fffa8a5e1f845d4ec3bcb7f941283ed6e1c9e8f8af1e31ef36d5feb0a6519a9158d2c1fa14d83c6b431f78166a3b61f808993befe3d9707107e37fa82fb27b69a142926cedf54036f4b461f285d0fcf8f2db034f3310436726ef49a05c7c8692b4f285e930aa97efefecd6c80ea4c530e5223ca08ce00dc3e5f598bbc2e92d3658d779dfb507d7d32c833b726f6586130b128306b5ec3f08c56017115c8e77735c75012b52762855b35aea6642efca24299c6207113a8983e3c7d001e3e0a12bfbe6e5eb861d659efdd6d69864d4ec7980857493e93384f63ab3b8f068147c16d9090cc3ea48653f27dd74ba503c8d6aebb26ed63f902fce0f474b45b8f1dcc1be15cb295191906e34b83ca799fe35a96f1bf2ec5a9f2f0b585e9c4af67c21b5aa00810d282c3a3177c569e1ffa91a72992e1bcf3e08f1d02650b3451c2cf16d55840f5b41bcc08511f3a95f9178929114a5b3f414b886fd0fba65c7e5af55206bcfb7666b8c5377f21ffd20f07c91f0113f0de5ac85c6b38f972daa4bd0cd0713ee40b520c0eb5eb53f13ec985bcb6cdffe55108a600e48efdf796672178e6c86bf605c22d25012221dec8e2d72358e4de349ec398568f38ca985a477140dab26487250eca09c08aee1b4f7a58d6e1b7abede362640207618e68e23110299af385ab2ab0609bbfbf57bb30669566092b9520e816af9293929c693fecb3470c53cd7ec0779618853c06a35a7e22d7717b41f6cdb364253a66224990e61ac94005bbcc871721169d68d36c53639f9b559b27a2eb95f33b97f5adb8e0a2fa6b97745d28f3a2dd926fb5941c04f8234c5b4420b2d4a52aac7a527776bd4ffa9c864d3a23bbab4d2968cd2707f45dc5b697e78e604eb6d2fba25d2cf66d9e5a9dc1f462fc15dcb1d2dcd5f1d1764d3f5d4fdd74f1bcf26aab2038a45069b04977c74ac5dc890aa24b7d7ecb91162389874f72356975be6830272001f15dc6c623178837f58b04988130de0fc4e02b7a2f055a7e523caa0f20630ce86b37bc3f3d603b120a3de6ea2e1b9aa748d03edccf62aa3abd8f6621046f96fa224dcfb81b5c90ce67f2161e7c47369caecf7e2b15bfc72ca8ec6f9b4c1ade73c9cd6810939ae139bebb6cf1a70273ef9e04b2d3de4ea88f4da019012e5378142b87af43d97eba6524e57d0265a8096e31677ea88ebb1f2208fee5ab794e1d06f6e1a799f2860d41bcebe301865c5cd528e2d1e91fb74ce2feb039104e837790ba158b432e3e3222a9f1a64429ab0efc669f0b416ff7fb2e59a11b6c4e29618c4c4b9ce368f88f98aad4800f3377c6e479fab57951eda152153dc32bc937b430334f3b91d730fe53052497f19b6426cd89d5df43f731f1d716f241e0996088fcaf3fc294959755eb4f0d5ebc3c7db0c2076cc137ae7a5367fcfcec7bd2866b1ddeee2f912ef006e13022716c77d7a0bf86b363657e5b30cc01263f1c836f064131173a00241bd701e0967a95e108a6aad14bd2ea08fec7b7bd4ad17cb32da262b967b213aab3adb718867cc9d073daaffd2c96fc90342832b021a66266ce3635cd3c4b89daeaf8f34a44d36d3088f935a2408f54f9c7a747f3c8933bbcc26a5f69803c4fcdf31b0dd55ef21d4503df836a19c7fe824bf2dc08b3010484396a0f84eeb168263c59ebbda586e09288bf3e5d5079916baf268f77627d07e6d131abb5dc2575322b4f58102aeb23ed4c27d90a451fb378334845ceca4a33dbfc0c9bcb8c3b77118e3ab786ea92ec677d8ded5569dc3d33b9e931a68f5de9f011da77c40a3a16f54aea37e5c3d6b0a007eb70e3af9be137b95d4ec71bb2adfca508f6b21e5784ebe986024044731ce66cd116ffa0c790a04e4b6a2da255e48ff69066838cc2d65582e4e0ae10197f5ecbc44c078c079467628beae8b466e5a40add393c9ddd69a4e03411d4928e1ecb6510dc8a8a9e8e8748e4218861bda447e02f6730c4b3771e26837aa8012c4ae5d66b7e56e0fb000da38ec3808ed77766901b64404a35ba13f2b5c65e2f814eed3fcda41225196cca27ff665725b0a24f95d65cd944f00a875d1db8c3636a5913eba5f1e6ee3cac161464b5ccf55e7d8390f3e47295aeb14ff34aa0c4ad992c9204991a1fc172853e33cd1f4009eb4e17692a00a6b48dd812741122f1ffe300c1ffae8823ae715c584b4df593e9a46c4e572542df041119d28634d78747917cf36db52253a97c76168d89d15351416ca13f0e45dd32e148ad7cb9fc1b4ddce12cce3dfea46561f915e096fa7d9ce1e6b99838b7579f0b8337d8ed89058bb797774668cf734c8bc0d2279b598ec757b5c69f9a2c9b652be9cb01541d35c7b9b0ef715d35da8ecbca3f3c465cb4b4d64fc8b74c2c67f9e15f64a81377f1c77345485792cd1251b0b453bbd6168b8ba1b136b1f8336621a2e940859172aa50574d915991abc5306f886567500220dffaa41a677804f366eb5274c7a4f707b49a33adf76b179a05862d13237c8762ee0cdeb1bbbc96f0f0cd75d276f581dfb6c73a88e98c2286022fe7cf62b989a136b6a1cad043d12ce06c51e8f0148e8f5dd50714028a1b045d759a2d49414d4a1181c13930af79be903cac6088a4318234b5270af817ace9516132be699a38ab52b657daac7130b2c15b63b1ea2d4a1d8771bd687c9bdd70a7f19cd8b598de9b91c66f2a38926cc05628a3b9a5bff2aa2294db02e5095986f82dbcad9b67d9e08aa120297674efc88ef52c3112e213efffdc097f0eb5f2f057ea36525065687807942897bccf439420f7d88c1e24bc633562406c9cef7103260a228457ae3dd0403148a4939a71d02cafc7b60b76644d9b08bbcc5a543a63f61eddb55ce3e60a3cde25b7cb6ca2685edc7cf894f29146bd8edbf2f6e55192bad443c3ad9465ca3563baba1ad64a00268c27f8ff770799fa9246ee3e59e7b44aa0630efd2b6a5119109b2762af80816831308f5aba3d02140acb7322f39cd33f52d0739c55daa1fb892aac9782dc005e31567b361a4a6c5a469f84789fc53b81de981f313e34d2e34e092a6179bc3ec83100a1bbd8a2d4e643e09fb105f2146b2add3e729d83310ea50d8f52867645f44caccc238b626aa8747a0c22ccf45f0015afc76f7717cdb2717084f35cf683f39e83ee22d67e11581999386ae1be2004b81b85e00e3d6136c14c3cec0b2076a0c3b72791317f7e7c18e754cba80fd7108b2510a0724ce57217eda14534e71484b3930d8d129d750c9a06fd6299f51c3d47e20b1956482315d197d1f5f6642801755b8908aa6ac5e2e4e53b832ea8247b3692c769481362760737ce6606d104ee4d4b9e8436cf659a59c1de8f3d4db54d218f96737097d906d2faabde8ffa4035032104f52e3c55785e083cf4ddac24693bb936b2e9f460605f900abeb5bad2fa7f9b23703129f6cd720651d03f8480f37c6790955b1f30c173319fafe231af862e28848c34fa8debbb2f488879d240eaf5ee8e9e1148f890ec6a17b2f1538ab3c3761fd2cda00b6a6faa7a808a6ef5853eee86e57885489ee24ff915d2ad8717573219e0bf775a0a89d19be2c8cb5f3c9e1c3b3605bc704b2d8a396cce58f2e6d424d73b6961cf4ab55a99f28fd3f392f147f94fca867bfafca134f3555a5e782874f9cd5d4df65afe526e67cbcfa0015bfa95c419146e6b5e105627c4fcfd504c40274e7569e2c5c59fc0d0a64482cbdb78bc2f4ce808e34ea3361288418f9875ab1c015b3cf2522648c1b86def21df2f78147f3a29f15a6739de25416f827197a7838f026c0ec0cd81dde3998c8357ee9a0f124fb02fc5fe9661932c87993bb78bd6e9832fbedf6958f5a528fc981202411eb7ef9fcc56751793c674578b4cf87c431add769fddd619d765ec13e71c296ca55954e6d515f748b97357e915651e1a3b865b8908456f171a7e79f45601d2becdcee8f7157a243eec634ba73da78165afb1f425712b154fbf7fa8e3e538168ee3920c4c31eabbdc4d075695e2eac83764f3e4ab5ad778afd0f65e6f14fb55e4e918c565ab483d025ad4eed88ffd4bdd22f6b2ddbc3725459a1fe87a672d1399aaa347bdcc092761fc279dc1cb8bb1d533f98454f2fc8fc0bf50ce1e55e4a8022fa2e967397d5bbcee6914c80a3d2308e138a79a3cd0d9d55f102c57c1efc86c4456b48847234866708be4923fd78ed935812e6e09c8b61c9b4a4986f59be4382cd8316e4360ed4a15b11a2a9a911ceda952f79c04b1b7d9f9df885827c9b58bcf66d6e55d5de24483c4e16bf0c86641b0de1efabce7269946218ecabfaf2fce028efde7387dd6bf4f386674eb08b4798c43565179635dd214e123de349ef62a697ed7a8d9a5ee9f61dc2c4c87773d1e09a0d417511560c4833427897de19bb6df15a30b2939399eec459941adff5c149e588e6ae3b79274dc6ad52f573ee35a694274f239c60e331d2d7ffedc79ee031ea77039b0708da6d8fdd9046ec95c14b69602c48a62164d8e27150632d3e4a5b603636e2adca838f199e010439ed795c5b4e5ad4e797ca9049aa34e9dedbafbf54eeef8c9fd181fb9ed0ab62f0ed58bdb32ad8008411c545bc481f6412c33a9115e720e0148f64cf7b56adbe664ac92dcaa5ab8118cce25dbd57388a23851ddd7bd3c813b6d3cc58a31a7fe5492e81ed6c33fd4d8680f1db6e2a18032d2839ea8dc4a672487172f82fc0fed353cff5c6773e4a4b01a320e6f067af2f60129b48bf15a7c7c36d5c34e5d251697fee0ff3c578034d9dd04f453f3379e3a492d8ef549e4034d89805348f47b1fc7b20ee5d83692b4455aa08e75ab85dec1971598aaa5a67e7687c06b3f38cd8edcf4a21c840f2897319e1ef39220d633343f75e5d99a514942d6186b4b63e4de2e8fc162024835064e582f7a0fd60a621f29ee74451b45126fb3c33ac324216a50693c0af703312bccafcaab2b97f5cdc4a87b36ea96d0f693528329bd187e8786dbc976280e28fe5425e37fbaadf154d5b23e2fbf679d93fe27e85aeaab98bc49794b3b4f02fe3827f4b445763d181f472095947beb18cea7eac3c7b703c1c332b30fcd7dc7da15e255e184feff599a007f68e1da60ea73423d3108df1d19a3e8823ced02e8cda771f04bf77f38a16dd1b7805fd84dc209b68ec06699162b1fad332559241b1b019c1f871d0383aa7f1e736ccc13a39eea9982cc5ef53dc532cad57e5b1ccfcffb0d485f3684361a36eb48d76e6ee1a31c4b5ce93def40923365f95eeb2360b348a73227506a65db2c535e8c24a003451b089196e0b0095f7ab68fe67e08f70ae4915ceac2c85a702ce5f2f6c7d3587fd0a83b4b11c74a57b5c2343f2830f9ff669434ef3535ccb24f9adc3f6b76cf8793c7bbc9577717ecd0d18cc4bd7d6581a82cf2aec58b953e58dc7a29b883a5d1716d313c6a3657ea219a38540ef14f4728d3243821f58114bbc2caf0141ba28b3caf60490932320307d4ca68b3fdfd0ecb4765790099859fb8a715f560c90186355c9574d23e59ed6651c314480b213e2e7e1b0cbd40d91a4c2537e02f6031ad714c1fa6d29199258015c66c340088b3b298110e4452a0628e25e1ee40ede89c4118c4026f9becfef8bb9c0ed50b560338961a3c00e3247ee4c420af1513740c543be64d8e6ace7e285e7e82e25d3bdc8a2b84df62c36bede87cefaea2a94538ba18bda8018222d9e0ca08f76f0ddd31ec02c9cc7f62d49c154d384603fd72eca48db54efc51054c714b6150f7d02b212844fcfe40e840f7041cf2cf31dc83a6604930bc514f86148f8879baa5183b2ff0bf6b7b66fe78dc99a26012d5a3df2261aa9d2907b0ece02f3aa642f6d09b101498292f66433a2c471a346c9f9c8e7295a688951ffab3ccbd414e724d9bc30cf70034ee86a745b9bd7389241c5b6af889a2267e8c2f3e185b0a21760ff15936db2742e23d40762f89ba3bf46a9e88af1d7515bef0b365305b821dbb5894266273679bf4516a819f0ea2819ab8fa25f71bf7381c88ece1e44c5cc3e1130a5c4e46a1323565ed7d9aa01bf77730b2bd594c1d6e344e6abc99aaea7d6fcc408d97c83034d9e32ce2b20e6a8bddd7c849d6ca0eb4526d159ed3ab60e208d017053e44cbc2155fdf9d9bb1080e2219904c014e6db9f355cf9164ccfff15b4bd51046648ea81c818ad98505c9d94a8d97364477411d5342527f0ac8ff67e2a56c3a4493c08c65e5cb85e7374e6436c4bae757cf492e966208583eff38d4458f811deb1f7adb9fdb13be61b954d266305004e8150d9b548b1c86752cd08e72fda88bb89b969595c031e2f96a4f1650177027443239d6569f9e89a99f95af3024a85a9dc810b713e0151e2db75179e4c14dd63ca93f984a2c9ec65e043eff170912e9a3ec1332ab80e77dc35abcd9b5eb8df6c970c4de15501dc1795950708bb27068df8b6ce0bd2fa634468ee26935f1039c52e7035d21a5f7470c57885e7a44d203856922cb8ad3db8aef4dd974789255c5064a39661dbf3c091dacdc1916a5165ab1d75ec6eae07f4821b7356be70786b2cc2b1e90f64d5a954e261a79b4d4a3bc50f325f7ab26664a299477564359297f7c6cdb580dd9b178eba29d64fe02b6bdfe7dfa5ae54ad724ca2dad1f1218da786cab3e8e8da543011f1cc0aa152942df71ca2a1a318538ebe7c6f214e900953986ca8e55a336ec2f557c91ed74c78c4f8715779443c79d9b759fb8974f4a2b728eb4763919fbddf8bf7a7238ceff78f8630ca11802f1a5ad783b20ec1c9c11a685dc0335f0bfbb15791ac1431c937a8a8ed90a46ece41fdcd32ec41bf0f8514fdca8b32b50b183e72fe79981565cd6999b909b5af72f63b3b23fd0c8c73d89fff37b8fa0577a5462e4b146e4c845472516742e06980d7ac4a3c3d77083f25a2a9240b14114ed246a3ab5615337687c30a3a985195c9f00c5ec5c3ecbfc400786ddd4c02c5512d9dbfbe8366ad828338f5b81e87cf56f65b5dbaca07cd1339bc8aa8e89aed61fb38fe4e1c3d45ca489463397d2a45c77efc51516fb160eb541c1a13edb0979c65e572152de654c47f68dacf1508572f38cf84480c7b5cc47431408830e122958c659795f5087d1307fab14aa93f0bd5ed945ba05cef1ab3cfa7d0e30b28158af8c6b1b4426734f35dce3a69a0ea9cd4378297d6c0d8e08707011bb1b6e6de6c3f89acbb7ff14ca83338c3e26c5246fd8a5128ac31956da0bd0a2f95e0fdfbfa97f1ba47ab8e3443d42a2b58471a1cfbf6c7b20e5d51b9b3c23c897cb28ec6410aa5277d0da3d7917531f5e0e9639b4be6c0e3048ad7e1e9d708d05096bfb27e6e9d7b73ab8dbcdd05b5864e9e2df06426d09629779d0850a77f4afcb3b4c59dfc7b2648786b99f6c8ef5ac0048504d04e0afbf631102fcbae2b33132ec5334f0194187f4f902dc9775beb889d3263d19756e9743d9e9da7e4c0d88ce43ce8cc407fdec8d9816c6faa1314d02017c918b84a6514b0ba24d470965f6493bc5da95ce4eb0dc6a20eb7196afa640e2909357cbb8be2bc0b6ea5aec209a9ff73fbaa541600241f84ae7ecc543903986110cd81ad014ee4c1e9630760bfd28c885c6491ac3117ea421371a366b5996e0e0287606dda8ead21710a9b8b765441aee6fb341d88684513de12826dabb7f73635f7632e4ee6c8e1e68bc57b52f62a6d735a1c77a1f295e72700ae8a5b896cc44f80ba40b3743cec064bed0b61dea6577a0fec63a1642ee28ba73c9060ede79fa5e66962b89c8ed122ae30181e1fc697081729b6ac1f91d03b215e99a72ca5789484336a2d9b3a77b30b773462f92abf99f7d4ca728e03621c9ece7cb180caab70b99977826248ba8f67a55c2ccfd583e4064c23952deb0787fe6d598e866c3ce925b4bc355c3cec7bd83f2bb0cb13a5c7abfe47a9264a3a32b509461acd6ce03e95157b81dba7c40f55c06a9740726b7ac7e76aa937ede6e80ffd254b1f5932fe77b026611df42560af87d73186ebe5e612be5e8d5d2c8cf12e698d8583d1bb74f51fc04d8c0b5cc3ef7dfc0c44b938486ce1eef44e172f924cea882d49b6a5900f47609084636b166eee1e9eb333d09457d6218bfe73d62b02c24447bb5395e84cf570c43ecaa7a05cfcbf27f57f9d5ffb5b37c78fcf1eb31723daed612bd382f8e9371c8c2f1574333983f780295c41686e37769d6834bae55abdb959ca3ce35d12b3a9531a0efa8afd79fc76553642f53e3cdc9abde11561ec0361e5354cc7594b8b17569414dfd15916b85541338f8d6eacb9d69cc604c159177fb5f8d1721a6c96bf7659fd3318a3b18a7b635599ff150b57bea467282b306a588a05cc0ffad46bfa420f8fc33aa030477a48a3e77ea16491d7b97517635affd389c6eab34c7e7a9aac48196a536f58b639285b88b9bda2586482879600b6d60e4202f34e0132cb539a9bba79d2f6b3715ba100a37d0744a190a5d6f3242d219007a1af6455f6190b96f5788a2428e18816ad0e98cac484ad179a9f8f2570257f321197b5deeb69f7de0c7843ea5e2a50b5af7c5c3f65c41cd3f08f3079b5d12bcbe9595159c7bd6a6c89acb6320258a40bf4aab1a2c55bc25d1e3ad55d14cdd8c93364e13168469320b3981c7dd05b65bcc8dcc59abd2b23d32f66faddbbe8ebeefb07a0622abe8fc5cde61a35d7e44cfe1289afd18c500666b738bc4e7d2a810a30254914be9fa09aaa62fe6f8f311dd80b37fe0f2eb271878aedaf310bc5835b7823fc1161056e8ca624648a588dedf8dd0e5f86d43b273c4faec4cb23a0604dc5a1be37c60c3939d5fa5ac6a2077e63e4b15cebbfcc2ff0375afc58d278954af748873c52e8664b8d99d6efea1f65b7432a479f50efcaa0b14d2c25b73f878fbfcf3dfa77668fea90656fa60e076d9d562ca52c2e03fc791a61f77408e7f61d98aa227eaa72b8a2675b5a3797c3a62cbdbb4ac73b4c95a9cb220b02c278f439db78b83f3a17b4c105b251e481b698c94adab726da4dfe97b2deeb1d61abd178d2cc517ec8be3c8fad9db9c269dd6bf228cb6e0e0915eed497040cbd0feb4cfe0711dc2f045aef44721f72c247f4652329e0f235f143df5258066aa6349d9430c5483a30771d3e4ea41b3212e583d78917accbe058284e0c8271a86682910cdeeef733dc01a218e178883a2e4d1f0e40a4cb4dc5f2f6377b0079f9bcaa95d899a8141dce26f99c5a6234ca0832d7c722864f1411d5b3a89122ee0dd82b872b637416a8c5dfc2df2c395d3fdf7e93c749147cf01fd04422c292fea93b216312740a2a56e45f37af509786b0eb90f88673c8c4a409e491511360fdab69dc4d51ea0fdb0432f2f98c444e2db8a6c3ca72187d97449567bb124a00937c8269d945216d675d31f48174d7cb06bc7859c26e4509a1063e855badac6b90e88183c5cbeeab077cbca7f3a7e8c6cca521f6a9189f1be67c4c3509d3a60c0760be54193cdc718e1bdbd936f1766b2a12ffadca5384a04dbd3eedf05eb1c38443a4e1140c8db072a3d961646b612b4279965e03538d3efaf2abc256dfe79b28100001748934abd5da69082ebc3e752bac06dfdd335c94387d2ba14dec5b3e231503ae77d1894b2e9f2a8df2fceb5f4824fa2fb501142b72c0b95b92ce9cba26fa82f125af8403f13bf18aef2247e6cf0d223a520f8505cf9866f20d65a81bc11764d01af5dea9abf0487e230ad3778a61281a561e47251c4f4b7ef68eb5e89255a64c8a42ce0b6e0af679b0129abdb6f78c1d6e4a3039aca216384d43ab46394b3382521684b7b6fec5fa55f4c4fa14c1150b92215763b85a5ce5907dea3a0ffbabced969941e2671ba94255f17f3c7552625b2fef9ac7d15954c8d82596f1f99faffee1f79d2058316dca49c09975a3b7c799f85123676e4174c3c1f8a91f41017c798cd5d545eb301cadbce7484d5fc7b5900df361d7ecf6e825ea4d4acee3ddc48d2cbd43b9dfd15bd7ec2023454e66d4694346acf66d8745c05774d074ee48c081f66f94e0418184f2785988fb08b434536fa9f8597116d3cd26e36ed05fbbda7d03fef63b10a09f737f7224f2d961421aaa00ed2f0934ffe07ef937d55a69d4bc23575c7ebddace32e67804179c4d3c0758c5e197797563846fdef4076f8e14d380e1c96f63467232a23e43587ccc4e1a1cba56412a08422cc919746473d5b3a0beeb12ab8b8497b7980d1acdf4bf11c4f557dedd0fcce87bda3ece42373f00425378567ed32c39f860c8ea34c90e11afc672b35b1d5fbbef434d6f25b33009ba87e52d644dbffbd8423de56d11e7cea3da0a3f41a2664c09640fc1b80f9efb51a9688fa1ac0efacaa00ad754fb5e23ae5ddf98b9494d498e715f0bf50c73f219b6c83a26e647c17b7c186095529fd3bdf57d0902273ce857cda04d23ec70031be0ddf7b3565c7cc12fa75e1c18b475ddb95a7d8429e2cf27f4df5b777c31de130c4c41c9a6635c75b09b67f92b1fa0ae2360f5f52b6f713daa501bc45e8b8ed7f91cda8b063454d3ef45574211dee122c3913b5faea72ac1aa8a8819ca8bbc986f85c12dcb3c03d0a82dad9e58f566729318355ced7c5c4945f1f79ac484966067efabb8b7c27365822a98667f21573da78793520baa2e0179cef57290294e94db1d2b6b829e1cdddd12a07bf7c89ea964e4d99f3e95cfd38b7babd4899a461ba1ef18506828581dc74a52db783521d3b96918de84db9573cb3bc8c0133b818e36e0e86139a4670ab7bf026952f71ed3ad6a2628d965297432f0473c6e72a3ba18833c419b7efc070abca00dbdeb0f305ebfbc7e9f1c984c608e0a0d4a729c98165a5c4e17111ad30dc02264311c64e7e92db109da63bf61c4987f760051bd1d3f410ce06ec12661d9b2b5acbc8e773322aa12ee0c88","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
