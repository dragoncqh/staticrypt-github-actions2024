<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"878505f77f16cac3a90f722e002509898419fba365b38634958d8cf6273929029c1e7c1399f7dbf057d30e14cfa077c83e6d94e809fbadccb97adaf05840a6fc3e544147824f5b300dc4b840b37bc24a00e5e24446d43e5ec310ae44cad7380d30c152339a6e1d3ec103b0a54cbbd41b0e3ed0dcdd526d18b2a65f3a7dedb20a11bde74bff452383fe8ea6283c29f6ded10c27a966c6fe63a8a180ac8420bf0d30b19c8f3576552e0a655967f6b4a404b92398274b05b94208b5843449dd86cfaa782b4a4f7ef813832102683cc17e776842a90f82afae0989b27f3a639f9f645f061065accb610c455aa454a40a7e6cb144273cc0ef1e4494f94d1e93298ac8ed1349d5d7a0078608bf9a03d08e6ab90e7e6809790ee92f0e164d76f742c8d7996f6152171e766d4fe82e016ea93b29871531aff86adf7d1ab74b7aa6b60d7743425ea85f1649b70e851a0d0835bfa806c160e42a4c23d5d75b1f4ebe58ed0e1de7699ff5e58ce67485d01772f5463ca123706a743ca8d002bb81859036db5338c61ddf730d7e8bb1c5c182046b0b7368446f29ab76e091e71176cb0d979cffd1819988bbf14eb42093da701d22fd1ebe11225c16b9c1653688a88f34ebfa03398b36eded55a72d6853714e7d65ac572f888576045fbce65e5b5de903adb46361d1f1cb28bb4a370f5eac9b4e2d797b465ceefa7fb5c236cbc7ceec47501f348eb044619a184f2925ba7d35391f6129b6ed24d37d7c301fe89d30fb8dc892d54435f6f77895dbdcdcc754a53a95dc7f3cb280c0148b209d9fbf05cf0bc7bd82d28d49ac749f4896a185e1ee9bf3f9fc22365d31c28e8dbed40441845daca0afd7a80e4f505e6aa3966527b2241542778fdf21c9c3986456db198b2519756219d3ef63f2580692443c3a0272c2120eefa4a9c0a8f1b7cc1daf5c5d186bd6aa0c22ecde6599187b5d7f1303a6d2a91c81e3ecf62b74a1648846312c19b30a2fc80bf937fbf121d0d390e0d52a5c65dcdaf64d252a051a3683a3d96461b6845d78807ec0735bd774672b59740659e6516ae60579e374360104aa80e7ce4bc01de837c4943aa5b82d83b037e5619d0d14e133542011ec77b2975d07bb2ac6e3e0e9c7d6cbd386860ff8d05ed8d13f30febf953d0980d23b31144d55d82a92a0eeb31058e3d7a87e2cca5719da175c8ba2388e63b86e3c747c9e6c6b6b4c8aadf2391a64a81ed301c94cfacf68180d6de1be9b7d9fd7061b3586006e9e221a9c014dc79e3fe5e05ecd6a4de1a71ee029215e708d50c47b3a5ad1ca63ff99d07d6df5332904515cb8ae6fffa5e13a21970f8eb6385daa860294cb392fbfcb980fff1da1c0d60b417d9d507101317a894218784160d7708b1dbb3e84cb56abab131b447c15b47128a69e169591b6196ebb189696934d73e067164d16b0dbffb9298a6c16223239fe240cffd3312838001ee89255a9205c9d99ded783987448665eed4f548bd45d03c1bfb181d16a8911c4b6aefa943a473ca8c5b1beb5ad9c1af01ef22594faa97f34c290db7e1e90b02e120c5e21c52bbd2ce7eee0a82d3010eea447753c8ad6e871d75b92b874c85459fad68a97eed22625cf385943107268ef2986462299742cc8c601618ed827762ccdbc29089d3d5837ee77c62e7f637d224e8653068cad51eb8df555d7fb292cb982ade5e469eb7207b4e621be4e219413ed989910212566d69220f12cb3141704c0904e4304bd5814ef27edbc453295bf1d0754d16f6d2e6e84c00b5adda5dbe5852eb4abda5ac34e85f050e791d633fca5258f6d0364dd461989e3ed743452c658f38961ff72b2ab2f6b26a89a2819c736f29191f37efa44d4323460156a711c0c389a7015142f4ddb3568ee7be439e2d06b6a570c4379fa584450e5cd87b390ca0b84db245a8074dd03f912f9754fce157e697f4d3cdd05dacf5e0da04225e07fb0dabc78d80ade782b3c51675ac05f53a360c17d25076393402135167721c82c70022815a8abd1146c2fb8a76742c74959cd8bfff7fd470c59cb6f02c7f1ac7a6df3a5245c795b325325d58289a37f7cb8ac5103e070f7d8acd340f29248dd73476b66d539aebb5a96b6e352346f82e1f5452ac97944be1d96671ac6c80bc8b20656ab6fb9ed4b0eafcd3a74c100af5edbe0a02a7a62c86bbbbb83c377675fc34f54c8cb626ca9dce142d2fd5b735141c046f2609a707befdd3fde25d9ba30aac3bac85eb5285bc83c9ccdd6301fa882403dd74f8284db8e5e33972eae3c76156834d4c2c18311bf5847962c3c92265a2db30c365aad01b43e8acdcc19a1b25e6b3373939d9638a730ce9eb544ae399b5156dbed3973424cc9caad1a7f8a05d9c51107bc8907a79bbe2ed328753a4adf2e4335b91e6f56a3b0efcc2fdcb2d123ca85b6dad44bfcdeef913ebac92a8b6739d4a90d532573506dd1f3e2d3563bb13424c911f8261ad79f0e9868d0aa4b24f0baba5fb5819e67a8d1ce303352f746ec798c4ab6ec1d85f5e99e3e4c81c98413f0432c308080562312e08c19b6f147e467c069e1188c05569f922147873c5c7549b4c47dc23f81ee62d4636454585d6e085e6f203823131640dbb3d5c78b5e27524fd691974f344611da34b7f121cb9a73b435e989c3bb85b18ea0e2b358a692707a00defa172b527730316ea277376955f54b5d62b378c0c800ae920dbba0940c0e17ede03f1a86913f0f50a2e307981e841fd47ef5e788faf60131d961a5961cf1423711583f9b411b5a4173f52b2dc357b2e54a7541aa482c79dbf68e09fd446dfdfb71053fc7cddeef05292a6f3e4688d58aab459457d875053ed838d83efc2053d09e3e08ff4c6b1ca1e721c4253dd8f67fe8feab8408be1c88718a00ae44a2d55c5cea2658f6b925beabd1548b55b53cf06efa6ddaa5b834eefc6688c9cef11e92e6a328df2eda0fda184f36aec1a0fea6d80f2bc1b4b6891d1b1b44f2023407dd9afb7361204fec5b1862be491282d042a960eda5bd6155a68d3e63af1ac6f87c35c3c9d85c663edda0484af5f09d89d539d1a677e762a5ba615d8b6fa24f187930ad147b5fa036893932f8dd7e4b9d1c6b6029f063ce8640efaf572162cc4b78f6982edc679a843a9ad71a24a8725d7f07a3c4507382193f1067af3ed93cbc848f0f77b6c0d2309a2dfa5077271096bae0a0f7659027252d30607e6bc1c2c89d67264319d72b2afea000bd78fa02f4561913877daa3994e33bafbef0518ca133ff2174a0a3c6ea4167731be2b42de94b46802b4431f608c01f093eb9b9117a888c3c083fdd7a208ddb51770acaa584a989f3605bfedd1a781836942bc052b21add79f75e583c764f8198e53192dadc1951a6144912f50b966be762a1a0f5fec7d198b4abdd4cea7b35b6cc4418cb732eefd77e6138697cfe1e74da1146185c42249df84ebe12a9e03fcc2293b9deb16241eb3bed142812890d8287c4012253018c3fd431db8826f51b562d7ae07bcf01d81938c864b59ff84fd46747c5d518b3dd00609617c18f51ec733a6f1c16ca7977227e7022fc0b54b83aeb22f6dc08e1a66246a1ad5cd392bd3799f8704879646d0ac0d5a523bbdef33c38b26c5e66730ed616845231efa067779ae6cf12914a688bfb29b06db9ca97f751bc129f781b1ab7a559f3efe4e50b166639790e178400edd4ba3ac9a9cc08dda982b529494f9592ad7fe24f665b28cf6e4cc2067b6c49d07c704ac276ee06ee15b939a7d5b13fa2947a72fb0603b0e5e4e5b64c3d207bc9922566f6e18d6f425954524506e5432b290f76e208591228cf128cf9959715c7be392c955607189598ddb4416d49853f3a41cdb18c9eeb7e1d39fd4df999680e30c82ceb7f029271f02bc0a5401935774d1169b66b0c02829cee964d6518dfc93b626d77e9e8406383c0025aeeac2ac4534f87f5e773bf6d001fd1de3e48dd2eceba45287212cef3e3077b2729c481a885801c0965d6d95cded60c612279029cd7e1702acb159149a8fb73e73c571d82f863a1fb18737e4ae90d7402d97f5a1f1cf24f47235a9c33127764255ef16fe5e731eecd889813e5c4ad9e23933cf6b33d1e1d5016db3e5f43623f0498ab31c7cc462b056f470736fe3741aa22fbd8c6babab502d9c8eb0fee59d9342317dd3c0c4af7bba114cffbd59efde4754eca14cf8cc01bcf8a64378c892e7be2b0fa02c72b94e1c17c849e18e4ec9de03b49eb6a884560ed2d087e8c1cd8525c049df5026a4ee9038a6d71dee745454fbf0f65d035a934e030f63d1bf6f0793d803813943af1095fc3fa647a8d7daac649d049fee9e336f62eb419146b19925eb25add23a3f87eb301f43ba2cdba115644e58fbdff441ba7fd336bfa8781954710abb097460a79df4a6560993b5c197302938a3a56ade300432b1e3e6281b9f759e098e3ab1ed65896477c7937306d2aff5d39d0b68a410e60f28da902d6092bfdc258a58321b854059c4e0ab8d399ae0377d3334d661989da3efc16895b25add82ce5838ff06c0e050404ce4e81c96d7d50e496824581b6a8cbca1e02a189743183043ad0db12f142b48eeccaec5b446f56234edfdad53d8ce844ae3208cfce90d2e85de559f83b1259e1e839936912bdb9647ac8896ae33593219196718818897cde0da23919e762dc67d8e134c8b38f2dce2cc331875e68028906fdf86eee8194b468a8989e6124272d3e1200bb57331b338a9f2ee3f1389eb916cda7e4689b4fd82bf2d1206ec9611fc43908880e831ff392fac7fc2e70f9a794c257c5144c20348b3e18ecd1295ddc0de36e9f076c83d6876cc307d3d50b42773e7b2203c6aff88166b0eb241a5a535cdd580b615e2ed37453ad509c33011adb05e22c07cff50da2525b0abbeb2c8a370852a36fa5527ba18a78b4b8de50dcd27ff0d2625e036e89f71fec71d81b57f2c4dc5fa69338768fcb45f61d525fc50635a51282a33b03fc46969bfca5086dc60439bf074cbe1170b7a00b98bc1b5a4a62437b57f492c0b5825e85d2f11234cde3120ab35c34b3b92b723dae49e1e003f6e6dbc6f013692ed69b6a4d03c87fde21ac8cc834d961ce4005c39f4509c47a9c316efd29f62937178929697d5fb77d40c7632f8a4faa6744a03476c264a79fad3b3705456011c267c37f9d1fc055e3d8a67d8fd0517038b03c1c1735fa5719c7273a55f8ee80b5e837f93a02b901fc80220fce2ed12637828bd6abfddf2d6d4d2dcc75c5d1d273e3819eb59b838608a249b830604b81c49bca238f6682482bcfeb9228c8dbf71ffbf2f1aaa161b8605660828c6a3f41b6cecd2e4aaf33b15d42ad3c9b982ef2af676cb4ec15acf84d33252069fc6f19830aeec00a95721e9620ecc0f2f1837f1c15d60cdd1389f0143d9904032675bce0952980cc9b2df2ebb98eff3b074936df984bc4a880ec3e458a36ef46c6f03ed8cef0278fe9871713f3f4efe386cb15d1b32548528399f05afb8d15a2e5dd0e2636ce985da1ea14d6bedf6ddbf3dfb7315ec4cfa2fb388643a309bf98293004c8d56b79d67637c3b84f4754f698607763df46059d1ef9db02ba3034af3532b6485d83074d3e8d3239c25056b7b232052a7ac435ea95b3c60a1c32ad96e0446dfa70ecc4cb3ee22a27e961d257359ea32a26cf32f83c61e170bd1cb3a4d638ca799cfd3ab594fc6f04574b649df867e7ef56a9bda49dbf6861ac2b1d3907f6d71ff9be9d1fc023a84716fee2a78cc77b633c67cdf6cfd1782289e10f0f0c0d951385f2e307ffebda1a1b0a67bd5647654cc993dc561b5f29a0513f67cded123a9eb6b0a228516044ace72dfc707e7207e613185934a99ca34961e592bc8a88d57b6d074e72445a223b547a6e0eef1416bf952af7d3fe4092376865cd2d9ac431b5459d8b0a0e981ddbee7ed1849d4d2576f8d11fe8f6cd9c3a1799261a802fab88a35f9a838cbbaff2686b1abb6a3ca21970dfdb1770e1b80b57d2b0c7bea300ce7fdb9af1b1a7b838390a61f281023b1dec2a99967dc54dd94ef03657c6d718884fad6c8acf37c837fcf50042ca6a571814204e4298abce96c3263ef850636436a7756bbc6d62f46f1712e6c1620b3b9dfebcaa6f3888954a04615ff8c7a729bb5190c5fe66c5ad148f78bbaeac1af68b3f61d8cc57f0a23419b7d1eb553a0ba23fd6915ad8d06b25ec8d6c19e7bde3a7271020704be396766f312d015013633eb90e5e83dbb8ced3273c57cf2a19691e844ef4a534f326aca287c80137019b1638ae4da48cc4c8e31ae9716596e4fa2cd131c07fabb2a07e107fc4bd5e9372801f015d09d1ae28212543e8dad657497a48d57741844b104c97b64aed4d1d87e554f3b9af16afe832115301707a53b4f0503009bb7b311abbee2a1d5cd13389c672c839f2cdeb10fca8a26ff2285b8baa51dd92560ab588f91477e4c6fed877007249762a56ffc35dadbfdd26fae041995c60681d02f845f4eb47b327c6590432d40ad88c545465adad9fd67e354dcc291ace16e889ba30da04fa5fc1661a18c1ef95ca68f85453edca474b35944734a360e87d7fbd7f4b13466fb02980187c51bb51b1df80593e5d91822d2ef90fee4931e5da659f9d9d3cc101753930d3de3d3561b94cebf99fddb04bc7bdf38304efb3e41e7e8f64f34e0fd6860287d73e0ab8c3ea66b4cbe5b9866b8b3f71c17913a0af05a1049ac6c7e7d5cd7ebeeaa51846ce2fa5a3a5f0c8f36d85fdb980d83eb03949477da4e8359f6baf02368c39082c0c0d745638270cf221dd3803cd6aac4513d43d406bd7ec7f5c0cc1e2eea9b99706ecffc679b617058c7ab3fbfa8c65ada1661a60537f02bd50f8b878d41862dd04c10689880a9dd4b49c5b5fb1520bc28548d3208fc04832ea575827c1fd422d40a8aed3aefb3a6c0b8769a7611116ffc3516de4f085a40a4274538a790e5a266f3d973f0611f930670e2050aa9787b2ffdcdff361326271b1f952cce6dd9383a986679391b78345900ec2fd5e5f4c214d38c22e52a0b03644f90e075fd7bfb655768c53b3e66acd2337eb0e49b5da8fd49c337600a5fe5d29244de6fc8ff7acdc830ecf9a8cb8e931f651cb03f9794dc0b8eec449777e7e445bc445f925440e79b3e2fdbc71006fb69dc8a7f0a43897ed5509d017a5d06a9b0f0a1072f2f9517b7c727501a3fee34b7bc08a2e6fb2e01206a97b1ed9b84ea82acc9f63439d16f962baf8a2ad6c927ef47cc85622339d99cc9a18bf5b34c99914b886ffdb5f5a038619d3ce6a1bccb343c8bc5a478070e30eb293c43c660b04edb032c0595954208d2f8c14d4f8c22e301cede9aa10fd2fbdc2a475dd1057d350fdf87229d70b1d0536ed47dd0cd193b98ed487538cc7f9e34bc167a2a809a9d0ee88f1eb472c8ebc91129424953490fefa7353bdc225fa944df8e403e00549772f44de5369099a7573ab1319f516bed65149ae9340dea3c0fb35d1ba52598e2ebe09dafbc25d5f1cfb73c155cd91c66a2f217493ce02e9f152f9cfe66d6a94a1a9a35a6dfd61fe8da42c8e209f96ed00d2a8ef635aef5202e7e402c82dac77bcc8b7764555a742d55d6d9b1ba6e734b59a402a5668b6ae4e42be3b6498973433588afcfca514e54206b8c43e297fe5ba14d0be6d154177a3c33ba8c3a78dc92c8deb26d1ddedbdb35ad9406997d5417d35ff076405481aab4d131388deb2bc2d3340f2e309b5ebf3048cd89f5934c0146933470bc2a9dce1d17da8fa121ba0f7ada532f90f61d00c200c25ecb57b1871441335e9b9ee9056eddaddae7e248dc829473172da9e0a3bdd79ca714726303c513fa53797d60594d162f81a661956bdde9c3b2f4b022325fc789b809710bb2e4547ec03c0d45e1a5fe2262e0353fe5e1d87cb5c575e2d53f8b888678af4a0fcd1e9f42b8155be78abaeac5073f0cc399d67bf1796ab6f73afe362028cffc981fe06c42f20131dc53367fec40fda1d38b45cfed891a4e844c37bf900ddd6656ae0c86e50521c4dec47ad07959aded6fbdfd1b57f40717c89db82d70fee8b4e7a713487b2a00678ca54ccda97ba59ae1d9613f26015240d31b0da71ef0ccd8dc6a754cc77d7543ace25d3e5dd56f6a62292389114638a5357216786145789b90926930c726b030914f1f5c4ef36a12d98f7a2518dcfec9baa942fb50f0efc7f15eca56487cbb02b8e9302dc1c85b9c661ada859be6cdc451ce6aadc252ee905a031253aaa0c4503533dd97da2e645b4a951009aa64df0047da4b9d51e4a62d424029e6f852701bd04c8bd493d9735fe267adb07c8f0aef043f5edee582a1f4dab7f929732b43552b4214d894c895fafbb348f7d3b8dc1d39ce8d9a1f557d46b56decc440d11f134d27cf8808c62fff2daad5494eded027370f26f5d97b3c7d43a2c3089d10799b3d7d6926bdf18bbdcb4b1de9bb639434c64b0d58a0589267d6b4ef9f013784810a0aee4ee09dddf3637d94dcc10f853e61814b6753c296e93dc374e9c58e8b6a0ff6c8866fc84380ccd61d3f593d051af7f2a403b50580e10e7bb0c85a5d8c7e2e9bd8282e01934ff1938ed67256b99326f0f97dc0937c60f26d95601ec4c8387f3f3b94a1c0158363b5cb4751c1fcb44a7c83ba8567d76ba77ee175adf0bafd5b7287b14a14f1b2c3bef48a3e55a36e974d90888807f8c38504699d526e2601bccf25e2d888e3f21d247afc41cfcb0b58f456ff309b19b91f78fc84ef152dd9a8ec12823c5d20ff75b47a7ef0ac107b89b3235304072bd72493824628524215cc8f6f2570cb383dc1c43c179fc3a494c3b0e8f13eac59ad68aa203e8114af5ffe555502f9685e4411180a8df5af26ec899b6a227927034770ffa6429ae0e983904f9c7d5a54eb17149b2ac9fcef7c67ec8668440565969424f8dbd7b7e5e149cd6131d0cb9e81da98326f298fe754f588400052d3e43201b2c9dd8c8bfe9bacc2d6a94e99b2de300d58b69420c513df7990bbe2d85995da650f033e3c5acb3b3acff4e52a89edd7134074c97df34c8ab0b55e4f690d37df6b488123f1ef412bb986cbf15e6f032b1dc1eee70ad550151623b45c70d58c7dd2f5e35e93e6b1cdacce72875b7d133b25944f58683b76a3340c2d6eb5b6cc175758543d8d6b9114779567be8f561d778d919723b79641499ecbc18e5d89d3689fa52a1dfd998325c4d0064d73945de612c2c48fce3f19134e7f02b5d3b899663fd0ccd5f96ab5c18899560d8bb59ef841da50e7add95002b9daac703074a1f3a7959956b476ce0d6a6ccd97c8a2a8202da3b776002d808f86d087e06bac91a0f3627e4ca9885a15194f6e013dcc689adca2324428096214e2101fbc333f4ca5c8713c3d5aebf9bb0a8c5e1ee756721c8ee35b08f3cb121ae17d57d06b7ed3d8e64201ff6b6d320b3655e5fb23849d6b89605e6f065fe4bf86020c5d940a189089339f5247833015e516bfaa2e452580b706641694fbe213eeb90decb1d918ab95a238abe490b07611269756d5e0aac209f2022d662067480ff764b38352f8a119b99ca905b6e42aabe1be99a1c9c369ed38b4299e4004636f502010ff5b13728ee13b550c4a158b79f0681baa6972a53a1727920d858342da4f61cdad9455d19f806adc27418dcbc9eedd295151a22cef49ade9b87dfc68d12222a3657a7dcc229c9e7ed83a29c1a04e95108b9daa976883bfa02f820b052dd9f38b1a011f9ef6ccabf74154561199e6cfa5164b2ecde396faefa3f3e125294cef1e9cbd44648ea075c2ffe503ace0616dc90214c164dd0971c3f4d538f3f9c86b0c1ffb0a8953ac14d3582c217f72418b41fff91d12fb1493aab9d7c8f08ccdf188a9128c7f00e434cc9ab686e1008c6594d72c0691e1c0a90ffc3b5f29b8774b3b2a788f1b80f8cc72ea67f29ae9f697a235c3a8e0f32c201b01df3fd12ee1f4292953fccae75595d714d8612059246e558e22ef4d3c2a93888aa02a846198c8b22532946b7607ce0ca75d63c52eef1db2eb4d198b6f043fa4e525beb8dc6e4712128755ff732897452a90ef9b667a6cdcc016783b82a047587b1949bae17b0b327a012395fc35c38d35536338be3eb01c64532f53c0b0a8c4cfcf3672ef6283d9b5fdef68cb0fcc8fa81cffc24d887d9c1da34b9309148c46ab3a60030ee988408daa08c1258ebd95a35b9c9dc578e6e8792fa9563ca02ed8624c93ef294cf071676e784120d2099fffd51eca74a3e0ffa89c7cbedb0593f4bc78eb82e783b54bc8cc1eb7a3acc4a6d110935292f4b45ee47c629e407b91cfc2e82f09bbef0514f5cdd94d47c937c8397286885a8169abd63e9fdf32aadf517f1993846016b8f21f10ff500308f4b08e07a96ebd277e990abe10d2c77e37ce20cf3d0ba533dcdfcd35bb688a3caf303c07eda09fcc8f07a2eef3e96092fc073b36d88c5de5f119f6b5a6bca484090ebbbf7c4350fafb10850c31efbdafc23228c317eca3d266fc94d5cb074e74db2140af1b3d171d3b6f33add0fcc52bb110d8a3e0abf707a064a362d3316759d4116fbbfc12e697df5291ab3bcc61aae59acd164fc9a9ad14655454882411c694aab3e173f457309972b68a18b568323170c9371c7c41b7f8ae0cac1282d980d1a28f96e6be4d671ff3d549b3d39f8eeca02127aa08350fe4f963b1f17305263a00ba940cfc6dd7448967b2929959e4898d38893e64e1af6bc02704985f382a6b5fc18c28306ca9e2601150ccc6d78b47c1da8878ec3fe5b2a65defe0a487c9ff13f1278682b5a89d64af0f71b73aab6dba56b6bec34d8e94eda3fad9d772b003ecadbe97cc8312e2292def87aa2fd50933cc3dee2d821b8d86ad39721ec7be5f0a8e4bacda0ef300783af26e9292753053ec36e487aa03026d36edce9a554be44066e64eb1617825af79ddbe354ed67d4201469c4ed49a74d5fd91708b898865769864d3419d118453c32faf2922ea7dbd8f2b9aeb7b9f4956358c3e47dbce8fc77c6da3cae36554c8348f1f9e590f2a98c2dab0af63a8ffb656bdcb2e4c9b66b55dcd05f63c4d70c95a5bdb837fa9a0b5e6bc0a0047bbf2e44c00742ad3c31353c053fa159b263acd99ed1f3ad6400dd2d0c0cfba4f5a20a3b1d161964d079ed5c3e95e2df414de0a16a03477dd41e8069992d249375f6a69abb7a8cd64d957323ae8ebac8d848be34c51f3618964ea95db9f3ee4607d2a74dfa824683af6afc41522a6da1dcc0fcece9460ceb6cfbde613ee562e5972d2e1b6adf4cbef1a28b8cd21c3c21c729c3375313b92d148b1b21edb2743448047dc5ea1d0805ea97b273eb349afeb8c40a7477eaf009c4a91038ce2bd643e2df1bece59b00ed36c78f959cd20bcb43a7a98678c7624ce6b4cda303c3ed84d9a8417b119ee73c80135087013fa42897c1fd80712adbfb566eea157912d05bd4c9a56943b4cf2d7e0d6d2253d537b47c67dafeb410370bd7fdde0fe93b605bdad51fec8fd63fe4ffbde995859a2ee047c5754afbb898b446c9c971ca7b859f690cfa9f30ea48a49c98018276295f12985e803161c0a6a20ae4af4f60942294f28f2ca48f2cb4d537ff20fa8a46e1508d8c331028318f3f23274555ded8c8d433715f10dbbd91909da4e1ffaaf83e5020187f254a4866c6e41c29f1d53796ff72a24d428c51ebc9c0476e5cd3c688bc846ffbe649643ada13c340f6a38abd1a8c698f4dccad62551370c3aaeac89e6c3717e931ebba95d881643845e0e6cfdcb9d39e2710340be5348ef42f91caf54fba8a567c6dcbfecf94ec96273afc9e5114400c73c14eb1f459c721d870963d28811d0e40e0c6810b9a6e8a70c3a6ae56b12706266bd76c60ebffaa6a730d6d9a5fbc060cd680e94b2bb422a899ffb6fcdb0ed962090d6e95d11d57d8fd729aab797558e000125ed96c2224b4c7b1ab047e9e53f9079027baea456a118b0d1070b8c6b73864454202e008209f1c865860bd205ded40b1bb19afb3c33f91aab2e0cb223ce52c1ac4347ae0a314bfe76e7bc207e021703ce646ec6f5ffbf8f143f48817989ede403966ab05b42fd78d380bb1830592658cb9ea2b359cbb928d9ac89ed7d656442ca850b470b5da94992e556a9b074d2a6d81f84e430bc7251cab5111e0af8eda44aff80056397bf6f687d47fec6ed814fe5e49fc577236439fa55eca7824eaf0f066f21077555556629f2107aebc5973dba01158f4b900d30c5ae49964eaa04bfca2282cf1dc406e07d7a4f792aa401076ff76ec7f76dc639f13844d88df1f1dad72642d8c26e86a2380771862b349201a5534cd013231e2f108500bbf9342905d5e79439152ae910929977bf38e452c09478b3787e4f5f7d8c79fdb10bd8b3eea1d7a0805ff004911bc62f92adec33766a411a4967357120912ec188fe4608e9b3a56d1246da3ba1b661f46467dca6112fe4a97275e0f156e1ffddf1fd48b1bcdeedfacec19bc01e3291ebda3e0496290ace81e949a354f3beec33fd005d750f1716757b787ec8a434149846845894b15f3c9986f47d456aa87369d347fbd173a9ed172b679411ea20659e7d0914779d2291043d31c5c86bf14bcbfb629b79fbe8c9e93612aa5360bf730120f1095f78a7d4e9c8ae018e8cd3b195a990ded39a8bbf45075a47d986604385866d26d06768cf79ed0af2ec0aba168f0629f3b0444590f3873c205f113af2d137ed6d9e6cd3c14144b24db3f772293d032f4fc6f40a05926ab863383bd16e9807b0601e129d4d0081d6761f662ed8984ac6eee222a9c7fb0c2417f31254e33629df7ef406e39190c060d1cdd5687e7d0173750cc4f0c65f77d3ed83ac2be32c911fef73586cb6444e529f4af749ddfa075699f27e387836685d331f64c9c99f5a3859bac88b8771774330123bbadbbd4f043d1108e9e7a1c2aefdf65f744bf26724d986059a4f862f886536140add32a66f324c9f34042c85f4da6be2f6664f1411baaf4b3487026efcc7f7b20237ad625dafe3794f80eaa2c7fabe79aabd79139687872ab300488f2fff81e73277664f928da10cdc361b17341b60f8537fa23f18c7aee9354c8bbb3041c7c0ce14dd9d67edc00a012f32309c23aeac0201938d278531f4d74ec46538558f0a9acabf600d014af26287627b23f5fd98f175c8539ddf3d8452a8d13df40a8542cb4370c01c551cf8b50a4669b13eafab120604dadf652f56f128ed887fa3de4bd96cf7203a0f858f64ddf8052e7044efa70c4a147120ab60d2e753215871a2407f405ddd569871ee9459094705150cd4a2b0f9e4bad5acb6f0bdebf54295ce5eda079d034fcbe2418101321ac19fa7f5dac7d6f4dde34bc2aac72937f14f739cb435b39ee33eab18f9c16293d54d00879782968bf71b8fd3e3ea11a967c1da2b930276492248db68a073cd9d35ad008345040b0f951074694d019cb9fb3a2fd7e59decb2f1a3523c6d64d7de5296bb210eac747d2ed863b181de7d48051ee9dd50f65f66de995c8850e1a6cb8e9a22aece6c5e9637fc5a493f1fc439109273a7ac69c1b43e1f36dc8988f8b3882a9c0326af4c02f2dbfcab9c9ae6008786508b7b02968bbcf97f1d28032cc81bf0df46c398bc3d9a0c81db6d59237c082bc0195bb89cfe6bf1cd1adafd1629bbf1efc775bdfca0cda0186203d845c2c22c29f9e3da079e7db539db952cac71fea5852fddc457cb554ae049f242c7ee66faa8d00206115f1104c1a3916d61dd582e2cfaee493adcc9a00b6d12edeb13e1e28ebb49aa16dce4c5163403069068cef7d226d39ab037e4eebbe6ee50487afe4421cc196b28f0de7156c55fff99ba0faeb740969c30f71cda29b6f55b1918545e48a3aec9494d1b2bfe1be18f09cda49e87d5e5e190616f68cb8c50bf925cac9c6b4a18d4885a0179af70f99710013e255716734e1a501c198df854c00cd3dfac775c15ba7b35b2ea7e2610b6f5061cbd42f59bab78379c085ac6f49c0f8207d3ba5fd03c2b6bd0893fb6a534814e7682d3035b9924f2d4f0622fd97b97fb394687a2bb4f186cc1f5cab41db550f1f8152fbf8e0e45ac932dd95a46265cfc3892d260423708d8a40485d6f137df4b36361247f89870b1bc4b9a2f0fb80859c8f14aaa90c72c236e160f1e28b994d3ff521518264d029bdeafc5bcc35714ddb8e31577eed5eecb0e60d36f372bd603236fd3260787aea0568dd1f0721e754a9e83b87d71f39605a617be0410c16a82cbfd0448c57b1e529cba7a06ac1804f42502804c05186d679ff045f4ccf913752482c08f7dfb620695a6457be670f8a5fe3ea4014d39c5f7e7d5c3a1c7d6b89fc8dab196348442b80ea28ad18e6ce2942a31495d909f7b425baa91a894f4822d6f3abbc73047644004dbbefb9cb77f177161d3391de6fcd981c6d94a17965cda8f9eea8c0233f06a8a2e79fc530da2486aa8b960e740e0c5c4010ca8459edbc43d993e6779ed255f3bfbf348631616ec7432c4d54e084a7423e030e6d7e2e1c488a451298b5db5edc06a483cefaf137ee18366792c4c3be27f0fc254c2b1d4fdaeee76f24220bdd729114a10e25c981aa9f5c2a9a6e191c94e4e7110c8aa1a0c6982d757d36f69c01d74790c79ad4129383cbc5e1da45902be1082288a35bc7a3307aea780ef4c21ee6cd4e49f05fad960a22843544c70ed0179c661585daddddb7548da6d4a2979131524b33db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
