<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3115a700c55079fe1a06fd88ddb43be25d5d4333924510f5d5b554289d130191d55201e3ecd05bdb8b7bd4500cff058262d22e81d78a7ac533a4815b034a4d29ae1a96a4ca3512d4ee89fa7312f8e09079db04320ca5bb456116df9581ad24188a8c485e22d7cc6ac2c1d6376210e4ff38023da86352066f27884741f39b21d4e8c7df93c545598406e1cf2c6614ddc7cf4adcc6dd677b783e2fd8ac7a9e0235e8131f96274631a74e58055c3bc2538d498aea1f1b460ef78476ded4ab92296f5cf0d790156778adb95c0eb6a957def0d891bf7fc99c020db66371f9583c284afd33c42f786fbabe7a2b57e8ffdd8420703c786701674223b2cace9ada786c43c9314325e80518662a8522a3c26cce15d347102d0e5a8a67ce635549f69cb93a1651657478a5523c6e66627c427cb1a36876c80d413f2174e742acd8db4b714bedaccc429c0e2a169bace99db802301a66ad6a160ae791c87f58a057de5180a30d6a742633b4269b03115639cdea29fddead6dc1c18041e0d4d48a3b7b923494167167f24508753c37f9da761c85faa1a06ad46c2aa0860e1ded16fcf4be01d14d1b366819fb25cf9de7889b6c1a33b491ebabcaab72e84db34523106ec5b9474db8cc85f2d33e04a52cc1d77bed9408f26559eeafeffda39eb08a7ec826b4f808793d018d18ce1e17602df61e85bf6ef04a9433784f609fee94373fe520f3f41d26ef0303d898de9cdd53bad4671fa8ee24e3e6dfc6e663d0dd31eaf386b0b8e082e5647cc304c0ae06a92ffc29aa5d933bd714c2c809e0c2655dcf9b59d2c3d402d36d56f2afe887595957d386ee02bf978dbdbb5270ad2503e99fbda0fb35d7929c29c9dba29118aa1f699e6643569337b066692d1d8b52d84fe3b506072f353e148b89f29567457dc804eee46b07555906560e89b658ba07b1934e5ba62b5c7f706180e3057a758f926df2803df9c052eac4c3353d0dbc86858eda039be43a57c6fb843a2d329f998b5ead668470d1517d481a6d684ae96c3257f778a15dde0edd4400624d5146a32caa7036948064f147e2dc494a0981b8cf7a54fc95a62a6dbebf1ae09546f3fa778cdef61b5c8228f2d03e352442e0a0ecbe55679a2c0f1b1395036a3ca81b401adf40306aab5079faa330c9a09d3036332ba79f883697c6ac4f463010702a42540b273c45812723c27bded7fae3b4e0333db2b6d710e27ab70efeb128f407c31bb0c0e32743ae3f43085c123a15b508f24deb808c5b07bb562fa81f8d6464fc5afb70bd0000c2293a41298f7bfd0ca650d348b38dcffa69f49634d3a6c3821d6bf966919f9fc5332e4908af87bbfb2af1f3332d226f2d895cf6af90f9fe0d677d917d7ca6b159859f9f12e7f08d0e1473f51e1223382235ba7dc77904b9f1a35a646103314d3d50c6ef269d266aa5d387679fcd7cf54ebcc3d1caaba250d3a9b6024438c118373e5f596521b8bafe1615d65d13d8eddc42ecc867ad9a2a2d08ad8ede0dc5777c5e0c8a5bc750f1fcc252bce05d806c185561ccdd1898e08b27b9e4aff0ed6fafb763c0515f2fedf5e87eecc8bd05afe4a6b6153fe0a4ac9534d92c8ac8218671630744c02a321ca4f297fd69f40857be3f639f1c9d1a29888f2c75a60243f7dfa5f9aba8a2f7f4f0604d0b66aeb94298a0329d7da2349afdd6412da993f0718d398108f1c97100cf31a8ad581d1872fce7404b384eed147c23e983a6f67b93975ac193fe939f6afd5edfba6885cf58ba958ba383e25d6603dd23941475c962cee68fe0412a02c621d0125043582d1a26ecc13342d7d64ff9a56172655f97ab9e951496a43dfef0b7f7b5458aaeaa3eb03ab48903ffe2dd0a0580ac567c2b8594312f1f444312a9e45eb0c196eb55627c1a0bfe7dafbbc7f4f2b96de958fd788226d4420ac7d25e9cccecef900e78c3d5f5b63d05918ba49d87ee5b4fe3d65322621c760e3a926aa04a3a208531ba2fd95c149b9ed1bb35b5b45cbb9557c6deb0f0d0cf1aac906eb2fc9686ae29410c8cfd20285dab5a953180f9d4426fa158433caf4f0c37f4d535900e89204cd94b189a499feaf4d2ef6f3cf3f51f4a5f8f0d5fd743093df96595646307a9bf1cdc4f6e051cb2ff124e2deed6491972f5b2cdaf597c7b2454aaab66767593ca2639eed66ba84f2bdb5233e86093e7dfcb1844a6c8834fb3a40669853b1abb195793f446aa383cd98396893a2c9fa32c6426ccb01bc291edc473ba187379ba67875a0b0c53b0d9908fa4368ee0b5b2367b422b3d8cc5342ebe4b0eb36ad5ff19225aa31c7238ebc58128ade5660183ac9c71d2656b100786f8fbf3f1635bff6a8f16fb73f1ced87a13449918f2b67a0dca4f47b42c8c7b63a314b6ab08513be28ca294d3d84b6502837d61ad7eac7d700193841a52ce3e58f689bab7c114cad25560ee43c473991d810afc8b07dbac05ab3ee1af3d4aec82e96f4b4f4c6c8d625102c8099d3bf53d26b65ed997ab04abde790e6718a96fcdba070c3f3105ba865607143451984c7b16c87f859aa752fcc48ec98eebd8131fda6360d0874f843365a2b58a8c63dc18b736e66a2c87e6bc5617eea1f70d5b909201e5277261ccdae3ec33007c539ba8fdc83628030d338897405ce0aafcb445e333118f237ca627f434d1ac7348d9c0f25c5be77cfb6a9d46f787c949d9884c87cdc47f6fb64d64e5472767c85da166bf9b72be5f234bf14e0d13f62b5e05c1e133443b8e06195d42c5e4a4a1d1544199f34f28fa31f11dac63b670c7be5bc4abc8df6c49653576e4508d5698944251c9c61336ad16263eac8c8f2622ffe37b9eefeffbb21a1295076858fac9041f85f82b26cdf2c446f8d3ee0b922db346b9307cb26106780984c283e8053ef7f9c739b814ada2c97409f3cf1c6f93480c4d9215fece18bf450e63378963037e50a298c8d4913a644e018081d448eb6b5f93df51c8f1583a378771df88cde6e1b853aca265ff2481955a9868c5a1525a25d91b9a2f282482eb6fc7afd079f1cfb6f8968e64b4a8fdd6420f28c56243493181f2e2df443b6f51ba22faeb05eb95cf107e443cd0ae222a16f1ed5226543ba71b4c91abd671891885f8205b945b9c326f11b2b658c326e05061fa393fa09cc76ef983ebe8b6259a7ca335403cb70868fd72de8423ef01ca38858854b1b6ad1c1e7baceaff513031a3ed6965e575c50eaf41e7f3e785e3e94dc9e757ed7c5b45056799ebea9e47174845daea2813fab7f749da4a8ff6266705e86080e91f2687cc7ffc7022270654b3196b5c57132edace659a799b9c848b949e5d92268904d9a533418fad20c9b72accd016fbf87dfb7d13710c8073985de330d144f176178d840253e204677b0d739cf51e3f6d7e5ba13be69f53bf9a96497f79ddbe41ce180963f7fd00ea88bc998878e3a5efce273a0d54640b17c95ae3fc13abcf872f5c42824792fc02bdc8424505d4e2faad056145b391a5b8c20f986763b8fcc5fb2cdabc85226df62d9e009d511d11794dd6a9601b11bd167ff4d6de873442d3d8a3bf47883892f4b6425b7ff29b7c327b723df247c92dd251c1458c1df0fef8254a0a03ad3326b92c70aa6a41745b94c5d4710af1d1584a7a87943316d22be605685ce07abb53c1d42fc9ecf2ae500ce48cf4833ef0b75c2078ff5ad4da43518b1d19351dee1259ac6c7466599a9a823de233dd04cc9938315cc5d071300e6115aeaa7f97d16644d5b5ff8715e5498c7fe22aba84e097264c2c5312e9429f07fd3be8b3843fa729605ac762e0cf85458912788e0f66c757983dc43c80408b788b427ebbf0fa9cd2e2183ba25e16bbe3709a83df8bbf29d3ba9b086cb3b0e3becc2ee90956c198745b6cf46e51f367442d522d9a98ac88256469ec2543cd2ce624027f61afbe32b096c69c3fe70abc49e7e0198f9b06caf13f3447f799852113a782526d05040d619b86fc03840d9bd71ce4a337e95005b88c57af2c42f09ab5489acef39c77f44b7561f7d1c5ed3da6df6f06a59c708ac28916f0596abfd267fab3772e82cda2a6fd0b49dee02de425d1a98106c88bd8342cead9ebc95955685483ef9a0098f19a24ea3e97fad90e20b6a57bbde47992fa8bb9e99d3a10dc29663d9e69338c263a58cc37cbb2be5ee6a589246a91ee1335d9cf41e9e3e84f9aee29d54ea676ec628dd5fd0cbf07489fab3d85581861b347a0de60f4eafa22703483f5e55448bd47ba0a0ad0b79797e274476d311135f528d88ccbd5ead4b3b7e1353be99c1f5c4a3bff8867ab4c507c63b2ce2a93dfa30a65b565204175679769a43552dda4a8afd90edbca3739a836da2443eb4e460515cac2d8f66e965d4d5564872bb818ddef710b3bcd51282e8cdc88f59a8bacab5dc8ad3cb6256f1d3a3af07693c026bad0efea1d8eadd3ab637e0444deaf44b643afbb9578a610721d1b05db5d8bb177ea43f53b904ee5fca54969410b24c912fade4671e962429f48227e6f49f5e3aac9d4cc733f00de40f754bee75120f610f34135735bf17bf311bc2b0dad7ca00fdd8734d0a25477498e222fbdf24fa200e52e4986f1090b4895398707149b39824d8d1cf52dffed8747be44a3aa3c7188810ff934926b75176491185557dd527f4bab7616ffa8786abec2cd65611585cf9b22925e6931388003bed9175322caf92ffff5251ea3221742de630dcefd47d3a04f9e0bce2313936a99ed5281693c0c0367a940d0dc953777c4b87988d7daf0037695f4de2140ddb2dbace8c6d91d7e63c3b0045f78118fef07ecb2d4fde9abc8e77da59006d61be4878101e9f05fcedaf75816a256075a2734de62a503c0cbba552b619d56042f72f08a87f4ebf78761800b0cc550e901103f7289347cdc8d189fa7aec40229260abb4721be5d48ec1234a13049194a2210f386b50d14d33daaafcedcf7ec79cc43760ca716ede6cd7677e31b286ac8f57b457d87503e7f587df383056bb00eb62e8fc2105f4e11d0981f376ca57414c583ddd1ee741a6f1cef62b89f3c75ed12472f7a4e4c173e9fb25588ea51cb07dae48e5c823d8c82ce0cf47c2b23ce0192919864de2da3cb055bcb6a9a213c1e97c08a0df0841b0f7351fd1bfac0d59521e59ae7d36a9dbf429754d596dd115497b0c9950e7404e300da359284195c65f5588ad9878808f7ba6cbc7bac5d6d2672b42eb2d946cbb91726817af78e01d8cf61f42ae46a10521414ddff9bb03a90d252df28454c3d37aed5173a0c1bee8ea83689ab38a69e186eb82884984a4166c5f84e9212a53d313e4868cc7dec9936949e1d9355c2725fe00ce33a6b96ecd0baea2a6c1ee6dc2d57f51056b4a3d3a3cbad3a5e99240d1c071f16dfb80717f7d01003b2d219c8e07d9b1d19f6f072add0842b61082d6b021261caffbae192e78dac8d17013b8b8cd9715a2c15f71b4a0cff02f6b7d4348222494074c73d3767abec4231b3b3c2460a12cf1b3100e83a43d82716c1f2365e5b2fb557034f2b6aaa1f35a7d9869913e8185ecdf7c3dba51501cd842b516ed8bbb78d7cf3705bd2ab328a11574541883c4641d05209bd4c889d3c988277522532bc92a1fb42fda736458148394f47720b1692edca746e2b9d3f3fd4c74c7dfb21fee713c3eaa127f95808fc81c6e623e0a10578de7d7ce98f2477f46e834685a85ab0a017dbfcfd42044bd586c016d01ca5762e61eb903ad708134e0c5be7be77cfc59d262a77be191b1004c7f5e86ab32e7ddf52195d485c675141e05493624509ef666333f09650febfc5e579fd0b7ba74e0fa2ce347ac82c80e713b79a93e673bb4f20fe879918d3e02d6c705d8b8df38265fdee268397b7eb7356d642559f5a2255c6165b8b5aa616dfa861da61ab09595925faa03a67e2822e22f73193156f6b4025245657245ae4fb086ad6d5248b43ec43dfc463c07598394c5095867bfebe2d20ccd3c7c78ee50d6aa84af0cc21fcc73e2ebce294e623c0537ff28e9b4a38f71d182b9eaf4edd0b5550c382903d815063830d606b8c59bec5c4d49da2606d6d91174aa753b100f55f58cc3951158f09437eb552b6b44f37c4c874399a7a9e8511d881b348bccc8c2cc7308df0d975be3663951b9f971df663d84e32cf63bd1de2bac35cf036f5f377177cc39fa2871b7988801c5f6b7b38ee30731df18ccec2fd271b6bcb960075b498af9fb9711901d5976316681bd669b32f0f2b59fd5a144150dc1c564fe6a6997c72ee2b14ed87d49727d20e7f118baeadcd489b882b1047396f44e50b8ef025a372eaef661da9606838f4f0f765afe1d72e738a9340117a0302f06e0977145c83299f7f29431312144affe16f551f48f8e9d7cc67304a88f5a041272aa95ac3844e9aa88836161d080d6e227bdb160dd927d3e9e3d2c032f7a21ebe56fe4072b52df4efbd3e7afac07fc90030bc1369264e72e9839893e676f9ec90b8e980e713401dec47d1c1d77fb5b188f940e744c674f20707c6901b97969da5a338d1277f934ec271ee96463edcbfb9d6c1984198d76c709e3e2a7f106b2ea2c17a217e7bfb255b7075b15fd426548fc0f3aba2f978561ecaf96fe14143ef3cbfbda79307dffde2e6afe2daca9309fc968d34c800329129093825716950d70642986090767430bb4d1e9d360f5c956e40cf8cdbb753d4ee59f7d4853771fa45956a56b42b659c6c6a571e6d0b8bdc406dac861fcb4c6870cd0f606c03bd0e9cac6cd155c7ad3fab22bfa2b36370464fe2272a8715376b840339514736de050f8097f6ad1032e1a6907986ff50da019730ec97fc7e7a0356678514a8c384accc5d7e192e7d9339efa2eb7f20022bd69bf306272ef8d113e3863006f019220d20782736564363449b859f2601a72312984c42d3d172ad128861fef9c8cdbd1adf8387e24f715a2ce2c0bbbce8f9e0d8436f95c7949db06901ea61f6e3fc3b573b111833a9e168b7b1ddbaee39cfb383015359142db306b236d2897231f5e61c51f0f7fada15522504b6017b08c61eb30e818ddf7e0c5e672302dea96ac19e11f1eb8d800e4ae30d41f5688e71a9f882d54f2beea7223eb843754bc999ff821606ae26f5df01df87cfaeb7c5ec65e63bd98b431c51e6ce24962c3628e60d1d2169bdac2a532219360a607c4985143178b298483ebaa8106097bbb5f973ba1299bc430e042ae9fd191047f59af94b65c9e2a9d9bbe9b5c27c04606ec6b5fe690610849d5287cdc30d5e82447f69e27449539a563d986c0440ea1e1b742d9a5f67f3727b34ab38b1d522f65616a01db9ed1a8cc64d247cb57271d5fde71f7e7d947306be60643eb974a8b6ccab0e57116db0c8106c49f97157f05c524cd77aeba513e1b25e3c6c1c637170857d758bb0333b7bec37ae5c8ae2faf8447482325388da358644b2d29d919a4ef758211dfbb44bf0917e3b449d8a28b8b777a5f1e7fb628bd224e83137771438dbc37608f436d77552a03a23a830b5b2198b392c36a838b676595ffd39e24ba6ec3e2349aa57dbb80cc75fee5cf2a1e49168906b6b1c540764be428e563c637632a8ddbd2aca066957737b625bf20469431d54074ee370a2fe24a83304b4bba6f8bc175dca1dcb7814cfdf9a612f2f88dda7be73502edcb2d94790e274fe8de9ffb20b2abd80123d3b9b125dda2500c8dedc96cd1f06078aec9631ed722fc4e72887a54e1d3a6edabdcc8aff0329224a8d6cf07c932d9931bc2867d172b659384854906efa7404aa5ff15f6fc06e6b7752a0441950345dd11e1970e55ef31d60efb4b358d0f9b9235a34deb9aefdef4ef1007b254369e99598ed2b42a66bcde8b84d136495614524b21b09ffd7e16c9eebb27cc5c18a5b6687d3b74fe0755ded662d5cc0e737bea569610ca6525e79857a023b0c428d6ad6c1e29f0d88e9f4b6032b1996450a9111eb750b5aab08e2ba797eb5b0cbec45cef94b83ba780cd0f618feb36281ce5f8a167adb73caf234270ae098ba42ee1204bcb6cdf76c3255f000fd31da4d205b4ef55f6dfdbf63c5daa6e0da59ab5e85c0996b331205c59cc5d08e3245ed43c99828555756c4f0253f873d85cf56a7a85996554a274470c818eafae964e3bab7d69ee56bee2a67d15a9a705784f223b89eaf4db4d7454e56d11f0334fd122942200ce02c64f5f9aa3c1200b53677513d2a6bc34df1ca347e363194304ec9c65f5d7028a8a3f32ac2bb08c4b5b3e1491d62f351710573ef05f818c0bcbc966b54e382d0a77ee3c4c974c2cb971c73af6d67238cf48a0331a341dc9de69148920e48a08092d9b96f35e91bfbe8f65ea6408f00693b7a9987b3b2e086d282553eeed5dec877e57b76a70e47b6da8e6c8cd05cfa811e4d0958d6d1db9479026e7ef133d12fb4909612bf024901d34833d41c2c6f87af948e15a62db90b3942a1b0fbba489d757ae07dd25f29a4f1392fa7b56d866add89bf82e4c4cdd5f203e88aded07d8c824dd994272062e835e49d0cb52cd151758e2e5fc9ae8e9cb1bb07f1a46bbf0d89574cbb155e3b249f961bfe7391ce98167d9249f4c9d07edc26a36f45f508000c794c1bf11ad11c7b481d20d0bed77b7537c96721f8633dc9be5bc1f9f08f2bdadd7afc9832f424715b30bdafbc38395f5abaa6bbd7a37bac5bf50b2fcc32a456b62d7d5f9435640bf574f7baadd914caf0caf379d5a7bcbc0278abf1b73e31769ba459263adb555da8401a8f085c8c82541a685d59f55ce80ca496a5e4f70b72968f2ac19ff598c48d80079e9377aa1fb44dba18131711ffecc7ed1153c45fcd703bc928e37325754f3ca86a9055aa5ffb87309b1b8b40ce5c2f6a5216aa11d5ab0eaefa4391988555648b2caf860f7adf59eb5d546292d4f03b31bb822f839c44395412ba8ee362ef593c4b12d050bef3cf17d47e5fa4a8e3e8b1974de29fffa0928056a4ba927272fd7119187b862588ae7af12abf065f85461335a95f6c08f5f1ab750215ebcadcd1a47f2c6bfabfa75ab3fdcc2eee1c575c75fbe5d91e5203b6732aa443f325bfd3e802397672925e762b035e7fb75d934232ef991b59417b1c3bc17a52126272546d68bad48ec7d40028886dd85ae0cb98d3dede3df241d8f585d78b72c13432df9ac460d56106a7f407209638b756e9ee32747c97e2adcbeedd3579c8d6d346c3913d5b1e58bed022ae9edee88976caa76368bd592d18f9c11c9bf7e30e74a0b9c575b5a83c77cb0c577878dba2014f7a187e26fea1f74c3ebff31d681fbd18d05be9ab50c964c4490489fd72c4a3a42dfd20c0bbd90e8fd6a2a60738e12556dc0a060b313f2a026d27731f993aa3aaffd807e974d63c379f6de061054c157b241924a1fdedf93c645abcfb236405bd135f4b3be92eb529b368ddeadcef5c9f08d3c125f2d863af43c2d0ef6546b868a9926383310939cc2d40a435567b7a14bc74e5ce24168cff67dd05df565853846ccefa0e17fa4927a1dc7a00dc7cda7a2fdc5a56557d4c586d993c789c86708dab104868f92f0e25a16513d63f4668f6533348883fed785e5ade8191a14c0604d5307505d2945daeacf9bec91d51ca6306f8fa36ae1ef1f01069ef86955e107f07bb0b6c7d3292396862391b860aecfef29e1d7a1ffbba97d39dc76ee92adae6d2abe63dac660fbdaac96e43430d43a2ca28c8a2a17779e0584c6c8e7f2fdac134c2856c508c387ddc084ed1cc6a6c9169075b59b8de2d97f4d1f6eae1f89cee0c84aa4f1129e2eff21f5943330d3dfd13d1c1538858511e9c1c0d4983ecf3199ff65a7e1582d9e7d633629aa2364c385df3c5a7bb4c96c57963e90ada26db4d86fa3847e8a482950ad02f38d9fa410958cec5950447ac5d4cf0521320e38aa6b0c3f718ee9bfb62bfe8ca5d972f7ae947345987452867ea61ad8d3d357960c4156b9e252044f37b76340215758edb88fc1311a03bb4344d2ee70feb25f8143f995f3f4970cb9fe4a6d6c9692a9d60f0e0f79b95403f87a968e52f7eae0a6d3851a3c63a9634f19efce6198b15df78dd4a39f6273f4caf6ae83e4e936fd4ef94b919cfea39d8ca681adf920a0e117c3c6f57a9e176e76778b8f5d554cc61993d2a95c65212636fd00e979c1dee81a8fee3afe529c9836b19b7b8906561b9fc52d0d57ed16fa7a757910e6ab235c3c9d1d1c4eaff3799c372376dbb8629c806ea53e6c785bc8949e594417fef5fc425724f66359a1f8a7da9e1a70753c0284fbe29889a98ace69a18d0f13c323fb3d5a2cd08afe91e286a79838deb2c51aeeeb3b4a805b285b5e34939811783b243f972cb722b954c8fe9f5588a38a1bca36b551beb840bf4d68ec4890fd006ef53704973af566b0eaf1bd5926ee6d0dcdbdad740328ec9dca6a4a5478d3203837916c851af226314e1d51d6bc948d7c3c93f3f57c4718c9c145ebd28c1528f0dfbb17e3ad746653ec9e8ba7a4da6dc3ec2aad876937a30d869998d70ce6b2b321a5b4d84315a36f401cf901e3e42f6b7171782bba2729aa71f1475776a1e429aedef21eb53a7aa161bc320cf263cb35c0a31967aa370f97658085cf702a505c80d3fef40d4fd7c2543b954c5df5ff3ba352d1dac090181f114100854bf20606d4b17ec9c4535a2925cb66389234f7ac425e9a36de4c07b353f70727e00e97a2c455cbb216727366b74846fd4bde383b6d8b8bb059db8c896acd6a5d5bc8034d845491c505babfe7c8d98d7e072afb5a2e76c1135b05baa3d60067de1c7cb3e3459a0f926a6fe4a8d168bdf625eadffb33458f5ec27c2e5007f28193cd1b1745f4aab7614ced39c774ac11fe56fa6698eca9b092955dabe017090f22e57dd4c3f61f2cb6546172c38ab128ee6254070891883ab9b2407b3f262266fee12ef85ba598977e8ebcc73ecf9d53e0e2b590249e21c710a28ac67f05256e903c26366e2570f29b141a74bd3de39025d715488c7dd8fc2aaa4a3bea9d13c004127bd5ac789213984d5ec386efec611473134af85fe6e3abf674301f63fd69e89aee6845d6f80298cce8aa19582e8eeeca1d2573e818bb26885bbec966ada7800c56c84b42116f825e9e63c9f87470e41da9b67f4d3f5dc0a068aaf98d880be338f7b9d8937a64a0fd494e062f02156cbf245caf9f1e270db8130519f58459c25b8e91df9d044aa485cf00c1c6bbe8bc7869116d26e147b3249e043ebe6f5ad44cd9e7d7e2b254f4ba541201cee0e29094e5eeef674cbdb777e54d730075905d2cc5ee285bc26c1bf82df84756e180f31b484a9666250a9414450e3e5a1b89c7230842c447b0d557523dc50f85c671c27bb9ceb31497de5e1fb7f9793f7cdd1ef685716274f4f5483d8f389d5bba6d29c98b8c7e1f7030bee639d67f8ec9f99d05d5d4368cd0ddf86a6befc94d742fd06f9ba2310a9852fc219389337d5173bb4406463c400e4ce091e94ebc7648f84ee272c6236f6108320106337b1217cd31c9fffe70bcef98ea6576bf463b139c6b19e5efa98278d5845d743166ce261f759b3ec113ec51f13cd86254aaca03001b4176581a0aee64dd3c9792af8ebd187de457f89ebba1e3cd4ac0addb1bd3d6e5cbe8ab43ac4b94026ea88bd8fa87d450762d951d3fe834bbc0af3330169d3295741fbdf32bc3121746c09913ff8337e94fd054ea7a865a77f7815a22324e58b56a05cf6410486cb649aa6652a004ea2c962fad5fafce716d366a72ca919a765b61ca4bfa385650365401ae942dfb3b5e3281767d8c395aa513d6d1d5a2af35b8b55dd01280ad3f346c8a7c0016fb91f057a8abb812533faf710868be3ca308e2414d77b4760f88899478da1e03f71f1486caf61d0fbfb8b955e80dc67daeba22d9faa4407a48bfc4c59499477b3bc1c874e26c0d74ff4e9badb1992aabdc0e026e2742a369c94e1bb2d020c7e0e9cf707f93b6b9dd5a125221925901ebccbec9fc2badc0531cfed5ecf9f0cfc8b516400bc4574ce7fb27878fb5b663ab6253f58d0c2cc0f1e3fb713a34cfa7d0bca3744e824fb938ced8b3bc4567418e4ec2d96080c060bfb1a6932dc309da00c0e74002adf347f9e07e1daf3d912c829632a08dd4c61b41f751ed14113d7fc9b6db405cc58f3df319cc20e5a817860d1efd7aaeb16bd101a4ef41fd27384a9a743fb58aa476b77238db1c3a4568472fabdb0ff75c410d7d6c6f0da8d2a5f378174616a6f6ff1a5a059abeb5d6966c50dace70c19e9895b0995085cf022eb35ef251a177974efec8bd9cc738c93b9fbf4f4b09c78cd3d8234a0ea247506233e0f2958c1c15efdd8c31eec8b57b23a5ec1a4fc48f292c2092785898e99e60b372a013c381d54626da443729ef72859bc6860294d27a57a86168f65a1b3d375f3df497afe465f2a2e63bfeca46622fe196ba6a05447e1e63c5371995e7b53f6c9d5dd723cf2911caad335056b4fef6c896c2cd89ba43254f1cbf28c7560398654e59c7f9f4cefd711fe6262c001d9cee020d18f6352e7d0058bc2d879161d4135810c63c83ab333290c51f8be30a89db1fb836e0f47cd424af4141a7d1ba87a2c33119171390e05af32d1fab86374406b44c96403a806c8ff130a4382c111ea2a90c7c6461d0d1797d5bb3ac2252fc098d7a97dbbc6ebf6ae6452f1075c2baca3de68c6c8a83f9afab566163c05a5cd11842da3469a5326744d81082817b065a6e1aefccc84edbc10fb0e91b56b634ee9c0e8b334d4cb9c7d38be1e644305d5a800f73b263e0a0ca2274f7c8b188f7830dc0a212af7abd1908dc6e1fca65b9a9ea21b68211f39ff25eeb9add83680b67db6ebb39d5f75cd6049445fb6cc999c3d5943c19ffe1743046dcd7d7807e71d9993dd66a8bf8fc32fa55907d7d099037a633f215fbb1a942ccf80712232a24e34b0e6489e561159896ae6c5c3e4db25e8de061c7c5575a8bfaf31dec270401e84be8bd9be8fddade51065cc9f9d7b092fb35a893706e2a4766caf107268503846349711cc349e9751888d422b63339af660a8c89126f611473d2d96953c7f786f1a9561c6472605c5ffb5465edc49a86c58e51c77ac88b438ea19e8504d3ad9e479b007714d7c7756c2f95c30792ed6fa6eb144d0eb8807686aabbc40ad3ae56c5ec4fea4a63d337c3d2035ad10b78d732e808d9d93ba392d7514b0eb6acdff67d72d76328123495b997c192a848766b11a87bba750a8d157ecb56decd9177f5bcec8924e710b6c3d84dc0c801fcb1020696bc90b662e14740a29f180a4ed89a2654570b90f347760f41714ceaa5786a3d98055b9565c07f7d31e6753cc18cd1a66f828bf1c7a57710160e7a1685349287017370a0393401101a8cc78b43813a7faee2bb633a89814f9626593e73dd3fa702a77353a7d877f007faeb75e250c679dc63005ec069d86f4d22ec2adb550e6c1007fb7917e8eaeddf6ea3e7a3beaa842388c6c2b5fe99eced9004e7abbd2b808abb2f1d0d9ff55c9ddf66045e19b3cdafc9b60d3c1f7ada7f3751783acd87b3e645599f9eda37576b81cac35762c618155748e7a20400fe6477ff28fe2e169e105f34d793f0fa97c43c1e1ea2f44935cbcdb258aa1501a719b463492337e8835a337a99c72c0b8d1fab200c53e20231fc23b4c00f59bbeb4fd4bf89ebab75c96ea61400067ebc524c56de7b02574e71019b01e7d2df9903743f71fe25ce081b8bdb2b759f61d7b49f7cf3407eed05ad8839a99060c1cafc09213288b9755bde2264259a3530e4cade87fa56424356731c830c48d4b66d0a1241cd69088f0e2c6432715351c228ba5449e3bae5e866a37bbc9bf385574b4ce594cc4905e46a42c7964aa0f919169adfd61473adb364751ab6b5d87de81ddb344fbe7bbc6b4230fb6df5e1bcbd574157da4c2992fb00afaf8055ed7dd6ad606164b258800a886a616408f3499c886d710188e9429856ac6055b0d9e06639df52f10a343e3fadaf9c8ea46d8e7fe29ce9c8ae6ceceaf02973a43a66dfeca5b493f7821d82221ac9639de88e0d3a7954917e211c14458ca7051d80515feb1ec74c6eb0834b0411f02b9dc5b0a9650eccc3d84934f10722b8b93796a8c8b437d5725888a71868f40acbdf8b79b8887cb8f36650c42b5baeac111196e1f07eff59a51da2c01e90a40c44dd55749724f8a6a03e984b7e73b3f42cf61f9186ee3a5bc836294360c4298d40eb7ad52173a0bba2a7a5dd7d26678c2e105ea33c10b89371f6de2c8bcff693ff151ccab78c3111cc62888eb52d516ffdffe5980f0a337bad59f41f168ca9c54a83d1d6cf1c18ed38a683f41fd6df39c727b35d36013e80238bbaf587294e9704c68148f7b25f05b06c3081b0834be4ad452a1908614364e787b30ba6f5cd3f637d08846ad63809d457316d93635959be946d54dfdf02ad1f3ad99b347466a068a228f64beb073c25ad5f18804473a64aea158a8d91d951ec1cf89a7dee6acd5d144f4ee1e655c27cff899e61480f62de3342c7145045b2127313a7de65c757c4852373c1e15ff7cbb334c2c95156a75ef9cdcdd14587e74805483a78aedcdec997a876bb8d46d5e06b1260d4e373cd33ae5ac793b10728599ebeee0694aa612441294b36b9cc4cb47b763fad9962691ff9e501b3404f9455f77b6dac1c3f08a34c9a044d5e8f1bc6f5feefe050d3b850514759b4bc8e67f37a7a2fa2dee107bb950f08e9c48a36ac43c26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
