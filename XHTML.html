<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47c30af13bc3054fb694b8f9e529436c42a3307a67758c808e8daa71999b27bc7269bbe2869a433005fbcf63d157a65a74188d29fbce27532c19904e690dd982dbe90ef5fde5e8cad4003a1641cf2e1ecbe84a1f71aed31d74e8d0a6f3627f298229b359d5dae127ba66b75865f810ce29478c1e7f643026be7e16f1efad6b5d7f19c9d4699795d3cfb40d0bdf750418f0cb6c6e733a7e906b78c0549ce12892a6a961ec350fdf52b88e67822c76dbb05d306775b3e2062126856194dfbebcd33e29494199db6dc0eabc53ffe2141ab1253e355b7f8fe606f1dc259f357ceefa78e2417d6050b46db5701cf99bf7a063f5761ac5407447415dd31fece2a84a4fc060bcffbedfe16a07ee5868a61e82234777a7b0ddac3ff2fe7b61ae51450840442d00056b9542cff94ddfc4e4dfb24d23d7e5ad3f20737df54ee8d3f955ab029ff860de7deaf24fb42f9b2b83b9634b9e70d02bdaff54f3bbbf3ae3f79d164223a8c83ccde9e940ae8eaf773a88da767f58aea4d79b1316271f97b32cf077063e758f9c98733e44de6da3de45afb57dd73b1e8b20eebc27d78ef8388cbf40fc4572fa9ad49ce4faf771c81b4e5230898c40918f07df6fd798094c37d9e5789ca4890bf5ebd9c289ff86b190223a20a207c68583f5d29dd5e54cf82e641a478d0dff0da6d486d3526acd3c23465cd01d92c52392a3b1c123a5bf7740ad7751df8f2553adca23640fad172260229dd2fad5dee918903b664a6080a9e4b7b7cd7d662c2776f446105d40dcaa8059afd2de1980bf178d0869e2df786d0937b5c5099cf0f7e220da03fbc1d0e6a2610dc5c3e4b0195219c505dc5d36bf737baf58b84a62f628a83fd74666ed83813388c56b81ff1e69476ebb39d62e10ba250d04b51f350139d4dc2e5af2372b418689b2fa836b43e5683734f3d643602090bd1f4445a434d47293e8600b1f1f78c2b85b9723abe4d9eb54a399db519c06dc7fbd889cc13f0fed0965623d6d8229a3340c2ee1dc2040595e1724933ed5686611c9067656d99da337e2398c8d17b99eee8b9dbec79701e077e37021de2ad19f0fffecb46829e2a9f3456834c8fb927341fa0b8f95d054fe93252e11c9d449dc45bdc2fc723b9c17eb683e676050d77ce7a6aa43f7ecf8011e1c046c874cf665e30867fd580dd9a77a0419d1a4410984cae05ff58a5f9e9886a71d82cc3f7e94c44a9f7f3f58e6bf2299537938dead84442730f4423e6a37e58e8b37af279b98a4a97121d3bf932307b4135979b6a49667a382c28634d93708620931ae0cb684e569c753c3ef238e77d9a9977cbe2b0021c8aba8735e33eaa4525c440da9b87c2a61e89e33e01b4749178c180cd0531032d7178589cdd9036fafcafc77267e55e1984326c2d7857ad54889c0c45f616bdd8b8b91eb5975d0b8d9fe864a93301ee555b6c5535e6b73378812c5bad58074830cd66529f6e35542cef95ec95cbb459b6f3497b9b5c753315773b5d7e323cf9e33cddfb1ab35c6515ebfd3b2706dad9cbec016e7ce9b8c1b6defba14a6f7d5b40f9dc3195107f0ab0f63fe192949e4be9507342df0b70e0c1459ba43ef90079344c52fa647e2d4d99ebbbf3ec6a2501d5a95d19c22edff3a31611b6ca78aa31f7128986ad02c760f1af8624e82826511d328e7a7c36553a155fba11aa1ede3abf781535434f11b08c24b2ef94ead88434577ef2e1744baa78da464726fc73152596e67a63f85c0852534751121ee5477db8a153c644ab935f42c465127c72c07da3ac9c1ab875a2d7d1965a75fbd797efb942ea57222a92afefde96bfab9c7cef926018a444cba67642d94e15c4e3bbd984d6a0dfb24da9fb27c99d45f3c511deb768981f1c1af5a67c6b23c92e082a17899a837ca8fa0f973f74ff794c1eb82da927039b88ebb514e17a021b73af8d902d4190e79c22eba53ad8d67cff9664f8bcc3a95005d2602315e926598d517bbccbd65d9de98715adcb596080b116c0807ed813c54c624e8c2dd0dfd3da98640e2ad5eb44a03fd5e2c820faba3acb445c3af42f22f9afba0a72a123a69d3506d8be2a8ea15a1eecb20ba3f849d6380c01051ff548b5330dcd3c78af922e9165699336782d6bab7394176c8ac99e167a000b33e77f716eef1c042551aa79ebc4f6e9a40cdffb6f2d15e762f462e5b2900bb468f9fd0c2e02f39e4b5f47d9828a865164ffe127b345ba484821dcb8317b0ef251fa9236c2610f635e4007fdf655147d015fb738975560971d646b1d1df58873dc297e7a1c8ddeef4e030a8126d8b9fc2fa72f8b71e30e1e826552a2c514db073b1f7837e22f19b689560adbffaed3cd72e95913911fc39ff0ca789dded5e90ccc84f432121f1bdb9231fc7b30766db14efa9eb78b3f9af86b930b5b77154136e29adc5d3d7b671f6c5f6f0d9294bb5e8d5a955fe79cecca51de5d9e543d45b542f1872b71e7bf560565094637df0c41f113aea2a7cda17c9ffb7e352aa5db5d9ab0f08766f3246ab7cf705b0a77cbe8c2fb87b7ccf50195ee29ef8d03b20d83f8ef788523ea13bcb96579b21afbbb81e8b4595881d1302ec4fd0bc544f6bc794209620d31be7333ebdf926bccf4de9fdb32ecbd6a69d59c9f17f6138c25db7054d95537c80532066c1edd145da64d8ecd746eeb9a203e039583dafb0fb37f827d3cce57a9b366468340bd20cc4ff1e1ca7b4ddf3af3522299bad9e7f3e10001f10118666e71637e3f4b69f883ae2091936accf9839c7dfca5ba6ae67963195cec28630af4d9fc4da06b2c9749576cd200e5facffa6769d8c8169e7237c36b144afcce94bda5987084243fc159f7e77f6f055782189bb9956b2526c9c2ab8cbb7943f0ca06a967b4e65003cf06a2871a179be18b6188f499c92451485e5e83e3d406cb50616964a52663dd9218ef773843e4eb7396b62e4d41bdd47096170e8e4078e135cb7cce791a653a48980d710b1afe5d0c5b71a02e766a39c19b665e75e2056b8cfc3ffa126e7c15adcf8a78d01b7c17430fb3c52c5dab59939f5d9cfe95b4311ef58db3b2666404092d0c46957c6c2ea94d2e0526f406e7caeb6758c874938f5bdf495c26f1c478a75afec9d0ecce4d5e12a5a61441926a2854e6ed8ff4d7c0ea874192386bea73091a061ed77b6b908e422443bc1d87bb1596313168e95b5cfbf4fa72997635ca61648e2725944bdf376e5812c013930a62dcb2805adea76f8c75487cc6f70fcbd0fcc1846206e4be56b0e19c93b35befc7a5df9f9d26f46eed2957119caee966a30ef2b1e324f5322d93dbe1f575c753eb475c778720760ae6a93b7119f54eb58b481289664fdb1672ae87e3a9d6c110177de7f6b7314f30efff7dc24d62d9b6a2bfdb23a8276134fe484c7bb886fa52c70dbc8d8e769fde8835b29a11b93d4700bf72379c85de1025a11280a675cec204580b0be31768f40641f30153a0052919cb01c9bebea404052b4633c317c0236fb281926dfa6a46e4607d464b748dc35d9e01aa10bed7d93c784900d3236350ea4bb5dbe33770455f10ca6e31dad4ab308d56f9dfd0d55d54c33ee984090f1ff43a53bd7e4e664b47b811d44347ef37821dc84413dc60dceb79ccb86a1681033df61d28dd94e7c7f55b2a27dc239005bdcdbdcfdeda6d9344eadf0ea0790e1bb2e93c221af928f5aecc7284c3631a8a4df617d4375cf53fe95c39ecc43984c5e1e0eb6a616db1450ca107a5a274a6634d5d9b518db6a0020d7f7b470561572b190352e22a026099ec6601d64dcbf8733a81a9bfe68f485841005c7145786e9ea183990110b192d6b08050f39688829898c33b889706ee7e6d096dfa5a32b1b5ae4affcb1b9baa0bae0aaf7de02d2115eb2cb4c37df392e24995da7f80738dca01db17d893cebcb3a06990573b00ec38af01268f2eefb0da6db1a352306c8fba9bc78c7e9fa30dfa41b21dcf26a25f8e23a06f64d7cf8fc19ad908ee6f470ac066153f81a44c0e1ad8e665bd812724dcf491490595647ec5201f08f0f34e9c32b75075ae16eae781f75b6dc0c282f190b17aa3209c6ce6b1ac8d52afb11cc52219c99d5447b32b1f32940a4bacb83442997d1ab2a687399167b84836d1245a1f9d7fb68f1c28b08290da5ee57e6493166bd0d195ca424109e85b598d08d461469473695eb0c3344d736c502ee08dc19893af1ed5e72bb866c41a468bd048c95f7f8d5473f22009c0cae1f6b35713df93dd4384da8f1ecb4240cf2bfb7b33d1700972351e4273557cb6579a0d24230da1ac94ad2fdfa58e26472cd3cd627fc979e61bbfff90f0205abc51283d92be830da1e9dacc3f11977a4cde89e14931b3db2ac2602a9d23f3ccf27363d6a225eb3888f917aa9c9774c7e422490116cf8ac1d9b41880fdc6f779e67248d722745f74fb171075697dabe0c403b6863b715313bd830ebafb42012ccf0417b0c33fb544af687b1110f3945c350d0e6b086e2692a5366d5ff299f4937b9a9c737a9104cfc7d1ce6b7f63739b83fd9916b6a0cdb60a4a135e5bab4a86509f18b6ca663c76e26efa2fc038096f8eb489c04d744cb63f0a976e1f27ee4dbab0b6324bb390f61e478c8967b97edf62d42cdd5a1b65cc15ea2156605bae8f66f809ebf6f8c5b3ea6f42984d138c5a68a36516668d565fc58a2558e57ed5705be330c61e0d0334a9085edfe3d65fd94f20cfd7a38eb2dcdad4265d82b97a64d613491545a079e7f493e66f030c32a218a6719b236b7a396ea920deb1e59efdbcb6a42183d1cfcffc36a821fcef20a6b0299d50a6a7b291c709eee03487a52a0dedebcb21b6692824d152c1dd0140d4342bfe18151850843ffe61a664d7e95ad8cdbecc39e5eb12841d6f2aa86fe8d6a80a036a53e452bd7c7dba2fd049edfdbf34f17a25abbe1fce4dbc9ebf81abf7c5955589f6647f2e77bd9b5938e55dc1efda55cba486a71b77083851905e684e8669536741754ed0965943c0f6675f3c5f8b1ae026b38f6841f07535e0a4ac88ee2e40fdec7285d685203d0ae168379c154fd2ea47cb0e1d4d70cec8355742e477eb0b8141f610b38201d48ce1a7e463bd6e6d2311916fa394c16a30ce8a57371fb2ab1f89c00bfb841f3c81d603bb69fa9812dcb5ab118b8fcdefe10c9d9882a4e906ee877e6995ece90888a01269b52192113aee14b969660e8ca2b3cca1ee0798926756b0beb53b0b5a573d64d3e8be13b901f370c4dda0c51e2cc1d0a8435338215116fe60fa21147c093187beb11258bc26d4653e0613278259d24d932c29259a3f0862ca6ae9c49db46c4814a774b5a356e30375c80412469664787e0cb173a94bdfb14b7b4cec4d6c2288069007a8d46c1a77b445ed6e0775b74e487f1eaaf45a27e4b073dc841719546e3b9af11e6e91312607745078df3a6c05d5230f2f76797bd9b79ed16a0b4a0c12607b2b131cda7abcac648e94bf06efc3f003b61fab84971d03e296e12a9cefa8c87dc16f96209bb454aaedee4527fe6ecaa3b61a658ed616447238fa1a2bbbb3efe06ac0e26ebca60dab46c0417640d68e0cad1a58b83b39536ad4a8346ff7c6927858f6c3fe166f1a2f2bd8b93bc2b0f112a9d5b8c80e9352f5de579257ddb712c92ddb6e6647568fa45c664daf678f17c6f22fa152b2eea8edacf6aab7cc67b942b9d591dbf7b14cfb3e309237f4589be09c51f805f70a4087dae46ecd27c327cd7e8bddbc652c27623af8ed2748496a21edcab3c14f62deb86f2f0a301b8f4b106fc966438a193ffad6136ea37e7187197efecf3f8d863bcf17046873b03709fb2a4694f8c25befe6a890da22b806aaeeb85fde0d9877b594474ab058e2f6ae50b1d74ed29970e0f3ae96cc6f6394e7fda22ff90cf04164d6b10d65a0c3a4cec8dda21ad559bc0b36f1396283fc9d3fff613e2dfd779b7e2ba3a3e531f7c37fc00ad11543edf67c0df522a0ca62bdb14182280902aa3ecb588ce66f919cdc0e79f7c75fa2d3d07ee3d2d492d3e4db774d3447a750b222ae2b8ad7ea859e240dcf519250e166350f26f0a884093eef24890c3709bc416eb79e60290727693e65c990169ef89f8ac66d34195bc539db187545af435f5b69c06420be4053f2687bccb72c8cb596a05e8f92c8ddd5a306b4887ce80f2af505d92a2063802d96e1c464922fa276f9d2686acd5128c2d566117ab7f99524e90814e6b4dc19baa9fb494526f8b9211b2fd068c3754aefc287872e00a7a6963600bf5f1fb6d1546c4d5747aaf4e2fe70a521854402bb68f035c3e7610cab79719f17b4bb076df6f5d9f598d58971f5bcdf9731d87ff60cae5eebddce05fd83624450e53103f030898c9175cda5c2d6e7b9849c6773900d0afce7a61a139e79955edd68102ccf8dae89809b9399104a6184af0e2fa917a8138d14c57afcbd66568293c47ba35882062733a9dbda95db24474e91f31afe2dc0762a8c927e5d19e79cb584d3734850b3e9206d75f1d5b9b7740b92d3bdbdbec396339a6aefdaa1a7d81190c708d11997c74de6a2f8d9ed7c12ef89747e81db7ed5c50089ccb2d54031e32243901c76477937ee82d19b575f1f01a4148f4702f393592720690a12a5a13103edb782b556444b6e9aba2b7cc5b39b3b52314ca500810b6e01ad1e2d209be4f23a33f683cff280b07bf42aea48e38c0d68ef25c89f2cdbe9b4cb85b82b529e04437f970f00c5b3e4f8e47c421bb0aef80a0269c78979386daf8426a0f8244cc52ff0fc6f24cbdbfa98e4e2566f6f535e37cad2721c90e31aeba6b7d3d5fd54a5f0cb298e2f0e41da7724f6d45cf3995a8204d2c0a6abb2d8385632c1aa288272316c4423b69856c092a73628b42c346234e68e179fa6b53ffdb75146d57325a8fee07fc2bf4f86c603829031017de7e38b98ac0b64a95627722186d18f83f9a808346840fc9639c3a8eed6a351c93d817cb14b9c1c42bf04de625a47b6b0541da69aa6f217341a1074232f61d223f02b16a6d8bfc2e46c37d492dd0c7eb5371507a0f7774265d0cd8aaaff2ab037db4768626587b5653432e2f186fcbe27ace2e087cf6cfa3da7d32f0609763cb0db9fa82bdcfedfed386784c274b820ec0edb68d57cf3a014805784de4c337b7fcadf4526884abdd795ea09aacdfc43433990608ade4048b6224eb7f27fe8b9c8cbec3035d2eb39d915dc30bdf4f05162448cc8f69680dbba38deceb66b52eb0ee7c04cb3ebc8c1e3a41c1327500da28bd2e0c2ca143d70cbd887219b0b5eaca8e4530fad7a41ef835e0781edaa7017a657874c8474aa3cca604043fe05d1e7066da0f681d331874388ecb20d68281b1c5a23ff5d90781842c78b87ba954602f4e1bd23f2264b0c08f69b54bdc253912aee9b6c941083ebf660e5b76a8f96adaf48f4b7e0cf8663f319b18e5b294c16a0315b3bbad060d274368eb767e216c7c3122db00e77a81fbaf62143e643e09fdc9d419de607c6ecca27747caa6602c38908c4c38b1beb6f8673ddb0e79c11b60c5c43fd2061ddda2c6161d6fc1a41c81c99ee86960ea3b92bf5316e7a205dbee892eec4c512771c4d8fa99d8ca08ab887253e445bcf430a53368a031b49e1a0813721327fc44fbb6b9dfb8b0926c5e4fe3600445a575f5381f671f8617e0d09efb16f8485508d955cbef65a1646fa078d1c3e4d10b1fb3745ff17416b24be1d01c4e257bfd6a6a3a5b68ac7d6ef5f6995174e9778eec68a2abe88db3f61e07c08d0747ad98c6e0a4426bc877e80423cdd93d8f10d412b3be97fa4ea0726557ba0f664137acee7f774a0b4986dabfabaf28ba4be17056c9fceb9e7b1e8565955d8afd5d83f038f843ad0c662b75a70708b4d0e554a05edc22a2c8a515ba62cbeb52af4f487c46480c842bfa0e1d40b513e92ac8b270ac5ac92741452ad1689850501d47666b93f0f84901a4a9f2d7dc95933052303c1caaaae987cb8d748af44c111ce84c8181022106f8c939b477d48fdc740423023a950e6082655f9834d105cc5e52d0b6c9bda0bda9ebc2879ba7438cd007e4babe4d18450c70a0fd55596ef7ab136121a4a416d3677384ef21cd5319d5277021a41845c787092e3a156d78f5cbf3b7969c828c4bd948f2a9531e7b0aafe41540854d684eaf51f91a8589da671936c5933229e6468d769c22191247261b5084829d4d3be9a01ff28993efedab0288c2e3e7d2be6a0d8b0bd76666ea92ef165fd1c7d1d999f372a75148eba7400480a3e8dc1d8ef12f625603b4d065fb59d6fd4c7f2f66a39a696935dd81634d77fa84330bac08a61b645f11df63ea51f8adaa544be5f612ed18715ae42fcc30cc78688b8d655d47923f40e00cc4908f6d782384bc2a150bd0db54460074e1e87fdcd418c08bfb7da881323076397cf0a8dd99cc597e4a8f21346e8bb79be95411f1c47d7f624894a7275ec30f3ae2b76eefed0a1a5684bd65530eb692e3ccbc49161aa58b1056189f74d4c4ecb92c8c8b3f1b33e506c767ba61a3ef78421ca1ddf6e9d094fa06d4e82a2de449400ed9c6df6e09a5b63b93a44f6c38933ec98e304820daeb80839832f033b70c6852461c46ed5058f9b26b10fd71e6e2deb4a4ddf6b6d5a50e984a2ada69bf4162e883f706109ad7ae74e9dcc3056a4b019f082c61020a92d1027192d63817dbb3c3d7f0fa09aa0032c77d98f1c1beea773ffd0c816716f54c8a79121507b77e960987a671148609fdbf88ad52c463a500928caea142b95fff30385b3c7bc3d4c6139103cec5e05a25851d39888b58c1195845f2251139a5ede07af886036e27d6450e8417a2b3918a9125bd79095799dfba243904277cab1a7c08eac3970b8b9f66b09ee69f3484e1fbd88fffbf431a2036f9143f83a08812b5be2627da11fad43308b4e2c1cf229f528ffaaeb5ec8cfbc252be5910c0544d7a339efab0f12151ff6602a8fca43fa92f68d0c2ab01fa9840c739c4e313bc80f6650c6221ed1a800dfcd12649f35f5ea3e637bdaf49da56d75967420f5a5765b16aecba170eeea4a639ad69a3fc0d4bd24c4cd50b9e8de71e9b40b4ac95a64c1e7b4bdb54e84fd55a6fd37d0e971b59adf50318d0ccff2935cd3fd5fea7d05874c830a6810898fb5048d2c28a5195d16e60d81f4b6b5cbe507338dab7d8187fe089233e52dd319191cb2d9b5f35a188d928fed670d615da465c7f443380f52d7c498aa0f129cee49604dec56c69a6df4ec7a71c655c61d8e67216d8cb85b5c2fc04d76b2a1761e23531cfb3eea386713cd8208ce4413ef370a488d8e4e275347462715745b300fee7842f9fb142609750c1e3ef194cf8d120c9a17a65d49b1da8c94fdb13684941203624e035916948eb4b15750146b73191a103910913e0fa360f846b32398bee18bb31e6105e7609f98216e08085985d143a9e75f5e135ccbd030290da4a506864db64da8c6f13d7e4b156cf39c9588425633b19464aa1622bb05306cd12cefbb0af05c178aee2d7aec2a40e4d89dba625a6b0bfdcc00867362a17eae34418dfcd765ab78649693b7e47d9f5acf6c8745ff1882f3c62dda3542a27d2260bebb593183508b941fc66e139a02fb07bd6b4fdc77dc3e92d88959b73d1813c3663b2fb0874465c9a9050d7f13974f5e1c8d85fa0f73953ab06eeb25785b71929a4b96120b665a040c90743c7808e443464ce54f14eeb439da67b2bb2e3fe49c831628c0d7c64fcc414c0a0115a7bec0e6b1b9372deebae64702e97c3b3d476b8227fed403258b12878e3265e43706430aa4fa2e7db57764138f20dd2e3523a5c58456bf802c34c47bbdc0bb886fb2cd13a9dfacc688541d4b65b905040cbda65c51af655ed1b240fd80c041ebbc6ae60729129e65ef6b6907571124c6ed84f992df6fe27dd3b8e541e50dac4a7edb7df14ce593b05825657525c92b0d41cfdee91ea178899a261deb83a0274a6fb7cf74eb8b59af9ce694392093bbadfbb6db995ec7f4567683fb01ee9173199691816c3b84adeead11665ccf7996a1b495646898820cd15ece7b8f222726f892a614bc2434c2d6d20a403eb8437a687fe90703965437842f07f42c53e284f22deec65806d945b7ee23b6387c339a87e7e36a85dd82304104504a3cc39e0563ef01eb8895a793dfa707bbb7edbb14cb7ab3743a86a761f5f58271afb551ef92563fd8d97480dfa15cdc196acc354ed5be9a75781444486a03a37bf70beb6aa15660437aba1d361fe20420c11e92cb21d493adceb2e4a0a466dfe8c170ea37f62b8f4e07c715e8ade3d4fea06ac27a836efba7ba1993bc3bb577da19fffc009e9e1141dd3d2a84d2ea5cf8e29deb6c8044db1576411edee2eab5bd8275a3e858f0aa766244f882f7dfa410aca02e9b826b78b569e112fa87e658b3ba9340328332bb1f52e27b4ebd5b6a843ceaf0a29aa562028d1062d32b6e3703a0c34dc5527c499a11245843c5e555c846c019fc8a78c70a1c465c93e86b5feb7fae64f05ef2977cb7c643cf685d9b0bcd32e9d63d779321dff74b616051b6d72f89379db8e0cc0526a50f7f27783389107b1e46f00ab80c751984a1b570bb814b91ce008b2b82e88a95bab6e0bdf506797b183ea52bfd65f59ae838656a07211ba1488fd977a7f0991d737cda48e020fcf228b32486a465aaaf096a3db07f5788947b38ad75a6385fd9a1ab32a4db64f852889c8b37e82f6cba7a512a66543645a5837600fe617fc26bfd97306513a4b1aff2ca36062f81ec503738a2d429200b4c4aec61baba72e2f2379c3d849369a2a18e72ce72d7c1b21ae49e7795658c00614c52d27c839cf94cd52d7eae95ed67b91493b07bf6a9b7a6ed3ba6e64e9121b441c9238bc6bc5cc323ae747b48f855bbbd9a2edc349e528083a58e2be2262aa9c56968828c6b998e36c2b191b4d4ae5032b1e4afd836798581d40232df4723da3bbbe0450f1f6ffadbb177bfba5512f4e93e9bf0ec521379a951d104ebb4840ed572802d743f213578b9f193b45c38c7c8e22ce0d1b9f92199604361d6a2c0f6c07a92d1274291c5bcf5bda70d733f545e0627e0216c50f50bd7ff32ab40c46962bd59b7bcb72716d5d5224c8fb5d0ec523ab3b7411cc22e40f66d9b2a4fc8066ccab5b9ac0e0c69bafd260b86e91cb1d08a8ab5720ad8788c7c7f3c7e3f07e905643fc2ada1584405313b52bff10b8086ddb870df4cf70d60cd1b9af44e3afba672c7c709feb6e18f4f492854047e6b98a9003a872602a572b2e8e75ffe1a18f32794c2e64c5883889a2d7dd3b2420dc1d3a14d0be9d28f9d689f32b13681227f7633607dc288eda4721329021666cf47c89f75af54b38edb18eba88c088d3cbd9dcdcd889623c9f539fe5e2fe9e603a12ae3998c742d54462382e595b60312defdfe5189cb6f256ebc3197a329c29ea3a46b44670209b5a79fd0c98ccd6d97517c2d10d926d33bde40de6c84f9103b49b42f63f6599a7317990635ef19df5bccac10da7acbef8c87cb11aa57689649f4ace4c7c8dcc67b009c5be1fb59754d1f0631dd071589482b68e2f560c86b0bed5bd9f9102eb87c7a05e0a41896c81257784b5d264acb8b9d6296d913b0512b4f90f590ba08b80d72d400d8e5958c132f650d9427e2cb535dfbc34facd0f6a4e6a783d5ea02a42ad1e18ee048fcc25ef9a90e57243ef950eb99c9d8fe505952e8b7052ab65065f90881986a2b49e327be223991122d8cf5b0ecef32cbd8b575361e7ba417808230f4b85352c4bba2925d0a56dec62f921b878e67859b63c26fd90d92135c0fc199d47c70054f9b29568dbed19261c6022863c43742e638cb4063036fdaae33df1640c5ed6f4e482b758206aa02f5f335bc01735cc1e88abad0f612167f908ef56159f538c5562085ea6abc250f238add684fae6964eddbd4457003931bff32f1186d92baf6bcf992b347283c5b6c4ad8bd7851359e7f162149506367e759d2c4862469a43d38b8d01ae3360d503652006333a2ee509f41e43a4af4b6c16d5ba99c1adf5d249c5b9b87768edefa7e902b648e10216709308e76dec9a80ab989667247e91617ee9da32f27979973ea86fd13dd9e38dc9a3dce4d3eff8b7c0c9827c8384a6bfba4135b504ef5e8f655dada775ac3471ab06138a9afc1f9e47719769b3719f95c0f706f79306cc81d81921fb5fad53174a943716a7c4926e11b600ccd640f3addb5d8c7ecd6569a13693304df428ffff5b91c5e3579c48d0f5ebd4e453bd55507666a7ff6bbb932fd3fe67e33c1c883d41b56ed8fa7e45e533ce7a5939cdd383d92f764a0b93f2369f91b187870515cada7358df810e00ab5e182c8a919f7e7f3482bed2d9ef4ed56db593afa7a5935b58b89b1d54247f645a5dcabbea3a04cab4a23c246a6ff20e12bd9a632fc989e0f1a5bcfde3373f8915bf407241b15ac6f9a82398a4fb00aa9f785fe81dcf54a5927b296ba34cc74b38d0ba918f10399d091d04fd5f500563d645953c245700f0ea35cbb6018e819e2fa0007c99bb381fc5da7205e66c1331cc22310f3c0061a515103f8d3b8e53cfbadf1ff874810c59816fb23d18e60e5af7a9ee3fe151e70b21014e6d40e550a08e0dde5e75be96e81d09de8d02635714a7ca1045bf70b086ed27c6b4d94313b6bd5d8ffd8eaa4bb70bcfa6c301ebb32f120179358f3289ef48e383707929c2ed59926d5f6e9a806fe37302854b4d7b44bb80327de205df309fdf5978e0e491614577d9551832bfbadff2af8a2c50760cd710997f413401491754f8b64ccb2ff22d9f6320acd867955f8696a51b1ba77547d352487de13a77077dec379b15fe7e091edb348e2aa78d801b3ec5ca2b14d32512c81a4b3d38bcc124806ca143e97d2cd167bd4bdd585a610455385cdf543f85d4dfdc04058ec0897158dd2fe5810f51fd4d6dced5f449e5d482761c1c5e60401624835ad6f0ea1217e3b27cd087fedfeefef62cc4a81f12ac8c21a6d82a0cb0612528d0ae17cce70c84df6c83f0e8d3bdf454afae27f697b1bdfbc32e21e732b14c68bed46762de3e4191b03d9e59fd1cbe6b6323332df0d29be8e1b6a311ac12538595f15f385cf2352860f501887af0f703fe61b929d4f5ddaa06b8bd806c2da5b8a480c79a4dd64f1e44922d9a9167c580ed8854c85e57bf09d1a0f36c19763af8f3c10861f0954a9a05a6088f2572ba38ae8b502548a42af91a431290ece7bfe58f471b935f028b05f57dbaf7d9146eabe60f27b126d629cb7d00fccb0ac6072be883c97ab086c5ce65d65b091075d97ed3ebb673ac69eff9e887f79fc4b6ae9135d5349e0329544b087aa0101e020f658635c4794881ef4602db969b6adbe3de4220bd7f83187376e2a426e28e346a37e3287834369c00fe6396a955760caed87ffffc550b27e66998657d439b20eb132b328a75ff142b3988af8085e8bf34d8dfe6e7302b1776a5e9960ea15319f98ec0d022859881de75a86aa1f11eca2569ea52d07ba4f93cba93d7b3a74f7d5a035e692873256b31a235447816d3e15e62a4b46ef26e0f2d3617cec9052f892d2900a0b793d66e6adc17ea2d4648242f9f760a0938775efa531ebf5056d21c6fa5b460228d83a965e728b90a1ec1a309a22996130bb08edb82c30630dae3e21a6d8bfc6f9216faf625656972615c322df54a7c11f4d27d47683d3e044a1edccef942e7152792a848a0609e88d108e7f69ab45b21f5d701b7f21883942c2fb6b23dcaf760031faa3aa53739a76296308d4b298d62b06d8a335c382f1b7f54b22130dd672b02e1abb68ff76a3fcdce2e2ebdf6c7efea5f5923a32ea097e75893067f620ae3b11a4437316e1dfda820251cf4214fb1018da3329a4cb609dedca1b070e706542f8ccdd086618f85cf55d8479a0b18da7d264b19c640c89e876b61cf40fa073a19f4e207fe1eac688114167f25632a24d8e57551b0f3317685eaf8fcb466e02c2c7425474bbdca5a399562a2798391ce1076ef96b1d69e70b3412372c3e97503c9e3b21102bf5b231df9a2d880d086f02df262c574abc680ea4b21401d05b6d86ef478e93ab597644b7bda7fdc48a50cde1ad825cd1ae50d12ea871c7b46fa8c4a9f8d43a536e87815a7a22e1ad0cb8c510baa969299b6dc31b8d2e7d4aa34dbbade057d3c7b4657f908337c3595a475617a40f4c7fb54d3758640a48d550cbd575c7e54827fe663f6a5ecfe11e746e4e051fd02b2919329ff42d9e62a83ca040ac94ff1f7c180bff2c7a85266ebfe4eb4f6669072304e4cf2d834aa13e5c33d0dd56a292674f2c0c3c9bc0a1ddfa51d827b34196f8147297772cf0b78554c8d930d281c520e477688ddc9c4a6bd12b74bd0c999fe6853c1590b75ef215b1ccba169f986335fe4dd48fc8de28fb2b7da10ab4f7be4c950e5d639b388447b54cd907a7b4ad85c508128b45a848600562f0ebd5a518a17a233d380456cde5d23afb6775553b586d752c1b0e143f76f3a29274f86295e7ee0e4c104e96485145ccaf54f972cc281b1c172cf06f135dedbe7e8375f8126f2cc09c02abb508ea9ed78d4702c0b286a0898f31ddf1c83be63c75f2905e335310565e484427ecbbadf7aa2fc603ba0450e0543ce685b8eac7f9b63d0443bade33797fd38d813cf68c7f36fd893d83332a109b8d195d6919be72e21e2c73baa5414e8ca3075bdfdf3bf8ee7e9701df7a132b928278b5d761e192ca0b3393afe61fff1e9d022ccbe0782f6a09e39e3c445fc0a7b04cb5fda6c3362ba24187807f01da97a7b320864acbd9f85cec566a5dcc85cf1341fb00b07bcd9a165aa4e916854e84091d2e8f4138f89edb3805ead446fee7d2f832fc3c44fb64e31134053df8c8e862c6db4d4d2e8360d0650680077abacab2544647767c4f7075384b50ea7a6379f66924cb3b5c1cd0b90ee6d1c519cd34e78cc37d270d32eb50841144f61d0309baabf73f0e25139391bd5f5f2163611d9c895df94aa9b1eac1f19af34175fc00b28783f9929d7225741663e809dc247cc59dae109967e27cbf6bc9681744dedd830557540b7577c8ae6638c1c6a13bdcbfddc2f1e5db7fdf2de6ad9ea3f70ad6c0acb581bc06e7b36f5ecc61b94a9c6ad2d4e3066f8c31721fd52de408cf028ce7636a5669dc1b1e86d80fb64eabcb2e4fa6bed8cff1ac992f05f6fc3d7baf1fdceb6224762baec8cebf4230d85423be8e9bcab5fbb7cb90fd046f16c474ca70624f698cf4bebe9a2f017d27216e6bb6aeaea9d2edabf27c5cda7b04583b07af3a65cd49da9d36f7689398f0ce37412fe8a6ba189d898ce199d794ec656948530f5807955b0b580a265f2409ac3d24f3fb8cc991bcfdbf2d0aadc49a16897060d642ce12370994e691c3d3fb6d262f04d9e06a398974e71e36193c49813cd0091b479a7a39d9414a952ab9ae43c11e4ac8b4ae9826e8b666b6f90f31cebd4e180f62c9afeae81207344e563ceb48e479750b0d07dbbc6f91104d35bad727134e477f4073e1d61da657c40b00b94628f4dbc502e44ec12f6395cfadcb72c24561fa26eeffcf67f5fa1f9fe88d688ba03257acd2ad85654b96201d5cb50150c52e4b8f881fb912a3b40c66a9e1a724b9160991862eb74c8ab4759043aa348aa48860aba471ea3e0825e290342e74a180ff2e6078997eda8f515d704cdb8603e11ba06ec93c7be42edf6e6425d0d9e2b818318e0073d43468ef103c28cf7ab230d9dc8afe752755f4965b058403c395cd168faf33bea7b281ab2f320de7bf619ab3564404d9b7b6b896d02fec6a1a658c58e46c0418641d6d4d583c099ac11b46f42d86221157b9403d218f5b4f3be7fa73a8b310160e84980d969c7267da51bb603d91d1dde918da0cc127b08c597a7b685d9a38988c88f81c8225d6edd50b9104c23850121493c44373544975b9304ee6570ce8392abd89efbc55f8822ee210f9fafda572f5ccc27c7d64ae9e83078fdfaf55a8fc208fe06ec84e8c2ce06ccee10dbd98a0966e7a12383030f31c0e170853c28c5e0d7e6272cee84954b1fdf6e86d0c0e44bf3ba3fc17e4ced1051f9ddf9b2a4e2380daa355adbea748ca740d71945ada5f630620800927f29acb598b14adf7a0d48eef7d1b1d3216995588781d9532268c7fe43dd13c7f7d0da320d1f9aa1231d9e6cc6bf8c3f18cf52a6a845c4603226062e84396fa012e9e9aa719a77f0f084dd354af3cf5974e5f78a6065a1c8528724a1043637f43c59c1994a476897226f845fd7bfb216fc7ab858439b4f0dc4da9b9318da1ba65de25ae434560f84b301f8b74e8a30cc6073de740d577d366c9f0d9d8cdcac9c292c381b71d9d54b98d4a0c0cac8fcfb8b68922b3a26d4e21a2341bebd03388b7c2559884cdfdfa00a30bd2130a5670f95333e53810a75d816aefbb2a98bbc3b68d83321ac3be113e455d0b560246c2671a8c0843a0b1980613bec7905a0dd956a27d18cf1eb799d151c99663eb2a05b0734685c2b67dccd64e4bb8024f6eaf1957cbd678dc322ed5c59d878f6f2ae3248237f371dfb53102d59be4ef64f82717241be20594aca98091d8440b25eedfafd9f08089e805880f24be02e880171527a124474fc40715266f026e950a9fb4a559b699b0c5ebc3083cb02131841b7231f937110d8cee0a43c15851b649db0581d1bc962e3d87f94dc61b1d53bd3e6b1188d1f0de81b2d7c68a08a9147cfebfbcd26fc05773b02541e1a464cbf5b073d3f54aeb90a234085940931f17112837654ddec8bfa8751e5183ebb4cb83dfeee76e4d42c98957f2b4fe01551f866f115ce82ffd51f5e7fb6d9fb231d4449e2dc652cd0af02330f54cba4bebda21220660b27cc264da5cd969a63d548e81af3459b9bc639435198ad51a4fb3d76a126fc783a4ee80082dc104cc3e23c182ae12b834d5b159d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
