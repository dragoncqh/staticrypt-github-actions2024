<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c00fe29cc9cab2973839d54fc05056ebaeabee238093a34f6929b4724535f037fffb29a762a38d39616c00aa0b30cb6e1d500a6607b635b91900f9997cc5a8944364af2828f65969f7597dff0052e735849f775580275bd891f0229a76df532bb5cf3bc5b706b8b74458293c65817f1c256f0447fdc5056882fd1de1b571d88fe869fd5ff89af71901838bf8fbfcf4406ae5aee5c12b49002c5ee240da249619a0eb18981f6e7ac3e64d55d66bbe0f16be70b183bf46ac3f6009d730e8c56c21f142119d1300eab4fd67cfa33f2d45ce8f7dda809684bc6ca99ad7c09798e172791208d983a22912a59e5e5a0e847f5a0bcf882c23a601adf1b5efffcd8a1dc65f637bd61a925fcc7b0fae695a149922342131cd595313bb9b84e91e4653dce8ebb92b5e12cf47b15f684921d9d9b1796d62dc21b12c267f9354063db221ed7fb4e74952e30e6b3cd6a9a3246808b62d570c2b1d097cf3aad16bb58aaedf505ab96d44a3a66ee7b1177e766b881c5baf1b0700d5bb34ae19ed6698054d3e41f0b0b5d8cb1de6f708a5b95a05b2126adfea1a2dfe07c1e9c9c17b1ca112f6df314e48f9f7fd7c00e16f95d37c1c6e0cd9eb238bb5d5e44b95c3766da188907d0cca32f580300a980fd6a3fcf17bd48c612b205a6d78e763a953cf4460ea5e49a0a8fa4ade14aecd5ce1b077ad6255d35343da63e2fc4691e6d8a82f7acbba3601eeac1aa7a9f647200614027c8c574504720db4710387a6f8f0288561401440eb25e0f6ea1f20243c2f6686472c183d13f2e47b9188525720ed4b72c2ce74dd1421fbf9ca70a7164b6b27128071c48e8a8e36e472677dcb7c688b142fcef5d530874bc489fb1b063a7c4b96d130aecdc6696d30c3e4d4cf8f473ab94b27dca25fae49ed345e3139137941eb826048ea767d9d2c42ab9ac488cf16a74486734f5a19056f84becf96d3d609b790bfb4962e1ce2feaf3359ed6efba369bf4ffb530b90c79bb568478eba1be23dd7ab02070b95f27a021989559fe1eef7cbc216175d5f035a330ad62f0236d36cb18765561cdc3f263c083504d4a0fa8e7f26cb0eb469cccfed0821d264edad635c9ba12690fb810743c63b2641bf8e70963cc2b109a999eba70c46b20c4e7fad64c8252b2ec59f13b799f331cbd80dd061a527f94b1d52748a08e0f233ea34b0c575f1c7478cbd8638033faecafda73c1f209571c847538cf058ad9dfc05932bfc2b544a6470860b59560e792776fa7735599a1941414e140847ded6a0c2096aacd75df8d3f485becf94cc7fcbe63e6408fe70fdb26f12679b274ac7ac98035a5cf66c4a8eb1b4664372fcccca22b482e816313450e38256f1980153043df52e2410e187fc842e8809d087efe33f96e755b608ad6fc7427b3d12412fd6fd973c8cb54b5490792140a7ceed84946cae1ae14739b2b38dfd5a33d0595df9b24e18e3203526c65449f7968d357169eab3b5bcd59c9c4c26fd6a77c0ea6e22eb0053338314a8acbf49b143f7e034e600725f7850e340119cd669371fe757a5b22d03fca3e6e54702e54f6275b1319950d9780bf1048a02a8396bf7f3450e158ccd4af18ee6e3e93f6b10eabf4c732c22cf2914b0b47bc143f979d00dd8254beeb159770312db025fc5470a961d9840b2c39e1cba5189d2fd3d701813e56a0e26ee96c7a21514569ddb6c7d80773d870a1e3c048c9f95c5ec7fc132cbd262cc2709b556cb13a2e0ae3dadcefef97fce3ff1bb25a12ba579ccda2b05a424b29d22670c7a9b65f059bc73025e121bbf50367f1c7b525a44eb7c7affc1536072be890261c2d6b2fe4ef92c9f319d709b562eaf9eb5adaa3781d0e4f568950b6dbfc5e3b461428f787e7fd7bbfe272df2a65105ff61e75dcd398019fbb04a13b310fd70c3047e2f27dae9c08e39bc49a4c7fce95f36f1010651cc742086b0fb1fe25d061e9c329954c94cab9f0d17f9f25f2c57265ff85d8b2c0be5af6beca7ee3e958fb3096d4d8699d78bdb5dd4034261abbf4cbc56a2d062604c42e744cff3eb097fab975c47e88b9b526fcbae9b5e54e3e4ea7931fcefb86e10f0e3d2417baf6269be49f500d0360f0fdb422ed026c44b65f00d0d358aafdc70bf62cd9d7de2316d75435d04c4a98591dbf4f4ee564321837484c09af2b331e1c672b5ecc8bff082963f3be38569e31ff21660752ecbd4f2377a2114302fb272867cbcb32ecdf0316199d9357d719a8442abb8153cbfa21fd5292a3877070f94bd683f023f072939aad09af9194427995679566ad903a0f939d6f5dd944054b0ed9aa292e7541c0d82c7eaaa2cefa9de02d6471ac49dacbc880657ded12f2d188ba84f6ca667e10e368cb78d5e69472ca107b64d6e4ebd53721bdc98efc8a4738081dfcb20c52e3ef302f0e9ad42bfb65be9a6ef32423ce7eabba1e4ec3767dbf7be18a486453d744e9c54178e79fd9e43ef7b126d45998a93ab42d54f3c21e8112b7b6fe76763ae9b42b1a74b1eb1415cde43f823e7652906285d03aaf51a48f9d70d94d8f38638f3b294fcaa7103b770eff9afd1d1d9a4f412bd2432d3065f7e0dc7adf5a674f91b7b0c52748ee4992ba32d4f7587964881e84d46c7aceae539463238743a245e2f1be3e408e2ed987f188f1d1c7883e9086c045002a6595b3236b9f595d4b2f8a9e959fafa18018422ff631a80c8a3725d0c12c5eccdf76d21a08d596db214d24cbf55e3db5608d0adb76ff1c87630a05dc32c5219e7ceb2c4f25de7a62a66f8818ee4ac016b3b8fc2e6fa843d69f87d22303f9c4c5221c90413865c06002fb98f84c9da733f0ee2f084865f606c05e3c06aa35bcceaed97345454ce790b79d8403a8e6b9126149c76ab5e20d2e97e3ec6b405e74e37f1f1e501bf647b6095ae4f53ed0b639705c954e8060b31665e486f49886b387b3fde2089eb52d009f365d4e8f95a39f13b337a283e3fcd6cb40ca20fbe893a4181f4bffe4df1c6a6b397062cb51bdd4594e268ea926a7530e676082eb9c82729f94c7d5b9d35b9f41252fd839c822269021fea531d0492efd3b63f8df897b61dffcdc65ad51a9a1fe212a23d4daff19d41fafa0712d3ff374a7b466dd42d352f0d8161e8c35a55d1bc83ebf0c74b941a2a10a64562326531931c7bb38727366d6110347f2e16561f3aef6be8deb58af3c812566b6620fce1b1207f56af6ec968f8091d4c38f55270a20df1484c2932acde33a70a8a84d5ee1962549713f73bfdea6c4b8292975c9842a9776fd98f89433316669ab99b2f0fd7c52b6cfc0e494eec6cf4b8cca5f4c028b652894163adeed0f5ddc65b9df5bef86ecf4bcf8563bcffbaa216378f0bbf1053e7a2162aa7fddd37b768035ec8e2584ddc41c3b0cff5839c46e3b8d6c67e398707a85f4c2ddd43f13f87a1681f8c4702ae7dc4fbeb86d297844d815cef850122e6e6e72b4ca661554f732e9478499adf7d8e29715ef29dad52dc6688ee8d72520c120cc2fa421796d3d69074ad1ae96ea0bf87df45c900e718d817aadc3b779cd48374b3ef9c8e398d5c2b05cc548d347767d7ad759d0125a2794364353375b9c1afa4119b65b00a81e722925c9602ace059e410b1cf917b8c368898ba73af91c57b632a150391e46b24988df8643275cc6db8252da0fbb401872a8cfeac6fb16166ed75e4714b33c225e66dd1e580c0da0947f3c062c52bdac983ab448c94c34da768fddc6318b7a43c25762a6e3be7e89074e7ab70aff4b78957bd7ede718a377d1dcf3c5aca4d6e216302dfd5cf3a6362e31b4ff2e01696ee29a393b3a92f31d09edb2c89e92b3bea625ab2cec4cbf941df08eb78c7926366eec9b5070aa8e57d62aedc0726115900fa9d0ac8a2ed4d2ab84eae908c5f72a78d0f32799b7e6aaf36eae059fb3f0cd5dfa4beda0acdf170112519c8c12a2dd3e9d429e433d7368e21f5651fc138346dd5a2f1c31e598d420c9714967866a53b03f343461fdb9283463a3ad5e25d1b96aa8be9d51aabfc370d017ab601c1a24dfccbe91f5fb0edb227679e6a949ee523c832378867195b0fca98dc90a204e6903fc3090d6bd386fc55e4a2d724333e08501a6d9fa5597b76928dccf6794a563c9cfdc7f3dea4d8e9b0ace0cd3a6bb6b1d7579c6e3bb8c29ee0e318249d731100d3dff40afada9fefb7e3ed021a62480fb6f809900ab1893f8169753ca28493cdb25170a732d976108e795b624ed8957dcca0546d76e7566fcb134fd4ef734b931596cb94bc8a06be23a24a3263db28f58b0770ded7ce4b54ea8489d4f7b819e68e54bca16d6984aa72db1ecacb9a5c4e90c8a7ed904a1e6a45dc12c5aad9bb873d80f0a2f08ba669c25d8c217bf3e8106d8a2da6b107efdcc9ec160c557c17be2947d2793bd21ca3eaaff69a8022df0cb72fe041710b6802a38fecf0a361a7f7b279d95fa67874e08cfd0a2fdd33efec1ace68784bc2e6967337337d8df9089b7b9b7a1fab3a3c637043dc1ff91426768f1a34dc89a122f07a96f004e2e05138523d0cbda02435af6b2107a10495d9f1abd8da9da5dd32e1c0f8c20372f1f7d1ea1d9b671aeacd8db52406d4d79cf5f2dfbcc85e235aae8616ef72fb0cf1ee4920851de9460bedba72e4ac5136607ac4938f2cc489099d7ca5acbf8873672a7c996f066c97330b3286e50dfcdec1365360b95df4fa444e2e168e1a3193ea9c1a47dcabe79b020f86702c43341a103ed02743d2b476f09c2d9154691abedd421dd48a2e0cce6d4969f18287287e2af68df69df4ce0221e53e6cd8d62fe40317d42017699e98aeb24880021a6d675422abfb425dcc17bccbe3baa260956b299c530877cb56550782d2f94a7b41d55715e9672e476deb12889bf1bcfe423b3f7745c6bce53952ae9aaac83bf99f7b427328449a24f376c825cd8795491935293753dad1e1ac5bcd8e06df92cd9b5c50ed0faba35308b8c7446140e540397f77a0588df1b5060b0f0b38648e58ab4a7bdf688ea7d5ac00fbb1a2aa7778301e5e559ec2ea8aff742c104bec6422eb0189be606cf3057d8eacca3361423f802ffd37cbf50effbd51c42cfbf54bef5a573553d68078bba1b32379807eb53bb362cd0727a160136d9d588bcb46687f1b24768ccaf033b1883259c019be29071bb3db98baaf3a67df6aed7e40c5456d8d8788b3d74243ad3649e7349de6650006e57079046833e51cd8b6631b462f9ecb9ba7394826ab0bf66459ab5587f252c9941379cba5608a021dfc4a8ad22862dd103bfc9efc1929df801d56c01fe4bf3c788ec29099640297ee14eb200890db8333ca67ec56e8d5c08680f53a3e9795ba6188b6c74c80130ce517513c254a1d108caab5e3e4fcc735b7fb4b59622baa73b1fffac3a88da0e943379e499764c65cb01f2d27476e0bfa63c32b09b14b16912ed95f82a25a6a5761696b6dc40757e01ba614dec5740e8fa39c214efe6dd1be6183e8ecd14d27c4c596afd8f98806c57b0a8469266ea7ef800029230770534650e498b3b9cdd87177c8118da5c585619f917821ba96b49c1c9adaddb309912ef803d2788d1420c37e7f5b64cd85ba92b6ad825f56eee5b00a82a395d435dfc6b94f66447f79c85afc5d773df24cb573fa0f924ae07bbcef2eb80836703310ee4170852d31c0f60ff4bc44bcef18b1f91af07e8ade451a5013bd47b3d015bbb47955f78dd13d27ef321232530d1a5a7c05d1b971afa48a73c202b864919cbf940271460df49fa0c1193c31b0b98bd2ae55b22694bf7e583ca9b536b34087bb67bab6500e8fb94ba4598c37ae5a9887a28da2e007198094e919c3741a48b25bf537ba7868314dd27dbaf99d30d880e555f16170b82e62c151d5f216183e1718fb979ea31f37f99b7643c62858d25aed9ff6d31cfa7d2f0a56d909d2142381e1e170997f21f1c3a5290f083517b09e70592bba70ad0e56547a379653beb6432571cb02852f765841515ce20ad87be92df81238ba040ecfedcbbec6537c6d8ab82b24b0391be4797099b7c0c9b1b89ed934a77d5040eda524e64c0d5db951ba4e6450d69e981a405d9818ad7861c0f5f391a4737c1c50bacb6d61058790660a3548c7f7ee6168159eebbca1eafd4c2cfabe7ae4b34c281ac419152372fb26eb04cc1d1c379627e9a634638f671248a5508696134795536358b5a2630ad4b2d0305f151e4efdf5181433582f65d3208ad857ad6688a0ed5a217456556b48a84a9279ee607312f5c37e2790ccbdb55470ea08d34763db687842d25f2ad659c0bb977831235b1710ce2f172cb20ba5f67f5846a837c7d33580470364bf8f6e969b4e1372f40e03110d5ebfa101721aa56beb184697de527308ba2f33805c95421740c626a102d7fb90df8905c51e0d5a6543352417e39f8de1cc2a640cf46979075e8b3a652b0771dc86a03a37efb0eb493943da8300abc468afbb5e3324be88db34e028bc86f6f3a2321d73412a270d77640f2ca2f83f6b6b59d54d417f0d620d4438c75a20484824f14d808e8493ca087175d32e1f698dbb4d002ec7b2c37b1b542380e9e9e9b1f4ffcc3c6a01d460c65db66ab67554dc372441fba42b7a64a725c192112299804b6b0f50c9ff994d41cd7c5e4afa032d1f8c024861bf59aeb7fd3f50876aade9df12330b8ed924f006f8fd1c05c4250122e05c8b99360c46c618aa43c3f18ee4b1df4dda9756183924bc5ebb590bed5b4c75437b639894444436c07cf58585e88417abd27c0009b46ef20161cc5c8aa506e295f43eacdaa7167d0e949330abe5be02c1202a46bfd289707f33a94344993699fb7a6d515dcae48e176c3b30c7fb419a174341034851ec1a5fa7a9d08b1cea713c491f387cb0f71c18f0ebe35a160aa8c8ece657dee4a71f350f26da4e4e9cd697b4f1d39b9e3289166a7d326db10a6c97d7360966ff03930c98b35963d82a5c29459900e282b5e6ac89b4eb05563e3d6393411c0969470826cc8efc022f4d26d5daa682aa1007eb551fa11916855ec3340789c263a2423b9e9d3dd40e98ffbb0d8b00a49567e82a4a203feb1665c4e22d990dc32dd2f478f32cfda743b0f4713b5c61a308d606b3dc92c7ca20501fe9b1bd2e9f3e760917d90cb576bda18a2dda40bbae073ae7f4b2744dfd8a3e02d0470cc914d08db119acc437f3dac376f1b13e68eb0f2b3eaa8b0e0973e6d18ef76450a096f11120d54c3f928b8fc26905145a4383226eb78527d268e6bee01e3c8b6a625d02ce39b41f0e0a189dfc3224bc2bdaad9450482d19d4fcf9843977737ade690235cde093ac4064d066cf82f9564f1ab9008a1ad71a792e12b6126f5977939c4f5b71bf8a118d458a1eac3aa04b05a8413341d0fae0cc1050e30080168a27d01e3ee5777832a87d7065767c8d2e498735e5c6e8150a90e28cf327bd632d92f6c931500c32faf5851585ffd708d0c39b42553def772365de12982afaa3fe341f21a6572f0f971bd169c5ad7d69fea51d1eb1b1cf64931be875e2cfae17091bf356b047d3236175b92569a7210c726b15032666d92501fb6b661a87ef20b05a7f12f8752c0d8aa4980e67fc0155de74b8bcecdb6e65eda5044c0bf9e243f8f7a05c3e9534f33d61ba4975647abbf042bd67ada503ac9d42d4363ec154c0f5c5ea6f080770f670ef76c0a7fa9bdfa70aae3d85aef05f1aaf7a1a6564f923e851885ccedf837b1fee0ded49685a297ba4784ea382e73c84151b5f3560623e53a545bb16b74a35a90213e8e43913e2085e82d35d62ac3b062104e445f8dff748fb9c0930018e39ac01ed3df45e74f5b94b02ec7656df8eded6d203608900b96ab4077caf5e20211348e7d438ca4aa09ad070b72bbecc71d965a734bcf8a207c2ac51b3041b9d3b9785a441ae9256968cc723fe24c80b3e82dfb7e9ad3dc815e09488dd06c331457c4fcc54f496546b4130f52679e6c58f762e58b2bb78ade0d0f4b9595b0c0c9505f31ec9a9df7813e61da5766d1e0c5857a146fdddd830b3dd594583f2b3d4ff5b298185eface4c9c70d9c1be9edc323018e420bc9a81ff1b323eef5b1d3bea6a477249817cc8c6e381058e474daf519fb4c04299d0271484333f6774cb6813cdb302eeb54d654e155914d69ebaf45e8d4da9e24e77b80a9343260d78fab5c3ec9779e4d7ed86b8f14309a7f27d65e78ea77794fd58300c9b86d859225f84e7339a7e762d9d80f55859f8cd11bf2431285ff4237b9f7267077f730cc38356b1fe9a26ba855296d72480a56f7c1020f7343ef8da9b21f8fcc54dc0c7cfde5b015f8f4ea2cc4f9f1442b071fe7ed7cd9a7f51c84efe6511bd6b77af30f1abc893efabf03a1610e9b0ebcb196c8afaa7c19c753d63177719b25cf538d8b2e85e66b356cd89c5d426f4b6f8e5a205068ab77b8a5d38ea3decfb0316c3bd55ff2b9aadded0e0bf3faaafc1b6fbf374d45052982f5660b0071305191c50520a335ec0b3fb9ea49e8fc49216492c08261e9f3b5dd71655d3bb00ef1cd5fcd1d7331080411d65d96d40699057de578b629c948dba1cdbc8065dcb78e08e284c0d6c669f43f733cf6b3b59ec66f129526291b00df3c9cc8b3f37eaa69311226911061679d03eb017ec0487e42c524cf9670cd6f670915cf4362d0ba46254b634cf198e9290e2c130c611347e5ed24a03e83ec660d31e2dc6cf8929623e6256b766382b63baf61e198c6d36152040e679be389055df13f50cf0c8d8c02c394357b1436db31ec0b3afe7facb028d00352694e7f4fd25bd56dfb7971669b254fbba03bd1e050f0af9598f0bae7c1a1c2a4213e1729993ce5ee845697c7d7c27fcec9f5091e3778ada834bc4d5cbf2d4c4d0507941c8dab8d85a950bcad1b0fc640fa996e388d7e7a268612d46707185a7f4319a91322bb165733f7b67143391af8a3759aa83746f2470dc958e1cbd0444ef699837d625179f0a1ad97f86e6a40e4e84944f2b20264133101609e944c8ee07c205fc7c09675ada7fa5199c8577032c0aef995b41fb6d72a9e5d1dc963c55820e646792d036d061fbb1fec11a7fd81bfa965610d7f3b520c5eac5c3f00559a9c257b7e51806940b96c8e05e332416c6adbf500da1e2e27c236f888c9895d8c94dbd11dd15a12f58141cb737a99131964740c8b38d4ebef69d387c32c68e4d56912d9b7f1c665d6961b6d948d90481e8a09a1798dc3a9d7b966c8bfb88070681f14d1dc7946ff0771e2639ab37c99bdd1b90020e7c282a87d664a025d2470f2721a50815e289c7a2d5b1de3794f0b64a7730e11ec89569ac02b0a411728ee40ee6c1cb8aa05edf02c3f73b5e0c2de663840eeb82b8a8d046a14e535bd3c637780088ac9ec3d65cafbd166973c9c93f31d0210c46bdbc4107bce918314a7fa24a530eac35255f6a3010efeb1df54c7cb18a9f066f8508d72bc9afbed913d5ae29c797a8c7428e119b5bef99d9e96ec7aed683f23319435b4637e926e2197cf27d4cb3b5f06c7858f4e82c910e4e9c4492038016305d50eb5dc5e743f0fd09b3421515cd891e07f9e6554ee4c85ce15f37711de1bc1c14aef5310fda1c880b12c881b7f18a3cba89489b6d5a782d84a608d76d38f4a495d9c699c9d24f347cacce8bfe26f35ef1d5aef50e08d019eefa3c398b93ebda6e5dd3bc184382c0b7bc1b1a12a78147ddbf2434ecbe1968a5043de70073b89365620642e2a9e19b9587a0ac73933800f03b9cf9b224138ca460bebefd84779dfc4c032f941556a748da22c6031851c68bda4a55fef64cb995a2d9bb5abc8a576d5052d68e3c183350b0fd74e065730bea11312ce9fe7d9f5c2630af6e0e24308622d8e2b9f54056e23169ef8ec273b9260a863865ee505a2419bb54287fca20f61f55999e44ffc44c60935a3f51b982a85273c51ca1e0bd04ecfc8029a6ee69b81a706708ea69357eca30f58f94923fc217162ea92f1314115e19e06e5f53427925439f15d8bb3c9f0709c0c3d210b1489f8a630b51169adcde76ae014c24530b160c7f10a97054b953c1d3b184e94b3ce98620da434d137a2ae24b81c196fa36772510174e2162af143f766e2a012550f019ee553a2a362785db4d700556371a9c800ad1cc12b87cc0bbf0cb74f551617591a8cd666909347a407071ea759328b78c9c47113baa154e185740db9bb2edd219a0ad5d3a4ce6cba02eb47baa2f162118d22935860fcbb68b0131fbe78e1d217151cbbb9f4a303eba771bb2e418907fcd1239d747294ae2b6c89323eb1686012a8d36d20b57bb29436623bec43899fd394e33d55a85738e32a05916b68702a05df35ce8acac03b5e6c635b131d626c6536e8bd93c9e7254c2c7e113d74fd6dd7ca67a9abf8e2625cf2b873cb84d398eec23c6b939bcb56810b02899b15e50da0fb196e240aa6bc3783b71185447088465a09d8e976d03a6e87c80e72c31aaf64e1e63324b0de1925d06a548888cf02b84e742baf848ba25a6030d6bcc44cb54fb4a4d0ab448ff6d5e9526db588fe54958b75146db5570b4711a2c209c4c56fbc55ae39956f15205dbbdf3e409b24a519d9fb4d4fd32bfc90b2ff79f6db8926de22723ef1febd4e13d18c2666ba846e843c992b6fa61cbd2a63244196c1164acf1a34286093bc6e0e04843e6537fa5b6be93600bf9c52adbfe90b02e2e69b95004a207ce49b07a5d463a420fb96e1534307f504f5709e748e2360ab152be5c472cdcb55b1f2e05b8b826fc6c6246d6ceec328a3f18a1aed08d49a41efe8a0337b58a119d211fff71765469074e20c09c3495c0b68d362300344d5e25194e2280dc82af868c3db6b18f3fa28d79c7480a4ba8c93f32854f46d8e61d3f1a121167823d48106c4bf47bc0c2b3b9cb2e874add892ecd2160d39ee4df8041fd8e92d6fa336065a72b557d4f762549a1ff49a94a2e6868bcff791f2f44ee8d8e0883892578fa85e4d4878a6782b44cf8956625d034f8b0b8ab69746fefb9fb9eeb9e986432042bdace3e973912b09c9b209f345b6b981439cd74ee78b0bb2dcee51210b0363f034f44d9af01e304d0da8bbed25ec751e353d81094f8ebbfa21af5e997858cba2fdb85cc9c3ce828aa3d26e556d79ddf367817451b002c10ad01e00b78ca42ea13bce7f03f22580ab3ff9cfef72b3bf40ba8bd16f6efec709d6988f91ee96afac30867a58e584a064a28c61393e6488edf4f83e78b9984a5eba8a7ac24aebc84d8262726d8823f0f838bd39525b86e3ad4c477ad9320b74d195246243c94d8d1c5891a65b457327a4bf73830a09ea50b5bd56a95f3909257a68d5cfadfbf38086f80bf3f93009f16bb2496b61e0b7254b8d974d6bb1be0fc2f1806d05b8a3f8c9c80d6bda9c2259ff8fee17b7d5783263833576d043442e3d27a9b406f332e3e0e247e926c5cbf31acb3599219057d2ad664419375ec36e61971ef4fb52c280f2e0f1fc147cbd7093a50573fc051fab1720cd889fa89b7f3bb013bd967cbd346c15342a9d615d1b331b26be87c6aacc2632009b871c2b1d1b1803867b0506b410a3feeaa1188d3dc88379c7b719166a77ceeb93bb8f5e10696c94e70f814665bdc9a575d0b82ca5acf01a801b990d3ff8ec24bed99af18a1233e80b1cb42312b3171396d928b0c3d0f1e2df64346a35e4701cff6741eb6f8e21b98069bb2d74a29fdfb02d9adef728f675f4d8467bebb1d4951b737875bd9399c6a2fd6152fac8c91be46b3099ec479a09fc8179d0e459f563adc663fec3b21831557e12f5847972ab365f6fd5e726d58c2f12d6210d63ae8ba206a987c02da1dc0eb382ada43ef7cd965eda4fcc10237601f2113a4016c45297ca83e4b6443b1a136426e222b00c6a0a267a687a3b270068da14d0c2960121d0655b3192569d0f9746dc21779e10340521f16940105e6376f05997b51e004e5dd235e9ae77c17c5263120d5cbafe8dd897955926baf6474b15fd84ed03bcdcd70fd43f8f043c3d8ca76dc9a5c244563a32d2f53cf880cf40673bf839f3d74770671bc13f18694402fa4bf3dcf3fbe8e512a2abedf4ade4078768ee94e270db94a8fc58472852967b61641c7323997c6e22d4bbb7044929000337414fa4e38cdb755e681c017933af10d40232f26eb1fff05069d89da7844fc791f827c9112448143b74580019cc4d8ee0e116fb90d010f09acc3d4ad74277731fad716e773d69eedfd39ed4b8f2b6027a3202f9a335f9157f517d55581db35f61e6c3c75e2c4a32961c5a79c70d5c287a706d031caa3e62aa34353a6d2e1a0226e7c12c3b7a783f9a1bc2f0a91d8bf473133d42220fe1610631b4dadcc8dc38084a0d7b233c26d3a7df6fcb1b1ea01818a230df17aa9a8fcfb70c799ad398b5909a2dcd8a873062501d04b1f4c5b2e540a34a44e3e25cd56cf6b2b326e7ed831988807e58e99c42e058b2f9e3c1285c95a15f635b10ba7438ec7f4a8acca90bb325b215555b3ecb222c5c69d34a279ab9378afc5e295293e762875bffafd20152584ad063f5cf32cfb6a51c9f29c1e5b040006ccaae813f3b5fc1f00f138aed5f8e6e8313762f2c3700b8e38c5d461836e3b0054de629e4c7304bbee8d53696c0273c4111c9d4d7a75a4397d620403a86ae727ca91e4494adde8fde39ffa955efaf1039aa846b2ad57dd17e01e9eb27564216510b5c89c21ecf79dd7a39166a954bc44096cfc279d8596b31fecbf205ebb8e1fde3ad72b18091ab4262f65c95e2fb76dbedc2b3057154e2a81a69e615b418ebcec5d3219a3f438e5ee81eb29a899d39f04a7148a2531c9de6e542f120a889421d8bd062b187e827086eaa520746bd161d1beed416650c1b2e86d0ec617ac6b01e6e6946a91280515efc151c72745faa4fd573ff1516ce824a25cc64e0e774d5c2f5bd7c82b59b7390e785c44c144516646c9cf9a0625a22e2ed301c232711590479eae5e94a1c2602878a7a7af8955fca9d43b7bd88e353bab69aa2a455ce237cd9ff4122ed34e1be859b0c178b0fb918a703e96816ba6130ba2eed7eaf4a857206c2913c84b279c4d3d4ad35783c36b9023082d4bf7c5122dc87ec9f02cc6bde764d264862e07587d6c241ce93cb16c3f617c9bb813dfb3656cf3d9c178e6b42e6fa0c04c0cf56410475f215f594ee0727fe8aa4d15ad0c7027b99583831cc43c73f360682556a74436a97d7664dbd34cce8aba721e2a83a2d0b3031b8af018a439d370e58f42e6f4f69241b5e32767550031fcfeaf745c57a870e896c9103a9f769b06a7132023896dffb1c2607b9545f2c0dde168b751a967a8bc3bc2d07977ad1f5f86c087c03aa833ce72de801b017da719bcaf6253430d5390f5bffde5767f4ed01997d66d102a3c2445b9209e436d62ab329dedcba1965b53cad5382ee0cd2ad2dbb15932d0b2f1e7efb2db33041b3fcfabc4966cf4e1cd671217ace1cb7dd60219e3f13de98de3d6371758db3e2d361e9a70a636c860979bc79726d4f5ff54454f9a61402bcc18c46784d9a38e95a946c881614272144d933624de9c4bb631614063cef014061db2138073ff4e8e175fe5bfbd788d7b9106084e033d3b4cd1bcecf2cea1b83cb884b546aae2cc458f4674d0403e5fb94b2bc4b41b7013f277fb04cdd011e50e42234bb171a338254e85919b5b862feceb4848b46281aaf5be504e44dcc82d52f6eea8c35995a39804fb17647d0e9158beeba428086e0b6b8485dcadb3bef28e8eca831fe970995d76e5c63b7ffbc082fe5c7e8b2cea22f4fdb3f3de5e3028172ded2ad427786f60ae27d412733ab13e41b766bef668aa3ef0b71a99b09c2bacc6419dc8de581eee3024d9cdd0018cc2c4c5173c3cd46bf293fefb6ccf3827dc090446f45ead95e57ec3e89ffe4898afb754b88913641d8c1cc73db010d87644fa4b4bd76675a48340c2be02a03e1d63fe57b40702f35107d1b2eade42d009f5c14a35bb887974366313763ced60664aa869adb2ba6ef6d1603678c326044a9ebf33257c87f064ec3644746d602dea43c5b7df370d7ae721f249f5171296e39ac22ed418b1dae49aa45d524aea2d97a8c91540525f6552c4fa09165c62c927d656e3a7615c4080f355360816bfcbd19e71b1360b3e021ccb2bd9f2cc8c7473e7d8347435d7a9e38d6871e9b91aa4bef935b3ab708dbd487b5da2b94372d14cd4eb72b73235f70fae99a730ee3cc950c55fa50dc82b61be4d65202e4f676af7929dce2e48b5649511d9f54468670b4e962182ceb591afd57c8492e5f39eb321559813e3eba6da85750dce57babd71c25538cbd5287f678496b7eefd0686c99238e0539af7080f106406d5f3f89dc0c6f8f83f6065d9e973c610b7850d1f2b706fe6b1706af3ac394114f508c3ea40be2909fe218ba1cf839b6db27bdf293e0c5c21abcfa97bf3860abb234f7720553e89517d6cb916e996e8c0b88535e60b3ca53ff9064dada05dc869312a528fee782ec1aae6f80f6467f2e7c571a5dec646dd4d6fe0fc846cfb11f5f446af93d3c1798096589a9e1bb033eb672c3e6099dfba2956eebab759651e4fefda65b9467579dcde2216d970c93e4aa7d7b64617e16d6ec86a01c9e99a130dc6a45a135b03735a976ac26ce0929a6ee6e753053e87f269ce2d5568181ded1f4ed0c094aed6b6981175fee8fa03a54af15ebfdd6859f13ed450d3234b9ab5e0188ddd0a9a0a92e51c8093454e017fc21b5baa3d3f828b2d8af5bef619f56971870e95aa87cf2269682f250af1d6a567b2c039772ced2f65cfe7e64a60037890f6ed4ad7ecc66cb77f0beb7c79acd509ee88bffc903ee47b749ae4462a985008d6e809da7b2e81722bbbe8d62ee30789fd9d32238a4e334867957616f2de5bbfcd0b63904e126b9abd2e254254dee363ad7e3dc8771ce0fc1e1f872ef35c54bd85a7e0facc14904eff777ae55bc49d5c3be937632a9291e733d51cf64190c5bcda47ffdc31495a62c3d608327acf24eb5bc364de471591a27a12f22a15468aa008f70b9f630a2986a5284f6172534370755086365c62439c67591d5716da9657471cc70a079a0b43136decd2c92ce1123a4af741474970f6c484b38cfc7498b7fc757c76f23eb731ae1201e95b39f163906eb8d1b9702250f9239a78aa39590bae5f047f74879fb0ba5e49db6271781d3f3869c22fe39cc8eba12c2c8281791253b035d1483468b85e4ecfab299cf1cf9674836f229e6be6a8e69dc970d9c9046dbac55494b782700304a45a73aa8e2628e974042079b1757daa2e39261759047df74115122693124b688e7206e8f707fc963e77fe32dafed7d1b58e3e152019cd58da7f654fe0924a3b5e8c1aabf67de0f8e3262144feb59a1ab16146af4a625542ac559f149ebc5c07fae68e42022c0ea1361c6754d26f676ac043c6022a94bbc1688525b64d5ea921c43c0f4e4497d0b4daa9ed18fbe8ee459163fbd47d1bc7ac66469d0175f5bfaa40df0eafa1de4089c09a2e96b398f9f7b2032996c40286603d2d70621e230546eb0cadf25d49307f56f3ca138bae5bf60a39230efff2a90fbd2d58aded7199cac8cf5b48b144a939da63053d310e9ee96bfd20f106547849ff6ad30ae268b85275fe131ccffba934804afeffd7d2f49b9855ba2e4a5d2e8ec9c7a46d03cf36db8c36ea9cc06a65b6c9ac5e207a55c82a99008178667971b3cd8c72f19b21a64574443d7850ec77db11b594d4dc34f2fafcc4ae34f9de9e796db300b42f8b9e491280772365e1a0f92c9d945e5800e0584c4b343392fc4193165b81578de7b347cfc7259b7cd4566e71ffb6f1c4d6ad911396725173510a7844720567d9dcb174e811b7897e444f837b5f71aff78222512c9d1019a0825c0bd4e830cc9a6312a7634871a413f5bc72469ecd694ea6ee023d508d0a34b9d2f241bf0c7981f4a7ec3342c3972c406453a8ac5ddb5c233581a42e6c6d4b3b4743bfc69b489d525c7769aaca1bce378ba24bde7411d2823d87f6149401d22b2b5c05f53bb7355eb97709203b2f01097f9369bcb067153705a534d41e80c92841af760adfc910629f7979dc79a9b4a027c3dfe63b7ada100eb5b13f30406c586700aab9590151261ba467d9b01fa5c61bf892a2154c33a6332c894cd0c0c7707f37756769049be687e1badb9f20f55d9cc2f78794ad45c87059f15bca583b592fce6d6e004b93507051884b74f07792baf280ee4b1139339c8710d7f3029d0807e1dc4683f79712ea40ddb94ec9cf36b0cb78745aeb03c497e1bc448a9bc92ef0c528d16e429a95412f55826d17fc9078aae2bb7d3537faf6265196e6d151dc97a37252cc61711d30ed64245c05ed8453fdcb30bccbcdfe12c0001c592c94aba4172a72feb88952cf756abcc6def2bd54317e55d70b2dbdb48427e27edaf0a6961a97e99682c7cd1731d10f1310916fd19aefda4f7813b7a7f37bc4bb2d208314cfbc5be05aa6d1b358d5879eb0507542c26283499130311d5ab905d8ba18d325b4a9ea9f96c664fa5dfd0bcf823b9597edac7817f60519b86a5e0e17392797813d794ec94308f14798079c5f991442aa7abdef363d4235546059d7d6faf3983fda973f3a92521e30b04e8274ab6debfedf84ab34c7852ce67bdcaf74aa1453ef82b4719fa9e63ed990d3551ec01e9ba35f31ab147e41318ba5d56133500fdfe7f228274d02d9f6c580442ac55646ef72eb6f2c038ac0d1485fceac9bdf877aa05e5e3b6f2a3a9da7c1f3b9add7ea9afccf4acf0812a2f7e5896bfe6377b20716724d6923398c6a0a16af7a49b9a0aeb969ae1d0670dd4327ec6378f089a47bcbaa50060a61332586577d8ebebbeb9ecd7074d6efd6d7d3ab6988345b185472952df9f448f0397fc33ac0b204f0f61c770c00cc6d0e0516e11989549e12724d5b148de937bbfacae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
