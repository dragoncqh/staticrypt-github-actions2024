<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f669f1c9f6218e18c3795c7d0448131f159cfd7af4a4f431996d902ffde2829bb9dc1fdd81b4bbf5f1fb7d5c7452632b46234a6db0c86b72efb6d33402cc8ec190250901d1b3a9978eab6251f5bfdc593bded2506bc1d2cda17c03533a28d0cdd8b87cc4ba2673d8bbf5484b2f5e31577631fe53da30a5ad17bcf9207c587e48f88b4e97650ff3e4f2297f140b7638a32fbbc7dead3bf6acb1b3dbd7a55e3f6ac2a7a0690d23c0c066508d501e4f8f28487662533e719d16ad7599da619836c842cc4ffa41629031d57d9b68652e6fbfd3e4fe7b3a9fc50c738f0d08e2f855e81a032f19c665c80a038a704e06cb202fb03d0c6225cd5775d9e30d45dc0ec341783e3299cce37a0c937a3409775fed88e5e92520241b83a06aeabd1f7f06af03784a61e1e403e628dd2d42e3f6c212a75f7a9a4a6813c2aee1b5d71436275c7cbca16423c49eb3947be0c475a2fbd63d7953c12681e879f18556f1227b0e7bc9f166265481c55f5ccff4c2b9bfada4c7df24ba1b524aa89c9342fb12828f398796be49c3fad07263e805a03d649c85e27f1ee1dd7223289359161376b6dcedc046b3f81cc658a2dbdc293679451e77a31b0b3d674b4d6bc42f332127210983997320ed6b2f3cdc3ed384d66333382d1c25552807b2b03d72d0bf9e260c51fb1cab83a27e7973b0350f595c679b9ccbfd44a77e4caedaa7f88bedd7b75c6a9bd5fb7b876fe72aa12f3fc80a4fa5d0a4b7ed5295e327812a7b7adc66a28247741910c6d39a8617755573687aa913b92b26abe8f1f5e98fc9d887407ba48d1b165e67225454a4bddeda89f78ce534aef6304cc392a9389b44b9a7ade38e66b780870b1cf2c215b8d5c9ed317e58b649939a016d7581585dcb0e7a9975fba30c0a158bb6566c765756015b665ee98ed385bdac502439e14506f4b71a90795f969a924512e4eb22f60c0e707ff6f2374a663367bbabb06f175578f7b6d20ef25431dcb056d542e17587da946d1eec2a15372c70a2dfd533d88c1c9c5932c170e5413482d4ead3acda183f97c07640f13834f600321deaa6ddbe9756fc6718e16851d24c586fdd0a3a59cc3c8624a5ef18a862fd7c3fcdbbd8fe7199023c5c293ab0feb31d68190b18a86cb60abc1c6d4b8ba8bd73d764835d235344571202e23098e7c6dec45c3a75448b4ea586f540f3cb6f15548629a8477a5490818ff800c7492e22745c7b6b9ce56706fe249ff6646852a4ec2131f677611d26119d519223308a9f800b978bacab948f623cf621110e3297c5bdd8915bca96ac5b5bd72c5c4d0554fd71de2baaa38e0af812ad1ba6e2ec9d12de368786177d9f2e765f1601dde0158e63bbd6cf8b875d1ff4659cf27f6e85682a72a668328b65935a436352dfe729e9f2e193f97696a6c0de2cd129ed97ae283d8a6898e31f93c115a2e4c4e2383cab3171b3229602f0b72e318c6ecc51be4f6be2fff6eaf565cf5dccf264e249a19fdc5f27580007c52bb66b4edd321d471a95b26927757d180b678064aa8e23ba39bf8ea2e954b6be19dd4bc03537c71fd54e79c78fbb595662e3256d5e5b16ae63ad50f114cc1832755b69292eb26785e9522c9d0b5a75f7718969df37d9e14652f124fd6a0f7647e3be6acfa7ce89bc52b6b999dcb05971015b44bd99e3aa2f66c7af1119321724d6e666221d21200a7f2eab1cd25e02bc8d845311b59c96749dc860469342117894f5a6b619558aebe763dc83b252e4b854435fa8f8b77612ea3285e2fe8c7f54544591a6892edbf6a04492d02fb1284ab7fb842a80819e342ab065a78e9adbf8cf0e42b825a363605c03fcbb1ebeca99f6d164cd6f0a9fcc7757f6d65ea3a4fd6e9a9bf7fc3ddea299829ad2e59c2fb8b25a7f89a4fefcc1f28b75b4516b60d1b4b5d89393619d325efd65a47bc5cd22d03903c5df63d51388df6d8534944be33f98bb97cf0c77faa30afb6a83b10bfa603f608ea9ad1b752837b741ca1a8b06ed18f3dd5c8c133dd81ba25520e52e066ea7c55ea66404c7f6fa38c98fdb897a23cf2736815c82be792208b1b62d7dbdc21024ffc34370f78064514171da3d4334bbe0a581da4beb74d8b962c4d5097898bb5788c987d7dd5f9632c23d8c8bce7429468def3e82e102862e83118886f680bf94578a7351ec330a75d5da2ce1babaa11052b5c991c40b5c88623564aa40096d371a9195b738ec5b509a6badfc359e2ad85a5c14a14a8af8b75ae9031e5025087c002a4cac831866b11ec5bd5160aa948385ad8eed3e2742fda8740370c0db281a3c2f24722ec5fc51587bf942f59946578ed730b32b96cf141ca98a0b87fcfc1b50f32453946a53e9b76e00ed0f78236baeee86d1507368201277012d634ed20d8398da4cf802dd6968ba8085767caadbde1dd3d180b6f95889668127f7f65f245e4908d10aab81f883f1be41ea94049c37ef15799327abbcaf72c20d2fb6778871f2062347104979a3b019e1fed996a888fe30a8bbdb4ac95b1b32af065ef715cd706e2e48dfb6d0f096074abd50b4864f3f0ef9d911f7ca26d96ac68e81b944f8e69a08f7b7046640917d019135c2eb023a764da2428f8a2d36ed26343b2a7bf21c33cfa777bdfe11dbf5eda01089015af5c1d85ca196c4d6bfe4ddec85b9d2ea945ad3e8489a6c876f2214b435b294f4892ea0ebc4db6a6c5d8519d5e6289b4511cedab83ad01b90a57c2c6ea87c84a42aa0c2329f8a2b6df4c65c37fe38ace51599b0a375b7dbe394c97ad109c78ed015bd2809e3ddc7c5bb2fac163de7fda957258fc6e4550194d9db06f581e2783837d9c06c9ca3c35c3712f0b01128e24a691bc098932113eac1a004fd462242e1164186896743a706f04c1335932078036f717ffd07c4015f96db6f0757d6753401674431a1610df3e13f4d735ae40b46c99ab59676058d666d43126020d5e86b0af50b4408a74a21c1a1ac1f60e466869e9d0044b6dc8338aca91e3025cc76b372d5609bd0f477d56e95364d92e987e01caddcb86203d91429c5877dda72a68373fda96eb0ef7c1d977440f8a3a20bf1df680407d444071c33f92920cb4458b739db55b79ac10b135ad0fca0f9517e71f4c57c63a00b72d5debecbfa37b06026a3af94581155c89f60b6ddc8e7c4997a94a24fd62bb1ff241a08f32c6764196c9960e831fd4824273f82fa42806af6ce536ba48789fbf46ea98f90c71a9a100a85146f604ccdbf08704583af0ebd4ae63327cfe7a2169f323011e62165f8788db427534ebb2908139ce1aa69b34ce202f80a21fe2c7906c1be50249358fc4fc6d14e50e2e82b498132ef6ae5d9a977b2a0664a893f0401681345b1147bf92c1a9c5f290cbea9fa7f42811c57de06732146b45a71e3ae9f779c1ef891d3cdcfbdc64eeb29a80a17b982f2c667f182a027fc2dbdccbd5f41855ea4b82b49ae1af6eb5bae151b1eb292caf3cb347fa308390bdf75a55bb2fde09159f37a50ffabb421a32841ced937bf4b1a232b329c0f96289e50ab72cb7fc915077086124f181498582becbb0c1c96f6a01a05887cdc7f703b53a27a4a9f6e93c9edc4835785815aec2014f0942cd3f1559243e6b2f6462680c8d8609b88fd77bdfbea984983a2554d1dc93b5ed4578e8de937004156f3f07351627a35f74d72534561dabe08eadaf85dcf6a1370c428d7317e58777a16282501a6f232d210c95c8b500d776de4a2877f5023129511a86766af23adfa9cb0c246d5f11f7eb85c1c3eb55d4722adf025d35bd5a494ef5c0a3d55acaa60f5d4876a72445d8655db72bcec1d6d7cc0ee2ab6bf941d2c96fdeade49287a8ecdd0f9a0aacf39b7f21d77a3537248ac35df9c5e6a07fe41f645b0e3df6f7190d9efcc96640fa36dc7fd7fbc2a873d1c64d0815afd1f1f7343b33919082ffa20c2835f67a98262a6be56296eff5920bb3a4287abec7cac9f691acff4e0eb54cd5b8c9a197b6541de4dabb2387a82866cc0d6c97e2ff45b8bccb3b239d9ab2af6055bb8821da8b59be2ef07cd401869f4762629a220642955bbaf39eb06cb5a90d14d8d17482d80fe2d05b29b69b6f3daa0c60a6df60e0368561200fbe34e9c8a8c7a4d024df09147b81acfe6de867adc78dcc6052f48b2177d54b604c7cc01a7b1c31fa4037a6cc991a7ea63859cdf7d5a1c7c8ec77627ed41c80250e0430d2ed071fb86d5060d357637a817ef240c203ea5e584340201cd6b0472eebc48f914d2a45686ed8992148d3765d22df5b4da9f827b553244a2aef120e5fda51f567439f45471d3bb7835afdf97649788c4ee68a423b9681ef37c53524da2af7e454e5a3b3dadb9553b54b40964a07406109b5dfbe950448e4272b3342988877f2b7af9a6b08b5c2de6650ea1af53d8b4f72df87dbeb3289368fcd1fe518410a5e3dc71822c9bff891895d8852f94bebdfd89b38b0278dd297705c025389f5deb98131c7bdefde7f8fa41a8a8de0e58e0769993d08ff2dd1e820d1e5baa61398b66bea3c0cd63dd5ff10dc4b2ec64224f9b07e86827de05fbf76bf0494c1e46b07c061725cb505f134c18e179216a3fdc8a5b45b849c2d56ccda68cac65841ac4ca6fcaee0514bf8b0a97596f4699b0e02c6cdd65b3b987cae9319534ffb9d0107fb75bb846859d24a5905133d15bdbf91c67c753de0a5b246c68cc47b8ed48e196fe5e695518018344111492b9a63824d4099bc9ab09692b317b43c4698ad5010721f458d670403860efecbbbf1f6134d89bc8c8dc078097e91f3e0187828b67ad848f7fd65f102a6812ccb80201b4490f3df620a18c6aa3070501410f85ff9c6e4e0513a60a9330aea9d348305e29ef121dcd7001baa9d54639dea5011d61eff181250be1b1dd3ea9ab3d309e41eb6d0d1536b4618072d8ff18a480293edb02c0a7d27ab5d4397c5a828f883b712c870659576309c2e58372ca12d44af467694a1ed58ee95750d854246c714d68c0e95641da05c57895078be819a5e648ead6a47b950888c0a8e285d6c3485c9067e9326a7671a892c1a5e29a1efd5cb12d942b0144fa8ee615f6b61b07563baf2819a34c00540a6d3a60f527407214e185f168e76405c732675a7247b21a886628d254da1267770e3a304c1c12968b4eccde633ffa9f5feecd625abe01735ff44ae275516e744e43812c9345e753daae0e53c6a197a14c1eb56723cba6d2017e5c8884511fdb86164d597acd347c5d7a98e566d4c46f7ea8cf8b4a27092570d02c8c44a4a30d5d3747f01786eab42ebb555a7d77f102583cfc5bcf3f8417139e0086162c2b7262c387ca9d08bc3ec27e3d328c7d211f46ccf57f68fc5ed3e4cf67c5a468a0e83cff010865f599dd2eef1f58db66e08adf2fb07adc9f710374089336fc5ad626c0684503fcfc03b31229d0afe9d376a12adb664aecd60a048169c76682ee893dcfa93405335b6dedf09fce757d898098a27f2acf2eed9813dc0bf0134c317ee3f681ce13e3c43ec1d6d144d24d3d42abd152e80aab4b50e96f0be3f91d25e4bd614b6f29b3c1824939b3692baba1fa34e159a0e225261d692dfa2ebbdba37266b756916eceb690fc12a726265adcd17d801301b4e8ea6cba732bddb233e8366293208104957a1bb3587657e9295c07a4a2d583b458ec5493664d1bbe2a17b17c0448355ec7c8ca8340eaf3d9832a043f3cbf76c7484e65282bfbf1dc374b0adae02ba2d767882b408d4a8d54be19d46bc1c931799b309eb5d6a90a64eb3047b7298a7f35b871ffc63bc47da6b7bc02de518744efe1e2ce416376799c3596eaf560d8fb07877de3d6dfe12b31b3796eb50604241ff38b63ee916720594530a7599ab31ed42a39ffbc4627c0960c56fa1c085a71b6adf6b995c97e7fd5f2a337700c953277e402fcd5fe6211100b8f8c3dc3226da2e9a83bef97ae8333b37710d891e69f911b420de866c609c2ec48ae1087f3527d4c059e25c59f1662a912e31285feecab276a0b3c15e6bf4664595dfc8c806da5df2bc7f1d33a52ca50f435c6bde5ccd4ce0b2f84112de5e346dbf18153a7971f60779973d4cffd6bd7587934eb3b0605b376d49d8b7f71263a4f0c302b85edc848a025ec3d437d5e8fcd21354443802b2bdac1e52922c43009090be2f4b7e2f2ff7e722953910f442d9a2a9af5f8d3d7d9b5230dcaef1ad44a4bc93838ee0c5777f35fc220ad4441a6dd031baa9375008d10db82241c6ea5dab7154d48ec934d22341c90a723d9f6db642b27bff69ac361c717048f7278934d335c9741c916dbd5fa97c8a068d73bd32686494f16963af3ed7ecee3bd7f96417f507a971512991adbb117512b8750f2ccfe1726910762b6708de50b705631042038495ea7ab775589d9ffd3634b7d9dbf76daa39b891b66289707287c3e696400e489f48edcfe6f7afc7a1a65d0f9826327f71e153e769683ad7295d8cd50b663e1650b9befbae0770a2bf5171ae6838d6e788ef026369dbf4ce44bc47e8560b433152f7ae0823219962f05d051e87b482ce48b554b4d40c199a017132e6edb4a1081b29a60da2969e9b94ce213c67e78ce6884eaf72782c44f7b94eece8583d8d72c2b2b60a6b6fcf857a0bbd6337ae1629468443b2b4ce60f6ef3640e9a746a0dbf6e0f83db402003aa9d829c9408ea71331025aece7770a729ecff50165ef71921d3229e17e169a2aa01c03b56849182d511c35b092f340a9996f31c4952b221a98a03f1500d12fa492e60e042615f2404842f11c07a44533918b7d2ac7f1f5cd309dfd832e3ba5d1a7b68c2515d86af596000168792833a5a5ab6a256a1dc8aa3ca108eca889a36b8598f1bbada4a289a2be177b6d17e7a24657478409d01b0482598661d6ffb7ea70773c2ab3909ad22c13c93bcc6a56ba13f0358b633a4285cfa16d0e2de2a60e92f3ff1cd80c7745a16bb5d6ab3da8cfb29c61a1c1fb53428f9fbea832993e7a69fd87d5b8e66297c78bbf2efc358f00e986a061fb1518653665d1c1ce039cca60a83f43cc8b8997ea6a8cbb6bc06dad5eeedd5c8fbca3cba5ac82ad97ef277209d4090b577225cf40e9f2cdfa2598666f3432e7f151a03bfd3b663e0d88b1f9ac00851629fdc1a50f5c39a496e9aee0ff7556acce9f6349bbe1628aa060a9889ef82fa4a583bf16afd978d5bf497bf75f0d724c6a789b3b0cc62ddc4868cb96b4f9b7c631950e6d13791d1954e00fb326b93f7280587801d01abc971a7321b9e9a27fdf7bf7c131cf28cb6f24e12f32453cfed88f686c837bbf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
