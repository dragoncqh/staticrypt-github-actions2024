<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"236ef70f2b27d0174d98a46c95ba59777f87d212aeea5f41aae611e97ae4be16ae1e63d3c5d84efa1457ef68595ea3c94f82b9e7651410eb6fa18a8f919ef38f9cee8d42e30defd09b8cf0d0eb2853e4eb7361d46df1c70aca22860cdab490c4aab75faa0085d9931eeb0b6d25acc6edb8f7877e852fadbc453426fffbe217daffd97f2d54f0a4d35e9ebd851cfb2b8500efd5825d9aba798cafdd768b4b5a40a90d2ba7a225c3f96113e4980bcee48e02335baea33ffe689cc77871cc593c29a976596583b050428a813674c551d18e7951ae9016eef3132b5711686133cfe6cf9f5429c4e312fca158bc19e12e276ffb8b732fda2c300ed42a3bf53f211dc3342e54f6a38c43585cdeb7ebc6a4328c3f5ac573896f367f5433aa224ebd83827ca9b91fd7f4b92c70bb8f9301dbc3b37620b48d2ff75c10d0178d1c1ce77b2de37ff9f7ae9e727625ae680a608370d380431d67cc5ed0323e40632fb480424d94208901342badf5caba0bdfe4ce1acf75f6b0086deeff25671791a05e53f899bcb6a093d6e2fd4daf1e9caf92c28aff73937f73d9a6f4d73edf004db2fa47362d01eb3dd195ceef239fa5e832e7ee32e9482a0cd9cf44cb978e52a76d161f5e523fc33955b996250da15acdfdd4ce8dce5258146d44f4b7319d0990191b7db97098010ceb0ee2357593348b1537b6b657dffaf80eac7179fbcce8e97ab41afec42389b557bcbf9e180ce6efe214d1a78e118d62165f247213f748f261f7f1f9425098827de3ed5e0f43389f35051726d093130cc0689942254a629e01a0eb4035d5c5300a0ef0b60f6c764e92361d4c3d5bfae1f3b5e323d6b78552a03559a1cad91069f557accb588298e3e7a075a192aff7d514c2075fd9a92f8869fe6e409eeb031970cc9bd375560f4052a428a95a3c3ff724fd6c35b4f48cf7abe71d0480b994c4d67aa192bbcc7ffa88019002f7ec489cdf3aad1a16ec16663b83af8a17171d698f98b5ba63ad21efa1dceeb006daaac9352d95327f0f17063c4fffc22683945f83f57ced0431b98246c85062a6d2fd6cc54fb283b395a28fffa054b6921901e7f536199fcc6b0c7fb0e2693bbbb15a1159cfb00fab350bcf9e2cf03cf2ef7a9f599b680093a6a2a745a56e0a2fb12ae51243e44a598d1e70991cb11fc222d1f161b6311ed9c3c55f9787596c9064c3a46c9997f38310e134244ced61c37ec21a1f690fde6c935a8e088cb8406d63e37ebcccc753457f5f4dfc9ffec1bc46cce3ae094aff2450fb73187724f8b15da2f98f139e6857d66085101150d0d475ae3d5b384d6185aed82fe6e564c40ea49afb0377643a309408d2c30a583326103596a9834c22bc59534d4b8cefc4906f78f3bd14c0895032edd6aef1e937f57a63572cd76de9f2ba79ccf226db5af9e2767d756934511f5c8c929d14ab872a899987583f7ea2fb8b9e8b0b99843936f79db08ec77d16b34840b3f3d75b04a8f116c2d3ff088a4a8d9284bf30e116ea3a78e5d1e2a6167df274575b6e834b96231ca34f739023c3f95ffc41881cbf6b9d35d4a5f16802b0b76d17b030a4c0355b70d5c8f4a020f075c398be39a40aaa610203ec1f556703cd68defbb23cf19195638fe83443f5510eff6246c1804012f198fe9a48f7d5c7b85d246e6d73d169a318d74ccaea14a9594596bb0e55ccb25517a023a52d1b619f6ffd96e6680ac126cf7d72bcaeacbdb6b48c87bb9cc482ed7d6f4d199cb00489ab44077de85eca731cad6ec4b1fb743ed06f633601e9d2a54491130b06df391837d38ca8299d67b50762737e872400890df090936b67190dd0e8ba2c4f281140b8b4b3da556ecfd57d592b7ad9e86d9f1c1363f204f46cb2f4cde13683e4dbabd9a0c9d45c6d4ff5d33864fa8c76ed24e992bb0f20614b3fdbfc94e57761323427922280df71855834cbc32b2ed6c572b8c0461b56eecb28dff805f375aa451c14f6ff1ae0facc385a15ff28019838853a79cfdb5f0d7f990e5994de0e5354b0945ca70e617a0acc9826ddc5aabae47697d1ff0b011ac5d4b038993f34dc9811666ade966674b8e8133e0c8124c253eb00259489484a1b57c57434f320df61c6e1333a23390d70d62baf8ca27a426133d89c8a04b6c3fb86c28959fdd27a833cda559567172468e529f3278a375e1b55e6ace4a51817382b27bcb1ee58544028e703c974043df8b193fbae131573fe4c3205d3e9f2f099c86df047fa4e4916fbf63c5256dad5d601c5064ed736375b12ca98ab3c121974b246327df6667ecca80512078e3eaec59cab5b46d85c3d3799ec6f9d2075d09f626617b1432c469b0aad2c267e0f0ac9040c2f811d92e8c413934f33daba8e436465c3028f10f42669e5ec34c337abf972184288078240adf82c89f64087f2ff590609ac432b8aae323c013e8a313e546b647a614d5fe73c707693fb3f9038eefdc5186444ab5a716974daa832449b66b110ade467ec14d441e18628bba4b334d47eab037618fe8f61af313b1d7c01316fc2ba08bbbccd07b0632b03fe532512bdd1a7e4620906cdb6a61b9d9ce288d923fc6b9819c2690bc41e49adeb48e6f6e950afa7b2f52a1606f7f12d3351149ad282a85ef17dd07a2ba4407f1adfd863849d716270faf44ba772a41b64ce69ffc39b3188648442385de3c3e50259d86a52cd3eb9a6b3cebc659177da87064340d3a6762712b906e0d135136bd8fc3f6b8021a6af9f47ca25089f135b189ff3afe14aaa61ea74d5962feb38a8d4b9dc92e1f26de68aad27f6b0bbb47316b4aabbb1f15110d8f5a30a62d3101d366fc11a401f4906c6cb6348b835ab5f15d920ae3d2fdebc837a169bb447ce2b54cfd93e293a804e20f17780c4b8b757b58dc713e1591e37d6ad1d6d8c77a1122f780294b0e3cfb59fb9ec97102031e76e1432e2e3673a96fc892f2361e34316e31914f1584dda05943a0d13c97911b79882c5c32f04b62a511d1a2d1ba9e301b4e1412a6e99a46a640d1e7d7660319c92cb54bca4feb012e257ba81687410cd4318babcd7571f6b83bd34a8735829f78820dcbb3889ee34660d6241f592174f7ec64c1db1bc51cdfabcc881ca7cddb7f20e3d2ba755de57650a1c89f5d870f15ea798ca783c1a0149a8ad6be970dd3fab4f2a140a18b297e48c437b06b6c7ef9ae1dadd990469d10e15c366e86b00db5f43dba63d1e8d71f78ca65572cb7647c3b7e1760c58246197affb492493a9c032fa0975b65c3dda6f12b006148eafba87c4fe448882d67a5601bf4817085d0542bfaf3f746775c273347d2b8f4ceafafcaa3f65e312ca5aa6efe3a777013e9e38d912440c2a0bdbbbb4c499636453c69d3565766cfa79705e5ce2ac11b18cb303b2c07ec849eee29257f8e8a705ea71b9a5d0bfd65383b3e616e065747abc28886bbab3fdca199aaa788b346f83b7df2c7f5659edc53e15e368ed1635e4192b9f021c98dc20acec4712d4a11ed6d8de54de35ff474163b94b16e811fb929e85c79b8aa7a727cfbf356fde17a5c81b0c2b12438c01986d29f318b25a1b356f0795ca73a858c3e3a577d532c910873e936cf99e17e8460d1bb07ba5afc50894ade8e545849026450ff62c5fec83c48b80170945ab7e57bc1d39ab9eabb5aaef9f1b50df5209c2dcc436b2a4445e88219752e842933dadc4815ef879c898eda57261c7045d61160c291aa9b3b7f44ebd70244b083505f7d6e6fbd80c9d3ae2799a6e87893605c98086a1babe5f70350df6dd5e3ae6e0e40cb163c97c4f19668b8dc140f3ac242779cb7dada449a07abe8a386d07651159b35c3378d234aacf13f5bbc8d6e862752f9ee08d0d22471e77b77d8543054cc3291541af756159cbed397130d7bcae407781f1c555e15d37255c99e6af1423490396a003599adf1b4465445a72fedfa4f86eaceab0196ae229f2ce1cdc8ef7469852642a3add350be2af52832864a608fb15a41ebfc42488061c0787e8b642b359e051a89384056e4bc883b98af2a1d733e91cec633094685e05b99218a6808d1a1e4f9c5bed966deffd5bee3227e73aa2c3c7f4f5374e9ca44fc2f264e6dc586b049ff8f5b6f387c8d73b902e84c1b686ecf28ff2ad3918c7df2bf3e12097dec622e5b79a498327541194bc4afa38838981cc2cd96504ee529375d67a28c3c5eb011754ac942b9730a4ea3855b931de10165f05f4531102363d2ca9c2eebf86d1f4d627a31e44b7ff5b94fb58e86b3b10cd4cd5b0824f982730fea53aca931019dd0147aa93b9cf8d9eb508ebbe6ed39eed42b87d032c3619b3330ff20b6d05605d1deada09a5391066958cff5cf95000323bd022155f293f4f2aa42cb487cc6cc1ac67d0a35fa34abf825d54d503e4afd52296dc8d575686e36ba9680b77d7e337048814c872a9e73b361da2c81efc860dcc48682efd5cba3db55425865836c884a6fcfaec8f72103c54f6dacc29037a042555f8d70c4f866576ce9447d199427f73cbee592a3c1857c2a1dbfb8cf95a04de9c8006bd30bcf100ec6e1e309d0d7c247999b7783014c6142b2fa00222ecb86bb002d721ad625e412e000272c073363cdf9e459d5581b953f849b85c6eac2c0b04f059426b04d1eb166f7118db6c09dff66cf26bd8612e356f38750e470db46c47cc1aca0996434e4050ff8d0b222de4435cfb36ab836f00becfe8c14701065c4ebf9c8048444d435babbfd68ff5520759f549a9ec165677969121f46b98c3a88e2ea69ca165376d226bd84f01a8e44d99e12c458da3ead673db863cd6af8684c6f1d08c52f07f72cc2e467214323c06a0e2863de65762a5208d5aeb8d13aa54c2c0c25b49074a25e79aa064acb857a72e94c41311a6d1585f7626484b425f339fdbaacef3ac7fca307154987829790d7537630d4aa4819b84cd4f11184a52c7134c2f974580fd88eedd4ed1f5b2aa960a53302cb543138476d980c3db0b6898ae891062d80413ccc717947b27ea4e6d385df20abd0509bd274a01d634de03efe19ee56d7b063b07ea2963350dc36b842fd5905e1833af1b4d160cfb031be9db53252be4d2d5e21aad514f3c9d746a2acb79de74441fac694ccb2507a14226fafa3ae5506de8c40d3a0d3aaea9c2d1543d193581b1ccf07a6a0ca4a5f9f8be2d7886307552eacf15f438bdfe3df5c842b92f603357bc93c03175f517429e97822702a263cd13cfe20430c79014842ffac504b429c6c2a30b2a9bce51afab8355a713c4bfddc97436380fc1fc8337d96faf8e7607633e1eaa41fa570b3e13adbe57cbe4e94343a5c601d0f4fa9948fd0d4e01490da86b2757c014c7e768fe9ff40f5ebf13d42044a543dd8cbe080e2a11f5715b19fdd7c0dc071fe5b2bf64f5948bd5528195ae0acd36b2e401691a8fb97d8d910c3ad7044bed01cdc3d79b4dc5d0f71b66d3d8329023aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
