<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aaac6866fc50bfb037f61dbfe7ece5af93e7d31c8d6f21dfd10148016250d71dbd8aa0bb6197efd97c93282637b8c0f19487c69a58224795be810d5f61bc419d1b45210914385c937991bfb21b883476204534f3a004915070dfe3c43cf4aab9f42959ef6ce2cc8813e598d3f2032d72dde1df88d73e1ae98dc8ab315ea881ea69c467ebf53d352324ac52b2bf9540af67cac97e90f68b5a302e788bb365500004712a6454b8fb282ab6822d95d0606b920e1193b73f2f8ac22462590c0f59ddd1d822a3a7896c1722c95f1a5e3ec9add86a0e0a5eaf229dafa8ed9378c2e2480aa127b759ce63b652ce5d131d38580b5ff44bcff7691aa6c23455a71f6aeebd50a62e492f5e2f924f9fa658794db8cbf33b3eb9bc4f0d78acd22294d5b556fe658ae52b7ac7716aa93b38cfd91e9a969619648f3ef897f625895e92e8d1bfc7c008ac7caea8263deda25e846c99dd6c962a402f2c60aab3da30c587dda72b550674cdcff3ba94b5bc6f99bfca9f7d6e47e1d8629379659647c1d349dc9d6d9e463461a5c31e7101bb1237d0ec58df81ba1018ca2285b180aed2e30be01bb8abfacfb848b405dbad32c1cb0d338401effb99e5f27bd5e97e0475099d7002cb94c24052dded7f65b2baee0592d5b68bee49204d02ca9ab725365bc98845eaddb30d0b768fa874accaf406f993e0a9f4a31a68d3139ac35b5cd6150d34a4ce84caefdfae3604c5fbc6dc10ad2fd2e22a36160841d05ab092f5486a821a3293d4bddfd4cdcf608eca915ce9516969eef4b0b32c44b9166e26b1158ba90e56ab9f6e6d3211fb954b8a8ed05b3743203ebaf8d65475e2dec45a5ffd94560ad32f7b5ad00a29515b1ddbfa6de567e59bf9962ca6865a64b51f46d9d6ab36b7c57a74f92e94a3375c15c2383ba16d3046cc7c5f370b2bb9660acb54202a647b3f2217f92bc103b2648f286a9c88608f047e05bf71835ff9ecfe9c4ea77f2148ed4533e8cf0a26dd40640e3136b8e83f2306bfa1909981803966ff1aca9f93c56554c99416b3166a1789c417bccb1561b7fde480a40fb440c20ea32431c5262ad9bf0c15f6abc499d1ac325ef14557ce82be929af5f37c78cfd728f45be4335ecb3a19270cfba14c3b6109f785ea126e064d692bc7aa68f89ce106dcf702ca2d5efb4f99ff8dd038b80affa9202bf51224b462f028d1197aa339c1e84ed26ef1a035c3ebe0f92da111edfd4773aab1e934cdd9970a945386205c9f1cc421858fbc401fad13c9991ffef943619729114d04f0bec4f21771a2e14e709f097ff29681db77f1c383c41236b04849065035d01bfd3223485f94987e445d2f1c063f6e2a2ffa594bffedf1f43025f862466108424fad2b758acef2c94563193806ced1f031a68641bf7540c929128df8f8bccf4f32da0e385afed64bedc3e35cb31db130e54147a65276fa4c9ede5a3193dca391a9457fdea39761faddbf368adc0322a843e0d672913a3a02aebb4bf1a45ddfac531bf83af1117b85e37b169c186662aa87a986cd925322ec174a2c47151c8dc8327bc8836a489e96066514499b8c86aea21003ae83364dd310bb0446fd5ea072822e42f3a22422f23b3e366e55591d6e806c2a2bb9da8f7906ecb3652f55af75547dc95b32c7581f9fe331b2174e79954a4ecd17e1917aaa3d82a3f7fbf9336ee241b2191f1625956dbf5c3990716cdac720d2597bf20e7ba55f0f4e50b5993fa5df9af8027f0163e39d70413c72a8fc6244e93b1979ca9976f6aaed9639ee6503c443ef787532952d129ca6464c1ba2dfb2975ed6bcdcb8c7899368cdfee286bf7073b01042018f77e3a626d4469fec604eafc905a325648f9e8f57f1fbf393be654bbc6975ba2bf3b399dd26459c889ceeb7a5b53ae045226eeaf43207519d624ba4ca3a4fb9eb60d9aded2de4055b41b766445cda078d42ca61a7a0c82b875ad72835415d129ce82ba9b90b94f005928f5d05d3dd07fe37449541b9098c01423f82e5c6d407bf405343485a9b061e1b1e61c2fafcff4883fa43d913153ff932de0d244b9ceeddab6cfea817e5630a27ac6b419c1cdba3f5ca79359fcfb24f893d428b4f4bd278b13a841be3dc32aee058c7a6a4db5706a0a5d9b82cad07c964dae34108e6b80cba708afc347f134004638d3857eabb4ab41927ccbeba6795a3a1bef19b36aec2b8a48a9bf3d1a39ce2d62bc9f84efb964c12d413f2fb028b0db4eb411ab0e82faff0c7f9428ba480f451857ad6caabab5e4dbc70b0b4af290d95a3c2a02b907578636b122226c7fe1256f48dfe87a1f3301fa7db09301857250885a55d1797fb8884d783c5b10a526cac42b960b785109b20dfa8b50f49d6c5967b719780f202b591223221612f211831d69f09a301475c30d8566c2fb876741c9102d657dcacd5de62bfbf19a67144657c3ff19163de9070ff81993177b823252e48beead6cb131fe29886ee4fb893cdf1b0547f21a557469d9bcf21fded69a09092578d01c12f852839b86a4c7dbad79b0651dc44e9cdf7e48da6133470f7eacaa75436a9b33363f56132e823cf87d6dbe0040c409e3c73c393421e9515675eaa5378ad1124959ffef4a0fa53b1ae005ab92071e497dfb3c7aa0cced2e94e0a275c07eb271964cf41a04ec39b5762e739ce40569cb78e80c8ac2430dbaf558cd131408f9fb0305088ac2774ff3d612aa89e7cb9cbf6568c0cbdb3b790f62d5762e977c5e443070bf520b1321b1406a031b2f5ab64251142f5f886c73cb92f0115c50b5489458b6e7b5e55d4089e6193fd56ca6e67a55ff9213ada14840930a2a16e6177c5a3977b9a825ced509554c56b8f9f1d29d456b188ec4951ded304fa373aad82130baae08536a8ae4f296488b832659ed35238004a1c3160debb04e71d03202de70bd653c0b23405d70de249ba8bf239606d30082c6328680a3f7db6eab1ce6d6aa3fb62e71f2afebb6e6872c4f558e5ae86f532d75b928f5f54fb5e490202fa083dbd8d77896421c7ef98712d1dafc28918412a970149f5b0ced8f56fb2d6fb10a6252a0dee32c8bf351f09234a30451a26cdd7e1c4034c344551ac82ea449756eab37a92ab321136b5f252ab6b3f37b0dec512e7cdb72bdbe0fe8899006a404c4c5d9c34249912ef304e9a0fe454b23ae4a8126514f5784fa9515751b1ac9d9021825581db8f2c85e57c0bd3002a8d803a27521c4d6bf77451bdc11f7061319d8657815ec15e477866d5d3e4833281f4af856d0002bbc48edb258486e157fb5134d103655a56646c070f500ce5129b707d5d90f6a3039967203e58c084b7b1f233d9b3cdf846d0a3cbea379288e3cea149e5c4858a4cdbdc52797ba321a0e478fe8d1de027937addd2dc5cc9b259d7c5ed9b211c014c37f42a305c543bde90b075b753692298b2258c9412a520b3bb2561abdb506d75e4550cd393e3204618a1146e869b8fa0d24bc7672dbb305b2b9b2beb20ec3c3cbe2d24be1582e0fb8e9b1961a5d05173e4fc2632190f588a034028c23c1358686faa982b232b1737b0a74d0b931cef3efb835362e47a990b5db156b21e2216c260147cb2f6a8f48f275336e10fe261948401ec1ebef7c154a359c12ce606aad267ea658792414f359f14430374d4c99cdb19965e1853912a86c9f293ca7d0612c459357cfe008bc0bd5e5e3ba8280aeb627f176dbd52e0ccae09a435c5b31f3e99083148d472e09ecc390c63f30a4388440a822852fe0edb647fbc44d4edfad87868b2b692c3795ac08267ddbf9834b7282fc7c1d0cd537ce0048bb9b3e56bd25d884c1dd9cb41ce0e4ba2eb563b780859e470e8683adfd2b21a074d339789e82a1d7f3ef12b33167b4740cf6456a3325fbe509bf94974766e43bfecaf599bd76e50e020012b34f1be62e8a54c8a56fcb29051e5babe8946065365475f4be25f7f6e549eefb1c93b88297441b8cebc63e06276029ca408dc6b5a1e73d1affdf19bfa39c4e82f9f3391c176bea930732af6729bca1ef209db9b537c3c20c60e9477797ddea8d66d811bfbdb862649943be056b78a6a933446c65fe8591d1fac1dfa7ac7a9e0b1a2678b9d0418a652271e5dd675715e048db07a650112b926ed4658140cd8bb097d72bede3f3ec8495701f6e63b8224c6c42c2ae11abac877b84be46608558e871fc732ff7c1758f7365b966ca56dcd36d4dcd661770ae6db946f7aa761ce9f7d14a2b6533b0568117f6262c59ba0202de92a5f895983dc682428a75b3740925d0d89549656375631b4cdf5a3a55e61352fec6c74250a0ab5b10c0aea60f0d5539ae3aa7cdc3af1e637027e59343df70e3a5c5930467d42a6357a58a8f0967365033291ccb530078ca9d5c9b6f844eb6380bb4eea25636c7b7061520a56ecf431b764a725c261fb7d1a8772890b54f28a695ea1922d3eb3fa46adbeff5a2d788b65c14045e2c6ba7118151f9d47de1e3b8c24ca9e86821a5bdd8e35cd535340f8591158b7caa2c25806eb7328265041a0d50bd1c6873405649facd329190012372ee3e7b1b7372678967947e0cc68245112fb97c0d142b109f6acf7d8689efc9753915492087faf3c81f44266855aa114db71d8422b3cf6005d5dd0dd7cfd58bbddae703de958b168566386557c0ef8c3124181b983db51509b58f6560b7b19fec5bcfbfbb22dfe9a20c7846c55f60c740984a0a1935eb2c9a9e6e6a1ab2d82da1ba2842897cc5e8144d079bc0d236122fc4b8e2202bf7758f2a34b6bf70d7814691827768042abc652d5cf9fe9af084fdbc076f314fb0789453593532af00e4f19ff850c180ae05052b25420212ed5fa7afdc6568c4cf242c4d1d02d4f7cdb4542b7fecab2a8ae5e1d1f2c86fefa312628e2b8f4521b5edbba0843e237812117e469b66212e01800a8e25e31d916cbe1b5500a291046e6adb3a2710011ff97272a4e73aea155cd4c6f2421ea42910b377bb14ba34b8375b0b137e70e938334dbb5efdc268b7e17918cd0b4d63681a9cc7a8ef1415df1f61c03888cfeeec8882c5db1a0d8193810e1ddb9d4984f1b034d5c6f9af0b86a5f0be63dd741863f49f0ce31818963e7825519e2dff23cb9f02c8a4c0dae3a57aa92dd2aed25ffa760e8a376c04760c097ad45b4b8588efea55e8899626e28004f6721f9e794b98be6d2aec3543f60c350f9866ff11c6c43753b520d43f0c2b46267a0a0b6a398b2bbe2c5b01a1399d723ac1126ad1c3e3516dd648737a3267509005b0b55cf7a0aae685fcd0c7fbc14d83fa07ea05738dd7704132c244a1a69f5a8f5e18580b1718542f6dacd9569648ad5a5fea982426ddfd92531355076e32e4628b8aa69e1e8d705316f4d50f58ef81420ef3327d0f3211d138f8a3edde5044ccba59260d0a4852dd289935a6a7a3f973bc841b4dc452b2594b8e8df51d232e501557e6eed62d1f094ab8ca5b85cb59b9e487d906130d84c5ba9eccc96fd265506f3199f6a1e5e71ca9787c49e4a8bd52d662d46227114e24797fd3b51d5ec6894b714518ab84cbaf80c65334bde5a655f414421b7c817da5d0acd9858dcbd6b9d6a6f047bad90b2498094e734463bc2788385060a7f5dfe241ee951a8269823ecf4dabb640b800f5fe6464daaba50b15c5cd89c02425b29e890adb52c592d83af83088354ce8c0efba9c3ab92ed1822a6eee12fc29dad8cd081b024af1ab6470e15598f7dbab038a86e938d407146f0867bc8b5c61449119fde6228ea4f5fd6a9a90755f5d9c6e9ccfbf0235b60837b8da875bbfcf8fbbc723b36ac93989c6cd137bf608a3cba99b3f2714e3a9e9d497db233e8350e71434ec8da5506ea47d5b5034812b48a25b1d1a0c4d28962cea344a1d7443f96fe8fc5b49e56c7a3764a73c2df75354ec0c5fb74c4f291d1bfa2f206a18b067094b68d7766aca04ac05efc8f5f64f75a114390f53fae5e9a17b1e29be7d9171ad46c2dd2e31af7c3bbc222f77efca4bbbec61b5a557b1aa28f880b5e9bde11e2cf71f5453eb90fc3b361924aa306b25efb8d53315dda5e39e09beaa31fd08db216256fecd8a84e00c49360d027a1db8199965ce18d7c4926c28d18c823692ff835dcfc600fe5232e914617bfa2fa45f88cb7e7c7752a9ca27d0b537242c839ad187d5155fb16f1c9b87601e5447bfea3adda19e4190bc88f0d95974014eb0661e8fcd403530e35774548f9aa3332e5b80c2efa7ce0feb8e2de5f815c4a5080af028798f7a9cc5f6a09483fc41843a848a69618094f74e4137350db005e548b30dd9d423a4b6cf40d4cd24c40b051dd1de162c3aa1c0b821c4c27c68355b2c3b226e5f96ce4054139a140557a8fd4926abef75ccb15bee78253ef0b25b6aa28841b4bfe816a56af52ccac347f94f1fb1c33631398167f4a090e3a05213abca31b103e523690e64c4a27ac0e2f0c5e1301837e6a4e3466e8d791e3b236bbbd9c63246cab518fbe0f4b5ba41eb6bf56b5dab12f77769bf83acbd39822d5c6ed560fc769635f71f63bd278fee52ce2f9093e868e37ec942176ca91738c70b6b37e4dd91ecf74aaa417b816cc4d90e99af9d64429717f21be32ad750ea3369546869d44eda7a3c17e87e1a1085a7e413f43648a17b48e7e0d68762462be9b4614d42b3012b516c5b9814dfb970867d585df4f890365ff7b6588b60ff37946ee7e109c11505b3d997697970baa937cef733fb7b731856f2a8f9f2bff1bcc99947047b1a3247a6ae6464a064a22e10671b2db6f1d90e8417eea8443afc1b9e124e71dea9ff6780d40a342e7e181d941db3b9062495598aa1aec5749eb3f6be84372a41a411c71473d9dbdf493e300919e1fa69a6a5f1c022c8ec0981ac46e5b6265434e93eaecd196813776e8f2b6392407412e88e832c5fe60eb10f6062cf79bc498dd8b1021b3e74f0ab2ee80ec1db2182c93de304634fb84c13b727d105f9cf87d4492fd9dfd2a3dfa92725a130701f337180b3991ba35d44a1723ad24a82c505f3275d32f16f3889094eba9a5bf3aa82304c83ce91af658c5226446d71e3048e108d33f3f24f9582a6ae8e045e6789c726981b82831eba70ad30072647f633fad223a6c806f04143aa063b940b620ca35e251523bd3010bc6cec7eb1adbcfee8e27fefdcacad3c53451bc6c94ce82f831126560891355c72f3490e53fb6e4914c28999645a6c627b755cd686c0db1fd2f579be4d04b005e6500e8eda58e80b99d81aec4a4e8a08095e13be6fb4dfbbecf2105ec75b37c7e16ef251410e382eb1c388681e644c28b28c345e13b960aa85f392023a082e46017a540f5deafd97ff3699a5dab98d7140880e4719b8272b5d0e71e7ed4f0e56cb909ea64946dd548217190d27af92196007310c3a8af14d0737441a3a1f35629f9ef29bda499fccd60609404aeab94e585310f8a2d7e2690210c1edbada9cec2a30f9605942ccfccf4e49d72c7a4c3e129408238338df79251e908b3b30055a6d5d80b90f5e2bd784168764dfa04c2150697e8180890054335beacf5bcfd9b956fa50c1ae20c22ebaeec73dcc3ac092bb7be142a206934365525c6276e6f6dee12fcf9f50e66189439aab7468bc9d46f39253156e34dd1a0725d15f30233b081117a309b35a69ed84b70a2acef52ead85546cdb2536663f1344d3b199c2236a9a407317495fe49e4d8e93284b2b7980ceb9d0563900ea6b18c6bed8d56b0fffededf9d553b32e273f1072b37ba6678135afc95763b2696f5eaa7fb49ad6ef38aae2e1b265999b8a6b5e0fdfb7532ff7b7f70a821cace646890bff7d7919faf8b2f80a5ed2de56271c2b8512a4c558fc3bd7d553b854b7772aa52d68142a2ae4ae93504c12bf6a52c0d7081063a62f2e9bf888a39b36c0435446ba4d0c37eabf199289e6c73c93bb267626775a9e2d82c785cd3f016874cb09c6ee69c50bf1d7b3d46414ccb5a2ea0d9c90bbdb873644853206f518e5d27dd8f02155abb7fd47d1310f74668b6e5f2762b4cd3a44c94735b56796a19e3e6d8186917b6da54c45518e1908f126eae69ff8cdd01c3ab54c29021bb35189490e67d56a278f732528ec978baa09a86848b17abe66b400fb9e055ba09eeac440f5673bf34dc06629ec8affa4ff8e2858027938175a9ea5c012206ee6a74e8e5b149d8789059956cc763c21609523edadc2a793b9d4753116db4769ff2cd80f4ff652702c090223ba1bf5813d217144fc0e569b7c8caf7c8ea8dfa1344b234f31ebb221482615f2263e08be4c6fc0546c0a30bc6f4b24d71e2dcb09c96ac756c05f19594c40396032b0a26a9a7bdd859c8b0b2285186fe994487ff777aff3800ff49d455e43a4123cdf2c01ea33cfafcb105de1bd621ecd77bfed3701b28ca93bd052c6bca0f427642786fc5c83c6e078debba5fc6b6a1130b90d2d0a06fda903828c53e2ddaa138ab4a7bbec0cbdef61d38d3c2b4f76488f08ddad7c47403c32f520345a8745e0acf216076fbc19d7f3963453258be0691c1d141f4f55a91bf08e7380bce8178d744096630c884c54e19be1d3f1e2eae04b04c60c165fc43ab8874bb68bb34d1958240a6c7f186b981cd7ed21ada8d3bde7b7d1d9424e034141a4ccba41a52dc93f6fef40f30e4119871df1caff015c76d61e2d12c2a4990c24ae70a6d4c0fcb4f885e8811be6a27d0be2f250a8f4731a37e0da5a74dee67f78e4a9667f3ab6398a6dde0655818ea6b68d992265c6a454246027ec5ee16c1f245e79a47c65351d8ab803eecaa758793c099351377e53dd089672988b53fddab77c08e9bb905cdd2f807125f3407953234b28e28d67ec19a621abb823dce71918e3e061befa8ea4c459d44c8323dbc37ddcca68e1441eb3cb52a8593d75fa13afa52a0a27390126eeadb1611e87a0bfecfc3a9a8cf13c10d5edf56a1aa464b81cf017fc8a9f52328d9be64eef2b67abbe976e84ef449b57e077db15484fdad0642e019af1bbad75d6576c1375a6a225fbb7ef291d917b7079f359dff86127a335fbebcbfc9f10f4b50018fc684ebcc97c12ef8a14f18ab06969073f8a0f00cb8e28b26bdee7dc830ea1a81cc45bc965ab020d745c80e70b9e101d5f4f1e43590afbc326d572d714f8217dba628a3dfec4beaf2fb1b3f7d9c94cb1bfa25fd39e844a39a7027f715db234995a1c1f4237270469ea3405b29c16fc11563486b3aafa98d2b7803fbb6c6285d8704322c503a861d5696fe0d4f207227f2553c46dc8cca442f72d09566bc68ffac9d223e1d211923d278069f48a024f3048d4f0deb93f345952e4b3e6aae0a0ef5570a4e0a079ded88081c4fbcf510daf9301ed96d87561e7b9f7ac6ceafbf93b9d80a238a4cfd827d45f158bc0e639d4b83af0fc7ad7f120d6263411c3bcf9c23be40f9ac8c869d865a420e2cc8bee0b5b772a190ae353f560cbe3b99927ba7a3eceb1a28663939f653b7808d5c1b39f18499c5ef76f804dc822e1f8c29557ccd44e31fdeaf2d991fdd25212d65dd26171a619b2b0f41d7002bb30ae6792d4cc9dece19cc032c6991d634fc184057a1d116efd38918097d77a43ccb776dd9ee13cab7db04b865843cfeb264ced948ba2458d4062c6bf781659e12a7cd28b8bbd752d98ebcca778192851b73da004d86cc2da67b3d54c21b03c0973dd4d49754f2317c9b643d83ae80c1d3ccf9e5e82bd0de187cb323c395dae86e4e8610e5cd8d3561debf514b22df8bc58fa872be4259bc65fc1d04c29243c300c17e6e524d9f86f70c0932e2cfb34d1f27cc3fde32df90ab0b51137fe47b2e9dc9accd4fecd57a4633f5f0dfc4c479aa15db5609a6d166a835858d7c91a21b854f5b2244a26b1ef2fd91733c523689c0fd7ccf4656078263e6cc8daaac4ecc70ab518402f591548f55badde314a3fab06fbe0c1a3e5c9c7057a62a044a1d41c1fa13e69154b23ab2166fba5c26391516bb2468e175d43f3c93a3e6465ca5ba4a607b0241d8cdfd4359f2d8df1fd8cfcd55a36db373b821d01aca8d7789dd008549b174587110f816a6d0f0a8cf004b9c6d75c76e32bf14d73e2c08b22faa15a16eabcda124caf4f6efc42f6b80ec502593485f60c04ffea0c9ad7eff7308b6aa33d35edaccdff18bf8183755dfd368c2f910d4fc2c7ae08a248040b6ec1936fe84664551ef578bb7cb5a77cfcc88f4c8bb9495961987b0e0a1575c652f2006d2e2811cee91bb06d44cdc0c4a2a2c638463811d7e7de0f825b4849822c8507e546c684ce721f9b6509685f81fb774ce8c3cafd780918ab8d643018277fe69e1a31e8d0f52c6667048488a0660e7126b83b1c11ffa2b0bed3bd16088df0c5e549a4096a48f6f26c8b73c3192c310a44bde2b7d0e4737c9a0876abaca4be2339932b085df9376fa199f1047e5159ff8f67069740e783bf06a2a1e1ab2f46a49294f487eb3c71a4718547b3e887f6e4d85f8bdefef4d7b0d962a18263d812bcfda9c361b8cb3acf97de873a766aa1fa67b5276356a7b21a85d1f1edf022953f84a66bb60653b572658e68d8454a8dea66210c6f79a642ff63ff23a6097a4a5a507502f05f6f88581545912b608f9a275fec3dfd114e66a60279dae8fc062ec7e3433c32939d4ca7967307f7710ece66702211a38a7499c08091335dc9e660f296c7f88e3c5a253adf0054beda527e72ff7457a02a0ed17cae1deb6792ace82600f83cd51409ef98d85cc5e83df8726ca59658ba184942d524d63cec4fd0bc9d016fc8314b4a397b9ec543f20b8ebba720d51b8496afbf840da5985727dd037c5d6ae75c628aeb24c21165b54112f0dd453988761095c91e0c46bfeb329700e59f01343f653357c48deb5a68850ff352cbd3967fe23361cc08dcecebbfa242f61e65ef93c72c44cba88fa37c155f7f9dee9afab9c7abc6ba56b656352f9dff05157ad82b19d55cd1c45210bbdf9d2e8b614e14f61b7680dc7f36fe50805d130685465b1f45115bdb9bc51101daaf7b15e1d42105bd7dd3b94a23a42a6e11a28325d0aad31cc10cec2e09b65ee53dd8c2b0ea61543fb5bc4c605492f70489950626df24b546f5c4df9e14aa4b75354fa05880ce2b92fdcc244423758bc603e599cd63958c7773ab55921c7ab75435c205382d53edcf6d186e6113b4a8f52ef81bed1c7bb2ad60b55802f861540e6e981c2c7595f2f38a4cac2cf8713a2e245888c48a5fd05540cccd73d511a921c77a0fce0d50ce5a77d164476f26d4cfd4545388bd1cf9bdc03c3d0e62979823769322b3c2e5bdc515baa69d64b5382df0261ab56012c42cb9ee5691ab5493fcd4237ffe30cba8a7479fbf40a8e742477593d840b3b2a2fd658d60c00277588efb2a0f865feed7d8a1f501bddfb23a6d614dd5e11af8a1fbaec32d8f06026a6a48940cc0f4a51dc8ea22324951fd80026d0d97cb0f9ae945038d34ead85c5156ca8e27e0b8288bc9428469ceca48c2aed8c863f07c669637743a5a8602540acc0c72e76ce15c0340a38f94ab4a41c3ed858f2ff94d1f3c9001a1f2d2a4dfaf34ce23963641e668d0a8e03203070940f7f497aa8ad90380b5260aaa7d101b8ba5459efaa1daa4b3f5d74e8d55b28868cab89f920dd95d27f4faa25e3106139dd362fb344a1d05b39b8e63e25170ae850dc160fd4d3e121a5d6f5395bc8d97e14506a405446817ed367835ddfbb4fed6e55d4f3f59a0049b91552857ced7a381ff5be1e67bd6d06345297945c0f8aae4904cc65043bcf9740bce5e7d3d93d13fe4d15f4167675c35ee1b5c7d14a54e37ace362e5f1b9ea806bb0c45785f9384d981346be0e746e6b40c6c8c424ccec1fb84cf083ebdcb2430b4ca40a423dc7220e27274e218508d4e5ad28ebbe7987dbc385886780cccefd556d3350e2773b32f30f363dbce4f4e1568e84616085d90cce7940843bbfcf35f80a2e3f8b7add5a9648068a26a11f9666abc796048550b48645a54127ddbab783c4591375e212b7bdfc80cad766926ed2a11b0a460a668230ddba8581290b6b51d506d696edaeacc8f6cbb17d2a67fc0959409c799606bed7531354a9dbf8a3ec548ca75ce28dfe1b94da5069ee2e33935845664dc4f6ceecc9b9241265d77fafdc9d2fd47a77fff628162bfd275167928af756e55c631b97ee85850282abd14396d952417b0b87e19add2a9d0f996cf49f5f25b4920fcab32cec7f4f50bb8700c02a0529f74c5e78b14b6284f23ce853a068d8805208206aa746a37156d6622d5eb955eb89ef59e832f4541f186756fa105663c09d114116b6397fbef3ca154c4f06acc3956113fb86eb3a129f6f1a5daa4da4cc57f963c3743d6f692b0f23c44ee5380a484589cd097dabb53d93e9bdaf3631b93c2d88de2903d531c38a7672424e22783257232f65a82c50b093d2921bd4e3e0d42cf518e0cf9fff0d6371a08558d8121f5195c6af7288d821a9b444c4da6e0572cb30bde627295a9fd58f2d7b657916792c3610b768d4487ef31a9d0a8383d7374831fff510e39e1ca4bb235ee21d3e4c913cf4556d654c65a4041aaa520f5af9c124e535bb53237ed1b527b5cb4ddc04b8fd5b7af8ab92feb723af75576c7fadd0e1a9991546d764badd83417b6b427b65a9149a3a604cdfb5d579ac8fc53ea3821a2c9344b4d8190fe7dce5d456dff324885e64f60f08c3746c330ae7caa4ec8f7509b4430c8fb9295806c7e568c75d58842d461333091679c8a3c00f403a27e65842f22aec1aa14afe013eb4e88c913571cda5fabd5c2c9ddf8b6be6e936b1f423b02bcd79c5b8b0784ac71865f9177259af418a407abb85fc325e89c175903b7c5c77aa915de2fb1d24d97541f66fb8bbd22314ecabad61abb9d83dd656ead9d2e8f48bb939906e496caa8b7f5b75888ae3a8601c24da0d3139b0e35c6b9d6e8c38cad692c209e54ff7a2399882dfff9eb64eb045fa492673a2ed3e275dd4b967622ad7eb5591d4257e23db55caa261d733ff8530ac84c0a29e8afbc5436e956a0c6b3e3e987b9046c2cb52a07a1678927613d5bd92b7f0e9ea8786b38e725143827c49a6d5428cd79b6f9224e925194302d6cfdfe032e3d254dd91ece9c2750a1ba081e20647b7b7cb05285f8a47b65ebc3e2583f66276acdcd65581a7bcdea6428b57278fa3ee431a9fb3770902cffb8c61a2efcafe7df37712fb033318440fa788f9894248398d50f7031f105c955e80e75ba508612f8fc53ac934991368ce1268ff0e15a3c9b6c270bd1f0747bc6968702bd0572457fa9889623cc3ca092d39de8088e35cb0c61101077f36023fbdbdb197caeb1fe355d7d46eaa9911774901c1426a0edddfa1fcfb403d98eae2436a723bf322258ebf7c86ec821b1df8df7ab6e0177ff201bab422eb58e51dda41d2d9bb26ca76961c5366b3a88cfbf356c64d63e63e5a4d52a06a389f4f0c341474bcaad7c36afdd73c506f4517d671dc4d3d63b30fec626b49c7e41ca13b4fbd7a5a98a0845a987f5a6b7c05769f01070e028be9f62fd5d348a787e09756967924864f50602c2cad17bf7c0b46409b9c1dd5e905eac00c6d5332ab4f276ce758fb738c05536b09200b2cf89ace4bc887a644b78e33445b95216d6aeefedc6c584ca69d4f6636bc6b8e828e83c35f69c20a10b996b12c4e1398762b17876d63d7ba6b0f21dc787b773b79c38d7ce20841171155262c6b7ae6391b68502e21d096dd9773da8bc1aff3d30f84ee6ba5ca64e1ecd2da6d982a614b696856a5f8d6841a8fb0e9cba685e3ea9aa25d563e385df70885bc98bf3079bccb69a8220227a460f6f800e717514f220e6a71513139ea5380c63906c3ae618508a3c21c37afb8a8a86fa64f6e87ca0023a5c3e3117d17d7ac94b03d84fd07294765323c04724f5cc75ad8b338d8e603addb21d3146848a418efa4783f36dc768f4caa0ba274006c7bd2667ff7164f0ac22645e45d0e5df1cb2822b87e28188bd0b346a60439100390314a6324057e4598228a180ea84ac785b2b4a386f91f7159d8b546fc999dcbc41c8e4f48228cf5a3a38f3ce02cadb191521a082407b3696c36fd2c32285c4b3c268961ef3218326365cb0cfe70402edabf12b1c7ce2e012882a8c768d458ba1454d1394ec3b6997bb2a43881608aa07ec9d95800639f54c4241630c7b9590e5f5b33af023ab2ff119c938b7037b072ca841f876283037bc1694a61429073311a2105ace4406c750c852bb2b9cc0a293f02cb2a5ab5546db46dc3b082bc871454f538f549eff00a13e07cec4ba56c703219624b8fe9bbd71b661e19273b89964fad17c8405500284c5fef699000110077fc41b8f761ad1a2118434cb059bb65cda150cd1e236f6d608b3380c56f0fdc88bfdfce1b78cfc6ac881c50a4302dd2c213b9c8ef275faedb918db31d1bd20b7dffbd1fb745f543975a6c4902aa653d59c24a60067e658cd1589b88e43bc6bcd87eb3062b19a86ff3a8ba1518f4587a29a99edfc4cfc4b218dd66330f7d3f4f9cd59e95d4a4cc6962a9c4bba06f6fd78c09134086fec3a1a8e6bdffdc5155ef753d87f13ed35833c5f444095024f36d7187c4a631bd8503dbf9a602d022a6713fad4db093c99b96366ab7a093bef8d4e316ae735f6950b5a6073b9046e635c9b30f2fedf14c5b5faa41bf216341d16669408a516c757a1d0ce6e1228ce2c001b325f8e0c4f218cce038770ad6b9ebd5be80b1fa49da96422f5d512fc6ece4243f82792abf38862500bb5dd69e89b0ce160c833ee71184fa1facd5be9ce38a426708e1da09f6fa66822f56dd2251901d09460981203787cef133c0891ef131c45474a3409551f8559f577cc3f0c964e9e3704a5a57f635d8e293af878da596d810c5e1fd3ce6d63f56fd7b51a365845f110f0bca4831ca3934eb9bfef6cfce1a516a6ad2c9fa43d0c7346a22c0a5ef673db1859144d6c07ec179a6898a810040ecebb9106ae18df2794abcf8e1a0abb979f94d5fd0c2d222bf19477672e5aa8b00045359100c2392b0dac0dc84e96b288651522f9a1f8f4cbb1111e894efe709f7c66f7d5f3779b364342bb2e8915052038dd8e286d14db215affdd6414dff2ef9c694eb2ff4743ff27262c91f4525d927a796518ed29802325b900baf10e3ac1081a17c2dd94e2582a4a12cc602af25c6557e5f052dec9a39d8b3fb9297e3c4cef2526c16c604b9683c287064d97e617cf6b8dd6075bc92ba48b695fe136c4899e703d05fa79cf9f7eae2d1c7d20cafe54c60d40d95dfd737604ab24d0838285936caa3c4a9c09c7779cd09ddbb96a294bde1a9005bbc71d7fbbf989a05d23734329335c73cb812e8d5e63449201e109ed77ea74c13c48dca0233034b31f9e8cadefd986ef72fc5d049f305d5ee066cce804d0a32c7000287db705065abbea5c2d8fd1cf7ee501bae3be397d13f4efc318e60d3b6e9e4568ea30edd396fc9a3ccd4832a290bc8dd36e0ca7d223e1bd1bcdad5e05d5c53021fb43445934dcf81992593489e6541024d37180f39911a6dedf9c5bcfbeaa095d08d8016db41d10b98db1d96b66e324d959dc270a1a03029d29a84dc6278c888b38adcce48927ac6da5e1e657902ed558d8513a74673a9c76eae8c2620ca810cd2858164083629c523774a954a940d7d77de96539b4dd8e7f26d1891bfea754ff039733762802b31215f29388a27fa0d886675d8131c857257b5f145ed457bca0da3375b89ec43df6a15043dd01a50a7d6813382b481f0505e9cdf5bd5e713fc19d6c9cd968f07135c86e9ff9f541f200c08e19657bca90ca7ac388e16caec5b12b997e71b7d415c12eb69c5b4435f30cacdcfa51b2ecaed59728e585c75dc621507afe6c39a0db005faf8dba59cfe466d14d47e187c216c9283b8a43a6ae62bb11d614a016dd6ef0ada2ebc018dc575461b4703db5e877717f8984e8b1d87ecf44040231dd57415d2a4789f6ffb1cf4fdbe42688ff18b27d7b3be469a7d62c274f0e3f3d9aa40589ec60b903a0d7503e99d51caef6fac682783c2b2966f5d1e8d58f215eadc74cd006f99cb6d08fe1e0deb17c218031f7d31442005dcbd8cc1e3c43f719b46e218d59fe494f58732e0d7b6b62b651ab626419a80ddd87b4260587debcaeeb33c0832282b6e542bf2d1ca0dbecc894fd1802d58153c942f6e6474962d425ea94abb3da9129f073814bf44698dac478954cbf5a895a9c62e8ead19ffac21af2fcc968636ec36f6df4b6eb7329f2ac41417fa60e1a2e8ee808202087e30bc284645a32547527bfeedd45f771b24fea61ef7b83880efea6b6ab2f49c14c065279e5a9e64793e580e1b45596ef5fd8b8940c835307a8304cc12e2395cd6107dbf6e5713ebb8b91dfd13653902ac3e770db40df2523385bf1c26ed62245a696c50971179040799555f9ef20336db1878ef3bdd6be34558bd53b49307eed3239a141af6ea571d67b7538c92e2c07b3340da932042db1b0c54bb4a26ca9162f28a557b473a101586ccbbc21f2bae0cb75cfdc740441e6c2b011c148e14ccb308bce2ce4007035f36a5cc0c2df9cda8a263bc51460aff614b5667a337c79716ba5bb04ec2d54e6b3c68788f9e3f6ceea0710f3c0aaae8127a2a19273ceaa7d31c7cd8f3a6cd345c479e0b202b2b944a0e9a81f63eb29ae14a68e29aeadaac4009f2c48e28dbb3ec013857792bb60dcffbec6de51e5741a76c62d7e3a491aa5334037aaf68546ead0aed7266a5db6b5ee805a1edb44fbd9cfe9abd3f6840a6c74d29342e5602b5914e847ce44a9cf32212423ebd48b0f63d0821a3177b8e743ef54a12e057fe7a01dc92ee4719fbb450d58e563aa0c0dd67d0abaa0555552fb915c13ca297b8eb2c8ded2439793d620c397152b916eeb6858f7d615e53d6bae67e6dfaeb0adfb478023827eda5f37b9523e4d4a196085bf34bd423a57962e6a3baf5e933dda392390941bb858613f6e18dc7c354db2a5ff33feec973be52df1289a4409daff92ea3791018e4d04c00b8750cc978d0dcfb42033a46429e6ac5c9b78d22ed70c4a71e6290a528ef2dc129bcf00760d0c1705e1836cad07fe5a185817d40b2d090230ffcdbc4a712a3a2ea4b52bee13ff05b3cb8ca626acc9d94b9adb21d3d7be33bade5037a1fe2dd1d9da659caa19726a43ed9f07f09c58d52b06eefcfb6fef2f3f4d378fdd7ae610437f769d666efa1b075b853dfbab5f76ec5be17bc6f8995c0c7ec0a390402ff506759e2a955d230c05befdeb5dbb9b16127b82b94f4393ca470663284c77cc78757f550ba7f83dbd51783e89cecdbbdac252455903af3880405f0d849b35ae406aeb7db158015763d3d1c0a4409f8afc5f75633106761ad5b571b3975cb4403f441e1333e9bd5df73d72075b9988e962f72ca9392b8236e195813096ffc59dcc5dd863ebc41af1c0902fd85ec5734dc6801c907e491ce764bf23f2ae93c5ed7148f89f128062ca362143691da9e610819f54cc4486525c96826255b7d72f87e65c28a2e3e0c3feed111ba0573067ec2e4216b21d622524bd1632ba764bc9f44a738e35f15443f883a0108f0355268dfe36d8cde13fa687623ef79847c9379d33384243eaf73d50413d7eba2ae6cf29fd38df82909e5350db9a2068970724be095e7e0a6254f408e2a83b7a14c4a975c0d5c295750f101cfc856b4362a80f9716628fa545453290f4244bdba0a33761371537fbb158acb76b1bfe53234959f3366eca3380e475d71cc5bcb2bbb4efc174f605ba5629365babef5f158753722329a65667cea41c1f0d3d7e2117883c75066ad304da5c4ece541df29ab4d1759e05de507094aa907ef8c1dc1618224f92a93e75672e6270815d95e35ffa477044476ee02a1846a37e6c2435908e73aa1445ca20bcc287d45b769910fbf4a633fc2d86d44846a5793434a29e2ecb3c463a27fe2b19af262d1ded722dc01a5166cf027dfdfd591eb589b6f3d2714091213dd11f5f2ca66f4b5768048823f3c33b196843208a7258cdd96088a63a3141513654a0f7e727f4eee9a15acee8d73dbb22d6c9e76db7a954d0b4165fefe1b51032285d4a6192f1c1ba90a7721a376b7a6eb6e91978442b9087d8caa5a5a3d5e3ba434376a5e319666745b6b5d1d8256c3167ace31e576bbcc24078a4332e5e2e8fb472f7fe6e906e1a172ca8b5a1624a3da75b6ffd107b3868597526670a6f0d606ae6545e1cd69947b2f74924dfbf6f054c400c5fd2e6d04199fa225d2bb2f50b18f082bce3b58cd60387a0a685ca996eca6a3153384eb2a8fa9c147f114721bb2fdd3c52f3d691a3c0d674426102ec2731629220e7fbbb102f4166c2166fa1ea2c0c4148a82e1d080c75f6100846c683f004417a361b67257f320c8dc46961f40325e6266d2da5396f9c6dd86589294390477cbde2060e8544e3f70b18eb8c41eb9342df1c9888061d21a5d498c9cccbc279f09b727dfe6300dba36df02e80cffa9085feb0da4ca3e9f50b9a9d0be8dafff976ccb9417bf5cb229ac4966faebbf115792aaaacd9059dc74ebf5f6f16df94cdbba28e005b197c0fca4608b376815060711b7ba8079482fca8456aedcf525ee28e17697502821a565cc8029ff2cc384f901b3df97c2e8a133c91c5ea011367167db244c03cbf86907e5268cae28da058544134fab80edfbf9d252bb48c733906f5c5f6d80d70025eca935825e38671b8f54423f7905af781961ea87dc0d50c716f9280f00661e97f632e6220896b2cfea01c95293fba44fe720c18dbb74cc2fd46a319933a1f732d7a7d55f6b3389a9d67782f9a52f1a7e7d51c9d6bfb37f6c050fcb0fcd68e28b07adb85404bb83b3a19f6bd9339f3aa11b4830eca9215cc083efea8ebeb4b1c6c743095098fee3b3e8175bc22f423a25a37af6cf6bec5781cfe006dcd1fe292d888d5773008ca6a97b0cefb21f9d4a2cc22dfa2862e361ff0634e31efc1bd7bfe2841a40364bfb250b4002965b83b2d6c6b68fffa3e373becf43e5c7a80e2e61076ffc0c9880bec93aebbeca67cbab46692fdae29ac564d52a5567ff254cee5b2e18a0f13449fc24b70186d6dfcdf23e9624d646772fc3fe352a4e3d9d01b1a64ddfd6619d8341b72debde1710985bdeb6adccfc0366ad0e8fbcfa9d8f5e8d01a5ea581833402930b2987119f52e98206cd24034b568979e3d6c08afd48eb4fa021cc59ec52b30fee56d14c404d0929cc6f29a216e277edc0b4253cc90340aeadaa8bf1c3b6f9e7af69c66a204855820abd79815eee2ba124eddd8045b2c91af33bc6a11ead0bdc559d0e5c4805d486fd2a9a6d3f309facc4a45e9655099e4acbc0c963ea429b2efa44095d953c608118e57e94696f5b1902793fe1ebf8d9d19ed448da8fbe1ac519e0ee6a93f46d6f7e77edf75e1b93614d15e0764ee294789e6bd06c69f93f3e2431fe868d91b9cbc98e25189c2e2b86ded0c90b80447624e6e743e117ea7bc8438b2a13f2d69b574ca80a7d0da0c8f41deffd946308b0a7c20d12f731b0966d182b25d59bdd9162a3261b8f72d74976a73ec64a218593f8840f81d13089de1b11e7961729072694cee27e2360e1cb5139ad1e9a5ccb605f77cc5e51d045e50ccc3417cf49dc1fa2b2d96d283313fece86e88b43356586f96921d14db66aa172b1cfaa760840c227e528f9fc34ef9c19eaac14d28b240dcda5a8dc0e4fe5ff4dd009dad3fd5caa8a5a39d930e02629d89858414883cc005401def5ae7fb67ca29f881bbd8464e9455258b14b45ef6277432602617ea549272df0fa33c157b94b347d2a2562b1dc0f965d6cfccc46d9b6107f80ee3dedacf87141e522d238aa3faedcab39ab61c7d2035f0f1d417cc3ea008f8847ccef570bddb5522c37be6ffea43ef3ec715620162e21b7d434e86a9d182f0fbc9ccf050616d47cfd06ca49a731e7ccfdd15ea4124da80b36cf06059c0ac4687887e74ca09bb8df9d44edf1a77d52dba66ca0c80d757a9ba3023e7a32338d8f7de38e10ea57b6d90f70ba31d2f0e14932360eb25418c3c7047a7323caee572d9bca3f2c613d171d7738915d035e4135cf59dff537bf54f34352d13a44ba2e10d9f328576330abb0d606bdccf8668a12efbd7afec317d1dc2601aa6b595da57e6ca8ae3e30623b25b9f85ed7d1bf064a006a0005ed4a0ed82a12ff0e88164304fece87eab9e8076e16c5c9506ba1137d21ff74c652de379726f3df8792ca235b53a70a98a13951fb9c13bd4ce9068600c66f2ca20c529fe0547f8a87eb91c9606195841f16396196b0f4dd365851894bbfeb8e3be0260e8f6748cfbe31206c03cb3785c2539e974efebc8eebd54a0861b9f86abb0d46621351f399410284b822b519ad47891a49a62f3157722e0780ecde18da48bab0649081c6da94bd9314ecd7c4c8877d5e5df2063b7fd58ad1c0b26f9c2c7bcd8a8c1733969280af2c67d18b3d669dfda26e1df19de088705bdc65448bd81aa29dd18817443f9710fb70380631186fc1e3c33eda9771816c1fc7b1e71897302d3aadc028577ce1a1695c9652b17f1f3cc3bca4d2f900a59b33528748e8eb0b4217c39bc86dd8ba054c26c8b8dee5cb0baeb518bb8615ba24af7d141635640f7186ce1c42d415d8386477d2a59ba5aa53ac87dcd8b4d96bff6167bb913bee1dd8ef4ab2f51368b20de358fabc8f124e2e60c8d715407c003fb1de2fd0e59c4b5731defe3d55b7fed6c1869b243772176023c95b84be1f204cd29b76cf38522faef0429677f8e767836e4b63a818eaa10b1861aed3b6d818174a8a672a93eadd29e8c449ecfc835f456b166cf4c6501fbab1d311295e7be5d1f8614a25a0b908d2ca977008d0b1b1874dacb43d4aed301c791ffd8d7c52be76a31228654d02002cfcd0eb7193132712da47b67ba6dde8ec4f17bc2fc52ebe9a58e05c8adf6ecaa6131a6aea5145524a3a047d0522982e3526d5591f870d5e8803eef5cfa37eb8074c4c1de828c736e07e30bac42dbcf0ff5224e4504eaaace0f6a322e995dfd3d82a842fe2c97a90b230383082eccbd08eee421e8aabda","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
