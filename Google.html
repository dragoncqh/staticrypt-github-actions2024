<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e8fc5d15fe0984568655ab45df5767128634485cece8b7171827d96ada8256452d6d4cb2fa06ebe9184111e10de63e1e41a9f7a4bf913dc8a7a14a09532d204be623b52aa53e5f0d04ff7beb5ea6971d4d1b204822bfbc351c16048917ccab8490f1656befedb9d04e6379bd76adef48d5c81f011c61decc7e5adfe7e67111067620e670fd49d2108881677256aacf83189a0aa52535401f078eff60f523060131594b5f74bd5f2eac2edc4088bda9d37de731aef68541e4151abb0893f804dcf62d59915077500cb16b4f95e4eaf4f4f10687b38b87f6b08346b54052070cc928f8353c58cc39fccf0b33c5b9a2a2659d5270470980b44ccfaab9958489d1c6bdf9e0e5beafd2f48089a95072b70056abd6530f4919bc8591cf80e0b231b34456629bc3e9cec8c28d108c3f52a790bcab26e7ee744f92e6066e6abe91899915061b701aa495f5bce91392ee6dbea79ce569581be2d37abc8370e0f4d05c452b03aa690ff22c40dfb78c30ae0d0e9a28bd902fbe55cc7ccfc8a5b1f8d22a1b84d669b835350edde21db1ea4fd7273c33c5d1ab04e1617b5bdd568bd5bd8651f703836c1f6bef2cbe2cbd7d4ba90d48670e2044f8c485d68c02e2552880dd51fe97107276f58c80bdbafd190cd79f7a6292c592e41d80a485d5f1e83373cef5dc561601bff1d4f1ad684c10ca7dd5ec09dd788b92f94d72fd396117d52b1cd8e63c2624fae9252bf403c04cd78760492e82f4753fdbbc8259ab1d9e95bf0c1ed0ced844870998270170d974bd231cc6e024b3ea71dda87481a75ae139c808b000b7755bd75c2a0f3bafbbac5bfeea3b9ad3aa37a697132fea0639c6dce03900ee2fb3647f61c0cae06b3e960e0fd929a6e54f40defc8230cb5a2cd11373f69d455d9e2a289397418a046052b5d3b074d179cb6bb837e2f1d308ce634e6813fba0c7679f3c787fe36d36c9361b8a7e9aa72a3632f91467c5bb7318d757c2ca712b0659dd073a49f2a7455a74b40c209cbf47c4ba51918618867ee199570b7598ce5c733c910987964fb53b08c830b3fe42a4026288c3712aa329e7cf64c175b9d575138b288093226089a3c9d4f9a8e308e5613da3013d53cc3cbded0404b6dd06ccdab3403fca3bf09b653c24afafc40ba6023e5f9ae9051c8a74c1159bf6f5c6ae8986cad5d8c743e82d4a8cb11ab30c157aff47f27c5feed0783a009ac6efe8dbc270296fecdfbe7c9d7f2c3c6538b1f2a239cef868463c8f0e3203de69a5276096ae0b0e3cb84d5ba3820567ca9b40877de5d3a2c6d68621ca7a9acaf73e5d709c78a5b9c85e36f09380f01d8b9b6b1e08d451e91a053a63e96ed3ae67cb6cb494b096b2dc9baaac01f7ecc4a37816abe8538427d29ce5462cf141b7a24920b89ef4ed2359dce9e0454ba8bd8dbc0b9be2e2756956c75fb0dd17456c4c6538af11539988687fd7052479dcd962d4b6c80b9154cb903a17eab6c44650940d5b90d9c0f7dadf0d0202c5fb87d091363900be1f2da3b58e0e2471c0af5f46e359fdc5df90ee1e13d832dc6f192ed12c0ed893082e1f9b688797d22dbb7e9da71fa0e51210de8d85a2bdafc4632b439bee308ce319d7b89cb4a4325ed0e5d1de31316a74aab1c9cd91c19034af17b84f840c61844f4f852790dda60db9969c88cdb2b4196d774d84df8da7bbeae60c7b4220f4f5bb7c41f990cae4a8bec940a95bc2501c8b9562aa20578b59367525f121167e3e13585f90af2e64f6629a067e5417df69f179e1c2784b47dc35e7b693b00d823583d0e3eb859ab480eddb9ee1722094dd6dc147789485ddcc69544311d2d63db5d8dccce70e46d46fe9ee79e5f7c97afe1c09a7504763db2eb0e28b784ee093e90ff6d103219ff00ba2de38dd16c0ae35652d3e3bb6ab4abde629d6d3170c4ee60a1062ab213e0a9d62eac9a436cf4e5f91a53a4b5877a3f9cc0988e4cc7a0ac277d4aba54f5122f9e5c58b5d3d7210de9b793ca5212af3bc298222070f862385ecac0c36b8a9414538bcf4c824eaacc3f967e8c0b546a1d5ae52051af84d068b70e2a5d38d66699ec7dd541f901a92654b26810dd793ff5239221fd63ee7a802f363f532e390b6486e81fbba30fa83132ba55ba45c09774cc90fbf99ed72e355f91a9664dc02c3238feeb71b0f7d68c61e13b34cbfd2c76cdb7b05cec052646ddb92d16629fa44c0d84bfbe9149bc96d122c57c1a63351d648f7b683a57792fe19942ff0364151e9fda4457efda6df1060073fecdaa30c9fa95fed896ed726dced7f040f293959b968b7d081b6979e10d8683d69398d64a7ae3a4a7a525dddd1f94dfdd9e3f87f8f2378f6ee804a673052fc7ac7ab581a0f27126c17dfee161ea1c8b9db8f1a5ad73ad5e340d87fce624e21961f37dae816a482e886c9d648063147dc4c29f9bd2a8d379d2b211f89a1993b47eb5106c07be5e7f4926d19e1e5eb0a8db6f1bee45209a7979753e35ad25f2c1319d0fc1d88ef587392194a9fe47bd90a33c4109cdd5f3667b1ebcbf78c5d4baa14d62ba20fcb9032dd854f6dbc6df813491093eae01313ba58083dabd25960ad27cd76e93e8e424baf3ea2804d3bc53e26d10938323c3e83b3a73abcce479c0283a190ce8a2e52e5c4446a989ad3bec5ecaa67081c51b33806c1de5ade9003579c4ca3547687da80d72178c7baebbdde04d1a6d9bf1610920080f21e724903f451de1b4e5caafff1fafa86916bd5b152d871b6306ebd639c01c503a0af8c5fc91c49e4bd654ee1a0952728b99dd8f2c876fafc9b459ab50c47c294d8a1726837f3307df2ed182bee48b26d67c3747336b45705ae696517ba81fdd507e8e551435c5ddddc752c24257c446541800d804817a3bc9f884d5c6898b7af617335cea2291696db20f4d7aa942ec3e0b4e2390ee7c2f8055574cfac06eb8359ffe26d5490a84b8b926292e017130ac030a88af04a7b8f10607a60cdda07798d883e3790598f5867a1aaba7698de6038b21a73c37cea16d6e6ec626782a493eebdf9cbb4515835a066da8cc8d4691a59708b3b24b89188b2396c5ae672664143daa9c88454587f576b22e2e367aab0336a9bdcd1041d926d0c17c434c6b4a567aef837b377030f8f8a0ebcef219663773a3642becdfa6dc0d9af8c505446e6aec17ae566dc227a988037db57fb320a6bf94c764fe90ccf0b8fe4af9f6c2858f4c92db9ab3460452cba3308ac114d624df9c002995c970f6de3a7e6cd380f541e3716b2a9d907aabb28b1c6215be6a6481f01194d4f4f66830a7c88c3e9be879de1843d317db7072600a3dce5b31893380e93eed9f832068a95a2b1a8f59d63a145bcce94f001367d7968d2ffea5797eb05105aca813e1bc20f387e48b268b154fc60c4ab5781ec68f454d91ae1b1249c4674c856937281293445655f8d2a562d6b281cfdcf5e60d64f2aaa52f6d072b92b886dbe9ac3c587f0df004b99a970d37739684aeb4278385cdc10bfc700f7ff41d0ad3e67169bb06069c2d13c3db8cecf7ec45ba053763b41b4e5487a5087ee6c03a50a944c9b83236b14cdd2c9c547ff273bb8db35868dd5eec59a5b9b517aa4121b349cfb60c46ac3935e3462812ff48557e3a34698b72196214439871c443e1010cc84a19029563f56dd79b7792d3bda8358d9c1cb38dc27c41e0c64c426ab161d0041bc1485ce5c5466793887cef1fcacb4fd43c329bcc88ff597dc5f45bf779151907e524348846505195365b0cd2a51efbab9628709dce5f0e214a5d573a39879a25bcbc0d4075e4070bc70e7b7ef0137a6c5229ce706c6fa2d551e5a0d9351edd7dbb6600531af919fe4b7a0b20f14eb767ed5f02f0032d8449ce06d5bcd83ba4ae84510cae95dee1007fae470c3b5c9cb3207a571468d06b3629c1a948a9f2d0715344ae6073471cdc1bd29e9e2edc7b278aa27ee8cee54cb0b3eb4989231c57833017bb243fb4d8ce2352661d8c295fca992ae02cd94e8ac2e66f79cfab60bf0cf0288fd8dc3c77c2d68fafe6bc61c5f6ca7e00a729fbfd9b2834ea419c8b19cf4ea7aaeb54a7fdd7b2f0355e5b37ea4209f0a3e1c91cf0f7f242ad57226a062ecbe3d09eeb750241a344fd5ba17f0d28a78e2f4ca076f432872c800a2e2e0de2942182c3c776e119d2d314cbdfecb3631b87741f250401cfb89899657ef674fb77f0b48689ac91d80b6c1cfce7b6768c052972014f248122353db973f235b056f0c56a56f1f9c23eb338f012c73bccf4679c610857ee934ff73c06d568601b626fec1dc11f0ddb36563f8c631f42710b1a4b8035a89f2a8c2b460b25ff8cd0bc7b7c2bad749ab82f4fa7a9ae167104f747cedad4cc4be33cbe77eba10add72c892f6890c73a09ffd0d40e485ac1e80d7c2a2fa712d76841d62122094198fd71081b2c3cb8189a54f90e7778862511eb4758239785ad5a73ad7c5e8499d72d554a63393c064d2d73bd5aed31eab0ebcea58af6acee022d70a5862494ec30340b3350f764bb5733be84c1b45fbf6445279b790f7867c92f7524e011eee15bf7caa2fc759901d9746d2e362545edad0b0567723edca61e0783020b438bbe533275f0523509599ec44c0ea9ddb364f1e6889ce4ef731ee8b86aae468e5896c76da0c3f9a75c49c7ac73db92a2e1e749458bcba3858dc600f752f1aec8cd182b7331e53d91d956c0886209a855e2d0d1571c8ed324c36b48cea9702cc2680ac8d53383036c29f869ae74e52a0b3652807f3121e0549737f84c6d0dc389711acc4aa7ff2315f5a216aedd7e796ce9621bafaf2c233996e4984308536497d2cd6d1e39cab9ab86a2f2ca89931875a72b04d516c18a2b998e94a82a6e8288e78c735db53edbf6b51f54ba08696dc0a9f0ec9d4e93ba8e8ce72ffbc70c8a445e00473e20a9f2c2b24a1a3803abeccee14379fd5d0c45d267a005be9d67f4584115ef894552b73655786b1e05bcb0b08de606aac7ac16a40fb28275ab92489f41ca0af0d21e8733930cd8bd594a901eb20832eaa745c6fac9537a24fa5f8abf115264420e3aee0ac7851c497319698e0a7ecb8969050732ba12ef896417aa65349a096bdf4d2532c192d39cf0d1acbc1ef66c2a07bbd3c6df419da79bebb91d0ef06a1308ada338f4ab1d052c3b89ed67c9a2c31f51cd54b18cf047fa533110f62aaec4aa66a7e299f77db76dbd848e8eb9a3a3867cbc5d64a91129235cbd129785d252a0da32acdb0f7506730890d5210537cc66a8c865d6bc5c93e935018f41fb7461c4267d8f8ec6378f2fab2d377932ee23643d37b3b96b93b1cc26b4da795765ef0d4caf302088b288497f7d2d0640583b28ac6d8a0f5cae16b1159d4dfa786d84da61afdda382644bd87eee11de6c199d6b69bc84f5c99002bd2bc4d6bee190a64d4279652c094a60e41d81a0ce293a36ceee909a714bf3458625ceeea21b1b9d9194c26a33a41ab6187f9ba33fbf7ea80932a5f64c7096fdb51813dbab539b7cd913ab3d2c19b48e238dd3e4868512deaa8f5d73e944e8ac48977e6fa89970750637f27665a69be2abdff27e11b53cd3613a6bd9e1d99e7f28cdc481d1c72ef92676adc4fd15c9085b09be60f8ea538ce80b755ae3eefed0033fe026942422ee418e386b72866f124b1289365ea32753216857e2c06f29ed66f2caaae90c7655942342c88338367e81d9a16ef24f4ed3a2919b87dccad4ca8db74bafb3e07ee25a9af2abd4858ec001ca394bd9232eae1d415a75009bd4df10b863ba80708c61b0ccdf7fee1295f1f087a880031bc1aa94312dd2ab85f7a065f2809c05f38300b7743315dd71b497365f0339141f9c6b95f86a115957b6b00a933a85ee0dd3788089f55833d342aa2122923797b00ce654bf70a9ff5cb5b121ef4f245f2922143de91301e35c0ab7937d3cfe5a851c48b7a68f5f5f7868656682e2fa89c7a5f27eaf482ace9c88a86799a4efa311ca7c5e093f1969f301844eaaafff06126c2e09431b2ab231537256a25fd99fbf6e7be29601037b209c9b3f4b4c1256931854ae6578603ed2a0a505c860e6ac92165117524bc0d933b3958935e361eef4f7c575bb2861f83ba2a2a9c8b96643493bccfb19921e7487043a318024a584ec7af989a496b5591d079e1d6325c00f028ac4fe4bd1c4e3460ba71bca0ea815b58437f4838afbbf03f020ec64aeebba65f9f74576748ac600561f54801b734c84b96eb58951453f81b8d63f63e93d19f0504b0c1c4063ee2e1c7dddf21c379e9704d9265d68f1c8b6acb6a789c1107712f2f8ff8ea2f5b95a5c3cab6a77a008e4247c231c6295d195e6d7ca12963a649d65668c4c323d18b5e29529a1b7f6426832fe50e1e0055fe45fe8d11e111dcb509080f2d76ce707a5910e49fb5780bd14b6dbbc668a68ca8a6b4fb571faf51fff5fdf230a32a0a468fb1e29e645d8c367653dd3f45ed33ac56251bb35ab6d866327c4179d7a73d1b4f55f8a1cc4d9fd29766b1a82e5995ec967d188eb959067ac00e4e49df3c20613069cd945fede2e948248435c2146e9141477e50b329c7cb5663da86b5af786db15636c0c79e94f1052d602ef0df6f056f590bb69c151d9a7e864e1f4e2b1e0c6c2db3a442eb12fbd20aa5bc4bf27b2bd66c5aef57f156370d38c3e130eb16482792935439d0b68dbae12b80aac768dd1f49ab9b6b661472488c30ff6922976efe87c58b8fc010e8d8e929e4ae5862e9027f9aa4734d29464961baedb21ce5cb7850a9466ea612e070794708d5feeb1a89ef4a237a04626e455c0a5354f4f87e5aff72a5a79e4650312e1412da169e0c531d7b4d2e3e3f284de41a581576427a2a5122f9b86e3cab01d015ede0406aacf3f184440cb62f68b5831557acb32972af9d8e3a80e8c446cf6f13327664453e2c68b3c9f49289b9a7f62a18a6c22fb053120dd1a02b9b3ec86dabf2b2f198293e18267f912f5297923230e9cb25dc980074f01d7efcc76de5628ef3aca7a122a1e6ae0610a5873faedacd866bab2e9ce2b394ce0d625d6f2bba4e863b2046c74a5645ecc8a30fe2f6a9aeec57fcbbbc361a134bb1713c1922e8fbb0810759908fa006261a9da29edcde6476267a5d7c4e8d500fa1d8fda0d79c20a14af5797487acac555233832eadea58e9b877202286a0d9ca6d4a3d2c0a88c0cef5fd4a905bc9afaeead77adadcf7a8e655033325c5c85ca4fe18caa500a22b4dd73554f1f097229ba1293abe0d3836145cd9447e14fdaab808b97cb0365f4a2aca63ef4f22f079ca7ace9c8ac48f46d3805a21177635ab163e99b343bd0f0d37dba256e0098cb9b82dbbaef70b6a4fc77c3180ef0a04ab198148d08c302efdc79de6736dc41ee087d0e57fb3b7fcd5cede2099db34319cfa06238bb6a7e174528dd4c39d5e763e3bcf5bdf43a1ad46ac2d93d9b32e000ff6197ce5932ea08ad81a0fa1b9c8ed5328d26c4e432dbb3cb15b0759c385f780102bec8b4b10b4febe0a6162324b41de1a3682b134024204ba8dc6b4f7682736129357c3200cb1a3cdfe5d51ced4e2a555073ead25fc4ac4bb8e2ce083ab34a36d84c5579ed87448ff78eee33aab4fccad320003d86f9e66e17a4883602b430ffb00a4d3884ffd943fd476b201fe59b3a93dcda30fd203407746ac9955d01141744d284859d68df2ebbf6daf0353d3c23eb76ff38b01bc0a680d4fde3bd89fa0da0150f1679c040ea0a9a2ecdb5aa3ddf9bc615c30d3c93e389703046ffbfcaf2440ef0159392510ee45521edcb6ae0cab4ae7a4447a73d351f40cb14a0f10794f0d37d0ca3dbd893f225b8e028a9553edba15a4757165d6a7e2b7fba641cb118b7aa63870723a41a0b30a9bd74881b538ea9d6656a32b09b7f167b73abb0c365c9187009f804f350096f05a9459d83ba3ab2ca69e2beaf58c2774fc5a7cb779fa80d01639c52ec187a50290f27cde07b368983094598b968da1be3e207a24b4641b96fa8c9131504b2551186fe4345d10bb9f05b7b7b65a79392e50a4588325a61fab0764d16d8ef1cd3d1560b8a31c5048cbbae64633125cde9f35100fa84fe2d47be638a405ee626700e239b78144d06497ade44b47c1ea0bb07ca9e553807c41da81ef66589e67576b3ec52dfb590f5f95260a018eb0ef0ea038cda83172b1d1f7d508c5a33518ff209e404c12209fed9026fd3e626ca4963564095e358f7ed44c48a47ead28d1af3484d08fb99b6669f9ab09ab66c233f4151a13b3750dfda26befaf593f258a8c7120d7b23260e834e68de02cbaead6019fd6428c7a10e3090fb5b3443039d5c47970b4dbc79af5fd8d7051063a03fe12fb8d35b667ef7ddd79ec09908c4336178c04bef4450077cf85b36bdc11c07dee2db7467ed9f277c4f294986382c7600308e9d87b202aab489e79632943a53f500336c448b3247c51ba1473905fe61c80580a9ecb286e4359031ae9e3e2d0a15c45189b0d53ba9efa69643fc3816d8d3e0230cc646b3669aab5cdf13852d5fb240b1774ddd21baf2799d282d9f5664f1ce62c7b3166bcd1b39fbaaca7fdbc1e58b2e0c00385bfef3988c8f7519fa9a2424c99b708523472cfbab887f06b8c8766ec6e6e9ee495ca38f8aa4a91857994e7f848581d466d932911d478d78589fd6d5e8131cf408815eaa143c90978835a26a94db2722dde9e5561d2a6b9ae8e7fbf8039900289d31f45da05e1e10da3e43d0920a0f5b046af6ea02dfb7adc982ea241ae170f02eb475318f725e2618211479762c140b3fd6b0beabebf4f0db0e89e66c403872d9271e6ca39c55191e83cd5e6eb1ff014861317f480f3c5625e350072f03a9dbd278be80cb8b27b9e208fdcc3a280ff9317deec8eb673cccc510809712182f387dc364ec03ec97aa6478ed63ab30d2fd24b7b391a990e9b61ee0964a56f1670c34d0989084afd4d4db79b77721dba0124a374049df501f6618e848b664d02e9fb5ac406a642a6c79ea106b4c13ab79359da000f0e543a040ce1e11a16027387bb77853ec03e68e34741c0bc4b864c25ec4e0e1d2e7f5a651b24071f588007f199df977c78b4eba122102dbfec0d119f4a9f53aa9b3361f2a673b9cc0d9e48a5f65744c09f7f3809eb2a8ecb46bc6276ac7b6d1fb55e2e4ebe9798e678e455a9f225c3c2d3243b3006f791c10d09605829aef854f3c64b906fd3c92976f62ddff8f1a04a2361c58a7f00c0f26391e47c661e9eb831e70c22eb03f6d399c44db96270943d7073b52622426fa9eccd5f438f00a614fb9f74010cb14463135bd363cad399e3aca62535911b506c3f2914519cf8fde0d0384788bb00e1bb302be9e7dde766cc5b4a07cd7166190028df0396cc38173d761b8f9d5e7ff6fc5cd30fd36ad3ec15103b6069fdeb3e8f38d1800d15d1fd15303f5b5f2d8d741f888fb7e578ac101d1b94b1365e929f2ecd57a31a2d30f56777985930e905caa98db4e35e385efadac1e045778777883c21d216505fbeeaa24814e812352968d2f84d73ce100657ca9987c91730bc1da5780b214ba58cf05a4c1b5c08eab20bc60e4cc68f360ea59068dbf3f742b7ee9c69a35cfe6bbe18ab90c83d66a91d484bea33318e1d2c4d849702bbf189b658a768824a505ec8e9370a752356bad88f1e566085e24338c4da2e338ffdb649c72c46b4eed6fe646fe3ef03de3e5beab1dffd88c06114a4812374f8e6682bbe3ce56bbd0887dbe5465757c51c8dfdf9ec55b2a75e70cf3fe42f403db9f34cfb89239daac7931e58d6ff83d4222f64fa9bf4ac63a2e703e3332a8901aa860d81ebe26283720f6e29bbe5064b55b281892d3a3ca6603e760695e1291c286e2b14fad2d5bc86ba1b2515c5ff8d93b731378ef702e638525d6be3390ea28edae97ec3ffb055f18f557f4a08432f1bccac4d91942eaf329d78853804a1e21717c8d7aa3be7c92cb0f0fae539fad8161ed578da9542fdc212a1bf622ddf72c40ecfa732040613df126ff2a2186a52ffe71bec8028839eb19076d2ecb88654b73f208918982bc13c65887d2612c901c1b8266a9e172d89b459b372186696c725f94bf38ee831e56d05535fd905d84d784cba394f8d029b00fe15befbecd585790ad646c929008a10726101c13651d31824241e31f3fbcb2bba3eb56c4815547ea6f027c6de5fba7c8ecded9a2f776debf7f64c08ef027b04f58b427ddf988f28b317fe66af9fb63747d0f58243aa6b5e5379de0e63c8806cf64a29fcfa5cd3645c5a6f20664e1b13cbcd5b57bd748c582064ead35075a21e5424e0bb3cdf17d7764ba158fbde67c61859cbb9906d9c567407ae46dfd2cd56cfa74fe31cbe38fcf0a66a202e7baf4aa814a9f0aefa3da7de372de4268d26adadc829c337734e681be03740d30320bde71fe74a2a61e7fe7e62d7a75fc69a4d6952e01f9602d7daf537e6e2a646fb9283c7302266163427b1134ae91837bfca9fe79b7ef7f9f3a8eb518e9aa508ee018e529401df0c63c91569b48d58ef51900eebb509d7f52b90959604acc9d51779751828284ae433e4b70951705f73912f9582130ea2de92c0604affda91630701d8e98c8cd9a25838e2ba46eeca4858c598ebb57af443cceb2fef221210e110daef2c1fbd9980d3b11aff8b996314a08e0a189d568231ad00eadcc84a72e1bff2475fc9e74a2c8570ffd6e79f60bef0437e5ead546379ac094731fb5930826d888acac8513043bfac5b4e9cedc94e23255a864bf8ea058d6a58a2d649faffaece597cad35bdefd2a1c20aca627f58c656d3fb1b881096c5205fd253769cf74d704911b7e04789105af309bf49519c974e45706aa1325cfe2f855d68a0e61a5dbbc54f2aff05fdc88bc9d8264f773f9c295019340b9c646cba4300d690b073f3ecb8c29bc99895267773b0c453e6b83c9e59513115615cd2404b1e4acc3eb6b45dea3f821660ef0a77eac88e74f8fea12a58f404e1908d6c6ecee96404267e2e14c60c872afb1bd077f9bb55bbba5a7f85d275f4ec08c31f58ce4211674442ac2777605905eafc19d3180f81472bb7a941cd6c9f8424b775f8cea5673332fffb198e66cf330bae2790b862a1c8da741ee019a65a47c97aab2ead909410ffa8e7135941574ab8f6be391df4d61d0e87baf703a5d1b2dc2f327ff861fa134882749ec01835abde477d442f64478e6d7a1937ae5f339e3e95155962b0a8daf67132210655f62d5eb228fe9a05e9f205973f68752146cf6c5e298700a712efe156abafcd77a3e52af3c652f9792e6f450e91af13b88eaba02cee0f648957c085a0d7319502d81eafe62b42c353e85d07df1223311719a1546c81a82c64b1a9eba89c12c4039088e6e4e237fe207bba9c0c4ba68cf2f5277fbe767046f07406638d4b675eea11c01bf4ed57d552da6232b8d112cf9ad0fed092520e2055777af76e717a694838c646c70211f3b7e5a76990abee6cfd1b8b1a98ff4aa7748b766d5ad34112d8267d84375f784e36bb5ec2aeda41ea8f97fa9ea149b600f0839a5d11226b79d56e461b877bcc77dfb2a83812d3e79264d1c2c3b349e153aeaa3ec2de1a416c63533a1314ac2a0ea472d2e5713f59b576dcb3452b63d900a6bb57db1c98468e4db6f4b0ba79366d415a2dee047cd162eb31a686e250c90191666b5ce64cf786e090b3e8fcfd268739d9237e9d9df3258746ab0c1e4c411b4016d02812fd400b63dc1b18b68807b62508ed79d777e7bb172876052d72866ecc596a155883af4ef39fdf97267f7babc02b1a2b263bd75e5fce8964b1db9ba08b5f221ab76e8e78d5915363595e7567c64e61e9ef2635f7638f6455582f9c7729af0d5b95727136d74332371f847505c1cc2b2c6569617302a1675d56bb896e6a02b65a2118faaa9cb0f8430391915c786153f79efbfba864471f04b237605db9b47839c91838cffc768069c6e2a9e41644076335cf5addce7be228e9f32551601f34e03c3b1c07f6387106b46fd6b9e2c523fe2cfc3ca65cee3f23137abb6dc7ca8badd419095b437c46dbf3cc44d49fe87b5fb1216bbd2ef343ea38434db55dd99a0a020354f922ce2c0c0397218091e0174eb93941de2bc478eaffc2a8fd9dc69c40d4a4f2d1e33d0359325923fea95343b3f3ddf4e49dc0597c223ed5257b959a0d7ad5e37bbdae498e15d101e0a1036e50ba9e4330dcc3c733504f49fe6f650c74bdeab94f85bb77123feea68e0439960ecabcc51eea734786c5f74789b911af9e1a3b87559d7f8942c7a1928d7773c0d99125fa23ed33ee6b1d0ea16b9780692c14bfd2882dde8be14cd93519b7d86c9143538d98fc0a63ca5e800b983a48c0e24d9f705d749342a9d0795dfe4e1c10e34c9b97a8e59ef17ee0c5fac5ba2e89e359ab0ad63d3820c41bbef639483e7b357f337153ead2db703c9a8d878242b5ccd3d78ed888c6a97f4ab1de114c1af8c655ab18fe2697173867d13fb2d91a21c9bd52489706f20a3478ed99ee394a317a20bc2a3a1aed9c304a0f304ddc8730f51a49b8438a027ffa41ed83ca0a7cc11671a62bdfb591e5882b87bb8f7c5fb7533aa5022670d5f4f0b224cfc55c429cbe5100dead7065999f88e70eb5faedac74bbfe61ba9d7b148432b22d5eb909b869e956d9b357a8f70437dc19c40e82fb4ed0059841748e6c6a627dc8d70f1cd668ba053f2300acb851fdd8e4b3eb6ec1618cfdf95e5e7aa720f286507132b380273741ac501f3a67963c432280294a0d8cb55653a629a23e228ec4848427248c1780e5eb82dc4f10e50c6185f2403552cbfe705a612690a9fbbf4aade1c19c119dc1524f820a476db26c391061fca40f5e27239317d6fa632e8b396f7a606bf9600a8bf175e42c93c65b1d0b930b3fe2ebe555fb004b012dabc8ea3f09318c155ae94ec7ed0ad3d5ee4d64b676ac6967b20178446e3de83ffba8381790e5d9f3b4316a543b96f01c20da5bbf385670defcaaa507bc087cdac8f72e20bb357e775b8904d4cb299c197b8ed5fa3dca0c53da89316b7475633d9b98b5b69a87beadff937fbb881a035df06dabb04ad3054ae5b7748ba7ab0835ab8ac823694691575ab8499a8430dc248ba35899981fb81a9e1c1dc9a4d4120dbc76f79c4874a4268db17cc9f6d6c84d716f330ba9b54c1408884d9df11e0f2e9fc4fb7805fab9e06460f93c43ac07fd60da0a89f5830a794cf3975ebb95a409dea66af067de5285ead04a76381d502acb3bdf33d389aa974b69084cf583b336c47a261b9e793e2a6bcdf2670b96358a2256ce2ecd87ba0036f7b84f560c6b1937d205890e6537ccf63e01ba89886910e24574051e60ad83d4fff2c0d85d421d939a96c41bc99a7745b83454a6620893e393ac5cb110a1a1e6245207d3332f97d3a94b2d431f5cca3d778f4c2d435f696e878ae40a09913f5af3f668308cccf62b660e9f78d04de71f9350a9ed5acd870c779856c22ac6d13f3baedb20e1cfd2a011a306790c542a5d1445852f2987d15fbcea9b874d3dda1afc6e67b2d2f242528e9000e9760d5d43d43fbfa4b83865a635b331e603c671bc81cf9b783d4e4750352bdc423b5fba870537d1c1ea6f5ef14c4b9d0dec4c1263b0220dbc28d17de9e8c4b52040afa5d60d86d2c6389d3b287441ec9f7de8245bffdcaa87d1fb2d2522dd2bba00cb41a1c73996dc0d05e577c2603c05457aaa103cade9fa6df3f418a3fa212d1527dfc58c3840d2c83129c54f00d8f2ddab74d604574bf26a970d06fa51efb92e24180a8129cfb960faf8d64014dfd8d3f4bef266cb6bc966e6abefd1afa8dbd8411e88bc0a59a512ee40226bf236fd096a7ff861283ee3ddefff128cb5341825c9c3e1caeaf73d67a1f41bd66c6ffed40e5766f52bc04b43f65f3d415c824fd067a9e196e1a6bb5717300a970002e81190af8f6d9fd99efa500a0751096330b22c20205b90b071c24ae908218a41289c18ecdf1375236a1536dd50594c53b2d63e9b3ac2ad56fd5faa8b2523a4abfc70c9e1c6aae983f6565e911c895d332d6688ac2080b37d7ae67bf8ac0dae35508aa0db2cc00fe92fa152ccc42535ae4bdada06f37adb4332492804a92400fa5f3bf5ec90244772fb3b091446dd5ce03b93c0a3d2d5248c84e2db800d4d356b8dfd0edd4bb4adf785774297022713382c43dd60c08ad69ab43612307f4d15d83226cabc0873a0cdd0f3eb1199ad7d2de8f47421ad5954bd1b8b9fb9a687763c307feb783622143bfb72c8b21f0747c4e32e939d5fb11f060d251759c47b812e8406e4129a3ae7216620d6e6eccf0bb6208941dab1e7f3981eec00b1c2558b3cfcea3a0a0491694acefb94f7c10cf48981c61b33491bb043f8de052d56ea8663ff32f4f96f4d0a78cf182397d781d2d664a3b9c45d21f39ea45797077feae8629e8c0e78f5ba1da650ef25158214a6fc705ac72afa03d10b5fec2bb9ca2080cda96f6b690fdac8def71bb4b679f82fac4e77346178acf3f3b17ab6969d898e273b61d0095b80c6e8125a561cce75b34c97d55fd452031a1cf607162ca276efcee4f4eec6af8aebe34705f8e5ff66c8b570daa1bfd7e07f607b6fd6dbebcebc5613ff9c7fc5d0324b30e73e5da871142c6541006c0f8477fce4caa0c63e36caedfb3f8e8643bbf2149c23cb4fef575b426292d08be156b8af3e4258cd57821930a6eefa5dd99efe2659509e0a41e6f88ae0d0f1f58488fddadba029d5699c54b42a374f94c4c52b51a7369d08034a6cabb03fb1c525bd1ec3eab1a3f449184dd9252eb895c4cf8c869013926dad1c8560f00d8cc871ecbf6aacf5bbb1da9ebacd6a4d7810df61c83413fbd1c3207a85ff277300b25ac63280a308801aaf44cdfb23cd0a6b36177023b801192ec7de960f7cb0f061404672ba7bd64edba92a2a9bc0f92d80533ebde1517a31d0c72a89be8697e5b137caf91e9f65fa37cead085eff11fe071e117002fa78ff1f1a9207188263b77f94137314b05f519859b601a8c031f6a412b2590c3adc9b18d9aad2a2cef5f781f89c79bbad305ca01c1cd822cc692780625ada91c6b74f60ccd16dd4dcf9ec9c06b4a078be99ffa155c29bd39f85b6fad04410ff2e988d48977533d2b41a771a0631661a51a65071898601d25dea6e66c08d66aaff796b4f3eb10d2cca557ded5fe86a86ff47bbf18d6467f7401b99b53f86ec6640a7e2e3db4935631dbb470f8268a33899b3d87847c7d818ae5940155a483a163fd5979bea4b44d9a6f39b8ecc9b091ee64ae93f92dd10b051c21ae6cf6f7afd0f4c48990a49a19ea7ad14649f86fb53e7e6879a0e92038f609c27e2e95f5666bf675e6eec2f2298b4ceea7da0cce00e96dd55c5cf3c1f02c0d31c49846a177b03b3b2409b54d47a554d148c7ffedf2827e7b70d404de15adbe12676f014f7b526a9e6cb656e38a646eb4e400e3c5134fc46771e07cb67562f0fd3444ca00eca4f74d161e05111faff46b5ecfceefcea7f593266e3e665908b4bde20fb258854658d39ac9da03ff749a64a9caa5b9d4e917ed56f273dbc80dc78c31ed04d268ae65f65a8f72c7c4b46fa0d7c656853d2b34538d88da70af992942bfb1877ef47e2af021ad84074d0305a559f5ada012e2c0f5bbe1ed8bc312778c18f3079a6cc2e98bfaccbd9e6e975e599159aa1f54d0c7f928304a177667fddad5fe4d4614e6e73badc3968c63f928b8c58dca84fd8dadc5d0d1132d0a4f72e50797361a76f594c4bdc16a3ef7883180a93ef54395f66a2c0074c0e06367634c732cbf30bb4a474132706a4da27f400b2f6b86b27f5146c4bdcdfdc9e1a1f2c870ee60e47fc9fb17c920a0096110cd2bf68e3122a2282beb01cc8a58e2410239ca32ff774cea77e762ab482ec19294593bd8c583e951783fe689d9368e3228245c0acc2a5c62d48901e72c631a63108baa9c5ad83fff49180a879486a8010a38e5089a63b3704fddf7938d255dedd76414a26db979e7df6a92e4112189714a12fe15831ee3b1686da43fd7348359b59b2521971dd7c2266b62698b845ec5113740716c524e79f8be0cf8334fc2aa0468adbcb0b57cee963b54df244438135bf3a4f46ccd7c4e86dc133a1da640fc3aa73a3459abbbe23c6b73916ea4abcb426d97e20cb46c98fd9be4186559d2782b8e84916661b7e15f94f0037b9139e1d811f1c18bb89b0bced7a1ecdbb881b8d1576b97af5de65c0adef56476bbcc20b49bab30f064c67cd2fd9a5a1662d17fa65a808243e7ca2afa2edeb390a98302a9c76f020f09cef3bded5ca537969a3f7f3d2d9289e2558d11c7851c07dba1efb1167cd7913b3aebf6cadf9547682df32ecb6e1642dd441f82252eef5e0827c1ab64d2c8b963cb8f21f1f9e2c72470e23f30aec7ed6f7d95cd123c17d34839ff9eae5e7cf09783b0f9b8f608e51c4aa208097bb26f331ca908da44799d767d4d16b107807347c9e47a238a2c45fa9306ef8aaa0dd10d091336c47bae81ca41ddc1c1eef0e55bbd6bb09089c6930f64a5320b21f79cc7e6882233e5e7d31175bbcceff5f61f1f3822d4f678521eb2030c11037af08dcc6a5b3bba9582535033fe9bb2602af116539d53e24884410b355c49abf50a673cc5c60da9a315eb27b538a6ca024079b7165c21cb146ef4845a0206e9031a5e0e9ec791bf76af81894edeb2b5021e62867edb7e8e59dbffd16bbb473be0b006130a3fcba5706815df2683706948e8a57dced9e507b5dc671791848ea7bd4fd3c9cd64b8b49e115accd3cf428b5d7cdf8011ad4dc0d5be1b142fce507fca41115b291a174fdc8e69b049ba451e56534fbb442abfbf963bf285399fcfd531f39bdfc7b00be711d41d6cc08109d848ff95d8ad777387e4229f6866f13459f15f6691962b64c9ef3d0fb0d40888c3085bd457c50f58c19b3eb3ae94700d8772aec6987634b77e08cb6852e89c9441c4bdeb7537e83ea7d1afee8e66314a7d3262cec00466c57639061793c1f2f371e32a3d3391cc9084cfc56009971c53c28a06e5394494b6983417912fa444c5c23a8826f609b247d828bbbd7e89aa1393d5054169504fc4dc265b18ea85368055b09e78a7ae61c659d7364ae5c8e24f7825aac1e2cb0bc18f376e6dbe620900f0b40a2ca0173958f7ee7354c884619e917a7fdf56ccad49b1413479571f860add9efa959f7dba58e087d78bafd7b187a75169e253744df98a5fe01ead16e0a40664af08b808e57a31f48444b6cf09b5419e8cccf5f2bbac300db8335a152a6c4e306eaa2ab71ae8c9537c2e0c46207de826927d84078f72861b9b902395d1e1ded9006641c69b3dcab93488736ce10eed765ac3234822b62fdb9dc6650ac14a1d7e8b51b2bb16ea87ed5092b183ac59b22ff8bd59cfcb38404ead0f4e8cb9cbe1e533a62e58982155e6357c9fc1ae6ae9d7cafabe0810c474469e7dcc0c97d3b2c4c070a99858ec4bf778d261dc0174f223527c6ac7fc3f03e14cf8ceed1969bbb29e2c2f1fb1482c93e78b3def5b49ce1099bdd5188209ae93e7d08695dd85e75a4aed9268a0d22bdbca021f5e88c675529ebd649b8e0a9b77c720bdb7891447fe48cbb6f54eade8f21801e2ba51930c489208a3ec309f1764bfd0cfaf967c8f7c5bf43acd7112f7a0a6fe1f944519333e2efc1533d62e2b4bcf70730c1e8d1f409e1379a960ecea52764b87a25feeda5a8ee8321a20ed226a2a087828a602751509a9a7cda52eefc30c8866c95df16849d7ed0eb7addc06d280c50faa40fcb6b194b339e980706114a9c97cc0be65997366b382445a51cff6afba44d6a56e2ab3a5df16a3c16ff4d17f0253f8c9d148bdfbebd6da5e014332312dd31e59f1e09ff4c30513769ab23c1585c72171cafbaef8850ce3b07b0a24b0aecd73c4c9f4ecf7e886258d2b9caf224c1dcf04d2e05b4f7646a759f026b4a63d5f78664c98b8df649af25bcefe4555ec36842e3e7ab1a3c7ff9e6033e58f09079cc1852256a667233c99e9bbfd16eb2ec63c154e7c5c85806308ceb0f600cc717f246d1bfaad4ea1ebec514e700941c3dc23e571aa9b5d6d7538f50a0d4b306d167544dd432637cd082c4d1366ccb7d51311200fdb613263a8098810dd119a397d243def025c86547a4e53424e4729397038d6a76580462b6dd4e7b8d21cf1a51dde9735e0c67a6dfd0e9a385b8f12dfe1fd94448b1d763940c8da341b616f4cdd0dc1a968e0148fc843f468f0fca45df575af1e4f257f15373d956c0928937c524bdc32b83769fabeb269e0a128c95e7306682622fecb9154b5e5b8a1a8e031243cabe447bf06df2d5bc125505fee0531571cf949f7569c50e141e19becff0a4e41907a0755c70e0c04c7c951dffbf527940b5e3ea7a78d47b0e1d16da14b2ead990e826ac09722d2eefa7a96f2a06f98c8a024b9dadc5c2e2a26d445b1a800268573cac72db7ced4a0c82ef2a24b2714c2f09f8dc01337e566b0ececc996beb163b49c1c255f139b76958be81b32dcc304fbca5dcfde8bf2aa45cb854bbc8017e0022060291150f840346037cdc189008abc57272c5ce0644c5fc937246b21b5318bcf305152b68201d7c2e400b7d5a2dccd30b11579ee749e711c9edea6cd0e2b355692870cf1f5e6121c825beda8f291e7230ec697a6a0cbbfc92bdec91431c9c3cffc994049255e7bfacdc4017d791dc96001b18d89015a59fa44a2478ff6f16b89a4d129600edaaaa48d45c5ab3ab2f9b1675f08a25fa5b4d1f45ae4dcff3baa0156d7cc3e15fb3c3b8671f1611cc386a556520f33c8a90cdeded3d0b93deeb9dc5df39ac5863bce9babcf7049512ba990f3769d7958a3eaa684cbaab5e893b57365a7e43c209fcb1a2c8e814cabff2ba3f38440532aebb8285f96b1cddc7be55d3a12d3c246667d265184b8d1a6141ecd66a3284478d93e0f45662e93358d3e69e70699ec17638acf3e980d2c6d086b74743923c40014b628c3b113572fd535776c3974bfdca8a6ac089095894d9969d1cea4454b1a7237b99cc6055d3e988fab586540ee6f01a8c0ddeb0bd6dfb5c7252da86f85c4574689e9907783bbb8a38f3ceea1d234820a846e8fbcc0523fece5e1cbc7667361f1ce724661e863c4d992765fe9df6ddd118887b24c867bb8392f1f7eb8526023113cac4e5af2acd889f18a27d6dcc8823b484e4eaeb66aa55794a6b60c72ae7d377033854cf768ba0f8152cee655adc2d18bf37462428a7f3def1f80189733fd73fc4b4b879c89d3cd0702da438ba27559f6cc67ab7b862b7b46a8b32ce1355422f9ff6c424b1672f557fe21801f1042a9b74b8e16b151d3fd615a295199f7cc8369f248054c6fe883b4054394966e1c1e38afcb0e192332cff816d6b3c7cc9bea2617b24e9367e6bc4c9720cdfefc4f014ae1b5ce661d7e53bd0efc5f98ffffd96f178757c25db57841b7fd9251692fe932843520569752230432ceac9ef2d615f5d8018f3094d828ad8299068d7607a3588fde9008145d55f64f93486982ea0ae74645a0b42c2d904b59e0105f0ed3a7955eaf971cdc7eea603122d40b7200d7492cb31e2effb3e3724389cc4b5a5d6b714813cc03cfac6a4091cb80b38e50f0881f9038f8f1840916b92c54047d73d9bbe8d5aedf817a814ccd6a6ac2b0ea388130e631f81fa61c6fdda929a9e737eb566daec496a2c41cb14e88ab34d7ede7bf950bbafcdb5a4ebae2ccce0c71e817deedbbedb43c3237a3b0739d852dfd0bf4f8683dc0006b25c1634827d3c15adef966c484bb50255cbf584d1310c59994b6fea93c593495bb12a90c412bdec3515dbd8cb7d08f4a3ba7ca5aab1fc558795b39d34baf428fbc19e3d0422b7ee95f641d304aee9046f34173b09b62e7c913a87e40436609aa9130d003186286350eeec0c87c3daed7e8831467561047911b08259aee47483f79f7c6154fffcf04c105fe89458e15a8346fdcfa81396ba24fc58a5c1fe4b928b44d332720ddd064bbd58fad155bd5d2bc86bb6eaa318cc94f1a2e021480ea653e14fe37b8f1f3a09e534fdc9eb1f808ecca5ace0de31a2a5fb4db474920c4442c39a6437a6f7ba13e44979f465a2de27d9427f18b72d36046709d233a5facef364f85a18653ef9c57256dcc1c9b2fc3070724a5bcaaea3744dd26fcf40ede1626adc7df5f302f59b55e0a0e4483f29d578968277c57e2f799adb7cc76a84bb32a7438b5e00b94f6836a3eb8c74ddf417ce92cac4553719faa91abeae5de36ecbea6e37faaff39812fd81ccc9f597f62b26968a3368347a84d3ce4290f61a156a05767af054b9f03d5771bd910fecc3f2ef68f8174dc1189192a9dd5c2d0d51d977821bf793acacfc7b7e84b2c01d5ac0a6db14794c570f72a83155f8da695f33c03e306b858ac8764d4f41c6b643690ddcd8d102795d8a12d8e1be969833561bd42821ea12fcb83725fb94d2d60f30046183073f0ffa7980edd0f271dae7bee4a36fd541d94a07a642dffea519aa80421d79e9ce851889f151c99e022c04eafb04dd4fa9563887f325ed91d18bd2cb17ae07d79a339b8b375b5f891e620e1b9145bfd1d2c60edfa0f51fd35f67af57f79de306a28b7cfd684aeb6ec799275fab51883ac7553364498e3de2b7dbc02d1bd50fa5c0efcabb036ebd1249aa873c3ab935f9fa3c7501116cbac62e12f2fb198eb2ba4156dd88843073e3561df8c5deb2ce299d0bb3a7e6bd79e53fec65f4cd34d4dc1e3fcd6fbbc0c7cada3bfafc76f66053d5708d1abfc95435c28023b9cdd9b1aa79c2b501b7b958fda823e0c178389737d539cd86c4e762318617e8172e864c4f2b715f56ac2209e8670ff335c4b30ff9427df1a08b942128fd2daa9d0f14a921a93f5e2fcb7c952b267a299b4b7506c4b44d8064242bbae7c463b678e1d9265a6ec7674bd57d239d127a99e02a704091fc0a2a22b9524ef56a5a5cac8386e330bf02945df5f395e9ac5306f109e7f69a6739d059c573b4e755bd6ba25bdd08725da9b8789d62a2d0a837e1b8550c0c6bea7925bfc4dfcc3639","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
