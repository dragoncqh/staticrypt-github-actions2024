<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fd9d9f7e6061637932272425a44f1ffa83f0266f7bd4064d9ee4c74750619bcb19befad9ad0a7fd954240195993b1b133e0ad919d59bc1b880ce80134d2437234838c17ab446176e856935c22e591e881a28e9f7aff9adaa39389115b2ce6a15296f810be4ad0e9c02704e959a5f61e84eee455e9ecca58a3e1ba409fa01c0a96643cedd8d9f9a1067891866ce3e1dbec1217f78b85aea24457250a5c474e567aa828d035a2228caa5b5e80e261852fe583ac3c904301d64604493f7aff321106a2718cf56410d90adf215baef8853be3cb40c597aff8f17fb1bff1fea62c9d13e25f9e063e0822c73f58e7e8a766fdcde3970e4ab04bfbe9ffaa4a4fe6af65c665a6bd0a593101aa7871eca45e3b1aea9cf19a0e7be22a0b6222c59b2601e165381adba4bf6226c999627f5709c293ecc3bb6879ceb9d05e519ad5b16bf8effc8be632c9563c94e775a0b75eacde6cc6fbdbbbe26fa17171bd127661fce0094d634e0c6b575e27387fac12c95f1d85adfa1fe8c0b45530e598a9bd59e6ed06f764a5a18f847de93d6fccb38135ccdc377f5d89e66a066e444e69f6ab0487078c805dae2dffb3f875ed6fa4f9e0e385e7d097aafb9cea79c9d47fe80d9cbc42235e38e69d837675da1422521623cb6ac550dab3eca56337b72b649cd318acab65eada1a1667bc508f237509aa2422b24663b942f531083d9a6f8eb2736953aecf3febfe09db141f609bbb055a1d25f221cef5b33b4995183ac0fe0ead24518cbf101868c34fa9e5d73d4f9e9c22acca266060612badca6932f66cf89183e138f0de57058f8fc55eb3dd72a059776914f227444d2ac0126e05f4a5055ffb4696aa1163b30d24da810a5cfb98d9bf07c23287574ed765f814163b72d1d719864771cd08ce8280de9e8b160f4daaecd7940ee8eda76715e58a5d8fa990e16d532a8c784517520e4fcb797316c7cd619171e14654800c013358effe998c6589a653a4bcc2d534f42ef15d692ca606bbd189f68b291b204e7fa952e80e9f06684a3a03ed782a3f0dee6207ad3249f9432536757bafb2061e54bdd56b6049c0ffed9beeb999ca40c9b68af3310508d09c3e476135073417f5cd5b8c86c134b48cb1635076a653492db3914d72e6cc78104d4d8ab3458f7bbd0a5a5b0ffaed7bf48a0f48fdec26de44f5fb71663032b0e581693059c0b4c9f06e65f19fcb3d7b9b73f212eb45ad40f7f2778f4082103c792c0c26016df778709714c7ffa0fde48872751b986831192fd32cc4f11e122bced9f6e6ffac64b5bd030f5e12356b563af883c03e2c2899980b7d2bce656f62e9fb6e873dbfb464782821fca97aea932131277dcf8a6d82ff8bd1085c9033ed362b8d8ad6b8b47e2ffb6240fb4a4e3f4f7a72b9f252ec8a3f0f1b0d2349ea09d171629b11232c1bb8b33fd336497cb6d02a58359fd2cd3a3eca0ad3e67ac56af53bd63768f852d17c8dbc273ee5cf51ae24b4f72c39908936338b4fce21f462949f6dd88206e624ff79cc872750e49a73d8c9baa08349d20789940ba148538574f65f62d3631b03829683c90a14250268a2f2bbcc851359caf2d00f8a55a2e57fbb4ec41c6e78d4cb8203286cc4fde8022b00c508fe952cd92da1b56b30e3d79831b9013773295287983b40d219968ebf782b25e9448c9488c3f1de7fa14086444862da4e03d05d66e8755acc9e66355d6d450e6eeec8b1359b93f99b51702478226a2c390097ff0e5fe59d3842c555b96bcfe3733fe94fc68160b986f4eed1279acb133605914bce80159b26f381f642052601b000572c6e4885386ffdee206b47abb7732fda3e9f8409a1777e6917d89ddf6e2d602b70e15102912226b87925a302856676e4b0d2dc0630a6d7938e3413e64b56c663bddc5154d183019990760f9d58465803d33a37f20a4ba04a5c066fc0c0f1cc604c402ee8f0535dae369e54a95be861624005b34e01757467d26b43914f552b6260c552641780fd8f4f2a8a7ebd3bebec46e8a7d6d3f88785a751738855b06f9096e0ee2b541d491728f5c178cf68e7de9408e63fe4f054a4b206d69d516b1b652a2cc15960cd74d40ea3197e475f695ca532ec2f1032557c67616e1102194c12c3d22c5d4f25af1e83e7692c90e93a976f15ae888ca010049b93cd5e1b11cea5c6743665dd458820dd3e80b013607d2818d2483d5641ded63a973a97f48a8df13a72307f44f56aa0e33b0623b6aaed2c16c28adf249c2c0a52746d386d6983f570793a04df41584309fc23995f6950a67a695a3c12d9880229d97f14e836bba842e4eb81d2b186682e86657f50254396fc465770691775f323f6962ef39f9873430090a6783322a884b8f856593474b7a03a4cd9a5bfe98fa0361f61876dc66493ee8fa2a956cf4141c07b08ca7bfe34ce4d3918c49091f8530881038e70df99cf35ef09b70c3c0a7b97380bad7b4aae71d6a9a540e398576f04bac9e50e1de41886498257a6dcf5c63c3ca2179306e85f1b2c44809662f59516287ad71933372c1728ea427e08e95bec8c89ffe802ddcdba93f5feae23694e0cfd07471e5e9434d1badc22353088f06e9875ad647fce3ab925eef5bb9794752e071f2532aa97f638a5093c9324b61d800cbf0d2466e757790607990d485a5109573259cc352a9ed9cc916a5fd39596d4e7240a4bc512b9ed2576ba2350a9c576bf209a13f2b69603f7e2eb962301c1196a0012a9d870838568ab32544320b1f66b404e778650705131a2cd1ff772a5cb948b60c0125a0c1597a0d87e55bb2e91f1c6ec47eeb05db5a742eb507659bc018602763b88126fe1cc7524d5b27a5b95abca13a3af3b7ddc4bc69bd0a5f6eeff719541fd071433ebb9ba99c6571edf2c8acd278f821a8586bd23c4d7a295980801b861a9b8f0912956ef949739208a5afe4ac340c43bab7d48dc8aa289eb1636c02b4512b3845851d6d34beb5e31e1966f09751c036444e41291160ec1a1d0643764494cec955dfb06d424c0eb9e3666f5696e350a9bceecc0fc3eca3d64aa9e8daa8a26a7f4db0b83754d3af5a44b57ff00a54991a5a0a25ba4009557b3de9301979886eaefb0f6e89a80e2d9137a48e42035ff2e4a0f15ebf784fe9f57c7664630f32312dfff89c676f793a161328ccc94f089cd523370ede40521c967bbb96f733254774239733709a6358dd8e3d9cf2c42838d2fdf215f3a2e14ae4e1f668b5045f759383a475560711415099441f90350ba903feeae324672c66e361116b1eb2663cf4460f7bc7acb43012262ac9f392624e2e418abe4aa38b86f97e184c033c51af03fd89a9ceac43a12e541a70d828d50520a1cbb184333d2959ce239efd597d62de3a1a6580aa677491177e46495d717f97402efd3648d91a18336077b357692cde9a50bcb84d8b5c8ed4491f8981628ae2069829da35c4ef532fec9eff30b7c172bfc5ee1be80277b7303c96e77507f62e51c909130a9c8fbf49057af5fa22131452bfe7ffb7a7c4a1ca1abe184dbdb58cac5c2dc91a4bf913a2c2bf4ef5b295c4cdb045b595edbe30169d5c7c280d5e86e5b4993550ee2a856c9f9b508b4f54a42bfeda6c62daf79aa827aaa37c15c942ba69983049b6884568ca6bc57e3076ea0df41ce4b34494c90416a9c0780371e3abc8c6517768b709386db7f67d7229cbc820216658f66141c62552ebf8e6799541358456b71c2588461a748adb730c1ddb751d5d393bc5d140681c931225b76f0322127c0f84a7223af73e08539f6beb976b78b3eb9426f2b87d6535eeea7e13d09c06e23b1b1914cc03f11fb17d8d479cc0846b597457df1201d75e02b88d7e74b0dccbf834d609ce78a42f97cace3c68da32132ff5a8d92cfdcfe2f5d7bc53539f08783ca680f90b54cbdc9f0513ef79347f73e750266513c9b7795041d5cc5d60814ca693e4ed8ea57b2009f032c6e961c713cee6c532b4cf34b7f5d81921471840d0e15d312e93d809b1cdcffa0bf45873af45fa9aa46588a0141543f2c205dc15ac2329d4a6453c3d96cd9ca4cfa1b61a8885ec8e57d8350d464cd649d0229422d6e619bed27187d7d87d4de60118e884a3c9bf76559846161f8004dbc7f7f85cda810f39d93b3cf3877519bca88cd586c6093d2ccd9d10b1e8519f6f327137b9345ba2412ef0ce15be016ed10d205dbdedec2e95f5d0fafae664ab02c2578dab2629384b6f614e8d6d020923138e75743119e9f790397a872a631cbc162d7e3a53f398c49fe1c5caa2eedcbf34af0eaafa623f49805600bcde356052a412dd82c3be0c49b3a497a74e0431fcfa28c37ac0dcc3967b7b5326dd48292c4819e7783c2fd4f4e017a7e745ad1ba4722e6c59eac3e89a73156a71f2af2f44c01a6ece6b77bf50f08261545375ffd4e348539890d3b810f30589c0d76ec6cfbde19504375ee9fe04a89bd471355383176ec222043f53ecfafab41b436a8ab6850569a38c11d156e3d986ece4438d5225dc8d4eb3a5d3750145c2d1ce3c98fad512c9f2d555c325fc567602ab5d1cae7fd8ec425f0a60e4d4c30280707a9377c2ecd0e4a147848cd2dcda2a768ae350c82703b6692972c3171a1c9d4293d6d169e4552f9ea0d7a15ed8898d4044882dde4d20a411857bb757baa3a5c5ac14fb9c57e4744a00c7ba51322ffc9e55510904e6b460d55ca744650024332a1f3bfddcf8ca5650b9c1f53c8203f7a0b5f9a5520203de8fad1bae0a165e5c594eb416124296304dae7bd323e35640c486a18eb7b33d895bfd526d76eecadb58aadb89c17f5f9eae8471ba45fb0e507df51076e07e902ca6ac6ecdfa9110e2afaaac93af226c9c1c3671157c4fbeaa9e9d528cb83fcbdf531b2dc82901c6767fbcc66ed64732e2827434ce91e0f73b455423b03ef0a8fe8b92c045f8b5abbfb497d2138d074613461f02078aa0751fe4ec99a5bab4b9e97944a902e3673b06f5cf93f8fe95465bd16e89c40b93e62037b8bfc214cec86f76e6e3cd282d947e90e339cfa8abe8b2782a51637ee1ef9caba8648d1d832ec37b89bad19d8f8740e3685e9c884968558d422f5e63e4721001a1e03cfb1c6b2350ef0ac0fa4182d200a4f36d2eb149ea58331331c2f8cc07c1254d3c06b8240a9f3b4e6f2695a4e80f055b0794344e29ec11675565737f25f82bcf807d55e3cfb54aad48f67bd8f65ad5c739354f8a889b1bdb019bb77933bde46b928e9754981ea210b80a4c0ad23c5634ebca6c9ec6f0cda4cfccc62ff64b2a7aad2f5bc8a4a67e0f407e7890b2f973c8ae26bc523848f52aa5068d39052c9bd87e8bfc5c4edde8f11ae43a4b4c9825435392b03468402a4612f7f39ceffabc0d493695985bd4486636152024299413b9e9e949a2e3c456d0f94d24b771b92cea8b498452208e0b1c595bcc0c7dde245290a6600ac8dc98afa8fcf0d54ec56af5b4846290c3e56c9c2bc04b49f8ae9e9ebcff60d668d3573be848f202e474aaebca990c645ca59ee98c8d3ef2c1436cf7a139a1ca3fd8798615304f444f7c1fa1bb2edb7e62cb4e3c6a904e094f2c93d957c0acd8176ced23b1c5dd42833a29c6d68d2205be1e50fb30c3af01b8a8a366bd7657fd841a60e253219cad312896279903068da916b314fb6695c229b4329735023d1fa52984f0768328e95ccc2f94238ce5a6d22deea60f7684e1f670e47f6d1af04977e0313305c558ab8d0db77b2827933aa8d40789642b00e35021040f80fae8e10505f4169cd8f2792536cdae8ff4bee3a23b4d4db09cfc0dba0ef716543d2ce8d0a1ccb4dc06cfffe2dc147275215b03030de2e4ec52ba26279636207b6106484d2e5b1c069557ee11025f9d9d6d4efcc20135e6e135e551c93a1ed189d9512b102c16274e01f470b403d1ab4a7314d8fbe0af1a57d583d0a9f6075755696deb9c04a3d73f023b35cc7cdee2100fa53bf875ad97980e0798a92c15fe8c6fa932424d6172c85525cd54302f5acc5bcf4cbabf5b2a4c363bcc14af7bc3df240c9341c3b54c6b2c207f23d5f531c2dcfe9bdaecd0f260d1380abceb28ae3e19355fee62a2932f60db35c0c2ceeb17dc6711f886807862757427f0dbb3407d70b73b44d9eab23b1bfa3c450599c415ab35a6d020167e4b8fe9750b676fd2c2ab701e89c9b3e39e26d4dc55590ed2b388dc5592dd882db1f1faffbee1f3940d1d41d738c68a96380c35453aba6f6e128145593eeb39f42b8d2a470f05e23bcf4b6d49890c67ce5d5d49efeec0a8dee748e287153f539ab58ffadbfd5304d4deced2e8b3154b7e8de9d67d105236cad893800d82ee6e9caf0c9053b69589ead406972359d614d1923b91c767aca355bb8a463c5a2280474e70338f1f42c1f37063c6fde59472f8fa735e6a3caf3a0cf3e910f06b6a59eb76bce7f8e7263e28155993749aadcf3d03d1bf36d96683bc00cb8fb1c1bc498f52de13c42b603efa013c1ea7f372b4b873a896738d671e4beaf694da9e6d3737580ee34cb5e9480f39ffef8e08e1b0053516b0693a5a7dacc40bc4b73fbd86fd2bff3dfc8032d3b1d049db4b83069b3e9b87e388edd4467080993ed4e3375954259dd48a5c96324f1ed045f646b90429f96f4283de82e0de4cadaffcec3292fa0a912e13652613efd62b27bfc86d90abb4a44db7f5e6ee9b57175ac26305b84b6827b663a4afd89a83a8426bb6638bee039622dbe76f12c87d9544b75ca2795b652fb69a60cb51abd791416f2e2c0edc31e93b1a64a53f48fddc8d2d9da91c8862cd5134487627e485d3125b3d132a4fe29b5e45629d0cdd4336424a594ff05249de363c7f7e023d5af50b8f54f7fe016d6d5244ee1e63b7ea6f02e3fa292d4cc147af83c99012982a3f310423adb32aa747c32fe8b7d976125c2a77f3cb845de7f920217bfb1d78667fd090fb2d1d1c2c4a02eb9563fd1cb44d598fc0f38cf9339ce77f12568740187bf9910940150b9ef77b21eba455c1709d395c993c8b8ef53202a53512e584e38c2d69dee28cd7e725dace2ce36003969b3d7e66dd5d3f557bb62ab58bda91e7d059afaa59ee5bc8ab944906eb55668b3c9b9013de9c6f2207f802d6fa612ca04ffc362944e0596322ce700e05d549f29b003b7859ba799a5291d4358f2f17478845236803bceef3111608c82646309f19b6014ddfa4d146f9e257a28b9bd464ff79c53564e95b943544897c9bf7b837479ef2285cf44edf411470efb04edcc38cc6c2add83982d0c9cebc03585d0ee30bbef867d627eec40f9e161d4d2ce0ba73a42f66b8306d89be60bc799a9bbeefc962c4e8c74fb55ed4b21293195a812eadd49fa0c178c3404672df54a819ca4627e5158594f51f47b048a27fafb27966c5c8f15a6746e9178a8c6139a9b7124e043b4e6e2a72f1bd42afc3e741149e74742c03cb9831e5147160df4f9aadcaa0c85bfefaf34df76f6a9c7696c438fceb30d48747b0f7f578780c4ad8644876c151e46b848d381a338579339174f1102b731afd23892cd56eac4afea3ff9e87fc0d43d50cca04059b6374eb5e1656549e313f0568826d32b7011ee91e7833e71e77f79d99a1ffa2d1fb3f4d22a83a32a2c547abbf62ae31e191d75a49ee69afa3993ceb07649122d49878dd8ac86dc838e69a5a4133750851cdefa91b3d31c6c0198b25520a99746215d48f7967a8fb79d7103d80a7e601b78e4f603468b6bd98cf1a9a0a6373c18f01a76cd7f2fd794f3777c78466157e37d98e85c0bdff3865154141590115e04295780e9cdfa9cf8c42b0cdbcde667a27736b220df8714a77ed16d3c624f9facb4110778935bca7718bfde71470f6c66f0ea51bedae043be649db13d1fb479fccff3fd613409a25f4fe1e9cda6cd0e57d3e0861eb5df65a1ef1567a42fd46fd30cd7716a40035d95b04ebb2a70c733b0e0ec19907efb09cbc96f6de7690a2aeef58049389f9080fe4e106a51e30080fadffb27c26db3b26f24923a7a7aa02fd2635623aca2c9409cb45c491d958b6edc3781b8f2394fa03c1f19547d512dab5f90c1892142d5545cd7abdb4d1967f0dd78e9f6c8e82a3ffabcbd40d44b49641c6b4a305145451aba9f38e11b9db9afbbc49e69c073aebbdf8ad31992311a11e49c8dbbadefcd806931ebea65a504907926172b6b736b28a4fe435431c667adb0acaf933284c20bb9fbbf750aa93ad4f7671d7895b7437ffd3826a9d5fef9e700b162b3cb4ab568d4c9f5d54ded9e7dcf4f94659f43d4272ab1c6de94174306c5eba03430fcce14aa44a5939aeb99a7a052ab8fe941a68758926950b3f135845d8c06ad9c1e0d599b128d3c95cfb61292a345db837eaa0513b364c1f1fc00f63fc656be86d73ef220b75b9ef19ff6da2f6f8ca1d65cf7376117c448feb929772461c2b00d3dd356d0370a0ce2b28abeb97a2779d8734938824535335eeef83e5b945b1effd9bc53f93bfca5a1a0651a20c612a5a94466e85a48859ee5bda194b252ffbc127e50f295cd38cecf30a6399925e7b480f0b131a4a42e269fa969772e17d590f53563c36edf1428f5fc7c42655983c39bbe2e879cbf2ba7920eeaf139a0393f19a0e541c9c8b3caf185506082f3e978f906f2d51019fb9a8aa56795519e91fe856eb55e563dca251bb47758b923bfd4b206a62766e1ead033d0d320931cf5f640c922e07c512d9274adf7d477bf84a72511740d0f39ff5a1110ddb04c2a46160b6f4cb994a641e76aa8d24193a50eb9a514c356932ef0284c77a45685b2dcfcbca4be38f8d5cbe13253976f7f8bfca86781d66064d1e99c9c61114cbd79fe9b4430c88600ae4f6fddd7523912efb839d91f240b36e97ca58917e549a292b22c3ecb3bba94458c8784342e7abb6ccef080044587e0a2a945140d2e354007567dbfa0ca79d8870082032ac88054986e6ca95347acdb9330132c9f5a261ba89e6f410cfe61cd232dfdf25e80fc2b7e3d477fe02f6589179576c0425177269a6c5d0b273ffcb132624993696cd855dec3443ffbece9d1b50a64590ef15529b29cf52712398240360aa89978809bd4e69c6e51dcce92c58659ef4b3d4abda8ee28d753036768b23e42fec72eaac0a9fdf09944c5902ae0dc2c4066068960bdcd5fd3df5793172c1ea0afa58f413abb2aad1722ab14eebbddad1c4e1d4409de3fcc36d33ec6dfb1d2f9eb9e86bee84c03bcb67a76503f09b3b84322c06f438356b1cf7d58dc4169249e47f8e2d658d2cd6e35c391dab9d97e5ea369ba5c5923c8687190646816ef907713ccc80c63018420f1e74e0e01996db0972cbf4e861b31d94f23dfc86a24567853734f93a6a796bbd6d29fb964444eba0a27952ebf261fcb8e4a6ee6041a98c4ae635b7b37694dc167a5b4aae963d415d9b2b06988b53e38cd932cb1f15a8f78c88bd9ccfeb0070db74cdae1039f287cb5c4d11e7de22a7561d6db3c6e2ec44bdb138897524568f7794c1edc42a65ae105ed048b97837738c5efc699b0d3a3c31d7e4befd0d42b80ff82ef654a5f074a035f1044ea8adb9020ec0183f423f1224802bf66eec946d027daa89044f07eabbbee34d045138eab9f48411db9309520e46fd5d5756a41417775ec06635553584af61c163bbd13c29f3769d60d5c4c9573c57a8cdb5a53322a558ad07f28a2e59184bbb594838a18e9cc3d6e47ccc24740f763e0940f29fffab3d825577f68022c0b46e9d6109450030759a5c377ae018dca3da503bcdb6db81e9ff119986bf9a5daabc72a08e5927870f90323570902431345bca15f99364e6a5eef17e159a407fb1196b5529f4b34567a367047385e1b969fc779d939a9fa387bdd03b95e0b1067162c5bc426fc881978aff18f93556f7f9781b7992bfbd0c7cb15c94479664640d34bdffc38d2fd7ed1838ae680e1322c664ef790978083e16c1cf773dafc2d806087aa10e916577684fa3f6672aa6f00ba4254cb0aa6c072c67c4babe026c2d478286046659d81a96a6f7311f155ac2bf6e216ffc0083a666f5f89edb2c084f8ad6c7ce46116edf90169f556b7a26ffa5c63d885beacc2834906e64072fc3041378ae921774bd2fe68c1cb14feb0974177b8c509bef9beb4668107cf8fd63be461634d8fd18b7424ec3248fee4e0131a154e01ef4f00a9c2b6fc9d79e7288b43c1f64c2af14c6a2f963a646c427faeca22aac70d1a7f1ad24d9b3563e95342dca80b87cdb7efe48d9c948a1ad424a584d5ec36502a786465e35dbcb1693daf631f4d945fcdef53adec3cc6acf176748e0b528630a59fc6fa19228e34885871b2e9973238e94000f035cf2dbbf84ad24d061363077dd23ffa364e9a5fd8d3fbdffedf5f56e53c27a1cf93b3dc0ceb8c8dd4b4dc8e8fb20c86e2669307cd360de0bb7dfad81844ab0522073a3ab191c5c45c40097c0172addfdda5b81360a36fa073d273def38a0fa5b538bbaf3029ebee9ff65459380a055e6b98c406e8a2bcacf0477bb3ad30380adde32a406c5658a68b1bd2f90dba3d1df0585b9f5be6e2932dceb2c42651455b5ada0d7a3174c6d704dac9f1eb35db7fcd0c22425d2764dfca51cae1153b8e5f4e692c1fdd7fe9a78397c57393ca211db5078f43b01f1b498fa44cea1ef8efda5ee65e03c7c6b5b81c658d76436ab8376f289da81cc74d96200a147cf855420ea32f4c114e4c9323e59591c834f84950290e181023aa5685dd863e9fe5e19d529b40729e6f9718a307f280173d4a495db4a6d804e195b589515c3726820e016510b17afdd2c78a738aba8bce3d264a0b9d0c24052350ab3f773b24404bb1eeae10f09c65dc6354f3484a8cfa0dad3581fafe3e0e5cb8a9b7a95607403e7561a1e9cacef30b33de1d8af6d2b07f9ce7aef9744f0b623503ed300104be2a7b8dd42c5e2e73a56439a618bfed545ac76b037eb0f7beb4e863478a24175c136867983355f37bf77c5098fc65da086393ff6443c6cbb46fd28539cc3fa5aaaf533ff7a5745dab9cc04b92732577ce6a2fc5c5e8a1dca75110c184f7a7b669ca8114cecbae666f93b90ff49f26e1739be7e41ff429f3cd9e061fca93f4c3437f82516cabe58f5f8277987e8cee49f4d23de8ad0943a262a7f601fefb5367c2e493b3a26cf20fbe2c26efc2f65cb033b6323a0efa9bb821c7ebb3a0bd2953538b4e2dcc2922fa2adebfc2ff4224107729aac98998694c942585b0461a6fbfd4934961b36d3da6c75ea43b7a331902bdb80f074858bfae3de4fef422b00fbc9263faa6792ed9c2affdd9ff569e51a451706e3695e4cdea08884fdeae29bd2b506c15d99b81b20662aaa24c38acabdc9518183a1a37449533642f68b51ab4ee016a29d662736ba8fc9910cbf12871c3da70cf49924ee03fdae8c11dac8370e0cba784a1c3d0823632eabfcca3234487b1f93f4c83fe7bbfc8bd459030cf37e1d8b186c913ea074e9b6d0a088fb2e0a829d0989fef5c4e8c6b17c686b53fea60624a3623ead70a944c5086d948e4e3beac66394c65e1ccfec853ec9354baacc0da8636605b8ee06bb100aebd10fe80995ef3e53de6f7953353bda80dbb54d194369bd4c18e31f00389282525a56ea6a774dbb4e79ece3659d2ec9b39380025f3765cb6bbb33c456dfb7511d048a97bc831f0fc4e798262a75745526eefd927c94dbafb7aff1fb40a644efc63f5c0e5df598c9a06ae982da8d3e27d36325fea6f15262cd2b58bc72b2f84af27d00bc807c46aa87ee0f5a5118623f29dbcb389b9214c6780dfba2b8c8b82cc1330907bfaf856076f05086702c2e7465498033f2da9eabdf1ff3bf052257b00ee0637febcf04c6e57bf1a12cd2f40e5e6b043e9664d38d6cdc589a437335d1e2a5bc7b092437d9c6efaff5c1be58f1e7b377104af3a7ca3261ceee1be115e55aff19d34da64d128ec66754fd78e6e0e9e95db9fc0f4fbd2402096d5c34d976e0e9392133e85acdbea514a093fc90ff4cfb5915f2e2213e891b9df7ce4c6c759831421edbcc8f8e90f4ed8af1e1110a3876658c216f9f2e298a3c171f6cc1fa376be930d08590176862231082211272cd7201ab17066c13307722a641c203dcaedfbc4dddc4297beccba1b8feb9bf17d97f7ee5c96da7cca1a1b4b920c5c9f31d9279fac1f31b241186e1825b81143217d23f5f20c1119611c0b4605795798b94bfb569038eaf734dbb95124f8289249becfb8d8338f74320d71c1867b460ec8a69cf1361a7a299a9b30be29df27b4ae41aa7c66ed14dedf76c0ab6f4e94aed1b0d544131a05bb86d7b49e8a34b9c850959150d76456cc06a1dc8e23fc7932ad4c3fc69d29042a66d76386c6b2c07e4167b20ec77c13a76546d01cb4cbe82846ade2b409b844c76c8ebacd393e02a9389a24ce8c6587eb9112b4725ecf05bb38c047242bff783e21ad4fb091a41bae022b439affa0154ab29a7730364df6dcb99f40a4259664495ec1472644c07363d7b6d4dd6628a24520f1fc29dfb7588a1fcf4acfc032ebfaa61c08f2211317cbaa533bdf6df0f75a13e4db251481c646f7819369b84ea7656afb96564643be971d000e392308c4a6e5465ca00961f263ed2f352543b9e670ab06629a81cc88c43f624be696d7e897a24cdefc7950c00d48e7f5e3f202e2828ea72d37adfcf9349d60beb03cf0818bf7fc636f65adfe3dacff8f1c2271bc864246b82e10e74e23c9fb09e7c291830f1973f17d4de4d09f66fee430391aaf2fa0df543038d8824002065af7f8e9ac7cbd449dd9bc7ba7315f74304fc35b9f1b64ae62fbbfd2f76da430f25f4c4d7020f682102bc467b1d43efb69c76f5b9f26e328a9d662428f1e757830ca6b847c92d747430230cda07eddd763b0a382c32dbc25f07844dd922070418c294df97f1fa51fb6c6fbc119fced8365e29f91ae016c66a193c578ad5e4b9165f0e29d431b42df1272ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
