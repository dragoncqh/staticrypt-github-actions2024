<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ac3ff8331395143c107b2d3322658a42dd1b2b07389222ce99891d94daab88d5210c6b5f40bb1eaa39f79fbe084258e7caee1e72590382388e0da9530377a0b4449cf3ec3409d0fbf2df6091bc0cc3aaf4940bd9bbfd57ff7607e6caa724a00b7c6a6531b23a37d7f03c231a28a6fe8bbe3304d59f1bc201dbd742c8af5c0f4a50f9fc4091b7ed619ca24435fb62906535fa73795050e51ebbd0956b4a226404b825bf72829f19163bd2c906cb223b4b3e76063aebc0e10e14e5cf19b5a6616af6e08638092783e680f9233b80c74ff4afbd6035ab3cb8a5ddfb4b8b87a4fcc4df6c128642040a8626b8e1437e727dcb9082092040da9370fc5d33708356a0adcda1327a28e9c2700cad1ac092681022ec77170e9b99b85c23c71bc08714cf462d635079fc3053a5666eb1ff785e19fd64e64570bf7a8ada73aa49d69ff474c1ab515ce978e24f58470381c54dafb4ae9d59e3a7493bb3039ca11c0b2c9efeac4503ce47ded5d9ef1fe812d939d3a5269981575391aced86ada9d971765cd9347c96b7861a9098c04f4145608a36534c9e75d34741e18f3f675b7984a9eab9d556529a47ac7c44932d6b2c39d95d53e006a38176b12d4cef51d23d44d80911fe697bf35866650c25177d6325b806e590e6bd2bb38b5085f27bb7599f6edc37cb92b4522a865829f5005eb64f9f6f9b1218b93dcf0cadd934299d8fa419c41b74d75c5f1c8f3223f19d76257f3f006c36d886744f7922f160a718679e1adc412cdc3b842f5819649cc2d52e5bab05994cec6c1d940d543d9b1588b71051938a6eed979925b4275159c06f093ab705878a3f333299bfc3b46d6093329c8b4639f78c3175b36e1d592dd01ad23085a1d323a39bb28dad9bd3724626a283c6e344c66e2b68fdea1b746a2da804ec44a09ca36145ac57768a8d22cf4e46b84e9707291e7da9590c85c19c56c5df1a3c6876d68c0416adaf680bf3cf98698834c436f7a49ee326b8ebd0129e9fba4c321ce52af197641f285999637900c2aee6f532b04b61a410374ff1aa191d5187a74d1568a3fc41c6906e36b1b0684520489d9377c3868ed23540c79cb5af80d50177b55c6f584a792b190bd26267c4173536e88d9ab48038aa247cf1d45b2b0bc270f98d69807d5e916b6619b0e2210d7bceb4d880a21e73a027b9bb9d15ed78692f689571b08821558fe221fce1c7fa25252358cd4d7258d6f33783939528f524c10dede0b2adbc63517fd00a06b0f4dd2f0fc96407f291d00af31ce9033e81a87608f9272ffec16e6f4fe17ddce2ab85c91462a28f3f7c5379f65e22113ac1c0e1fc4ae0c4bac0163d41be01ebdca2f6bfc84076b34231d747f54d37f0a6a068ec0531abdc55d84e21b7159a070d9422273e57a70698da54500ca178ffdfd6da4f332225afa680de3798616ebf5d6c5d5ba40853dc8ba20daa4ddcd1107bb89fb48b14fbe2a2f5f8c09b0ba04e54b637c7a7dad1ae588f136eeb5d495460a2d702bb60e6994a63c79767c614319b85c9af439df8741354e9f70e9cf4c21b072306b1d6d510bdda286b905efc5ebeb94273fe9c7b3fd45c6ffc0a50a55ece058c0d41e3ebc477ae57c3b59acf137f007eb6978cfe23a1d52d723670af63d3798f3a8f705e57d6084e4b1853096536aeab4ff9e440a27158deed20f895482d84e2a52e114a5767301dc9efe4fa3abbed321dc8431b1e0bd022ea89fbbdaf49a2aa3c6a44977b37d32b5fde6a429d32d412eb9233b25cd86cb0070c799fbd38d93cd17d815b592041c20e4c0b97e58950f8f973a2a3627b4ac0fbec00fb5d0453d124e3dcb77c18d71bc04288be5d1e591c4a3a5447dce17cc93454d7031a1ecf76dba7a5a8509f2297320753e98a4f5c6f11f58a34d90c64fd56a941b4ba42a68c2673f95c46a80370e4ceb349b71322459a28446dcb7ddfffbb0d0473dd89de2ac12fbafd1066d715282d4f166847ab46f5725a2f8c46b3f25e159555c5b559d8f1345c2eaa877846f71d4f6d99c1768ac2c38166790c2d54daf4d92162082c3d052260fa1e267aa16b85d634c8f21c99846a808e483ef8c10a13dea59ccea0f34e1f3dcbd874496ff171a4b05da04785c4aa09bbcb16efe1393f3f1c3fc8035424f4052788f77a9e938e88c53da04bc8cf9cca5b122283c0353461bc3af7fb34bd13891000c5e8440ed1ec38147bf0e4c214148bea601d4c4eb9204b97e5e02873d038d576e45494c95d65448a97dc75326c48c4c4d368016fb79b78c59e11b4f0b9a0589adeee94d4710bf785a488c07e60407d870ccc3fb4a3d09930a5da11820ccf2ad93d37de6113a700348d60ec18fb3a6dbbac59ff5228e2a8d840b242094c65e098e83f56aafe7f0a44417ea71223db6150e4f17ce3074eeee5c586095ec539bf866a0e6eaced980d74278373c7519643492d81fbda4bd97ac3fb91bce053f3bf9b1814dbc94b7bacee3c8d6e73ca8133ac423eea9b1cc8df6a6c33ddff9d424d3dd68eb9408b33c99bcd0ecb546cb85b7c891e35ee1f111c44c273897ce22544f8548f20065300e76af7db322bd563c16d4698ce6c57f369f898baa2b2a8b061a72486cb821f1d4e61545f43475965d24e78691fdc16b4cf1f582311934317ca8ba978ff68c8765aa9416c9682cd7fe58765626eb8bae4abcd896ad823286c19b7308023260935a37603bf5622c33ba1dd7fea204024a51baaf3c0ff4511d9c93f754c754f7176681aef38b35e4409ad0d49fac05c4a8232569813e4f0ed5c9aabe57ecf1b5ab8f709050ab7e3bc347199019ddd14a5ec3ac5efb929cbfa81bc1ff085b62310b4ad79fa9bb373cf86c255a8c1c06c54a24614aea57a3cdc29d4ae8e91d953d705ff6ad7d5010b19673d54969be34bb3d0f6e66c2f82cb9a2d853f46f7c7e03adc533ee2099c79fca1ddd9b92f62674d45f946e802b5701f25057e243b1d55447a9b53d71c288f0b5a3f7c63df2f633b5d891e52de57786032a0b77b09524fd7381b6cbf4ad4159694a82631b327e9fd3cc01b9a7cc0c581785cdb7db6277706a3ae840540dc03d157a1a78af9d8c87c72f807c27d6ceeae81983f02aa7c7209097e031363c7026e85ba78ee7a9bb3113a928428f347c60564fc387d83fae5bc9e163cae1beea70b504c99cafb7bf1ab0bb5942895a9f3015fb11715097a1fea4672cc4d587f83fa81315b1490b1703fd057cc27a784329eb9bdde111ef03c0db088d1ed81d27f28a458c777ad10a4ffbcb76b11c114fec6341fe193187e7fca623de919d93bdccfa2dc0aea686706451f5c44b4f2ccaa8e4ea39a5cd12eee8a08803aa3ebd4be4ed4c486c42acc8b774fed707cbc8bbc76569a6c2b37f17174afbe0dccf5ced0493f6eb0deecbb9e20118c478e7a4c8e19be93a247a9316124b5f2812b5106c64651ef5ddbe7097cb293cbf0b18ab45656f09b97fbb1b18ca8023a8a857abd9d391f511e9e0363c1dc00138094e459d0b49c1fb6a7e67d398c8131feb6b53d852667c52a4f581cf8acd24e69e7b98fb87092aa746eb017cdcec8f37722e5c0a9540d030a1f76facde1b362eb724c83222123f0e9e1bc31eeb7215e57e10ec65aabf174189119c1480b2c5fd36ab369d296551b9922654dfb410350cfbcb7671bbbb23200a6d33b784ddc0f1c21a8f4a7cc05ab502939d9638cae72db4045a093b3f27d0485b0b5caeb39a478cef5eb28f5b3a3ecf935803f4e8b6e7eddeaad08b3910aa9a70e82073deaa512fafccc62bf68b8127f9d69dd7e391376863c8f99387638e8f6d2a048c6dd096d1553289471da893d5d10cc55100116c0270dde5576f0729a7d6b42b270ddee90fd55842c56c74e8b5ad8de0235edb8d4e70fe08c577700cfed8bfa97866a23c13b6292bec672a0e433e5b6cd1da8aa44caeb9be9c54539d2a1ee8a037ea13d97ccad679a8d759ebff7449d150b991e31c599a342e62505618002a5c6ace4830418447f5f9251fad7af077bd81a8157ab92632edc0152586d60a1d77bb1f0079ab8828d253093565fad5d8b6d2e8167cc4ac923a75311088c0d02f7d7d16628659a083690606eaefb55a1e8ae0c20723e07b6cb0e27c5f7cd451c690d768d6a9eb6e85a5a512d07f369bc4fa5ac2ca56b7b892f87e872dd669e61140d644082034be9f20f1031b0752fb7de178e5db7d771d8eb2d3df273c21f368b32f946dac4a48e27b4d1a58d332235b9e79e47f2da6bcfaa2822091c00c40072a6b698ede29f491cf0860df2cee243f9afc47063a2c94ee1fc5f1c95315aeefab7900e85b1515d485747572bf9c7a7e94d5602ab51bbfe7f425ab4bd18ea9a6722cbef5a7e878d1f3058eb46e5d9c7d7f76012fafe7a831ce607b2a313808312e3cbc225d692abee223469d3d94199dfe20e63475a8ec14677d909464d67e582a50855df7ca93fb896249792cadcedadc13985ff1cf856f1e96259f607b4c607fa07b338a5c9c06e87d89a176fb3adce9367cb94fde017f633b9daf1ae95b136cadeb8645fc85df3578ec072f824d4f5140c6a651440366890fd74a8f759c6694b6fd4d2921c24a919500393cc2eabbcc14ef688e27c30abecc592943d39ede5d3bd00627b68c9469aa59a2201ffc76437808486d2c577cbd790fcc6ea8e18f82af572ddeabb9dcace9c40673ec125ac25f3d9b2def2eb4df95fee674c894abf4227103dd1f4b34efc7641dfce2cd9768e8e198cf16fd5a2cbe78db8b279f38086bdf7b6e174cd2421789e994026dd11fcc1c6005fe717e2a20b0d536fcd4a6027abbe590c45903e19eff2d91454460ac75c66243816f1ca9159a00299171f7db398287aed3e8fb82b93f4c3b913ccf213fcd34d022bf8c811251610a12a3ce7b9548bd948e5229e68c3a0bad2196dc3b5da4de92ffde72265430f0ccb75074d4c76a1e40a1f061fc58a8f73047cc377ec76cd9230c28742f1a841afd7fea9e97986157f2a14324e861a5ac58571ae5f1e1d230644cb7775a609686778030f6a7f88e608f15ff5a9511683593a0dbd75f72705c955cd3e9b113df1f033af294cd4f71a9d6610f41ff78a9620d4055aabc7c80caad1b93ddde0412b1b25a7c876b6e09e446aaadd2a91e013e0f60aceb550b5649708175abe5f4ff40f57ed4246f0972e0c7dcd533e98c665398efbce0d33bf873ceac7e1697f1659e902e24568a8ab140e85bdab53e455e5615e2dc0a39b87580af5dfa697ad8897c13277a49175af52263aa7278df48e4f5a6f8951e4c551b9acf7c6b303833941b2a8246f236cc086c9aafec4be3af69004f2839c344f7dfb0eb26426f877a801c6d69344c227e616899dc3474c412226308039bf6bb9d1a918f85f0fe43020c45d5c57c9af01b9f6b58df2b08797a16fee14324d71e286a79086b005116205031bb58d3dd7612e5bdf1afd0509259aac3bc67bce169c16bc02a1e540ebe89d92e2a8275b9df3aa315a10a5c42a0b0ef9eeb6a232fa60a91aa4f56ecc64154007024d2db2bed036259fe83674053d2dfc228d9c81a276ba5e0ecd4875d181d9538e8b544376cde2a934bd9d8ace7d57a1f9832cd371b0b52162d6d5d2184f8f0f8cad7ff6cb7019657370fbdc7c4aa64646e9e2b789d8c1388de87638a0080e0316c0f6f8cd74b5b5b3935851a59a5de04c4d3bd09971012f608dea6ee309938a96cfb59f7a8fec678ab570a325734b39edc3ac7bf2b53f31c4185671403e24c49c7b69c20f8194b1d49665f39e2859888ac29d9831400a50cec162fe9017f6d5f8c6395135f4bc61799c34c011e45bf2a5206db217ad7120bc29c982a4ea82fa015f827bc4d415e6f23b87f24571bad90f90d712b3bdeb6f52516f1b260de0233311d441a9c126d6377ebd97f4d95f60e25804ce67b3bd0063925652bcd0a537249f63fdf43495d6806a1a035b4ef4894ae33587478f3515fff3eadea21b6549e5f9f332e36187b7ee8605de80187016c679e7a139f14f20cf45eb454e5c10d8e138c250eaa02705be4d10fd618f7717c49b3816aa2018926cee8762bff759c4c3b6ef2f09185f92e795821ef7e74deffe75107087b15b4dec599ddea61216567418a99d3d3f87c9ab0afcfa5cee8bca740148deb172c92f5b08301cb8822f17460021cbe49e919457a2c8572c35656233f01afc891f4abf1bd1e70404b72e3386d2b1abd1b4fef35c01bf8454f72d5af6283ce425e81c019b8dbd97f5d34e07794ec1e303a10edbe863713e88e625bdf665d7c701c690b90ca70109e26bd8d48791d74cb1ca0e9cfbdcfcea50d63d0e8322f407f06441abf2ac8ccccf7c7b7a2ae984d9c87b99ea147e500d78fd513accaabebb1ead16d4eab29b5393a21fee8bdf56640ca7c9dff86fc8472d1d30f00d6378735342da1c1b4218e230a1052e20c5abaaae1a52d5181dd2811056c03bac6e9b33916e905efdd538cce9fbc904508882510bbaf5e5f10beb2dbdf901fd66e99629187db3aae18e1b456d5237681dde8ae3b3f6f82e72aa64411d2f7838cf4897780885226a6e4db7ea947488b05f87c0016eae98f77e136516967cd691fe7b353d65a9822977ab1c92309e2ec96f68797ec646fe4be407d858f384a1fc1e7088d256e7c14dfc556497b40d0c0bf4d65d6f94ff98c86a14d47dd84f3356519d2c771f289cd5068a588fff297a0459f8cc7815de4a497f36d63812961570b76c593ab26c8e13faa6ef4f832654e32a01f87b24f192f9b3d23ea568b9ede5560a7747ac7483af7d8caa844debec663106fa6098021d8fa5acb2e68a86c8469ac6c22e27ffca934d88ab865ec8fc4052ecce8045973ca5f573ea0cc11358e2404edcb5651fd760480a212237411e37fe13ba08bd688f928e8788acde6a6c517488409ded73d33eadc0ae03052309112d1b91879797500fbe64d5bfd5f5c5b0dd8504d3bb14e954c46d4efd7f8fb9f306b9bf2a6f00a162792a4a95bce3d8b81c77c25c77c18acb69992b1262a56f871995a5f14e323da19702a7767d3a8a9222f4525549f59157692af629fa5048b48e4ccadc3b951e2e8b6455649904cbdd198c3600d1c2bb4c0d9227dd722bb1ab44695afce15e92cc06c5c8e16358caa677f6035c5d3fe92c492a39606b1fe645f7eaf486d9a714951cfc19aaf9ca81c70c4863ee39e530b8165c1fcc6d89ae1a0585a2f35c8b82a0dfe02c9d275d98f71193405f28fb7f32ca6bebf89d632f5ec2d97841e795f979131f722b47685b3e0eafecf13bbde0e56fcf72747f41c6b2d9ee7f9330f297b864799913efa072930abe835aaeb680f9df6f6b4b2390a01fbf6ae468c4d9d68aab7cb1f99bacae7fbca47647deab088d1c5b3ee24ad568b1f19610ce3b28869f0b3dd93c7ad50efbf6cb2002aef125e67df2667051eebb51a9f4e9c4b0f573be7f582055daab88834bd68dc59004cb1e2185e11a1767dc36af2295412443c56084cf022f9ea7d64825d591a58e5496063fbe9ef25c350c3af721a0e8956702670c34d619119fda1b70912a8d0fbadab6ced9df8a6d832a0fa2976d79304657c8363d0e64ae11bdae8411e331efa8169bdd8496fc599ac5bb94e040d986b0f0c7889ea8fc4d9f484f430ccb81a92177f302c6bf68ac4ccd2d3aed1d0c7e6970fdf0b0142dd36633cfc1ce904ad8e43d99926639e6733ed8c2efd0afa1d6e701aaac04e8bf9b4f7f148cc871a2eb8b0d3ba70a2d2c632f4c1dc4ae1cdbd1c490d3abdc3395b51cdd75832bbf6ba9523d2c33f39798855f4971f0082227b35111cda8644cba2eedb9e94812d96f183f9dd37279bf1bbda995f7331c5a824b9ec8eb0b4aa57ef638e587906cbc099d0fca1aacec348d482e7a903cc1c7781a29d2b768a60a4f0d70c6769e85f043dfec7494bf8fe5be2a5273382c116a67e9a7cf9015baa7e8a9cd8a2e3d60e2f34ae7d629ed6d955f7d357576003c5301d9fde3ef7580ffd173bbdfc5099fca5bb3ff13670898ee43b7d7972dd881dc40ad77fdfa917733238e462b8367ace1d8cf5ad44af7582527f07ae2989b9805ec32b69e5b428c005d9a2a1c5012ca2b011f1abcf7d82f61c779fd1d42adc8cb17a5209db12bc266ead98bf41fde6c35363a6517544b63142cb2f38102df2103474b17c6f301662b468459e2e8b662bdf7cf1e01d6430b59216b82b9be7e5ac0949fb65456348f7c81d834ef4b7de00b622d24329febf24ec95311cd34988c3fccc65e2c07a2dadfedfdbcd325ff925485c50a25d133b86fb0fde9f7dcd7e525a32ac0e2f00d9fede86c568c13e943548fbaa31382f50e673095a7174f0237e3a8f30a7f93fc236fb6e2b5779b52e417f537bb6332687e0020222eb72cbbadc5b6e949295f92583f094a784244e905468ce26815d68cbecb44bdc8a2072e68a8e2afc48b41c03c9a5dc17f27db960424366a555ff50c976f0ecd1e9df119dbbe1b24bdbfcb757fe49a9649803f24fadbd0bcc69f9fa42b6c9e7845d08fdeb28b2bf41c004f0eb9303a8bcd6d42b52b55e5d3d667136c3bb99b92af865c5595e1b7c2d8a100936624b90beb777682ef79d9fa26552956ef9b66d3ac299951aa00bc996015c0b9624d39e5748f451863d0c68e892ded01db22c7072c2ac84394b0f3f6c1b6a2182a4ee0f70a9005be62af0f60a6de53a28c8d5fd26378f86f6e5bbfc594143eedc9cf4f37f0cae41145957c62581451d4823d2afc814ef104da6d161eec4d63b45dfe40cbc069411e394666c07f93fd2ef1a1ba45e2123590de7c4e48d4e638ed786ac1e98fa6b6f830a3b0847852295fa3c6ed2e26b3b16c8e5cbaab047dbd8e97cf1346c94a24c2e5f29841a0bb96eff0361c769eb979efa7b8ca32e5c9519e6a7511a4a87849da541668cd80ca1c461d41fde85a66bdecbadd4d63ab8103e02901e69dbb01097df08007b63507f8d5c1422847912dcdb1a7ebd401193e7b2786826a759035ec646516faa9d880395725b61189ceb68240651ab088e48ee856ffabc895bab9954a17ff21c592c02e2425d445245f9f267f35bdfaf8c7269352fb40877634bad541f4975926330910ffa01dbf3aacd5f6bad90dba3bf1088f8dc58eafdb5e1c983c85bf070bf4c0b037386887f35d7c7a66815278371d9c8e73d9e7c03cf9e5c4ad9cc0678f933f6bc78de886eea0696602c8bea94c6d2a64bf760c2dcd0759eb8d5f2738e6b4ad79935b4386224d96e1f32ce0d598be724e8f8b66c867369b3f030c4b1f64c3556975f002491affd6a7614cddee8e950b649a33fa825955cd9392d2678eb907c474a84b0d160f40634c8a3c337edd206ec60e411aa1f215131ce58a2242c752ea3de83a1082cbac1848c9636d1cc0cab9192a3eab00d8d3e0990d041873a033ac8b157ddd5db892d6fd53f0e6b697cc1df67ad0b832753fb946696a87f0eea8377d86289e73fc115574f27565d6e90c21f014ba1df219c7cec5591c46038c84e11e7eeeba034a2618b78fc17f987e50e711ddf3c4ce8e0eb6943f35d1c75465ce0d518aea29f530e6a0004a5da726a21dd748f03d74a3e92c6d7bea23ca24d5546e9e050f17b00a0b2ab75c994721674afb8b8e1be36f8c06eff1845eb3cdfcc0a79e4a792c81d4220e3c8829929a23158bd63b852032d72978d319daa70bd8493ce984c4fdc2f5c2bae9adcfb9c3e178d66d62c6252228b7d318ae073cfa70c3ec0ccbc0317f98785cd2f425139dfe4db0d5ce11c84948d1f1a03b127524cb04783cef43aa0089fe43f8316c123dab7d54d9694a318d9bdc1a163a5a176a2cd7e3bf2e5d98b6757c795250dec72622161b4ba71f47d354bda6b86ed152bd6dd2c95565e42ae98144ad41d65e4b43a088af34d6f0813c0776152e9b1759053bd89bccd1439963b2d58b115a0ce6a8278e58106ab950eb0f8bbc2ee3e77ca56e390f3d2959454090a1622d657246a6f8a568f4ef284b00b8a796ff0e0c83245c4518d2e21184c350ae3826c26adc8a0c820516c57c13409b50c100db692d65a4d2e7a1d17331d9bb46f5d58d606aa949d76292bb031478556931d73750e38cbb5c842de7c5af9905fe994c1340a87c60b34f062cae258c4dfb3860711d7f6d46b792e9ed9b1960d024743a62f9fb5780cb55bdbf4ec0431b8a41954b1db08bd4e217a4f260302ede6d22b6cbd7d6cd250cd0bda8cc44e886c9b26b188e08ca4e9f0d933ac11879557d0fa683cf266ecea8a538b18e2b89832f1332eb8e84a126bb22248ac4259aeb4d799cd262cbfaee43c61d5180c40d435a0d8ecf00a9cdc8e41f51fb60a55b28c1b6710fc4d838400d0de4174e9da15d483f1336996308c1f073510caacfe2f38f11af1216df93143fdb4b1bdc909f4453f41c225da7ceee0c6b18e0610677d14e8227ae21712cf3a0235195bf2d98bbeb158633a8629fa2b71552d74501a8ee10859802a050ece32b9e7057863a50761e8f9bae1312634c896d2fb016f948d6b7fd19d1b17a2a2ad271d7d6c70e7d813cde57861e167a06778be1af15f81ca7e5e17b8c5a89d71f8e261e1ff54c264c8f9945c6ff0212458047002a1fbecff08e6f6579395cddc56ea0e4280c8f0ce7a32acb93446081e767268ed3a539528cbc00d4e8c673f708345ff9d24b3d9e7aed86f68d52a1b1cdcd7b0e88abc83686849a9eca5b4efe69db726011fab6fcd500c11f46f58320e7e07036565842b6a99a409a95b65db51ac0d079cc747960684d1ae87c9538ad76db582b4c0eccf0d305c00504290f0b051b72f2cf86bb471c9e8db43a6c95c0f8c1fba1acd3fd137e5d50334b2e402a0311df92ec66ca88ce274d3465e648b0ce752b4c959777f347632dd240429351300e40b9d3c6e38639cf687822f9b4042624713e50c5cb4c1c590a5d22c5495a251f6f560b6fa3658a653a91962edac5a4406c7b4a9b89585efd4b3279d9330dc40748c125e4dd8a6672876c90ed204503be52c07c356a4ff20a935e9579cea098e356e7eb30012dae24f9532c94f51c5eaafb3d0cb3708b0707ecd3f000834ddbf7df81c8113960c5d1e751648c9c14fe24c113fa839ff9faf89c865adb0a898d47e097fe9d7c8560372ac7ebd39c743e4dde38f5808a297b0a2647993c1869872680cb6618b7af040eaba2c633b25280a27160feb2e42cd37cb1e2c053e73ce5e665b855c60fc34e9f537382f343610d0bf23d9086ae9590c87b632bfb89566845892de71e26b4a7afd8ef85eb98a6cc928d98bce278b893275fe9a2a8da8695a1b2a4e5e5284eaca66a0eb364afa099be5a17f02000f661ec43606266ccd3dd3999af44c9901f69757ca897bfc6963237560f05cedc9cff204cd015f9ac12d594ad297b18973c8c07bbc84a27a62a240db5d48b3a2b8d8abb03712e79f6c60f5e62bd6774a8e4d54125d5595e8a29386000b91ece1dc6596a4858299ce5b0369a0c7fdc126473c61e475d29aa3d85c929c93a80c335f22ce46ad9d6e2e01ac35b6efb216a1f5081f813c255e2680b3ac70e4c1e6c32f1a22e3058df7bd08fc465ab5dd3442453cc28b2791eb4e34408960c488281bd75c4380478d331da71caf45b9f25572521a777710096022ce03857b616c1d15abee6acf2783542cee8ff9b98d92ca6f20fd91a99ff73375f7728c79e5bb58cb3bcd3079d058f97fe67e1fc73779ef619ef07945bdddee48536b7828ffef72c23af4f622588289fbb7ca78a9ecac1b6ded6244d3666274b402659f1c68a6000da8061137941169d488335719a58f6c1edaf26fb07d7c66abfa34bd5203658c3e5b3f6e158f683ec6cc0e0f750cb8d74d5503cbdadf19195d59269fdc13f06e4bed22e5d715a63f7365323ce91e8b6a40e2c16c407a8547ee3f888f8844cdb3efa90617c50fac3c257ced8339ad3a69e033022a9519db07644b27b060b16daf133ab9b9261810962f4d13efae806565d41222b87383cfab86fcadb68f8696a798c121d2f9d36a13d250b71045bd83fa550f7cd1387a90f6908060e520ac96c4af87fad0aa26ecece8096b8ea02478a4cf35a54fdda8fdbe1c1983270aff51de579043b14f40a964308ea62beeea2d05201b19364fc799166cf553e44002b6e019d3376a213a864fcd229c8b2c4fe1d1f0902027d5206cf1696f454a43fea82a1f899f8c58bb9fc9910567c85e892aca7ce934570964da435ab2802f8c166c9d307a808e72094912788ebbaaca1a7002fa7d1ca6ddc516a3a04e7d7bf2ca3a498118cd35369fee888c5bfaf0a29f5b039fc131d4a7f4059d31ab7e350614ee8eca44eac95f0fd22bcfb81c6847e1df725ccf66442133e1273581f45d76cb9c4e2e0d4468a2bf53c80c2e76157d960bca2d91ecdd6b60709f5f63def891741aa1b4c00b49f4f97f816e23f68eddd7527bea973c6e869665e2020acfd475bf64f013371593144b31399799d73871245eb37d0ee701b7bcc60ab0d970a83129ac1a51b93165f43e383059ff7104da4af839e3a49d91423c0c679ba6392e53a247c5fd8e4879a1d96dd962f4cbb4808a30756c06cdf8f308758c279d886877bdab4557a6e7128c9bba52212597670ff0d82c1e2c2412a97202e05d5bca2b7eff16231c7bc4977d6d1ccc912327ce53635b71420ba7d3f92b6682152e4a18abc6e2230df0fb3d1075790e1b29c2d0c6110906afd08bcae60b6b6f2ce04c4ff15aadbf528ac7a1a26bd471008a1c860062eaf8d4d7a91d4620bd584797aed4a3c6e8b359ad38ff9029096190bd0a20ef4487e0ba671182f66d9ba5438c4c70dc4113f949fa7060a7c13ebadb86934c4739754b11e8f910f2b29b8478975de4b9b8674ddd1c2f5428029d7b0ff63056267efe8df3c2f217c1145066ffc9cd29a622678b77d89de251e7193b56c9395b2294ded723c05ce5d4e56e9893acd3c18526275123d6f44ba1b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
