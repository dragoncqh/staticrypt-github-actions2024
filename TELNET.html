<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"631e497778a2cb6adb3edc446bf45c39c9e40bdf8d1964d7e6889759071b2d34909b5c86fdefaf1c9d9ea6dbf758b58aa3ce958ac51272ec43d827b5a72023f990bc4bea2eae1cce8f3212cd767f7e52eaf964b48df597407990e7e60bd0f60343e8ff060d6d52c898baacf149d890c2fa681dbde862cf48c8188793641ec600ce91a08b805dca61f95d1de0a6e059a8327b3249b003767833eb3b7c7ea6be292eec1f543cc298300b2c8ab727c4a99dccb2879d50894c38e476cf398a849653b9a69b038fe4e4a0e35f28fa46ab9c73186f553a5d61bc221548290c9a609293df7b9595d2c79f483f4c3b3cc5cd6431f18a85f4a292f42e018af2e51ae59f5f83b2eb03e925d60f41bda1640fc924d93250d546983d3e143c1af65aa5ed6504b4cb8e9c8f262a82b8588ea0bbe6c098303edaf58f0b39c0f9a3d1e9a42ee6d1df48cd791211bc184219fd59e2028e228a061b919d48ab7370f4bbbe42e3fe59d758a15465d1c41fb1ad5520909a46c7b98ac118a57e84caab23ab05c9ab2851b57dbec549b1ae1e736dd08159e2b24fc02cc53b94546587a3ceade10ed5850a59c70fee58394d660a084742f95b80eafc97f1e32586017fb7df5747dd8eb7b2c8feefe2f12ca07abbec676fb1a1fac13cfa8bf113913068066e6f8a8ca38556f4fe83e7be0bc2d2979705303bc9c27b2fec3461d0f639c25dd6e1849c08987cf0b4b12d3014fc437f44de2c8fb67cf523c383b1a4c115058cf00b0848032215d67197e95e329edadbdecd8cf320b757baae3abb24080925b00e919a6965555b6f8f3ad8b66d12b4d13d018aca3d4a15a17be2e6247daf30ecae01e86d050b579ced3206d12540cbfb894f8d0d89f2db1f6fde415e2f5c140ed810bf851033c88d9fa7096ee89487a6f6bb539b0c76dcd47b0dabc4b6217899404cadd5664c27c58a1ff75c79ed3aae52ed3dbdf01f1856c19dd5609995b0ea06b9a755b1b27e47d8e5adc422fec22b47fe3decfb32b932d9f9f8a6949137cbb34aa93eb39b23a69528d452baa42b8a0f22b916c5943c2cb17b1a0891d452387ded97a904d7fa4810721defdeca4fc788d2c5245018384a4820fbd8225ac7de3c07a38af55f29aaa45ecd50a3feff2c74c9a6d9faca74339eec208ac4547b095741f3fb5053b4468130aebfa93fe23d64b60dd4b27b45f3ce3bd374f3474573ea368dddacd3d3b111599e848bd40226b6245dfa8d870e3ce1abaf08f7b0e21acc8f66a7132d46c07c16ce728bd5b43fbd0b92bcda6b5ee28833ed8eb9fad985c71f2f08ccc085c4494a920c7094388b1496e726e4255330514a4ddb1b61dfa4568c7cddffdd68782fd684f0638eb2083cfe0367fe2b32999b1ac7d65f4f592359209b06d94f6cc0458af62c39abeded5e738d84d41b8c06b6f5d5a0a47bf47ef69ec32a8bbccd632fbfe4f179bdf8a8eebecac24163390ccb3a5e7c5efa2eea2b7634ae369aaf7c8f3da006e713d8380d34b76566cb586712448a617d014777fdd499d23b7347aadce9d450fbb0e2dba40624e13e38029c4f23228d98f6ab844bde5208d26c55319ba39fd25d1dbd601e61fce832bc57dc1bb39470c0ad71a3d424d652ecc78290a77e728c4c6f9c95814a76ff44bcfc07b5b6dc200c8fe7351296482c6e936a7ccd64c49bfd6e162c8a71aa6d87a46e2aae38c4ccddc2656d5813e42bd0ac555c5eaffea50d101e88c5df991a089b82dcf2e8c4ee6cf2cf95886f85e007ba4f0aac6031dc50b3fb19d724bf00a7c518575c3041747e3b2e5595aa8a915d27fa96b39b5bbd0a70453261276372ab071f1bba4a5082c90698186a66f48ed4e15c11ad6c561dbaa1262cb7e5ae660899b35d0058a6a8b4ee481425711ed36717330d6e9122b6d1338312d0e74309bcc84b0bd7f161a012bd3a17d0625f28c30eb1dc56d4cab12cbdd8142742ee8639f5b97cef271efd422391af261628a9bffa58ff8b146178a51a75b1a9932e31b4b6fbc681b7bb25acbc018a75fb58c8845a7282ee4dbdcd712061ae24a80b09bdccfa26182e578bc927c50b729b3902f14a8c5c7b1d943b139cb610daf55ccd4aee5b640ab4a3e0d535928f4e3d4de8031078f1a6d064ab6fe2c3543e3aa057014e3aeb1553bae93832a17855c1d9c8535e61dd5fe6a332842579083f5859b9b6dc1de8b9c86d62ceda7875320145452100c08c4e96384ceac03e977816b20f78aa9eb9f5c462f201f955ddf964835551a10c8f898a25810f552b8ea3ed2f1aed6cab7e4a25a348b3bc862462f50106ad1dd4887401280d090fa851112ed45be5e3354ff6d5bca90bf6a07e556a1be86181f0d5908b2c9f904fba9b06da49d0df51b9c0255f277e4087df9c7d30ea9369f034186c1f658f832a57935d872770ec872b6faee2eff49e2dd5c484682ca65b020dd35662e19da7724ee70e34b6b5dd8f1139c44dde6ab5f1659f9dd61caa35be289e273c6855503a33e422d2d54980856ef2323a5783b65f6ddf02738948ac953520d62b44a7a2a11dde6c6ca80a24c7368ac64bc500770654aab6aeb9d2498052d23c0773b22d06d2f4d38eff61d3994e26472c2ded4180524b709a17533eec637f2e4d025a70337a570641e0b363964df52683559ab5959b2bca1649add00a860c398ba8e675d397286fdadeb6acc0d2faa60b0965a2db85193c800d16f3b750511eb0aefe0275f4dad787e406742b7935951c6f8353cbe55465853dd26eea130b5ba72a9df4c6b12489a079d762d60dff5de79f1133f7090cf4e061df3cf1521b8362fd6baf0f3abac01ac7f206c44194bd4821287e2a7a1e833a87fde33d1f256496d89382f7f706ecd674366c0914054486fb00192397f0c189ebc34966d8d40ce127cc80b9314c08eb5bc25f55d5d8af53db79bbb7652ffd0ab87d322c295d89575a2cd90cdb548349ca5dd468278729dbb2dff76a1a21b92345237031e2bfa63757627b78ac68aea0334baf5d4ae6b3409af8581a8fbcd448c2c4588e36c99c915d11a6d8bbce6c97b53716e7add3226c070d9f218e0dcd0dcaf76627aa13f8317305b9988f27b3c887ba8668067076b6c0e320b663274666c6375f9a0fff3bdbc7bdada095c137dd750cb677e6f1f1b0a72797f2f5362ac48d097072c10fb571bde4721839178b55dd1d65fa7aa21c1fa3e128ade92ab2bb00093a7dbde5aa3a054db98d316d10383c1aa2529762032824723febaa085ec4fad86590865cd3dfe70f151a9b881f00923360942de8a4422f35b01070ad552cc0ceda796cb78993a53b9c0382fb788882d7570a58204b20f1fca95ce12f6725f7062ea2bed5522cdd1d4f07a7e78b262e00b0cf9d316107bc96e2b4fe78965487200aa5b4cc45a4b77f3729114f259f87f5a3f08a0e36f8ed22396e002e044eaf97b7557908cae36fae1b614e8465161e33187cfc93632ef6fefe1a066ea3819b762d07093edd6508d61a0becbbe6fb7b2356c52b09adc4bf02a93684d0ecbe05b4045d84d44e93a6735eed6a3eeeb637938f1fc131ceee471a066e5b88b404efbfff35c72a456679992f1b32b2f7954ded551b105693c8a85c9d002b7f1e2e7135afbec54f94930b31d92b21d17b43d1679e14b72ec3d9d2e6f49ef88723bb5fc8f980b6bb253df82be7dcd301f1f328d72d4d0edd35f2a4207fe994115d8ce4561bc532f6db613cac3793076cc22c2f0ee16b5f8c6e48903044e14c4b5ea2def1a01a37f4cdd4294c3bb0c215d702b71155961340e6536086dc8744967b69052c838d602f522178a955d288455e522cc5f12cd0cba67082064c937ba5a484f4c8df4643795fac0acd817f9a31b16e36ab3a1979222e2f2dcaf7cca2426c506aa3e1a6d589650d71ad1252bf90fe8ab2fe4c8f0b87f3067ebdf06eae4396a8889096a7c7e3115d02e63fcf19604f0628f63c33c867a1e7a7f9fc3fb40c5eb6ede63b4b7ab40d4060adfa40b597d4199f9ec358451c1688a6b71b57d66fcb60cba7e1910afa392586fa8e9adf5bd7ff21c0365e04f4c71379cd9b142356ef9b1ebefe4add8a7b39b4a21c2c5d55e319a4e19071cffbace588f5e32ac81de357177d65220d4694d371d24ff4ed4f1230524cb6a045546131385eb9842c3d37ca25f63ad59e1c7e622f7aafd74529cb4bd9a82ae3adbe5a9f1d1704f04d2d2214ca4f667985fbb886f9d9d8ca44c716901fca2f25568856c7381d1dfbf389cd1018b1ad815bd82041702d5e9733197e51d13da583ab13af78007cb5c36010a77dd23ef25b4f92135172863952f3ed988fd60ea2621d839d479b898759c365897d9983331a03777c00386fe1b79c8aefa0efcb3e70c15b62d4a1b275704fdd88fb7e060b61ecf44301c71be69bb9bae1602d68d35df40308792e33616e0b3b7f034384bffb8c1ec815eb9b14d7189b75fa8fe989958080c55462e7dc465b7aa67d35ca29da7403afb488fb51af27763bc5c68c43e16b1db56b4f7db1e579e1c3780c28fc287067ef67d93dc9ff229d5b23a28fe92d233d65e8afec76545509c94db2071885096585872561b44e685d521e2540fd6749e5c29480fd57fe6966c9f3e2b46e83c7d01049805bfe4128ca4c41de8a049a648429edb9c1a5a4b5addae3f7d0d87efb626e7110716c42656cc9c9c9e28472405284668f6cbb138f6a48847f7c91943d377a52c411061b59a9c9d37a8c3f38cb91d0f9e753b26224447978381ae5e0e8aa57bf6b2f1233670623cc64cc9d803bbd97145e01e9da81a03ae933e200da4e0af9b87bcc835e152b3ac2e2fdccab93fb6cb3ad84a9b60e4ff3513c524f16ef92b5063aefa42f0cb9d1eddcb1f2697d30fb82d37c9c7fcab1b59d61a70c55ff8db556db3550c3b6600a3ad57a7bfe3d8fde9eec30305a91c969d5ff43e1bd1c5d611af2c02d87154dd76525ce29679ae685e19edbdcb529a2309e4787107b0dc848f7ec49ee8507d814fc23cf337428011e9422794830e20c1c1505b5789813d4f6363c37f0e50bd8601176e60370ec451871e4ee3091da00ff517587d8f983a7dd39e90ebfc369b7dc6fd0f9f818791aabff58e3ce774b8b757d86fa6486be87a435e344937c25849b6da9be57d39d0900dc359b5a6fb19427a51c50db34f78583b971945fa6e1425d14325e2930be639bc1ed888d115501f08712055bedb96152b8fe38dcbab494d6c74414951a6f88f4d36a1ddd98e27a130d87785767bba1e4572fbaa0164b22c60eab0f2b1eb40fef6015b606a0ed9765990fa6ddaff051862e901ea877b3ebd840b63c5bcf8e4a0341defdbfb304f22ad85095cb4e6d7787f3a9826dee4f69ade5506ee92bde23cd79e4bb3f72c2889a35aaef34a0c5b3139130b6ac959c434c4204c9ab86d52be7c8020dfae5473440d6a05f367363ee8aa6b7ddc49077b5ae3a09f893f413e5e189dbb2ed147afd764b84d356bd21811af76c73a59a9c394ca7f9f37431cafa8f2596480fcb665c40090b4f80d51c3d9df298b25705761a0e45a8d1f76229281794c078e895ec81a3635d96803d4b201cadb7637af69cae56906d60da7df94ff704d8e89a5aa095f01e82be82a47a342eca0fbdab69684fcceeaaf476a57e06dc2be3e94cdfdf8b7c631885db56b018cd5772cbb4fdfec5ab8d8af461fa2792af25f4a1ae7ddecbdfbc36f0fdd6170b13fa484ec51be56d7b0c861c059370f3c6e05bbe1bae88da7e98ccfc05410d59267bd71c1bf7d5a02048091abf6ca20d12f3625377a6cc74e2b9678bb3c1683d4087f388259db5c46904ac5c273921a6212c1f61d7a376a548686f4714e1820f8d946b1cf13407f11bb393e471750a4a0429848b49f333c051c790228ad631a4c774a8a774327256fad7bd47ffc8f9383e23630ebaec53dece4a4908ece2e81111ac6de93a6c7977de3f64e278262b83aab9454a64485fdd9fbbde3ef730ea654b54262be21d51681d2e4eb3076c9374de9de4d1a5e0418eaa1a656cc6856900463dc22d7394984a5883d29c613a004a986772cdabf8ef417d5a1fd7f57d8ac30330c3dd566c915bc401a696af80dbd013abe4c955134ff84df6e163d9f226f7849123a2c8e27c017161eb07f1c27d34ef9f228b67ea8d1132ad582f88f93beddaa99f910a789976410ff4a5d25a6c8413b20bab5e238556812e069f774209807ff7577f273a81eeea28c1ff61c724124809141123f73e5c723269b091988ef2119da877d2dd28de8eb1fe5b49e74502f827377086c0718ae571f829b6919e112219e95e8b36c5290a0e0fa834de0487e48b7f1f92343e1740fe1e3fd026c6cfb525b5b7c836505f6e53c9e06900d8ec7dc6453175a53ff898e411bb64f2942767bf8629d4c1495575f9f27252e34803f0b21eb850f958052db9bb1615357dbb454b5004ba7bc792df0cbe46e0f1f22636f91d1dca717ce735d0829a6caf0c24d18208437edfda64da4654c4c2418f6b3b072b9e7dca68f92cfa3ce494cda56ddbdf0a008292f3e8361ac66b297301056e62465e4871a0af8000d0d362829611f15971a36cbd3b890a581736ce698356d6efde690afe31e4a7b3e7a4b12e8aff2840cbe3fde2a1188f76ffdcfa11706aaeec24d29f68dc5db3cba0b810c6d277e6bc9a72abfcce38ac8d84e02e7dfcef4f8a102dde087b4880ce7087204872d1bcc29b994a5f6d60878300ae43ebb64075fe2c6bef91bd5d56450c44e4c80c5eabbbb7cead88c93dd5ffd44eb8dd66937649fca05f02ab89419089262db8992ed41ac4ba322ef1b335e7579567e40c4f05dfb8b05a733bfd1afd5f961c0753fc443a052e557b024029269328256cab19f8647eb82fb371a7f048a0acddd201debb5ac6e12742cb2c71ad58d3a16d11d57ecb743750edf84efb47ed5462b73fdc0e51454ad095f637de0d1f689758aeb0403790af47c68078afce64c534f9cd7089c5c6935dbfb55a6e9584f998cad2df33f27d9255c54ff2ae7ba7921cb5ec126a129d82b42f3523304e3c711720d1c5a677fb2d5b5b5b974a484a72fa8b97c7750410b2061de0bf082c33a9b3db8c3e56dc2ee095eb5824faba66445d75254980b372597e520b4bf05249e30f1fc3fb09ae3dec4687b6cbd4fff1f6b3f496e177ef74a7cbe491a768d096ec449e7595dc470b5c42de0a82ad3eb4e7e91ad92901ec2616fcdc352497ae89630505eb1672c18e2adede22b23094d5e40e6413d3dff79a1d76715d8823e307e407eea547b6f351b53065fffad2ffed651b634392c0f8be750aaefd03a879fe148b15c7f6877a540fe7b9eb02df0059934c12d7396e3d02c08fe8167354aa546380f664396ec050f5be3ca0d90afb47462afcaccd850ba9fedd5d5796683c6b48ed3938ad777efd46ff910a25c53c8ff159c7a8ebcadf3e8b5791f49a2c4ec56930431da0d28e86be9e0609882302d9779ef67a03a28500950557f1275aa2f6d2538233aba2e6e53cf1e597a940efb4e4d4ffdb65cab26336f43c2f97ca1ef72e114aa7fac346f41586529123f67a7e8acdb7c39fa3803ed31e1996a53290684cdbf140ae19240da65f7e89c27978b4284f2bbbbe499d78607bf381cff09d98280c4685642db46ab70241f1ead2b135432b426c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
