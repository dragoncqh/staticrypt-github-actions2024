<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"273fc33b64689efcf9b5a02d883cd1dcc4f7922bfe87b58276aa8cd42c5f00c6365f544e47c9c78b9ee67408c8af47eeffc11b5748b3ca9283fcc4bda3f96fe1c2dfb76b6b5127095dee86f28c2b99b79aaaf0546f621603cf3bd095d809b1ce1d35ebd87cd0f90bdf885623dd7cb8b98d7df6709128dd3d60b21ff07b78788c71b29fee139905db31848d890f5476729fac4109a80b0122e69e1c79117ca79e548a56baed3ea20a0ba428f0b4faf3acd3ebb4d03825852484ca93814397a181381734f8e02cdfbe9a385714dae02ae07b0376805d044d24ec8ae71b8af5f72aad89059d68063020e6331ebe7ed4d5432a85ee45fceb8aa9d48f66c365dde7eaa6bae58428f5bb93ebf0e82c57f7a3e0815ca522c31089bd17a48ef02eccac849dd41b0c64ed30a364f0973d91fc903d9ca5194291f639eca6952234de079be7a7fb9604146475358029abfcda365e751a0ca9dce7110a1b0f2f6b70bf63958e3ad359da07c14442d545b4e1acff73c44779a154ba5c546cc35b0aa49480d2c2510c20906891fe673ebaf2de251d575bb1d9094f2b0be2f0260d6748db23f7d6bef0f887a55cfab3f19aaf0ef22a34933a444e9d7c1b878794427ca8485b422f4d800e4a588ed0b6269f8c0bbc001856560406fdcf75bd503cb81dc2a02ccd381e91c1bfc91473ea86329b827880a70c2910a3ae766e1407a9f407001818610abbed4054c91862305f4a982ae165a07d2cc05de218e748d8bd23b2b771689f8a5d58d940bb9e99ccee0f68e0c35a515569480a044303bd2ae678fa3ce2a7da3a17cd47455a1d46e1af39083fcaea9e68439334d881117da192b30db0f00c1aa76094d5f73285ff35bc3bd9ea9b7faebd7dec82cd1a7f73f1a9b1f31b9783584faa806631c7582af648237c8eb321a519411f1fdd7dc28b2242bc26ffc6b2dc9b415f7d2a601a3967aabd6d191bf4ca7dd0f6ef40f40f5a177eaa40e36028c987481f266ccb0f30b7dff2867646f09cb8cbe10c9849824a3edc9f5a95187e76299a1ec098b9b425d9c424caea161180764bfb61f9c7ffb34f40deee00cdb052cb93d583b0ea3e23ffc5f40fd5212d0130c49c918f8cb835cc8503da32371f4b292bd9ec9ffdf9bec792791619a65d1fc82b1cbf6a21213551a7181351d7c12b076d70597bcf8084ae485d401d9965fc4359ce5d14092ac687ffa53ef22955f0b18e68a250c23d52a2b139521060929e84f6f449d008908f449847cf5f66ebde09498fdb466837c86e3cd3108c5e7033a6d1c279fa72899f0ddac027849a088f9a9372458c3c7519cda07926fd7d6e16440374d1a371c908a85ae7fb21087c780d844ff0a3a1e63ef0313e325014154484a32e63504280e1a58f2ef00dff9200ee3f564a13bcf4bb9d8d8b51ab84af051a38ce73df5a8b16a224f63d39d4ff969e96248415f382c4c71e4b6259d6ba22a2a5fe49218e37a1e9b91daa48faa9aeb68b3ad5bcfd921a2a92acae57f4ffcc68f3f9ae0a69214fbbecbd452d57345b22889634e45fd245bd44281787df7c679db7d3a0c8d5eb5b94427f88e040d007cac2bebba4ea85b0248dedd376f8ce3b3a56e1247326b56360c4981d0cc9d90a94c6e0b8c3cdd116621b73a88b51cf2455a216ca2f51e609bb184206bcf21854ec5591083c0981af7e00f6009820297ff5c3b65a54ec9f814410daaffaad19859c9bd2241ff1250fc72fcb982a12a4a268124993bb5d9bb39a25f30910dd5b1d1ec9f0f815bf4e0648f8534a66752cbfcb35572bdc38a234366decfaf939237a909d44e07c5c327b0507665d6443a8e491794b317d633c970a664136496b7e1824d9dbb532a1447dc2e7c17da694e730418ad5887b54e352ece199e67a0d38826093b25e187645f545fec9a1d725f9f94593b0c86a3846115c944f894df9d5d1f76c812db1e4c0d3b33bde56e590a3148a0e214a9779f4c4398ded9ee2e8393a28fca007994bd1dbf92fd39240216270d81a7fa59fa048c6931e4b917f9b1f4f24970f2c407e7d01399d508f4a5c7a3bd7baeb4144bbbfdc45232bc311343d636521773e3bbcf840b24810bc62c1f280998b88c778d3d7a3bc749a0790f16c9b58d37ac78098fa5a98c76acce1badbb3b6f64a132a1a171d61a1121bd3eb3fcfa6a0e4b1fd65d06c56fbf903ee83717c48ee4da07f01ec784ccecca4291113b32e2be8612c0aef4e076ec3dfea3b618a9a980efe9f1bab4279b622a240f1502ee696acda1fd5f40a33ef8d5d2aa30a7b168b3751c9137f056008517bfbda2edf1df310f322cbcdb154570ca8bb86e13c79a4883c184c9b3caa22a6293e568bed97e878ec42c816b31ab945fb7a52b2cc87ff306da8887d67ea429570494d9b7670dbeabfde87ff506044ab27f332e7ce359f5ec2832f114595b1d5a04e396a5cf755f77ebc50762ac3c7d92994419158dd791d6b578cb85882ae5e4ba02bed231fe6b5ed5ffa3075338ffcb266435673e04fa13a41a5bf6e0ffdfef9acacbc64485ea3c87ef346233acb66866ee37ccee54f71f9ebfc8a1f7d85a0e4d84d949244bb086f2c3255b58e50bb842fb837cb555fa8c5d41c76e5a626ff34836954b88c4dc0437b1b99e98c02c75587985c58afc03fe702db7805ad37f8d93a8a1309bd98c4a63820471507b106049b9670d6efa7bdc4a74fcad5e28b70d7a768278cc0ccc21e853359bd57ecdb09f979d07b0f7ad382e69387e4f4843f58e00c595a6cc90aebdd6704c4dad9313399c42377e3e278295d122868e53d6e6b6060e05d59582e3648fd0e5958ab11d474d9bf0590d2a72ece707edfa5479505120e0231a652397fef02cec0971f93003b245cf816e4ea216ce733a51baea92c715e692ce53f55b92adf86f036e4fe178254b8f57802ccb390eb9cdae826fdddbae5feef69e4416e4d03f70d19019503c09c377a5209c86001b2251fadbacefe46d88308cbdc145bc577a435a6edc94b695e57e138dc5325d7fea5306a4c330876d7c2ef8f718d25f5514012d4dadafd22cb2e36f6376c19b486cbb2ae766b2da4c51b8c1853e90b65de5ec02e6be0df20b0805d0a7f8b704c2b38ac75a272040d5b764031fff4f727fc788eaa020a9ef0f29f605f0133b45c05eb2eac3ed17c4d96d6d2535b9c27febb2e0049cd342bda116c7c5af5d5756521bf9ac4a8d346a3f4fa329b4e8b825415d0a80d24d2beece3b036629f3107101c5f9fdd91a758e1469bf0aae38a9a59ba8561a596a1f6d012e806c0a42185eb2b65f83204f0bdc7044128495d11a961513a080a672ed115168464f9d8ead47fd7faaaa6c2b39e28fd8ee7b1b8e318096b762e880e9faeaa2881947e11f80bc93b9277f4fd874132b372c21356ea4095405f9a5c8bfcc3ff696d2e31ef60b83c9b902bc1f780037b47377c558881392483e44f587c0b0a3cd8e77b2c89e8c07703d3258d5722a34896b7ff8b2f4f42f89e6006c88be0da69d6ea4c1852b054821ed330e0f90292cd6025b500ea9c00a7389226eb2e681049dc6d5577bb1b41abd6b8367bc5156b53da5159fec84eb2e5cc70a2d310662b5231d9e6e8ad39ec825044a75c5583fa921045145121e2c70e1808d5aeeb1b8b0bcfb8518343bf1f42d048db0001ad03376bf88b0c6bc124fc9bdee70a8b26cf1104af864a15b9b70cc1af6846baf3d56217d6ea8b4dae70a469daaa35000c8b57a04f79ebda2ab0b40807d2f6936fe538704b8cdcd94666749a00fdcfa0200a9203752e82671d762f002a9a5f8f9b21ac46562e2cd46bd9b2faa0df53149a0ad47ead75b6c21256c3c53b81180b16a96e9e4836d6707603a6a6b703f5dec22d1cba48d6d0ece395aef6c9a29e1b63a25e1791da585d7a1fa03fd702cd6fb98015037859105bf3830ff1e0c91b6ad9bba34c23a296a4860e3cda11a227eddc3193f59d00ded2dc7e6d8828195e7cfd4dd7a0a5c3c88dc9d0db3823c7785af2f3124c29d9532aa28cd04ea8c0ec69dd224557204b45757b3bd6d96488d3ef59443bccbdb50339e740b85ad735fd7cf6edc722451e80e195fa693cda9e5d2eb6ff9dfff745ee43f264be29edae074166f851905d51924a0586547813abab30b1af176730e645bbf7bcbbeb9ede7b0095b1a451d2db596737597f778dbcad3cfaf27538105528fde583741b999e7450ea3f88c7249f0ed6c7445b4564334a0654203e24534d57219c342117d8f3d780ce2caff440b3de0505997ac6047f16bbcc5d1ea8ed32408ab0155be57bee50eb5d4113f3c8dd168f72e0026491f7cb36151acf1dcd177ea8ccb76a5b309326b43ca042a4412e576ee21dcdf4df4c90c1a13ac89b31d609ecba48f9f907ada0aedb9ba8dc5ea9e4d261aac993ec584aff58efaa06904534d878fe7dc7c8c501ece2a46d338ff41e4b8a77d09d99294346e1c31cf2f6389d1cc51d5f8a1f492fbcbc6b8d0d598859d3c0daf1cab8d7c510beb79dccdbdf27ca98f8205ec3e39598b8673964fd71a96593a5d07b17f786ee2e3c551dfbaa500105a143b586a57350c5cb7d3d520731da0f5777a41feb12329c0eb88c77d91fe91e31ca90f267d03bef440b9237975b0e0c86057ea167b2718cb2bb41be576a1247451b372295ded2a1b52782ec51de3cd1a922253b5f70b27c970de38543b34facb1e11aec305369dad4d32c88566eae2212062c6811531779af81c22bf432b8ad8f22b09581b21747f9d0a23020b19f385f033fbd317c74949792316473f98df79bec76f0a38d4cc512cca4f9755805cd073b71cc431e791e4686f80cb1a7eedf6b428bcd5664116fa16427862b0cde819d0b20342c3c224635dcb6468c88e1b71b5cb7826d30c75c8b11fb81289ca8efeea0dd6001d5ebea3b4488e3bd57ef114dd4b41093e37d6fb95d607d07bc7b09fc4d13168e6f58e1c4118a6bfef6c1d2989f749f65c085a54b3e08e3f0af01d5f711651aad41145cc9a9373d10d1c463c669c3519511b25b0803fec6eb43f398b20dc3b20e13b393a805151e75bf7a466b1f6975840e51126ba83301cb26e051b44e477c047a156227b43aedec831fa76c93f600323d6f1f7de813dfbe5689f0773c1a449c4e6f7b732cedb253a2434da7956d0b6a5a5dd438bd4e58be891969c245a6f20da05f42191b366995bd78b78c749f0137516fb632910a8af7f753ab670602ef28a502690a247aa8baff25b9cdace7e3f07817f49170f6384222a377aefb32d19855d22579bd446d38e457d4763c24c4f68b154c4131f1a665e1126f0a0e4098f3c0e9dda3d8a2593ca5aa0898c4edd2fb5ea7e6c1727339ec2d181162bf25677f69a69c9eaa043eaccaf9c10a6410238595c13c6301c06eff35c247ebe8b5352d5e566fd8f2857cbd78567956a8b12f049304f1531992cbaa2c7cd57f8f11f509c031278126f08d80ee870c646a6a848dc2cecd919bacaf0895bb224cdb038038f52dc6836c6efdf27e8ea135521612ff0a4bc7c991b0fcf85027da5002202057e7e47a45da5569294a0962c0c4a4c866db79ab03bdeb41e0befdfe2e046910bc64ce48114b92c07a6fd3c79d90ec96fa0baaa0e9875fdaf49621b151598617994c721cd64a4e1bc93ac9e17b584aaf1c6c059fe29f373183299320d984fb64f8da7509be9b8cb28ad1515a48b35bc0a6c0b1e6dcd44a691ffb2e75e1b6c54af26bda9e5d9d97921377bca9c23381203032f9c1b4d1a13acad210810a61f9c57bf23c2a40db3adfbb654e313f3aa26576e153d80d9d55c9573fdf6e2ba4d5b3283e866eb1ad91eaccb4801903067d3f63cd0844e8091932be583ccc9b004e879a655556f358cd7e4ab94b7e21f1f05b2f6fdd95c8078000d5a6359b38c99121df979d8a2ce6fa3f0e12b55a157ecb2ec92572438023e4c577f638a47935fc98a2a10d451fbb003360c311caaaed636957890cea35f85cea1c1aa2d2d8546a418de457029f1dcc272b46b125165a42609479a3832135c3362d518d922e95dc9e437bce0b8ebd8b806fe955c792a644227780d64b4e4305c7e5816f3b3bd3f5087cd1cb72994359b0ff0a74bf61d73a008fd470eedd84aea93eb21d8b020bfaecc950fa1f3e18a3127a76f15d2dafaaab858fb26b665831e92868e232b6d95f7237a6a36969bcdfa4c55f00e7d00f0f315cac8fd8917dacfe6303791e29f3024e69cee59e44f1a5a0ae5904628c0f8255dda640d48e52d6f54f758afe1359dd605aa8381bf1e7d71a9aa184353ef27117320a222fcbf97348af35e13a9042a1d3da3425210f908aee11e8bb4ff93144ea55bf57e7a1b53d9975237d312159aa512d1a805403ed1e4fafc9ddf7e703be2e240538bf202c929b69ec7593b8347415abd8af83ff24f61214bfe37e47286308163c2268f5fc415206bf259c3a86246de9a2362c13064f15074d65450124bb14277651372fc8c14208e1b288c52e41a130df5fb2bc4a9e2d0858996a8192df67fc5122db27f96c9c691993fa85294de319e1f1fe8b40790d48db82a37620a3163207df89b6f3eab6e5b169b63fbd9ab56e994f48d6adc5b270b7d1ddefdbc24ab4c5cb44cd27ae60c6da0dc2edb7fb0a2d27d3b3ba5fab284d23a41b828c31f890a0482533a1fe8627bd1b2ddb3ba3c538b21c7015e87316f5e948ea337810e0409667401ae51d6483668c289287c54c371315a91780269a6dd9513fa2c0a5f8ac6017c216812678531b5581f22dcec5d1bee503c15e232d302bf9dd6a4d132e75b4d37a7d57510eca7a05424da1fac4e9ec5d937e1760264e2ee97141df4ec6d21173a8e59116f46a9000f4454ef29977b242d05f2f163341618a9610a505564bae5b156c29b36d1a870bc37fdd8478fc38d0104ff3b5db6f63a72d342ec6cf7f64215ee277e5d27c286a8d233ecc7c9899d1d2be3ad2bfb320016a614c18463ecb2ca70fb02c3cadc2c34b62d8fd08525d9a105835a6a4e7531b99821ac58989ce5a11d282fadf2f64f092d836ac8112a8316e714f77c1889647193e22ac9fd4b5ea2ea9016aa3b59779e571e488879b4c2a28c78f4006ce99b406989749e7b128ba3a631f1974203aef879b223f4f64581e903f9dbe3cacf2e829a94ecf4f1a0b6ce0077275b809d6ab63d2d40abb741b5dd03cec8d2fcda5bc76d1d70aff8365bd13d06892153031bab3de125e62802cd9aefdbcbb433c3f3a7b1909ad74c87aa82081cbfe73998cbf2eb3efe38e7a259eb043b9f1e94b4b7df01b5d905d01f2581f58572274335dad29edf9f04ba9103bd3b42f1800ac06e32af7383feed04215109078fcc548828434691be1b53745a83234039d896f8525087e94dd97c0e23edc9039755e5d25df73928bb72cc7c7ab9ac8279b24e4224bfc77c87d30c6b649555b6f9a1f3f8f86edf29ed47045364474182c8a06513283d7a9518ad554c832f77ec270dd61424acca42d92758412b0deeed080bb5dc77a226590f6c370c80c00a2608bf1aee28fcac54e5c9ae562a56f54d27cae8a9ec8667dcbaa594841ba2a469e1ed5cae33fbf632edf0b295808b41689d42fa48ea6ff8724425d2207045370575a29103ba5a0614b9730d730afad10ad2a81b96ae1fa0c11d42c7c478580a0aebd28bff0f54b7d65cf88e464b6ab30b85faee63e00734a7128103e0bcece92fef3289c3108b67e99c4c7e1bf8cb541b6f294a982b665693bfd24a311b3fb4c43ddb34792d27418e03450a7fe4b14c37a115b2b96b9afd18c5ea1261db2d59ed0990a1d85781f4c10bafa50d48380198cc7d377d515579d242cd350bdff75e1c5cf574707619a1bf7b8a57d6528bca0bb8cddda50fd8ffa7dcaa82d5d8b67d7f8f702ea34d86d58cb9013bb805e420d3cfe067b75b28c69c053ef28ff16d9d0854c809c10cf7af43b3d7605338e675a91fd0d0b482ffd85ba515a6d0957607c59850c3b0a004fa985972c4cbd04914c2dfbc73bd4c2c927d9923a39bb7025457a489aa26357b25f459b55095a9a7e3411ee9b921444a7476444fa7700bb87ecab77afdd08c1be5c81f380581c5699def31f69f0ee02f93f9e7ea53be9c6b94f2a3074bbffccf66abed2583f3927dc518bd33ea13df67d799fcd59890887b18170dc7f4cbb4f2267ad456a48859075ac9a09c8edbd01626f919eaaec5a8c5b556c87bd756a1c1a9a3eb1e0dc129888dffc433cd6f06f12368efb742374243d77541c7276d4f99833d187b4d2846a05d7153fde1673656f9d02841d73b212238e7397c3687abdf1240c3649ce1737fb76aeee3958e168fda3c476accae7cd6994d36efdc05c5dbfdcc654dc651682116fe7299ebdcfa6b31f6b595f30c57f55bfce76fe8561566efb60b4029b938653b99d5bba2e473170e62bb136dfd45de79937571514f1a83ae6698dd0e2a83cbab68caf4aa6aea615db4dd5f558a41eed41f7e3d3bc41707770c52dcfd5701d8bfee3f9824a92fc88cbdaceeaf61231551ffe4ff0f6c3997c1a2d4444f168ed7cc0c308fbac274e1fa0f57724acd93190b3d40aad23f4307e7b474276ad827e12807327c57ef328952d38563f755defa90ab84f68100a3881ce6abaa3477973808d11be3f8d32d2f817c417c49b656788f5f7a47ca7ad7169ab750a1d3323acbd835a7ab97143c510115e6b62e2a8bd9b658512b95d91c7671cc2318007869ca4941a29e62a882939029511f503610b2f0078e7b69f83f73310d374b1dcb3e49fdd9b24b6577149b78c1b9565d8678bf6701cab204244f85cae3dc21613b2e0fb654d4f4996c189a485ea5126749b0e8615408f885e71d51a1021c81a9488836a9259849e2fede1f1ea2a9cdbd64da5a41a9c5c2f0efd58cd690c7e9271a3ecc367c2f6f0826a613745d6231b49ee436c947577c69658a477d7a623ffa02b1a7c965d9f2d1eeeac8cfc2433c213543e71f85eb8dd79fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
