<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"567389598cc61ec8876d0995120261700e4bf7f35f327e268c962e65851d0138da92f51ddacb44e7c6528a1cb496ef543816a73480e53a9bbeadb12fb094e933998dd2a6c6b3e8e63cd40089ab4e1cb7c035335e4b3c1ab290a747b1fe52abf87d3178877304132dbfb9bffbeb8550e3e1f8c063bc5995e49b8e214951d9e262700e194cadbb35265d1df4d2c23d630cab8f5b022751b4f27abb342a928ba53b57e8b42a03ed7973191b6a9a2f38a862cdbd5dd3164e22394422e32c63b8e22ee3001f0f38bfdd09e5e2c1c35ecd6f6855bfa2d2af4877757d9bec15b322b11a483b49e8cd03950db7e5a83d8630f967adba68d9fc6a896393e06b31700fc09ab92d1aecb75c8511ecd55fc9a1c5c633d1bced5d38e07cac451e4a01a075c454629d84593c90f77aa8508ad2fbd5f91a0bb17508d0bd48fa3d0d137585bc8567fe07771a2e19148dd91eeb6f09aa58a5fa05ec76aeb36f1e790049a361192270007744d12f0c9b4f2ffe2ba6e23a17f627432ffd97aa389d42c843436da5cb1a557660bd13e18f04b03e65824486e8493539e5e6c715cb0d63adad379fb04c4eb42416e744c2a23f4d88c73f856e69bdd1b2035fff2b0e7f33625061280feda668bd12a0ca1acf22ae9e022ef0e61db968510fa2e26e0067318e923dd6cbef73ccc0ac202c6744f352637099277bfd5d3f504b4ae57d5229cb8519722ac7f0d4897876bf5750651448c5474ce5fba4776eba52f6f1670fbe88d7d28a47bb989b125dad7b65e08eec779142b6a165b2ce3a6084fb2230ce6b1414fad6636294cf8a44693e3cb7e95b020c7e9154430fc97d8706bf6f1fe19310488c97dfdb90335d4f622ecbd4ad9a12c0fd585142b8add2574daaafc91687d82ad4151becbb657b621bba9bde52317f393df924b65f60b62ca54c0cde64beaf71d2c94aa216417c9cae95c8f5f43dad71a89ea24358f649cb50f1d7b9604af0e4cc0132ecd159bb82fe9ab9e5df508c6d661307baeefa5cc8a20e4f6343d5d91ae7233993ecc69f8900357b73e138b7ffd54568229eb87e7b032f5725c538f97726bc9f8e5a6e86c7d5d0bccb86a4ece21376ce4aabf688dbfd267615725b4c15b9a85b9737ca25b0ab970bdb389b96a8d20a18282c8f0034f9d3e637a7eb9178b5f7db116a2096d4a3ed0ec104be4f79500832298986c57591b997802a7c92183e69d112b19a6bbab10da19af0e57f98722af8cb5836b1c33522fbbd7f3fb149f1ce3fbc9b7cedce115185f755dd914bed515bb84b69dd49f8311f040e1715de34cb05b2da28c69b2de48e51d3df096741bdd2a1b373bb190f46a3cea041e5842a9ebfb1c923426edcbd832e993c286731f9d677612269ffaa25d3d39dc1b10810847097a7c420486fe8be5d468712ff3ad94a158441e07980faf45261d18761b16ccef7d80442f9f7c4c5d147d997225076ac5a646da103291f0ce855ded03091a64f088624d9bac41a124071437ae729102c7c4390a7453052ed8a4ba1ea244965902ac1eb895eaf0bc4587fb49d718a73042483034d33812ca32971d3e02f8502ddb10c05abc679e61c10e0159a9db4bc0e43e7b347c6b6f9ad2bbbd1f824b9b0ac77991000fcf08c38fffb193e5414a2ef038edcf680a238fdca094cadae5a761c55678186a861f9b913c7bcb01633ae72efdfbb03f4ef4dd9529e9dfb9396d31a3e1b0333d0cb1a9078c0180c1c0370c5077d0e530ddc0a26b7534a1557da35eff461c4b76dc4a5d03e33e3a980979ad192bc1896bce3c135d69c0e80c5bc5955f24f5528d66f93bd9d4c901c4b489678ebecb814c48e7f12cff27ada95e8954538d5b40fe169abe0bc06433e3618cb0d6abb298eae071dcc4ae7701e88fb12e4d079cfbfd15f16a68ab747f7e4e155769dba48d1f54a1001103dddacd38cf0dd55ba7d0f4945968b9486169ad49155d9f08cdb93c66e59ed37a8f2412d5c142a3c3a0a7f8e1e6e3ce9d6b8abb294294ce7b5f28e65f44e5d28d25039bf39e9783eec8992e64cb874fc55069c6a3e28c88b6377b19c0868dce7db618fdc151f5f124deef4a02866ef14ff560281c548dbc6080395ff2201fd3ea39398cf868a301cf0e492224658be40c59507960aadc1a3e8e7add4605e955bb7b8b47e9bb2a127263ce6bbcab52d9c73f6bd658c5b3ced245697e345ad912902a2e6f1c092e6584ef49bc5fa3a683986a6e52ea65ee8469d897698173364f64cb32c23e4b3a65094e0e5e73f1e0c37a0d556c60e6b8efab7d434e86968aa3a8ae202929de50aa6435d418d29544a9053f36b5a146637e603fc005bed340eea0e77ccb0bb51c3fd1cdea4262b25e8afc7ab8f26aa2ff84346247363268d15c09effa0ec0b2356d854dcdfdc88a1ff9b21be9706f3b0771afd9a31986019f4bbba8b6852c6769f2e965544af99de22225d8ae8c91dd9ee45a91fedd01cfa05369b8b1cb6a30ac15654de1cf5bd1334301416018740976c397d627bbaefb46d2805bacf4afac3cb3773c669ab21467777cd92e2d1a7c5e338713808207bfb736e48e3ce67d02f1a2577abc064df59cea83cb38f141ad7872f2daff800cba2611e3d001f1763d7ec8c992b7369d44a32dd9b781278a574db66ce3ef859b2ed09e0158e58ff282f3b374ec1399f4b5072c37c30baf8bf1a42b91e1c44599332f075c2287288c12dc23466b0725a2ba1d02ab97da8b72cdeedb3bec349fdfc1e7c7966b6550c23e29af228fc26a9c1ad69effe80a9b1ff19bda787d6f16a5a06c454edbca70488a02c91bb6383d0910ede94025cb1d506a594976312ab37c2978fdff0b4b3ccc7ec4d62fe51ad05ec8041a7641d8d8dd46e6e444a5beb427c9986b33d81bf5741480dea8832d668a4c3529db35cc5c7777de148e512e02e109d84c4ea4fbe7e255a8da7f1ccf098c75bfabf59501b96342bfe35fee711b66cd333f9ca9ce73e96b5c7253d391277d8ddf2aa0eeae5629a098e5be1b9b6a7209bc9632814e0bc9a0df480d153269aab3245704dd8980fc89ca9001ebf8a17e317d4ef95f7bffb92f27a56cc74bcc1d9af98cb03ee5c46a8825a15c2f1313575e34e0414a0fac60600855eff9f1f145b3c7e764657e3d1cf2df9f95e1ea3ca46a0c3662dbfd64a6dfa6fc85f9e832b8f2ff26dc1779f81355abe08787b55aa109c8f0c849ea337ad223b4b1788a7a3e870a0e374eacfe21ab4f0edc954b4ca5896c627dc17f0423c80e4a282eaf05e08b19d97a9333538b86bad72cfa7cec1daa3a852eff3dd6090362ff4e69c68263705105bb20c3ac97d663e4a4f4ab749d6f0cd21421debc9a4ea8d1e58085afee07a1a758beaec68f192eae08b7af5477f20b4aa543f4e6372e74909877713363f083e0f886bcca5547e355e4c7fb632f2d4c257cc3e82538ebd5d60d3bcd3b2e70afeadf8fb487a8a8bfa94d1d54e38548eb5b9d50d0ae194c4f28fe4ce3305b8754cc9d97f6cb138c353a1edcb779c8798ef4140a454daafd2e4282959cc6a71d9263d305dc5fd70b89afe1fa758eda2f316036f6fd4695bd4a45e25d0da583ccbbda57e967cef0171a499e203587f035528bb6357cf58b648924e5610b7b92fbd58a5572e598b209e5211f917012c4f9c18695d8e879d84576aa0fe7fce0bc57eb68755f3b6c23f6253f066007149d7f334b34a6f714a9b3daa09e4d10e153e9960cf0550977fbbfd810c435516cea454942cf0b522e4cd887eba7fa80d4724c3d197cfc5dd490ca529dbfb8f143834d5b766b34155199ab3190b9fe4531062bfa7346b7edce1e0bed6a51905667c69a8b18eeff914a4bb2440e794154b47da950de245d43b9b6cd5e22ab7c8ae240785c3366d6f285f4efa5e582516d9d153924bc90ffd50944f185d819e5f06b35b9bfe5667b3e8846a9d9562c253c500f4f2927edb42e22bb61909a4d4d495d127fc674f28e180fa9f547e0be28af7710661cf215632b348a7cd9019a00ac242c3516501109b331d218872cc63f4f408965c18003a3d7abc53984daa3e8d72aa3750aa52fc2563f6bc9ee32253577ae1cc3f5805a7ff25636f994ae42b706d1f481a2eeab9827899f7400e8ac859b4df04a980580536c1c99be2db05ae2563cc99bd07410ce2312d3ae974b9502d13b515e9848e6e1dca84aa2ec1ec8d71b386cd588be88ef09d541bf6bbbcda42f0dba788dade7c38165da7df92cf4d246ac0a72b1b067c4c1fb3146825a48f24188c26fdb1e9443c64f3cc63d49402977fbdfcd6292265f87f646a5f1b6f75856e55ad42ad36a2a5f23b093d45a51b391a8a4ef9802305f60e559b4740f263b9b1b2c840f32967eaf230fd5b93fc47e9220d6f4bf7fc0d7078b41f195cc7036e46822ea4b5022966dcb86d1ea6e1eef8681436f079ecbbbeaf2e8a6dcfbb3f6eab34cefa9c07770790829d1eeeb538db0febe549e47f923bb200db8a743923721ef9d18233ff959e074e5ace35fffb2cb79da09d2100b816fa0531d6bdacbe0dd7dd1b2e024246995efa556e5708d15d7bab2aad1e95012292f27686fc26a4ac7b788f1f97ac85f2fce7385e9095e013170b9e01da06c0254cd553d76e871ec0469c4bb016c52470ee902333ade0fa114da136a9de56e98936308e256cd7e4e35d6d1a879e4cc9f479204666ccfa49a312a15d093b215c5e94b132e9584a03eaa50dc3ef46836350315fb3fbea006c50325887f54f5079aafbe8dcfd87df79c2897ee43d73bfaa1b6ce88a0c0de9047f06ac80d9035ef71af9977ff11386df13489cded31ff1f11237ba5bb14e636ade2d69bed4fcafcbb717aba8b2775dcf7f86ff45e4fb61717086cf247357fbd12290665596cd2ef23cd03943ea9c516fe492a252fe178b797828a9700784600a0a3b9171604f1c133915ce48fa7d795f07d731a42c8e320aa8789e8ee66b49cf58488ec0b6a63fda4090935b15a51227f9858ec238cf4bd18e474614c159481a86e39fa0d8dfbc001d7edc9a28ab8d370dca4dfb3c779110b9d1a7464c492a130411c44b239f2c33c4bd621270ceace9f76f3098d869a4751be728a18794382182574b9ef4f97091112724a1cde7a75369","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
