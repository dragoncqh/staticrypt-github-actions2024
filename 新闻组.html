<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ad41cfea8d0e7b38886139d10f1bd9016a95c6e6632aa4be5d629b9ff17cb58cb90e19df444e1ab4530f20b5573780b422509b8349a867548558d9f984bbdcc35dccd42cd8e12c3e3bd47db4f0af2703ce077a056918b874ae2f1825757469099c79bcdd30284cd530e30450ba41fff7fed376539e22831e4c346a2f8e00038b44eac4f79482cd93497d850eb7a58818058c3b5814839a6882e94249478fe4d20ca4d2ffa1203475b8a9b7cab0cc578a6bc8b2d06823ec82da831edcad68aa2abc7cc0e44e08d07af601c940de92f676a39bc3b564dd00eaf0fe94d1238848994e0265b93759014bf0527a180b9ac0a1709524e185ba02c2e066762d730d82c89b4b07614122a1d647e8846836be22b3c808421ede8ab7648b9bee2c4aa43b406fde477a9107dfc1f667d12efc160745d6b2728f4432fa5ca59e8e92d05d978f7d4bbfe9c924a5f60bbff38cdf4b631c7f31a269e90d777096a7be5b0c89a2d585107d82303063504277152e319e456088ff048dd0ada2fa9001d412d0c1ac43206ae7073418726e7c47dad5fee00aab2a4fd431a118e7728edaf8d654992eff964bf5cce565e990ad9e0c26a414fd6032bf4933e4afbd03e6a4fe9dfc09e92960005c08c679fe6feab4c719aeb2dfa2202f554c81b6c53ba928097474661ced0ae4fe3d4e586ab156720c071274998266a92b011e8d6c0049b9a956976fae6f550d7427b46c8c68c1eaa5d740bd5ba5d47a619c67e1e97f030b4c84cd3bffa04208f6870c3832bc93e815628ce7d562fff35c52d4caf9598ac49431f4aed39445af345d4ef99ac97bd63ef731687365c5c99d6bcbd4d3027a7f9432d7be5d1c7767fa7d4653d24214c2e8892004e2d289482c1c2a288766d677ef8f7dcbdeea81c6581d2206d59d9df29724caf14c45f7bfb33876151f377ccea95bbf87968a276e143beb17a7998ab33701fa8b8d8da6e3a659f49c4ce9b56815f3e741794911ffa85225152c2c973b6e5a358b1613c47ad3fbb494c34a1a8bd393b1438719dc9203f8cef7f1da9e502f2a18341f3ede9f7a4e2b37bc63bed496472796fad3f98ef5c45b27e83c9604e69a0d9353cdd14115f4c772334e56a71d49c51a86ee4b51c88ca748a0eae46a83445f8b796aa2fe2755420cb37fad6f441384a83a852719006f8df52b0c6192db8a2ca3153f9ce81ed5d051f84144e6ab6442e9b00d429211a663c971c06d9b797e0e3dc2d772c73a6b2bfd257bab370928771bca6b8539a0d559b92cb0a8987dc4f033ddf52d9da6eac4df60a0fa4b7fba647db3db73e67b4ccb2bd619b87d009c0bbba804150c884f21a7f419cf423c15d52fe553296a1eb1d2f87e647e0c4b9183ac854acdd1efdcab67278123c02a2441447e3a7f864143dd51b36ed13c38fb0b7b86f96ffa31214bd04b9de25c1fe4f735152bcb552f819e0b45271bcabd30d892636e6bdf8434a4bbf6d9ba444dbad4994b2a973ebeca77b29e6b72115d6901ca16cc8eb30ae8b137b888567feb08f043db9831bce91aa1a7a9510a9f185628155060a596d5e53311428abf58d6dc56d50baa12cc044e56311abadc35650e472423f3d6886eb031eba0fe083d777959142517703f97ea53ec3f2ba248b62d829bc8c12628c345b72d26fb6749b6d10f715a769047717ed9ef881c0a4688ce1b0bb0e7cfbeaf9ef0bc27aa4f6fc940886d51f55ed536ce1ce4b6c80a57557f13fff51b4fe43cd9197b56121c376ecfe89e112113563c9dfb7bff08679bc7750d6f85d3cdcfcda5d11dff3d7137da4255c6cb67eab2bf864478737a91b8dcfe07e108d319ef717d37461cda203203aa7593856097fdef47c5350b89329b460e10a5fda38041fbd9ab5ec99f1d066b1134f1c9c38536fc2380ec06a4ed564ddbada463372d152f8f0508aba50171c448faa7eeef06590f4695ba11ea1115c83a740231e1c663c239f1aebb14769942784354e9c460a8a12eb9708e352043f6095def16ea50125e0f086c54f1cdf5c90f7a5d643fa79d815bbee706ff5cd6b189402fea9d31eff26fa3fbc59aca7906321276cd9aa5b877ce25445bbb07db04f7ecbbef23ee3176c9feb0172c337029a5aece6ce553208090e4203fd7cc1dabd684d771081a27db5fdccec84f2a14905e6e717ef2ca23b2d587ab0e0ed15fc8fc3ddd4b53be7e5c738edb3c9f69f8489a24e21a10f28d099b697b8c51710420a96a352dcbc7e15320c3e6b5c5a33aff00e25acfb142a80678b1ae1cd1d2da973a3e358ac4e8072fbcbd522ea7c404b85c761e25f7de9f7c60484d65bbfbd68ccb77138b883cff8c7e290bbea93abc8d9101fbb9fa9987288353bb7d4f6f330051f36df3fe4acd30328fa23ed9f64cdea9fa551f901d9fb16b7b51b5d24c6b37ae3d39005ace383d86fcb74675cce976f4b1b1038a70a2acc7fab34b4477ce5287d2edc5c30bfad1997c43910d0b65feebe1f7e566e5b4b88427a80c444f461893004d87363ed1f13b6ba00b8a3ab4ab36ac44db94ed04044c2266cbc3fbca4cf3c66c28b674e088b8c637a0a93ad8d612b6c0d53ec767411d54de8976f16e31dc8386e65e31eea49f10aceac95e75c73617a2bb31b50af66340df82df5a9e2746863eb4461be6159b9792501de27820ca286c0092ae753c6d32a4f55ffff33f559dbf95e16338c83e4872a6229f97377865de35accf10abb019a12eff4be0461412c101eacc4dadfd8db76c3e017b52a656932bdb4e70149d271843e8dfa902511c66c8e25c26c53848147ecc29a5093eb4797482c47ad2f4a12ceee41c8d6136b6845b2003927048bfe136b979301b40920820bd7a90c218edae24159a8e0709f6a2091f007bc958495480b93e1ec56ef46cee62df980418ac4a16d64b6652b9a47383adc0056e66b6f79ba0bd136b55e1c8f04c08fe76ac775e7cac3ac0717843b6d179f2e9907b928c7a6bb326de32d7655241f8e3ae602871422e6d340c52111d815799c73d89a42060a658fb60293a117ea32cabd79f70155951c3de342f0e52d708f97ccee604108f18fe6570deb5f240d95a3e59c968e02a62a12d9e600773f721215a3e20f22a7d32b6f5e06dd300279c11e2d76d3a24abb385069d7c063d04c63e16683bd5d7185dd83a3f85b62c45e066b6c64f0898bb97b7e2dd14b434df820ab9d4ceaf426c219ba7973e2b13d469ca2c29af4668ea53fee7f69b6d7565e71bcb58d9fd41f8cd431909ff30abf53cab9fab8d54c9ffe08d8a1dd1e7f6dedbe9c7ade607af1c8d18d6ce777bfb74a6fb4f9af294ac388d7d800944f9b7fe479c3a89303c5122921edc2da8fe66487f5a3ed82bc2e330c201994a9c76f02777d37bf0700c34dba9868866d9ecc3346ca7d46fc1ba95000d68e872ee1421e05c133978485ca464340da17268451d161ca9e5c0e13e12108ec358f91899776ed7a252bf21eebd125e8bf0802c5a2b889bd37f1401ee47763f35363dd7eda86f3c4b8643232735c291193b3b1a35d2b69b637c1640cdf673d4a4c16f2c6c530418712e24d4869b2c75b6ed543947131c3210410dedb5134fcad97263ee45dd05b9ce6334ae390c2abe7387781ee3c09dfce7b5d8d5dc9712548fa9c1607e573a791f89d08ac069e2b7f04e4879ed093960c8ce4fe898dea01ea01ddd2b5bab4a8619f45816e90e4bf93cc74c04eb847a71081d1ce3ba3f98b8d1adaa7a3631870f9d81154958b75140aa36af33b9e76fae647a2ab33039777b93f665590458b1f5ebc379da9be4f9b72496bb644fe173701349b21b97f7f96bba4992797d4d6c84d4b5d6def3a4782a5798bf46b1a02ae79c1a2f67f465d8e6ca9b56e686ee570d4de8535935b955aa1bb4156ba8004d621ae52bcdc4e3b393aef7247c175f61922d19a6f49a6cdd222f85abfb6b959d78bb692ec82381c98b059b32eab833f60df698a85790ddfd9f66584358de1f4029c7f6574534ecaf9c0cd64da7d2fb89367041c645980dfa6ac6fcd9a1b604c9f560d3aa5ab3a8241d4e862e7910a4a7ee27a8b4ad1fc029cce5cb1cb785dca5f8a5fa7ed0c72ef37340de7ea37fc6695fb73ca094ee2dd12dbafcc86c502ad550f057b6865374b945a0f6ddb8362bce5d76be64962da9098a9ccc137c65b9aa9f33c87b5f43b162ef559f624e0884e5b8cd6699fc07396dbc6627575d7dd96f216a44959c82cbc4217835ac53effb521533f843f740fe8aac4338c4d3cd23d1c06e9100391e50a8ca05298545655f20e9b802dfba9882d3bcd8619cb17285d153aaab19732991f8832fe4e02dd4fc72a0480e65073bdce2c3e7e714bd5e56fd7e4b446474bd25d4a68ce811c8305aa830a5501f880e0618585246ca84583ae4578ca9a2ba82b5382ac5ba1f68afddea7ed38da20a4c4b9a6b36a25660e868176e1012b3821c06b9c3f02a8cf8dc6a4c05d1c295c31f3c429cd375a77483317f12e9ce12f4cd878c238912e38ce7916c2dc9a904606f1c5cfd24e6f06b04858eb35ddb9f9018b30aedd0dfb56cd2d3cf61feab3fe29996cfb15bf9f122babdc82eb139bf6439b25870436cda8f7ab5b388140de36d352bc7c37f5a8e9d0f3193c6cf9a132d0778ae52dd774ee80ebbba63be43ee0fdf7457fdcbb6e922c7795b49af17faba9d453b221619c745468dcf516732de242c9f25879baf60629d7c085232a01bf54462ef4255e4d7382b536b93f8418c0e5ab0141d09ed8f01101c5311070aca40eafc248ff5f6ddd817e768fc6c50f00625d2339a9bbdc737ad7e0dc9ca4f9a858554286542ac3e2fc74ee46b64db5db65850d01520977e450cb3e3173b2bbf352b6e6975df49ef54e6056a4cb600738f88f511c23b57a61a35580c122eb7b728d546b96082609738b351972fc3009d849a26946696f6ea679e552eea28f4e143defeb703cb566f0ec6873423310759c99002a85dd0e2a750b284536cf6d9718b954d62e881afc78b0081640f8d50e63f8161447ccd75aa46b441d4e8e001077315ea7c230c9a3556d080b79ef4055aff7cd960551ba0a8c7c60da19b61fe8a6e27d71212b1ab2b9df2215cf6beec237d66fdf8f436c4dcd0c57b9b8327ab5eae3696ffcfcd2a0fc2711d901bd17dc27294306d02099bdf3f173623b2f38f9dd6ac9a9c322b2e0bae1b1ca5785567ff2aae1d82c665921e4242059d840d18fefa2e6388c93cd41ac44298ed39075f3aeddc93d5518bc4aa5240a76e25954a2d9a197db18de19733d85845f984058a620e7e016d30b221c29402d255b22788e37ffae00d6a7fd086e2e2cb0c75c25a818c97b5da81fbcafe3af0c1c09929bd1289cfad52937aec0ef6239b33379103662d4461936a259c29a180027733dddf5d70d83b3ad48cb404af85cd424d37d510f15a2350586a3be015584b555494771d17438c22c56e9dac37bd39007ef7771cb89b80f2706ff5ba632fd6989ace5012e4684d230b7bb0b535e85e75cd381ddc6edeb4dde4c74f14a9616419e8e03c4b49ed5f8869fa54eb98d08fd5ddd349372d78db9577cb78f1c525d69c8fc3255aeefcc3d794e082ec26922baa0a4c1936a049954d835784c60bd442b939491888ac6ccacfbc6494ac3432fbdc4b842bf0be0679de660b57e2c2a10dc69f3b0060e071805058297da5d5da626f9019ec0f8f4d7359535f36c54b37854ed8b94f5f73673c8ca074d067fb7df2a904c00f1a03db70a68c3bac6eba777e221e37a60d81968e1484cbfc8edac2de2ee3c4c20604656ef17a0850f35ede596338a05bcab5e745b3e3ed6bbf838c1f23c134d853dcc7aaca492663ec5d19b8ab027c650bf7deeb4e567f81cf0206a93b6b879c5af49d056a5f27bea1418646b244543f98f384993b59545a18073e619fc39edbe213d89603faf6ac49ded90006464c6dcfb6dd599f358cffe812e3c5aef7cc3f430c846329773f7cea95bdab2b50e14a6017d5f6f314e2cd0441b498c393cff913e71c2b56539fd338eeb2699a0320d458d3fa8cae2b623eaa81d05832875c23823e33786e6d0a53145e5afdfbe28195a1918ea3a11a2ecb835dc9412f43574f6bec8706739265f2f8154afe4c14b458c254d2fc8d35ab4ea02c0dc696bbc4204593c4810866daa5dc2f3852cd0396c281edf2b825f47bbef50a571539eae9f9de61dee3ab2cf407653d517c9ffc9d327cae4d484a4976be3ba7f92ad8a2779170380cb1d30ca93c3969c99397e2d5fd4c8c75243043270b2956a4006f5035c8466a2bea251bb0b0e2ae7d581a21c8dc67343ca13b69a9226df61ecc80cd3b0636406679f973e98ae4beb5dd48ff907bb4853a95b7ef402a395d54934865a15073a0997813bc207bcdda46a1d9fe1bb1325dcd9d7e51414c0477205a5c9c19331ac041d31224368d346f08bbe3ff59290bab3e38fc13e6b9e050e867f85dcc66af6057051bb7fb5111a0b07f4bd58c83c221e7ae0309046228a44424246bc92f1e092f63f7932ac7d4106e6973f8bea35a4244eb5a1eecb2a50057e3b9c64be4fb80c50165037a737a8a004fd2c6b287910901b0345134110dfdf64983472405ce32393e7cef0555174d6992d92e90dce678119d98f7179ea4bb0b56a65a914a593ebcf32a852c481e77ec45f7260ffab41f9475043d3337783f9faf6bc57e1c7d8955a801aec24e4d1559a5d55ef25cfd2cd56713a955b99d4a56995c6e47656d821ed7320cb83d202934e708c565c05e47c87fe2dd4727324fa6af66120b2c0bc379e5be6b461dfcfe94064bbcceff908a9e8ca91a45132e99f471ef95b6554583c5174dac7f7751844ed2d0e3c6f82db2f5213e291c073ed5632dbd1190f6cba3f8c5ab9a7d79f186e2e51761fa2c741d0505a8d1db25b70a0feefa28dbeb143a2d1daa84c4c47f1e270f6e2cce031118d7fa1e107e8191c823002e896c1fd11a4c3c48f8bc00e8f24e4e39f7073d113c6da9cead1871113e705ce1505284c0e7d944b22523d28b0a68abe9ea17174f32e27f34d6d3fe973ae44605634370b0ff8df15c8060d41a65a68be6f41f182fd0f7c1901a21d64739ebe16df2f7ccbfa4e452ca46ed5a088912988e37496ca5f29a0b12f88fdd665955984d6d58478515d9c83dc31d8308a2919ed0e1faabbca971f9103ea770212ca5bc781e69b7273a4681da887697ef4cfb94f0e562d7d85d99c9eace8719b8ac377bcadef4be6d9fafa0a38ada3d463ca5854ea9ab28c9c878f86f62d9c81b844fa10475b5fc241f1fa0581683de49db14ffdf9c1532877910e56465d10fb2304aafc2f80b76f501a5ce5ab1070293db7eeb5fc145eb448a3c9fe98ac6343c64c5cfe44b8ba1c372fe3684b2c41e5911d721b3430dd9372b918d190da8b21f606d7557cc641c70e9e0ff37f58766da2c6788952c61d69e1c8274f46661a9e62b59c4c51254dc21f770c6915d064e1ec981ef9c7edc1329da7b62f3901ce616eee64b3fe15ec79da466edf4a0c2a405da863bed692d59f1952ff0749a95f27c436484ae98f3309d3ff9bdf519857578a6afe180b90f27fa34cbe94d6de33a7846c2235169f1b1824273fb063a279441068f6a850e784d95600acf02624c51d8729f8ccb30eeef84045174b405b3f2e97ef555a05e7ab35ae61dab3ed6b94991f7cb6de0bebb1c581c150bfd787e3ab01e206743b58c979fd50d6695447c0591df03615e5666c16d574d83cb0066fad485157f2ca59d55798e46367b1d7c88fd1b4cdd823da1220712579ae7ac5ce13e2ae02810b56afb20c470b0ff62652f72178fdb349651a7ad3f6dad630fb33958c726880e32456e78887c3c9c7b52ca1f8804d1b5ebf4d1d8bd4c11fc6e6efe5c566bc33505068d5838843ab4500fcc70fc3ad0364e18ffe1dd07c4c1c515d7e0684c077bd338339621de8697ac6c67cef8a879cf2bc58c007d198886d20f3f47ea83616e6ac092733e82464899043021e2bc809f828d2c2b27214a20aca75599dcd26cae8c91d6f8e0b907b6c5e1bd01bdbb02668dd6436b8adc55b5b43a308a8b1614296898cb34c38d22fb725353cbe0ee08977084122d6e08ec7c91bfdc9786959214f231cf7c523f3bd6f849cca580ed42b43f58588e23282c6ae6ffd7982bb73d6b23d5a4a9e9938f031a6154991897577bee5dc738a15113dc25385e7a1998440c9c6d411f3f6483900cabcd7ca7be4399f95fa3ce55a04f3bdea73c52c664c18acc833ebf7c85d6714f3c574c12c14c3b2998395a2f90864ffeba5bb5131ebdb37a831def7e71447eee87c37f35ea3c15d1c591675798c906e6f843877f221e35f23618c0b763c04395a172ed25f7c83e0324801f37eac74b4a91bf71a41f5ab8d72b656d4c4d4c226b3924a3845bd54405f482f01166c2d1821fa79e33c22c1f4a2753755d227d32e4c6dc632ff1a528a7946877f5bf8c3f26740e2940624a6eb8b2d4a59cd316453981d66d1ccd7eec5f5e39fc1073b2c429c17aee85d74644ce614505f8f772209f3b72c893cab0fff4f0e4421aa9575005639097d417524afcfb26105aa45cef0835d6d86aedce6107443b7ff94068fa9b6051113a661a93eb9d7b79621665ab048dab36bd85573100832d81567e01821bf2850db615f4090b1adff19741883f5430f7378280d28b32353d95aa98bd49107005e4c7aa068f4812151cbb9fac1f94f9e7d0a46d0ab1792c2ec8ec026401bbbe868bf472d3c1819297c6746ac3d035469a57b2ab1e53227a8a494f3bc7a5f392f74c448eb0ca5263555956818be6ec3031a44cf3edd57932285b8beb62f5b3c5462112491dd592e57f64edaefab41e83690f28c9fea7b05708c4a4f15e300d2a2c003e9cf092173bfa893c55cb6772079265e28f495993ff2127df974395640709256042a9913dca1e523e132d76a4cab4c4fbe7148f1ce01961a1056eff17f640ee6ed34197e2bcd8b304a9882606d4505d91a245a6ddf1982eacdc6bb852fd1bab88ce8490d207ed29d6899201a9b722761807005534154826e2ffafc65f0d6c3af4ff6d06e3329d87a3b4762476576fe27861db7df28141e62d7522eb6658077aef9ababfdc2e4e52f779304d9d09ebe269e6cc1d24c7f1e58dc22b32e30d4954bbdcdc6e8e1bf378c677000bdac70189f4a184da557da6525c66f5df6c144de6706b2e3d9a55df04d0cbb33597152ff582e83357ff69dacd1cc7172c52998bfbbacfc558bd8e8e76f41654efb3f8379343082910482546dfc61cb67aff413c7722b7b284a9a9b9674e5e02fcb5de7459d47372078b5289d2805a8622783ef686b7b25bddaa4e0ee3bf6bc6be24742b7c62d47c5547ae114ced4b99aa4f8382e5381fa6700873e654102cd4930f8b1906a929983f09c932d2291c3b5a5ac2b1faa8cbce89960f8d73acb57c2ee1d6a662ad3d187ed592f6f59f93176e916a9e9c243467f14aa34b2dad415658e5365e3ebd74d618708cf0ad3b7b6bb0cc8da5602d6284977cbc2cc143c8089825916046a734b91ba16149d8a2f7107f85a2ce86bf7b813dcdb9ade66130018812e140256c78e8ebbcaefd0ddb6c9b0bdf86aec8c32e21e984be1adabcb6d7b16485ca59dbb946e51a3fc312a819e2df1db11b138c4390a9aa8911461cf5b95cf4784909a5db5c272c958321bf5cef75991335932f7272a7a3f6e5ef8957c132f122a2b94e8992aeff9d7617757e177df8696b0c5995800c139a8b4775b30889743d8895760a0b9b58087387023596629ef202f23f4eb8c1b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
