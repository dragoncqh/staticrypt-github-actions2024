<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eac2e69e229105cfc8b6c7e1783abb53dc10dd9ff92d154723d8e8edbb242e2c88c5e67036cbfdc85c5305eda0f5b31579f698ffa57423c4f47620d92a604d7b0198f047163db725ee4dd12a7c8465968fdcbcf89b5bc1c44938d85b15f011c306bcc20d1922554f27f19d7d67ebb2aded4440b477cfa5896b924a80483d1ff76b76bc13e62955a904d7a9fa5932e67926f035f29292c8c19b78de85279eba39f8a818655364ecc7822c14649d36d48f91a367d00d7e12bbb4089dca58be6b503818f11647cea5749abd672df73eca9a0fd8883dc706bc1764e2e002f532911a30fedbcdfb3a351858d1f06d006dab54fdeb130fe186d552d32b89fca9426daf126b83d02ec6ffff332a20b11b8f7a7ae780c19718bbb2e24b32835d392a7ccd6c6c23c9160e97f5ef23db15301abdd24b505ccfd315fd52ce82581b966a95b07e38a45549c03ad6abd8a44bccca768578204f4ff6a5756719829272069f6d170f71f21819f9019f78c72cd6ec1b7aa15cc316afedd8b3fdfef9af2718e289aa4488f7453ff0186e1da5a3a849391080eca404e161c1246ad8b8a8695499db33b48396d3d89c0fe0a49f5ab3757f8a46abb67466820d2a0d04b45aa3c88be42ffedd305ec60617eb13dcfa3face4e82ee102832dc006fddbe4c85e69ac466fb07a7b073eac26e48a4297910a8fd8717527e336f8dd7c6bbe8b7ff0fa2acbb7400395764e93c1a8f8d3da415ead9a5df58fc971f0055a7b3e324deee254ef1856fabfe0747d3d96cb9275d09bda2c0d7357ed3c1642d7115bdaad47fa905bb5b33bca402c35d6407e86f06542d4b3f5ee304ad5f84010e657efaf4675b01d1afdac71f2b6fab931e8dbf4bfefb5f738cccb8617fd0d28a5a199a6b2463cd516694306c61289293bfed9315dee922f80d1569d5e9ce1c6a79a6f8eb9fc053be2b2856c05d012b2fde73b3c1d814415e1caf202158a2a6c8090e9d1fb0efac21562fb7d0703c92ebdef244f1e27be901c05f114ccc99dd7870331f2320706d12187de410e43d4451bf19594a70680707240b012c7d73665be43c66a2533ec06c9ffe43b0c86145f3d532a014df0f017bd741a6693e3af5dcb169db78f066c7be6f25fc45db256147722e2eeadd27e860d6f76b3937490e94c2e7c79ad8b26a86795ada09b6164014d35b9f5c99648429e4bd721256e3200c071609c0c167acaab46b7516d53b1318cd7165bd2292d1b2180276abd0d814c1bdc37bac05dabfac09bf2f91f5f4ba9b73a71dbec2f50b7acc11d358865905b35ed96ab9405b9b05c7e82e0ebe202753791d9c6447231d0ecd6a658a2ee66cfd4b67f0a7966d055681667bf3c53d955de80fa1ff75e36810329044071fac7cbeb0b46702c6a004f2d2ce6af3d9663f5497c263539368891cea877d95056a302a423724a857adc0bc4d737d24f3f1949bd3c636136049f27c5885feda9e244ad7bc1a262573d721e970066cc3eb4ec242e77e8d8d7002d2c6ffcf8ce2096c1c3571d4c83ea5789effedcb3a7ca7401036ecf0c7e765a549cd1517b9896136746725faf737a7bf7add759c1ab55e3a9658cf8f0922ac553de7c1f1bd58a887742e4de47724e420ad9de989e485ca42936f5e58718b48ebb5e388ab5b86f5b60085af6d871d2267be9e03a733fda7142ca8ec40cdd10b4f8b7f2c6a6d68a25264b811dfa0e26d454b82abd59e14853a3f74ec45eae10490c77a8a2d2cfa64e9827506cca3fa58a9f94ac8bb1881959cb5396023f1d7e0753b7185df74d6355606b44b48b99293c7f2a4d15f515a3814ccf28bbdd00beabb1fc7bb0694c0ed45ba4d10196c11e19fb31ecf0108bce1141a69defb6ac69bbe391c023a2551964d16a71cb2296012df98cd8226b0ce14b7d3da4ed93218d6b6befcb88ce2bed736f2c7d9c4d0ef594185eef865c499b7aaab61357a12399f6bbcecf4e3212d6dd9dfeb77d49b38ab0e57cb13c25e63cc2d69389f82556aa3647e5e742d2bc42404a2a237ee94798e6dc1bea685c68e7134a5a0e5f73c5d0a5b7bcea1531e08b46a04fef31fb509001c3da41579f4b98dac24a1ff1be476c4d8e6a200a0c80524665da370f5f35af8293c9e48790659603aa049ed13426be8657f175daa82e0b18ff06e77eb1c4f0e87628546c8b014a8bdebbe600521e178d8892da94607bc254d5fc9b0c73ef9a59ddb852fc2a62be95b247ffb3ee1352d89ba64d71a739cd5b57879d414d40ec63f629bf9b750a8f02e0aeccdcd17b3bf841f3bdfb5635f7d072ceb8d8fcb89a93f28ff25e798fd122d1b86f5f17a8bbcf3013310aebe69904a0ea54dcc230c50f56f46e60de6e56be040f6f6c3683eba8721828ab18fc65a62b0d6d7442e19404191bc2bed2c7ed2d94c0af435b715ce57a52fd39dec4ed2fc8b67ccba5ccb62eae977c04d2e5f654ac8d8af722d40def9299d3c37767aa386d75940bbdb07a40342dda24ea8bc81b253162ba9e667816fbc6fc6606334dbcfdbd99b974be1fda9b007a7997c6d64b3af093c3d00f0a22f6de22ea0fa5b01d675e446700de0b40ea51835db2be7b2802b7241a2ac990641f972f03518d57fc30d247825e7a62d0793b7fae836abcf4835a5d98c516ef8918491861a940ce1dd83f1bed77edc4ea9112649538e278b8e95904a19bb1f5c495b3e630972b62db6c30fff883736df69888bca31699514fb0f39f0b78b357f3698cf6436f0d1901b1de612651194d72ccff6b60c091683cc21a2e9c14e27ce5d6209f5401835e541f93fc287f26f858080245fd7dc2aa737d53ba2474daf11df796841eb0176aaaffb5d9342193c99ad1220b82697341545ef179d2c306495482d7d80f8ee43f08ed45ad10bdd4205b1b745469e82989a37e2067eb77bfcca36d0a0ff1c525060fe7add43d2a1dadde59d4cbb74195517a84f7d503c7ca9bf6eb1b0d2274c85aa95af5362f052a2fb7216825c3a561ae0aee1359e37d564e56ab3ef391e1dfa3b63af5e02c9ecb8e236d5260ffc549a55aa7d0940aa748b81df9b0c2483a7407000383255fc7d2689e929b52e6e443aef28941450085594052c958796da9ff129193c692822bc75955820411238c7b53ec6a45d5c74da65d273b506fc56ba682be88da013290cd13c9dc7845a1da42f36c80baa8e061aaa0307a513dc722270e35f01aa3d72844be1a34f11b893a9a4a230c2291d2689994626ed9475e557917fcc55915f5e71ef764267897967d031357d36c0a9160a6c25e2d78cf1fc72322546fb77007cd87d4e56c6729b248a45d677175a6fd198f5cef606b3bebbfa248b434c44c69e4c7e4ab5af4776990123327fc831b793d6ea22735014caff244cd22477dbd75e9bcc32699b59ec366e946d16d124caf2293e57a088683cde877fba70e2064bcf35e6604a960dea31170cba4a30709bc3187e16cf27a1927dbfb4ed6c6c6ec2feca17b865227505b8f15477ca82af7c5979aeb0a9328abfe05d46810d7ff547784bc778062cc7933d0272e5ccb15cbe97d28350a33b508dc2a6472315c30f25c67d530f9bf010616cc6eca18f179b3588fde630fc2c660bae7bad92194f388fe9dc9a57fe47600837507c8b2e27ba33baf94c7c2330ec8f164aac4935b19c961343ada49c738c283365371ae0add47b2265dcaceee0f9e073fc6edfe56edb5a47c8dd45a70241ebefe1cf5b1ead5c1ce2d05c00e73e8a4a1317df72d3954f3fe8289f4d8b75e419675642746c2ca9390c7528f439caa099b9ed4e482212b85218cc2ad2e680b62504b824980c028606c3cf31b5f46af603410a161c78eb02c237a17a4223b92d05ce2ccc00d17bc6b6cef40a0900a2cfb0d2370c54c32e17c890849048d0816af8a942254de60595390174edd563a00e872bd1727a97f7133cc59b66a5c6fa01e5fd767be5cb31f725f6feaf392af27459eeee30702a54b5aa5726db339e05ea4c1e93e9d44412e6672f406a8b8699ea5e8113118e46d494258d62baa4882f9a81fd0f5d88ff1b8b4c0faff2c8bbd64c27a2ddd4288115ed37a1971be25d5a46493af39d1bb29c710fcf375cf248cad19754087864069e6b6ef8890c64cffe3510f935b884d9560da042f5a9cc3474cf4172fa1f5f44ea8301b69b109236d991cb7a835960dc6bb061ae8be6755b5d77bdb69bb00dbfa90036823d10756557aca7149f16b57ebd64b182c7fa65da22f54ec3b084403f861edb7a81626d71f02dbc79aa20dbb657ed1d6511ec0e2a1b2018f895dd466637e091714714879cceeaabed3c4b9944f15e833ba7b33c118a6a9e4bf540886dd7ca503fb0b554ad001abf57d73444ea23c845521188df248579539e8612594f09acdeeee5ae2359fab24174184e3b36a21b7b35e4f44ad926057b7a14d564836231f2a4e5676c5eb7ae9f02d97ccb3b7c79ede292f842475304325da8dc0d4a6c771b356a2586aac779e7604ac3229c87785bdd298addfd1696989e813fdfb27fb938c02275dce081240573e7a8237d5cedd6437e600c77f20b2e20741c8a97c5a162e71ab6855cad7f8324a1c35f3e2f8baf8c4a9ac793ec6c2094f4200289ead8a7e6a4156289f343618ca8e157c03d06ea3a613a0be8d6f63cb99a9cd238ac692e82d936b0cc27ec6a7f828feee6813e46484fff2dc879a78deca2bdfd1b6b19f4922e9845857d1a8199493a9eee1b98ba9cebc725182cbd86450bac4a443906a408cab804854c9665fb1109c1bafe53c8cb1c57ef77dc319c6f5f94586676b1d389e04239d3e35f3a260fb02de49956bcb277ac234d73318133d2075498a72b46f52f1fa4b6255bccc44b8583c89ba3baddf527dbf6c31ee6eb4124a1d57ee83ed32ce2ec811a62889d0866e9b9a15dc4c933e8af25f327420845ba545e0c5eb91136a10ec55011ad0d0a30c56b615d277a07cf8b1b7a491a82351406a374b04d7c7b563b25d4fed608fdbca0eb0dd4ba6ee1a61aa512b372742a47a9ae64ca336d0723c4bcab4c1350ed59f3ccf4d7594e04af9739477284577ff74d3ba4fa0abcd1073bb816095de89d549cb1c0e8869b67bdec1a26613de66702c949b718ed0048189e572f1f1ab1ae96a8b607fdb0e6a1fb022020c8740ad93f2be79fc32e3317cc88b25cef8ef63b6a7e41d06ff83a66d1a90cb72f62a4697f9b838714c61d3807350645c76e0056e753296fd4d92492c222c53ac831dfef16c657f90a0e38002ddfe1466728a08ebad30fc824e8439e93b49c30e9252017d57645c538b9fe546cbc1b30c27aeaab009776bd483af83f63cce2c78215d30da38d8b9147d0a9123918dcfad4db4261d1df0536c0b8c5b5627783fd0d29c021f9893db53d83ba2f33c1a34bf2726913a2b0eec35e9644b9e2cbeb4fcd96defd764417e48443524bad5852200bc0b10c6dfbffb06fac241010765a397f70311620cdd68e3890222b0f0148db91c6d7884d045921aa49c8b24fe7741580ca69090435727263855376c6cabffa14bbf2b6aaf77bcd786f55caa2610c813dd1615bcbf918eb951f09a6b3fec932d2e8d6b14bc5f008db54bff6bcf963c1208130e42d8ef7ad23f347434baaf79527e3773207745d6206a45b6b92bf98ba8fb43ac74ba6ede1099d93eb3b644beaab98e75b09fd29e3df5de386b73a5483cebd9bf802d1a2ac9d524f2bc06bc330b036f29cae9724e74f10fc15d1258eba62a1eff9fb8d3fe9b1e6a93b46a7c13759e75176357961070a3f2896e08b43291d4944949f92f5b5fdd4149e3ca113819588b2be3cd266ff52336ae4eb9288167fe9bbd47c61ed10d45cccaab5c913651a58ce541d79214909adc53565805a751d0fa2785ee4c20f810e29cf405bb40ea59e6f2ec09ce8a1a661b8b29005bf0deba575e07ca47763a44442e05679e7aa13c8e2bd1d06eb9c818d3e9ba971c59cfee67e433e75a9921fc58d152d2e1954aa188df5a8c5f4128bcabc72c067ca022e48523a339ab431376d1f641f8cfa993d4e7a865d4aa5e50ae73d11fc5d67b80c81aa5e51f82489d6c74510715cb500f0cb1a7cec050612f53552966b1784fd1505460e0b81bf16892df340e9da54d3c487a40cfcc8ec75b13d216fafd276cb1d8bc4528e2b2b70ecd700049541c4f05cd31b989109a29e6e3447129c5c76d9f5f67920115c8ad12c411496dbbfdad0c429c1eff9b3ebcb7892952a105c61ded5b6459c6dac8a9ec4969f717ef90dd71ab26fdcf8f3318f9e919d5d79e73e660314fea1227cfe9b93f41bb276e64c0b78c47dd3fec8168e331ff1d0fb815a07e33ceb3909183fc73d660cab8c5184deb250489cb66f9c07c64f3b6a0154374a17ecf855b5f39ecd67083302cea57b530687087982c14bb9c351c5a56c02d9c4727435119d3fe5ca593d2e65a5932ddd107b2ac2252f828596cefdce06d43c81091c2d4b933b9825d22077dbc1dddf61ead7bbcd80588161854e21e2ed3cccfa2b630b26652694339ff49fccb498efb6fed65a53e119d664e76c6d45e95c6d32f61d4a11d8666a3f09b17223b6d5c01a2c7509431432ae41baf77ece89e46d3c0ced56edc3a2a40920d4fcae06cfd62f63c7617b2012bdac4c887d5804921d4d07d155359d1afca0b5ab94dc7c95b91abe3102fa7b25def3459a86804cd77c8a10eaf7dca43ac731ae3680c21150b05d04bddd894417a62e44ea5342b4d4e3e519a6e1eeabf62f02af511b9e754e2716eef69350f560ed879d41e5520553e4eb019778e11cae77991cfb3f06d8e46666973a9648c90898d06172709b51d77b46902c5bf5be9ad39e27cfeee4add830dde00ceadf4fc85693a947f95c14f74f4bcedcecdfb8ccdaf02f59fa0f1808d172af662a66945f8891a442521d425b7a4f81cd777b06a4f57409bee58463e8016ad62bb35c59e2fa02dd5cb3a55e375c6fe2c4a0c934a85a5eecdc90939c5fa230dcb938867b759ae6baf309ec5e883a9d4710a7649a899fd1de0f38144b95ec877b8a79988ef8db83331c883a9a59fa067e5a6439f010dd0613169f62a7b422da11ebfb43e84f926091df1044079131359fb80602022d3b49084b72dd6b4c79df65311de61a41215673f70027663008b9c66989b0e9038d39ba88d8313ce10d63f973997a69961ea0762151c14ddaef1238d6f3e370162064e7f085e61f369b70236e96caf8c9dfb86b4647b77bbe81d2ba038b62bd40477fe0e103c85c20d84eb46193af1f8118f6b6742df6456c803a929e82e0908b8c3bcdfe15f4cec0306e14289b0f07a739be4a36f72d33b643fcd435548aa78e75ea9817f0ab0e9af1be12462fef81b1deea319ead8b8d96649a4dd9a4baf92729825ff1e5f63c4657cd995b8844d576a7d8379717cc3fa8120ca9ff0574e6bc8aa7778b6fb5ff7af89eaab7b176a605aa440c0b0459029ebeea75d59aa27ca4aac1758b0d8857b613cc8c0d81c3d920f2396919dc91094fb1701b2ce1351e8e00d3ab53adc7e79a098fd94aa8bbfb39509a9c1640306188900e5564d6c78e5a5722d181bf1853dc8d0a291f19974d7f07ea0cd3290af7347e1b8b4b77dcad9fe1c6f801fcf4f855be7143249e16650df6974eb5184df4f86d845e49b91831c2018348296d75534c49103fb628ea42fc0f539d70fb33daa90850e6a055aaf02cc199c4f9c3fe7a69f90e6169fc84e9ee804d47596d3ec481a8dc07108d88ab62606ec0e6feb685fc7409ecd26b73dd57df956d5d4894f4101e7a0fdb12f2530bd898d2d5d47dc4fe4d315cb7daf7e11b4d65ccb98b69dbc197aef4411934e71ebe6e35ed398abb8198e429790ef85836ee2903e1272f9e3bfb6129726c274ecc6d5d745a939383d595c81adebcb3c013c646d57b7532e46d1963cb5d320d94196a25840b085a99370ccd0e53830b792505de16bb3cadf028396141d09fafd23db9fea9dbdce1cfa398949f5f5063e7499768e82bd56336623adf17db6381017a24ff52504f05d7967a45d9d730f5be0928707f6ae9ce8093a1bca6ab438cce20c3d76acd2dace931bd430f29f805d09a26d989bd7151e9d5cef4b5b0fa88ad654fc99f9a038e852c9d4f973661332784bef9923e598c5db7c706aec95ce0763dec9898a24830c99d542ddc5f2185a98118355a27ddcfaf328b578aa160015d6cc9607125390f4a3e4c72d271d3ca69496cf2f9b848cbad5ecc8ca98f00e529c0081c9f4f658ec59f3c84c2716d6460a5ace0c2c2f564c2c06dd610709dd43fcc42a6f9e704c92a6570c3fd94238ae3c42bfa0991309bbc7a4092245e2a0e2e91ae628c9f481e9022a2ac72b93c0a17b9b1a50061441ce07cdfd2b914a75c60dbe4acf72a402dadf350c0c72764fcaad66ba10d8f7f415f47d07b928d25a5146b855a1729045d9890e688e8cacf230bd0684991f35d96fd41a8a0add0af4a03969701bd7e2468ac62decbe22cb88a4c323d4e91f1ab95420c7f2c7fbdaa3dfe2da32a06cf5e80c581978c9253d60d2a91243e79ccd823951dbf871393b9a6926d54c486b6b5ad540d80d6a299d7abf1a6696e8f4523b7d27ff76a281ce867ef3d7490fb97d655f6a449369c986582bbc94fe445a6393789f40f5b82a92cdcfe14d4fb1ed04fbb1d6f057015f74c15cd15d201d48b00aa9407e27392c7a654110f0c4ff39e9db3274945c04a70740f249c3470211fc59d1420a0e6bfefac66848d746472ff62f738c8cf760db5d8507a16a3f7f0fb108aee0f299dd7d30486377039dff834825a8b177061fd8c0631fa54438de84d548867432d99681f2fd0b3088ac57e5569d2d5bb06fee2c0e3074c5ccb0e0e6f3e605d11f12388e8991748fbe3d92145a977624646996caa36a47b2522729054a846a49cc05e9ccaecb7001ed2fd6ff59d1bf724c83aa8f59cdb42a70c1d436f2fb2c380482411f25562e03f0786ab909a3c28a984b5f4511218cfc809ec4898142d2aecc8cfb272dfc138ac65185864759797a2d277c3280e7fa8e9b2c92b64b4d6d775acc0f0cf863b753a9d79b757cebc4d49d05fdd164248ad715a705946e44e66485c49d11b60c86f85acce1966267aa05947ff6693ce30be9079083fa3b0d04705c99bb4a3858639686eb1ef926218c839a49dbfb3852b0542ef4ffeb51d490f00b84b165df63c480b6a8254e10bfe7681430948a226595ccde8dab053bc1a0b6e9f704a55c6f0610856b9a0eb64e3b69b022d7097d47781152d51dfe39f546de1b6f2663f4f7a1b879e4c87bb401acb1d467c7adfbfeda312fa1086a0647967cd30d8fffe27b34614f84e2d63d66a11b9185572c5d07ab450d863b806fdd01e214f8564d5dea5c95c5e26d78cf5ead8be631737f69bdf2fe25f2d563a7dd08258adec68c301100d9eebfe346573f8178d2b533b2a390ad5db038cc821d62879fcc674b7bc6c9b6cedd1636b0f5281b36f7c4c35d9903d8a3c56f0416207008612fbb34266f41ee3805dde2ef43ecb816c259812befb21f9883d7a030b069cc6feeab67f5f004bc11de60f56a3ee0ff08dcf255924442b91c2a041af3568bcc7a3294a3b70b5b744b59ff9451399c1475ab9318727568f4d6468aa58b0e013ecd22ed7edae8c50e7d1c3ad81198e571cc9d8dfb2396c9f1708c27e3e859468027069056bc55b6c7fb00c611436d12810da23fc6bea6b5a7d25425194d784a3b74c52efdf8992d581889be0ec1b4ba220d95273824d89c27332381958d807e74da4e9d2d38807e5ecce559a9ace63deadcde0a83bff82336f2d917dbb35b40010d27b315ab9b2d19f9187c87c928950fa1f547b82c464212531ecc9f8ab49345c17653b725a2545199d9bd2490778259f1735be29ee42e30f7c3743478a40628cbdc765c419b40dac24024527f3be3be46a52c2e2b1887328e60a2f91ed3ef8f7fbe400dad3901814118c75376c60258a7da7d66104b1a2f1ede2e2bfca829c9d7e641c216ae7359d890bf7f0c50295160bd5750b668def5a86049e90143d785b1882e703efc0cfa106b3027ddaf7d81291fcdc5e90ee01194c70711363718dd312a93a6dfbe67ade482052b4e132f7f016df9a1c80666bb6202d04aeb17581af867b18d526e5217dca80ae9f72d45a16878ac530a7557bcbecd0901262eda0ba2279b298f3504ffe8ca204739de09ac5f4641ccda37ae478e29559efafb5bf16d0b3789de5f17c7d84b0b80d9f388cfab0d33e85948b8b23fe930a7acf640e0f709d9a81b9ca1195dc80f77f9b65558b52b417b33abeb94032e78b67fa12fcb89337c17765130346fa56352cb916fbea26892ce7fa9134d4064fd0f10cbbf83c28e22e5e4acc3bf5b96bbf1ee0efbda20209624398e7574f355d5d47c43aa0da4ce06d2c60b7f6e8b6eb6fb9d91ee5866945debf993e2568d0ffc73db15240be8b75a136f429167f183b45ce1912f4968747ac35b93578255048ba9a0909d7e2db2387a887d2526d4475bced67f7127d3ecdff82e7326c4370cbe36f9dfc7abb3d1580876477240c56581b7b09e07a7e3ee1601c1b6b9ea2cc0c827e5db9b16ad850edfa3f38ee26b68dfb590d91c555dbd5c8194c0a50d618a29d777013de7559b10870a27942ad4dba754fbae8e77012ee97a4c14514b1a62353a725127bb21d8bef2d613487836edd9661eb523a0c4ce86369283b5c6167e9b0f4ef186e4652ec16f462b42d51a268de03910fcc037a7f0abd26da6ca53925b99e842f898aa4b0acaa039a629e42577c7642b1e054f318df0417d1d254d7f4b187623b0673d1507bd785f8c22add4d76ca3f55fa84196272e24d47d0c7b9269b17669a5b11417f25ee413950522f1dcf224a4b97a0655f8a4100ce93d03d389a8d4710252bbb0b9d2c37c565e3c2ee9e4ce007c9ffd4211bc433a0fb83f1047635dc70788d83d9288a38faef59cb2957aac2bae19811ef0de0dbfaab2d409544bccb9e867b2e6929af878f08408423eba68ff6c02b214515e3457a86bfa8f11c0265c4d579ff53d09bd6c4ea25cd5bad18e7dce152780d514c96943ce38d0aad35b148286df3082374ad69f5950db93d062fa4a8e9e328928de16991d3963b0241178e50a67c595e28343cd9a7859bdc4f422e83c2dec1d44ff8c8a50db4ad668375b39240748e975b671d8574d390cec4f6f3928b86398c6eaa2341924b8c40b5a598ae2d4e3c25b352c734881ef92e3c2e69b659e106a261204512da5fd989761a976186d2e02c1afcbc4567abd9c57f0facafffd3e63b5e15b40d8a4bb579167f8abf1a397e681b4916aed211b9d8eaba360998e2613c46179552b99508110be05784fc7e88fb493447d62309361f52039c422c0f2f96456642892f1453dc9dd67be0ee8f38106a02ad172ea800a3444d07b5806526b1a78d955125667f91fe367c8ecb4983420a306b32349a46c61a4286adda8169a8c165b4c066aac2a1624ce0bf13798ce57096c84fca6f7e04e41a434f0ea4586c420bef343b0a6cc8e769fdbd76a4202b366b5529a4b6af531ef4a950604e14c82571aef64c55677d1b00054b24077701eeaaa0cf8840b9a22912351b39e3edccd4d762179b75a12ac8f67cc8960d25295e4b8b5985b0b6910479eae1d31070ade30215bc890e31487f2adf451ce7e83384eb39170b96143f505c88ebd39c7856c423f61ffaf32a393c49892076fd583c9dae4d4554d1dfba9e07a43a2608fe9ed1bb37e913a20cb6f4183c964c0d36c11d920dbcf2530c68305506b4ec96acdd5402a742ce98a599de47bdf30ec79ae8a172debd8835c7142d09226bc7c05dba7f84bd85554858980a0b9f1fbab0a49bf29ad065e69a69a81267a238e89a28c7521961a32973f017dccdc19bf4535dce38efb0a4ae00c4b9de7f58ae3a60df867648c8bcaa3812c31a1906a55acd4fda35c03a396fdbc7255a06f261f92f1ec623dfdffd05f4664a57b301246a57a19bc6a1571398aa832f8b93c95df59f17fc22577bfa6b2a2a1c5cf624aff04c859b57b4d84ac4d9e70fc89990919b88374fe9c377b11f6f920ed21346c94ce42524b817f2c864a4fc42e57d7b74336ece795d39e36884197069e4d4086d2ded007ec8f455560888222d440903cc92fe7ab675e6bd0e03b9acb3fe58b568d2f83ea796dbddfe2c899b1de79bba149b3845c3b4ffd4e0c1b69f9fa41a85cc1fed8339420477a627b21b94eb247e105585a8f278b8a8deb67de4c2931c4eb88be0f324d296d5a666ef5e3213e76b27edcacb7223ce7b6d8c08f00d6758bb83f753f67de4a3d7d4f134800a3f430857937abc23e141367c37c834dd5607cf2d5cccc4ba2ed209b9c3a413002df9dcf4055296be8c18f05c31a630782034b031a44e24ac950bf1c71914ecdeb26e7cbf79850964ea2515b3a13cc24727c14564608f9ed9753e8bb1da9692d1d7157be0fd6daf960b274f5980f4a1079531b6ac4c1c188078194545ee262315cc0ce9884eb01dc740c340364526659ffd4c2154b30b644f2b8d2a6a6b52493bd10527602df06947a9d5f4e3cd965e776953bb3b989c5367332e33de68547309d160eb722d247740be03265942283b64e7f690427891fcba07c9879d713b7e9cdcdb87ada2cc29cc976d5dcc9a41c4d8486d376b007636ccbb93c13dbb785576db885e6aaf2031dac999ec6b6a63c7de2207df7c3dea20b7551716616b49d3194f3d276a4b8b0f230614dd1ad2cbbdb05544ca0bf63b2fba63dea5a38b61a262ebfad535b498cd20edf2099a8b6616b17b18816395d029279b17e3e3d1bf1d4b1b20120beae3e4bae0d4f9e531c80163ec7ef3c80c16d8d322d876d586b4f748af02567a51f6de72b32a046b54b01f671444b4cccb720c8350798a0309f60d37c4088b9e774a55ee28632f919571b10c596243dcf1919437cb289b12eff98131c59ada35389382c4a68ec769354bd47964ee70cda751e6bb554ab882a783991d0a9b049caab756d66545739339c69830ac0d00829a428e74c437e8e61f1f058bdfcffb7ead297e736e7346c675b01df52b39f61fc0e6009bf550953bf5d8d33085068bd813af5e61576a4e618d803fcc98f9373375b2986ea4fbb840558f3efa121e0a5b0cb166a036fe21943da1334bc30199569da1c8e2378ddc6f766c2fcf746e9269f70edd60c2e72b38c10953c8ca9a480774114b287352f374d21372f9037d1cfad608cf5b27d7e0600b0a4b10f45aef71c4c7784532a8572f64041f7cdf145968fcee51f021193a75c79ebce89fb3cc1a98d7951a985d4dd4de594bb57b0c07dbc3bf91476005323e2801512b1fbffdcae91a808715f084fc09ce0dc341c0efd95dbd0db1f8cdce07b7006ec4d97fb78a680988b8fec91be8fd904d1fa399ca54fa773c843ad6af3a407a7384c5466170b62f85061dd4f4ef7ace10873fa1b03b6f705a203630e46a8cbdaa514ad0db2898a27355b7779bfd2b8686667bee20eabef0529292025aa10efcca1464eb3bf760834f6924386c8ffaeab07cc4a9773d556a00c308039e3e89c2bbed6c2f44d8188e82856e693c470e27929e56dc86ef53fcd47e93eed6bb971089e8f5a8ad6abe358d025be5afcbc491847f7b41286c5e9f34326247c99ae93ecf78df721d8fc1367dc185519ae6ce40deb708d4ad90ce57b34ea92ced616f3c84e1a50f5561bc4e838bde27ef4125f20fde1dd9231cf6b7833ef018fc497f95666a71cf26a22ff0854448abb82c6e4fc27c86bb21c4dba876fde16154426f8c45961fdad1f4f06e03b939e14a5f314059dde4d8f1ce00ff7d1ea6e7eb55d1d16450754530808f4c996810a72a8b7128893b5bd97f847ae4ea9d98e1d52ae2ac2d2f6acae4ae89eda711d5f3924c1486eaad01a188c8a463ce133da7419716672fb4892bdd931ad36c29681f6faeb55d15906b6dab0c2bd6056293be93b6cf73e690bd36a08e9123192c71037787be533777763dea4618a75bb81930e7e5cabcb06b06ebe176d2e3f2f3514e30b554e86d2c7225a2b02e77126800d897f72d43067a0ec8b54ed54f6deaa7432a0e046780a842abf9192da7a947f22b7083e0d346872c57acd0f06939b3197c317384b4c2273e42b8fa51a6111e96313b3e1df764acf98af79a412403bede815d29198ecaac7ffc2f0dc45c3e6ecb355f2954a2b25e93bfc466fed956460f97f3243bb5456e1d2d99d482e200fe78f64b3734d589d5a446cb838a82ab3830a38b166d534fde51a35e796360d69e3ef44985a8529cea2fd72fc19a5fe5d8f7c48d75eced54d177f86577531e4ee770c9f8946127ffec684afa0718f46d478664d753e5b8b9d0f0940af3beef72768d23d1e089f21725955d6e42464c889601ef57db3e75069a16713dc0e815f33b7077c66f74a3365f11b7274b4ddb640bba2a643940cdf2bb21b3b5874d4949b763355ed8e9d1208f28473cbd3b961210ff235d84e98af5eefb3ff248b33bd4ee631a321e01749493e792d1fe579640ae0ea8dd06b048a4e22e5cbf24539d7d78338d6190cfecf171c96dc9d2a1a8b23044fbe3890a923c6ef04c0db7205ae753ba7af48b5d1e80b327c38abcc04441d4873acc73bf0d36b086d2f3a002fbf68b954db43dc96f59e27950a07c93e3ad0a9ca97a005448afa8ee504301559171da41d12aa315cc184a643fba4cf723322f15ce71492c9b76cf7a94476ac388f7060e5dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
