<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9df8b9856eed20ad4541560edbbf19ed234c1d9fb5795929fc7026a5195f2a8da16fa3c9f47992d288e19a5ae803d9ab16f44bafaa5dc8b016297b7c5c31307180e6f60913a5844708261ad9f8ca3bbe4690ae9bac7468ed156a271342dd97d08236d3428824aae73683da793a1d3332a697616c2fd3e74937912636d83570f9663c475c33fd6422c042a4197cabdb8edaf14c2a5e31310fa36e93d7e7edf42be2e54e4ca274498678b145bddc96dab399497f396669b6668b3dc11dfdb27011888dd1ea82ce1f44d30dbf69c6c32c4f52c72edede3775000bd06a99f58c0a45dceaf48c3e0920ac94b7f2682b1b3acf4cab3021d859595a7397800aefc9949e5fb8c6b950b26af92a94c105570ef761e1e15aea8f172b54fa5e0710037ccbda295ab8f734944f4c99d57107117c0bd6a38a78d66aaa7aeb5b7a46e67e1ca63c02bec32b2b0ba6a2a5f42e4808e0a539942bd58ca1f5a236c22a109840602d4d9fa2111ac026d32a2e185d4336a96b071d24dee11f8113c59fa950d4e8e2297a8d157560bcb9a94284e48710dda0414f5e019e91ffb1d504e0c7befaeb674f460dfc40ab5d75e3ff0c12a00d438a4611f8a6361914ce2828ba25b40951442c7c6bdec1fdd915406de61550c2a7e2bad4399bdd6a4855e192a0b4771aa54b5518dbb300e6cc2116c45e659409300ed6ccefbdd275b25481bc2e4c66aebb1af38fe4a5eea1e8a1eb6eaa7c3b4045d2cbc6866322e8fa6ba8e64a88e7434bffa6498f47bc00724f1314dc350bee955b15c829f815542651075de6f3f73a0df90f7b16d92ab3fc3eb8dddd4a93001be794566add80a5b21a45d06db08461569d4cd878724294d09e3066596b995a647495b99ed401ce232e4c77a36307a75729af68c2e88756a4d40e5e9caf5019509e038a6f7408ea314b0361bccc71227f0c0259b02165553de75939eca16dd1ab9fd5ec8f11b660610f9be7cdb550f28f9a5b9e656e4b295a41d2022c7b22c943ed72e44514b6fa287338632572758aa59fec6b26bfbc9216d3843ee72b3a3ce9ae5f127216f768ea35e56042398f67cbf25881180eb8bd8895adcafb17a8d6b56f77b7ebdbcdba40694102ea2f93f852bdfc1ba9560b74911d19f52f5c23dfeea46250065d6b588f5fc829fd084aaae064bbc5ab99947ce5651fd4b0316b6c2f1e46967e1b785e82c0b71166691d29a9cca89f40f31c31d0da26b09d79e8279b2df6267ce1dc964974f681bad88b0c69f551d6a2728ef0e585c8d9a0832bb99cc3c0ebba15b14940ff76f19a29a88690cde05c255121dd8dc6ccfb3ce2484ae82f5c091133332488d321f26f3f6a9507bf7e56078090d0fb3689f5b48a03f58a3e4031cc9c753738c972ba869ea69876c5927bddea65c2eccca022746127c81676176ab81c46398e455582ab18fdb2c486fbbbd676ece558bdd403fb811608520dabc0fc92e2e39f1cdf568882826f83e6f97895ba36123815ebedf7a680356cc45291b22e4149a59b5a3db413d149d81bc546ed1e9187d46ee20a8cf27020a4dc7630e488a51fcf09e96a0693677f054a5379bed058dba463c73f58b57c631abcf022eacf197337fe2254c0677a9a0af047510494d1548b044e172e021974c0addf70234c5aa27b60ee48bed637e9e31cae4904bd4419755f49453e1e9e2aa16123c2511f8e7aa41dbee5c076efb3c65094c5505684da66a1acfbcd6dd11e07a3645ceb7b46a45bbdc1303e872de3d1df8782eab1fffa4b2d2ccc7ff57a20c65f2a364c645e0661496c50a422bd6eefbab2397d12a35a106a73349a4ca1a9d3fc21e52c8233c5bf91d595643fedb9f4399133a78154751e752081b309b8987c7344a9d3e0f4779b0f3faca9ea0e1499bf88e2d3d4f44cc4a8fe9201edde846a18e46f9d1b555741df2f41f69b8f094d0a5d50d282bdc72a8a05d271e41d2fa49ff01df327856769e39bad1580db9f513c9bde32ad361c2caf7b3b2e875a7c05e0991a70251d8829423e89aa4f4e8902cd27749d7b53c39590ea0c475b3285dc0853fbafc5f53f7e1e95a0d01f7351a849c87639f11c61195c322e8363cda590baeee64c4ad7103f943491f52f4d1919d91e1d86dc175adf57edaa4e1668e49f266bfbd241da5f95b234598963d26e19514432309867944b0150b2f363d3cf253ca987a059fe3756265ba1f12addbd94b37e4097fa658eb38bb041af6400b0c4fa150f6d8025151e938d8d241a754cb0dd55784003f5599fad1b168eddc8bae77d8fe7207f02bac1541a8cb7f05efc8e6ace5a67d8d1d907d66dc15233d213442a77c9f06fc915ee48e24069437cc174190e2fc8e984195fa6534d03fc7f4c5d7b9922c453e34aab000b8b4f7fec0108cb16f1f560ce71a3154ed623e81a448d366eb48e29927a06277bbd58f419b820d157aa68cef7ebe56b7f8bd14da6ffc80eade9b78eeaddfb0a5242521fdaac8d5d57ba0437afc00035aa2ca06ab5385dc8454a4adecb3c7f04982c27a65c1935676ce8d3e4ee274736cb0ea86aaa145ea38f8e726c63a3334c403426dcc7bc6bc8837b1827348c383188f3c0d7e2cc71e67a9fc7e3b22fa7b3949c2ee256700821f84a96090d92e827b13b179b2b9b3d9de5fccd3dc65bc21a0690f784b07627098ed48403c1a95a66e0a0af90e8b763bbaeb01ab7413b62c51b68f33fc4532394c1867a315db0c4303de3708e5d7be0d97647d7bb673860e9c52a2b82a99f66238904cabe8ede407db2263d4251abd053a0dab4a71e48dd98508407379eaa0d7a466244abeb3695d0fe15ac52236921ad8bda9533a2b8b9ae256820233c70393e37aefb20d637e99003a7c7e7f0de32535a3ea028ddfa006dca4347e80272376be78366766b2c276dfeed5796f73e4e333bd18f881049958365eb1d201d9575381dfba6c2ca8776a5d4ef682dc080f839db490775d0c55db2968ba9b3478152edd77286fcf81fbfea91e80ef994ab93b14fbbc1d99af85f0611d600c1e3696e08bf48e694c5e913d60d6a867ca336fb2046c1bdda3a4675f7c51bbc10a0efed62e8107ab2b328356efc18b31d598f6c096bcf6b07cb8d9b6ccfcf60331a6a50b13c6d17d213f1d6647b8cc95509dd34333785d36adf7524df199f66e50c3e150f0deb9752671bf0f71ade1ed8ae0323ab9bb8c6c931f494c432abc74937b34cf3a24c70745a800ebdf3dd06e1fa3ddc57608a7a35b734409e5d04ca672d096eaa4310d695f2bde81f859a92ab152b23fb8d5f7d91cbacd6116f48bb4bfac0af4f16e74db0f5252c259e28b691d77590180e664d83b4fe12ec3bfd75a52bbb73e33023d8b1c1b6258851487e58435e9b4102d1ec2bbf454d8b6c0f4527e680db08531b40e09b813be1b587ba9b79f1fdbc7a9e444a682c1cb07b31ef814da72637c0bd59cd6d7bc0d679bef4d6605626143bf7251c8c95556ab7e20046b1471c3d91149fc00cc6c7f801cbc55a96ac34cca69706f7586351a6a933176d426cc505d85de1fbf0a91be14cd7ffb37299dbb87b13f3b5d1ae05d7fc141c9e29319e360070573553317f1c5c0a66e6e73d869094e0e35952cb6e59944322249a1592f84328a8e74ce59a4e56f89884e995b8f93e86f5bdb048259874369fd6162a661cd049deada3786f2d954eca87a1df5fbd4e431278cbc6e2db490b86dd78fb06ebe9671570e7262ec00af7ea4942b5d5367ff47276d1bfd62e5aa646bb3907c714d366697766e01b401ced557b4dabd981e3ce9dd912eb6e81885ff8d018a5d931607914f7096dd04f1011704362b6de9f040ee8f1b91c09462ca2b881d613fc94fc5180cd0574644ed3d8e887944e7f2baeb827ed75b9ce23e686515993d1dbafa963f64709cca8262c6e2d046cdd7ce440128e0354282be9c984e3ff2543a5ef08266e592e665b9610832611c2eb7f3c00f25713fef1cfcd8559bc877e5c98d788d90301bd16336fca4521feee0e45c22c511f7169feef531bea125ae20f68a3c93badf866794b75e1b448eb901cb4279f805fe985c543a91bdc4697fd286a26435c15b9e0e60382b72dca3a4ee78ce7c59a3c2f429092ae7bc230d14ca3ab5634dc1271b63dabb1262786b035f345ab04fede0a9e870dcb565323da03b0e082d7008761fb84e861b7acc3e03ddd15eb9ad7db1e029d8a05d52a13ccd34ff6e01017fd638bec909ad082e815e05a79b117075662b87a5f2e7b0635d8d673811bf5a374dc10538e8fb72f02fb9e8904419befa4f60edc65bf8e4627b7c458b2d332f1f3b57d88bba01e21593318eb4f408ae3123d7e17a990ad0bade60fc0c2c61226236c7f0d97c6e8548f71d735bac9fd3571aa97a6972097b3b7fd377b3da09e8ab50afaa3ab0f664a4ba00bb4b5af2b8f53a5e07e2e8750437bcf13946ddf577fec9bf67ade7aa37cb233278199eaa58357b574136904ea1463176212d480c07c50a23f136a615aab7fe660cceea8a91ba9e77a102f6ea599c91e9f17eca8f2c53135027fc6c33b7ba58f4ee9bc57a3d64a8c64b1d4307c48b8399cdf689ba7d5bb1f236e0cd6c4f92307f33ccb23e820bd7cb8caf4514325039bf30033374c249b1def6c7dadecd94dfcf0d979baa2b1c08ecd9ff27fea1284777118296d849c50e5fc97ebd10e51634de0c0f20a3dc2b7073bffbb33d126dbabcbf69df236bc103f06cddd681eafee2780902b89541af38a3d6fdb00b505b9e1e278f15131d1494beeb48741bf3831b21fdffe82d797c1360304dd57122a4e79182cb63a386f15a0b3d1c945f3722457bee0a6d72c7ece3791e972435664eccd76f9a7d52e828609e22fffa48c12d37f6a70d8ada0b467dbd07221f6aec90feba44f3827e4a806e2978dc2a4d0753e8d98685ae16b7c270f6a2bfeaf9d4c8041d3fc7091d8a64b627f4172ae136bdac8e32589fed26a3b571accc3a1463c5d8aecd98773521cc47c4c1ddcd97c04a860e087d2e5478d7a2643acfd435f77790948f416288365c834c93755aa8c04c067d73bb4e799357247e7c05bbb1cff6dd665a31a7bc94421edefeea0a2d84c0e220d617c4e8347849a6ad2a7beefefab29babb3ae01ee258dcc6c8d37422262c348ffbf412b9dbb4d9cf4929551b6f0a490822a2269f57b35cd9091814d83728217184624a4bd23f2f3142172dbf5c501bf23a57fb7ed68b12e2a36bccae683671d5224b53613a16641bbc231485b1bd849207322631fd216352d57cd6e13fda5389882a14080dbcdc5af3205a48fb7ea1f96a972a2268a411e273713fc57b9157a18b039c1fabd568b54d7224b5bc1f53c7141ab67855149101a6f111041f4e97bb88eb2201e25f1bd5bfd15f2d9024dd7e4954979ec5975ee91e5353de69440a5564434264a48f79a1166898300d17a9fbcd789593a850852733f149f5119e2b8b151ad2922a41b1a06062ed1adeaac55d32fda3edec692b67d104f76459f930a5f48657e0345f7c13f8735fef0cadeb6f627043f5798c54c1e036d99c2a633632905ba99ef1f51eeb452727859db27f0dca395d965a0f5a4ea3aaf28dfbd33b8f6127205d362562adc231b6a1b03dd4f42d54af71054b455ebdf6c0181bf0f2b7f319bb990866156271b5372a66e9cd084c62b786f441042e1cc96cbb82c2229d877d67700412e174c1c48979db289da82dd3fd87f9174be7e241ff5c046f5e4b70dba3225db892d305e03186d13905c51d2d4ae711271c27fb00fc9d8f1b2dc42c7e6e03adf690191362f7020bf616f908493626f66d7629fe656fe899afcfd1f945f47d7616e689322815baabf5980103857f6534644f10513bae4d555145b9c80663bdf5a649285b3f91697d408f3b05899f7294e3811e1cf1d897dbbe834a0b33dfc56ede9375ef138570d989ea2dfb10860097e255633b79dd1e0a5e8edf0b385f77165cfcb6697659d7ba24c4e5d2520cc14bbbb3f2336c3acd8eb17b4901b92e62d538d7baa63256094b5ce2432db915690e7e2d1d0b5919b791e547d89641526e27396999f20e04bba1e1f22778ec379830543a77ad27d0fc54d2d364c2e0c238fb47538a848f738d2f7580355582822d6ddb8c2d852c5bb543a1888719a931732998c62a7078ad5707a44d90123e00a42a2978dd10944eff95f734e5bdf43007fbd72473aa3f1055e43b1483011a00c8977c91dd20bac1d64292036ed8a4a00bca862a699156ed70528e7530ae3e0b253ef2a9efabfd87bc2a2b7e4b68c3663066b9bf92a655a79e1a07db16074d3d159dd1c73461e29307ed91150ff575dc222bc66288b3645e11d2e232de6d8d3347c8243651032b14a19c524265444f3294055eedd91dcd5ba070780dec8361dbc78ae162cba903217a61f136209f80527fd1ecbd663f559ffa7049ab1a539d5334bbdd402402d131b22f6ee8cca61524fbb6b8b2da9ce5dd2cf044a606b2499229dda0af1b6903729176070e46c45b521a82da6d9f9f10ac4314dd296e64cd33b5b99bcd6cc2e7822b994c108db675904e43ad1912fcf738c497918dd6333a68cb6ecd31a48e7358941dcbd602b26ac9d54c732a0135d03523c00152f538d0fdb3b449ff36108abe573f874b10ad16f8660844ea3687b5eaa6f42c48204eb4299def78ad44cd9cc82136d865f7dceaee8eafdd1389d7f41d38b2db5fa2b487fa5c13357c93ac2f985843e8bdf417276eafe570401fe56d2915215ea6b4b6a20aeb20178d5111d20f72c767aa7451eb347cc07b33de0b17f3682fc636afaa325df4c7119bfa1d277a29b3b6e84dd741c53c2d5c2412c3da6ceeb7cb5b45de289423f2ba5a8701d49e03c98f2d771d73e6c310de728c0f791b2f5da3c681de4a9e5f13bd157ef302c31c072fb2b09ee7ce3c8ab2c2eac1e2e234d5b72c301f706607cc18779be873f1decd0d24e19de18e55f320cb6ade1e006b5599e6ead7aa0cf2562febcee7cad2c0428ba8c28f0d04e09ec588741fd4d73ed47d20a95aff3a6941980fb2092b8d62676e515e73e646a9e4d1fbc231c07e28d952d92e9f51dea547f161ffe845aef47c0e0821f303c6254a0b54fcf87a019af88a9eadccb2167aa3ef7f7a5d41e49ece95d2c8a3c64bd24438f1d5de3ba584ed55bb50f814edd32c4991638138435bfbbf447c0fdc01d091dc106a7f6de5984689ff4c7422aae3437fca29daf4b951f6f6ef79061c9aba2bdd9ef0b5ba14b5c7f4f0c7521e40aa88a652d4058f5d4c415adc4e0fec65fb6a06005c64bc39675fbf2ce8882f009f38698b25325a64cd1df46c87613360fab4bf8051e60428b1021ed753edd053c8e3a90b915e906b96cda7a692ac3d325babe000ddd8532c080643e311b8572e1c86b01047699535e5aac2d16deafb31eb3752bad8f5830b9b68acb35e16573a80b2680eaae0c2cb47ce6f82da8cfec6f5025e48ef28c5f0959846f1d81c3e41149d84334c3ef55511f0e42ad7ee2dbcfae972fb89bfdf3431b350629cace00f4e0939a06702fa41800fff160d8d20ac386baea7a8f686c6ef02e56fce8fda833c1b1756feb5126efad7c0a341f73f3bf442e772d151e747ccdd6ef4720fc5712c5b9e21fe4d118b8529d427caaefea27fa0fcd7ee1d96c76adf8ec0a5d238d50bba48b1beab0236eff9092ce8a5f288342853e826313d19c77fd4dea8199481eee1f732bfb5db3284919512fb03860b5a346681faad12b8b0a8893a3578ae1f60d07a08efc1437045e673bb2be1922aa1dc6f2378b897f37fd367a23eb677216205a6582c5d136dafca7607b2f13d8af7fc66cfe4e0849b9afb39ef1214d5dcce8bf2e65b547995279e44494460ba1efa11f9bab280a89747ab2dd1757065dc2e204aaa6d610e917e0a3fff8a900b9b13362f9e7b6b53455a18e1cb8d265371306ea145b609877aef27db69400bfd0ef38943ce5e26fb7d14676f3d47b56437d3bab1445ee61465c503efa3af76e3042ff50ebfdcccace47bcadc58047508c7cfec85b4583c3cdf8dd1635a3722513620d58e500ae93c7913801a86cbd580dc886e8a4555d1f631de4c88de5757ba3c6bb802c4764bef5163ad22be030ef34b83b00ed5713c5031ff2fa2a3407199d4501b1702f33817578a79460fa3a92fa9eb8a9e5130148973b00dcc5600c997b77537b1c1b5484a8787f8e6cac7e4c2677574bad4b722cfb5f012c7fac69f7c93c70debf47f0f7a2d928388d38b511611cc5e6267e605e838c765b62da3ae3c449753ac5b348e75c3fdaaee7fac2b007a331f9db844062ee5d118bd422ab1b7bd230c1d75a0e3a23b4cd1a00b20a3c6016b0a7af91a832aa4cf2b1d10c06a6f394054487d81ac994ac0768bb0578c80a9d45340a72bae3f526595271cacd2ca446a4baa3dbf6e3501911a1a96bf35f6c16100beb3619f110b71412e2dc877b517bb0fcd070739e43a7751977428c0586aa25e4967e634c5b00a56c35479d5bc857d9a21be3a3d384f5fb81f14901e4084ce2fef5856ffac39f9ffb517a7f5efa5ac8a28bcfc4a85361a86e8b094c655a30ed4636be8568b9f37be6ca7c426ea2301aff0924a86f99d92e151cd23a86c8e94c3d054408efd6b9e039b80e830711b329ff912a8a8a6a63c4f87c9e4727d8c7c724f7a9a91121ad942e00d9c8e4c9a3e204d85107c342bb84cbb7a909dd8440614a5cfe178198dee487d5602e25ce4748b4b1d0ca0f95075091279ab7205b7f211af6a5f91ed8cbc3cc44713d7296ed3771ed974e4b6fb5839e1759959a6bbc0f51a94a29f9732aae4c22bdc7a029ccc718d4c1ec6dd30186079caa133af70e1700f908029b3cc9778d853483a9dc4d11ec06c17557e3574d8a3a2f66349434a94c1773bacf3d5bee3e6ea455c369348ff9299c3d25a3ef6ce4febde6cf9bad24b6088153e85fd493eddf85996099a27f32d9d869f6778d143d7b873f7c3277eb3837b9c98e2c7864f805683f5796290cfb86909a54fdced036d4cccd920dd0bda79173f52b1d9ee34126e8defca9fb6a37fca716f37fc56a0279a2975fb03c51306a21994dbe98c6ff89ffeb3620c138d11b07fc25f57cc6a216bd526d5b522ab269d1b6b3dd758dabdf76a9a327aff37cfab1ace2bbcb5de599aaee8ea8eefe817a0c38463cc5b0b30d1cdbe2728629270ca24d1916678a0c07d8e7a164435151803098c3964e2863a3d22a1481ad9c09c5c4bbb2747c2e575d52febbf1cd24cc8c1120b2f4b782cc2950f47f2900d99c38894a691a20ee0e41707fbc0ccc6235c191099c807749053dbac9296a325a5eaa862c4023b1a09d0325da9593d51fd8151a0af107267ea1ded37b89859d95c5cca39fb5458f0b0608d180de1735eb1183ac2d7e5d00ed10a420276a9f93bc0915610f0573eeb3dc623b3ad8533a949ef6ff0f49ba36caa4fa922686f51a779a66496779c190484ff91ba524ff58eb8bb57af33d39dbfbbebbefea64fe620b4228358384021c3aad6a6f4a4269d3d7508ba6bf75c8eaa5debdea5a5fb2e4b62557da62bd40f745efaaf019a8bab66e4d9bd49c956572770c816ae98d4181ed5dbf4b62216e51d75c34038cd0c219ffa34001339f431ba3005b9e4bb58ec7d3e751cf34df72b7c0021b7ef6e45b9ad5660538e5201a2a87949c42287ad9df9a0597d418d6d30a1897bfcaf0ea83afe341a23323566fc24d4c48dac5e7d14cc7c93f25b9aa19084200015f2b1b554f45760b8d154bb3f18b3fcd522caf91601649c0aa8665bdf1b1114780b7fe16ba5ef4a96fb52ed96e707b523fc661afbb256b35b104931a58f3f924a19b2acab79ac717cedf6e1c4aee2e9680b42132c0b16b0a735002edebf5617f0ef707aaf9597ce3cc145678c2c71a452f810a3b704d23059251b3d051e3cc93977ce2278eec281fafa1e0ee7f1841881db0ca3369e2e67ca308a88f453780b0d557b0b2d3b76e6b0ab47ed174be56270bb0611cec7ddde0a404ea60b5c1248c4cb183d230c0119668f1a96c27bf0c2da85a50e32b274605407b3c7e2cb6185c9787ca5ecf1f2fe7d8e60082339b720e497769d753d0f9dd2a45321fdd5e250792a71f8a909ebd66db32e906d31b83791afc9f54f7d9b698c2ca90cdba7dbc22ab889e4b68e8cf5532403f5b5bc6f5c16719fcdf2c221fb21adda1631e05bcf41a94b41985e510a5888d893f0a45bd8c6fe931eb2c76f55f66ae854dd466a74b67c5c73be1a8d63870536bc6685641b0fb7b54a234150164fccd626820f27224e7facd68dbfdadd09dacc6c7477767fecc9572f872443b9a1c05bc651faf66fd6c40880ae502905f79e77cb38e14fee4427138fece14995b6891babae474d55735b00e7183914d72ed25468ecde8e58efd2915c3159873feeb44a669caa4e1dd1001aeb2330a83e63b4ef437e93cfe309e6d67d513984526874f1fbdff7048fde30a202cab0eba9d7fc5845be1215dd514c81f0d20396fff881d407892343446f6f4af837b8736acd4ed10d8da75326ffd8493a8dd2949ca5821cfc7778f905fc154468fe12c1629f8791d000bfcbfb20c5fcb8bd92fd167198c417b242e395679433a61bf6d678bc5dba8ca234059386899dbe4f36831290e7a51e4b04b90ab949677777dfc3f70247e6572016d8f24f9fb5709197606962291573769c99f5e41cf8922bdbf2482f98f39ed474f1be0ad78dba5cf03b8d26c101b88a0c8888530ba365d0540e9e208cc9f544089d4a629fbb66d50d968a13a549ea4d84b29657aad493df5fa51016e03d103bf38f7f1b46440d38c4426251bc4359ee451cff3c8232332fe7cc77ad2a696846fc8be0252601b3c67223256ff3627f581105dd8dbc506bd9eadda52cf35d76a1f243c84640918bfe1470db7b4063877b7f9f7b5c37a97f46ab05ec4e1ce8e84394695af2f6e2461fd9fd067df74b446b3a62cdb8e39ae798ce39d5a8d00e6c646fac2f24b5fd9484f4dc132c1009ab61dd9f0090313fcd6790f88bd965699d1c89d3b0eefb2efe23dac458bed4a82ef3070879fdaffbe9ee43aa5752bfc1d5777c728de0971afa4bb7e2f74fa7e9c48b53221b83ddab2e2d72fe5007891a4fed9d597cd753edb056d181daad801551efd7ce9c09492ad5f2d63e5ce4a622366485ca7586b01154729ed0786f70ba58af42ec17df64354c249ceb7ac6377ef47a039bea599ebdedbe4b19dd72f47e76a0b42719e00acf2f18d8eb555538abfd8c0aade5a44b687b17f4e1abd391b278f20bfe14836d8c3cf30440b107c23a6505bbf2583ca5921a02a38a556873e4e7e904392fc3a1be74f6128a7302cacd8e44cdea868a4fa0cdadd79d39a52b4fcb78871945663fd96a85bf706aa83f1d68bcea2d226f24110f6bf5a2dc14ec08b87deb29801ad2ffa644f2fdd745af18ab9a380bc85758119b3c6f99d37b08cf5ff76c00ee6f45074aa18c17fc8da10737732146c93d989135719a5a1e3f1fdf32bcd8c6e80fe3b21c886c5a16bbbb3b96bf986d3cc928be7a382e995df3554b77278db421230a7878f6b39e70cb7621134887d285be78d8555ed2e3ce26dad57e9e7e800246ad59135073e2ea057f9f217a1f9d04b9ba0bbac0f6cf96509151195ae00b0848757fa7baec3c6d8ec9fdbde6ea249323fcec03344b40b09dd0bd07b5545a14d3c98c508fe21473d3a5f5d52569856ff0a016edb457b1915569114e96834a99b3e92c68cc2b0d4cd890af9859b16f8b2883e470158bd8826ce1396eea5feb02bce25c822048ee4ab3a98de65ba4f581e6686bcc6a61f0c37a41f0405d7a6d74d770e6fea1bb731482fb837c428b76c06b80bd0d87c68b907f875bf7e9af02b7f78db2540378c06877d838ba483e654eceb5cdf2ccf676e6e5589be59e021f2a3d6bb1ef7ccc1e49676a94c1f42df3cba60f9b7ef80ccf5c119161f6a45b9f9304fff7068c03d934f1b16c19653ce303f4ac0313d0ef4c12e572a0488f5ebf02983946d729cfd5d81a8b6a4623d3160507f7df4d62ae6a315de7df78bf925d2624e807408b3aee6da4c1e66a2f112ffccda53da173fa1e2f2fb43fbebd0b5cadda1b9ee41281b10ab60226f2571696eef405f90b974dcb9fe66bf4af6f7e5e829f437217b083ef61e5329cd48ff7d56bfae2d88f18f40135331b1ba069efaf4da9315e660957f62b4b23cfdfc3e638d7152fb00d4a54e4cdb169b63bb06c0653d21709bb2b10493ea63cb377db8d81cf797380286de3d50d915611147274fca7b4535b2196fd477497ffb5d118a47d33b7585c166274fbac4ec00d90bb68866e2e4e8b4dd2793167848ddb69c8cdfe70daf072d77bfebcc32e167a1584fac715c7611c3164930e57f6be90a3739a428db202518b948888b2972b4ddf89984c9a2b2ec68b486d18bcfeb3cbd80d53741fc887bfde68b4d663c519ba39c0d0dd5c1ae5381275504b916e29628ff2328898eecc6aad7f572066287b97edaaf6a1a4a0fd3928904b4a91a4004f5f6b0762851ded91939b5ce0e8240b60a5d1d3146d57c7fe0f7b198fe313a0d3ea393c015dd701cbcc9cf97dd90a1852c0ec373d697bb7d4fb381ab4262b759c4d0fb9086732830454251373884266f0e265b054a56999e07cb83cffd42a652695991f7395812dd854c7fe88b1e5025bc2fd71f7981f7db8f6fdf37bbc719b483eaf5f4aa907b41f140491d2cdbc72a518708a220cabb3e8e8ca07c40524c54418aff1d62b4c422d74385c341dfc5da5216c745fdabac124341820e44f95bb552c35eabfe886fee53f38605abc7428ca8b0afaaff61e3d802f3675b6c26bb21a31863b6da9c31d0844f2cdf96840d3e540b77bed0cef4d5fe367040fa168a13b79264ad3d2fdc58b19f1ee601d4e73bc2e89a5db11be0cf3bf834425a23680a3e8ee4410d112bcb171ae069c860203c130b5207a384c396cf8ad9a8a1c1ec17a3ed7d5587b90afa9b889b907a640299316c9cd77eff8420821e85b87ca52d1e21603bad963185cf71dc371d5d681083e639fec027a127cd911a03579952089f5366a0edc2b73bbff0068eaed0450a6d5aee30bed9b3193738fc181b1b8af94ef6e773a8ac01a2235d81647b17163304ee17593de6c6f8d7ccaa83e6b1da61e14e29c5146953fe288136e2c56c1dfc3ef71480768f7e527c8d963915d94d9a20b6b8cdbc8d4381e1ac47d6850e4a786555310bb029d90190282388465f3484fa3523e1d6d2c54ff09a77146e5b3c5e1dae6278c223db5b25471c834f600350c361c25d898f5570a9f2d6ac9ceeae8d1fbb495e5a57805d86eb93733cb6c6becb804459fb7620065075e18a9733b6c17da1bc1994b61c62809f57135841fcc0bee05376d8e946769146fb8ba79da32de8ed3da0e190499674f862ebd1dbf802d897b7acf05ba2b16441d68703302c89307548ed7a55c3262538b9827f17dfd6e5f337256073d9012788e29289b13bc8ca72b45bbbd9deba6b0c78b0e591870c38b78a92510c507bda3ac8e90cca819a079423f0d20ea75b104050c4fcaea0ed78f82c44409ba824670bb13777146b1e7bf78400536abce2ea7c073b6cf633deea8fe8e317deecc7839ed656302a015d7296d82fde80c4dced2bb214ada3e5f8dbeb57b51ed9800bdef9c6d987f7e5c61ef82e02155d61d46713d1caf12fea29b5f71bbe4de6dbf87a44a693a4b3cfdebce5754f776a8a114dc8af80ef2a6a29ed50e0380b36071658b327e81b0b30c4fc102426bf2a09303b82e52b97c21a1cadc425a3b3621ad8a91bf9c38a105ce5b54204d03d220b8f5ffec8af609a9a6a6048cd02734817bc7e2d0b17f514a28377a9e423d1e835e377a328b9d394d1e4b484eb4efe0b77bcfd41b28d6905b407e3952457870221a66cef15e27b0f2910a30046aed93d43212bbf4cd8911603fe0b2736691f6e6d701c266c72103059a29a4c342f48600b76d347be5418e5bac9a35bff50abfe06ec229123e5aceaa80a3d977794f49d6b44c98f38a26f31d1f9542e71ab96bf6d12421a092e1b9498fe750c62b4ec2518d609b4bbf68293b661197ace71dd74da9786ed6a39d6cfbd8734fc0ce531c956fb180f5b4dd5a14d14e845116737996f14ba7da514ad3fde84510e6be464c61a6a7d61dc3d020f540078eb064728d752231989a506a74819c096f377357ef6c2b5936fb7d15c448b7f8e286e67c7413bf5b0a7a206bb5ba31a7ecf14987eee76abf5da495a5a34db200711aa7dfbc018a9329dbbb55c68be93f3a13d0c4b9d8009c1a41d41639a45c33cc81b7b13b51c9efd436a34eb6f95be9a5cc53904593eccda444220adf53e7e7dc6f3b3d890aa54e3a771ab82f3c31f11cb6a70c111841eca7b71e5e3977a3ea025464f30808491f11371522686461c700b4cba6368ff115124cb3b0295f8e3749c53eb9714c38fb2f57d028e08e25dc38b5edaa187aeccd352e1858652166a6e7b9a97b00db2c90517d2181f41110a7c5e70f046a7c450539556435e410fd638ef194050ee656c6ccef861335a57f20c49325209b460546161c7f88cc1ff15ef7e29d70becdf31b4aab512852cad8123fe1fb8940fa0d4aa957cb36de2fe27c1cf4384f72968c7f8c5c002195711a9040f1197f6bfdcd975e36286d7fcda80a7c2bb94fb4d3a96c4c6e8ec795e0f6aebb148c197549cbc28113f2b2707f70fa920b9f71aee4124ea26a5280b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
