<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd7231cfec8864186f15ed215e132a294a0cc27736bf01947e294e10a8353d24b9f4e719780e67970038769f4534d7da038174d14f974014411a6d636fe42718082a70a6bd3745b4cb44086865579849207a0454b861c268f505d4f6453edba064d99b9c943608a7e577c41ce49b138eb898f3feaf424490cdc6be30cad6bfc1241a482198c1448167a3fc874d83062c454488526c1265645c079f8c9a86e8afc5de8d0dcb500d933131cad26cc66231b971c4ea05424cec0a05065e24ddbad0872997fd39399b4c3e29c48274fd3e4d57027a766eabf1673b19e3071fa6a125607517d495dd7d0206433ed74b729ba302c497f9fb38413cc58e5b204ae8d0b3bf1fca773a71f50fdf7733027189582e05de25d88957af24f9777f0f57afd89ce1790fe352db7e3078f89558f589dd3cc9b356771416c61b2a941897bb421f0cd0010577b01d0ad54548a59d23c9ae814a432db7dba128e1437ce4752275340bc67fa1a117ac65519a5ab85c55a0aa49f1d48523e28d5451f4f9f9267aae48cba3df9813eaa678bba0490948700f0664f48b5adaaa428170defaa3e4d91e490c78e2fde29bd1bd162a7d9716f09864904d74a33cf22ef8c351b91d79c053c4d66f233cf59d368b4e15f411ffc14749e28bfaf3bbf9e863b661372093573c8ccd609191d0c93fadae07b2d6219e52d217e304c87c4a544fe94373f09541c4171b8b120d10dd08a850f3ce0b449fd74a1f87cb78bbcd42b7259b73e3de4ecbc35e8c518f9f9ec2caccd3eb764fa0d6985406f0faa18aeb5a554c3e316113ac56e1d990fe698e91d29ebabbe5a6c1a87d2ff9144310bf9aaf769c529728c1d4f72dd9c39c62772a1a53f60e1620c2b2f19228e92c6e7ad65ad608e8aa2ae4fc83101e880f58bd1778415ee0425b01ad7fcd96e1e4f2275bc9149dffbe7b595c6eee9d50d5f467c7935cbf105bd6d33bd146f2bb5650afbd8fac58a40c91f4470074091d9f065481b5f47084a890ea99cab61d84f34d6f423f7aba6d442f01a9e7ed3fd7741f9de1025cae75ecfb5da5df1dab95cb3a5300f7c6ad1b3f4ec4c5aa3dcfe152809d10ca18345e8acf1a58f062b8e2a0a515fb93835b75147a5651c857dc0cf4c28c27e006190a4e8c56fa658042ca9ddf2a7f86ddd0b3deea6a18a62bc1dd44a4bb15dbd664f7033142f41dad631cb4d0d0a428e187f4336254ed9e2cc3ddbf5eaa86f8b583f07201064e119c05fa5d1000ab551bd512446e0b3692d7ae99299de92829617ff62e02d0e1d505d487062e067c61111083f8a050f18a522df73f49a41ef9d3c693d25e28e4275219011d416e138a1cb39fe7e301972ca9d239966ea4c83024a43da94309391402e3c332206829b935d3aa901dd5310204700759b3a0a0ef466bf6053e452e06018b6f09d7cd4e4ea1e4b060ed7115cc860142046858671f8edafa54713306727b5c6c4a7bece358e5e5e4e22217ab6996aea28fae7a5b18d6a26bd368899a339b9bc7e6b69c03cddc1d6f2c55535e3abd3c2599b04a7a4eeb9c97e0546dfff213688432d6aaf600b112261dc8e137ca366eb3b65bdc618ac0e8706d83f4a80898b316a279f61ff73c6cd04187e3be666ace1514990aa7281edcecda48660934e8eb4483f5573ac055e33938ce93bcc563d797e67f679dde27561bb9194dcc78edc41e7798dffa4f5c481958d8f2db745fa9634f9b9a367989f232170dfea8c51ec8e3755b50e451cd247c1e4de37653db0374c4c00c884aa7134f77a3b9503048fc87cf9cfb26b2a60682b91fd36bb05983ec35183087d87c11cb22ef37412caca900a2f0d278167e84dcc1868cec46cf787b1aa289787707004c8789f2b7744e1a05ce74100ce2a03594b5622193bb38b6a77c67845b61ac01f023ad2a65b943c535a469d965a90753ae4ec6495ed18578a9aae5a50d4dab22f11e0112a6c42dbcb2ad83b8c60c3f84ff610a46d98a1995412081551193b28b7f50dc8b9f05a89ed33a79f4aa6facb76f5009b085cd6c2ef16518b2a96f5e869b4471d943aeb02d5dafb06dc5e533fed17623250a6232bcd508e1924e60e20176ee6d19540870e0e9aa0c338a677b7e00ba5cd6a432cdac833aca5d4d758a3acf71bfe425b7eb0d75ba498d206c699a1d10659e6d026de094b2e3822b7c64aae250a020e501b04e1f7080a2b329eb23b780aee59751884a97ef7fa5ff3e0d7726252e6c3c9b887f55804c795d03a32eceaaf13c54fe2accafc9f285b574b1c4fbaed1e4bae1a9e4889e7fc34009afbb57f4f36ea784f025832f6154a21a785eece43af6864fcf3fbf5a24fa32c1370d26e4aac3b4e3e65b571740189fb2bd8f375854ec704cddbe8482174bd64d3ce040a5c36be91243cee5c8a4c0165f10a07273040f7c1df6af81d30723a40ebb2c7db26600c0c6830d912a17aaa886b205213fc82a929860a28253ab65e2ac165029b763216951e51330ca1a3f05a632ad7d40945e5a9a6a877e60cc7784c69b6a5f060d78fe2f7735e6e1206f2ac2b70447805f4748e73c9868b29ed9b0a059dfd049cb08d59e90d5b1b291c677bcce5f94a9b750a3378bf7a694a0318a2a78f085e026a22f13fb21bab68d1e371a838d2cd56a229d7577d66d49ee0a7236e017b56550b04935febf2454eb2a4c87aefdb0faebc6656b7800cddf970d08eb43100be46afe88d2bac12bbf77a2c7cbd0d685e4d900416be78faaff0e5e62b2e56c8c9c4cd5bd46058eb2a068467e3e48b5976cbd5bfae90f67c4c0ffb52c9e5e01fbd01d4ca1843a0744454bab2a869250404af14f76c44ae0455035691e397a80b7a08f95af386ab1efab3e797056cb26840d443b88520bc8ac9d3802a6680f1f86670f94ff2e78784cf2566c80060c34bdd4b9605c31c7509808c7c50b7206f3db54c422ceaa0a5a481b0df686baddd6535f7960ee94335e757ee2bde1f8b1ea598b83afa1d60aff0965372e1931d4dbf7c6ca55e346d00248caa1a8621859722dd7d29ad5c9706c1b0f7a93be9e483ed7f37ffdd74449d40f33e7c2e3781f5360c0b8d96fa57ae621ef05f3e9adceab06e59f2c48aa2130b6b0ba4a7f163faf8e9b2fb6ba6c939d542719b36184323afdaf8f7d5c49ea7ede94544070a15776d17e32cb469f5a28d191a8d35cd68ddc8bb5c24c8483341a19882e96b2bdabfadd495126e7ae2fe5885112751eb55be49937a3c3592289e7b74a62129c99b41db295f458bee36db09a3463ff516488238186acca34b5591d6cfcea4900bc32912e78981a57b8d0c6216e22301d133cec95d8d83d8a4c547f948a7d045fef5bc7504b224f8bdad058d7f0c66c465582fff5f9127e6c1bffdb309ec6c9fa3e0de8e363a5b143fe986303489cab6374b7b35dfa2ed050955e2440e8cb356cce408c84abc070381bc3f1b29aafab8841edff00b9868004d84136401b2868aee446764d1985b66a111f28b8e74fdc5d0eb8565b9889cd9a8411f31e58c0512f6898f1059a61392265234ec81c2b2b4680f4fc5a5c5ea5a242c30463fdcd4efc747014c68396662dcf76901c3134994a5d4c42155651b24092855ebec7029155e0180df60ed1515dc3dada1d7cb488299620349f52ffe35ff94db3312d49c9414bc804a345b15176a4d4aa81b3e588d126bfa069639056b42d14ef43c28ed7af2b31b150f64db407f72b73026c9ca7836910fdaa28792ca88f400c21b002737438652b054a937ec61a8be3fbf2901ef087bbc5d64bcad6a0488ca24a376ed8f1fd1705d68d7f9830a67fb7e13708dd2d464c91bb4106a67233c83eaa1b3880097ecc5a7efe1eec6a78499ca73884686258ec84a0ada6bc2d57f5d3dc44707253ad0d6716befcb49272c5db10f4c94505cf0de4a8bec4285bf14120c54d0671bae4582d1b0d5aeab4ba7122fe17f81c9cae351f46ddfa8045716583a272e0db191d9e01b72bd142bce26a5576c16d56f39a41e9d22a2f4f6e758878b00f0ac4a62250bcaf59e6eb35de030d064199a891d5ede9832c0131cf0949d6ea9756fc26d0a67855af0bbe907bd8fdff376d3a8d1c757fe0aa16c8518c3c4f5b3d11f21ca62343febf331a489709fada9a3a61956de8c9e9fb07aeb9dbd109286a5a8efe5cf123a691bc58f4857dda57caf4393945eab3c52253c82600c6eb3cbb728ce93673f2888a9909f28d2554c586a22634e04523b5200098e370a878e1178182ed1b1d6d5bb437b9301f533e0eafbe959388576126e153dafda64fc89976a7219dc9b8431ff8bc82e46592a7cfc813dcabb34455e9b9d9b5b24f7ee3b0f105e09355b495f6f302afc6dfa73ad829cc72086de95717031049b41276d4dd4feafc95fc61a752008d64dc50d968202794476f840172ac71601c8ba92558dfbafe2f299df23f893bd4871884ea694ad9a8f2d3453004c33b45753bea4d1b85cfb1f3617f628912b026c46f5a8108332cfdbab02c7c7ae5ee0490efe7d7c5ae8967b9c7927d57a600e5bce959de6c7ff693b6ceded4ed68090d022a6a271f21d716db8f48ea9e2e85bb8331fc2792c2175519fada9e47fd27f46cc602bd6512df76ee0745389ad3d95848880933f5f04d4649049d9be78bcb199e2d5edced48b12a2c9208ed29dae060c3df908f98f5db12ef6ca53bcd8933c716bfcf11a49bd87707ebe7a72f99b759277be963390eb34aff77d132737bea75963dca579bfb758995380e3beb5963599397ca295f230d844ac3d13877714f7463d02978ceb301874cd7ab26da3decec17466c0b10df2bdf94b57d3026755c9e4684c7df71c513e7e28f881e242ab04d835c89dee5343bfbcd9eee73ccaef1e3d69e136bc0973680d202060a7360b2e1edcce438ad65b29d6824ddb9fdb655f192b476009c302ad92b04c491b60ee02671a627b2076dcccd9e2b717a9190e74534b2e747f2665f7da21e45da66d2355d6977c6ddc6cac4ae620e434ce32762d6156258d1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
