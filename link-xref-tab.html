<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31ba2e9e609cb91ed42f481f6f67bb6832bf2109120277281f590f7882d996a28d2853c29b99a4a0e4c0daa18150bdec7f31159c0da76d3543cbeaa975854614a84b35030612a3d671910237573896166199b0afc06792f87c793d0450b946271bbcb10d1a35b09666811c1d06577d87639684373ea1fdbab5c7a2de245063f3335a551b03bcd0c35b40cf4a2818c441deceae6336cd4ea0c91a8dc2fd128cbee1e5cc5a52a92add4675aa776c10cec3e89ba721f23f6704ae1f7367039fa2a91f501ca5a277fbc688ee5b5e862fc6221550373b3e79b6b788d35c446ba5221de66777f43b62cb406cb7f79d50e9e22930dbf255e306a000a4c850891af6891a0f3c59ce3534655a601792032e224ada947f87bf0cf331f18597010f311fd232d67f2f406435b5e6052e05f365f6afec5342ee42fd37fcfb497fe42903cc00cbfca69082f2b8181247d6bf6fe7cdf234e58c375276a2940bcaa3acf8af11081474ed198bf38355afc98cdcb346d4bb5c2799b875bcd9ad8f6ecdec7183a3c9df880a2c2aaaea96ec511db8d0725d90fbd25ec75cf1297bdf983440d9d57b931d40a42760975a170b8d161b7f53d92ef14ee96c239525c33bbd893baf65069795dfa722d37349fc826803009d706424b2364901c8a9c75eee89b4c9aca12e0e6e6cb6395778a1e2ca8324f06ab0a9985266d808318e48136dda01f53acb4c21daf7767294fa5650079d6f78473bf59043bfbb59a89ff3584151738aca24082d1fb3cbe04e494e96ac33002e9268a7e15f62fcb110eb9195fc1a3e6f385ffd10f545b9d49531e01da3753c1f3c091f316f95c721d909f6ca3d72443c554655ebbe263bf05a3b12f1159e46c295be8ae347ae708c871cf3f2c99f4dcf909b69e85208e373d878276655ae3c609dff22cdc1fd5dc4f7d41e8af78e7e258c5200039e46f8a893c81d9e132043033dff309fac8c03d79b7823acd343f4555b583e6a3fdfdcb3cbd4d780234020f3246c54dda463a53d0236150cc2418564f52da9f1a5fe313ef1c9e6860c7efb3df0e9bca57f0b9301087ddea1f8ae2a34be53f33ab432aff6c34fe389ef8a07d20c5841324b15985141b083d07ec3225c5362bb2a08a32213fa627e03ae5dc7e486620f53c5c8d729377d9285a022c0ceeefb5c06567d6823edcc5b704c1e46423fe2788fb74b7017bd1f9fdd3216faf5fe248593fbefb9b789a582270a82eba6fa0c0e1f9f35b63d6ce88cc2d0099741c32aa468cd084ff94552324b0347829f53513bfc724b2c85f7360c5dec0a5b68b3a7f768ff88a5c2677e731f742d243af259fa261a3ee0be2336922d5afc4b2b57d60d9665fcd41b36c29ba5e3cf416c972a61cf5862323e3ead552af49bb06692e7bdaca87ea60029db6024083185da54c209b22eaa6e48ce3eae356321306babcc11aa313f1ab4b560b3311cdb22bf1f8327bc8cb3ee7fdddf16a90cc69021acd3dab7451d26c26e7a639ffff17c2305f488cc740a5b780fd8a72e61bb9de4a57387d0586cab88f0858554e1962385d5950db647e7725365dfde54da0a6162b98b15d6fb94c435969cdf3ca2e90ada3d2d9b3bb603c3a35dbc48dfa8fcea34b9ee51892e4e5be023e146486da0be93488fc3c359f9b39e9b5d7841ceaec47e44d306685e67a417e052cddfa50afa5263d5155656004bce38f1be0fbaa717bb954a36782bfb6b456040abe067e26d256c1ae7893c11adb253281c5903b61dd2d3a3a402fbe8483e4d3c7e3c0f775864e6ebced377b46ee4a954a22a8a3483bc7baaf50c3cadb690e08b222aa41446c83a839d18c0b2b2bb3882b60de8c6ca4440f91639ad900515ec06a82cc6fa6cc525e46aef287a4204dc8f6ff75c2910145c6099c4454552a7bd1c7fd7b27aaec0d58eedf25fd175e6546ed833eb8edea412045392ed80bd7ce64761f52e7d43de11420dc8f5d99f778a201ce2b50587c8a66893487c41f0f8b8a1ae5eba94720a52042408ac65b7597b872605b594710f8f6943e3eef313b5601acafa53fa34ea55e35b1be1a8a5731badd7c55ada77a9af847e6d81880239177a877b50b9dd6ad90edd16e3d042765a60904f1febfd7193cb4239a0eab7d8777648cad975ca6749aa04f18e53c78cea582e40eab257996321401814e80c1383a0368696cac4a5aa60ad8875aaa27b3a2715f4f3a7ae42980d4a7e907bc870a261352d1c1209f82a0db4c1882035b8d25f7a4aab7345075f725ce8be7455015783b183a98360e1ffde392213b92244cdd64efeb3c0f4f610916fb69d4bf6669da5e564eac53a4d76f5aa6b6d4f337e3ae86b9551778d19bdc17810360c4682440deb78001ea3f23252ed5c04cb95c17111f6e60833332fd528b76048f0d5bd0cf67b1da5eb9a31a5057c0e6c67f631319d964558e3a8c2431bacc7acaec5ec44af1bade145efb676ed0784babe5bb34889de4063556a6d753562af5c783760c81ab73516e8fe29d03e513e90022341cd03bdf5b401376ac20621e08c5ae1c94bcda2193850515529ee8f6a93b3072dde6b2917af742b8fd870343afc0a11c64623252f6e035a5219f5825635b58b0cdbf25766c4655b3b6e45b13bdc7f8b36a7e994c0e74868635b692f9cd778ad64150379f2f8685d145076d2c877649a35a018f8f0989ffaaf6b5ea3ecf03a87ffba7b49a5d5c5a4775d8be268770be5ef9170cfe4c1c039068fe44d0e9fdc3c28edb8c1a111eda9b12fe79201fe5a87b4d25de3cdb166f5c3fbe9f6222744b06555775a8f45be1e11ad4128b59c0acfe18deee18ff20341a218e8c10a183d6156ee0ae22bbfc66eca6a7107a9f0984868de4a3feffceaa7a46b14e8964a436701dbd578443e38e3af651a059c8bf0720d3a39c19f93a49d15426046f0f69e2cd1b52b0d97b8e0550cbe3fe5c128ddfafb0406782608bca8fe4ce280a6b92cfe7efb5528efbd356bceb77dbc99a31a8e60f729aa00e1e5ab417c9545424e32c1c8bf08db53b2a86f48ee4e0122683a2d10d225fb7f4fc2f3f298ad3a4ee39d2f26c3234b9c773697c452d8f1425fc10f204faa3c8d33d8669077b6ba90c2382e7330064fe4782c13956cf6494d4e39233a3e828e2a533d9eed7b09e5ca476a1bf618de5261fb7a0ec3ae25c52f65730f1bd84e9394f45864e1af1208da238c64c7ae12f46f411f00020f4ea5da406da144bc67d45de48b2a9357457dbf98a054926c8504654b01de8e490647d4b2ee1f6f2ffe706de03bbc14e18d3451d15928acdd621e3cfa899abdee6397f1fe2f04ae7b5ecd0593d90d9109d56ef63c19bf8a10403a4a03f0d77a8bcc4c1d48af6917eafa51d50a15a26267234d642ab3a016700b04d0e73c150b56f7cb07819a633c4e78ab7f42311a711532229885dfdeb71e2e239aa8ce4626b83c1ea7eed5a44f4c673a30958f29f5af7fd8efa02c9e27eec68d969f2dfba1c79f74474e624f601af667a2763acb876b39ff48f7948aeefab7e3432b0fe32250b4fcef1be1ff42c15a4b31cfa8620eadc47deb20557e6044bd4e9101c1c8e62fa1e08704d9c8bd734fa6622596462edba1d610237eb129525855ac4c26d56fd52c7b3126e9331ebd87aba5b5e4a15f80e26f83cf94386ecf8e87fc3b80b32b09b534505a0682202201aa1ec3b86e39943adf4ea03eccd76bc0edbdea1e8bbdca17e30eac5c68022fde6e32ef71286cffade44e7a93ced6398f9e032e9772fd08b079f3a0796ee548cba965f09c77bd5db9754ddb134c8e00d7c4d635df925d03aeac5cb21d1d75761c340af58e58128cb99401ccc5976b20e5934ed4cb62afaa2ad3e6a3ed20ab70f3a1f0b043abfc3516985b32cc4ec2c2d2c3d76ff5b960e0672263a09434ce8986b9ebcce345d9752bdf0bc840553f6500564ec8a980e9e8d199d082ef85da4b14f78943227be06e5ccc9d18c873b709d794ebdcb4117c0d1a1ad1a542e58794df69c7d5b8a9f77f5286e3283f1fe38aff99d79421255231d494d11561a73b8c1cc863fa4a50c6d282922d6ee3e9805de344a42e5b50a9514001f0580749aeb2a9733b17f420fbd8c1a09f7545c2b9504c29523a68665ae44fb4bfab0061fd6a5bcda336ef986216f1068a132d9f4373f2664c265eaf40cd3ed2929fee8d6aeec54e89f3f0ff45ecc773a78dc5ca834590dbb825109844be2b51049e6cbb0ff78bd642fd0a3cbfeed39030b2ad4413dc19a3132e690dfee551a250eddc3c7ca07d944c3ba8fe391c06ef4b56bb89fcecd857bd01dbb07ee4400f15499b836ac6f70d6b779d0c938acf7fd80600ef6ed8681dd37a8daa66f29c42dd2ce40f5a1c64e525b66397c1036153d28c198e253f5dbe89011fb6430922a55be7f55be91be68dc4c239ec7e022ce0a3c9fb70cd66a8f35365ddb0709958d48ee8ed4389c90883a9f60c182a2cfcb8fdd6595d3b2725254b1f17f8d7231c7756d1248b2fa73a6724f1986e51d6d90e9b7427ad09bb3faf727a7178f611068e49a20a190989fa1eac023d7c8f2f0ba7e475e7d5d357d63a65b68df23fd9d25096add88b449c8cc713b29ad425093bae60bd200e97132037cfe7a09e030a68278ea95b212af44037eeaf33d27c48a8f5d020164b581191096fb7294322bd8fe02a58de2310c78035fc3731c56967e3761aed5e55cfd6bbe3077706960bd2efcc30edc69db6493037472f9d64391f331671e164f4a77af7d93ee528940522afbe5dee717dd31520eb273e8b8e9194fa3c970e5de5f67a2a18d23e4ad6420b8e5a4e009abd8c338f6510e86db86e22118f637782831351d53dc97c32164990b2f846afdbefe09c2e2e848e75624b84297f5cd38a7003673138968b21acf66119efad37a25b3fc298c797b7e6ea2dceab33d1e51c844c5ecbce1d26bd2ae06802f003de0fd91c87c90ff519bdb5ed5a1ed262cd5c334c161f8d52340150fd79dcdf0c489f9c20bc24b9b7de8f25a3e1f4c53324b9933b87b16d972d827fce3495b8e18ecd73751479c094655493154c74a9a956c765672a77339d52c54c303c8b6cf07b66ee664545f896ebd6a983d97f4ccf13f87e35b31feba871548ee0bf7614eda79933c3b9e1f0cab876ee05e1018256c918aea6f7c85bf88208fc3e699675c0ec80d9c914962b8ad708b64686013c0a3f326ede1b9ddc08662957126c006e5d1799ac61a2f56067688d680316c5025fed826a1d2910ba155540b243918095b3256f8bb3c987576b6ded34549f0b67da5bbabe5319427f4027e16d39351e5673b8610c3dd2846b3760f30acb53d3f55aba30a1b062130304bc6d137628a9342a2f467807b31a85873c49430061ad44f9b03257eab35e89d202e7c13a897c3c28b2948a8c9ac487385979f086272743f25748cc16070a819153260092f6b1b2b13c8d3c92e2dcdc6cf63b71ae2ba45e86214fa2e5cc9485344b6939e2670cd32b796e15d3426284f7cae1a81387bee769631d117cb513ba5acb92fe8f907c27c3072a8adb4b2fa5235409ebcfcac3b3e740f106c395c41fcca810ace2e7fe8a6b6631fef33424311b268bf715d563eca2e6618be2d8ae4d61f7e950677a464657742b51e57ac387620fa54f0e206156f6f0ecbc002b28a12851982da0804e2643a1cccd53d37a680dc53b3f47fbcbb90295d1377699f7d0ad0a4502bba0c10a9d9ba40ae05beadc5805af1f44d64f613322121eba42e8a14447e33dffc9c931d9a13563503dff68adb67ffa289ef494e8966d58fc65ae51eb302b5064a413c0e115e47457191f1e6b4391a3666ec1aafd7431e66869d8d6feae97496d797dd06b0ce78dc603859717de4ba9662abfc43f60d06b5e56502e061d958540180ee6afbbc7507f973155aa97f629f001d62f9b66b25442b2608ea1555859d7fbebb5fb73ba40d93dcc4e626b0cee609b13094718891da2cf69e9d2f0e675eb787f3a7d4492eb93ee7f7a39f2fca0857e086b5644874574c395cd18d32f5055fd084e530bd66afae088c279a6d60d6bfba6dd491097451dad760f7642c28210cf9eda5d926067131fd5aa391fcff308d8b15694cc1bac6814b59ecf7c256a98f1f35e48be97af459fd066311cd10e2dd94071a8224d4055c2ee7f0acb877ddd963824481cda0387ce2ea0d3714c84c60ef140879d4c399fec0e18d8220dd5f402a7ff8d2511225591ff415a26069e0c90f92fd6203b9a02d687a0f326c9bbd060a7e7561f970b71f53fda16d0df68d436b309d768727d6daf7261445c739191cc9fe11424956a282d87a2d765288c8593baa484edc82a2b41926a310d180b8e932fd4fe6e8d97d1f4230f1e2f22c758b63eda3e260e41a1e47731873b60154838f5c99e518003965c27418aa857ccadc661e1f8e2c54c07fc0e2ed1225c7f74258a6132e038f56dd2f37a59fd2fb3b32fe993683f548bf672900ed42053e03287563fb2310d3482c4c40f84468df29cad9cad383a89ac69e06579e47b6c1901b3d52d6ae105dff7cd8c1ae577ce6c0ed1d706c75bc3784935e5a1e02ba52171ab6520cbb86534327bf733fa1ebe9b67c45190438837eb35f64bd174924d107bbf37834ca92cb9760aeb2bf0f9c0381e1d4e4f4b03c65293439ae01dc5000e2e1cd76329d8e045f3ff29d5ccb6ece2cb1d53c980625a617ddcd847ac136c7938facb7433bf965dd66216040ff7d762f58c49915d79b96c050c569081862b8a2498b11e91d31abb4c49672e4734496a97bf77c7ab1985aa1acc2dff27bfc367201f655be8941734d2d93bb21b623aaa5d95500ce575cc9afc6b3ade8be63ffb659d73feeff5156ccd35a87d609e9aa66a3c6dd883c9d6f24e8ce4871d381750f1e5e6e74166f52c1a09cb4eea25ebb5efad2c00fc3fd25fa2c2c282edc6c9f4909894d39c4b2e2b785720e61b1693df777d37aad359b55eb11c63fdec9aaf17d86754e8c64665af4fc48801d413bb83b7f917cc9738e0671ccb24e8804b645040ed7fedbd18a61d883095a1c4a964b24d5f7592dad815dffa6ce42a1c3f5fb8978aa7fa825e3f09d85a6cdfde3cbcc150ec0d43bb6272e34bb8a7d7b5179cfcd62efe3c9f062436eb68eca3c47cffdc99f1bb7240b2f4b180c8c064abbbd26d1555250471e0fbf0d982dceb57fdad7833b836300fc105131aeb0291c08d3a9ba0d78e151a82daed57c501ec70fd56a25270ded4bd572ce8c8cd64f06575aa75c318a1800734676ce0a2f082db9282a9be4e5049b3e9013ee63ce580c660cb2603deaa9cabe29ef8e6c22e7690d38b3692529450c6addd9b8699b6a7515855a5a52f1185d629becac9fb5515930a368da1c2c6079127a74af0b024f4c5fede046c18ab7f8b4d4cd0ac01b12c1945e827c2839187ca9c1e9d8a1feb85504b371e9fd4546185f0ff77cdd8a0c10bf633c1948524defbf2d6138a0a68b3c7e518d28db2519852f51535fb88cf6cc461dacb292af24316a331b8c6eaf6756d0dda8a41cc9bb822d0ffed3e99f9883592cb29514f19d25eb9e8c9f9b90ced7f90579a3ba8e3659614ce24c1f5008ed584e07c8e84dba4a7b3e5b089c56b731df094c3677534aff0dca2a8c6cee5758a1e6e80578701a3327fe64540297a073e7036e932bf5c37f7c917ca793bb2609aa8a264e89ebeecf24b25117658e9df0634803419820b96b8fe6b4d660a5bdc9b0a10f0f9620a4ca167592cf6bbea7f1202de3f9cf7c6e9cdbac1d916266429a910b7f48b5d0244ac711f62005d831d104d922fdb4b7c00a8b9bd1cc7255f76d3eb4bebe9b2789a28da3446ea96bf7053e88c7a215d0411c2d1d20b428c5e15f1899cba9193722795cd466039c8bb22a2f381d21dea153df5a242b1b905610a51a3809ee85e9e87e20a9ca91d50309734e67e9f174675c6fc087bb1690943e71fe228419ee16bff91dabb60dfea2cc7dfbed6ce0296ebd9a79e303f883a6fa98f3ef53435f33e86a10fbd41145efa16f3239c4de58238c7f7961886e54969388712599e1a02b12b7308600a4200130d014d84b261447d79fdf0ea1cc58d7506175e3f091994cd464981bccea23c7e9a96d060211ea8d56d396b2a5207de871c5fec26fef61d6ece24a5f756590100b51fe8f6a3f9f4d6e90b899742e247477b1fe893c3460fc0865f73f0e7d1b5c2aa128be1a174658258d527991c7f7cd79ce9982143412178148c1c50ae138a49edd75ca7ffe718f07add0fb5bc12d238f7595c7f5f7e5f53faa186bbc524bca57dd737646691d506cacfa098241f646ab275e6482b5941573f0a2480d2adc5f0d5fc033488639164e02f64b1b68f95bae8ee6d425cd41f7c2afe2671f82a79dc6ebaff9f6f589c066f267a66242cc333ce44fda00acf582875cfd3a0f4ec0491775cc2eb13ed0bef8f98ff8bb65c7b54a36a344ce07f0d646fe996be61033e3569ddeeff592426aeae1f71c684078e2402dc9d50f3fabded56bdda98b40d34d0f6270732cacf89550fdeb078c12c31441b3e1661efd4565fb3ef91d8882c85801d9032ae2262166a499223db1b6cfe8f4a6c3ab2669b38089697bb29f478bcaf9ea72530f3ab3628b9ccaa480b92992b95e3b29dc744f28387826bc868e1f875f40e0ce56a463cab23b73da5998c69b62e11b7b47f2f51cd42e51403c5fe9f112c91e213317192951d668e0f979aa9d0dc9032231d70e1b3c5e4ad736041e1f49beb3a99258e77b8d21cda34f78db9d43e5847db35654f2607fa90e71bf664619106a3963babb1e0ff0d9a7122f4fd22e1e14729aa2e9734cc1118d2ebd6ae473d44f59833a303f9ea27299e9b5a26e2818d224efc96a6402cc478df915586d97b8858db44e5d2d1b2421dadfbb75727685ef75dcac4cb3144df5b9aa78ec3842a08a98031280c91b0a9a4ea0db9e8fa46aa4e02368f025b1dd003c89496da01da0aaa7aa20c74c7ac533c89edf1d953d7252909ba28522bea8341948c9cbde15ce9ba4f6d0d0f6d835b7d16b233d99bd33130fdf72fbc5a40d27e436e31f66b4cb56bae357902eb9adf7bd4c7229f6fa15858f4d339539afb8ea58df42c4d12279f61e181ae3456e334d5257a3c3b1762e143483af443feb9a7a3ccb0a804a05cdcbe9d0a76228cbd2403237fbadcad3ac1c1749e14cbc94f30df70db37edcfec22b565ff24603a4f2f6d6db62b03808129e03f14cd8b93da4254404983cb79778cf69025147bb5460789dc82623d5820fada846c968258118518392218334067d2a8f076e7dae8d190d0a25feb1991b2ef24e101b29921d289f689d1289bf2ce835df2d487c6df3a8d9f7efdfdd5708f8fb019df8beddcd7f9b3a11a2858adb04ed7d8b19f2ce3440492c29fed4c324cdaaacc044878b0b93ca9f7611cbae83dbf39ed390bf9650cd91b3e69f273e719f76310300dcd8fcbb90c98c7f9a5d0c31a2c5cdf67962cd8bdb1dcd2a0741cea8f785112520285e92b0ab0704d52263fda4c67581c44a2df75709b597105696ef37fad703f9696ad31a0c80daea3c3e9d7e2f55a9deccefe10ea30909606cce65897786fda4684945092c5591d460c4ea19ec1b89e596ce854b1df538c95671a1ea88cb378fab135a1fc7b04a9f460e4b1c5de73411d71081cb4aadad6d783f69ae7511e4287ab3f8a7e9dca6de7c3da4c971d1ada77e90c2d3852b874914d8dfb433958e692eeca1f2fa20d3f22f9e624a3e251189b546288580088a08bd485bed94f09156744d818d66e159e9077040c126edc54c2b193d078d3f14e3dee4bf455236b17799852fdbbed3e19602f64cd293587978ebe200378813bcfeef0069ae3f5faf35505531bc714540a9c9f0ec3c279bcca8796385a6ca83e002fd1f7938b27658bfc249cdc4353c8a780a1f58e60b41864c0c1d9ac9c1f5a6f6a4234f8516488bbc77e2c94df37bd63c5a9ca8538549bb33a0c9ac29429c9cb7ead5a24e714d3f2a89d31a64223f72febd0f08ace529acb10667235c1d94dd360b4869348550a26495cbc6e194f59eb84e1b8608a852145b9fdb3d8a2a8d5463ced8599427a5c11e3a4224dd8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
