<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aeb273440550808ba5267f2ede11072d69c73338692a9585429a09a68494ed64b1ba4e43a02724e3d39cbc840bc1f16568653977d24fa5c5256754dfc15033ec417d2972272759f6db9e31294e81b033e1b80fe77cfac6654e5055f441eb9d89037b897c8a1992f40e6deb20c688d292264bc7516522cf2a039bb5dbc6197b6498a59c218cf2a0dad42742d36060d85c6b189e1427b6be8e4f8ce3696f64be179d78db9fe1a71c327b5d35166d97ff0f4c59271994f3b51069e136ce05b048bcd8dcd5ddfa5eb21df50520bee9ac837c941ee62b62196f88ff2f14166480979a36a69fb3aa4875a95087818ca93bacd44a56aed30580ed686645010e1560fff34d14a141bc5077e0510e7c90406fd3ad865aab3d4af8342b5c5949ca3196c9de169815a1d5c3005ba1c6225667a358f510b5950ceb9227c63f80b98507877117a0903cd578b1bc46f29191f7bd44bfe2dd751e70df417436c94f4676843e09fe087bc9c7d75db9fd48b3cfb57aba9ba771ec6769f86317190dd6cd3dfc1241e7b96bf6ede59da77a33e7ee7947890cae00f28a6e8a8bcd7d78cae6e08fc587626b71afbc6e9b004880a3e1b79198da3c72ff38d452710e0629a8897a9c4ba7e04095b0b2dc6a3265bb1e140b60350364eb186b4525a44babc10c3a287381e12784dca05b6b00e86bf6de2191299d6bf7632b07f2869e9ce0ec1909a979ae5c4406dce1db5d0c759b59686f1d2b846210bb2d1d7d287ad303c8807786d01aed3d6cd01430ec7171b3cd3e88b44f916787a321b435b5605f2d827dd4eb50980208a3797515a451ed5a687294365e5c9dd56b4e5b0d39342d1d1c103b3cb2d789301d8aa3aa3189202b50594fa33abc4777a04f481899c6fe5a1e21ba7fde2ae07efefbfd568e96697e83543111af86fcb8a672962373261c4428832ce337505e0d26d549465e41ca25f4bf21ec359cc0d035029c27a85a11df88c1c0a39ad932fa20b32d1d5f2963f46ff48e159fc656ca8a0e3495ebb3f540f4df1f19b3be1180ad726b67a07ab7ced48a9a73da1fec6bcaa1e4bdf9dbf943e723fd9091ca1ba3185c42a19f4fcd244407aea23588c5eb4a5aa486af9e0a8f904da5f43636bb1f03ff45bf9a76a52abdfbe0fe53877643d09198565275be01dfbb2377e192f34f0d0d6fafd165bb4d9ce198d896a761196e7c25fd2637ca772978831419927634f1b644cf9cf83962bf86c45326e31faa814d53f5254986362d27ca60f67084f322826467d5960cd244d6d07781ea60ac713fbc9dc908a613ad1949600ce34f0a6bfa4ca4487fb471eb74fbdc2037176e561b3f6309c599d626cc93c11be5b3e31260e299901bb20d87d0b3e83fb0828f1f873ef1ecbf595025863a461ec169a7c5ea9fa5fd07c5c512678f0262b57237269b6ecb7f8c29fd5f2019e199b74a94dd9d327ac5e7138b18bd0198da510dda66a3d3df3fe5f86fd9277214847a5607b6b5e95943bc17fc41645595b0bfb0a6d86eecb44025a4233a64474e4b826dce6755bea450242bedd2374d1b7dc366ab109714f19e630eb669b0b44a81d709d5f4cb22b6819c0d476f8053aab4b34eb9b5fe09a961fa63d8d16f6253bd1952219b7bc4583bd25fdf6af2b881a85e08591faceb55c7b8f9222563a46aed0c73e45aba0e62b99c0fef52e7e19d302e5db726ce28905ff2550a0f5667c4c3f564d9d357b9ad17ab706fc905ff8d99c610d1f3946497a7044268c2ea92f498a5176f500c2ee4cc88dba13e9b88b5b18dfd6b8b954fd08eeee4f7669f204346b3f4bebe0462730356113fc065b0c75c05358f99469cf371f37f2319029903e450e3f410ddbabe0c5cda4a57cbc5a5370296dfdcc89d37c4ce8829de8468f29c60a4f8eae8984fcb0b0f7826d0e288566761d1d09ac38a821a04c4545008e817f207a70dc7b424b466b0d018405d80172ffa70b9fe8dd9a71814642426e651e8a5aedc78515fefaceb5f672a5664f5d4d0e717a4d92fcad0aa38005be61acd72207a99344847acbccba77fa7fdb9c16e0a4c5129c6bf58e90bd904cec0bb47064ed46bfc366e8642c111da73e3faa436b11532b4bc3a90628728886304bbe27a04a9b5fe1721c8f1e2b9166507639faadf6700fb1347fee954136de42c3c154ab3085c364aa0a5a9ac0e2cbd07d2e2151de2f2452e26011b2c5209fcdcd8985767c512921ef5b1265a15a74325f818debcc96dbe9c612f76f13e4f7de83c88ed38bba269aa8f824c82c387e68589f50f3c3a06f574fa5d93057a4db2552fa64dedcfb543d30379ffd15e69905860c1409e194e23efaed61927fc7f8446d843e9f9fc40ac1137a24a51e5d773e10264288db9d46cf5b19924356898f25b4ea5dd35e8d6147e9b2bfc0b175caa9f6ad954c5e8dc0ee21cfcdcc2e4db9029bc81825376508e2e82847dcea5935e181cbc553462ad5f152d2e3f5c855dd4cffc69f400de0528ce5b4a8e60fd2c73533516908aee33401d9a86d2eceee2168c0064818975fbca05ab9d6c0c09d4fbea13777c1e8d249968df77f76f5b74f09290dc1757e286f91f83a019227123cf4142b46ba1119b018bd11b3ae0d06903756dee06fa083e5334f8c033be78ca0b453ed478092d9926e9d1ab6129b9ef3ac2f0a2d654380425f486c2b383ca2a2447777984d5d67190705db5b7dc024479d18b30ec32ffdbce37bec4ccfdbe93ea66b511c5b5047e976e4cfdedb3bdc79c4fc9d04fa451833b544ca81df93c7bf45c1a567ccbc51de551701ec2267da28009c8b95b58ca83779f7a6c4cdbe89389b29f6898019844e8d934864833ca0569dc92d7ad977827f4bb4b28b1d64bb294bc2767d5c1a145b11f34e094f4673523195e8043c1d85c7fd82f2f27a5ce1aad91a2f9f0ab8268375a467320d31ccd88767b01a14f026149c14bc1d25c9a393323719a5b0e8365844f9ffe6863b569a5bf6d34ffe330d41b534e4f78cad66c0714723edffc5de09ae86fee6d0b03e1ed1eb6b633c4f5900e973cfb14b8bfec3857ac543b43524767ad32dc8bc00614f641b6d57204957a9a6f57547f9a4959da3407dbcfe50e5efce27634ed2f8b739970f88843525d49aa5f418464ea7be0cd6ce1185ea0be3b2273c4dedb5ce4f8fcddffbef17381a0e65d5a6239105d166ad01f77c7c5a44b7fb763a660ddff5a8d552203db4c0d74b42d29cb04f94e139cc8a5e34612d74d9aa238844aeecc5ba550529b928c3f6911d924469a2b5f07a2d47a20db8b6db682865cc217cbf042d0aaa1ba41d219f6b5637dfc7daebd92e3e525d142fd65cfa931361da8f1eac87d35c335af56cdea137f90001cd0ee89055982fc74cf302f34086599c1e39d394d5770ebdde70521c1cda7bda6758fa78ae1bb48d6d551cfaba103f38f45995a434149a06a6be0a29f1edd69b4688201888d984b89c637dd209e4fa5c301537e83e4fc734aeb502900ae14f297baae3bbe7963c5304fce0d224053024b23fb940bb5f5d72dd569dc3602bae2aa90f15e2b35f6c76c74aadf48eedf958a4ae460f0f6e73912d10dbf1e94c1d31ebf11daff5bb422d9125afe549cc1fb293390e57ea0b07d2d818ac8f830a979574a7365e000d2867dfd112b6f638edbaaac08746ac21dc04cc3a6794e21715c7ccd901412f2863dad61919a33e6aba6db9cc67cddb55799e27a5fffb8989895a685fde2bfdc8ca230449dc3ea164a0b8580b87949a574a9dc6e2101c05dbe0d6404a9ec9016700dc904a8b167ce17490e652c68e869ecfe8f6338180e49d1086698594587feae5a06be019928f66937f96357ce34d321a436f5fb96d136db3c391a2d1a413ca074f798d157665228c50355bd5dec9d40bdbc3abd951e91277e795cbaecfec14a885bfcab4334c3afcb9997c259e64c2207e3c0799a90724e35c573aa1c5cd802a7fe5b455b4cd5285e13c59bfa26d9664069e1a5e8d7fefcd83c5c0addbe36e4d581cacc653a5a059941b39dbd697628851a9d422caab41f5980e0e60629a96031c11c0581a353447308a2f59d74af8c7df92315516638b3c25d8511ccff98dd3c69f310a344a46b983a813496cc47d13cd28adea30399c90ce6b032dc658b6113970180969f7ed230e3bca652f014da32a463065de8ef500c4fcb6f9494ccf93861e3b3ae58c77ce5e52da7d92f1a3e8cdedcbd77e9e5e7817710e1ada8be1b3fe65c4585a9b9fe9afa32f58d250a27b0d44b24b9c764364921ffb212bf1ba6bfa0645794919b5427b519a1082583cc9bcbb418230675ae0f508226475610a0477c4d22ae263ab09add850f9b96b6217e929fdfc0111a8abcab9581769da586e61d39451e9a5c83ac4b9acf5d74a335c4ca33cffe8a8417f9271943aac442328e122de41405a3c88625024662c0bbc72f38274c5bf05b2d7b4a23487ed5e9c23418a75e2813ab779d369ffd89d6d1ebf2e2cb77ee2d00e22a5b7d1766d988f4bc7a4a2331934a062f0c70654de1b06a47745d84dc08ed2b008738a8790a0ae7d78821bb1ccfce261c232b2b695506d91ea338fc2be2ab8f656d6927eb5668b105eb77718c12a6cc2ac83d565a6216e79ae1f84689c88d9e68b1bc9a860fbca4a7523b9272b065dabee596ae74252298e3661cec854a34747f98b60a9e225e104baecfabee4880d1fb1b06109798b6ac568795cdd621d170b99a8fbe88226e8f9730ed3b1b30e9191e58628475f2f7ec5e548d682434adcb0b73109444fb4c35d464df45c599ca3966dff40f695f0f5becbe3be06c63a951e5627bea4dad6c89bcd653414ca0c0c562044a66f57013bceb6bc8a52bd64d75a1eb2dbd6729b98533f3abd10cd15ed5b615c47a0ccc19a72f0f5e4e8ae0784c2ddddac113484f297204255e22192febfe2e791c6f45a0e5ab7e67b9b3a55c3647f4c0c9092a7617aed8a1ad376988e6b2d5284b2a19fb3672188ea7616ccaadc7f1c28cf71c25e121c3d4250ae65024e547f03ff69c4d33ea94bf63bf57c968d4952d2235c047786dd84a41219de309f5f69e82c9422a8de4dddc9e6ebba82d6d0c197d0b3f6f247ee4169bad74d4d1d3073deb3a2b421dd3bead3cdd2d2a1308028c91f46cd2764caf108e2881a1e60f2c7d216eef52ac4496339da61343d04072057b3c89fe65dd052dd4590b10af15df1abface29bdff1ba220d2a9a2884cf838d54f13ade6933469a6160fde326f006adae455d452019f06d49003809aa8908cded56bf4cf9910ca024b3a8a205ddeb4183dd85f8d00f6af8f3f1fe6d753974a963643971b792176d596d93e67f5dba4d6fe717f6f15f2d3b0559113bd6c2f2a47f1b45a7c3ad5a59d0040955a89385a26fca55c6332fe58ac1ac91856c653fdf44d37962bb7691b6e8b067392a47809e126ff1cdf8d0a1fb12508dfeef4943781ceec5b436f5bec56264b684a7991e7bfb2d11514220e825cef97769aad5fd088b459ba9691f7f42f0d207980792d0aca394afdd38aca8dd145f9470eb135f84bb0f24d351531d3f423a97526bfa6c1b878d471a8cac5182182b744cee351122b800b3fdf6f07781e0ba3a9b30ce2236fc1ffb517aeb8bb19d6e262f69e0a38e2eb1f083c45c6c95396722d096d30803f8f0c0a74eada01a6cb5cf28ebe9ab5b8ae63954173d2e673ea363ee671c25f2d87768c0c80c047d01d9db4e851a172e54c21d5be8d30a8424d7a61f949344cf540155b1fad1fa16411a1bfe027d6111e5ac70aea0f762d7f4fd284af524f2596335eb7fd3748113f3fbb85adece2ba1be9b77aa465dd4bfddd559f29110b6c139f6d52d23d783bc87693e22ba9f2323a6264b8c58c552e92a5ddf7edeb6e79137e992acfbbc7af652aeb5756457595a0351c9c1cab0717fe2ba5ac9f6630fe95dc7edff81b66a8a2d5d20fb50b205d786a706244143496fd55b5972ad755544e30b7d62cb4e80512552969835a3e3e31330f9fc85452e9f083d7d61714e28f914675c3ef8a0309cde97921b7c40021a7857c52c22c7644095c63cf81fecc58ce816f2a10f0360adf0d6205aa3c447cf26b735c630ed69ede83f84d31087753164cb772c91439fd3f5b43c6b97b3383f980814e31e8e924e0a89cca73622a6fabf05e328d40629f2269c39df9ec1ec836da41354ac56e58a59fc02cde7620daa58c10d9d028a3cc78191135d89b1d01f32b5734602931b78cdb36237cba751a1e10bed65d3d3119da762632a1f309560b8729f1c856e2a291b680914df5df816fae912a186f47780aa87","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
