<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d3fcb2e4c838fe48d10f7ff27e1c8a93c33a09630f064366d844191002a76c17c17dc0ed2b4ca65f96ee6ea52c0f97045c737669c9f93e3f89b65857437024fb7bd40211ec100a65597db0552aa060693b4c3db68bc874c73595961d0cdc08fdd56a2a6a1ff86025c6b12c471d7017877194560b0716b25f07a24c796cf1567646616fd8a881be43f38dcebbdfac2c898b9161820a57984ca546205826b32b2d177ee5228056c896e23c89028d4e908206f4e1fcab0b98854b70d5a04a6d8cc73a8f909f5e04bd9b685255720cb64c90b749e39966ffba12be1e489acce6eb2dd9775eb7601ed26ff0857f6b76faa558ec69904a713cf907b31e9a036ab0f521b8f883f2d55da6a585291a8b84ceacca7cb210eadc1d4a84940f27d263c49e6d911fadb37d5787108469e6ec8cacfe67bf3ef896942086084f093298e7c39a6100ebdee8d42d17fbcb06fb286451762d65498ccfb0b8507b8a89bf1afe96673426c924fb951bf7f54f5f7dd26aa9535d2d3617509728b203e7f42f4eca67be009de621dde86fddff4cbe266156b9640e1ed34fad1a01e06b8d791f39cfafbdc1ddd67ee5400a4c2069065bff02fdc008e7dcf954ddc3a7755b7826083173e12e290f27d0467d3654df89c6cb1b9c092da8cf743f00febf1e1c55202db0734dfda43f33d49f5dddb99d3f02596254c34a2e82b1f4d9647a9558ee011f055aae924510a33c6758a2e74ce091dc789f9e668ee1448a4d6161be63c179b9251a30653013b4f89e2c7ca587f7c19954a3c1873ecbf9a4d302df5ea8599a58aaebb184ca512d804b598c67b86b880d77c628132017f03aedb9ec8aba7816e2de7efc5c1be81ac7be33ef29f504c04460f7f00fde8943ec402a689fb15ae83b4b0efafdb67de01c2bbe19d8135354f699061fbdbb6b337ae381ca02141f8b946ab3e4c47c55f044d1a5bba5009bb6d2c49e455f43b4fcd119fa0145434e930cbfd820676865137d8a23fe02267a1ef8b3e824e206f64b033484b03faa566704b1309fc717e57d7b6c43efa3ea696ccfb70fc1fa214457800f28f4cbd5c4c21e6f25865f5b63884d5f3c4666f1f57c5ffbb115023dfbc5c5fc39cdab24ce8227a81b040d8bd1631b769f8398805b17f5fc0e363c7ce45eabe1b80a8d3b9e4b9ec7a929acbf1cbc394b4d81a05b511cca049b62cfb0b0d3c712febfc372a8e536454bc82c6bd557b000a6bedcc0d6058aea524cf035ac9e5a560d2f5e032d4078197e050967672bad152ff6a240a42c8f1cb9eb1e1a49ab7eb7a377333c048e45eb9b819da252489acd202852eb603a1f28e955e5afb1ea67e4f6136cc285a62ea88c5f012d9bc9a75c135d21040098be741a5aef921fe2f4c2ee0b0e41e4bdf93044d9fc9ba6e91297074f2be171152b049db5af51be0ebbcd78b1fa51059143953997625bf35adeccd59a8ec88d484ba33c2a182cd969487de01bce8da5dac36f2824673d6fdee171f0ec4290a15de1077e85c041fd63fea6238f4d781aa9e6b0a31b98e28abe235db87969d1b46cfdf37f54d50bdd4c8dfda6c5377cbb4ea805613769ae3a8720dda91725a6aa49f86c1ac92e2926be0300252c2f76cfefddb024033d199d8478fe23a6686e8f074b8204c114373b5076ebc024b8594dccc117db9bcc05aa7b07d97c92d696230e9b656a013f047c5d549c3426096a41221de5fcbb26497cc3800a9723e363f286e7b460387dbfb6c4079185ac1ffb1a420d0437698c38e2949e457c820e7215164a66a6517035a855e6b0ca5b52a13c1f7866e6843a2231417bf85e32f32f13b54d41a03497ee731c7f674a36030352383de0de715b9757fe6c7146b6727e2958c20d3cd41bd2fe18dbe81d5525daf7fb355f38179e8b2c17f47220e4c2b9540b465e7305bb02128cb6d8c20b35bc5295e48197c4675833c3d21bbfcda83535677f36323afde94106eb55f509665255f55ca3b3f1ff59789cf5eaed0a025c673993f7ee74ff5d0cda47fc2a37371867ab076cb14a82702025a9b16d729458f4834801c6511a939caf25075974239db8e560a0a23aa09f3491d72f478170bc6ba8cf5c4de746f7f2a5f9504a93d426cf20cc137735fac3b2f4a9e60b9d5b2a702ab23d89db64f2916dda3671526c3507dd65af6a5cf25966b3060f2582c9c7451ef3ad36cbbe955c8e5ff6f4bdb41613608da0bfc2981062becab14acdcc0529a24c43a1300b65db174a0d5ea9c4ff066cb533f97f1f9982b9ede34e0196224cc30f7c1f8c00a5add5203309a07c72e5e794fb03090184f562874bead481fb1277f76a338817422784fac9c95991f30c775097bab03fa774cbbdc02657bf397b7025fb13bd992088651cc7cea0121a76c2da8a65d7a9fe3a83391235b0c7ec46841a96672233cc636a6ddff1bc518598b696e7b27a09d0ef20ae0cdd81e0dda144d79a4cf6cc125ecab7b71772caabc01a07d2bc501210efe677bd419835be20208bf0d5aaf61f6d2d84dc3bde0be37f20255b30f8459a5e86ca5ca95e38083893ef6fca9edda4c9a3714c42e493a687b3d40c64178d27210664d7a34ad47c5de5820f48f05abc1985f78d1464adbce2f18490be7bc0a8d7f4b09e63e450312d8a5dcef7466464c07a850347033225c98a8f5940332238a94e2c36b866941487326798b3920381217f76353d310a62b9484dc85c235f3342ba0e65b82f4f413f78412a02aa1e39f7f004ed47a23b25e900a71f4eca1d6c23fbea38b2ad709ee93a231c0988bb076d63a4b5b6da8644df8b94989d06085820e0eb18ecb520d3d00b0aad5e1805d177e15a02cfc07146d299c391031531416d082c22b132510aeaff3cceafaa8c4362a52eb03fcfbfe3abbd13c8c9b16475afb7b61e04fb2b5a9c0ef8899f8199bb6c008a5c605a1afc0af66ec299eecc367fc5e29f7c5b39ad0e602bbcd69376b826f588253418b38b715d9134349a7f0768d2e361470a845024123053c65e513c09f8103e24a4db42765a9631a8e50f5f7d48982b12e700b43b278c4c25775e7dcd3fc5cc2037b162aff9944603a1633a0644c8eda860d1fdcd642c1f0d49b8c91054c5d0502e55d8137502e82356c5e49f62263fefb0f91851b2c23feda103fc444c6b74eee403285441bb93291b5c7a3fb5fd234426e39279a150bfeec437328154c57688812df946ea07d561b7f3d86e823eba46df03ff697077dd5f360e6becffbb544443527dd0827ddbfbde34bb20b9567c947def0cb41d8675f4058069f6d13e97a468570d4ac6aca6403ea23e02b2d973907fd6351b79d9c408fb254645a8d40a5a4506a5f509f68de0751b1455297b529bc823f1351c68fdb6d135daa7b35e050cd87999120e385782488de3d459b626381c58719b5717a5a9699b94603640805c4b5811b5afac8fb702a51d2495256d4779b65b255831ac3bc5aa63dd876f1be98eec07e93ebe45fb1111380daba3eb7ef0137292c12cac76d3118a7bf6a7ba4d6415bf23a33c9511a829309f7837cae40cc3defa1eb7873ca66ec6f88e9cc1172aa0de8634c5b61d0452e21b75279dbe0a16b3be79605e2b070e221e9c45e40dfe9b478300ed7601737347b124dc41c07f3dc7d4a6011f7c98458a8712038fb2a5aea38acb1c7fb6ffef889a0d4803db771011322f032475fb56d172df8fdf37fb1c7328545d54df1cea1c73a16ad4e5cb38e6057fb0dcc53f36ffead558e989fd2d60a7daf63da36c8afea062a7520dfbdd2cf6eb0d1c9ea83d7de5fccec8a5807371e0b6d40d1bc37e9a0c087020a84dbd5d9086656bdd8883b204f618abe6371b500efc203443789aec4b5ff989ee9331eb1fe4c09e0d2b9f3a478056c0afce135d77f59a26dcd9b8323a2dc70591e415d12be1c2d37129cf5bfd7529e63c461d40da0eb30251e49566930971b7283f049a3d2509a717fe2b7a4a41fba5db291f5158d70528650ef3b3d9bdaa29275aaa34ee563f428ce0477132474357d2340e311a3263f9dc4cfbba11a6f34e15d6a250e36e3e775c217fed788bad213cc1ceb0ee223729a7fa541d0efa01a2637f556216731923edf5be9b6d2a2127602e4f0b47b2f11cf08a7fcd066b4cbbef41a0205889ae387713b420937fcf45094963f4945beb831d7143c84c03f804b9227c1f76ee982acff8536ccaeb188faf4dc456f28382aa5fa092d9037991d18a2a7967857e2318491db517910d3fae371be12191604e3ca74934c9b9f052338fe3e2fe2d94a70ee9a2f20a055d80dae3cf5354c8d2cad748aecc2d91ef969cb7ae52524245b449e867e5b1dbefee7a5a4a8b7319dd641b9bb71188bb7ebd988d7a0689058a3f916fac051dd82fafd5bc25ed766b0b9d228ade90331da33b58ede92a8119b3fc74a8a8921205eb7cff3450c26ab97f8cb182f67578bd3ae11aad4bb3e69fdb92e315715444afe9a391dadaba94fc9b25e1ed97a6103922c0e5b17fa73abaf7f816e0564dcfe28efc112e2dc6d12f9ed4fe3cec973662f8285f66ce1416e12bf11b8d12e16477ee2a0c229c912af8a39e6d3c86c4df21703918cf05a79913ec24981f3eddfa355a754d32a556d2fe2ef4492f1554ef44d3f60d738d9fe6471c0b958a9d898a550d9bf92c5c1d25671a6b007c88febbf45117c3df9cfe2c346dcaed5f6fd7b8c13575357fb4dae36f1d6b3a017ada8c41a9131d6143291fc4cefe97f35c60c32c00c9e92b39a83a283a1a274d7cf097d6f3b43900b6f423d85826c0b388aec07dd4194542fe0a53cfcf4d38be644f6e4b511815941ff4a66cb4eb7fc4e183a1006496d5be0c762ad82b3d91d643392d03a8d7b40c975bfd9b0b63965fcb7dd85174cc381fa8fb184a5972e9a4e9323b23f3c725ba8fe22ae2e2cb65001eb5c2c7e649ef015d3e24e9ba99586232d52e0dead7f0b523ec3a25d3f863bb0538195695c8bf7594837c4500ce892b75f1913aea18b3376634cb98256955b8cf4ea6b7c803ff846bb53e82d66d88528212be2303087c82c5a10c34051c8fe29cab0516a07a0074ccd1c773d7d1e323a9e822e186e7aaff4be0692aea24666033dae1a8f08d3ec5ba0bb099cd5fdd61ce066b205a5268344c03498c20e46aa504ecf27e2d612a76e45bc26bde7f8893927befa1d145a261780b2b3947bcb2a7840527d31896eb874b2716a9d7b5c1cd4ad4b63affe6d5ddf4b609c8ded90dd06f2af40119435299a1ba4e9f9870980ca920841a4d52710027406ab084584d116cf34014a3b4e5fdd6daafdd4596aad309b0a5cf27b5071de910ede29f8d071e57a45cc5e585dc8a4cc7d77756c47b9159bc7e338a4e93f7f79084bbb0c74e0c6d949f0a9e08ff4b1356cfb504ab7c2792a1ec43a744982ea7a1ce16f493c5747d47ba12dcecd9fd66a2d9a371cfecff3431516d08bb1e12d787e8dc89930e57976dbaa6106a8ff0ca62f48a4cac7e3539dd4a36c33005ef460b838bbc39f4585fc42f1be41654171570c46c061524cc4ed4912d5ac1aacf684ccc7ab3ce64df175548855e9babbe9753e6a846613eba5cf29278b9128007d5f287895a6d29058e2d9868fd6160ab9d7777f27861439e1e9b0e6dfb5cb050e7f047a4574acfc783878dfcdb1bc59505bb21b82cdb0d899e788a331cd8e1c338eca7d977be78cf7835352deb057d3b19488b45e478195e22bdef536410ee10dee6d73dd105916e6227d2bf935a775e65ec451e456c849336e85e04c8502da081a6bcc652dc82991ee92aade20da152eb87e8086e8f304f38ec4081f567f6b9377982bc03b8955b58a9b8eb12bae35c71e8f5379445ea4b5e2700d026871675d24123bcacafadd5a078bc2ec61bc028fcca82a0bd1fbac8d3549ad4a4d65fec419a03393d1bb5e9bf7cadb8d54b65f6339412f6948d939de610f23ee1147dca7744aa37055930e8e93925537eee5b212271131dd4ab3573b3ed674e3c3d38dbffbe93cf8a61ca0fe6714fd886a19b179b7aef578663d3565827fbc17a74a9e5de7fa00c4cc3338b49815914d5c1aadcfa2f731992de8c18f8b85a0784c2d57ae867f6e7ab03133225950b92f747c52bfeb70d8855ed4dc9757a0f26b89de8d75cc80753969809b2183bd3865e1b084d52711be4e78b55369df7025a9b0ef7ac6bafd2ede52ca4884f86cbbdd8ae26ccf922aa5f4b10e16ca83fd9942698c9026c693ddabfa7e143c96e4b32ff227b7d97f79102af56ad51708f1b81c1496ab32f376da46819a5c709ae36405b653a6ac4b43eda1039ded8b2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
