<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3450b2f52d0c473ea08163a028831314808225e4daa79893d5926303cfe21d57db42da7e0dbdf9816e99a69699496ec8cb46c555bcf84b7ce931f451cb0fe360b94dbe63d5ac98c596fabe8b66e51eaae00d303b029215c153bc3bb793c13c66f42c82cd4dd69807c0974fe5a7d5e7ad41977a36b277f40558db2b5a8657a8768bfdad7c199bc828ee21fa620d195a151a0a1225938458a86885af91280512d78e4c1bb13b85e15bfb7a6ad6149396c65b6fe58efc58ffd3af67af4fcfef7fe0ae56680d41b5e8986675b9330ed73abc41f973992f13491798223af049aa5c3d705ee54f2852aca2cd7dcf1e204a06b565b31d13c9087595efc222b2ca4b1a9a6e4385a1212d66700bdca50fab1d3b7b6b99c12d45f4f9f242419d55f2eb9f2cafdccba738d544ae7846b075def614718aeed2717fcd2c41e3be2de86ad6264086a23236bb195d3b197f2a7353ef2ef1a6f5bfbefea0fee2c1235c038ad630d6bd290989497ef3398cb8e469ca44167c5a2c101f0c7b4231dc4bdd89e41bb3e04f63564138c2f11230c450ed16df1931bff87ad7062c17824f14a058222276ff321f628883b2e9241d07bb059b0530f8cfb74ebd636f3f854ec3876501ef0b5c4013ab9fc101a9bac0834c6dfbacdf6962e6b87db3890c7112e5ec5a2d034ebbb0ec71aa314c7470857a23dcf0a1e536a40468ee333f7efe962e5f3ca277efcbc046beb59f6bdd936640029e0fd3aa29c145515fe14b6740f589c651da4ee4b8fc00e30ea26c92cacc8e281be90b42fe07eae8e8bc2bb05d1c10291554dd69a12f3fed29238e6eb4bee234191b7602886add59931825f64b761606e16bbe0b6b359ea864122018dfab3423b38b3bb8e3eedccf047ab521b28ee1293ddc9f0d19433c448c5105020e65fbd2fd362a6b06cb8737d7a05b8be5dbc575cd37cafed0bde27a6e718498f8aa1131b68541f301a8c29a50c6def7aa425a5ca4c6a301d6ce3570b8cef2ef0b4abee03b6226d2a047abf51c76296e775af461eb8ed067129fa6a63eb7b5cbe4b4be967ea1cdd25d9e4c4938129b02bdfc0863f6317e54e2a988a9f09bc78cc600b1e8b933fee041ee0da492f163a4941dcc19977f6524c3ecfc8acc9a7d4437e64894a8f4a65978a9273b92c18b24225814fa3d04fe5a307fd842c787f2e102d47f3ee8f0db4cc0e7ebd1357900ff20d692473132a5424eeadfa74b6ff0ef2835a824b0ace5e9c9291ac816dc1859651242edf61f5877dd4619bdd78327c4338e6f89d042c21f2b0f7c4f1a3c06d7715b8f97607b96e3a8e0c6c4b00a98889429eaad9563072e395814af25814852699ac1e07d41806e3db4b860431d9d33481ba0414e539494b7536ecd4dd9128b89a88d2c901c3c76c0828004021719c5601cc807832c979f1b099979c66c2040c9898c9670bd422518928b23e35dfa8b45ca5e216acdee23dbef197718420214fe17d75b53e5436a6123b4af28c34a4c6ef7c5def7b1725336ed653dae37db4c4fdf0baaf6e792cf3edc2f0fee82dea36c1ea14f54f674719376657b9adff3c550a47b01de3052874eb8c6bac63091cb786286473cd5621ca47bb70e7a823030390916cee55f3d8782812dbefc0a95db0ebd4fdd329aa832d5b0c3ec1493be298bd7e0504116b8b22cc8f69a0f743977eb856cf5f0ac26c5fab4ff835eb7e8e922ae2c6439ef96e2c088c1c080f810b287491deb3aece000df2dca5eefce2e4b0cf88a5aa540231d63b9f58a74d606d4a4fe4e65c6cab2f4890916fd7192c1dd06e24d37035dce9e39f963805f1d66ff4076ed71d08d248694363188d85c181b206b67c1ea5815a4a5bb51cb8d2d51054328f6251b18e1c0a3a128ceda7f9a341ab017ad8f42105fdfee3e9d5e0ffa0cbe0e21f74ac80470790456ca807245180227409c902b4261f95b26704ba03c7e3d91c6d34be4383bb8e338909e4bce0401de7497fce6ddc34cc1f334521294c23e44b420de9c643c9e3b1dc87ce23fa215fdd237677543a03c6253a20e2d57a23f3b0c698807e5544d9d9bfdecae7ba76eb98c847d31eb7f966ca49b0e5525e7c3888d2a7a69fb81552dfb1571e45d0246357e67f723af9a797939e9b046759c176f38245d01fd9273b26596216b806c8ea094dfa8b565c4468e5ef9f68215ef350fdb828aa4457b5de7335d5fe83faf600114af0a9604380e3970034b60fc8d6f6d85e2ef47004110cecbaf039dc9fc16ab852e927b67ca5dc16e3cebb2705bb2829acf397ec550f54d508e5cc891fc805fec737caf99dedac820c7bb014c3d9d964bfd5e0bb63e987d9924c0c7865f1f054cd03c4b53bd16b6fc1613822280179020837875451733081e3fb00e57998d65ea516fd85bba378b1a0be3f89f86105c4be5bb1e5b0206e7173a7cbc951fcf42eaea03de62c09a316b0102e406d09d37bb48ff36c2bbf6627ff08ea6d63842cfda01145cca68e2f3b68929c5db903e0d7dae2a8537bb8ce9a64a6a4a56160e4b60aaea4981bfd36dd15e45d5c3e900c8dae119852e65425bc381be2edf8b0eb06a7bf76f8c4d684a52d422ca4a7492d1566f37a2376652d1caea2111f232bc876e8e8472375142481529ba92eaa154a99926f3f65ec2b9ff19f1b21dd17c5599fa6cf227a7a4de2a0d02ad06c003c08f6bfb83930b117399dc8d08d10e64e247cb05911bd17f58f1087440cb952af116925fdeb7deb25747a95af151f3a65585c1c1b68d4ffc496eacb7f1d64771ec123d72452109180d068bf7a5dbe2eac3447efab1d10827f095ecd601a336b6e13211932f74d902d1e78b7e14d74d3fb111ee8799f364c70afe22ace60a46ed631871474f4ec691bded2afb8e50d48ae1479fd610c4a162fdcbcc4729b5429ab5046a9bd37ba624df92765a95dcd79b0a7febc3cc986104964ce1f8b581fbb33a16905e690e8ada779d18e2232eb0055c00fb0fc93cf891272e524146fdee791730b990e26117c19b2ca9bb0dec35bc1dcd4f57b19fae408f16cda78f8dbdb21fac836315bbf6c26fbc4db8923b774b3e925ae36e527f8ac124a092517d08ee6935239812f6ff62a60f837d166a3b4ce19666a6818c41a20a4ff06e96cd9dda13e8c1acbd41c743c130c21e2851fd8fbf4ebc7ca87058a6cf77e46b51d659b47265ce4c4081a1b33ea764f71ecfd115f0fde52315e00868a41993260d38dc90a5469164cf397419a43ce5aeace159654ceef8603112537ae603beaaf60b91f0a312ff426c76bdca06d474c7afff40a1b5a45d5d4e2073c1ecb3166fc997932831504213acdd740a7d699a4144a689b6282f9e8125c076a7fd0ee6d1362e08d5d72de80f2fa084406aa0d1fd3dbbf56890494691ba25e7468c7445f1136f4d80d7ea6fe6bd2bf2fb5fc166d6e6c6d68240df28e384185acdfcbc6223310e8b5a4511dbdd683dc998e9fc3303077c133574c6cfc660a61d6c4072a5c4690099837c550bb8f653d24d454bff43d31bbbc04f6f26a5303817eb0925463e36c4d3e4b6e77e08988767da70259459c3235cb92dbd84d7013109e4cbe8a568cd7f1a4c163b1fc81666c6caebe733bc4f6fffa1792f7917692604bb0bded5a6525d48d6fa1220da752d0e21f2d0f11489d9df5a37d0483d7cfb8cf630c075ab07cbbde1f0ebbcd91d805d36bb6f9ec801d3a97bfcce736e9e8f15e3aa824267c9436fe37626956c1942593524a1de9c53adee0ecec43b10844261a9aaddd8f2bbaf49b53a8a16683aa8650c0b885bc87608b0c9d789a27ad9422999e714fc509ba4c39d6763db51acfd2ceff0f7e2063005aa8c7aae5aded1713fe02373939eaca40e5e6642de7b678202872b548b85e2b39545cffe247526dc5f0b7d0c3225fca3e6201a2ec64d34e61097a4d4772d92d243873a3b108877cae9d9da93e264fe8f88d931713724c444f9e41f6661cf22f3e62aa6d5bd24487dcfed96c9195d559b435e27611c2c4b65303248054339d51b8a3b0f539812416025993ef2dce6519a3cfbfff0596aba7f62f70b3bca23a35446868005e5a1c121ba70258a971e8f127adaf794ab825dd7ddaaeca0fc2bce9feeae4c92bd78c3b244809814f71429a28f7d84c0af116964269055a0d143fd30fe7f220fb89fa5528b80f7518759be2577b91bed4b14e7cfff28a376af5a4d5e578698554bd9290abbab714b4eeb9c257a58ba1391ef01f7c0fed69c792dbf78637087b1363bbc1262454e80575dc4639381a868324d66ca4c84c2f60f7957f7972881f1199b56ddbfa3b0d4d4e31065e9610c9505fbb17a977f6ba3ed0e27a3830642c7c216f60f822a509b9aad6bcb5536ce59adb62ec962c71fa7392b86190941b9acf3bc415b91ca5b2fb5efc7085941eb2e66de519ea4c32eaa898b772cb4a918e50f17ec660c71fcd0560dc4ff896976329c21f1996cd8f8921a8b08bd0abf85583177b68e361766c4b027037c54e93d0e10e246c10c6464e138cb8323bf3b9b9138e72d2da99ebe17393f2f38eb652ca4b2e6a5cb20dbcc7872af3a1b71bcb7507474a585a16a57bad3cd4ad4b154c0b3689e77ab43c456e24608cd0decb11dbdf25e9d8c7701d9f529d741884a943b4529d15bd9c0fe34392ffe50976cf021e83628121b7093a8b88195ea55314ddb949984bec8f597a94c58de3780ce2ffadf03794c401ab67a0b3e687790495b4fb2afd244880cc270600a9ad8edd47ce10a3ecf8977e136926901fc7a27a7e80b429727ad6e30a2aa50492d3921cc235e690f46c9b444c23254327809fd48a99ba355f3bb22709add7bd24d2699b485da3826b76d0936fe1ea43bb5a953b8e8d269537996fb487747a50a07bf7e98b6d3e3f00e27afb4ac61e776859f47ed9cf7a8d019f402333ee41f95d3a31e9220778a202d8d038d3dcf686411155b7f5f430da03d92cbba8ddfa7c9279834cc68a5dd63493f9c76ed6f90a116f39f5776a9c7734061cb168ca7a66f9bcc6a22b806401812b569529df70671645e0178be253c1c895352b4f5910b34df6077de868b6b659216a7b3e3146fc5e79d3acdca407cef002eccf9a789b8211d9a7e0145f6b5c265fadd78c7db32e5ecc785f201f46b2ddf35bb7e61ba514915283ce5eb7c6c34f0887c5a06996fc83c2d4206ea2993200ad93937e027b5a20e0c8df62363252a40e5dbcc33c1b3356635279a4eaf078c6330cd4af32fa091b25744255cb62ad7aaac929e668b65c1ac2223acc433b9ecc82d3928eddf4794a887c5cf2770a2a98492f3274c042e15b02ec694f2197991f2111f707c29e389f0815f27c30e32e05857defbd043f935bfcb2b7da7a0860508be9edb910d7521e2f2588437c240fb7429812492844a5d2c3200416e780d98f931be4941a1e3b5b05826d6c17d07033af5e351e2cf5ae0c5f7c860a29bf733c62e42ac2a6fd984dad4ccadea5b729009b7f44b857e6ff372c75b6942b1284b6bc8d46664d23272131fa26e62e9fc165a1ba1f79afdfe558fa45355bcd3a6bfccc57008ebdf536d65bbb0f465ed557904a066d966e293d29c7229c681a41de94d7782a23d5b4e344668030325c25efd8a14a96777cc9ee1ef52dc626abd48993ca82f29a4b1545f327f5da768ab9344ded67139e1a2562bff36e28265a3487d727811ce780c097e1526d31c22ece535e40a873cdbeefe15bd2617ef871c332f732f06d30355957719bcf63e5d8630e85cc8c1bccc37b73f88a35dcf44afa03d5bc485c11b7364b36a3ede6bd3a1870bcda4241e85f5bcac74a2877ce974b6b43e2f9fb152b458dda8aee97e3224a718e7ee9a783e82a2eb04d51c8160a205321b2431c37f7cae1468762aa6e74d70ad533a345709880b84fa61ea1dec347023e692ac645e29e2596feed0b0b811356910e5a47801b305b677078f03db284896a49728b4ee93a715f212bea17b29177a03ffdf2637bf52d8f872d7da5cb6077c5fd7f03c85690faa2735b399050d13a2530ef939f3d7a6e683f0ab7c898dfd0f58f9ef0dc639ff16fcc083afb9fbf8d7a00ab748d2f3dff0f95d69f178b6e7d6ae9ec0f4acfb23e088430834272bed38159f6062b08d06a24e12712aaaebd207693995706ddffbcc703b0c6d9d2508712b78b006089df6e05bcd90c814ca0c20b2d7484bea811c7b32365c96c7bd66e0cebd8899264c3ad46ac5f6d63d36104462322472eff1580f4b96aeecebd2c58d7e66b004ad60d011b25c3b08e62c396690e9c3b845f35be7cf978a216150af2cbee983a7d7ba876621db2ecbd65775829bf23a583c0a4d69af4d31984aecd03e4668c25acc7369bf3daf2512b71c67fea4e993c83c8b41bee8ef63cda996384ddbf6bafabeefdf935cacf6c84d8963524e19c59c7dd0db0983151fbb55962a4a162b996faec0d93141e6122d63f9c17921e184cd1b9a832b8c5909da1c4d487fe104847e06a4a18de43bbf7b2a4661a639982154f8149603a46cb08e96716ad85b074b1d3d41854835e146e29b8ca2c3dce889d429f1944e24100da6f1d86b73496ef225f8e70c3df62ce4b859cb16e2024e46974d99fc1bf652b76d5db44ecd4460929fd134b4944e80ad54dd72751959f54a1a0e618569e24b4ea9c174e59595c14d6eceafebe8c3a906f8f7cea58e9e725b29d3270b14b33dd8603567e00abde39ee13abbf09871c9e9883140d688b060199eb71d12ff0edd4576510797845734412af2c0512ec5c5134ab842acb31be08a7b60b893ffb580353ad430f893d30f33f74abb3279ff6520c4a391251489dbbf8e05bfc23b2f4d27c642571c7532ab353914d2f23ee1a3481cb0fe4e153d0a7b75d5088853d26994c91c1ce7b59079e38fe3fce9d524db74da7b6113e27a19cb247c1bc57053d45b118579f1a07716f840c2072cce2a977b268f571d0ae583b54e5219f87f370059f6febf0f5d12e4ad10f4fc11ca69ef3466a84c25d2026508e13c2427e49673e22951b64c7c24ac5d0943989bd388f924f621c2d50a29c60988542fee5fe16e38548004dbfaa32cafbed619e90e8b9181f6bc85c6b36e93c752744c0dc5382d05daaf040c94b3677bbaa4a6bc58548aba2f18603457745403a07df480db21f7eb8e7df7434028a8d34545f6c1da86ea6f7fed7f81b249acaf9a9f9d7d1eaa9aa20db395586109755d92e14fa581324cae3076e53da8c81d94bb825a453e21e6e17bb18139034e2e1b7b82c9cde492dacfc1ffb4df333e030a85396cca6d9eee28d1391dde8764667a776b1cf7d3b323e780eaa74e20e84f0f71c73821a9eba4e6e716efce915e5fd98f09e845c00394a79986ffa16acea1b32630bfc3e7f3296eb68bb84994c6e3fe9043fea81f09623809faa2dcc20959357dd9b2aadc33951e6d4f503b72e68a9c1b6568a5a2dfcf9d073e2dfc791bcbb5c706cdd55e3d147f6dcf52b726421c259a0aeee8bd7c0c9fd39a8cd1e5794c9b7ced976865de19f1fc60c3652569c16c47df843350567f165bbf6e4b0b2f4855f7dbc3c483551cc575b1356893fcf64354568de3081eb153ee4517c62803d268bd243e3d87b08f3324dfec3288ad3423adbf6b820d99a72c61677ef2ceaf98a083c3cfac907140faf031bcd5afdbeada15fd53da064b306ab234e139253b17c953aef354343ce4727b78fe0b9daf1aeef7e95961bd31144338aa1b918c96c7d540b62d9eb70dc320ada2f413f12cf316484b2fb9eac8ca9e03819e9b435a3ba54f1eb52e3319a950a46191988c8dce15de1af72f7871acd0925effe87eaac6d43a41ecc815c5a09e9cfa861c7d14e35fa6c9613e6500a9bd62b4e1d0d9378e41acbd9c42a05a97b0b9f2914d5f176162310049a3d62deb3a98011d107a5c91950e1682a1348512f55067931e7bab565858f78f6c6242568c5bf69a02bb456eaa09f0708334924529757f8bcb096367867b2394b104e14d51e3aca1ee01f8b4c36855d3a7f28013720c4d17816fa79c3c472969bcfef1a217de2056d3ace5566d36e3bc5bf8448305f26a36e6f23af9970c2a1fbabb6f8218eb006558dda05d8fd15d32e771b82d0935032866810504e3f204a35f07e1a4a734e9fd75a747bd0b13a8e8dda7f80c56ae34e96714abf993f269811e4ce2dec243b7710031001c61f51ff1e1d1238c16dbcd960c84a09a272c1c1cb3453112650e66330dddfaf7a86840cb5dff9f4b7c7ef4cb0d8a4a0102d432696e702a3994f517c52c5f8206ecc00cef90709fbc2b81c9e14cab8bb78412e20430813b8ccacc3f4dcdd44012a6e686fdec4e2dde0cb5c8013e3d9bb7e22e7e6117d6256b5cca002484ed12b01c8d081d9b3f773160693a4666efb3b596c93f98f594584e77f347cd284035339c320ff095e2e0bf48ee2278c2605246da61e37c56f4f920a4c8d81252b5b6f11248bb84c313128f764ad7f1bf4e06895ea36d4cf880fbec31fdcfc54228f1fa43a4eec813aed7a35464d5194d8292fa70731ea7e12d6ef4594bc3f55a74dea3f010070af76c79f2ba74e7ae591908460a3a7758595ce70b46e5feb47b42b31619f74193dfef7d0da34bb291014416afa8e1de6e66fd090a791ba89db2de33e6e950443a23812825d7db248246c32d82cb44c9f09d1211eed366453341412eb2b835e3ed4480f0347d9b596192438d03582b31dede599c980a9543bb8c66c3f3fffe91a5b2a3261e6175700f3c9d0fc13c21f797d1e109df884f06bf88baf0ec2a34ff4bfa5c6b23778cfb84819a4e8f995c3f3f721bc70dcfe853ea39111fc945d13019f5b82113867ecb9e171add4c1f3c6312ad876b0e00cbe47782cd2941122021b74b28cd2c2aeffe813d72ab3823c41ca7866a3534e5bd35d999c71df1e7ccde213530db358b790d7dd969d67f035e6ccd351319e635b28c51b4bf58ca71ca2207780d5c2faafe18b61389e240400a3968f54a9b08af6b1cd22c927d5d89526f79d60f763d9d5f2b9bb563846f2a5cc9c9ce0fc293f878029b60654b38a93a13bc8222539b6c96c681ec3894e777f1c13067307e2fcbb0fa68e4b0c44c00c4ce872932c4a073f46cf0f90dbcc41574ae1ab767a66ec3a1df214baa0149d162260bcad9faee192dd23256902284f32246c7937500ce6c1214a6cc4bd8ac785a514740b482205cdad5c5635ac12ae3412827fb8ecb84a6de8f77cd1275ac14899869f9e9d0338028508221b47b430dca9d0606f2073307e86bf2b7b1526f39aa89ad85dde18f1cc7a6280be8716bc89a1517bf796faaa2314c5d35f40ddf00220a3e3bdbf621ef19777250d9da5019f9e7abc817a92855ff910e741aee43dc6aec358f429f33b995ccb0ceda0f8483436bd9609ab7611fd61cafeaaa8a688f5ffcaf0604a81d9ef1d2de53a84b5b8c5b52d35b0b5837dab15296ec9f672d6cd3b29c9dd8e99a03e3006e6d3ae95a79cd9060d76b26c9a22848ccaf9e9a912cf98cc52ad929848eed70bf43da5ed305f953e7a76b2e8148fc4dbfaa5ba113ca39c41dfa4aae1d31fcbfa870419813aa6c74c6eca306277c8dc0a12ea04734dfee0674122dc07af4e1dd2d967e232b54220eb9b6a01aacf47b58becb47c22cc127d334ab75752034afc7b6d2e916e1a923c556b62d8868d31e967145b0092dc1fa60fbe409a655f228d3226dbded10e0fd7bbe88c56f6ad3623bb4b361423f83aa21eb513ddd317dba765451ff33955ab6c4a220f59f6146a3abd9eaa18f3fdccac2804c021050073997fbf46e03eedd4fbede71b5bb350c884c3139e4a94a85855f25368adf02b2cc49dd900e56865455c7359812a1046cb6b32f40f71caece1d5fdc5a393593be66c740bc832afa3844ec8cd45f2f4acbe742d8bae3465ee1715b83f69587d4e68250d892d2b246d875cec13bde9ae0a71762abc9689f7bf03abb54c6aafefaad770caca7ed8c4c27e951816024ac97e4652688fc06f91d5904bc68bd8c3d5e785da8a1f8e65ed994e664c46e66c887a0e9d07c965f7431cffc450d8c021dfb5a5b95a2c4448075ebe30b9b6c3757622a3703f2640090dd74a63b0c8274bfae5c90129f908529856c79568afdc48297eaedd2ffe6050b5997c679b1e3fbc3e63cbffad375d788f31f1de79fba41d6c1683e360f7ce4a52810de52254acc9c030089e528841e027f405ed02753da913df295c48bf65fb96671b046d5d60586b566b9effecb79acc512115789282321b0a57e597a296b02237ad16b3adbf2490c4d5ea70f319d511b3de21db9ca99d71499bae75170b5f3bf81d3136488798f672f1cf6bceeb4ecebc50005c6e6e6457ace6a1e8582a9daaf200bda75ef8d1295c61fedd7a99f652308f08a16fe1b289804cd66b18d6a383152d11197978c3091ad8a60e08eb641d9aa5b44ef8073f8e4304c586b621d4bf484fb8a954318ebd8c7e7530c3baf9cf3004763148a67a2429d763340c7ce068135c35c9fa26b93dcf4246f9608df8c693b45b61cc1816586a74e7ceb5eda2fc4ba31fd759475ca5a3c92f74d3ecebfa877a7280763216fbad3d176dcc0e246da5e747c9cc475b425c5063b9b6317bae445429e6ba752b61fcc49db7c71df490aec8f880b389f5e5e795aa2f6b34e04f22ff3ed6dad62aabc52ddb3e0e3300768ca86b6370d5e0f256075d88a38af6ea7a5ebd77fe04c6b3a57c7c5e7d38deb52eaf0324e0dc25c2faf2728f61b6b22784482527a2cba8aa9dfae63796508e733360c0fb444eb42f81cca5db4f2d01146fd3e486446dc1270fe217ea355c96a337789d25a03c0b1d65e5fc734c6d71176ee33137c77b0584aaf37b1099b76b45f42a3f47e1721e7c11a48b6d6348db83102915b154e6e6be350fd84050b2b4179a6964a416a3dcb2a36ef3558231cef0096af677837b33666870631e80e889ebb7bea060e38e2316de25184d5acfda607b4147173525738652e6c89b79019a1916fd8c11f2345abbd8dead62701355ec9384dee1262f1f05bb32cd28fc5a0d293c8f952f837b5f5541423e3d45b22b75f9668b70e824d1e6d6e85b28f330bd2aeb28969f343bba9fd36b3ac4e65b5e86284e2a79160d16ad69bf0e6f8390a2b8ec40939f76cdc25e7b9cc2156d11aaa20e5f9e356db43b89ea245e4dc4e8ee006ab05e0f0521a5b29b79a3488a7c3fb596aae7d1db808aa4e5ef8b74e9dc4011fd0770995775d52d591b75b1722da6b14ae4d37a6c6bffe761724a4cba56b8be4752e0bfd8371a4eb7ca571d75f5b942493bc8086162726c06cc394423232d5b4deb6d319bd780ee85075c4cd6bb5dd96868f57fb25047d1c37014e6968082b5730217cbaec15a7b917195c68a1fb6ef79a83dbeb9e1cb4bf91ccefc7bc1c0fd3b7e60dbaf8334e88f537709fa269900ac26617b9b22266338ba8e27b9b648db287a65679dd8a3c080577bedb574e53774affca6b9cf8f3669e558781e2895f85109862441e61011471172dbf27bf6106b0f8823647131d97d2150773cec5222ea6bc06789874e28077bc417bf9ec79a45f7162f1ecdcaaf822e660a7a0d9b6d65558dd033d7b7ddf09ebb8e70433e0800af47b8df4e64cc6beb59bc97a4795d94b5ec6a8291c59fa0dc20d4f8ecd478f1bb334d675a71fa7bf92ea228b9cea3cf1fe192cf615c3ef05426ba7df7b53b519f7505bcc11fa3cad0201c8f1d35eaa5f1741126e871566cd4da0e7e8ef5a5b3c61f14cba447fee6118a35f46f7e623733f861f25536b4f8f7ba21bc596ed75493a0965afd790dcb6162ba7dd220ba78d3a94baf70eb1bd63bc5716e7d20088c9604ce8a5dd6611688df8f21aa63063162542342dbaae08b0c997c43ab4fd914c46788d125d522e1946fdae55fbe97256e4f4a3732cf1a318d291629e252498db5b6bf1902d8e9ac1dcf1c022b23ec47319217ee3ae39747300dd5039f367584a18f1faf15c1641717650f80c68919afda38815005061873f28ef5505f41f4e5161e860428e47028ab096596658554f74f9c6a113533a413ec2b5e1af632a02b151f94746c49fd858513c22703b181a5c98e5416dc9976327371830b8aac10fb40821b8fcca4f9cb72048e27f7757b2f1c6f73b9f44c23d9b42e43d4f2b27243fc6dcd956df97aeb7559a97ea0ca11db353e0050bcd0c4271c8a545128aba7f0886fcee2065f6c152f35615b6652ed8a36e9e2a5779451c4d3f0f193c1e34bf477f1ed616c6d5ebd760dc00aed1b4eee142787999266aa9fc40425b87d7d6615893709e27e1b0eaf0263363e91aa84f09c18c4607f2a05f9a569a844d5ee8bcf30fc5b986456bbe08174fca49ad8ffb88175e6a44eed9e7ccb2a01aedb969287e0d835aa7d09f8f6969830cf68c296a341f16985d7f790eba8f1b2ae40ee546871823487904d9e6acaa3041980fb71f96b3d15d88bd6dbf3f87a61eb27e6441ccee7ed23a005c69546d5aa6e19235a0bcbc358a9f757139682ddee68745bb49e68c9d0d5c55b1aa821c87f2dc8094d7b138ab6b60f4bd0a5301f3f0b83e9a856fb252521dd9884037970e5d00fa2e00cfcab407e2d65cc9fba706a53bd20d103b603b3b9c623c20ca029062810892775089197384508beea137907c17cd53d5fa022f77367b301ff925dfaa9ff104c04d292e333edfdcb1b84dc778fe3f699a29ea2401c91efe24204a39e3dd23212f444d794e6c7c0790fc77a43d98d828a13396ff7b82ee4855762d70072fd5be665f28ac9561819e10d5fba9e39c57cbb0ffeb5580b4817b22c2c927b7954b57dc8215119e0b381ac6d1a08ded1a9868e8d3ec1d412604e26f55a20d3edf013ec6c82f60b416eea62a76381f7aa3f77e21b4ce7053eac0b6660e4820df6da6f9febb94354894777f9c6fb7191d1386d9ebc184940e83f7c286771316b3bf27642d06201d1e9c252c0c27da967d6d58c5f347f408999d678f280dea3215eb6a2f85682575db43a29157ecf9c2eaeffc141d5d17bdeced6ef1c5d6fcf762a4ee41cf11c91738f1b61ce9ea28f6e2e42415fd8e20e10f645ee83ba910e63acf2f7637af7df39781c6fd4f79768bc5b6b9957cf221ba3b44c7e934762e2893b3f6b05dd7b6e92992c0be1606a3c4e15894452be20eea8463ca2b5c3221c486dfa7c936d038c7e368333b5d3fe8ed4a7919b6a6766b3ae406832cfcef15bec5dd9bec30ac20efaf47cbf5b4d80ec2bdfa73a18e5223ff888b943f21a573b69c251280545afa47e0beb7d3a0b5e68fc549b7d41ed732949a1f607b0f434af9adb2e1a2aa99acdf1652fcbaa1d7a23062998aaaf909b62c3b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
