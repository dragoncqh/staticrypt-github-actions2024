<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db48fbd5eb5025c94da7960df58c36a0d8011777b632be7c72e1a3e203a72dc081620c4d448c473b39c6c1a9a7e9fd1df77d28590d32fa909161fcf8599756d7c3a56a7d5148c55a6fb6f7dba5c238596e621b22aa89d3101af0c54a5b590aeb1ca00419b739b319ec535389ca702d046a3db33e2f227a803a4629d54e21fc4047db0ca967f480b83649fefc56449bbcc98fa0eb97c839ef53363affef41ded97b9890107175bda8ec94d0046164ef4246aa5c1c24d983820b55709191ec71e1f0bac85f87fa56d907592c13f09f5ffebaa99f3b05b59351b309f2d1cb87170be6a15b05cccdd8362c1e86ce7ddf93be4aea50d328c9de9a3a122d5e152cd5b7fdfa3b4f2bdec409212aca0bdb7a731034b24a101e1a03ecbc4f918b6c1be7ef9dcb23ad9f046b5e7278dea12f5982cac462d95508bdd0413014931571d131256574a83e0bd1743a817383ea663febaf265483c3518acdb5bd500be20615006379f4e69a290bd6b1ebc97166fcc744fe4c02c2a24766ae71052be1070442047c6b9aaf54c59a4f3ae1598c68b9da023976f68c29e7f487fdee15fe9a1528454f2979b10a30f957145159bf72a00ed0c9f6c9284e0846cd4d8a4db979d60a254196047b1c9578fda8902e9ec9e5744428a83bafd4ec7c964aa243421187178e37dd204cf083c13c4507ebc1dcf05c46216c8db4e0ae7db88734da3f2fa09ba15fa2b67266400606c6eb3bd12e39c3fd086697cd8aa1e7a88e67dd1db4fd8a43c16e4d952a8947a32289b6541c624a023d87481011567d9bdfc2c0f488d803adc37e4f29f342a96aefb966da5831de0abc43a85cec9e69868b6c1d329a45e0d6e0dd17247b71efe69285dc448851f0fcb481b10bdb3618dffeec72ccc0f3952b60fdb3d1e1047ed4ac1d1b0554b96135aa3c1d69ceebe515573faaaf2f1089c988d9ddd98b31d630f05142ffd7b1c02d7b941e72442bc259f38242d60e7b7bf66bbb74dc0b696bfb9736b6fc848834c12ae8bba45388f8c95eb8e9662c21199a38e4e5747da771afec157640be9aaaea136877c400260b15d983023786792b94be47cbf3425a9e7d95ad2dee9d38a54a8386514033fd354aee3abe6c8cfbb98f1c8fa17a9a8c685e1f590f9e2351da77240de1f27f91261f5b992719bbd3e9ed5f7c5b7db16b643900d4cffae04762d1eb12d35c01bb7b48bdbfd47afd3a40f4f4f04b72878eb72280ea06db5aa23aae05bf58e7126dec400c3eefaeb96c4289896c8f1fab0ede5f02699dbbec7771b698fa80c5314275054d754d3c0738538e949d11e578c825e203b3f0025094513bd313f3d6a7097005a8436f22937922a4a73e45e72d22e29b55d20bee673fc95439e64baed30367510d14acc231346e92e53a4d36fd7d8c8a54b024545950d6e009bc7dd72eb0b6657fc00bdbcc4c75d6cbecc08e7a4e39f60f402e851ef1af2206bf3d0a15ca9a4ea8939d3a0dc059cff1f4bae949b8fc0140dc14674141b7a38b36a45abe24b14b728506683877fc5c1570cf83b560eb3cdfc88409c056d416845942acc1e6c7b62234d68a88c1ea9fa880f95838152d2550ffecbc32940d11ce4c11ec662c497ea50dfacb8594b74ca2e5e71080598a1c3d7bd1e76769d3122f40f7197a949c4fdf6a56bb9943930247ad9478f56bc5590b50db3841f8e8a42ff99e909f07228bf55dcbff7d141a64791b8615a6bd9f50b74122b67575bfb417c070e4d08ac5eee5b103173f1be70d1f42e5cd5f4e3abf4d5399b6a8c562f6bdf3c8acce8aea9210571fe89425ef857a5d036f021d6aa547d40098f71b9fe1a3ec82ff2e48b38868ad5260afa5f35b195f9e6fbb569b54f1b44875c95b51ba8309ec166b6c1c613c6d4fba077f21ce062b5f3fe100ee4ac23d29c882cb93de49fee2ab8b463c65bc4c8c78c9a3fe0a4be0a9da7d635f140a5ba1680cb3d55a48605b30126ab999f17eb2b285bbb8980584a795a84c3dd0ae6897c679a6c22b9ac79ce09aa0670c7de59f21dd570f1f0b4cf783c58e817bec7e9e9b0447d6fc3e02c00d4844032ade3f3c02112d9cf729e0c6573264276f1d282ced410bf17bd60a2c91790433d890045f4c2865ca1e3fa335128096310749810545f6c0b874e315e6424029e7b2b76deb3a35e98c9d02b2dfec7bd354b4b9a198d000c26d9344d95c6ff51faf0b397c30696c013f463d8cfa180d4cc6b34e6470dd6d7f874f419215c3a5a726eb8398af431c2d92c2e6b5544c164fec2498392bc99bedfbe477e0d4ab3bb7ac265f14e957195a5c88ccc954b9cbce2d4670f509a4f886ee3f68e0001ab00ff3fdef330b9f0147d3919e3afc120e91300399911e8a3afc811d7120eca00cd4d3ce66bf51ca83bb1e7d4844680716cc96b44e096406c87c41c1bd8ef10e284f24327ef62162903eda095de86c32e173dd6127b65bd2b5ec1bb08333fa1d8c3020c7eaa1cc8b7df7b1fcf093be718e1c2b8268c1165442c5ee5983855f896e5f0029407f4c5330785d5d9038d7d723cfb8f24f9ed3651a698cb7dadacc28ee19f073d67598886128674076f28312de8c590e6e9ed9b322c9fefe065270545955bf0f7bbf24d7ee9d26f22aad094c30023484b52c7a6a88b0c9881e5268ecbb1f30910ec1113182c183be217b09eef67fbe3e6a74ddbd1d57ad695ddf204bac62cc70939e4f869332d4642d5a2c6ec4f29f52601f18ce25c0a94321c9d3e7c5857d2ac15707992283b0b7cd1c4195c5e625e3b3b5ab4993119493f06ff3916de14c76f8a35852897d56932f8347721cb12b1484acbca00fdd40077f5081bdae36e32436b96a4eb5fd4b38ad70ecdeb6353ad05b403a1a9d22711699c17acdc23fa42d5a9a1999ee3cfaae9e7fb0daaf4c09e9d93d5b64b56756ec89ba20617326fd7d9f32f90f220bb85d98e251306b2031587399a6d1518ee56e71096bf9fd34a5cecf63db6dca04345d39ae288dd84d2575a09756b371a953cbdd4b8e4cba83201b1a44c8a61c9ef53287006601dc2936aedcd2768b781757cb94d78ba16d788064a57816d49a66f18eb6047041f947565802a92d0ad48ed47420f419cbfa9559e4242596323769edac602a5e1955332151724e9f281b67c3c827cc8c8e387425b4ebf7a63e2a908685e565b43fc07158a7b35ead9589a299db959959973afa6a2ee28939ac3fd68ebd00f19edf48e2e00a0d8657a1c56f7ef3b527bb1bae57b1577738230d1cd82269f688caad523ae67244dbfd1d090d1053b343efc427142ea7f816d8e8363806aa9d26c141fb13e6428d82b33308e0be03f97f4d0b13905d5e5ff42b9c259683b918146115f54299addc88c72539acdb8258bd7729b0085586822afc484293cd760cb75d046032e80e67f709f0136be0f39091dd7f822468992f6c54a134519ebe3f33b8e58de97858714fe7f6b2a1d7e8999ab21aae1a11f00fe1d36b85b72d3a8d786d1da78980797a4cccd28e70a53912b300f44ae631dded4521700cf0f3cdf50a063c229897d0f31fe0edfd31c1359fc175c47ed661d8a062e38069f53dc6801441a45982c1a7c89c5e78ac20bad608593cd13cb0e2ff48b96dcf31e6e528b5b22af30474cbe8f36db5c9abf86545a36bfa7be395c0f7692082525b8c35433d2d6b5454f65990c87e17f43c01c1129df64c3f0ccfe295960710c06e7076fbd754987a1c499da98e6c3640d90b3566e19b18e06a83e4833a4d624e6d6a86496e089dba9d21b575af730cbc36ea5cfa479360427c7f5e0c2b7e693835c68b8864e69004fba1488f0c8c95a0fe527f553576df1b524c615caccb5a658d5840c541df73793b29085f329f0c166c90baf151e56fb991d248e61f2a7ff5cec26195775e9e7a1212de01576fb64499ea7c1c59879d162022b178c7c3af327e39594f9e80bd6103e8ec0ba5d7b167ed29d4274385a2419137feb8400292e1f552b06e5360c29f56e01f1340942c6b3a339bbab7f9fc8802e442ebacbcc6e585a262baf635ee1d7ad5f39fb61a57f80c00da190b8ee98c27399c6d0a03cb14d0bed75286464f2a56e941a9d25138e2dffe6f4fefeeb41e9ba205c96211e779aa3c5fa95ef8099c295a1e29c52e6af0f19cda8566466616f170135ba54181a4a826cdc60f9acf239802b2bd868bea8603be4f485bac4cfeec9e0435f673966a1307c6de8f61b4fdb69ebeb424720cfb963d7b45a36816b730707bd298d4c4b7ddaaf2d7809495645647e99200459bfcd7f69416853ffb334e5428652f286368ef39e3277388fdb2d6ed39e79b758f7ee11793aadf23a2551c8f96442e5f522f8c068ecba24517c7020d976884f8cbced91d79e46c6b321e4837256456209e021ec8953aac38c6ad6b484e79c0771480aafc7a66683c652ab3be6589e7c9fce0f41a13434e1d1282738c267380afb4001b9a4b93dc40758b46f57186feac2898d7c7ad36678098737772205f6b540b3b3027abe5ca4614777b235bc538badf5dbeb657a7c75f13b6c3c9999b9beec52f1380468487409da8634dbd463fc29c3f7d11c0d7ad58c2ac4341cf09e72a2894af7f7db62af88dfc26a235af0292794a79f1265c6a543c11baad36fee6624dc3b9feaaa8ec57fbd9f3c2c5f904bac5734bd3e2e046c17fd8fa7e23c3a7d5096f94bd594c22b383ad49db2b76ba6123bf25ca5b928b692d26533a31f1e817be49ccf1158ea536dc748b8fcc13aa200fa4c9f3aa74b064689efb3506c4348910951489579df000106e2815948e2598af855d3bc0b011d81c5231e0be66e13571f3ac6ae25ac6d5e9558512c006fcc47def1218f2347d80c6822e6a8236822aa4d10b851a7be698077fc4efb1a6ac3a33b5cd2989f87afa49e4f832aefb09e0f8c8dc8fb60a17932cfe59429e267583439119c9e5b6d6f2c896e2830a5b74fe329bcbf42e5806aeda30e25f6392383d71214b38a6a5c7060641961129cda91ce7140c9bd5aff70d88ec9eaf3b7b08d97292d98b2c025f0f06bf396d287a72db4ae75760f27782e9a98cead0827a807e744688cb3c31b3bb29d86972cc3f54d6b5feb56aa9907e9038b840222b1e31edd4aa77da1709bc6f62621ee2e184fd4f3c46795696cf45e6d4a69462859b2d3439bc2d869bb50ae03d34adb1c1af02cb6c713a00a977b93baf177d82bc9bc47e32e44b3287cd1e8c527d4aca4ae7976ac30d2a1b2efb11247eeb5fe396650ee5d9e0cdb2ec535cd0176f53b43501270eacc82de36f1696a9f3fb6a70290e1019db9f6e5abd91106e77eb69d9b2128b8e2571cb9a471913fd579d5fa15e1a5270a41b9bebc6563e9881027926e33b16073e799d4160784fce0970fa6e2dd90d654c4d9b84327010e8b47ca611d1d3b65fa04dfad2e4287fa0348e7ae3906d1264111735b661ee9885b01afd24956650401d09852ea42d165245f7b952d99206b3d3bd464d0d74efb88e8c4bec264dca3374bd7a300e342b9edb670c17b7893419863cc100cd67944ee4e72b808ad1ab3b55ee3728f49e7c08e16de5fa9a1f1c03a278fb404280c47d6d5603fdedb67bb0721d467912a0ff608cce73a267180ae025f8ea1a19da56505fd3a21d3f882c036b329c8ce8832f406e6af65e0ae356d536d596379dd9c6f044c4ae7edee23deb9e2c53bde39d3de389bcfcfc6a546efd8a301cb7411a2da580cee53baec25a0b059f80a3d9dfd79341f808a5d7bdcf787e19966dfc132c20daefeeadb64fee8d648f2efc86bab941ca569f65e42ef8930858e45b438ef78713b4c3f85bbb5db61ee5d9d8bd55492f557f398b67458a4a232bf976691822210393ef60c4c14290fb5363f1dec4705576b39304667991bbf81a2357aa04530e735c8ecba27d66a1a7e6a67c2f6a9870111cc9849321527f9342eeb70ceb2a10ef58c217be38996256dff04f805e6eccd0088706f7a42436ac26dfb4c1ff77f4be87a06470e0962aee5cf8936064d789ace51434301fa0cd20349c06e332a2d00d4ae6ab6dfc69c487d0d8246b46d455d7130065b3c88d190e02086faeddb41a1cccda3048c97e777f7f2691eeacacf4279c07589a7e8d01f9ac5ada93fb1c7b81f87f1acd06ee1bb22566e7551d5766ebf748ffbc934e09e073e11c03d73268b535a1e3521b0385c8a320229e2b696060a3a9fe52916fd815a3388bda778ae8ad12ec659e6c96a01708ce9b31098bd49622f5725e332ca394d5a265a445e745eb53685a9ab1e9e164dce1b7f8d5841b868bf9f169164bbf7d4bd01ef9703464226f4238ebdc0a13fe498477ff008d0659d6eccc7f6ea919450b4b6ba17caec3e559c3aa574f9befd03f96760f250ecea8c3db01bd2ef8f7a85c8ef8d5289e451ab541fa5aeb54c533cd636edc4207079ad427ad277ce7aa084c512eec44709bf7c87caa498a13c8b782677400f7b1048f633f2416f3c4ef8525b0466bf9370f8cfacd75b7bb288b92ef91f457882bbd8535d7e77fc523be619bbae8447da6e209e2bc22870982bbf18076a88cb6022bbdf532fb885be6093428d66a071f32c7074f351e4793e1d4ea77517d2fab2f9f3c5bb2e1ed7d9af10c37f534c02696ce049ce94a9b4d3f0ca101cd369e7fb86370d7375534327f1f2672da588eccc58d5fe9d9a5c6dcbfadfddd8df28a9f455020ce42cebaf2e6d54d8d66f98974d2994b389839a01f79eb5eb772e8643452cbb1a8517067b3c1b25a0468d52ff6206d25035b4069f20aa89933d29af7fbff61271dec4cb9e3f46d70eca7a524d56d247180fc3cbe95af092e8acc203cf1f12d7fbf8987ea4f246d6c515e02b998535566b030cf8db7b0f279509eeec72bd38698e280a8cec1c101d342aaa640d417476815a69595cd2df251fe7c8dabe2d843b05ca25852693faf4c4581a8d2d405b5f12f4b683c2c0e77dfaa7953c2ed640606efe6aa6d59781d880b3a8b061789b1b972368702c77600537ff233a58ac83ea5dd7444e130eccbe15f9ff8bea011c0c6750cfd91752350cf674255f10a1530c4c83dd542acc7dd9220e39871272274f2baeeacdb6a4c24a650d4dc8e4c9a7a36d666b8d82e3c4f530bec0395763a81005e75bcaa3f7b6ef05921181a82ed55149b8864849682667bfca5d56f6c849c86aa16d1b3e88866716b6b6e6917ad82d8fadc8ae8b088b55f22d16fa362ed1b003f525715f487d078fd4560a49e466cd2c1a3b6d9f3629e36f8685332b12ceb302c8e7206e7f0f9b7b4f8e44c12dfe474168b6795b4da54550c9d2c8a6418293efb3a96fe10aa13dd031930a7df701bd42bac536107e73d6ddf053bc267847d47ccb803565fa310cedf2667d3ba62a3d125bbeb96959cbd6f0c1f8529a7507beefd12c95f31aeaf6b7b5c7e9941e92deea7dcc3482ef93d972a92e6a9499b9ce7022ae9b3b5d3aaa9255513b060ef48c03e5547775182208fae7958573c3921dcc1f6ed5403dd9fb39af00a032f1b2a543697e944066ffb8b32a866233418bce281b560209ea43ae49da61e414d447afa93f075f8e806f810e4f4126ab8ffc458e807dd1a217625d8907371440138b571e1d902b84f89588f58ac63fb6da2ad787b02131e2cc3d40b58b91184cb6f42b08fc1a87458ed70f3aed975b883edf5f207d334f3f8f0996af78ad82a587785dc5f6af3362327b5aa0e1bbc320f33881d49c518102ed4be22656c5ec7961d7ca06f5be803ca6d81c90c8042024f8afd0f73c7c512fa41805b0254183c565755e9f5ba3cd582b7c8aa35a7fe74206e135c226efeca9d204ebccd68e007e7c235a5011b739c8fba35f20f08c177443ac5670d3cd4f0def6d31b6ea6ee9266dcf722575373e0dc74f783e49892769e5e61ec5785e1caa0d5c17c365c340dfb804d1a1f71db5ccc10a71790d2318d84860e249b346e34310f90528e6a461389155fb48961372bfa21e403985bf0dbe57ff944c583de72224ae18222f3c8358aaf8fe33613dd1276b08f2b35aea316108ef3b60bb4a0a10c816713c2d3299d7d6f162906bf2f1403b1fdad97b9c02aaa599a9d91e652d8e8f02cdfc6ebfd51fe8bccc0ce7563b1dd07a5e844e65bab32eaecd207c1fb3d441cef8b529d8773a7559d2b0d6c478c1cb8365af71e6ca3f0ae44e105531cc40197c6441dc1b2fed2559379c3dc98f8c2e98716271db2ad8c7d930dff102a845afdea956b06be9ecbcdb3a1a1d01ea2b749201ec7c1061e328a498c2024b272614f069f7da0c2428660f3b40ceab9ab657186e1787eee2b33b2c24d56e52bc79d1e1f47fe6cea70cadb692071e023a0645c69a0a04c15ec21c776319c7da1760dcd03f5741cf5fd0ee0bcd4b6083b4eb0410e81926fdffb8fea1ecc8b24aa8744eaf66b825e0896b125d203d43dc7fef3f037f8cc0d976b6d0a2f646c42894933e39a22151d2ff59e573420555db000b011cdee85dd9c5c52ac93ba17a3f1a82a4c5601713c3bfb9d15db7dbe141a6bbbd3bb7a433ded074cc50c020e9837b385047501eb0e4f1a971de275a007a65ec261745d6cc00c06faddc619211c21c52798b9388b7dce9537ac241db2dd66f93ddbaf17da5c70095d0f7db6bf532802fa94aeac37787e5e1e1c11c92702ed5c3b1b158365d877efbde730516f7f96cc551b6dba0aaf27d62256c1cc900151c35b9b304916746f965d58e03e41b1dfab8f407e2387e6d0346cac573f8560e7d0cc4eac77a9886f9b11cd6e8722139b8571139f1c6f83e8ebfcf190aa52d910a846d45dde02b45f64a18030c7ed107bc10ed2fda52c7719ffb258c4f494314c450e234f0d2514f3619452f1d6b2d1fedf8ffac2977ed08a6730637080bdf2ad217d8d1129c8c6ef3ed82908bc040a1fb410c33e89b832b4021cd9fa3e2cb27983f1e851e88b5302bd0a4f2c7bf3188e73f33122123841cd2470a9bf0c7d68ecafd735fa9c4712406a83072dcc8d3218d14db2a2a4f3c6df80a087eee0c4331e5da5680dd9bf4a0006b1651b819732948992edf1c86befe1b6c12bbc130124b0c3b20e79ee50679d3064b785f3141aef05aa74cbdbae88ac80bfabd3aee46ceb0fa5545c76c580576b697527167cea782680d0da8562c94f399d40ac3ce00f7731a7f22e1b2827d8ebca0be4a79992003fd3ba546ab905ca518006ba5196c7d2b5e82f4bb8e7edfc838a6c5ae8ac0cf355b39022b7964797d046255aa613b5da20a68cea683fb6ebf4fc53e7739a12c0f073ebe7a2660eebe364f4ba1797bb01012633c26facfd48ce6485bbb09ca6438c55bc32a43e1c159a11ec17a9e23d17173e0c25ebdf3fac561b9c72b2cfd966c188f20970afafb45f04c535a2fed618bddd89539883ee5f372843f6c8fe8cf0361487a8eee3c48fd952a3e5b0ce89449943dabe8a13311cea1b59d3dc32dee23dcc3ce3bbea1b52d8669f6c7f4f8ea55c2339759046208dd824af6ab9e881e0d2e710ff9f8824191c9b2c27d1be54be89f67946524897cea2972e911cfdfd0f8d57f242a98a5701c98f72bb21fbc2fd3929fbe0294d2956a2600ee01a7e9fd916ff7705dd7bd5363db54944878172ea2b2a7322affffb57e72b17ad293c75241b0817dc408a40822231e57888a4b7aded50b7d57b5862e0568234968e0370892dd67b21b47837b6fd12d1aa9715595dc099bfc1388e2a7ae7512861a1aea2c350fa65924f28b65018e69841e7325a35fa34259d557f895894cde90f0bab21fd1ec4cf9e927224ccf61535deb3fb7919a1589f63e8c71ac987648458707afb37052ec663ab2a9ba004e2066243c6137eaaeae8b17cda0632ec1c724fa2c2351357b8fdfcebaacd7d252866e349a5e66d11eae6769d859db59b2eef9d7501f47d10372555ef2b578d701053ba32b4a9c046f14cf8a248135ca2662d3dd2cad1ea57eb56b315b2189a87fb4978054f9f9dc562f08e2d10ee0d340a85493a33c98e1683039bbc8a7ceac3f2592039e98b80f9e4b4c789899a956d650f4de3a6d4e3b0d029951d53140b1a2dc33e3e81bc6d45db552883b6d964e6133b943139ef1019d77a864ede29c9a05d012636a9671f8a2aba422a52eb4b5bf3f1cbbee2396a0127b118d0dc115ef56041bbb797c5c82a824f9c7f09acff9651565251bf24d4c20d6559ed16f6a5b9c74feaceb8304f5872145c65067aa1293ade93eaf6514fb926763acf3b0f5aabf1c18d489d473c6fe7bb6b702522bcbfbf9a94237b886278bf86ba8a70e39fb7a5fd9aa0a8f817b793a89611ab2811f1ece526c28d747e8a03a9e7c3f0a0bd392e8d8b78d3f6dfff23a88a7d5c41be7213068d6180994b822a177e4fc0e3acba673f4aaa2a4fcda0a37d6f8472234205b75e92fb4285c5d842812687ae36e9b2ed9df04af1ee3c618b9f0a44bc1a7a0fe7c7e476f055b5be5803846ab1be3bf8aeed9983b42e26cfe4f23d78013edd51af332f678562d6b3dd23ed5c4c9df0b7b1d41a4f8d56290376f2586e011c643345631bf9dea73d4592b3be67fed8b4cb0fe037926c53f872a74ab16d19acc6f2305c5ccd4a837a43a20806f94365c554131475f443128e23aa88f0dcef57f51232f238f9aa96c0c2a3bfa95c08f931a44e9c3e1f90ba1ca1a53389e7eb94ba2893492edc63ddf419ada8d1a3bfd94243d0e64f743e1907c92f7fa73e84ef40c81899bbecfd47c41662aed6b556d32d52662f9de2398391a5cdea52dfabd550f38f17316c9439ee1ba561aa5b7dd878275812817d9b5617d80d73b2ceb5488be725d6dde66403c501a68a1833fc8b03e60926bc3187b1bcf60cda48f935f96fa7401832efae939d57c676b722761c352d6fb552b0517166b326be9634eb977b28fe201d2127ad173e95003b9eae86e3f55e7f79c4a5a28ba32b466bcd2e1333a2959e8ed087d83dfbc2c3455303a0cf8007906038ab159fe948f1011da368a6b24990266fbcfc766a5dc1c974b2cfa8928576642e9a0a3cc1f39a831d2f35456cff2f80210f24c9989409e41a58bc126475a644d34275f03891ae1d4425b78ef3362488db7e645c06432fdcbbfbaba06b18aad479ad054e14afb08f90d783bd6315640d7eaae585b64a7a7e4e0bb6290da841a9b10209607925a3f4ddd1d218df5c343a0b82edd52efe07c077f74df0f13ecff57369c021339d02fa99d31fb6c0d4ea53f403cd2e5c5fc89605f43d9f63efc4ebe152380e921960e9becb34cdf571d5987e62eaff7dab69d916401d1ac3787b561af9fe9f956d208eb619810106f4f4418568ab90dfe183f04ba39a42c2b08c406ad10b52d42de367f7804b53d227793c8ef5b008a84cbcc38316009c2e88a971f129d00bc1d55148809a1e272069d5299582a52c48cc17aa85202bb1cdea75c45955541a95d4df7ce1b1d1df85f243a6a3d7d7467ccc281a5e13e45b5812055d4afdf45673d8eed814a3f8686070bca6a9f2ba33c12b3e1de7cf0d4b6cda5886961fc8099a93b0bd6f9e6b9a2a8b5cbb8ba16c4448aaad192102f8d6db9a903d565a1ee534d7af40ee56e62d83e4536a9bc0682434515d5551a70ad8eca75385a78a34546e3a8133b9031fe3d1dd0a4b0baa03763e4008b4e781c1e31f954379ae59465a3d24a457d1ac6ce39e4b9057029be0a40bf884981af060e4df67016082509b7c61ad52b930ba949e803219217a185891a12fc4acad4af8dc55eaf43ac7d8765f3ba002b4e76f91c502657a37f2ee7cd658e08f71038d61d1b5b11b7ab2958dff422799c647a2c6f133f5dcf366ed900422964722569e71bf20772a6dcc792b633a5bbc4eea56c5ee432c9cadf2b56ce276b38a5e57d15fe6561726b4b41b0c4d8ced56528d91bae853294faf17667c5833a7b917be821d8f998cad258c73bdc465c105ca8523917ef369a5b8252c89b89d2056cd5e1e2d6ab3ec4c8b4024fb48db8423b4524c95a1398d37ec656105a0ef6b5d047aed5772085d8c42d19574a0b7079c06f75b6ca0dbff1ba696641d60930469cf61b78e80eca13ee365748a62adb11d6fd5e955a7cf2d0389e6139f0b3a6e157a4f6aaacca01d778b8d339291a95306452163a11aede63c657cb5fb62f43d4460759ba16c31b5d6e0d62c4a6e6dd3d7b69f7ce7a82600a46e0d4d873863ff5b955b98448eb715f080f1215e7320d69a224a76687d2c6cc204b2fcc5d0fc4e301c53f0beaa559c0f278d32034cbac982577beb85396460949b8c43615a2cf229d5b39c59bc9dba38ca479988a46e4fd22648ee938c29d37dd6f52c3eda541696caaf6d0dba24abd4610aa3af1dc2fd181a46f1b6c6a3750f1e4b8dba3a6623a396cd02969a3d1739c447e29a503ec34fb818f4e30ccd5b030275ea08072631f92511b445abd0196181a4c83b6a41f0b85afe265ae5486cedfaf98218cc7df599fd3b6ae68c6eff5e82f6010676b306845ddfbb5d338ad08b02a61a6940009d2f77c82a909c887ed8dabac30def44e56f37e5750b71e08111efaeee96940b943ee3d63479994c78829ebdba2a83a30207561cee8870d1f5cc9d65d1b9f1e6fedc17aa4acc70a3344419543cb049dacc74ebf96e1bfd5d997acd36a90618061a38174596e902f2507ff96720d3a54052536ebef36dacb7322e47ed53a3ad6e3c55fcd7c3774783a5b074a1d2549938c7fe75ae654550dfa1a9dd7dab0b1ec8c57780265d0418fdc69766a00c8bc6cbb9a386aea694881cdd721ae3792050c62fded8c35f95e75678f599a124bf664f25e4f0bd321ee697bc3b0e4c00f9cb341ae4e7f2c62a6a59c3e3e590e108b21fd9fb41185bb147b990d0e6287e813e7f18c5d25cba6623a62b64e2bbb1fbc9e0ce8f168b59b529ff3bdb36956364f64027d6337a50d9712ee8b50a8cace7a0dc65e90af997e248ca953a9159dbcc435f74c57bffcae5c787f9a08058d7a48fd56ce2f5a1548ad3cb2036257077a5ffbf51da5206e7f0d470e54a11171c4bf0c08f0a8a9b8997cd02f36ea6d4ca994b6150fef4b5ddbb11d40541f0b645355011e4d3074dc9b638606cec5a5f00acf10081d7ea3417af1a91fb927f75dfb7279420b6bbdf5ec828f7b2859b9b440b08daa32a0f339d45b04d181418dad6facde5f4cd8037f97a711cf240ab12a7cb820e2663ffc1f88a74879988cd410344d5f2e4f4c6ec08c0731a3a125376f10c69d5050224c45636d2bd55dcbd3fa58c67bc21f2ce26753a1df26a1053d9b8da6c9ca2b47bca6307658393ff8c98fd15087d38907a8100f2f5612f076748a59b99cfb4eb5f85afa55cb0fd2a9c0dfc7f85d53167051f002b47e3bc5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
