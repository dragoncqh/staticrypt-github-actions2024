<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3fc40a661a5d9417857499a26b631a8e2c81174e9bdb33ef910faac253c6371374087fb96f8506177b788b0415660115fb48832f26c97b989c804421fb4d954220d1c6182ba11dcd58d1c92cd4052cc1b007af484fdea9287ca3ea36003a34623861649ec0d4d381a2d71aa7b02dfa5b5eb7369a1a891ab9ec5169a80f8956dc20d352732dfacfb91785c9c7c9eb66b488033128a033e7b6792f34734495afd1289510164dd12784252138eaca1465d0b9a849e36a2cf2d094a5499fa03e41c5314b95e6caf55a09f152e98b383aa82c6c251e5f1237d3b82efbef3ccdee34a5808abf3e815cbe1100bcb539a22b74ec2108fc44678af68deacbf0f60d88db71267c24c126c40e6d55f23178005682cc207aa99d27bf3e9f3ce8fee9946df67bdb93ae40cc986faf2c1a655f8754df3b3663c86c21d29d1fa6f7f65637422ae466c959da1d3377ed105b131cbb41c4573824adc365fc03556ecfa688f026095d5085009cb007ba9164a6560ee00777376b131e70ca4d440937989e70a09b1752d926b6ef6493bdbee6372a088ad224b46c649cb5411e6c3fcbc04ceb587c8573017cfb8a1617f4fdd82b1669eb46f8be20527e76e2f1738efadebf8803a0f20f5981aceea76400fc9bcd050ddf453c504e592b94e441e5d2a583039d52d71e947937fdf83a3813cc21d9632a9e3bdacdeecf877d3f4521e4fb5feb9f84debf44f680c1879c6b436ed64d879e02083c26f986e127afcbe54d0bee63dd446d7145b9e5320ec101d5e288e482c0cc886f1efe0a29f2198dc13acfde1df3365107b343fe3e3aec1aa14e73038e7c4ed14f16f503e25e08c352e73238ae167e07f08a5cbf0fdce28148b8a7e1a23fdd48b32865aabb755ab3f12662c5cc5f6dd3c641b96f15e156736118e7605a172b0331968674ed188fc628811eb7f162e5faffbd549ce6f16372412357aaa5d3da864f7626e428b2483886ea2b506256d65a9479a86367c9372a8bfe50527d7a185632f7acee69e6990429de68fd5ccaf0460bd4ae6a01a1ac43588ef6d7f2802cebc3b1c96e975e6d4d019b3e3705797153b233567995e3233f856e54d0ea4e45a10cf044306164281836600528d102dcd7d31a0799370e19b2ed40ebc19f16bb48d14f1b13e593f6f8720d64a77db1f33d4e676f83ee9da1c7669516131aa3721c3d53e179590ab2a793fe14e5f4e41ab372ced3561eed0dabd9c08ec8879f6a72bbf2e242a566ee8b1323083cce7f5c37902602fe6ba21f715efb92989b206b20011a496c3dd3d544269eae18103953c706bac59d6e9866a23e05999b1b7a4a4550fc1794500e6074caf8b4f5555b62ec97cb7b97a12f317ef0570a0d95f1bad7b41aef66b5bb530efd9c0c5ea99e598f8feced61ce0f394a60da5f410b18032dc4675eb3de43e75809c427d61c165745fb32cf1e33692ec3046dec28a8c2b074d95a139a2fa23138d198d9735edb051f804801e408efada2451b914aff7f9bf499bdcaaf69734704b288035f957dbe063c6e08554028d55d39c096912e280dac9cfd249b5f323982396038df3e10e542778d4f1f5fbc148af5e608186cbd3f81bad350ed223ce92a56ad8cfacfcd6e424bfcb411dae83d4737c6e99c98c98c34baa972ad4ae47c6e8cb5040d882d5bbf43c4371bd91e408e99661a71ddc57af5b1ee938b021bf18f942e8500bc205288da2aeb373d3739c364f1962280c2d81dd3d9f34e63d30891cbc1caf7949661c4a30cea7ad7b05665295ec6194827083cd196e7a268b8ef0eebb6b54ed3038143eba3c8ef5b2aacbd198d7aa0634a4255c2789b07d273a0c46822c95ec870a345163fa3d15045b234fe9e042d67e8d7e017343b62b0bd83c61c8611dbeeac0b150209c80c2946a08458a7e79376a9096219ca9a7bd69655ca663793e1f27d699a8c54fc16d04d4faef405c3a966f1daa8835eba9dce0a0c3bc96c761c18449adad0f3ee73042167c3fb5f107b117ac2bbc832c2e5622a5d561346bdaa5ade4754aebbabb16a46f377bb730cf74a7c86afd788b11587d203bca93d527e4bb52db5d9a1d4371cbd111df0a9ab41562a8272d4103b2b0de7c8b91e4e6740035639ab739a5daa8a7c9b524f22d63ecd37381b8f2ffae1c229c240a3ab148ea0641692fb87aa04f51dc714333e6437d1b16a5ec4152895427bbde739e50cc42cb51ba02c02920eb02e4bb3132ca17b27caca52f1b2af6f5c01b00534673edd8813ac4810a45aef36fb652f1b6f28ad68899374ae39f9ba92585b494acb4f11a15f7f90b7b8da0b4aa4083f2cbe0562dcfbaea63f5456b516d05a5907e10446ba6b73c50c282a5cd689ff0d2106ba56afbd7047ab6a9b273f65d8d07937992017d36c8aff919876817048a15868e1135e9ab088cebec2eba18ab16c5f5d7a8a2fc05c25e485633a3ada046d9a2f4fe585f8a1f40c21306cf5094f251b5076c41ca966a9473371f3b54796ec3c30bc2adf5e5f59ca81d2d739bbc3e5438e42b9ba006733fda3114f3ecdf6cba70b862b888956814e8c2ea9be30615097cceee3b52b804645a5194e1a547c1aeb47ed243dac1135b54316f037f41ee1a67aec85e0821e72b9b40216dd17cbbc2a6e9c556880cb031228608a37fd96c08c3e9f6e35d10033a0978b570836be8b54760bd587f09d24e2754b8d49de4ccfff9d54663ef544939458efc20b1a567b5e85a7be0d36130ac7e794d9d567221d6d1a6a5d221ae0f1a79cefc245c83b3307e51d1d01d0180b254c718e8a563a7df4807841ee54b5a28ddc2cbb6e2a73051470621ef113fb5a95d2073d1671428d610c50ac5f579953a02e24eb35f6dba9fff85d7567649b274d6588254a7c289b4ad9ce71a008d40f19a89c158ff0b9f67f11c168c252f52691a1d54bac443fc24bdf8dee714c7529bb810d40068140fa2cf9680fa2a7037106adb72b4db1d227a1b5db80b6f99ce811131c14c9b05632f9c4d973a29c2b3dcb6d705f45389067790bba173e5405b4f66fee2bb7ca3c9137916d0eb4a563774f5b41ddc833370300109291db8cd89747bf9f5b117fcfb1516a42c871659f60861c200e62ef39dc30203c4f62794ea3b7d5e862a40e4f4f888ecd7f89e33feb0059b9b2378bdbb8807b9478f4d7dcc20ade4a7ad59d94aa3d60420488c484cfc0709df596dc391aa06389f30ad59ff4f60bc222ffe4ae58dcd6c8263b11214b2feabe39c6b697029f6a1dcd15cfc8ca6653983b5b7ef728df2362b7aeb0481575682be28ca63e87ae73645e1aa1457c0ae0d5e053c08ac10b1ff74934013a88930a12aef4d6974d45cdfc846bf655d53290b644de59725197a94760f2ef0a042922254adeaac515e2c48e73c918b43235e276330943986633d05049d966389079cfe6a98d83f1e7f41618cfe39eb18174392b3a2fcb284e765e8bc7200e5e2d0595057b47d61a39972bff68bbbdc0f79891fb2366e426b5932d68f967c7645fe8f677d13a8642261884d56f8f75020a592cc4af77fba2be12323d9892e285670c9d571b9b2a02d25482c2bacd6987b83f5b900fe1f00d4284f8acfbe80a4f06e2bbb2818e212b288eaed5738869e64c2ed1029c6c4db11087debb702e033250f27e017fa2ab95b651c6dd8800333d008f7c88e1bb5814f23237048bfd21574d5c106dee4fb8138460ab475768569aa8ec8d1e2314ec82da5190645510cd2df7345f270e82677bc0e6b1641f75bc8c5515f2fdcfb3aa570d2c2849c0a0e9ae666c4650239c0a643e578469ebfbdb632954c697c44bf69ad418def42df6637fa4783a7d672d61f90a4e00ac243dbb954bbfc70de7d21133da1e45e3eac03f755f8456eba9f1a1fda1906a927cfb0337bd896a3ba970cce012ea1e5eca694bf2b76d28df0d4084304cdd56c9549d57778d3e19e8ca1ad1ea7529a4cfe63028a7452066c2a3503fba48e29baaa718f92be45736b5427058ba41bb044dc13f269823766934e526d61d80b68373febf2a2d547570c134b0d90eb7b5836d548703b9c454d318f311167407bac155b7387633ef21438e1afc340374176e4e7b22fd73aac85378320340b50735a6e4b2e6b5cfa241c00b4482727fe136f5b5b95725fc27f48c29abfdea38ac736f3c498c272e74d6497f3063594a3698818cd11132f9606e172a7e3cecb8a9fb0d5d4d981a4119c2f95bf4b2160c53e12cdce6e4d55be86c7572a498791c0d55fb00e13b2a7f626bddcef2a541cd50fbbd21c91e493586cab2d232f5f70ecb9a920786a40008958bfa91d13a9bfa9f201799e2d23ff05dbc24ac404e825f2497c6fc449f144bd21164cc3ec7a7a1acd2b0d10cec39e09e66477861051193a7a9066e867313046b5a328e1e11036b450b810ca2985a530013bf2f473378ea7ed5b4033a89ba0535b7b9c37616ffec4901b554a85c163aac4aaa73cd24c260f519a503ca934b7f075c12675e1d4defcff7fbcbb955902a4e32385af4547dbdb2c88fffd915cfe8b3764e350a5969baa40e50143115d56e65ac6d7434aec717686424350dfcff56d69cebe4585234c9795c893e30776d1d6e87f3b3850a9f24725514e0fa3a259042e6febc8fce11ed20ebff12dd1a8d06e74a973db335d1932ab3c3cdff759aed2896432a1469eab270765b057fdd813d5366ce2f539edb79e2a9db8474db22f94121e9b9da262d02142f9d721b6ef82edb467ca09557307fab01206fdfbda93f019a9a85491a36e26bf1e70b812f1a569a27949a74aab1bfb930893cbf169398a6f9f3a3299fd900e6fa09d49ec3171156e864269ea919c763265b74cff1beef7620e9252f8315df20e47b4479d286bfcbc2d40af7957e040a292dfc03cae5772fed42012fbcb1c6ec499edcb767b6f9b47c4524304a7743fe1f5787105915a5efda0eccf43363a0a64dc40dc074122387b7dd07ad27bec97907a5615fa68f24b9818ee8d01f89888f69988fb59426548520b308e9ca98dfeb7afeface0ea64c7b3e757e25f486541a1a53aea96cff4189fc33258f5dfffeed717e041d2b910709d594480a7ca0866d2a275635acd4bfd1a7a4428179baa21d5c6b8559d068ad6c33731b46aed17ad0911ab5b29ebc3f1a47333761b7a02449672183479a38c4998e8f9398deb9817afee66327929c876101453e1da4e7476888148cad6acef2ee000b0ef9b691bfe4022f687cc30b66678d423c1f994ba30323a6acfb1b3c83dc0191929b75622968e366ae6750d010ad2ac685a5d9b04029b223b8535c73e52976fe899b5c4ad6f4264b5e91ff8531f1b6c0ffdcac35b792be6bf48d7175072ecc005a6117416937c8b7f9fc91bad234ef07fd0ff479c60b8237e72e3dd7fb05c0908cb7959dee203c6f8c8e5bdeaa79904df61a51524933f692e00e4681f61c9ca4ca98b08bbbcf1807ee8f37ea2d71d14d5f59fda61ab8da6d5d87e709af8a940ce789d8cbe6108b1cf31c6150a863660a31d924e7f424a808a33d50c86c17c41db59575b3f68cd4b0020d88335a4c0324196aedaba7236ca7d99025265fca8253b7ae3b4bba36a088ad946539a118216d1ec823b75840323828d9d50eda180c6631ede3d4847fcabebbd235fbb57422baee9d0cb1490d760ee38960c05c32db20a3b2fa62378eb0a62251fcd2cd713d6420f620918d13e8ae08315bfd115eaa90157a33cc03a939c71fc8d980254f0b5f2a264a29300b37a014bdae3f610e41c0b93c4176f941525e66951c832f26aaa11c7fc47725b6d257b1b4a5812b754c9878e3b07ef9918be9712043d1c432b48759c6803a93b81dbce1834b70716182433b038b86e9b293f37441a1cb16e0033ae1045c1ae8bd59b2deadad78071518503b44d8efd6b8fc0b1c13f497380ecc908b744e4fb6bd2f2504dc797af822590f85343d1a21cc0a39319e0fd01f1634335fd03af285c3dbb162367d6c46a7b8fe3d57f117a521bb52e3c6dfbc7985e9c69f8d5c906dd1ac3afda891c0017b4dafcff7afa4c8aa4e2ef1715f5ea0e02b57ae47dcfea6163797da19e7b875ad547fe583baf239a2d160b617608e367fb89fb2032f937197d46e4aa03fd1da74d036753a35eb378ce8353feee0c3d377036fa1dc1d686d7795ec9c3ba5e66b56ab68c2e652d1493f90ad9e2034bec576cb1f7175366fba95ab41ec6b27d6a3b7ec6877505c9a7c5209438a8667163d13e44588ecb54e382f47210e7e32ef718d25eea8ce08a08ce708e6879dd6a71242d72ede692429f0f25a499336cf14913efc8cfa59e114bac46da578f6491378dee4abadc06b56ddf4099f0028319c719c128515beb9e81915cd496084b47e6375a5b21f200aef8b99bbb7cc9553ecb40c03c397c60a19baaa02fe6454c26f017839b855de3b860e9605ee2a773df8d8da5eb9b3c94e9e1bf7c70cb06e29094cf0aedf9c9ae56b82958beffba58845041f2e8bfad69fa5996051bd3997d6edabb5658286453aa3dad4e436f7a66e9583d63f8811e05d96da1178563f5e42dfd33184c24855ba67ca5454fcaac4f5381180426a99a0a07a690d50553b45e70eefede84ba38b991526d6c01881ab4f725a6fa16f1b92a320a4660d4195062ec562cc1fe392ba0d9d3748ec7d1aba4c6ad51e6d8fc0b30826a4f413f59d6d03283c386242458505f10449ea83d152e0c70226b86797b584671cc175cfc1d3b087926bf34a0a170c747277eddfcbfe553fc551c83c8fc07d7a596b70b62d17acd478d3a369b843d955e3ed6e703386109371e6b497244c12bde57ba3400738f6a663fee05150163ff070990e6cb17d4a3767d2fa933179cc22a3fecd1ad4fc1165a2278a70863413de7ce378a3c41fa95d0523069015e84041933f9bebccec22a39830ee6b0dad1175e56c0692d147db801777b58af71686b7c9b6ecf39c6fce7f912241bdad77a7c0f9f3ba7381c3b24810adc6a7f011f8e63f8e9c945ca997c18a3418357ae4f3ad4965a0d17ab5e3f4da12b3b03b58888913654b302b8741a20abcd35c5ba1037916afea6b2e1d60c865ccac95cdc3b75a48df60b9596d8e9f4196ac0917eb8e5a9c596ee62bf02869b6f49eb2433c7ff972e624d4371e8b519f535565fbf4b25c3b72991e9f2ad40105378777b6af4a05f7457db117ef46fcb5e367724b0e3c585287f9ae5e9a2c47cbc401954aa697d9f0844c4bbe7477f3843d481f954f75c1a420853246491e330d43a009077d28821bbe20e2fba7f0be18efa778c3d48a27214903255b128f8df3dfbe820d0b16c83ee538627f55700c2554c5bf38b0bfbf5489766aed796a79438dfc3ba8799a42a97f08c082e191236b0e89eb4dcb1fffded7a0e5bf472b4341c17a1f4c8a1946f295750802e37ecd77f2111267e9f6659054182fc632929695e1349e5f1a4a05ca4c333bafbe7e4d538602bf76c4996e8f6fdf97ee22cf7b240a2b663a738bfe9f4a1a9b915f00ff711174dc55a717dae33df4172b2216ec3173c1929b4788a73cc7be898b967f46d92da4112eb644ead792ed2df118c044a3d729c70825bff0572c671f376280652941b3a803185a370efe5bf7e9baddc1396e63f7a9337effc3fa126b64fb9e376c115e5b6d5d4e246411d22ec1c7ac5a03fac58a718a6d72b4024873cb234dd0c3e21aede07aefad39b1ed31b69add63f11f6c1e52de410eb510c5ca690e1de7d40d2dddba4dd56cec03cdcbe4baa93b030e25ee1b05dacb83290df548c42d0bb64f38f3b4041bf8e56f723e2ee901eea96259664f3195005c26adc35416d0f212a3f810f2832798da4fa5765e5da9487427ad3056c71a3bdb4cdcc14ff76d857d93f8465b177f74f44526fb9bcd043fba7cf3314f55752ca7bcdbc223924996b46e00244cf18bd8ae7aece8aee9524ebea15bae90178d339b2bf8335a8b1a2091ba9ba4e9a864081f90e6920844c9a78e05591cf47c247f6503be8e10ccead6174c6178977cd1e846769ab1170718d3f94ce047cb35fe71a39f0185bf7037a7fe6eedc1a5de7149e3f0d0369abc76772b25cb5413283642dd33f334320af017c50093cd5c956e4a299135c568a774f1565e77c0ef89990a1df4ae7e7146fa4f498bd33f1a27a024bed9bb1d1f7d856154689b63d37bc3dc02ecfbe8dd843e67789be0bb65e2d390977f1b60bbbf4b7567c0fcaeacd091d25debc3d718e14ebca655a67ef73e39cc8d2edc3e32e4666081668241106a2d61964b7546669fff71a910c90a3cfc95e6cac88117e37cf4a06bee1ca8134b2ea878cfea86a61c81b3376564af236a2a72855c6e649e95ebf8d51c29f59cb472c99f372e51c0d7d44dadaaea1a97b70b3facfec89a22aa8181e91ff3691d1ad7f175a75247b7a6db1c0af562bbfe82cfb0462bbe7aa810142d79ba1551ead45b72637e065e5f15651c1ff3afe4209f9310988b4f43d5534593bcf7e4268c00f409f2ab29b9281a2ab43d38155d55b580584f730c4bc82343cf60341ee453d9ca26c5115fa261bbaa998395886a2eab6043b1d5b786768f7f50e2c20c3c45165a05059b437df9a5e4bc0c5eb8e6c7ca69aac98c610abd05f0ea46ed17d106e7ef048a4cf0ce21799322b6a435fbf389665e42f9a1a04956be119cedeb6f7a6dbeecaf9d128043a850637daed617858e37020b35496c0ebadc006f5bae0398fdcccb39e8df7f76f42466d2c583c5e9b6277c0a147ab5459a7f6fd4171922f0cd423384368cd09418fe2a454c0092ab5f41a94d69804eda06d4261ea420a5ed44a1f34b5f1be0c11890d5ff09fa37ce8a43f6d05fcc3eba4cec8e27c42c2a21a7aed41e9c80e05ab61221fa3d01f75fc28476705c5b454e8637b6421feceb458b6c73ba6d19b9f4bb9e83630fee9c41f3e39b6d2433700ed8cdc3456906de3494a45ee196671231c83ec8b7dacab37b67b69b4c6094f919fa7bd0ae5c01f258fb5f48bdcd807585ca201f6f25da42618231d19d2c8365c06e320613ca4a61acba8610760c2ddd6cb4f40d6084eac9798a686af48c9db07c0923747f497a45bb5828bad9689ad016c73faa0d21ed1a1ade77d06c18358fbe5f63eaffda55e303e91b6d5b407239e8f79b534a31302758484d35cd8952f4f9e350af43524b4547128708f4291590211455b6eff310adef88cd726ae54ca2b19c611c8cfa6cf14ab8ccef2985d8320fb88afddee1da54bec96615a40241ed2facd2f6e2f06b9abe778e3ce85d3cf5d3839b849aac70cea7485ee791f50d9c89ab7560e58a28a7b6548b95aff09e44621fb5cd5f6517cfaa78e7309c39b87b65aedae8c8b23129646fd137f0268235b7c221a14cb781c2c4ba2f25541a34ae4019e9b4afc7179b511929a0ef4e350f60305750ec366a369536007b4daa9c15ab5058478dc7b8ab7d7d780d367f855e8814d4b0e33fbcca62cec490af55f6e76477c89b872a9fc91e4c43777afdd01846c337fe41b62cfcb062c536b8c2068ee0709028948d555e204bf25e505f34ca017d309d882b13370eeaa240ed8d2b6d74b4b6beb7b7f95a7b9fbe210b861e9768a0aaa9fc1e50671c2cb885a2ce2de67856b896d8e96280752fdbc432438bbf6f3e0517992204fb859a7332bd1bedac7b17f6c23abd60d3e59ae5f92cf444c2cc7a8db20172f7fd782e9f774c140ca608f87a439d2a700b69af1504925032b263a3cbe27d5ce037211f5782abe07e6a4eeaaecac5bf9c7d8aaabcd47fccc2256594d8bd2796197f1c853f0e3cfcd633b54bf09d348424e1e0d11571a8b06940c888873647ac65e0f5dfea6b440eb68ed8c2b5be47924106d6908de0fa740b798505805e2fcbc50bd6f401cfc798776ed9a31ff98f7ecd03d7ba3349f6db59e02d6558f4d0281c9c0a9fbc5486cddebdeabee0911d6bd7254cad17486e9012a8c16b95cfeab4c843a6349cabb9113643c37901171c36217ea5b53d597fd59377d2d0a58221868309e882ffdd1be235075b83b29d2989355c522aef53f4a28167e7da0fe534af5371695a8b4d479a4f2870f224c14bc744fe405d6dc6cd8d0ce262a72a7f572825cd4d8e22c86dbb9ae422c5ea6bf66e138b3714649cc35e6b29cbd3777abda5c391","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
