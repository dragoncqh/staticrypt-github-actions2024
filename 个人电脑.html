<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8fa4ae9955270b04edb8dce53e249c9e9650eb64b0b7b31d1a5cc04eae7568a5555d71abb876bebc09c57a8e280fa3a624a748ed176bf738ba97e267255e4332d58cbac0ac5c766aec3574859abc8f1150228c67fa715cb575a8189eedbbd7f7b4136e21400f7a89bed680f389fc9909febcab89fa45d848e60766056b4bde524f73c08b52d8a982051421ef2300807596681522f34b1aa4e69ef9c0e41f157fe8bc21c7e9138054579eed3bc14a3c21de8d6a06e1bdc5774953010eab09083eb6002d22887d19f9f6f7b681cab4c7e4e8ca9f29b044737ca8eec274365225bf05278e40338744f00f7e471e4163fb065cb14b936d07e79f79a338dd5cfc740ba3b0e57b243cd554461404bd755f892a0fd05dd8d2b61a1f674bc94c89becae8e4986f6a9569b9e2f76b331d5cb7544f65ac41275f2050c1e0aef564872efe53ac378279fd732c5518fec82eb4e6e590b65d79d74d0a2de793b528e7b0168d529ae2ebf6d823911a2c06b177e1d71e94adc82cca17ec0bb5cf2b1d44b0886ada53a3ddecf3c7f305a433baa0fd51f7be693f32f783420bb83bc759d423af83950b250db09a19c614dbd7f46eea265c0ba25a6098b6ecf1b24b318cbf6546f40f34ba1b8c77bf27e46941475d37c88306555706e6f1d7308d00e8c38536df7a993189d071be56392df70fe6d78a1dff2624928fbd07009ecf851c1ecf302c9e94f5b9700dd564d126dba741a114b55947f344ab3598e19cb0b8916208b3783e1c9a057da92b1eeccb461ff787ee31c042d90f0ed769c8ed020a5886a06527942b1f0552dc4e276f8785aebe4ac655b1c1f1c14ef129e7fce0e5093df682024cd16fd33cfe262fd03a5e85e6a055257197dc91e57a9530e894f26c8c49a1be9069caa4a46823b9527025a135542d8b4dd0b08326880b1d6752af2d334a86cd13d2e2a0ab094948054f45ec6459cfe0f5dcac6754aa2b13f210dd177b9a6f064d93f2af36f0e69e30c3557a9d1bd4900fadb0a48a77739b8e9dccb1f86d0515cc685c6719eecb9c25d5385e64ccbe178dfa4eced6abe8278ba931c01643cb41967d0f7a39af3bfc392d9cb3b0581ec408026e3c9c777a354e203c8d305f09a431ae154dfce518c22ba5d385bfadec0f66c07d721da2508af5f4bd24bff4450652209c890a4b343cd9f5793b4b4d1e09d382c4c9bf37d5dfc940d41a4ff59af752694a47777099fcdaf508caef125e9c323c2d897514667d47f1fc79b5e2274b23ba09a1cec1854d242bd7e5390dee079967667281844d3f89f45c51ea15e0613271a1be53c60380ba108ba4d2b0f4a319bc4d98abb1a6b914e2aae614f99258694fdfb605d0a4facedc9ba0eb4d0243afa13d4c2d0e558f46388dedefac564a307a97bba41933ff7340296946592a07495c62b632a2aca3f2157ddca211fc743c643da347f2e527036a40e0bc47703c8de8824f96527c949ec1447467a0eda15810c5e20e2c420ad9ecd85cfb9990b3a44a74ea33d2f67b20fc53b7aa8fe8eb00eee432cb03797f6c0ec50d37846b731ec0a0b56a9655430c5fac03ba2f1ff1cf448ff98fb3e61423290dd2ba9b96dd8caf945b0af57dce61e8c7b7afdb59c52e82741c9e7b75ef82d59d5c28e4a44f8c3339a79f2ae0230630a0e4a46a084b746f1449ea9f42ae5e84e06812e4b933d96ac64e87e5ed88350de41d0d02323a96eb34b0b7d9236e3c17616e32a1377a891d7c5b02cb6a9cfa7f83c959153de054c88c1883d5362fb66d01953cbbd2bf0c458fd7ad2048aa41672cc2a5f744aa72e03c4cb52ff00fcfa0bee61f5b000df0526d03a6f7c9e74cc47725c7b452167d6e41793cfdf85a60e86bb73a517f965d8cc716aa154b57304dce83f37a870ed223f98db5c0f420404ac84b4feeb85241e7db03f3cb1fa61f14bd52266c1dba63bd82d2843522ab63fce72360d250e02476569f98b2481491f80907d1f2b2ee0f8d2759d05f057e9af326e4e93e2b25bbecaa0d8eedc897833d5aa97c66fa144124f5d160a7affe7274383aaf3771a023cb7bf83262e65b03a3b7600be05f0406087eb215a8f58a3cdd4d959bdaa30163259a5cc36f69add6a3c8261be739b346e0331f362a803249ab3ef69f2ff93ae44c56fcb97b59ad68c3dcade0bef3967f718e404bfb4c18c661c8cf53ebd7de9edea00f5872c3bf7dda32f2e014bf733b57f82430c200feaf06dad42ad9b3c502e17c6a4b48804565509b2988c20f79b8076cdfdbc909b3cebc2b87d882136e467c2f4f4e57d1e650b78f6bb08d9679ffb3391548cbdfdb622ed6574965f9f360e6b5afbf712ddf7df5bc18ca3b63e50a2a34e51ed155e6803646978f6c7cde5ab3412d6ecf07a0ce5dbfacc88e33281deafffba2f181a690b1be6376987f4beddfd6dfce1db38309786fae2a755ac6f802b7b08e6d52c952c8605bbcd14dd18d30b8880d48f8247f77b8dd68a4fa2eb32b42dff573cde4192f995f5b8b1025f4a996421fa6a87fc5745052ab8c1f23f37ca14fbe420265cb85eb7472fbb30006bd514b316eed63883732d7dd5bee81e90b2270c41c3756994fa55e01501505cd93bf872d7336edcd0c34460ce4fff71a77a98c12d6496ca73675741a094ca6637d2da69322384c3e838305c4a9a9e3053e62a1a5366e576834cd3560232837db8d365a57333b7768f1417783a22342eb655db2f44f33d3c33a7cc7ab9df9a9863ca3b8ef6b2fde3a36ba32c13dd663f6b8845bba9a01672eab7eebd81347651e93a786cbc80e72bffa13c1b73b739b5560d57d09cf629aca7a998b1505baebc006e778db11351a778b96227cce86fa99ef19536b3763bd55d68de928657fcb387ea9413453ea031b0e5ee91d45182b57f9d38f270c5ab1c9317fd35504947e0b979d54be0d38f6eed009a5afe6908ff05b94789a14860d44f15a571701e4af76ed378f09d3fd9bac6c709c16d314f41f7e1e6d6ce49ceca88d90b4465762a7671d7bea3b65b90a69c65d57fc0fb5c9e8f6368c6bedd348396f57b51050320cb680244d8b8956f6496632f5831b549704007351aca3d4b0c2c78fd5857f26717d4a580b8391d5649fb6680e71a633f0cb33cec0990f96eaee4598e237c558fcf3dfa3e44b1308aec62fdb63f99dfce5117e9e5059310576306deebfb873657a9df5bd3f389d1186fb59820daa666a392175a5a2a6bb0d7aea70bad0192d97467bdc278e90a8db724e6a45689b62d5249ea2bdce5f122bee26550523cfe04c3cbfe8440aa9c98fa3ee09c83c63abff2c37d8233d94426c62edbbdd4c78867d719f7e4746d41b82a5cdf61c27e7418f77dcb90c0b2f140ed15068f7abd7547c2dd266566a6d57279ff7eea81cc1f017d4a93d3e63a77e108803180cb3dda2d129c1ec7b63aeefd413d73d8f25b517f97e7af4cea2ee0cd521aba3ca13e07b1af091d39093a4a776221f1c74e73a01e7d59aaad69684b43b3bc75fe4c3d5343f9d7989d71cd3c3fa569983c274590f42ac77b86637f2c16b2020d985e9678feb834e6e6b1d8cf84aed3fd81c709ade48cbf090910447c32e26eef5e30c781ce24ebd90864fcd49d12e51cac2cbaf277539a4c36a1a4c46fdadc85076a9e3d1e05e43cc8a01459514a67c92d6d83e22919862555aa2787c6348f8ba8e1a721a537158ac2888827f90baf5ce131a613dc91c6fb0e297300ab525d18bdddd53821939e8e610c85af9b7fee3c14be99e71d5e30a98d6d77c4a0e9524404ff42d52a96a31792df7d0567e8e754a5dab8252baa788d349fa35ee24637894e63753391c03c8111f69507d115fd333718af4034c914cd648d0b6f76b95cceb55cd46944535f270629b48421bdb088201c95ac0113b58c28fb560986d95f39a78dc55fbfa04872f8836604dd1bb2b57a31c386011c2ba1500c36d6464024adf054cf42caa44c410046fd6e61d71452e3b52d15a6946eaad0f394b9f6352dccf8ed624e09fb9a843a58c0f59d44051cf87af6843fd11c1c08f97c8e61d435cf7170763b01c6cdf19354d3181aab7a00660b54e8d2304e5fb8403b1dba0fc553635e0584eaa39973d36651b714529ab50b73bcbb0b610ea6c852dc61628bf93eb898bebcda6b10fac5087d7a7a89fde37a03f39a4b981f44bd8b03f2c5a465ac4661d537e667ca42e5fe39d3cb1e02a695dedf736707c244886338acb65637114a0c743956f11d6b465dbb2b25f7e3941918301077842d4bc8466883ef43d15ae4e94304f5d2f2dc596a3de8e2b250db585abcf00b5922fdaf8f8a4239ef1f7722071ceeebf91c1572324caf6610de22d2c61b1441018b6c9b975d3a49b57ebf0334aa0c0dfb63d49502b2721e1028da177d3ef7a96a68190653d3477ba6f945b3db5988a1bbce530b5fc874faec9c7acc3ee5bb42375407fcd523dfcdb35b973f5c0d4f1d9bdf01d41fb58be465209f4662fc8d1984b33906d233902d78fc4f7f05c22d47eafad552e4f26809276b8a577003e2de7bc6b7892081436ca24fd9aca11d03e0a949ff36e120a4ece10fdc6d49f6e0a54e9259656c14f25e602ff553dd73f5c676f7887167afbc6289ad95d20451314e584a0c04f0db6dec2c57e8b7ea2870133c98f6c987a272b0c581862c75cebd75620aa8dee717207412f3c1f408e2d081549cba5a6f2a45550283c4092052addf332b60333cb35f630e311ab773d33d366fb6402fcaf40acb7769aa865c45dec56e72e5802fe15455468d8d8bfe28b597993b18a87dd0d98b8d5b47c9af1155ba95c32dcc14075ea27a1940fdb95284dd87a5f58b8743510953f97904ad21556cda33b2d58c84148e8cd168fd61d0bddb0afba1ba6c9199a58ef3a014c75a01262edff7d568d4e03c585722b8c33ab8ebba440615bbbc60ef93fc559491e2216aacedde3d0888a883d444a8e32bc2211f28e24df148f2b09c75b067824c7313743201889d264e803d3222a554c6e8a8a56fd80a362c848a02ae3bbaa4e2bda3baecd31f85e80565e4db2d596472026c92b28869ed62c6c8827ddefd63a85e981b2bfdd76234476afdf819531d2357faeb7261887fac6c3f5a3fbc6df7ee225502e9901fa35760dd28dffd4fe4c87208cf32a5a74c4180ee539183a50b3eaeae838bc206132fa1e419cc66dcb941e2a3f63b1bb2356e23c482fd3cc55c8c0221c91f2e7e45f08040ec3c9f500080e20c70238f536ffbe5549ea442ec976a52902126c7c5e79d7fb3e278cdd7122ec675ef02b6f4267a7cdd89e344db1f6615c1eef2ad45b1e01c6b0688c556425b66a78aac65769da92217e91b5c7c17e0021406c76e5f5b8dcd8f57846ef72e452618a66a4224ba54242932601bafea84f5e53a8ff92830306ad751ba6be7edfec0bcc33343890b7c3a67ab59e77984bc7b2433c89deb871758aeaa2256111804af5b3974fb404df1389a365290a5bb357af6df3010cdbabaee62e2326a2872401b7d97756947b9dc50279523337da5878c49812e18818851ff64e65a150ad3b0ee55bb9229321bdc7606ca9c8e4431ea6529834f31a1a8e59d18866787297461fc81c7474af39c8d66f2f7fbf03e5171b4c645c7e078b5073de84215c95e54a92a14d7cb8251a7bea89867582522ff20ffe732ebcd14ffa3c34f07f7628366c549a24b92e6929c1055f5f915b34e6217ec723b255956e8af9520702fe7d98132c5d39c4b3a2b89c3867452a5c22880009e7d9d640d91d945ddf250b3a12cb68dcc7731eadeefceaf5b3a549450093a4fbd6416cb253193b029e9ac738c368b30a1b11c7836c8fcc5f7e56a0cf91833ac3e5e0dc5a7690aa8c8edaab364e5f7743d6412107a58c58f0d7785c911bd5dfcc6204111f7cdd5f20784ec96925465a8f1793cd62cae7bce2c91458ee7838a5ed7c5dd95d480fbbfcd084e543b17af6de998d775e02bbebe2c54218f1f1f647e0fc4675b3903f8455c92da82e14806ae94514a3a015ec6222eb0ada1b7e249065bf34ecc1542b71581da706edc02bfea7204461cdb017ef9fbec179c45aa720b8c4b83a61a96fe56251c5c5ea8f161c5d5c87fb6d2fbcabe3a8f9f8526c145d0efbe542ad45bdf305817654699762016764eaab3953dbba78438b6b8812ab33b8dba10f1da57b052564dccb6e768195111482333397d022e0403b5662af2c70843f83bb8af296483cea43105d93a42db0d90e9d7e7fd27182537e5f024251fdfc4c671ed3ea3726ed90ff035fa243d267574181ba1218a692957b5745406d71b0f87d76a8d392afb617e6a866c11a8284effa0563b3126aab39bb20633662d5717e8950d278ddf775d999c815341bc9d6fef51eaa25b787e4157c80db2f4f1166f847f336b989a41065cd03eaf94e2cee112a037a5584c23e697f8d653b6c801ddcd0888526e1df9c8f6507461aefe51241c21f2d74d6663a025539b75b449a1bd956d8720432969db25c91d6751c6c2d3df6ac853e01d615844fc0440cdbb4256c7d33788dd1591444c4cf0aa67e51cd182ee88143fe2af459bed3ac44a7f5914b9be2e80e12c562aa85787173fa5b663a959855c6533d3b9a1e015f013ad4bae8e53bf7a82ebcfab47c7c6328c6e6498fe69ba33f4f5387bbaeb800f5bda2b33272d68aaa7cd2e68a18e5535a9455e8baae9037afbd2535bb04eea14a2c6c97cb6895ea29538397a4b8d65e81ffd5ae20263db8b0d984efe96085037b17c144f149c4659a75d08b45f59836cee687ea8ed4a1cd48abf490cd59953a876ca966700c97e2749b923750448b79cc2018c036e55d7d3a1f14ee9df7c1b376c727bc4e4423651ed4b26276478438f7b6e350884ce64b7a0cf33d7fc2f2efe31d7808fa7689a4ef77c9783a45c6dd98e1f16f0caf4880bf1ca80513bdd703b76ac75eedd755f36be04b7d7901a536bb4bb4ae76b67ec22c2fb9a6e73a711e9a29364e9066b062dff9ca243c35a9e3e06e7dbd23285494705af9e24f3321515b9b274c0576f4dfbcb24587a0fcf8cdce06c411577a6e6321941e272f85b58c91bb84d6e58f40f99fb1385ec2bf2328952e8e7e80afe1787ef6a72c376cefece3a05e34bab773802f892e5c94ebc10edaa31d2876519cfdee4986777ee6e8bed9c083ee0f9d78bb1c46317dbd162c458bcb0419c10f9be4cb0fcf1aa2dfef816eb8d98c6d9ef11443d7880b40d1ad33f399c6a959da5ab60625192a49522a00571f1cb5c7ea9dedf33ed07e11241a2e98b680359c226203adabfd5c60efbd502ef5799cac18b790ac54ccee8d0ce58b57769962540427faee873cd26a4b4587c18d6422d7013146ed1f093b866d63f1286b9fa4dfcabbc048a13dfe083b417a861fed2227f52825ced74342e893672d5df2fe09f1ab39c649109b996c86334f5100dc6352528302bbf77a4b030364da3fd0aa39c78205a7968724c6405fee72367bee78f172e0c10780928f57ef31bf59bb8c9f64cbc6315edd102b99f4025ad978131cd513cc22b3b37f969017400352bb03dccfb5dff90b1344adeb15f4596ae09bc01d3050da9c61321135a154aa9805ed9432499e97cff429c4c54726c1f615838e322e8cd140fa7ed98d6e0b80e41a8edb7f03715e9c823f5761e66fe9550f4f667e475553af0128272f1f2fc8cbed78b1e9bd9155a12633bb9c8750cb377e27124cbeaf87b98620eb32ef2ee816ce08b556766cddfb1e37d751777361e7427cc60fada5f7a73fb432778c9897c663a9d122ac7f37c1154871d77c34632f37a8b231a96ae7b02ba4d0f3346b3ea6eba2da72dfe4d3955a140730c7638c7ffadb910f92e16f8edaa363a37ea960ded575aba326348d0ceba013524ede6e1992d11c07563512173dd05b4ba4b56e41e3f3d8e0da30f911d880a352ad4e9d3e98854731621869b93500c86fd49fb5f317ada7ecacec9fb5c69453524926a5aca05981f18da8415d733bf31f637249d9a08e863294156116c1cee3f9e28e70023df28073adf4a63d7c4489efc2ce076ba8b833908229195d145ac9606b6907c3d3de6fbd80a2093a26c0c43a163edaebe27ce582dd094973ba0907c2426ec2cfdaf3af89a8c1e27d875d33617c255ec85468c876926690c060943d4d77e7cef5e445c8f5f314a6340e2c21a496464dd3828811c53bc5825bf019e14eceea45abb90c94158bc982471e3dd59b1a52fe2c718f67cc69ee0804c17a31cb4b2b5639e075296733895edf469d66c2f9a180ad02bacbcba8a306ff33c4759297dcef9f5406a6ba8b1212335003ee335b6e7c7460b8b788e9ebc4e87ac55644cb450b04f3e14cee8f00a3f1799f131169acc55c88cafe1fb1ebdd766fc5304584894637f49eeb37d8a8b30a50b007a1d13dca5ceacbe1854cddda2d3867f5d8ad0c35ef7321ebf9f84e89aef4c17971095f71dba806aa9bbd44db3c23169570c444b56ad8b46de09d1a4aeb3356b702dd7ee31667e8290265cc5e51f23fc98e69e2c9d8518c27d464d80ea1e2133374033e41488dbd3d0adb5e2738c246bc9feaa53d8fc2ddb6fa3f604ffd216779a6ec8efea16949e8e7681b186f9e9651c99985cdb0b8f681dfcf185b941d2f38a173961093e4474f7571a912224bbac63f2bb05d4792a559c044f365429a0fa6008a06a8e89a7e5490aa925990ae844637216680f1458a816e202e011056146240664b89c91b2eabdb78cd97f9cd5fa43816e0bdbde22de9a4a03a5edf0a99c79a9ec830f5c784d981171c8f73e9672b902ee03edceb30475095e8cb6e061648a63b93214a12f3f273d1a9e27b946839bb06b6cd96865b9e7bcd3f7349a4769515b01b649b1041f53d0defdb6cd30be2a376794b81c342a856d9503c9d2f3f5ec5a1436608054ece1b3944005a228e5ac95790bfdab5d0db18afcae769dfb29917777b04df8ec75054f86379e456707b3398dc702440b07d585194b7ef2475d0f0962a77d14203a221c02e9b97dd63d02b3ac737b8cb9556a5a1fe4bf2912fd29252952aaf6e692b68b5f75199bf28fafc95c1d2493a7549ac31d616d6438b8817bce67ad911a17c72ce1ac67bd66d010193a392657fcb54fa05cdd4d433f6c37be5ccafaa857701bf9748fef174adbdc072b6b3dd50c5974b9e24641f4f8d18a3cc69dd95cc86dc01aedef31490131917b119c2abf9c82fc2953e5d6b18666f1d8e1f37530970b4c2dcca926eea79b76cbc3c66705b52df90ceaa10b6f95b70e5d62085c8ea6a64c60b476e74f6ac8147bcddba01c29b5e80569845a3b2b5fadcfd89cde0e49506e3181861d9ba143838565607f5cedb1595b47dc1fcc912580a8131595a59599ccf910a4dfd8203801cabe23c84e2c3e6eba67a368b5a50c881faad94bb8739af3fdf76b05caabfac76c11efbc016ee20c62fb00697fbe1d060aae2d0c220e6334189241cadb8ceab6a873cf34a89b8ba89c3ed5de69beb78edd6a24ca2bebfcb4ec5457ea43adbc0e4821462ac8862fc1a826a5dd75c3fc5fe3e83e6b8610cb2ca2a274676042e538a3332615743841c9efa7ebd6ed1b117eb5f9e3e3b78374d0c36906fdda26f90b5fae661919f50a1ce0440e77e12c97fe1797dd7a51fdc8356b6ac965079c38ceca60693834d7c8728e1516b91dc2ed630b50c15c7e3f2da9623f2a70b32cca0d0c8698e4b911f4c923157c0f5958a7ed11cc2dfc6ede59a4a4c4b8726aed08def8748051a34b40465b1aad5d8ebd89c279cb29df3c62117270dbaf797ebfba7f99e38404850e92c05add6401be5bb66c5e1d9b642dc0cc52a456be07d376d5a3956124bcb815682a6d564034055c532494ef905cefe7c640dcb24538cde662f786287e64099800c88ca829f52ef19a269926539001f96773501b194968bf8e3eb3afcca9eb7641a4b6959c06914b36302b2844a651f4d829083d9eb763c9f020ceba8591c1ac6ba9325f55bf5d9bac86e3017e775014db83ef41322beac53880ef7027794b79b30935ee898a3f1860abd569b833c58a59fafa58e6af0b49b3869f75e27ce10016a338b12466c585d4bb1e35e2f77c38c1e878b47a3127014a05f918f68fefbc3390805ff32a477612ff4b885057c52b10aa17f7970dfe4b4a1dc20b97e944ba448fa88a20eaae967e5fc0dac786e68ec6791883402490d19b29a67328bb1b571cec78ae97c852872ea6a22ce4ac75731365c9fa8b8eff204aadfd78b5f76247faef2c9168edc1a52c242295218148fe954d94e129428a9c6f372f6ecd976b16fb9d45cad88e469f65f2dad33bebbb3534f82d2771b5fc283620eb5a13c0db144f8c522e07c26ef469da3680b626aeeea7cd97035538e329dabcda59b82bf60bcd00ebca34061249155a894a387751650aa225b51e216449a5a81b6a358776c74607e9b72088c42232a2c5208a691098f5ac4cca28d80f60db184bbb3239354a12cc1f56a593ced83e3e1f07f345a7f6f6e25cbb3c50110e12e8e4e97cbf69154cbd6422c1febffd141918c50552da47a81daf4890746009be9563f1c72968fdbff8efb3f500323339892c9b9851b0a989506c7b54b08acb0d3bf353b416a9e1a614b9dc5ddc6050ac4eab141171fad8696033fe2ae6713d6e6f032d60b2c575749848cc6cea69fbf528fe77f2e5ef14f51387895480903c4f7496aac4945b94c76d8e031f3dfe084e5eaf3f507d129a06bc1974ecf7e004ccecd166f8f9d2d7a6a44d3a2f67d801ecdfc010e9fb79579b232d95d6efafef6f5a129c83210816feccc7ed8e8331329a9e42f42de39e2fc954aec5e368f528c7dc1c234b79ccae298839ca6934900990d1a87f3373e66c2aed5cb4adbfae517bde8bdb7bbc67a41350297cd03fd02af7f642ec65ab4756ea4a4e1cca993556562dcf474a9b827a9cafea372b16c55a52172033176631375273c2cd976dfb109e0bfe8423a66bbbe12e4e5774e568fb1e3255437fe95212ee4df20cd4adc2bd1e6f2453e46cab49fb4fe1d3296f0d4a7b6e8c2e11cd63871d30af97129e71e52b7e03800ed6494244b83433d465179360d9fafb124893445fd497b44a887e8a2d1abb73a73dddc88f6385fd6b06e32af7afcaa9f515f68aeeca7fb47c751909f246f90d22ac7a2dadda438ccd4e187d6ef8bbd037f1c0687ca7c3bdef534295a7359d9f7e267c07f6ea44bcfb0d0e55a5167ed444e79c2ac0b92e8518c8678d76439c814adbedb9741c7330f446c5a2d91c96bc2f49db25ff51aec7eccc21a9f052ee7d13a3f632c75343fcd12b6f8e82129d0b3acaa29dd8c3575f95331d9d09fd23c5d61c9df86088f0d65df3953292372891029cd26350f3cdc63fb4c95de3721d0497f64057f89318ec9422e36492df96be98fb2459e7ac2d093a7c2dcb03ad4a88323bcc014b4ab5edaeac5cb0424cd01a67399b3c4c3da587a6884eede8c259c79a1f87f8060949742c6f5f0cfc19c40efec19f326d7146cb51fd3abe63f52d7cbabb5518677d2f1ae2320c99283facd81e8c5146485912352e5f69d940f673f85d500f439df55dd610bceb70556d53e33b66c54e85b6e9aa5bd67bef6b40c29b86eb8e2d344b722faf16ff7c10477e6f81117db61fda4d8e420c5dd08063cb5089878a5633aeea7c0d1e576c4671da884a253122d9d2d0927f8a692f27e3fac9ba802c57c1cc846024dde765c34bd5c0a19169eeb64bc7b8d85ab0e1a99b0ab6b7220190fe9e40969efd0f085548f491bdde8938aad8527cad23902cd56654586b15ab2b20c9a91094ea0c35d1f992c0b440c7cc758e7c34631d928dbcb0d4b83adbbcb4178ded8948100b0af908cf48e24f48c0d65cead93e7813c6d8bb7c81740e44e48f6efe23c63181ac19d741e5d50e00c43d80adf74a5339394154f43d89e2680c95448098d60db1919124397b78de8c807a2322113e9cbc073f9638de23af2253580451497a8d7572a4619b84aed2cad1d950adc94bd2974311454433cd2758fa2459d1c39fb5569c33bd35ff2ca26063158232df2dd54710a5d2e8eb406f32d698f799d5cdcd44a0cb8ed13c25041ed6049904336d1fc075d83f844054a32b6df7f6ad2ce9486f6f73f1e55522a19081fdd15cfa1bac65974719901f88eadb251eda07bef0a5edfa3ce28f6aabf37701c48e8bc3e1ac74de3095f24dd98c017f6557ad3e7b32e0e8b98c74c05c71077e876baadf07d892f33ee7e693c2a0096ae7b0574b0ff102cc9668a929f2fd7cff856e50d8a70511b0116f71c17f0ddde2053a51caa75c1e552282bda70c37fa0f73322300c22f565038775782eadb744fd0c192a6d8ea6fff3c15318313314d29951833dc66058b2c6998a83cb1691b466a03e7aa2d72a7569a6022578ba5c408a391ad53c85e748bd12e067b9c5e760bcebabb8e19425254f542f813cc8c8cba053dd525dcc6cbfda093fd2bd47b0702aa7a033d8dbb1ac30db85943e7bcf2772182cbf977166c8186b7ec62577fcf7876681617f9a7575ced2eaf382505b636d3bc40127aca50efd976666feccadd214c3d9849e674cb135deac435c5a91ea3bbf921e18bf9c117de01f0e856b77e315352e0f024d53c1e9b674c2d4a9327cdadb5e7e1010b2d12fee17cbcc5ee0f60c9dfbad0aaf852b2a9c555961b3f5024dff135825bcbda3088b795676ef82e6cd7f375ed560a81fa2d1717467ce2cbd9372e155c97f1252884173de666168daa91c1bfeda8634bab099b05ea23e74989a9f2d4d2024b735c12fbc9eb8e70bacba32ce7fa0064110eaf5bd9a7337f74db993f1a2d76db69b060faf13e4291fbcc2fd55dc344f08a922873a7bc8e3de8f67db9b8142c2c46c5f51579c9cd1d06ad0f876d37e37aac1c617f50d04f987014b6c0b6ab8202d8b5cf00ca777ec77a0773bd71a64b4e73d0566af21f77fcbee37150d4421754d12d78a83a0a7449e6f9ccfeb62470647c0aea418d2c6675fc59773ffd629e77167d4a4f7f16382d1a602250ac57ddc7a03b9b84e33babd18c5e61cb0abd578f1e31522d6ebcc5573838167181ad02f3aad80916f5ff9b69d89b5c59b668fca2055f21483d39c08710f642c83a08c9cc76625d8f1c8fcf584ccf46f622028f469776dcbc85b81b485e00eec70e73e063ce1a8d0883394e9cda7c5f6a36c225dfbff4f77238e9df81126d14268306f4f750eb94aea04263b2f753a1eee22a31eee517515b42f31eadf3773c23e1d846324e2d49edf5e4508330049aac0dc5f986d325a2c91cbaac5c6e38c5bd4a678b6da9d0fb8444aa78f5b7d6e2590b6853f4f79cbec2333b25990d4df0725d0f37d56434ac666618b1b96c3a6bcc3fc0af6bc9b156f1b21d2e34abeec908354fd29ddc2a534236e038f28ad291f78606dcf4cf2ee8c1c6dd9ba5dde31e3c751f8de28f316030e4fc57d121f44992ad6ac28fa67ee4a715e1924ada15ab84d2b4628d3966f56c37de73bffdded1c893beee2a331600b7353c5504032cfbff64ae1743eb1ccfc5312e044e47c485d5a3a32e6f142472e805286f1d1374d7340f196a9c75193642d9dcd44ed49d1b775cbb255f5f6c907bb7876d2ce1b6f0bd566407fbb6c5873bb6723fa123c98040160b0be3ce5ec7065b4dab8be22714c9e2c5bb32a8f26c9087ebe0e9063273e3aa3ce41f368c5f20a9293e5d335422760d246a4595b35d897d9d0506eaeeffac67e15acd46077eb88393c2522befd278721ca7afcf6a8f6f57ab9ffa2e931d9d1e0306707e006bc1eadf8aca505cde2ed323b8a77338089f0ac9d7f6ac142323312cbe3b81459875bea426e55a840c57164dee41c534bb89b7998d2180e6ad5ed7b258d670db38b2fc65f0de13abfd5c1d8df9136c6d7ad7f6344c4eaca10912ab0109b050760ecce513d7649d326a9c1a56a18709f73cb52441a6290b53e5994d1ae86df3b554f48761b5bf78836a5ad20cd83f254e814196e62a9d16516b7ec3500f3d266d5356760690d60293bdd825ded4dd18cb166229b3986f75c1d4ba563d9b21493fcf67debff5832bfb1f9998ba31fd1c068eff927c055244255b269464480dc3a076afb8ffc176c9fbc37516fd91d8f0d495dde1882d76afa15766bc760430c0ca8281fdd6973eed59e6878ea454b1f5bcc3069ecca7c68e8dd5566f2e26738b79af7ebd9f3ab9fc493f25eacd7f47abe516bf6684b485be77195afa3efbab18cb4e27f6e03ef99d2c286e4643c226cf21dfb73f36f57f033cca2b3d4d3123bab1bf0cb7fbcd9de08aaff586f11dc8004fc533aa202ddf7ddf874a2d7bab38d18c92193467982866e013f7dc1b1147894da384c397997768168e989f512bae018ebdedef8050a55ca4b62d203224ccfed53435a6d445a47c43bde972ae8304312b67c21fe6edf08a2366e97c49fa17356f8c43773fcaee3de66b121aa9e753cfe4ffc84de243ecadd1a7791bae11637ce5640600d5e97bc83df891d531921b88f1a6fffe8f774f55c4e59a07293b97832362fd1a2c1f7aad64eb5e3e0763d1da4ed7180513f82e1dfa0b946f56ebcceaf31a7aeb6a418b142f8768e471e4b2d262bdaf738d68e63f0169a22d92464462b009801f9d8e84a171fc64f6c9300535b34c6e276d55c41b386aa6bda92a4ab461ec642b3eecad9ce56b4b5c767faa4c06fd6e2e3002dd3a5395342554a8d7c3e76d9ef7c6422cd7a3166016bf27bb8106c60321ac62c26cd93e5ca649879c0a5d2f5810cb7e820ba019ea2b464b3776ff321db23cc8136a2f90da2852a0dc79a26feb27080c8cfeaa99229b214242efabaa6fe218dbda8b57f95457f7f03dcb0e89a564a5f68ea91981335f04521b3c9362bf06e4133556b576508d006e228dbf66c6c6a233a841e6c3c652f7a541368ef3eb2e505d5bd751f78f7702aa9748a9f7019215ad55345a6f3f3dd917ed5faad1a5809df43319646329f5bbe9da714d18634de14ef8f9ebeb0198ee8c2061961ef07d89a58d706a1cb436948b61241a6e80c7cc9491a5280d2df7bb5e6d9256985213f557fed362be9c61e42736c39637f3e0fcd4f063b6007ffe9c192d0834791e7e89da1a9ca0aed9566d6444a7111471495143d723abbbf73b087fb6e5e84260a2bea29463e62f6af02e2e437496a3e51db0e3be878bfe762be60ddbdbabf7c9e24c20f01e005fbc7bc4264f6c3a4f3a0dd012f9ed140169911d4f324584a2e09a5ea245422b803e0207af75f847e05a141696de9edb730c22ec5705cf4293a216258ac49e0a32de7fbfa3fe42d3bb2bb19efc004e8e5b36db46a758c366b19bf490d99f5fafbcfa94aa11041ee96b50380a38b54b500df7ed51896affea99c9b6185b0c26ca5f3ae821a7bd0bbeda6a09676433a64abdb024e90056069fa7cdcb04cc5d4a51105f54d0215dbe2bf3f1906fe933831e4eddce1c083873a9b1f0146e07059aabae1856dfb72f4fd3a52d15395cc1cfe44b31513072138478af0c4ba17316552056460d1d1120670a18644e24eb093d51f2475a7d2c1c3e387786b73cd4a847673a04fb32fe136e64d3d58fab0721bd914c83b76c8d99043320edab8468c9c552983c1608624c7e1932233d00c273c546474f0a7de56c9369ebff5771216987539e0fdaa1980f160c53adab1731e77ee26d29869fbaac7fd4633f388e61742a76c5f2b357a90a8275b0a2edc072d80ea3e5cd1a426c1f60d913fa0d7b85af63e885b40152934b962ce3317cbc34825cece3143f13ab0d4fd200d6cd8d8444aa8ca56c0ecbfdef3407e42f5a193766cce01021ac796b5809d6fbfe5737005cfffad008b171384a6d999c9a28e06948ada1afae0c6d7ca606eaa410bfeb656a68ec25ab845d64cccd06e3b34e5562b874b0cc236b467c78ff7a8d7c473d4f33fe27d639b6f435d8f035fe45883558efecf204ac6a2de4c0ee9d9c537f2c13e62698ae4ea632a75876a0134017b4d754324f4fa093f4fc0c49c6573718c6cece4da3faffbba63fdd71c29c864e3fc53e9b63a9f437cb9877e5d1de9684e012fed7796a62ba2c63e6da67f6895395522e30278b6f38f9c7b8127e97eb3f54c19e9eb305a320ff8c432debc0ca276593d6d14937690c09bf2a1e783dee28889be11f3df8f45bbe4d18254ff10b47b6b1e1bb3def399cf3fe6a30ee0367aacaef3d10ce1030a568d121ba50b66789ccfcf2b5e671d1c386710fa024837746832a014f207be69365ca26dbf64a127a441a98f26643869757ad626220f567b1eca68d53df54d48f181469be5842a5c53973ee797f650107ef64fcc3c5dde5a77b1cb0b9b34f1b6b4301c84e4c4ca01255d4c759acfa01d2da14302ffd192fa363676e653c95bd788df1af34642ecca782522baa77f17dc12647aca3c855659d2fa0b3fd7fea6c4dc25652dbdbbefc5d7de8bd940d1186addf6ba639f35b5a0643e90bd593b6605d57a559be2872db34aa9becc9ad9790cccc69372a468b54173bbee02682cc01fbebab65f9fc9820f654ccc9f825af224fc718dcbb8ee702756f2d20d38704dc3dcfe406a19e346263eb3440d6f67e2e318fe4ac13d5ebc192bea5cc1184bf62a73f7119cde35fca6b0d707229550f471c6fd2e308f4468d0563861921e9b9817dcd7a71cbadbf0d0af184594ded1411e1fc4d2e1f526cca4c4faa39b3b616094dd8421a1f5d621621df50c2e3cf70d2c16b21b6798e07e66ff91b141e4033b3912ab97b4679085e5c7ed216d722d01e92ac817f33b670aa2315a59365f17fbed667900468de2033e69190434fbaf4518594a7bf23284a5d548b84f9c0a367d54015dd52e86486146294f607188c805cfb4689095437c63f1c108c6262f818bae1a7fc1e3349513c4e6a0ac5de1313499192717d29babff7234e66a0fab7ecaaca14fb72f4cc56ab08422ef2c0fbad49142155052eed82f74186820a11ec55de42c818d59192e652f4137ac976a7ce4c71294f4031cfba44d35b58933e1a746e2617a2f7062f6e3324cd8e35874ba5c56a2b8ef38641bb0eea91e4c1068255dfed4078f3551a54da2a7b907c964371b125ca2bf21272fb2b2c7bbb075b5c2464326a237ce27311f50314d54487ae9fa16039182f19ce68a64c43e21ea7edc31739f5e94b7283ab36ba4e964bf2bbe1f7c6acd346845f2a1e0e0aa11b9562538c0a741dc2bc762efdeb5418c4b0f7707bfed8313382b96181d396f727b00d30c6fffe3376bff616f6a5fbe5f19c63b88c2bec63c1237f2692ffea3a7b02eb01aa070a011574741ec302788b5e9a1cce86a5eac35d5c38d216f634e9039f47fa9e203c1a524e3c51237650ff461ca9ca1850148fd66d15ff3ebc0ed1c25f08f4ca015fffb0921d13cd3817be6c7248339ff03c5750fc53f6a49c79f5aa269687fb5976c5fd0ed1c9de788fa1d3259c4d5fe3b4c07bf5ec15e7c6004c1c8c2a7b07aa50c2bba5b16e72e9d3452d6df330b4a189d571b37ada6c5b94da36af7d9f8845338d968d9e923d35eee2f593f9316c0777e5d96abea824332bbcf5de1129483a583d924b8aed083626751052fbedcb2010feca0014a37b71dd0b46cde813d795b5e7c84592f67f75d3d4a6aff96da60e779d4d8261415f06c6acfcd2c5de0f7914853ed263c3064f7c2a2b7f00c6fb1a72015b6dc4d57a468e421ffe78ee9f524116149bfaa674f963eb6379c92dbf57191706c71998cac1f3042f606607a5989b446c822183d215d007b51e2e71d6adf2a2c358ecc7909ed757950b27864fbe87cb2cb517522e7eaaa4d762a32ac290b1f84050d809def827c5551cc478b83690149231c0c4311e6516e087f4fa9814af7a332d12daebeed7178e76da0e358f4f8b4b068fd2d1a2304a98338cea7d51bb44f040a670a9833b5d5d6ddbf28e6acf282534b8f6a6eb5909076a966318dd009769f7a034662dba91a7d4e7b6363addafd43bf552be12569a822d699871769b9ed5b3470eeb06350eeb837f08845b5ee411d30a23a9e00c20cde32c20e78d0299066587a28fab5b454dd3614cfa63508f4ca778cdb1c25354b48725159f6b11316f6f7103af33d01480198c43e641377c4efa153515209990a6b076073e38045d552b1af07ca8c9f23daa55b8f9d8510d0b1cce85965c96b1b6eb04e0e454614871dd5d8d1713bac2bebc5a7595923451bfdb1515754a0475b6e8129ecb4320bd106f1dc8f11412ecb29e09c9173da7ed8dadb1f1d9da71dd2a19e9ce3211c4d739015ca631f7a7ab5edaff9c28f25c3e141872f0b1b6db8aae6ef166faf6f61b3f0729d1c85de1c91993aa8d8c75bba2ebd86d5657b749d56c0d13afed24ac599dab8e034173f2deb9c5404df5fa0d8244f9a6a1101f2dedce9ece4ff75d7b1fa59715d2320a947808f1997c4a58d59631cd5fbce97f9f340264718309939ee0b5314f226ae4c856016cf343f0e163c08bb5a19fa368d166415f6a0e7ca9237f00d84df9dfafd9d980322bee9b321ead72b2b5fb3c93b8b8e98c7bf2a96402c1f7456cd4736193e6ccb86f9c7d8c08c67b9e76bb6415cd5ffc3251e302047aa2a99d161850d43e5afcf2885992f4bcb06c91cca49740701f64a8e71eab9ee72cff5b069a0b8ef362feb2766c156d424c3e5b5d1e288c7ee683b448ff5a1ea916262298b8431c7563d5ebc426f9271e811e3f9887f606d2d15bb46dc1428fa4478af3199c863f1c3fad0e95d9957d48a100c4526210f54d64cfe6bf910d4929a1479f25f5227f3bff284225823eb528e195d20c4c804d6b38443c31b50c6a9777f2760f2a05e8715360d3be357798911b60654a293b38987026a9860ae97027836f0e84d0e097410904bb7140129067aa3ca5b8f7e185555e975fb66e331999c96a9230380b98da67ae47c8d7ae5be171cee544f833bfd01a020383d418691e7912610a42a6a744a91de29a6b63a07b22b55c47b344d081867baf19113ddcc593ad5f0ddaa681cc901ab1d3ca9bb6064c8c875b32048480f600da3867d91c1a2840efee91185e9e9d54fe3091530b5a780f9172d2cc45e994eab6f0dc099a8783dd28d7bba18deacd4ce09b81a95234a5eed0def85d746bc7734bb1b81854ca3b116e6189f010dced569a25ee69a8f956d5a88ae2cfdf5d3f6291b9b1d755207c9f66baee552bd2e7bdd4ab5278be8c3d2adf251e0402ef598564bcbe953bde5f5c70f9129a77da3c905bab6c43c09479806be5a0061cbef18db75fb7a5ea65b570ed06d9922098be572f270791e6e86d07780aea45d1251d124837fd6d74c67e77591af198e950f95d42275124b4838fd568ea9fb3cccde21e1b15d06bca38b8c04d84f0ae0ce08064b4fabb797919c8742891a8f0211b44e1792976a1349a53a8c1789d98bf485e9eacfe2901d09bda21d8f3d0d76c72b222ec6b50c78d4ad7e108610908989520444c3ee62d45b45a2fc8dcf3bcb6800d17d78b23d007760765861cf57d3cc45321cc98ee503f26bba0ca69662ced15573a51ec0383467a10516c58417858512ceb78847dce05efeb81c0f07a966b3b1580708f970ef7f1fc3a60e82633d2c29c0d378e79d5cc9b3ac424ccba65cfdaca93c6bd918da33958ec74445ddab2c660ddb4bc0013932e9f2ba1647a142083e8ba68e47e2f2922107624ef3c91035e0e744d558e35d684b0bb304f626d3b377b2d737b78e6028616287c2dd724071ff80f29baf9736c13552c299539096f0497fd880648a3976169b8a0531962d55ea2e0ae68054f282016bf130449fbb90b7feddffe513047e12094cd3831f04379bce965dfc58825cf82c66b7841035dc288424790141c0fe993669e59ef094ba9f75973acb45c7a429a9db94c76a2ef77c132cfc948808b27577e7024cc07b6c31ab7e9a2eb145f1c73c9346adef384cfb15a429738a3d11192c188eaf8e3a5465a3a75ba6658d8904f7cabea76e4f0edbaddf47b29c660766681f85824a7fceb4553c17403612762544cc430f07045ce04fb6e45653793b4965a17812a0db3860a6fd4a8e816993aa64415ebe3f672a43a40cc06eaedd41071c2f456870a565086c5d28ff36e6cd0f4274338fcd78c4fac6e0c810b9a2fcdd5549c789db44f3c15405a33999b24323cb32f9a002b8d0db5e79da42f124246cd7714c467faad32488cdaa3d533da4a4f39746f1bfb1f801e89573e5c99b4245f99bbda598bb759981ae4e45f99a98eef1144b4759021f8951a7ce8a87de3d9de77a157df48e1e997c099d9bf2796f64fc98c3470e3c052e5d1016b5b1a7004c0ae3cc42bfff1ed0adedda7ed52096bde9cffe1c305cdf381d0b565a3b2d4f75130ef1ce4016fa4576c5d9a99340689b5e1cd6d63f34d26e2ce028eeb6c7d6d099f29438c62619692b1ba83cb171041d5c58e6b09b4a9b0ec26ad0c0a2cc90d6824017e90bf0e2bbc60b7ab5bec71e6eb9de337c6f2ce8dca782e9ae794a0ee6279363acb6a7ff4ff13803e42de08e6779a63db7e731375a458fae9cc6489a56f36f98d19a4bda9e6c1e88c5320d0cd3f4e44bff70ebfee36d5ce26444becd21a901df64e2a0e356294d61ec7a6eae3072ba5e893af0aec69ea7eb66f6471d8073fd0b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
