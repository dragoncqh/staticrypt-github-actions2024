<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae70293bd77ca78c739da9566df0986c0c2125b7b8b782729738e848b163f22929f4824ddbc6086f2a84738dd589ee88e1b922471e0e98eb8b0f46bbee9832e9e5538d6a840811c0e8ca78f039eda568874497d43d723408c1dfae88d652d542608a17f6bb8a15cfeabfb6d6678645c474d567f6f47cf4630e80e4121a5f92a1391c99b1947fe3c10c5492abf415158ad5c4dbcf370922edc3b7be4fe20dca96a6fe485615c6be402d5129cf531dda907ae0a211c09c56ecc2035ff4e8bc795f5ab75b21ca1eb90893588841bac26a8a935afcf75fed7a7f94520d5e5b630513d56922e8f9e18e6638b688be954abcb50bf88cf29b8027776d4c5f8e6cc1b26b1fa07ec1508a612c27ece20b99aac29fdabf8679c87ea0a9b8ac0d49dc521fd06ca9a8d73365de629aab4dcc7a2ab5bd0c3a731654d61d7fb2600c58a377885370ba9b6070beed4ce3cb43f689ffa0216200a84b05f3bd606f7b88d898f3837e20d399a5bce21203db57fd8b02519fdda01e40b3c7ae6982a224b90febb311e58c15c3c47f03eb58afe98a2df6dcdfdd95aef59df8a9f3676eff3f7cdd6d2569c94dc43886beae6cd98e1d0a3bbd53456e8507f8120b75916696eaa266207a9c89ce7e7ac6eb2e2d96fd8d27355f3ca91e447580c7649b2af2092033429a0e2ccc9f8c86a0611920d99943e00a51ca37af79e25171fc57dbd4b9b8d6be2c5c85c73df5c4be3b1c6d568004a22e6c3f266978dec580258095c30977d5c9b0a2b3bc479fdeed1c7069809627c68155df5498bb9e7f5cdf5bfc29e7b75db8e8c5fa784dcba33c50cb78a13cf01897a751d37553d2c7ac13c6404901968a9cc879722166d30ae8f662c2781f33e2b6f76fda9e06f0a6c198eda932abfea88546e1e0272c7ba82cc3266d8de0dd7e18b7597e004a6029c8ceb98b5b32313d1e5a81c2442936ead4df37503837474d94104a87b46b5e72cb42e48c862efc0adf3c125f3ffb256bec0e41f523eb9987bcbf2ef410dbda8f818cc9556b61021b7d9b01528d59492e3af3cd2dfec1f21ab6ec2ab30dcd4592b9ca090077e5ef35ada6e628bdd5d0a77a27afdb2ec19f26f7b49917fa29a7a7cda6ca095279a79fae6e1f401a21106784ff5a8d3241f2304e8b0407e85915f96c761b7d4c99384a0c4547d939754fe7c9a96857c10250473180c401a0db97002b72131d89bc155423b1c88e880487df20f8fe4e1a6516e07fba3a7fdf2aefe52f310e40847d2eae3152bd5f137b3e1860b40702ba4a92094d4e48ace40f9e2841f50fcb143aac33ba13a83230d36ff224060932c1f9f734222db36083ff2a8ad7927f02ff91ca4f0e7d768c6df2e19ae67245ff91e343b6e298f2d435737ffa000fcf2ad24ca117b209031435ef543f373e49680aa829b55b56f9ff45c68b5eddcecef431f888e4a2a3555e4eec54c451b067ccd5c2d198a608388b64951f50d62ac40be4b1d30c14caec173aec70882509cdc2fc6461423d6ecf68e7d27bd6c40584ba7c413f413609c0a1a650ba19254fbc990c44665eb153c27d699f93a56132463a970b09126fe25d0bef6f3c99fed7656b42e43dc7e8074b7c849369e7bd5dc52a6e8934ee2e8262774c59f754efac0e82b886b48157e3acdff75f8a11d81a3357ddc596243dd23c9ce7a3fa02201899fcdc9968b405c89b6f224dde77a7268c53587d468dac7c5f8b1a78874b9e587761dac9015e90488bc8799fc9ec17094e0b6deeaab18f1f3da6dc5544ce91b52761f774101cc6660d17931f998fed8fc60f32670acaefd340943ef9fb4fbb4378bfafcd768981f28e7ddad3ca9ae4d66c9cda22b3a7dde2dad971e9214b58fb88ac1d80cdb9ba1d73357a8379785f2c76d98cbb794d87aad7893ee9a6c27292c82f8a4161833eb70aac12fe2d93115c5f410159a092d8ff25897a0fc8931c76bbdca5630916a25973dc9c4384ab61faa9e900c722af5e72b5b2dabef719f0e3ff81db91d6c29bb75a0458298596fbd7340f1d40f73ee3e407618550aa001e6531dbd1bbc73f1935902bbc536f1f33681003a21640e6798133062a60389fab973f2ad33b897c6be08c42a36125209f813611034595c4ae6de555d5a78e22eaf028ff3cdfb47c3aec58cfe0cc7c7354bcfdb33b52d3eedf34f89f33edeeb51c5de0482e4431c5da8593c3f0ddd27dedb2e0426ea05394bb14413a148f027f2696a3aae28e6371628cd1fbfe09778d6a343a89507a536f106b7c8a54a14db20f66e85453f2ca131f316769f3d8024dd1aa0ecb11b9ea4b262b16a43622491f8c08576565b6102b1bbf3daae961180da334fc693363a0a9c52757b6ecebe3157775725b65c6b11d707ed4f984696f7f58dc571b132409915b38d232fd8830101b6d6a58e42cae603839449ab96dd325f0d797eee401b45c5eb7e9bbc2ebf937442de7c43985589bc3a4706977fab7b7dcd6f98836ec56b40c50978f3deb038554c01da943eb640f98460c2dcfa240c5ec2459624b3c7b8f7ef945230bf3695e234fca0b49c11b9f461b6eddd3e1e21c88a1cff9de21ffdaa5812c0e58c6d65ca59de71417648e7d23242b1e2bcb3a842776f5def519566b8f8bfd2787331b03b8b4cf46e2944f4266337e19ba5c85421e9515595e74178282be23570a8f612c3f9006d1033807e13df9cb9c457735b509a23aecbc76b1f542737563790c09ec0f96d0c449bd533b19904ef547413604e7ec67fc4a575472b26c4a53cfc74116143b1aa7d3d6c5cd68f8d7cac1489b869ca501793ea78dac23f774213050d429785fb0007d6e41e486c82c09bf0c3583bf7f65a02fdbccb351e622811bbb7875792aa78e1f16fff3902180371a5d5e15e9b2a8f12dc00b0ba70ea4b478a340831a3e4450ca314dbaa51cfe2c1fa03499411834df42773eda00257c4e67e2be3ea57c2372e60c0d275a846267d623a9fb976ca1b70da996e0844937993521a28ec83fb7e5d82a32b1d0f122e47284f384246de54bd07c6e96d7cfe0e56cd4f8f6be40aa579fa3ede84244acb7267ce9e5b0cdbaefd6c261b1a7dc694d1b64d46fda37e3aebe90135112c485604a50691de3e1167aed0f2dd11da9a7519a53aa9c2c623c21fd5730aca9cc733a49b4b737fa8a2f8b1a3953ef456f1731666b0a3f13dfdf932056c772d271cf8f7f845221d5c14a2a0cc0de6b4fbd1bfb9f5d5e6003c99e533892514d0372dbbac6faff90c8c5ce5f6bf67df0ef2cb5a2d646ee3133486be853b3a087c17c4f36a499001a929007a542e44d91bfe46385c5f792347492639a599ca5326980415d404fe1ee0f249eeddac9d7031346b41768c20a15be7b6de093c049cc7b6b158c4a0a81dc12c30f8bcdb79d33efb4ca582a9b1a172c0bc8707e79ff909da2f3177550cde9b8d93c249fefde7bf3234ac8ba769209d5f796fede3e00e3b66e9f73e385c37f92a6a5218d660d1f730b84ce617d31acd27c1a94f49d173d99828c1b264ab98db5cad61c1af0a39b9f59bcc0169a0c843a11c4fb9c8a457a55e35374e02686e844cb62032afcc2ca7dad107daaf728f7d9e6826debf974856a0691a0319484e193ab2ed68ca5fc4b30e2b29eab7fa58b4207ce068445c5d9d607bffc887b4e560c6ccd44dff510d44b70310e5d4e0f911e18df0c56f572e42f5f09dd165712a741182d3f192a021fdb6b6b84f15f13c51c0499728b1ddc9c6183ea4552aaed48802f0672ce72d5c485da5ad028f9d753e9f4384c30d4ef3a95b618f5f77cbc0d213b07e8d7547dc5d3c85dc9479832fbb57f511fa608a09885ad1f4018252452845e09e2f0c8d8401e3176a3e63010f4cb544d992c555c9e053ea35da59c15909d6ccff92b6004f52313877acf97de0e65a766fc09814c2bc91d45fc188e1dd21c5d964e443cc4f45ca61d93f8acb89ae77c2912152bf08d4f29f1b767b112a8e7734fe6da692924580e7acaa0ee59fe45a26c62a1b09fa01f135a5dcdf8e3e8027e875fc3c6a20f725e320d4849ebf05e6356cc042a3f81e6e26bb748db6543697ee07fdcc03e10612512558d573d31ed4c7954c976c7cd623899dc7331d7203ab652cbb636819cfa8cdb6848e4ab0d09158cf2c5b7ae566d5e3c14ebef720daa9ad7988b7447bd3b96ee2da10becb8d7bf527185dc502595efb967fde0d36bb9089b231d9d5a8e05d4e926eb663594dcc795ec377a69c59686b5fe8916cf26baa88d28616d6525963ea157c359e7b5818dc6a5a7dacf19aca808ac67774606c2f7dd8d361acf831d51ff8781af7f91c28dac746b906a5d92047f3c0083d10d87a47d0be11cac5ce94ce30d319d544505acb5bd917aa0913c4d1b918bee958770f8502b240f6ede720e83d13a1e02d4ed82cd14df505a84070b876b770ed5b7f9a406311d035c26a210ab7244a211fec5271c10a465d363da174957f18b2192176cb23681ce93c5d4e93b34a9df9c95507b3121376ec5fdb2f08933e348857e21e09253b9495f06bdfcc874b7815eba153526bc951e3486eab99163fa11ae1428fa0afc451dea3aa3f1b73528f5834d5f7ca81115b9b35c832a07675d44e7906ad95cd82a32ac5e68f2b08ecc9af181229dac92f7e9ac39320844f80a06eed4863e056dbf54408bc6c151cb897740e1c8766b7eead201b7b36abcdfc0b6b86f8abd65dc5e6437103ca4a27ba85831be80f4c42d9e200e870dee487914a0cc52cbcd4e9800e43f0ad7f4cdb0dddf01fdae28ae223df3c163a74c414f7bbc4305572cef13f3e3d1ccb99edfe0b93f55f708ab552612948a88e9d7914cc8492e8c66dd0972de9c3b6fe7454f31bacdbef3c30b314d803fb1db649c9a438f20eaf9c74c921f146392147443f97ad35f5e1029d7698211cb80b1fa4b61617406ea7cfa9045438572fc0ef74dbf2d51fb55ac84bd5b7bfed50e34d271199b17a07646a9ca95815733aca459f52fd0f39d7ca1f588561d1569ab28a8b1e8e01275beaa83b0661ff1638691a8a8cf6c7795bc8fefcbb7948d6b4848f7c924aafa309e91b3a27e42fb54bf0c3b94e96e300b05b8358202cdc8b3994dd39bedf54182d054ecfe47beccbb989a799c59512e9ff8bb80e177c39f2989b6a80675104c7e1ec348b058e4a0529575025a173d6b4acd64ab2598a0069d90f3a786b064313a3167db14290cca2cf4f841c2d3b6fc3d056ed59de518df447765d953a420b081c6190b6694bb35d3fc1a2ec85608d1f82a95f87e6b4c134abe51ec3aa91c3f647eb8a27dad6e15a7223e970c937758ba3a542e3e5d4cabd8816134c9cc5ed9a4acf47f74cf8feeb9d17f380dfa9a9940c224d65c1d48a63e7a74cc7a46302002bba1b3bb75e247342b18e13ebe52b97e5478041239ba5e85148264e4593173690be3e3cfe77422f6c8b17e260596b503d900621c258b44ef90920b706a0d33ed56c2a429d9ec39bfb54b24865fa97bffb6b2b5098c316a8ce2bd488a7da1cf9db86b73c23a41343726cf5c572e923419ec7918ef0889e418caccd3e574101be46bac3bf29217ae463c23b12f5f8709c86648574f9f36ea9ffb30f89866b36cf2d9ef4637b26d04828d240ad59ff9450a06f70f46f07e7d69be1a436a6298ddaab4737149061955cff0c935f3d89bc1347d652d8a3da7db8d70de6f778f405719db5947b316e4e329a77c80dfa2502d3b06f5d25f9319b499a958c0d16f7c1b98a746fe8b5abbe7134bb416f13900d27cc70ce55d0aad25f23adca2eec5423f47a732daa21455e5f93e649fc5a2d3fb29009e2933e24d3f95bf1c2d31a6fa498c214bb962a27f19807e548d5149a885721cc63c0c60d5f657de1b0453822d5bdeeafe7351c94cd64215b054faf040907df08a0fed9e0110aba46f521a89123504fa12d727356cd4044f112ac81e673647d203be481373cd71709029aa66c23de19490161c0b1b9b68c2ba5c476cb2316d53526e12b584d3fd57de4c774516bebdfff20a439bf7639f7bfc2bbbd0455744d71a1d66042e5f1dafbca39321326a0138a2a8df5207c8761208987cf84fee9128218ce2aa47aeabc97e3e900fc0dd173681807859ad08307edae2289357d8524c8fd88877ab9417e1d067104f8a4e2f4cfe76e767843f9b6648a1763dbffc0210be07793a660fc90dc0e9b0a26dbac3e4e5b4160b88ab4fae48c00d4c93770da67f5d4dcb3adf6e9fdf56044989719022b2984058be762b6e147327bfc193f70aa0ea5926847c4b8595c27cc39543cda8c1b9de18e8af27de7d9ddda9bf668bf1c213c6c8d6dc02fc52498820063507512b43a0bac38443165214a495c467c686e0e0a829d1eef513e7e6486ab59aa883cba40c52216364194cd0041ccae57e2588bdc0c21c4b8ee23941da34217dbb0a36a5c4f14279b6eff07d63e4685c314f6838d7c381a0063f4c050375220af73815abf28cb27ddb0daa20c25f03257f6230c0cfe547b3397964c15f21795cf8bf658a28b30dd1bc7213992113f88f73f81c4b34048c12988eebe8f4e9fc7003a46aa7eacf8ae22f79b267030787ee6259af5639fcf5b0603a7a2aea2bf55b0e7ce22c407cdbf7fc97731a6d7c893fb67b3e9ce1edc8f09d2d71bf3904c560df3a081beae9df5594d0cffbd2c6a9bd103de34f98e308b1703ad5960586138bcd6bbf8cc328e061ce5d1ba2317a1c6654f4a71e80b3c71e120497e6205aeca1ce86df577d6ffced5f281a86f07b8279e9b01bd5e6e5f2e7d474228d40b3bdb0ba90d6ded4409931a7e38345ca71c7d430082febbf01f23ca0c060fb23208e94744747a4b68595a94595f1ca09ed67ddaeba71af8da987039c999c0eda2e3be7ee1c9632629e6ee491dddd13fdfe7fb0ac311d26bc830c1ccf0b1d39b20edee5197dda6b56c84c6dccb2370fed7b81f3565e4c6b770863293c804579701c6ea3edb160608d4ebf1e566cd1ccd97cfbed29355f2a2841ea0659d4e6bba58e4c038c21dd13b6dda50479a52e030d5c712aaa0f9296034962789978b2bc61541b4bf4e5fa5e944124aeec5ce9fd34f39ac718e6c1d99128fe427291601c912d7840b2178f1193f2aab998dcd2dbdece8f55c7b80e6b31eaef26a1ac3ccfb12babe071d21c72b4e6c470fdb352e6f3f278deea4e9724a08285933587c86f16f3ba77a2f12450377b0c4f6a6c5df52fa43d39480f9862552eba889d2ccb4b5c3108e575897f9801f258f59a8f2e1ccc2b6f1d015f8449c41e50ef05f7b0c01a499bd24b3cce95723b7ec2759169c7d5f72c6f21f65778c75aca81107d0af0e36dac163b10f03f23e19da083d25e58306d1b6210664e9a8d6e918fd6081466e61f44881fb21dc6af415d52de84b7b5a06c449ed394873372379015da6a9f41a8cfdf8b66d3cb5de9007bcf19766f3777646373567f88878a0f67a257441ec9c0cb6ad6b9e9e1a168c902aba4c8b393ff7be68bbd2cf7c9c855af77169508feabaeeb6ed1087f40be62ead35b6b0db0124fae07b284c7641547405c96a579a241f5e88d3c89c5cbea0196a098e350311fe5108f342578fb47f3eec077098c76f3beb5931992a87a0b349f9c424dfeafedf828b43d233fe5da2747b351e7a68857d195a17cc318b8fd1768cd15c508b787382290e7c0109213934d713075f02e32ba37360e46b3a9ca0777ace34adba592ffbd62a5810a8f58b98fefa63b67a83d4ec724f07104b6b0ecfca70353aa8348badce0c5aad8d4edf0dbff4b915a907527b3491167f3bfa897493cbbda0f840765485953a77a5aea1def741447afd4dc1b72b4d2e9d1d837612ebfd9d214dba3dd25dbc60c571466ffa702d070337a91e6a05efcf1ef7716db1a29d0d53133e85bb7c8c7ecc41036fd86e69ae39fa516115b4561b1b2c91c6e2a83ae298af84c6b8369c3ce72e93fb0bda34ed1e8d2b4dba58202b2e2d11b006fb2f77bd2f6ffaf346d9d8edfadbde87028ddad29739a172a91ef1a0fb1c070b8851c4f066f93a7979f9e0561b62d247fc736c33216595fe3b671da9ce3b2e358bd42ef129a7e6d2cfb1085556547c2ea9d2fdd0897478fcdf1e5febe23bcb0883a7f96f01c0b56d73ac2566dd825be4837b5a3218a713d803ba428a1d751604714ecef5afb72f0a670dbf52df7641cc51a525a79d139f2703bb2f992b267f3a3be636298c8db0e8680bde675a12012ff77314d251c937bef4ac4b51f70d6d631e74e3049ad257eb80e4f497552a76e1085282408698da5b06112ad1118a15d24d2ddfe0a92d87faae79e1910b524c0edfa3a5dbab2dd78d40ac4e23828c10d3d9a27ca43d8b4bd87604b0cbc2ecf9add1fc4f3b5dc7fafe321a499428afaca7849ec55d4396ade0c139b37483899918ff05262ba324db555446c76e6c598a98e632280c6e3badd893d955931b69e4fd700481eded6f69fd435dadef01da85d21961ef17919b6db5de3acf29d0c3209bacbf80799ab4f9806a2d81a71b5fc0c77a43f20dd4875e6a1d0c665b707aa3425337be39ac5457dd724946ae51a1ace8020bdbc1b8bada15b1cab16cf9a3980675d2641439f171e85bb325ac2ff0791f92caedb5d4fe67615a6aa23f9407909180f83e4880dc6ce2885e510b2b2d63dc211f47d1c551e09ca1c696d4189dee807970f284cfd4b6d654ca225021a71ed8e218beeb9cf4df75240a08f708a3811ffc9669d12cecc7851e12d60508bcfd0ca81a154ef3936062a16a6681960ad426bf920ed0ff7b654f53e73dd9f4059bc30bed1f1daf11073139a6a93d0ff926467a9f04762fc6e5386cf1b972447a52466bfb2804fadff3a9860101815e34c640771cd83247e5ecf1c82ce658af63183ee0942007068a200d2cbb5f971609d6638b196999528cea2e2bbb82285b414a0daef0199b6334088b2f0080099cde757cb3e2ed4528d824fea0fb958d2f2b1384e4347073fcd9b59cd2c013141ca7b751b2273d423abc27ac7508d517ede01d086b1c86ad5fc8d278db35bd296b933ccb5a1145bc5bf8c34f33c629301f641abf45818bdb0ea4f15369f181d5418e8a7024cc67479e53aede255d65734af2af22643125a64ce615cb3f35bebba1cd065efd7d15268d19dcecd355ac4ae869943c643b762aaa1f747c6dd0b737a10f476798859c740bc0345241dfa4d1612da005f4cd623e6981d11ff40a116a47d7522d11d1aa81eb7227c96e451845414931d766e55fc4da091f07b282826939a27ef39b367a64a6e7523770a9d9d1b4b56c30422eb2d13669dbf5c3de9c6e07703c4dc45618d35eb3d1d35034a438e5b7c5bdbccfbbc609d9fba12fc6964c687dfb1ac001a99163ad814271a8b58a0f2015759e52b94143651b6745462f1aaf2ff75a0bda52bf958a8d2bf97273bd2362849a181c0ababf3df06f500a76809678ab4dbb0703c571f568c552b7a1f6160c8eed5276877f89d952ac3787e1631e66e57ebf402c7928aeabe5445eb73c2c0058e0136b55f8ab8e81c5ef15fd82d0e38fd71d4d8b1b61c06b3e20ead3de07e17542bb9ef23ee58d196afae1a9f444b209c94b6e02c10560961213e0b54659e268fcd9874a7449e08c01498d3054e37194738f9e4b113868c357a266adebc9c17aa6905d569bc56be1332100c07a24a8f6bf81e6d87e2ea9ea0417c1dc1ffe6d08c122bee029dd781dc560432d7b6e7719c356547fc6cc7ff9ac99e0916e3738c948c1f60da6f6fc761fb662779a9e563e85210662b945e15d9c4d17c58f619704f15b6c5645068540d3eb39ac4e9c3687cf09f9513f108bcf671444ae4bea4c7937eab4e9c026e041fffc3cb1e7b96540f856e99cef43aaaeb9977bf1cf590ef10f811633d553a7c4638a61f0ebc4bc4e664a697ffe1d9fa94fed29535f103e48a86518ede3713d128c68fcedb2124e63d232b6015c172bf07fef0e9ffb3d19051ff4fa2876862bd5130216e8e77c07ea7279f8e247b2883c28b3bdeebd92c5fd953b1e269722c9177e1ba8cbb24cf7aea442413525419c425cbc5e9af36d145d9bca429e972a146c2e0ad720f71f47f3d820f26a6afd2866e79e1f20709d1948769f4bba13be3912c6b7d500d56bfcae86ce5c04dabd28bd67970ee67f77a1f90cc2c050c8fe21e3dbd0bcf2dac4767fff0a9a73280c83295b23a3daeca02e156ec43a7cbd1fb0d5de278da22d23164e2229e99465e1e6e3c01fd478ef9f3848de4e73ac1810ba82fd7dbed523331de3358c7188f6a029b243775774d61890a0052540745f29358050ab0403ba4d94e342c0d658e6c6b240e59df94a6aa8221715dd892f0f5b22546b74de15bd39c25eadb4a81214db669267cfb7512deb0054e000c2a4463e9ed863583958916f5664c799257f9d38070c09a1fc2a5047f6490ba37dd3eeb07d198542a67a3aa255f599e581ec8e444007c0c816777688d97dfd635a0ab1008db08e793a4847c961c7a27e97b76f0edb83c5397e4d8e2b82ad97e342b60329283d19a90273a0c8a6fa6b8526c0b8a717a1e63fb572e86d0536d435eb5642d3e1ea20f830532224846fa023b247ee6ed235247c4268594ce6ddac3900225595a9232c325050e99d156e7b3c560a7ced9070fcf3e958a7eea01e8c4b3cc3eb611ccd93b5777ee0b0d0a43f6444c8e4873186431c130fd8df5f1cdd48d6bb52d2c1992915eca859ba51c0687e96870bd6cde9225c33e2180282aa3ffe3a274a7c79ce94c354dd30470691e2260760acddf141234d7a787d7dfe2c7a86eaee143173cd25136d7c0173674cb6b39e62ca3cee89c6a4d07e72762627fcebfce3cbdd7c035c401a6e1f9d5d4145b9ee3ce631a71666d3746786d11f82ba8290576c7e749d3472e2da9b3b1f31d47205cd1139957bea79971c09ca1d2b870350343234f04077f7acc879885ea959179d6c1c697a5213098e01777b991de4f11743c3fae3ffe53c3aca9af6a4f09489aa1dd26afe8c1cb433f391e8e1b8518e1767daa6b44d4dc7fbbfab7aea3bc48d77aa48a3df72c032d702e4afe780fd9a9e930abb8a3f8740c68f4feebc22e35851ff31eec2cf9a8dcdb3d18ac22a0b9b235a29eb6fb572e2fd3ae10e494842569954d165a32646b64660286a3d577fcb959cb085055a6895cf6ef12a7a6d7c5b17540c613dc2a8c214c9f9ef821f5761a67f99d16e4635777fc74dfbfd36bc24701707c2d44ab5dd1a775b7731619373bde51dfc57812880ab1202d9203fade8eaa4a24b52c8187995ce7a152e4ba96ed83ce0072dd370a16134fc81cdb8eda04a936cb2b46b88872ac8a91116405c859e1d1fb7c45cfc41a07a5b726408244a8bef5bca00fda1c18414e77e69aac53051b5c62ecdaee05ee2739bbf9ba23ee4addaa31065c0f5bb00d2679608796f4ddadd673e4020780774f8893f37b5ca911bd5cdfb67ea9d2d4a0c867c9c9a8561bc81aed104f16c3e77074f03eca45622267b1f3b7fe6f2cf40f18b7e5fbc28c6153df95e00813654d8d791d800c4d2e509c503e1bd856b3f41bc6297f2cded98cecec8f30a4130578698b5132d5fc6e859931f932dfbf245c84772cd9214367cbe84f0904ba97dd56e638c560c767a07a708eb6f45b94597b9cac0e9444db922a176aaaebd2d882157829605c3828478dc1783c5ed1cec414b6fad79cdba8290416fb79903287e4915c95c4144a36dad35b184bef9ddb571a6750ffc4c4ee21b2dfee2daae6fc8a77d17e3e09fd77909fccf47f531885dc095d99f1a9496122b9fa442e59a06ca93fbf490f46a4a7751bbcb56ba2a42740f9d5a596b5ab56728c8da04610620519339a3e7e08f44ad11fe90b236c3b94978300a728c7d05d10a88de683225effe848146d56a77dd0ba02025964b21d31d75249d2c024a50cad8549355e35075bb1bb40a77fc180a86b7e87a84cb7d56f9036a11cc01752c7762526568caeb55dae1ddf5ef42b424e75b747048c0b98a3cfcb0f69e390e636ca570665888907a27003e91c0e2cdb71339bda927429bd9073192dd75fb5b74ff0501ff83b9b5fb629fd720307e6750042779b4b1b4ae432059b581ef3407f53c2d1afcbd18051f89f8f633fe90efbeb3fdb0ad0450cc0a6ef92af9b39b1b030749ec14d51956af0b4f3609234f08a7aa20e31c9136aefdfb6c491e7fc72f4eae98c23b60ec304374b11d4155392c390c57eed5ef4f4cb8840adaee3a04b7c368753dc721329dd11bbb418118667e08a6bd61bda5b38b29a1bb642780d024d65f51efc6ebcbba441e50146dbc84ffe440b91f6a81a04d403fbd9f55c42472520325d3e0a756e2c4adaa72d8725b1330bcfa85b760e15f16cd7b90c58c4ab7ea51b9b1b066a0fc9cf3555c8c67c040586ee6b2ed5a8b1023f9cbeb84c919031f7a8da984f7b469e653bee6099eb14dd374ab4522fec23b3a482da293a59ff6b6c9383f6b23f0af5bcb36172f967e2bd5ce4f756935e3b42e50e487f045a033af27d0252be0037f96879bd3acff3a882711ed21846aa5ac2015cb0b16ac9376e70d3e81a58f3992f2981fd81298ccdf2714e0fc43eb623ba908a955f8ff1eb2fe9742d0b3e083e800386d8554b12b466172fff0c287ce0c46727715cb89001757bc7307ddfd26c391560f23eb77d122ae685fced9b98ff81b8e61114210664cc1827ae8f83c1d565801041bb1f956d596235d3e0c8155e712e6d152ee30b5067a9b8141bae4488f1084a83780967cd6d7ee0f1dec6526ee788e1ac03a7acc56e2a79ec030718f447d126e81b9a048a6f0f0613df69a3d2ba4123260bd0753b185cc09e897f1217e813fe3e67260c0f852f855e6a7d21bcc508662ebd1796886522245a2f4c4e69e2d305925a01ec1bcbd674a40865d80f4011c067093a22e9e7252db53f9038e909aedbe2007e57665a4168e25d0c50afd5259b8cd860c1a148bc6ca3c6d3148995b51d27ec16182621e240965257f25519ec469c66df177cb7cf335b64fbb3632885eb6aabe0a78ceb67e571b1c547dc6bfb4be350989f5337dbc75444e511def53d5a9ed4672261b992d7a0f5269217c5023eb532f8ebe20f1dd4887b421d2cb57729ba87af2885267251101f37f1965166ee47ddc6f1d81ffb02ae58b7cd1aa9299846d0642ed88d39089143be1563f6ce5322c048efb7b271ac55e60202a2065c819ea8bd162ff46aa3f4185bc4e315eb19bc062b4034501530b57b19ee7dc020c768dadcefa7e1f8403d063eeffdd8f202b542baea0471a8ebe87cf1fdb126ffcec18677444828816b73b83f2a9948615aa37bfa03965f09f1651153a932ea909acc73ad5d76dc3e1d1d578b4d82c51203fea578beb3c4c4c3da7bf124bd7fcc921885e2838a44efeb2a0fb7d84847f864d3f3208fc8c1da5fa1ff0cbf33e6932054eb32ebd2bd35ce16e9a3da893f9eaf112543b93a272079510f35f91308a135a76818be704e2b90f62affc0a7fbc0116a1baf87d004227c22c2b29ba3d32c966e68662040da8d55dad9dfbb69e05027764429d29764dbd1aaa893220b9533056b1ff4f0ac143a5dc994226d74fa95897f9e8010f31afa9be3b860785610f1570285da27730c47663ed223030e8978017e1b71b4756e6516c0cf511ffec39a8d765159beefec5c1ccc1106ad45a1c97ecc69a41542cbdbe01b0d919e99197ec0b38680fcfa02ef29eb3ad14670c405a6168c81d33c598018a12fab9ebb5de56e11731fa4b3e2b32bee880c6f61a14ad5d690097d86769e49727386591d269aa9dfa75ebb55b316c245069be84a77e650dfef9960c4095fe906ccff4e0d865e0f3381147189dbee4a5e4d28c202129e1b11509a7284ae8098c1df4e6ad4c70aadbde8b4f554e180dfba5b62c05bf2673020192ac1633de936d1930194bfc8db42ad4525b7a3c061241ed6a4bb831d7d87e91bae5d118ec8e4a372c41ee0050b6fa5a07f8fd98448c827fa9a386c485867f80f3903a6f6378ffe7305f8771155870fc81405dc02091f3b5b023dea231c79b6a520205b91024f0cf9079c360c45e3cb839ae4872377f6bee1eeaa84f110a71b0d905d713466d627bc1cdab4ccaf5ae4e1263dea84ad19274956f3f28c6aa29d5f00ecc4f3fce511a279acc0168796372563fb5fca132ce29b009db59ccb47cb4cffbe8ec96e0d5346515a3a353059ef0404c33cbf73adbef36ac76216cdebb2a8cc88b3e44d3077802badb50d506604591f94e4eb2b21b6590b88191368cad08cd431922022c1afc5dec0c7521d5b1ead9e9b92d40df0f828ca3357fee360916bbca27640739fed911b598f3a53440c8efe7361953e99ed0e12089b775f8d0346b401e0d502e546c18f9ec4d25f0c2ae97489166242c9e077362fcbb3464db05c922324cf0498589bb9764e49df2f01681c26917a14fd405918e0ab1fabc62fc1d26ad41ec30b6958a4bc974048b0dd2dace96798a0fa967e0bea200b13906df6d60a8b94cdcfc05213bdc620db04d6706fa0c345de785ee0e62ba6db5645616bfb06ce82bda11b5a11f3ca062bd9c9fe372ac5d31a6566a0027d58c7d791b0177bcff637f3449fcbb9487d5af0e54ea126acbc5d19f966f52f7d3caa520b5c1c9b3780019a45ecb93639fc7bdf0f6be997d2a8a04301cd92af3a6ee3f61316512ab54b8f0d10d87e428d430b5955adc5c4fadae4ced358d38a4c04408391a012a4508daaa9b3977dbfd0529ddd11c91e8720270f4892f58b4f66e6d3b953fafbfe6674799dc5286232ba1991b0969e8114a9398ee71bd15edee4d54ea46ce525a9cc1c2d25e2d4c29b073021bca386b1eba507705a2c627731bee458e4b457a32aae138e97697ab466e15b60f8d2f71bbd64f4580f4e628210a51b863c90ca935b180d397e0912bb10f457cb7c05ede8035e09915c5f06886372aa982a69db8d3f4f73287c452d258859dcc824a791789573fce8b71ae2709873d0bf36b66fbaa36154bf133bd65842aa38fd73e890d0831a4112d112f915e075d93bdc510677fcfa08fb821cb9c9c3abb107e37435b7181d3fb9e91e7b6d8520030effaefc764477e6d75d287336afe46c6911cb87d1b41d7947e1d293eae4c4c64779f5b7cc536d3202c3fbb9e3bf03e3e46352acf043ad8275489059958c56a86472fa8ce61a38f4dcdb8a1f9c56f1727b491888b0e27e43f5c944968956e88e9492da5bb0dd58bb0cffbb5dd860f9cfdd91ad94aaa1d1821dd73bbcc0cac8df78dc59d14cbdd52eab597ae5a3b5cd7db6b563aeeb5dae9e820ecdc69b6a41fd929251ef65c557c268123d1adc8df7123347406455dd3f9c0a09cee4bf20223017a8a5751e8de2045a7115b8720ec760c2390b1f881d15da3cc128cd5c6af5196d1b975a62e2efa53696609d0ce473da472dc569773e69180200f42ea01aa00e15361bb0f2e1b18f653a0b39189ab4c8649b5eb78c361518c331ae76140484d7ff86dc838883a4b5fdfe68c1af039287fe05998665409ad58eaa4c0e201ad4d45595fd1f288c58d6bbdbf8c9a1e58105d15635780a1ad84256b02e68a2e93663b758da1d59ed2f41143e8c3c7174e17eb33e11ccb4524f97bb10445ce8b67109219ae874f33c7655ee7e2d715b758809f1ec30ad0cd061419e84acc0bab0a381b9ddea8e81872076e23d8ce93ace76e4e5f58205a1c43f20980be4db2fc5f07343f0c4b71314bfa8a2732240024b80e0f003e895a91edc3310d35ee36b7d7d7ebb6a3590ed1d12c0da06389718b4b27aaf5b2d1881eb2796fb39408923ef9115419caa05feed5d920d55114517117c12eedcc0f423287b0dd5ac53831fa5567760511bee0f15614512954cee72b5b63f8e108ed5c2dd8e84ae22a70b591bf8276fc7148eb54973f968aec3d488f5802892f2bc5cabded4d8a607fc2cbc41dcc9e5177008bd1a0b81de0d5df4f2f6b3501ff841233e8ce37b641efc8a6758175c6cb915320f864ce1698c3ff1e1b8e1b11c6385a401d655b43e768f28532ea3a366399190c8b67c766a4e02192d534e526a1cb47c875e04f2146063b6dda89d8c5986f05d5b759d1f4c2eabc7919f2ee1c483df480981d3a4129a3adae7b2246011114f613c20fe7664a9c27255442378fc216d15ba5e24cd32f42bc1b902947480570131233754e2b61ca4364afd2672959d066626d1d25ce00a3d8a6313703f6451f488507b09874b7fc507dffbc4a9172500edef1c2fbff1c3afdaa5b5277c8efcbf3918cef8a252f1a5410cbd5556ca3bc002712ca3426a942a0edae55bda69d9f59cceacc879f2aa7ff256027f26b07b435f89ba7f429adfa2b45a0148dce1d2540afd0a092e2b5a911601cb3df1d78ca02568ae7a7e33849c12834822d4cdffaef2ce2a8e13a58cf14e9dbdab52d935b3f0265dc3d2e77d7966ea90424546c593870525b1be80121ddbc58ecf2409fb7555a1c98a9316a25a7b89e431452a6f2ba883bf462172da051e5071dfc556ea32b3b130a5e29737289ffe68b72df4dd4172622c94eedef2b271ae756b017a366d2c0552379e3c5d68aaca9045b09e8a7448cc7de10885b232bc10aa4fd0fc4631dd8460d2c6ddd641b680a28f1eb07285242ed4432a339f1243da2a8490ef62074057441af6907a750d5f6871cd93539e012ac1a3ac632d66efe3d04330940722e3201b3d7a3bc6d0443cffa42179d19622f4d4d4052ac34289c1517fcca25b3a9b6a4941d0dc4d9c922ce4a0f985bd762d9c71b2d769e8b69e1ea2d1b177fb78f7767374a6950286364865ace7330664187535679b17524abdf6d6caa79d0911568fca33e1973400e76ffdd931c7d77fbdbd9a48a63f2b1e0be27448591ba57ba63bb34a6f7ca77bd4fca8263ea9cb4d02618767492fa5ec3a1281ff9948767b6c956d4f77e7f60e22d66421599541153091b82d798c860a0a37b89fff61efcb25869bb2a5aa1fec15c0d0caeb589ed1c1b05671a4585363ae603421d6f5dcfbbf865b18242c7e280c63ae3635f785cfff9387ad002d598e329f3319fa2edb960e9f238a6e3c2be42f51dc5512db20c2ef9446dfb477095d5aafc1d418cc863a85264dd84d54ae0f67c89d638ad1c7d7f0304950364b60570330b2e9ffaa615557c9fd04bc45dcf51852c6cbf9976c896ce5b1bde764d07d901bf77fc3ce379af8409f4d5c498649a204f06557e0116bf62aa8e0d344d13aee5896f44a5671218f29a022c1ee4120232aef639c852f499baafdcd41563d1c41139216d7072ad8a70497a15dbede218ac172bc879699b0f0c44ea9e2b92c170e6ec56419eaf7d9f2b4158ab33233784c0673cb781487e719d9b786bc5b123ad4cfd88195f3998203a8d309b5ce5205dcb2dbc9c1625b4dc89aaac2deafd5549eb6c7e64269809b9ad1f642813f210b941239ffbf00f62881671f7479cef95a007992c79e00ff30fbe77f468ee2dcba3b93c087b60a09cd414f17060125105662f96588bd591b684dde2b48f61b6fc2a1e9a96ce5e7d668e0e102d55a60e1e7cf94ba7703c5642f5c2854537cec0a9c6e03e1baef05091ae4473249ce19bafc60b8d11b1dd250aedb3627c6c66e79353922330793ecda184a9787f526ee16f9020af98685c2f98863f847bae77d875091ec64e49460a9cf35b2040a00cd39922dcef3cc0782fa6f7bb547182512113385598058eec647153a0e90597d8ae2ba2cc71fca749385652614595b92719246cff94cc9cc70ca0bc38a0663808920f73007a4a7caf2fcd6f4dc31508ae37f0dbcc880bbebf0b0ad3e6284118d4f9dd0b5b05a76e932ffe5018c5c77abf797e7daa4c166a9b674b45bc4dfc02b8679f7f3edaf1e6820bb88db606b382b526286cae366fd6a2dc01562edd012d076455f98f1f46681a0ff0acd3a43eff761f66d8615b031048beb82b92e0a76d5357b8dec227534518badeebd08458f9f6c80e69d79bc57475d8cd47f9a70093fd791bb132dfd04842cccd9030527c06f390a54aaf10c3550b9de003471bf927b2aebd9c6b5d091e16e44a9231bf39aa3ed7ff9c0a6d16c8e447ca8bc5ab5dc718dc11e29fc575246a19bc41412f417e66d86f51da0c8c4a83b89e1a548b274d46631ff972538f6f17fc27f18ced355762bf58068a37bb41f84f752cbf7afee5d925d3dd59ad67492343bc2cdf25623a335453ca689ce9479bb46488f647d1d3442c851cb77cb60aeeeea637dfa2d6b1fa0ea6ddb74ebe68f17f966d588460a715b5d51fe99a57dfd2c921105696a08f82e9538fe8f2bcb3810f5f7c8e9cdb71b5057bb34c43276a2f7fb645bb3a59e1f05cfd149e43c783c5334fc67e6892f007aeb27d44a1e14102f725e1717e9876597a2cde136655f845caf776e30408b03c32dcd15f4b9a420c6530d28d05cf08a6f878ea3816f73af0de4c77ed22cd1c2951d33fb06a6ade7e097325388eea5d98e72ec24997c743ea11aec9d23b19353af4a4552399bbae0a0079f15325180f4c941652b2aacad6ee3af7a904a4f1aa59b5f37c892d3329d4ffbd65f520766ecebf779ff0e629cb7f88fd3b6705f5510976108ce8c53e9c0e56ac045f51737d16f0d15b81db32d2ecc91d547ce81c8d708e19ff31e8ed3858dd19610f4513d56a1373c4d391b2adc157f05ba6672d77c6a3e50b0322583092ca49adca4d30dba757aa6d6f59c2059b3c69fbefaf937864300f5554cbd4f338893398c44180f32eb728a5bf02ef9ffe9bb19752b4bbae6eedcbf022ed9399306b74dd347d6ad484fb3a87614a091683c04909e7d8f0231201b8b7cfbb61e9c66422116591143abc162a32ff17a207b16daa1179de3ec18921050b914ef707e848d9b25fa0349969d5aabf197a94b39316f40101dc56ab098a159739fa96aa7b517a0c75d0d1b1183ae2bf33ca7cc875932f98d99c716f7b8247392bb526eb6376470799c64933031b83a18b3fc14981a950bc3e53b66e81105a8d2ea0bb5bde6bcba7b6366383a8536b147b18a2a7cb2df64aa1820492730b229415815b135b598d0d950bb9c405a8dc39d2e774f651ca2979d2eaabc00ef0ed61344e410b777e2020f929f8e4a76be6dd9ed0ac20078a08faaa98b5cdcb5f0f91ce8cd4d905b86a2edc9b75dcf7cada2914c31fcd237df5f33226b66eb09c469dcb8ad55421d9e20a8e861850fd0d0bf4a762046a6ff526751a7bd81927532c1fd2e68587176d7ca5a3e922fa05df7dcfb2314961b704aa45c33d5eb817611431743653db5e757d609f05b66c733eb5071578e2b240e227789a8f036289e86a6b176f73c81f41398e963553367d541883c8258a59cfd169df27ea6c01a772fde7e7c419e50bb23ae54029caa29648d66654690e6d8b3353f5dcdbc647a9032f2d961a7b3b7e6c8795ddfd3f70105ce8986c8bdcc2b083810ea119176a156a756cadf8c93af9291ea99d5d2714506ab54e86fcb4d185ed542dc8d5b31fc26f3d50b21b38cf37deab37b159778fbecf3324f48fbb0adb4544180d3b78155c9404385e764f52994fb5bc25f63468f89dc3ecb68864f0116a65fdedefc540355f9f1a84901c9ba924bcfa3665798371d664f2fcc2696d96fd8d12cc149905044d69d801352f0e7e0178e659a05067f119f3f7ef28b1c4c25f41cd3eb915e0949376fa58a9818b059aaa59f72862869c0a5ed88b742d2b041e93423d26dc4068937c4e2adb86cb638fdb0fa0444625003e6a52f86e127781508cc409573e1350b34bc7b8791019decd0cc10e9b4a15e8ee900d541befa2974b44f4dae5c840e8a49d15af5de21b0728994fb553de73ff756d48b49f5e954514cde2e0db5bb091c2080331c4022831494bdb16c3970c56d21e804446213ee9204ca08998ea768248cb71a6f5ae36b7208bdd8eaa54a5749c0c7646f9c1c4e0ddfbf07f9e2f7a3f596cd4451426770de372937003e54893ceb600883aae99ccfa4b33768e229c9f4e67042271356e43fc2fc6d90e04761b25aed7ca15daa8496e73b963e21e44b0f0d9ac833821988eca2cf808429d53d3c4c57b76b69a12833cdd339767f2263d2f8332d05f4d0f1de076e50c39a300785717266440074cf38b70921da6f3fe4cb6403fcf586320145de6f2aef20a32ba65aff4906ae55929d86202ccc9750ca7eb8ee67144c12e8c0ed7bcfc7e7e6d45d56146cdc44b268350a309bdf9d75de46d85cd37fd8d20188e0ae851040836ae987720babd3e36210b71481cf05846965bc564aaa5b03588fb6c88e5ad8898a222a6acf4425ca83fc94d6cbcf57ae74353e25d3ec6c2e2a995e0ee924b870468f32392209e2a3f637f23fd84c757aebf142cc01848919da300ed0991b9be5fd8d78657c57e80fe12698dc7bb38df89579a1f0d9a518164189547340190f0983a71e79350ebc62e30592c24dd7e5d9e2f51da29380f07ed813a74b5dd3fb302ad54d46afb5510d6c0a0b44cf15ba13ef21e2a6493706b125fad629ceb707505a4aa031a1aaf383f7e0636e2b22221abbe1eee624f6e0d13f0517ea6ea08b490fcc31d3b00525c7a47377a711593b855e87fc7f2159e1ee4d700932774071d4b2bb0b9cf6dce530a74ada98","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
