<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cea7163f0e3bdc6a808ca3902a6f0ed4b70f1a69bc198157723ca8bec9c5a0c93c1ccda9605ce67b86fb2ee12590ae3cceca0e0ad2688d294c0f732f587faa0b9c01c01f01c3c99ead01fef65c9d2d06a0a10074583eb63898aa75591a2252989294048694c5cc5d13b489b0cf7352c0f6bc36edd57d9a36cbf41d33061b4cc99fc3da04dc0508d5039c059c5023243526a6faea062f7d57378d995c234d6a178ad58262a30ce01f3336acadcfd2a9191692dfb590eb2ecb82d9f01f1a255a056b5932bfc031dbee47533a348d5d792269f3d3560dffd25733e8345ff04d7e156138e4646f8cb0de17062c2dc5da6312d7b0c014c7ed669c751ed4d178a812b1eb8664295495571be0a0b950a7b630a2d16cb1e64cce64bacb3fb7c076f8a4d4a719fc45805966e04a56401e7c59b25cfdd19def25cda4cbb533faf860b86275f44b95720204ad0e6e6e76c0322d97f1c589ba40b96dac349262427ae3a4ed08af87aabf9e7cf7725f05407b5ceae0d7e5c268935f08eb2448cfc0a08972f717bf15970706ae8127d1edad5e9ccf900208b7f9b2e68a9eba823028d5d98b8d9f12e31f073402cc1e6f4f6f20b6522ce85a9c170bc26485cd4e786e07b196c56d9103f5dd4dc9b37880675db746d2bc4dde228380fa298bee0b675f64900c36fdf66f4dd7017fc6337861a113d5476e81ee3eb62665997d8a900b7b63811c2132301952cad6b2cf4c41b6fed2b031f232566c94acc73a9af1c7d66743bb76d07f793f8d1921af5dd68e58e7ee0fdb5c29f3c77ced00c2a51231e53e3a773964f691fbdff9f1db8406c953f08eb57b323c4dc5cc829a1442ea6aafe079ede2d13d0cda37d2b6dde407f569c005e1312233ff60aad0bf3bcdf624296ad17dde8c6f29cf0815cf8c7f9486c162b9355b5c03a53188297b2ac1910bf3f0bb4fecf61449ea4650f7f24d781946e494e83cac5c9402a1b1823819a074eaaeabbab55d4336e7741c2dbf5dbc18e853fbc6dc8e356917a9d339442c184687243a0bcbc5db512c3d0473dcf13f2a63396fec67ae537724fab5a9509e69d803cf4c04ae2978a998b43cca31226d0d25d78996f233149e9677e55cf64e5f120b7573c7d6371a1d9f6368d443974d9558a351c930e3495550a889685895ef0d906765ecf7f7416afab4071d5919f4a3e591ba1be41f07f40e8bdb29cc2c1bdae09c5509d8db14559d960fd613c576334f54a88693c631e6bd550c8930cf32e1a6756c2f9877b4f1e925026035fc630f9cc7bb3809288aa90831e5159ea1cc88bcfaa13f19e917a115427902579dd408685761db6d410a780860d0db3c8f09eac84a934369b4d3051c2e693a78316d4d2c41937a51301587d9bbb355c8bdb500e16e49c85f6fe5c08e19ce624bd35f6ae921981c0355e4c9d9631c4cf63977f90889dcbcb0aa7048ab175cbf62636ccd62748330681eb9be1e2f4e4014459a37a0af0bff41f3f57cc67865c280986f2f21a67a656935bbccf5e4282f8e932710edd64b9f87a238ca3143259c73a4e61db07f11737a23c0a9e18c847708bb6dd69b2c315881ee4932d03630a540f2da5b04d6a5988829c6e9b524650e6b1dd0ea39fc45f5602ba7f834489531a5a829b0f5d59fb6d95fb9ccef618b2ff96a01d79341b242473f8e5a52fb31ab32032382570760bb7b5c254388ec0a66fcbabfb452a6b6343e72e53753090a20b4061506c381efc9a6ca011f5dbc7216224d514e984f7a2fce6cd36c1b07a2cafa35c3675102415374cd50365bec956c0f3fa2849e7675f89a039315d692aa41b730ab0daa9bf7a8879b7c7a7d959d0e6f7264fdbe5dca5d14eebf34f6a8fa69762b5dcc22ec0d84bc14c8a9d8be133a4be6d4161c9fee7c20fc662c864adb38b6cf7d0d671a70a900df9d0b125cbcf8814fc2a363154362c140fe7145a1490a0fc04a0996a28e432ffbdc88e9af5071a3f8d66946efe3860b2f71ae2042388084e8e5ac8c84ced4e71ad9845a84c29ef85511eba684a00d43fe522c3eed1d5e743473ee75d2b346ea266dbd82a692f0f12c56642623420677d9e214676b894c29b809955419dc9485073355048ab873d6d84adff2211702a6760be0c22c80741d83743ff633557d8430ce0214264d49cf48a9435b7b4b8acc7f23a4dcb22ddf083cdbc91d691b6a16e0779e97b33a78a72d2207e0b1b2a3a4310a00e96b3c98f79ca3be8637433f6e5b23409745b0e3a5ac33752fbbaa7248d4a0e0340824b00b7596f192b978d54a800df1cd35c6170bd32631c1f34caef247ba641a2ec0ad3af9b2ab04814a68ee4c14a33094219011c110e2a684a7a9ba442d99778ceb1c0b00339868969c321ef00758d8c7e089a782329bff35a82df8a562f69c1511733b9a7840b3bbefaeafab1bf17cd4d84625507acd7a637c03efd610912f9b87be121a401efd33e8fa56c2be436e3fe58d6e4fd62ef5933f5ec46db6c5f651c8d2f0ed4d1a8b135380645a68596bd67b673335c846a1b1c75e6cc506187182263e2aef058bcbb0b66540f3e5b3b4a6540ca8d17e6c33ac9566fe26ea944c5567cdb7589275b2f20c53fba2b68730f10755041a8104ec384ad056ed8b35a550f1e97c98a9ce82db069b83a8753ac460a37a2c892f8d6db846f64bede4adef8b2414adf757d19cebb4c7976661dd42d2bc32de954a1f1069c87b7dfced8f47c30a604020a76c64d66cea8fa56741833a7e26f724555c4784beed09a75e60d4f4eb1b85be037b6526600a3b50645392d63768a69bf03cf8bfa2fbe07ec3d2971d7ba85dc977d8e8b8b72e501c3c6f91f92b51a035b9a080bcd4b4453aa4a744b82c942611246f666e8238e28eb738186233c995c8adb820a64d89162d01f059e6ecc64c2a30cd2d7de112e6240bdf470c4935d7b6799a04bf0d0e4bc77e8fed13ff0d9fc7a9d011322cfbf7ee3430e60a7c0c0525b9d3b3fc7d690d254a8142a52ded2ecc7d9b8b9c83602b9b3b6d0cc5ac9f8a7450a399a6a9a45eafa337ac96f8d1438840191337c110712e90657a8b73b67a881af221540cdcd322074dc8fe6e74e084942ce9ba21ccab90315b4da87d0e6a23cca5fabc13f7edfaccf7c340d6e9f99c8e2e70aeb675479a66ca5fa8acad0f97b1102b4bcf2f93eceee60f4490a377f584adad0cf44a3e02d3de81ce05f816444653ec48c76ac0911aa15b0f643d06556f1dadbe26b34488b5a0e931b69bdafda6be34114c466505bcf60356f26d19c7bdd8dd2435c54464b5b6c9bc3afa857ce2c100c8eddb71cec9f7edde6eb8023917e3350c1412df23d6b15ac4ff16c7c175a88e499a654a476d3a2ef4efe7b9fef26a2ccd783fd608618927c7d08224df50c514afd729e43232fcca25c397dcfa9d150a0a852bfa10d83a1ec79055a3587e5b02ac36daa08bcb45fe5a6e471daa970766f51d935ea0bc8377442100078bab8f69c52ad30719615b9feea22db963cef8a40ade244746caf5a0ef1b22728bdeaae556ed996eb3632d9d6c24125e150ff5482a30445966f7a6bb173257173fa4fe7ab94be5197ed74fb07439715310a7861b8afd7196939aa5c5fe9ad6f038dfe943cbc037d8389e56e0bf77e4014c219bbfc3508b8bb897665cb9020231f38b03d69e9cebda5b427f0accbce5d5fc527838f0c1dd9efb616de302d0e802ba00c9ecac41c5a40aadba09b70ddca834bbe16f233a5b8780939928be1039b5e41d1ea8919767c0b85ac7d6ea347fec1b024d74bb7f7c34e3ce6e30618afe746f405df69002f983cc24100aa2008136d30d839679f491f7bf45f3b5eaad9d8a8282eccfb90aa38c94adddbe16a66187a3516f50de159b33ab6410502a452c2ca75f966e1d5070b7f8ab6a230f1d81fcc59e2613d613edccae2eb27551d689a81e073f274361662a841eef7bc9c63d3e22f003d901603cf5f34abe5ef23cebea1e508909487db37ace53ed85cbdd51807a14e4949acbc64b497b7f7cacd08a000dda2bf5fddb5041f09e24ed49b6288e8bc7755836ac2bf76d6fcae26cb06e82e8b33f88471d7b57fbf25ba85e84485294705d63efe6fa0c0c6e34677d6e82e28ddb803aa7d76870ef13e5c60ee3fcc9d040030a06cb1a4dd0eef1932d85189d9a9a1938f6e1f5a4c41aa4be8a79797c9a029f7ebd908553f3eb2411cffefe5fc66ce2138032769ac52aefb2f443a98e1302f718686190743d8e39f01f0d9f07b6c078e3837d40d3516dccd73922ce02bfabf2db726df4afee5ceea7367590ef0977e1329d08e2497ded70ddeef7e434995825d494969cc373e0768380342e48a87403799ecdef5420b7ba80df43d44199b666f29f460c094ada264727bd4b75c194bc26210bc74380053cfa1e6ce66abb56796cb32e466c4e2b7056d5fc2f57c084bdffd2d1110cfd2f7300d4aff5985709582d1e97bec1c00818c45b781b2f2c48c49598266de2d53a26b1b158afaccc558e395a87f46d44bbd71d1435d566803dc506066e8ee75c42a23b2c55e3eb7ed34efe7fc31a3ba0e40de172e7c0297c5655513b366bffeb0127f37e384e66aab9a871aec35b37354e5a1250d066a3b05bdb4566a720091867a4b9f8c14dce654baf4c9f5ebb0fc4c05988c700c8bbaf1931f1dfe35406b1b5c63d12814ab6fb941ac8f7ec6ed4b4cd3a5d44f6b09432878ef6e509fb186af50f04d8437ffe2e501c1b4c6cf392331a4a91a6fed35fdf4e01b97868f9da6fffb0a889e231cd39b5d545f31f07bf1adca5788b7d22f53daf9ebb3d357f8bc0b3132306fe710605e6455f105d58c2cdca07035228c6c2c77625615f50cd169326db8904a500627a87b9efed8f4276425011d029e8da46b1f03c68c0fe659218d3e3610df90f85071d31a3db8b0e030d45fc6ac30fd8e73f70e9364e89c0d9d17cd1940e6b115951efa6dc78229d22628ac30597a9c185481dc41bbc4ce324640c56f69c07f641427ab820be89d6fdad12b0e4531a53a653d439d5f957e0734ebbf1e38e48c6af8e5a4a3dc07b2dc7302d3e9dc41db43883d82b7c0e7894faaa6d537f437f00ac7e56434572428c7133ef14b7f0bccf902430a528ce10c59e4c5fbb2aaa256e821f130ce66619c875deab5def9530dcd873a7636b02696f463eea29377ea638bb542cf9728a70476a2f7b976c6913351df77c3b5ce043e0eac01663b767d5aaa90156511e13317d6e6695a1f3fd8a89bf39d690193388c140282a2876312b8ef6c23c0dfb184ddd3f34d7b651d366bd6a35e09243444476dab26d99861ea6a0dc4b48303e362e84adbab26aff2fb61c2b3775081c7a794395ab1066d32f35eba40daa3867ca5443b80a4f98f25a6c6c573fcdd3337469ed2915a0f446be530bb35b3bdec6f566173a43f162614211fa55bc929ee4f4c770a1afbe6cf4be3613303fb58496b67fe27efb39cdc9d60b1ebd51a9b7c425c40792a95e0fb465dd8288727f0d3160d683592cc22c41f610dd7c43ea35e2ccf996e69234adeca3a768288ac7f566858534718519758dd53adb79926c7d87cf9ade7ad8cb492a2443d86da813f29a7eb84cbfb002670f2cf300bfee74cf1f2b9b3b216b0d3fa3f36764a42ee85ff2f885625092f5a3b88fc6f5b19b65687b4d85f24a6d9bd6006fe3e58bf43390eef6f83604f1ed5b9b68f587d02369bf72708783aaee3e77051bf184e83419591656780d8b68bc2caf37c306041b6ac8172faba21f10807330a7bac203758ca48520b16415139b30e4d1a9d3b7871ba1f56db635f9ca9ee64621fe9ef00f1cdc30a20f978b9ea7395bb141840148e1ce3ded72ad71e77521ce33ce435b6cd0ccf2427318e00eb3ad38c19787d7c8948e7649a49c522a083aa559d46a8091164804af6f5fbf4aea0af25edc8fe155111878d8c2d2708323ebf158512cff0ec9fafd35dfbcc53666a574367aff9dbdfe35dc0c55eed4ae86158da24c476618a25e4e546a791c2939000ba1c3a14de6c7e04d8bbddd1a1a44f8722ba5d82d8e71290337516694db943ccfe989398e8f0c5a7576418fcbe56f71f5419a0c65d4e19dcb3dc3f3edf3fa1fa5c24b4eade5f74f2b344fd7d1e4c25b63bc61eb1dc0e3652adc056e1a840bbe68baf84efe62d6e7847ebcce50f9853053466ffed0986009f5eaab7fbfb69c91f9ea3bdb379b9bd60e9ace3b9618e7b0bff319a16f4559efdb8c0f51ef0b6e5ce4448c310d7fb948068efa1442c7ecb473290f81fc0e9874c5bae52d6e521e8969bd0c2e7640ac73cd0dd4d43b5ec3e8b67b91100fdb337d26561d42bc333c99fb0851e787eabf8a9d32b339303ce7a588598c0af76416c0acb7459ec907efa3ca078f0e5ff4821939828cfff2d253095a071ef6a0bf726f270afc8f11fe7dce5867d8a4f9d9ce9e04a2987b3b4975668e1a823f2e46e6472abea330d2f9c021aa2c7c06bcfd1e1234635d52ea901ee0f1746bf961219e56815949fe601cc936922c9b924ea9deca99633ff00c874caa7464650e47b268a9e50c2b3cca686068dc25b8b6bcdc1747d69fd83167c774da9387551e2cd56a657ce5dc0b3a3c3e1b16b68049f7359e978c8b64b82514e6b512bb06a5e93cb7862e04b2447452885786fd7d0ff365901848683f1657f2dc7f5fb5319be6d12d07cd4659ed5631c9277abde667944eb40a6cb1955aa35b8a2cacefb1a5b3dbc956d1bf1ce5299f544489c8d72ac78bd473c160d658dd5aaf9ea98d9ff2a41b77c90f92e45a1a4e37baf7c13a46495feabd2ccbd164b57b82f02a151f6c368be5f3945cf690b4f4c2be95f610410ea169455c1f804679d0c0ab9a280747f0de9a683f27f5c9ceabecf52ab222513851b1f6585f1f1a8aa554","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
