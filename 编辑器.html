<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0311eaf411394992509b6a672a8f16883d0f88126d8848e5e9e4f9ed69d4357700cb2ecb1f735db5ea9ce71129169effe1e951914951efcc266bf4bece79f9889a471e6ac9da2e3f7de71085c6186b918b7b9dc322c79ba7ebf006cfdd6c3ab7cfe74eb77de536d15b13f29f4236bb0d82a59def5d36e5d6d88df4c3617ff3f8e3b1dde3bed888d65fa87a5592fc31e811b5158fb83edf17e68c334b7faa8642d81d501a7be2aa1f9b0dc3fbd615d52ecdbc59a5e6844e2b3eff3ff58caf8cee78d49764b07f6ba3857205d94fa4d5813c7a98d8573c1726bfbb52656c7d4adca72e5a7d48eea3fc953a81d52eaa0f8cd3176aaffa93db22a2a8008c82f9f04fa4513d441aab2ae484ec39091ede0b43715c55bb5ecc12e8d2633af8c1378b5a749147028bce3541da93ba304c6a227e61a5b4391285e2ef836f12892c0a51ec24301772eec0af4311040eda3d4bd368a1345137d8bef38aaed1957ab8fbeaeac7e57e62ec30e1234f96edcf2d4d3bb7f74825c971d2acf8ba850af98c101c483891d9567abee834672c4c482250a02a5cb9c70354f7d902d0c07a26dce90d28d40debd278218dc07da23285d3e1bdf60dec0a7e2e93ec206fc806bdaf3e13b7d16b6ab99b90d6f90c36200fb8d72836a5041aa730d90780e8c6dcc984026112a5c77faed35da11b4cc16bb0997c3c6f2209e17dbfe1c10d83489cb27484da4fdc4f9aa69f0c695569620c8c50c9ef45921e525c4276e542aa6907bc7457214bd1175a2905f85820a7ab5ba3300da57f0cbf2939d7e4508d0d10b40747042fa50bc305dd81d3ef110b4565fe4df641b3eeaf4f4b11612d3b28cd3a8eced6cf9df310578258e63b10c7259daf918ae0eded4b2bed922e9f4e6f46c06f6cf2d3169b408861ca197a202a70bbb2cdf23a7788e53cfe2e04219ba0c551ce0c378d1f076982871987ba42a53b1e5748afc2e91f1442ecda6d6d5d1c29f28204f45f0387c1b732809f570d282eee4559c182d66199a5bf772195577baef7cdb3ac4f912bbbf5df45c1dab3b91b9f2bd5b3a252e19bf7277f09a8adbfb4926a0e81f8da3333cfdc9f528eedc4caee4c400ad32ba3b9b927547fac7e58c7b4e01d04a6ae37a0b3926d997dcbcdbe96a243cd0c597678b7803b8c2c03e0c34dcc273259c2a5feaf03990b7c5a0f5fc4a25363b8bd1f71972c3c8550d85725e0a56dfcff4abbb898a5f49c3fcab44c97549b833cabf60e70f1dce00f7925fe2f1ee08d502c69a5a692cd2b4b0550e2bddc0c87b07c5275036dafe050f9e1383d9ca919da554e12c44a5ba5c408d853101c5bf799512901b8ecc851c10bc1f122f4fb50c7542fff85759a478c16156e1a8c75c1df5b7d9e256cb05d384f4db5c8a6a919a46569de53f296a1a5b2eb1980ea6cf2096b03aedefc109043d4a04ec64e5f94d98ee28a7d3fd42149ff6086f5562a794c11528fa6c50a97271da684d2c4f4b4c0e49c321ec7e2f1de978970e59d85b197ea339760efd2f9a9fa9ba5a25f4a570feb13a7cbaaf99b7bb44b392bc91ca0dfb27326d949d348b2a85a647604a9a1e93d869fd940e729978e86cc6be683bbb204a93f048d53fde543c49bd67dd521cc6d3d674a04091aaf1c8ea252f2801eff22af4139666ed3e12e290bd14c133b6ad6e6abc6fab92f7eba41dd4aab1ade770764d328eb3eb4fbecb3f5d522594f1543b10acf8db0403d29f259f147c470b939e5dbab3d87fbf8d394eca199f41abe51b1ab8024633bec7531281dfe5e672b84a81b9e4bc24d5676d5502fe705280287502afe29011a50df0b65d43a2613ef552f0f5a25a7c2d211ea1d06f8bcc7257b9cbea1db0d1d60d30fe29b5ca498bd8f76379661139d27b7264fe9cec0aa547af0e41dd63678425f6fa87134d7b7506ebf201173363b9a2f912c94a9b9db45d2094b0b4db4faca898fecb2721d7f7af9eee83425e9c70da7b3a7a49cb296e5ac20f88126ffe9e42efe3792f290007a92bd7c6617265c07356238352a64122209bd8454c8e0b507e10b230f7aad91484060bdf9dfd3153ca433052cc4baa790196e2dfc30dd53afefe6139afcd3886549c0fffe2e07b9cb4fb4f4b9152e27473dd687e4609a4a1c852c5fd3f694391daf1217354b4397e5b4b7e030f4328f1e73de9085a7220c467dcca235d82eaf089b3698473bf352c76dc03f86ca57799ae389f65d53bbbc5295a15614be0ebeca803b106b4fcf3f2df5e7d8577bdd28a50ebe80c460c63afc32c018bd98864e89260b4031802f9b9b0ef2fd3e795a26bae83d144fd48095d62ed7fe7283de04323d406d95c669c5c1c67a04046343dcc80d6fe5bf930cf20630ff7179f407c5f95d923ecb68ea99ae821d273f54616b21c37b9e01e7726abebfaba8cce0983e6b5af914d932cd5a8ba655640aab0417349ee3efc18f15941c444a7f225a059da172abbc46b1f3c46fa3a7968ec0b401653315611e9530a80a5d9e5550917cd3d3c08646e7d33b1ce26a692b1a24d72d17eeff9f31878d7d5aa8a83df64d72b54009c86bd6109081def97730d0c671b4af919ad4febc9185a713d0f5f79ded207f57fca6de30c63041d0f1fbc3b3ff961dd760a11c64e5e986afa6aa9fd63f137b5a3cb6a7f8fe1236daa9b3aeb7324b1d2976f1ec300faa83d661b44f4291a32ede09108e440310d4920fe7377394d14dcf4ab3660b31f3eeeb43a9e8cbc788c60a1da01c267122e8601ab88321144f4f1340235a38a1077c3408b4f67d85c826d3f14b69e0197c27c13cb7b8b0bb3a6c26b21177e1fff1aa023aaf2b79c618c26f7f2e54c4f56525839e5abb5f3f15a363cbd27949602eb9317d5ab78b91a7d137f178bb661a4353ad5a1d987671b7861239cd1eb7463613ab674e2e656dd28aa1d1cb8007beef455df3d91e4c89698974c5bb509d9ec439db38c7e5108aa8967a2e78a7eb8f9345711515cb307db20b0b7d6f8872d35302406750bfe8f8bdc3874fbcda465c0ced47553f12994787ba62d8bba660f4ee2460a51fefa4a49887b2674c643b1d80945d23d4afad48180f1c8c07d3c06ace48c3d7e4f54ba4ddfb5b4f600c2609dd22671e3d3ce894b17b807eb30d7fde6dcb6047a52bf26722d8823423f169c9088a783a85a81f1d36ea6f51270b53ee6a4231de7b609849edb80caeb03164354708c96250808c80d3b2cf0d984d92d8e50121d20cfe4bdd30b0f2b1cf121d3d65a18d6b08f5081bdacd08505d357cb440f07cc8e8e24b66b3c56ed88a2bd4866eb24c3bbfc35fa3e0531e09ac7c9bcff84eae2005a9f7693c55ac9832d9964d2862818bd3cfd9b4e4592ca797b258532424bcd2dfb3a8bfc1b414fa27a9883241b384c6a35648ef55163bf10e3403e766b56fbe9b3f9ea72ff27b20916665ba27d96066e1ee0ffe039a434272c2ad3897b73cc17b3e59c8d533ac3a134d621aa8cb52445c4a6a117ec963270ea6812fe5a0699eb8286dacc880f859c27bd19ab4f52539a916e5228204574728ddfe080fff34bfabe701d0a108e06c8cdf7dc85cd31e7993cdc07303c166851d5d22a1d6e36bac0edc54141c73fc8596469331b62fabead476dea34804fa8610c9ffe953c8e05a2cec578d9c3511dc6b712f1dec0d12b809ff490d5aa35fe6e1b359e62ddefcd9f1631e30b0c13139c14d9080b7dfb25e6df8f7bb8d5c3e06b78dc5bbf7d4b8861aec2047b0724e51c17cd3ec0d733a1692d39a78c9736c63b1b27a07e5b44903566a8e7c4a76f70776cc7b038396a10dd6101ab0c06322d461bf539c73503fa7e2bc88506f139761c1e223e98be048e67ecc706437eb460fb77bb5f538954b75b7aabd7f98734e26a6212fdd15bb87171f2406ff1a515bee345dfb1125fb4f2c3a01a4560dbd6b23496ea36e77fee74ef8418d78ae3328a3865d26042675b5e6ee55236fb89b036036c5151a56edab6757bdad7ff38318493be92a8646b75a2bfc0bec8dcc80e9365c9fc7828f21379c618b416a94c904c35231f1ea7b658acec15930e8e91c578cc305288ec401403e022e14777d568a0d6e1337d39512f034dbd50a19fd0da7730ea190602dc479cd2d57b244fb6640f2f6fba942d40aa30c0b772b401e3d307aef74898a063a74a7dd4e75cf861cf33a16a09b3dbc71d7d01e114777353a517a64384679a5e5338437e9845bf543b64b89d274e5f97a02c4ae8ea3e7c85c18e2f5ee09feb2d829e02a89b741fb4bfc9793e5ab57a38e5661ad8421b98546765142ddd76f79cef1f053ad33f5f71e9bee3bcf72023165e25ae144fb7f23a635249e086161070b061236fe5b6725454a62628adf34b2521cadf3d1d3a2ce4516ffd3c3c568e4f9ac86c028a9ad60671461c5732035497d13fe8100580b40fa5289487a4aedb996e8f992c4970c40376f35addc6974b899c2141007c5654ac6443fe34f300ae2d56869b811c3c67efdb3631dbb84ca8270211431e26498a790fc6efc728b05cb04ed613d93891f95f692f7a83f03dd0f9ac0de73e30de8bc984f050ab56e4aa66baec0aeccbe599f769d37a910d0700cd638bbba9676ae64cbaa24c5e175a0dd9a9f167c45731505aedd6484550fd752ecc225d8e44bbcce741abecab3c4bb1eae997836555483505bbe399154b3f5ff0682a41c25ea9b15992436721a08028ccb821d937d637b593bcdf457bdc280f8ee5cdd95ded0b4553830690ff5e7e0c8048f5cba68a8075361faea4c0afaf60c3943969234cb0bf68b1fa1c99f6224f37a48039beebf147983c2576bc9dcf55dcd27a7d8beb6c0feaee3d32218ce5428b6e1268668a554bac87bdf4685c2603d4fcd202b77b07a2fba64fe9b7e4a492a774511d0b84abe023ef5d596e390c48df184099779749471b60062fa6ddf9111d966da1d8b1984733fc0eea1a0e0d2653b68d3b4819cc79dbc5ba6e8288a2ed938e30308a8a59363ef5724ef85851c58d5af731a0dd7f52851e91d333e3831cb249520b305a952b55605328fa2634cecd7d650e942a13a86399fb93de49a20cfbbc2be9ee68c9784ceb1862a5450fcf377e0ffee0a32ac199d1428dffc3220c0cf91392fcda70e5550eab038305198dfb4b2c4b87230f4c1c295f0efce07ca6ce2da772f0c75807d9f4c4b580fe408720914b7e0649e5390bff19edc1e3cd4583f69312cf8fab5460bdfd744e9dcc00b5c8c9a3131ef99441c21279a5b85557401469de8cc7b0c9242e5c5b19082c5b01c4dcba29242113b0f1bd34363fbb6d481f4ab86288e330a0aa0a2b41793640294b67c820b5a10b978ae04f6ae7ae680fd53f553e4f5aa8c8f5f416f417467542b3c20f179853f0ae2c5ab118e301ed916d4ee4e34d5fb693c5275033ee7713ff97e0979b0c22c756b26e76518e722c816502907831a8ee231f35920ba8f81e9e5b9870cfd696ed7d7541d891d3950abf88ec58ceef3e8d9256e44507c5bab8dacd8701680aeb3bfadd39663220754cfaab0ad8ec4da907e1b36112c5d82206755de5bbc1400bfed44b5650f2270a97f7e7c5513a483972bd7d52c2318488eebac84a39561aacec09e847cb7d00c273d2fe5dbd7fcb49275bd49c82d50a4f54c18b1153d5e4a6ed86355187ecf123eeb0e02fe0532950fc1246afb79c2776d9f258299e63751a457c1b6e653a419357cc6e6c98ad07fd59d6d9edb0a1ef22c2dd2e5e620031f03300cc932a1ebbdc7760f7313820211c6882899373b1f976f45ce271086928709ae8edb7e3432cb06a31ea446a7e95db776bc4c20f6a02359bcc7479a2c573de459df963c7479f92f22530e7f6abef3a341dbe7e3f59b30883658cc0a030fe88c1285614d4e60d866accaffe4c2415ac406ee34cd9bf9e43ab35825a28316eb98dd2746cf0df89a116cf3695546fe12067286fe3b89629098181b199725723c7e8dd37bc6e25be9b01165d264192c375fc3d7a1bc6a0c9a228cb2b2edf17d25a54d7ab9bb77c864e241af56580251268413bce75d23341b3970ed9ff632e84647c15c04c95787afb906cd7a672d46f5a11bfef01f36c2b58d30cfe57ad4b677408870be606392795d57a31d3924f6cecd0bb53d59a990554ac7fdd2b4cad24e08130be954b9cfa3e84fe0001c768082f1c3e4de5b29102f2cbf12a7557bd30f1a487dbb468a012b3ad94139426deea8bdfdfa8cfd7cfa3c47201f5f83d1d9a4e9fc78caac7f7b4314705366c8f058f84b12b6a24d39fc23bca969f2069ef05a7e1436be946ec6f8f2feb0a0ec7f72408727349a25171da77a2056459b99008918873a3772417cb286974570a5f59046d05ae94191a554a0d39abe6197607785f6666ab2049f0ac39b3426de9419063602087130c757f270b5d7037b6658013883bb75563195da06f77025627f4ad4180aad85d7658d4dd0689b468495cdad95ccdd7ee934da896697932827bcd7d8d3a8ba551d7b5ae8be1b649394906b2c2262119cef53b7b69e034f4f7cda294803ae469b6ced91d59eae07e6a39e2927fd1ea1ac3de3b320e5aa3658d1a4e772269b1b2094f7c1cc3d49ec9e815d11ac8abe003a0eb009372e5efaa25bd9c98e8bf5310adf035836e905ba0904b18f387cbe4610fab58bcc58aae744b030601c8d897d5f4e1ad4b8018e2581aaa7b498b3dedcf59fdd7a8533ae5619760f0698ecad6df4d7d415fd7d49d67ee47a4f6dc3bbd3aadb1bd11d5dcfa4d39fddd1f32cf9b97d313bdfcb598dadd6dfb97214bb741b296ba1b6eaefe36fc1c34db49a43e2146cdbdb1912a5a37f9ad1ec7f975d957acaefe3c05dc6fcaa823c0a77b10a1c18ee7fc2b87d2b52db2aecea73cd20c741ff3ad7e1a9547162ab6184853fc2044ba2d12feaf6a0accdc05c6577737a97df7093ef94c0ce97d76046bff9d10a52a5634a476ab66e9c88d388cf6c7e0ea55d781de7f0b6978d1ad0a7d540f5990cd59fb84c28475a2953ce7432d8d7f2131828aa59b45b640df579c993301f544efd9718f0a6fd83c330b547d02103b9b898abc52eb9eb060fa7ff076a1bf184fb58b5ed4ce4790ad1a9763de4cbdc8e46462bc26446926bb941de4681701c007a01ecefb414615dc5eb657a163b8bbced3257727f19857254db442ed4f094b987db89af5c5fe41bdfe845a51c2a52466b033aa68a7e7668c41a563c3fa3f1e6efb7049dd56dd30cb6f8921ca15d7540d763e6eca1f9fd57191843853a5a8f3c8abbe87859be0f4c624628fc5e02726ad021bce4f8d500b1a8147265779d52ba804c496537419b0d4514f8c20af73ea81ec8d6345928267e623b8c5808edc994a0a1b977581c1c769f8d21b09e65cb5cb1ff40ad0e6c344633f0901c4c60d604e1ff492cd1a660f44648d284506d7f77a93d16d609fda7dcd3fc330491716bc66981a2f4cbd1333e98cb56f99b74778db0fbb2987337de85fab5faa5378cb6d38d9ea737e37512557dce9702f1c3a97b8857f4fc9e2d679ee148d0bf7a00eeee2a0ae5424c8ba25feb81942f053e5fada7af616b1705808aa55cdd14dbd581066b613b7f29a19da87654364845e950049130826d5d1676107ae87339568330f150589c348f7af995419539b06da85ef364248ef339b2dca88dca2510d8aa66b5c33af044ca2d2ae46a40c4b9e8c1b7993b977ba07603bdcbdd7e15f6316401950c74d524a81e13236ea0bf7f46ccaed5957f153243c5b7fd33c116d010872fe33e616f6eef2130fbbe48a0667bf10e1c9442b8e3a8da283fe0a483c9a85576b8890946a3d97a513e408fc8d72d11fdfda5fbefb45578d0da0088aa9ffe2abea9039c4dc1106ad987a931e612bf278bf80d87d4cd0c45b1f139ec235121950de723d52fec36d748668b96a3253181458a711d0589984951bc502d10e2215b6b7367be7e37a7892628d11cf37edf56c088bd4c3e8dac73fcabecf0be59b355d0a6de496687a6ddbcbec625c2cdcb187b1247fc1fc73cae2e99ceb78894e695f9e3d8fffa6236912931ab31b567edacd3bf8404f4dbf5d2c3ed850d7ce88f23db12e455a1df1f5f9edc3623ec2253570b0fb766f2cdb01d15e2b6ed4ea1449c2a237a2f1813256fa205614976748659c75baa2c2b2e2a1c2b7f37c83fc3e2014dbe62d4f325db65e90d3f6466286ce6a505c0c85474c51d6cc1f54c00ad1e8df1ed7e53848b1eb3cf4fd31ebd6cf4a2fcdb36cd003392d3aae02b7dc7bd9d32ce3ec8dc48381c6b8c1e4bc27e9f2aede99bc113475f316576e16a37b8374db7007b0ed8cd3fcf6b2b8a1843bb76b7867e32eeaab070fbd9aaed88a612f5d87aa017fc8feeb806d39cf979f5dba01358e166df90c38949091c1950a8229c3e2540b342611c370b8715ce72c7252bec437334f245d9dec10687d233ab399750fc6e0de32dfad4c52d3b80d3826e2e4e3af17a2869251ab225cf8276ddae1df896ea165391029f825134eeb39222907f9fb9f1d0909c8801a9f06a844b9511ff7b8f00291d1b4d52e4918aaaa293801a36ce6fd16dafb57f9c70b7f5ce19ae37b3b6f5f2896404e759ffeec61f201d9d2e404610394395237ad289a5802f23352c4e5c181c1acfe36eeef868740dc64e1797ed12fcd60a260a0f9dedaa220e63f9ea9f47fbb9d0a6a1e77307edb4942173bf125ffb29ae98175906c3536e07eed6da2b16e0803ee56cd6f2183e2d0eb97889f1cbf6e18691a1c1de0ba699899d9f9be39de8921ce77de4dfee268c0f8247587c0196053fc1c2ea5f7956b95185a71cf60fe997c0e7b4fdebfde8b70a2f561f94c38b0903dc62112e387a342ad0ca58e1c556524c51ae4f08d11eaee6750c26236b02f71770ca7fcc09d92fd4ed95d6e70d4047534655cd14ff8c874a954c7eb3206d59b33351deb4031f4e6ea6cd813a96c21192e9fd53ad560dc408c15c974660fba29f76cd746f2038f4d2286e6b5d65273cd3792980bd5e0356ce89c9f5decb3197a1a2e84020a46188f77a3abe6b4880b245a4cc79e340cc59c9140cfdc8758bdb7be2ea54a186a4a4685f590b421616ab11f563644fbc1795181a147c9ce977d544cdb0f3119047ca19cb18c22e7bdaa006728a7dd842dfa491ee73a7f36a289d984708a561c283527f0afb50a57106619d67182a206b58c214612e560612e6cd16bf62adf9a261fce6e4cfcc8311ac4eb19d9e9de3f24fc4e267f903175474e1f8428a1c6f13483ba017496a74b676b74eb921456639cb73dd6ae36e2a4a800e00fa1173c0824b44a02489d3b29040351ec3d6290bbe97493630a7e2443a59cab1f9e95266239c3ff9565c6c31ad6ce2d9f76a3d39d57ee978df8995664084af228f4ca3458fec3b0c0850f47a3d1f5c6bdeb53592788273e6eb5584030be698335183f0aca484a577a7265ed2ecea9076509bd0e6475e247949faba20966ac6bb140092ade4e799fc6eeeeab7eee711cf4fcc17a9e9bdb987afb9765c49e5e66808499f4934a98b6024842fd54708cba18ff535b6576dbc467ffa2c39204662ae056319dc8aea1bcf0808d0436cf7a1adae8fbea832f390289082ce88e80c442ee2dbdea85e7c3c1a013c8c06f5443a501c435d8ad2a6c0b95d5d7d7c46976a7370848538a00d0e15d54c783bc916006df56bbf31e7075b69be8b6b49d9757e6d0b1d435f55cbde071d6690e8ca4f48919ad0a36b2f74ff16a68b1dc1805288ebfc84ce386ef6a0f6fd020c5dc035d0cbc2f0215410f46c2ccb34bdcfe4bf4c3ad3756b53b7df8e7fabdba08c1b748fa4ee9b53a8d68b892fcdec194904076691db0859974ea322112540d50c6e98ce69d4a606b376e3634a538a9f1396c5c7d8bde083e55aad4108b969187fba6fd943744fc23f54d7480bcb04008dd7a8d4dd0f0cb0e884eee1258be4a7f51c14fb2bf706e824046e9950cf5ee02031b9da69b144c6654e677453ef2915a4af7c122c67a007127ed435b79c3c6b69768b467d0e3922dc89c9764da012d29b75141f6894ca07c2535a16e29305a5f8726b3462fb5e793476630cbb19f689ef439095c2afe4ec38fa592e39d42ab1032235fd4c4048a69facf05180c678e002facd680bc29afe1fe9549efa4481b936838ee2ca50d9f80a0834938af6efd6ce76ca96c1d129ef082e36593337f02a279e352ba045fe1cd7fe16c01da69c5a9753843a5455e797a61f623bdcf64e21d479fd4824b7116ae9a095020a7faa752a76a1b129e219c8eaf2317015c590123e8f0a2c2c862d7ae6ac738c9bbd4f4be6d83a2661f51829de946be925035fbefc6dc7666d6e0bcf3eead3347b45b79dbdc5ae8211e78526d438c0ffc0bc949549645d93395be2a830600f2c8f02d68439fd956f1abb7a632f21eb7276665654bf10089d10ca7ad102d4cf5cc7fe93f56f9a7fd0e527e65d2d7fc7605fbff8ef4158e6142993864845a0414d47b18b27e95638d5b80434cc12fccbb668d94bce343794aac1e1c2322ba36b43bed2652d5512cb1e12cce7d059c063497c1f4776951681e780ec9595ea288aa3c606d0ae5032b132ebe055d0f325b931ec2655b735a9d86763ac3418cc77c59cbebc5725e8b20554559af44e32a320d3664e2beb4ac7000969d97745c20c9052c1e1cf63eb40b24b695161173bfa5085a9e1bda2b67d31607c8a6701e63fe7b472ccf87cf349248dcc29b25db75c3395609dbe6201ab87dbff01d87615e0454acc28b52ec403750a40fe2858541ad771b96be47e115a6921852574bf6fff2445b0df8f1ce400e2e1fa3b533f8a4464757a3589864a08885710d5e2e21149a8a19d48d8411319694e4f3ceaa76f74e36d5df6c5628c34953838a60b2ada608bf89f4ac65793dc94683d81b5d6822e8d4ecb01c3113bd04ddae688f3f69e7315aef0fe377fde723dd3b8e266f90f6f6a5aea88ed63a82fc4678d83c8661b5854b4e575d455104fca68094d2dedc8c6184d90df6e26a043f7350900d24a8b80b43a3912f9a16d99a04a87f1fb0b5f4955f27333a1f3d6581e1e9c5bf2dc8821574c6fb6ff2eea6ad5a298e26846ce2dd718622614ae8b929e5eefc3574c21daecfb7bdb5dda56ae1682d6aeb0269d2f162fa2f0decf769fd518dfa844f3f7dd5a6cf6ec411205d0ec46a9742eb9de17fd7e77edcfc9db9108c4c1c368472eadc719f6f8f2f115a9b21d7ebb4f03be70a0ea3fa6a8cc021c54ec060323c19945048a56b1e85f3a49f779a4515cff5afb66b91f4e8452d38a27bfe16855bd8b73907a4db62b951e05cad38f8e5f2f5b5073a5864f3b0fff5dc5d9ba6d63c2cd14a2f61d1f24b2e870ef490ec36537726dc629ee67c65d39378c6bc40e840a900946ff70b857204b8bdc4bde267bd0acd08400755acd75bfbb125e3ad3478fb2388348bac9185f5dc46fec8b5da903213acde3489e16f08cf2717f48f80004fc3a295e8817e4a35faeb4ee5ed19409deb2cab02295d5b0fbf5caaa07c22ec19066328ca5d877c550e0560b1630bdf24a6308518d1e0345dd3b72388045c2719419651c4956c3a1c08ac916ea2aac345d57d655be5dd7174477d9ac6a12875027a095295c37d66f3f106ccb0e3a03502e47e21b0e12fb4123a04b59c028830b202643f0b7a11ee9c531f57e6fd9901fef28a8701542ba0709ab427101202bbedd3bbfb0e96d6427468cd5f1b7b8a4728b8780fca1d66d4a1606feb1de6ef1823cf57d96be08cd988d1460a3aa9403df62669c97b9389f7f503e3232744c89bee926be5ca6f778ee7faaebca8117455dd08d260dc57e495ea72db42fa2b4c44eb4f45f7403cefa4a0822774f2423eab9935f39fabca2bf4503f8c136adf173530c0575bd41625c45f180c5daf109bde05194d1a203048acba6a1450bfe7e7ec9a8d4b81f582613ab746c7f767c15df2b3f6649b682ab549e6f4aad2f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
