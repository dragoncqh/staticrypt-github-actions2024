<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef30d82bc4e490810abb1ab6c84ac8986f5e9b481974558462ba5d4b1d6adf2b28bfd6aaa6981eb2843fef21e1762ea9219bb5dceb82c2f22c68f9a6f720dc26b7ab04c2e5cbab0a9b576bc47a4552d9d8a36f55c2444ffb76d503e6ec42699420c9e4d0706c2fd75290213398a3cbae0f66153553ec4e315d8f85eea826591a82a2cc246e4eeced74fa41dbf110731a51f9d3a264d6bd482d6ba51cb892bce5708855afd0dbac8f02d397e3e3d4ef0e7b4bb3fe251072816a7e9af1ea18e06fbf72afccaf7b4197a0da023f60ac6ca5ee616eeb8062c16e498a6e02fdf5f0e3d342d61f0fb4a63ef051501105d8e5e709d53dcecc72200b95fc97d150a6bfb6de418c6f0f208580879851b57938f33364b1a180ca093b1db5ecb6cb577cf6b1bf08f644f04adf8e975606f3b40981e423f2d1f8422333bf747d88560a42ff3c537452b96b7c3a8ccfc1485b28345aca44427dbeb1128499d6f6ec38e60958bffb5753f768bc474221515ae92b6aa1552e8432e790a9f557964031bbb1ad5396b419d8ff861828782de16c84d5d45dc5b7c394fb207e5f1179fe857aa53b2c23d2e513f5ad018b4daf66463a676b18b737400aa795d48c20d03f861b6720d5a8408fc0ba21fc007db201104125e0599edd9bc17c33c36a2c6c50a171a7ac5bb6e9b4f4e51e241d4e4563f85cb7c6a90e89874cf414079d367654a4850e236cdb0f9f2cdd5a5762629b1fcc307762929672113ccdd0f5873047d530bbfc06f4dccb7b614714e6da88c90210f508e9241b48484a202e3ca80adc7248d89e13a8fa9dc61bd39ab7d6799b21e636cf9d18440bd27b2edb6e55f30265abca3cefdaf7ecd565146df219d4db21cd39c66f4df31d9bafae59a260b03834ba64a5e51a8002c48c132469d8f7bd313bd76111d1c9521cd88c4ee16408ec950e40f2b58024e11b919f06f72d516be88cd4a2e83c1a904ebca58600b9a229b4813cd52a5192528c1f2b0f5e38c0f5f5bbedb917b82768d811aebe4920cbad743abf3ddfb29d8ae4ae4ce5e38ac55af78b380de36edb6d53972f27f183b57ddbbaef31a03554431f390b69f68ee5fd6adc5bea0f8445d5be00c3604b1dd7c5e9079a37d7d3737da4d0bc791a3a8c92874c774fb09d8cc3ad953f2f074a5df20661d1901615e141e19f04f90646dd6e9082c773280801e1505d3d940b981ef87077b1b27e4f6ea222a6122fb682355868fc9104a27fe795b76bc2f39a37518c65430c324e0ed0951dd111c66cebbf7fc787b73509ad980b2dc64aafccbdce706dfaaf7f1dab1f52e3d6e4a0c3b9be14a9d81b334163475f9e5771c2e4bfcd22c85b0df5f00c3c30828eca4314394dd8653aba9f9aa6a80394c0786ccce9ee3a3ce062bfbc2ca2891e1f22543b41698ee343bf48ce7060d4cae0b929911fac58f9907c90128ff5262c3537ad6ae8bb3e2495273074213f437c788fb6c919efb081f7041eb6834d5b289f55aeaba884e4b39acf607da68630d21cb42fdabd32878e7e93be2a8af6e879ec3eeb95784101c73ee89a40833f0feb01ba77e3651d59ab75392c19965e577f03a8138ec5c0003e8afb319e21ee42a7c164f916bcfbf86a9e6ca31fa6af0553e71f3f92590b449718a0ea93ac84b6dfdf0ac3057a72fa92b7254b59f9e1d5f894cd10730d1820a7cc7130171ba35b4cf604285dd05f9208152a95072983e4683136d3ca1310556b0c43a484bd2f06702876190c1c6a6bf170d1f37ac50f60afec51264620a4704561141561af13422b930370e24df2478b9823d2f600fc75d21d42ad84ae2baeaaeee3370074b0a79f55612f17b7580dfd3525e3cf731dfa81c5e007dcd3e4c7cbbb23786a42b330b3dee361ad0beb08ded53a81f020755a47a05c9f32c3998581ad03cc0413d341078407dcdc1bb659d5b241cf92db80c72608e5cb15ac92baf210981621542aca965d0420da39411aa98dbf51dc918edabe3f968b46f836d588b423b9dd9edf518dd4b0d73b16205e80da9d5a89692c5b6e7688faeab72ecda47d6a8675082a0d68eb6538e70daba1fe766aa1242a1168bd184d338c1774f5d3cfac269bc5d8f3d704a5690623fb1c0ee7e86bd2ae7da8465727192015b3341e42ee7de4593258ab7c1ae3ec2ed69ab50e1bc98b351baec183bdfc2798b7d241509c4eba3a565cf4a6b6a2b3410306d662918fb817a046dee5e94d03143a5ab2f33c34e7bdd6a130e963fb0207f38f6e95712ee2bcfa9e6cb8c4c113232b2252cdd98661f62bd6fa44f7e615ee09249f900aae7d77e5e1418e704489327f828987fe913fe8abd34ab2dab681218f73e8fefeb0a20bdc9906e05d2ba7c310e3b9a85afa503ac06f86127209b2bb06ca225009ae28d2d624b6ddda557918bdf8199b1508da3837a8ca892e6dfcca0fd4fa85290755851b73c9ca2abb1dd417ff0c1f691333f27e33783c21db2a12d2a6548bfd7bf57d4534287cfa890a92f15f5a8dfcefb4f942e06712aba3034d675b4770c8156e0640ce410256450352b3c2e1442aa42b0aaa45af6ac818e350f6c41c6b0a405d8693663dc9bfae372554595affd14dcc1c47a5d2eee3c0c3162627e9e34bcda83e5d015ab3c76d28efb3d2e850a7346c035c94d7349449f71e387697b52ba66d24afde13691857278c35616ed335cc571ea7a0b36aa02b7dc9f26e9396532172cb46efd01829f4ba74518b57b228830a1c433ee4372adb62482e115720ddebfbc656daf975f2fc8eab41d9cf41692427561da8ab134579e4ee779722f732cdeeb053ba42c0ed0ffe7a07a7339ea89b20626b383086d13bdd91820bd76fdbf722a104cb84f2d61c9f02889bed018984d7cb73d91cf47e98decfdfcdac88412025415d295a3581ecc2499354032bd7e6b36580c0afd8edc45c2fd7b57e0e45d645a029fca7f81118bc7546b3f197dd24a928ebf9681e9549f428b566a4761acfe7050608901ccf9620dc83174022c4021d470a116c0267d3fbea7c29b13d3684e86e70b0aae84110812bee6627be7974aea31d914373dd2fd33d6168d8e70c4cdf96d59a3c397fec695b03ae52d215b314ba8c3e3590955256ef3348e3a24a36272624a6f70cfd6cb9bfa3f4d2e0cb023ab04e29974196c90852e5291351e23d7adca1ea94e277a0b52a6636721bcf0dbca8253870457e56ce6d99ba5e02a56f016e5206a8ff8a497d1d400c2e7763a831aa0609ab7bfe4a4d73ac20db61a08b270780349329e4e00171572bd22d9b5eff4ac53813d8fbe777c7640aa61b0f69677a7033d5f863a500c8eb630883eab09e219a8238f8628ac6430abc41f2b23ffd04d42a1f0487ed5564004429091fea7ebbc933340a0a28b81fc8a85a10d8da26e830efa344b25d57f511b807c9bec98273da6820b9d3a7d2ea93fd5e6c24bf436c065a7ca43ad4e7af098ad0ac84d40527c5bf1065378fc35b1c22366e90146679f0cbcfbcb38350983ab193c56179275032137517c5ad1e63bb0f89a5f4177d7db308ef9f21ae3f4afc4566a91ae83175b11182d3dc680cc596dad2c7451197d99773254b266a24113e7768bcbbc37326f97c55f28aecc3cf31892dbe728646668b93a1478b9d090f19cd420e57c8ed21a1d87f9519183193e46467956041ba50802e0ef8fbc5ccc88201441fc8e43e709e8178bd0ba17705759986ce2fd32e221b3bba8032659a08fc74d2b74605ad7d9f09e6b669a4388974d8fdef3d8209538495f86ca91b00fb42db97dec3a1773433604d9d3b552571f57c152597d2878047fe4cb47687f8376593e031ec8dedd30c40f839fa3d7b1741eeb19beb9539815671c7c9b97080e124c39593644de80f7be50792b05c677b863aee1e99c49ca2c75ff7d8bba509cd271798117b68fab14eea94f9494af54e16b0aa67b9eeb0500ab28edffca31d7f617d01e63764c45161e967fd3084a6b545ccfd95571addc83f2c201600dd24787028e71e089fa61a3cdcc0e746790cc223c825256d6101f800f9a446275d50ece96beb12e01770ded41c126230f36e3972364f780d9bd3a7e3c9e6922719045571c0bea623e3e0bde786fadd7432adbd778c05bfe9d9647d073d0dc9b96364f5889e58734c95a27f9f92f6d0c58062a016011017c52874d3761bfe6c5f3c8d2dd9c87f40a9b6689eac6e3a3979c3914738af59dd26f1a74aec231ed63291e96d6fc5ef63e127c2ab73dfe00d967fce4d758ac41db061fe11d003d908bae654f764095a89b5652d83a5117f676855eba5f217addec483b99feb5b06b5b53aaab9af2887cbf4211456f9975e475bcf8672dae44d0494ba0d8fe865830d694d6ca17f75c38027b545e4fbe483f11c2d9fe0c6c1b36edf14dafa8fb5134978e3801a8ead52aa2ba2a26add1d81b19da1cf1b1d7cf8f9311aaa6f15811cda81d322d0ca27942aabed2f0ce99f4fd8a5d74d5025eb4381b72fa3befe89af270420c024164049cfe421be727ca35869076383af2a79b31adb1698176c28bfbc7904fa3a73218541512f9e42efe9afc4ddf242e3bae954d364f3bf8a5c97d61fff0a87f984822661cd2ec2baafa35e2674541506e01aff4a556b00d810d7ff2faf9587db6c5001a0290f3192bd546a8298f30667c40ac84e02c700ac854c55d9d995b0ad13d2e6dd6ffaf3f57e8c42b518f15476907e06be3a9529723512d36e7a80a0ca2450aa779fff40eb85e0880c025805b4a877f9ea261567d1899f65158b4c6f3181e4a416732c96791e8f6b2ffee489ad61a444532830498343221cf4939f6c256d5eb44ae966114cdcf9c78723a9c58987902b58bb3e3ffc5f07306e5f7b0eadd85936a3df21560af410ae265b5ac939449ee40ff6370a9293eb21ece2315cd02e51df92dc7da57ee32b9214511a2baba58adb79ef9f68989d15c24d8bf647e9973d22823fbad84b27f13cce61254724308077ba92b23489e299918b2d369c14d4096112bc3b48f0da07fb8fe7c60bdd4c5af3976531f0b018f4917763d8271257dca76c6029d6faf079ae67a86c761ca8d6da11bb0fdabf94f150a60b48faf4529dfc6dc34778b58fb3f5c43e4593905ad2c0e83bd982473613c44d4669be9a2f954651b2b7398cd724051aeb109c943fc15d9a80e93868e7e3d8d06b8d2cd9245fc7389f6231fe604df866fb907846d56ae2967d85edf0a62503409fc1bf1ca3c09e7e128f0038573ee27efd62ca23e6bbde544c30631dffb05b13f170f8363343247c378d70d6d3d16964febb2c1350ad568e7c0a60b9dc68ee72d5cf750ac24cbc5f4865f14b9246683f5ada78a5113045f999f468c3fa5cbdc580d8229be9d1cfc96cdc24f0021e46889f9b57bb5ac5ba4c55d2ccd6af5b387f536b0db10059564a5c259fcdbb736de88b546a0dd159d45671906ac15ffb0feaad860272ad68e06124ab95959e93b5c491c3826f9202db8e117929368c0368b018fb1265e6be25ceec10b9c2f33892803f0fe6abf1a6a1b510dcfd19edc44c4b3502f599f8f8c39c2910ce05f493555749f8eabbc12664762f71ea77b7fcc6631009245941e48c5655f37e11dd1f018a7868c0cb401b7f9b608e304da9d849249869a05736834a7d688edc3233421428392b8d1a9046da3af85ef53dbd73cd95767d0e7247480f6873466f6c1e84f5fc27931050ee10954483b45f9759d99f8758dc3b3a273b395bf02a55fb5932c16cca47ad1cc549fc893c1f4118a0292c957b62890de9345136b231bed76ef836a22a212a11559123144810a9f1c02eece535d732f2ecfe3e25ba70dcc3e7bb4951c42967f8bdda1febd7ca1afe024c58067f6fe4b114c413eabac62e166bf51b32c7a1d382cbcef59781d1b1f584eb36c984b2b297f8f6f003101a0145087647662651c46fd2a4fbba34993dc88f747b0895417acba10e30b6c10ae63b1232b5f9665c396dba5be57e2309711d8f88b19618983b555e8c704c9f79ecf716fbf37d8de27953275147de9e153cb3fd186f8d131e021de9866d6c4f77d10e36f7d924e2104e8f11418cf6bd3bf63b0333749ed5278c75081d7ded76eb77ece84075c0371f4b5a785bb99a670651418ef52bfd7356041dca945e0d49e43e403d577f410998ed0069d68ce4d4cd8dc7759d655f594c8cd1d017e6482b65cc98dbb4ab61fd83d3b36528cdf4325fab64fb0ce45db760b2aa3dd7fe7d75d05ccd73175f0e98daeb280a2c73bf836bcce9be4ac1e08011ac0b5db996ce5915c975456a911597ac6bafa6a6bec0e761c505b29bb5219d635a9ead51279f7668c68b0930bd0eaa204e278900c57718a9ab1847f8d843447735497771ab281c87b25e411bbfc315cce441a21bf9ada91385fe5718d8a1936ac9070aa69d11654e786e2e4b8f2ea6d3d65ba0d4647df1f8b36f3abd8fc9792813ca0566d6458fca346070902f159271a80ad241b66bd8b0d860b7566b5b646f62cbf57597dddfe0e9e85901548450c1f7f088b5bfc2bee3715fc0040f8f7e862760dd4e2f31e60d9ba17a815f3e6dd7a985a417084f84172eb922e95b6bfe0200d33024e355a79f6828f2d77ae3e07efcafeef0ef8d01710d141a247c5a075f82240022f80284e9732aedac5aa6227a00fbba8100b7d0f02b7d8d7722f91f323033c04b69799d91e2de978944f510335c67033fb8aef9a6de378505ef0b1d55ca343d4a53a8f9f7b582bf6afedde8f500a4fcb4daae3d5de993386812e2672ef31a43e13a86ab293856e9f221e37a8d97a9f725b43df1935a5f75021a77f532ecd4b482438a6aef05bf17852248670f7ac363941d030f3b875e6e39d1b34b13ee40c94cfe76afd88d34d26dea1552e0d746000acda7c002c4bc7d15ccea713b7781ef51513af6f2dc889aa7fcb22108fb75c9fa8a9c4402d90be9cf93771e9a32be0af0619d714f0df837398c30693c5836e95cdef4c079f72bfedd76f07dab43955f29e4ecdfee28f99f403146db006e6c40b55c535159da1cb31a4df9ae0fc1a0bc511804840da4adfe861d4e632ebd7e6d799a2736d9961fe202955c78087531471804f138d9f44a43cf7c674bda11a175efe18aa35f7a871e087ca535d9a8bbd9f6c231a1775a66851f855fdf9e8f0451a44649969d2f1b23797c00d73844ee1f865647004b2508e085cf7bb88d1a49b49ab4c10be27d34ec7485857ba4210bfe98839e34715ebea76d46fbcbd4f4f64cda57d4997f0c2aa684d66a360c95caf5fe5831b2be5ba91984b685c72e042523a7a800f0164beffd7999b527ab8e493bf2425ab60366807032f6695d43fb18604996439827f3ae4fbf2f8b55673996456b76a48278ee4e3bd317dca8a757f94fce6ec485ea6aa16293510f44eb23b8ce1c485124889dd8e890c23eda07b48a76463f2987df617038a0927717aeaa6da668254f626a565a2c3387172aeb0e89522e9a39bf46cc266b8f4c6cb073195b445e06c7c2b1f5bcc7d58bc85ddf15b43111323f03a85525a4ccd9a68795631c06be20f46b28276f91d4fec816bf9353c1962d92493dfa91761b88961a9af854d00bfca4effbe25fb340cf604b4a089ead9685a9a39d7c1df13e41c4aa1b152cff7e8fc5686d0caac0ce04b2b7509d1f9c7ba67934dc452a06e6c7b30c2e3061411afcb1b288c9db97bbf1bd1182509cbb21b936ee123a77be252736c608d77482cb03624fc5f2611629d9ebd7f6c2688ec35a557c59b3f32af2465afe08abb202a61e9a40abefed0ab287b29364283609f0bf0a5698ff3b6b6e579632ee199636dbf2f65d6da5721d1497d2f2032533cfe5264de8ea32129c2fb95234995dd54545dcb9aa20bd3017becb0c8aa027aa8bbcc999031ddc435d968cc6ea5be721c2998c99895399c04d6129317e6c147695ec1e9078795fe97aa427f57fc9c2244121d2dc99c470e7cb5668baca9b87a4be242a1f64bbd644239cc2cb2de011bdc0167949291d3793aedbe4615cb7d15bdad282c34d4dba75d2fa18eb6a9baf0aa118a21dcc94d96c6a051ee5b68052b6e2b27c62aa96983a779b8f789c6ee8fb78e9e2b1dc92dcb3f59257f9411e044006e865a03b87eabb84a51c1928bede8f321f9f73658ff52fb55fed5f65adc6fc52a4f646c40adb55cf0b3f02d1962dd4dbcccaf0e3dcc2b3daa7e805a84b0582fd7b1fc47ca7e6d79551d28e5700c160ef55f8265b515d1c61c1752a03ba4cc59704d49f505980db8a11a9c51f77f2bf680573ed33b9770fee76342061a8127d09a5b9333ee0da8aa67c977eab4274380b6f294932ca799ddc761c033d60faf0e0346953fb041d5720c921cc58f600235b7e5b77bc33888c0977fc0c4c26e23e7c4757c45e2a7ed95b77be0e7b0b853f4dc852caf3fb52bea5f853bd1ecffc55bcd032e4057042cde84f91ef5c94c8bb778860c979de0f174e82466d06f5f29153faa4085c21d74628fc6e1fe3e9ea5d963ff2cd3d5b864fc813d204682e2c7ef687b62a690c6029877971d859b4ad8898cacdbe1839b7c33b5a2fa0797f4a1c5bd5c2057b30a2b0eeb77032d60b20a33692f10f8a9fd79f9891cf81a9e56ba0a26c3b53fa2a44e8f34eaf15377b70d583c90a4d27823c247018b0ab3fba3727f1e3eefea89c54e21af9fb6ea0d9d5b18a3bdfae1605b7894f44c9c7843e613963b85e1a5758efe385f8520dede16dbccee46f6556204dda6983d4bac779847942854720fb543ebe69268ce1cc304f67aee9e46fc4b0702b87aed7bf656d0e4bc6aca97288eedd7f1a73271324ce58d909e54769472da7fe22aa9c9e3021a509d5893e377f5844093dcbdc009324f5fc79516ddf4c2935f60b3f06e0f9462cdc20511cb3b47616ee3eb1d97809c1abee91ab6ddf691b91f78e18c4c48373eaaebedb94bf9f861429fb7ecca0129a1d5686f48ee8c5858931b51abbb5bf3f1d79fe4b4c5cb96b0c5bf54274ca81e19b7e85207be4e171f9059968090c529b87def87e7294fcae51823e12783ba375979d77eb215ba0e6e957fddbbf53c64c337c89e48c065b2e0d1d09c48615da3dd7748e1ead32aab638275019f5ad449412c7ede91c61dd97a919a672ec4dc4ebd7a7aa4f3a7ff7d33afd4cc5d7c4d19f9589ed09b0d49e9e98b800548313e32a66a6ec98a5f6cf6ded24dd96c573bb9e90737d22809f8f78de2208276701e91d433e75600073b0de134ff1ac1532f9a1da01b857d3db72f2ed1d417f06cfe5c8d7c9b0478f5b48a3c8bbebb3d5afc396afbc7a90b6104f500c03c21286051be2ff722283113b52c5301b4420292d08d6011d7b4c0c25d129693f9e7d053ff127da974ee7c13cf86310824a933be5e532af973bf67bd9e2d62174c8ed12d2c64c3ed6977fe5b55fa74251e42c34a461372d0f239d310e15f71d587037227bf7c0a98c6817a210ca0e46d1afe189c0e8f3a1f8e869ca12310d735ed20682243df666e641d2e24a353fc95af83b18c7fc79bc4d7403fa888ab25770228d5099db47324409546b40a81d70b58e34ed4a4a0abf02fa2eb574668b870bdd2442372fae7c55d9615ed06dc2018e7e4034f431f474b32e003bd5c67b32848b79d297c59863fbaf6c0bf3d9484fac5290738a9873ecf7e60802ce9e83226fe314695396b18f4efe572b5d4d8dd6ce65a501e88b861927935656ae0c6739ad63a3b3299d21956c53f276e9c5d4a677053ad4bf1d5e6cd240eaa0db2140c29c5d13a55b5333b18d1db9abe497eaadab6c8212f1c98b0346dee45a32c17f19c0d43bcd6a2644e170105ce87a765d405dfd093c0c068ba5f6de15977f3003b316436dd82440bb1e8ebba0b33e32a9e77d721751cbe2a0d3037b4702dac80a7de2355345bbee0ac56216c30f1a1473e3aa566833dd6cbf12c13879ab62405d39e98d57444c0a67965b25efe8ea30d617cd7c9c85944d0b7b4a187e3d715e273bcd9df319ff9370cac05e71641c2b5058ed81b5bb1686a1a9b7222538eb4f0080e7be568960d30b5b0dc02d823903150897ba265109e2dbf84add56d832719b5bc629b3b620fb87982644ed0eb3d2be53bc374dc11fea54a8591ae144fe96899250b4fb051deffaea314b2056f4b1888f8a722a445a3148a4f053788d645cf9463a3d9483d960c2669d95ffb01b82f1cdd38ce52d1ff0be9ae2e19a428c71c76843f25e1980b29a9e88e75a6916d7e3bcc318af4fbfdf2fa25dbac6ba7049e29704274e81494dd79acc597c1eec1e6c1133323b68ba9cb70be406a9c668087825e59dcac343721813eb7ab0a34897282c27e4972e00e774a7be94644be063c6884393ba4ef17cfd8f67963d1b887d3ac8986e6a3d5f297d1d33f58b5175551b554dd86876dd0d66efb20f807c5943d5c67060e6c586a0483c5072b2aba8ea5bf4b8407b1a77861b2b5da5cffb1d91993be1bf5c7902d839e474b5ca48ca91c3d27c7e3662e733975b515eb61fef41ae74d658c6670a8675b95c9798646d4a2377a459a5120b93b38b543a2a26e8aac87dc6c0ee2991962b3011c5cebaec2774b03dfd4207c3708dc81b75364d4d04d3b84e1227708a1b96d019f7d77d2c6f58c6f5b1590065c45e843fa62b932d10bd0dca6ccb1ef068e34cc3c5945c4cc82343b1884ad1affcf3a08316355f692f2e059c3c01e50969b7bf0339bdae37b66ebd8aeb2f160b198ec30cb68cc9eaf7328b3755021c3100aa77fbea04ae85b56165b1a087cf7f5f3370cf83433901ae6e063e10ca7133abb995fe77cdaefc7275016bebf5bf7408c852c1a3b7c07564f54c68dce3e9138182996dc1adb10e276be33ac382e82ff00b8fcc32114013e3a3c909ebac99df5b118c8d1ab15e757e9b591730b18e6d2ca6d72eeea6baf29e8931fbd85e751b8c45cde20f55b3d4d73fed9bb485635818533764f56af64a9e481c0495f1b1d41e562a8a889b57685f8122a3d9484d8b55d933f60de1fad8b5f2018eaf75fb87fcced421f000b692e707ecaec20512d45a112865f00534d1cb91a6174cd204a67690d6511276eb6b89d374248a1828bb2c7968493fb38f50ad74263520ba0eb6914925dd0dea4df6971b94c1c06f220a33251126eda52c1badd25b830690fda4906b4f37b21dbd786dd441ce9ccdef6a1b9f4604c6e245e9adb4c01bef3ee5896ce4b00cb095eb23ba052b4e8c930d80f7b4c44634a3e15156d832bb729602e4a2f85d8e37bcc2f5aa4cdea3a90576f4097ba4cac1b3d781cc13afac0d96824509db35b34fb5092b2734ce3df8d4bd6bcba66b7ea214582e1a46453b2c5f4e9cca8831a2ca107bc4246d64f462b74c376fd2acb68498fc5dd75c2483f6ca954325d41511cf35f0e77d33be473e0d1bff359a1070570a6d960a2002b90f02bd0718d105e9b2fc15f22b54989fabebc74683c4418ccb91217ca7c36d0eedf5932e963cc612f86e5fa19322231d217f43c2ee0bceb020f0924f9f0f4883cf2d71b1da949996b9f53ce436cdce47916a04504461aafaabf5a20244e09d9133d0df58d9452648967a3000c3c419be45562fba8ef6102f779c9a6438af68bb16b1a99d09bd3edb9022c00408ba7adc9e6c1dcd8d67d8ad8134e672e3727a28d9fbb2101f3cfc1cb16fc4d77d10ab0a6ddd2af6566180387d71e649be1478bcdfee9edc030d6b423c145248f4d10a43a789adf3c825cec810bce3d355ecbf322ed8d2a302ce9b9d5026037201b4050551a10b499e5eb1fa37e9f04499d2a036b9985bb274d41a76bdfe4797ac662419939b204f190ad633f6b73a419af88c7219fb4aae4c3fc174c4001fd84dded8b197e008b2303592fd1f113b6898ac8d7a9d844c9a9a07650676c3b7181912ef13459b09982bc8af55e72d719fb573568278836f26f0a6acec85adab40f305c47e6c9e7ad155c01b08d280bc22853e57953ad7ab602d13185ed52732b9c453e7c84cd79b806a79696b6557956aad6e09cd50910fc1d3ecc82dea819f6a6865151f6b6c4b14952b385c9b908e72024e725d624fc56c4aaddbdf9998556b774d359b6a2ba9e70579246870deebe9f638010cfb5a3525d455b992a5cfd4b93b5f4831e719870608df48757e81dfa90b591d5e154fbcde5c44c99482ffbd5bc2207cd7ef0a867d83940aae355702db5edb840131de9dacf6b84daab7de74517a0e283da1ef044773a9aeeb6beb6fe95eed36372e9820809f159b9e7e046a8b59a7720f250a60fd12a749411523488ac8164e63110e5b4709d17de41b82a3d65a5b0117fccd2205c3b90239fe3137c693b3910e401e2976a987fff67cc3c1442552895cbd0f1d1d4279015ac65754603cf00ec3a458f5f1e4bc50f8abb3b9812aabf80b5394e763238c0c4a732091c0fb7bdb5bbb1b9fd07297d9c9375d829e2fc2f361aad8401a64774647e46e8ddc8a8df13fbbc39c6c43e3fc7ad39129ab48c9b58b0b2f63894182fc85b6528f367a463b29ec8f7c6fcc762e35465952fc8bbc864f9d70763179e65ee89230838ed2280b619dc210bbfd7337fbdaf70bf2b9eb6a97ddb4b09a4ef17923e802f908c4df51c7a40bedb343aa376c980f381ea2aa85a30d4c5f4508feae8f20e6eb6e1e965d18eccea061351fd4d5b3719f2d436f5f73bc4fcd4fe91caea3ecfd7beb65098721ae09811cccf127e9382dd7199aa70510d3d78e27410144d7417c41bb35bf2da25ab902f84b3deac973503f847bdfa9705e92af6e154ee6c92b4b14b1f0eb1fda0f7e55b49b8a02729d1478fe82e409ed8764f2c6c8a23fe4392035c7ead0b1a51ebe10e8d4270337edf5d0dc59a2cc783175a05a101ec66b2720748deffa7e2db8c144a5c7bed4d63d598eaf4a0e8d2a3e82fa5ef5da59080cf24ae2b3516fe33d897249350073115b8243274377a97a8786889414e6adb7c3b807d99863a298079214e2ca054ae3b557be0d4bb2665f090e5980dbffb2d78fd00e9c1d9c8b736c92717f3f629496d268b3b65d52411a5f760ce494c48887c98a5bcaf768c5c265baa1a6057dfa02011dbf6b78741d66c8a01fabc3997a96f0761c2583eae6707bbbeafbdce3398fc5c022b4de5a9d015d880bf4f679f5551190e898fbd1f737e5377192ccb975c4453a8b47e0b57bb1340b586267eb7ab372777efe93e54cfd6d9970a00f16b9e91f209d29fa86f34a74041cd56cfbd0b6db5f5cd0e86b54c50df9db2f72cc31a764f045b72a472dff5e17f07583125f1158f9068590997b6329583d8d9aaf4c773dd7698e9643263614b261fc41eb6cf7982c973002a1125f6363a7b6af8f7073bab73057a8bc96dadbfc73d7e7cdd36945270e4c1056f894963e6923d8409bb904f51dc2479bf4f09e77415deedb11347dc05f4697ca38b3a97df8fe6868262d6affcd23fa7da42198db337bde48f2acebcc2b56a695f2bdd8f1273cc32555faa704f8ad83dd2559c86e321f973040b318bbe0296b0c97a0c1acd9afb32ea7054f9dbbc6732c90194a1e8a0cc174ec3d378c4e3703cc6f115886f3d226a0764819a3ac6cb17ea1d4f079cd663604006ad13e584ad1f5e46fa5e9fda9ea0098eebe079d029b856b4b150d038a167b284614d9b5a7162cd5ecdf0098429f8f523dcd72052f8b7fa72245cf78547363140270edf1eb74bf5e5673978106f80c817d547185278b146d27e8c362d0454e10e9e054afe7c87616739434905bc6157164bb86a7f26c2ee796031d1a577c151efec8b885567a03cde494cfd49cd45a1b1cefba4bb6cf340d00257e1c5434375e2de2553218f739e04ea6d228695a8192b3a47a0f75a7d4c6ac7cbc7cfcec6f09c5e47257b84a82c8690e0950f10b8b3420e8c73cee07b9de4c385fd8f5ff3192a04fea479eb9fb398c57dbb6802f8c24c8efec561d9a99fdf78f7e378e79d36ea2fe90cc2b04c03f38260fb96808d9de62655279fefd20b78e93da9c97b0585826741c4417ff29a366d078c65144ff25f080afe5c31c0c9fcf911cf41f4a938df983d2b403aba7642565251ebd6cb65249cd857d44528d7fae051afd83f2d973aa1d90486722aae57c70bcb17f801fa82d19b44547e564267a4af8491308c61e542b8e0b58a2a6f9f0bbb8b7ca6a2ecc17ec93862dde4b57c343552f71a19e63389369889f0818393281aac993ad33d623bdcd011448449eef593a69a6361e36e0201c7fa2a0ed9d35b9e42f1fb94fe0d8a8dbcf5cf53207472c985dc1d8d6474113fbdc520b7757d1cc74b360b2dc12a975ecef0b3d2984a527ef39b16867dbcae8620212286c627178a72c2f3f15f1866b28ba2393c005226344373e23b3973948660a22d16c39458d776902f8be41d26f9b2775507251ea11ec3f2df7dbf958165e7edbcafda8dd67b1b057cd0e709871efdc8df6bb5f4e3961ba876d7ff592f099506ec1c1a491149b25ccacc3b7ed2c5551ea6fc065ee4e249a1f4d55a37f2c91b209685e24cca447298054f38dcefc0936d3398b68d8cdd9dbd2ac51dd6e15620a0a0b1aa17e5d75182c5f799127e8611f3d9e86d034754db16500aa60bca0533cef5dfe37bfe39fa869098bbfd234806a6ac320f4f7fa07ac572d6d80c7970b4ef32ef7b974294f4280c53d9071b2000eb8983dad79c1e9a24afdfe39235629cad6d79f7e600deec89ee948ee1100bd7fa3439d1d6acb604fd662ae4f2a8286c1a34ffb9705d99cb879d9a1b1a05fda14e0c60d0267149dcee1e9820ea62dcd1ec32658484e37f90cd21890f45eda79f9487e6ef0e9cad189f57fb4a91098394e905aebaa797d46459eb7df743e60ee1c2b592bdb554ded3e78fcbcf36dd2ed61b3f03bac044f2373507a47d482a3d2f81670945c06b55a718863e944a30b52bffce58836e066c8789e1955612563831da12d4c8fde7a30968f61a5d13e50b7d3156dc63622c8ad19b05e8743f6fff74ae077151c2df9f8a136916230ca137b4cc33bd71c07b07e492894dce58e358dc6292969307cfe359390ee8fabc70db5c26c74fae08f29144e6a6e1518ef4bfc14a448d6e14216ec0a119e2d2fb7d1b64740e407bea13ecd3c9434f7cd2bcc5cb367d2cc9b8f6116180692bff19172443cd1167b5ede07fb7142559e7919d4cd90f8c8abc31ee74ea786d562db33c8848e87556f4b566c028d4f910ae722b66c35c8f7fb03e4fbf16a128730a7ebce6c0a097706dd0fcdc096821d657c916a1ee6073c51e97e73f8debfe407a73dc3376b0621033ebb5624c588ba204c29b0f5e3637bbabe3a1bca4de1290daa74ef956741b47c12c8d435d9be1caa9fe11e13ad8afa0fab586b1ed586d9a9ecd7c61d9c316477858d9d47f6aae94f2065013314949e97616dbefb6115f912c78dfd6abb7c4b1173f54101aeaff105a88033236a4cec168c37c8470f56e38734b1bab819c641d0445c9e2789f2cc5c81e5584046c72651c88c704bb75629e665a67c6c54e7629cd44e850ce24a22db72d3ffc306cde4d40d342aa77bac641319eaea2d653b0c5b1514e67fc245c6eef03257891ffebc8c211900af05a80c0213a4989b1fa17fc763fd6bafc105a4c49a6740338874c4bdfb4abd576ae83a9628e08041bba67c54fdbce6133dec25f25c33ca367c260dd49cc55c03921fb4906766948cc20ba7b0ee6fb5bd8ca605cc9b3cb8698450ab52aa957c86378788565b7f0838161fc71076b9c89f028dac0a2675c7debd50ac92d22609a8aedee9cecf79ba171fa0e255be316da46ed2aea4f27f713b367525a18ee9a52ccdb148d889ae43198a7500ae5714754f64b87e28285b7182af2d43bdbed2680d6bed0f5a6a80d3943aa60c2df85697bf5252cccbff4119f4f2b683abde29084df6a6ba9c64f392092df5ea1cb2b79469254b408b31cd6a426a0340dc4a262e3c9b0e90f44136b81f403776484c5a6318b3e7a6869cb59a0ad7f71e781d2c57b9f89ddaa29b7f7d8dc6cd71781fba12f382dd3c374f6bdc7091fe047c53b6e3931e2b09d08ea1173f08e2633bb01eb65b171895f7bf5bd88d3adc5b3c470de8c02b575972943dc19d6eb7b1be9b7e91e1d53f0a5bf4a91c3f07aa30a62c9223684a1c8028c92a41186416514ef83183bac9e350da87baad774a743bea724c534f7a1171a7244000286732110b64b300ef6ce3d49b201b70dca64c6badda22f3965b0d19b7d1e756f823ae5d254cb785474ae1165ba29cb024cce60b56c26a1bb44dd5e4fb6a0c26d40e98e77114abca52578942b31bfb06365a48cfdbeb770bf192d47c3926437c0c575d1c95940b065d61514eb7c812c87e4d249c151f506a2ceec8d2f07f65aba64b97b5a6ea881787db981cdcbd59f8034b876c4ab7d3a89f732f7ca53ccf16161b149e0a98548dcdac1983a6dffe7cdd679d05a1fbbf44f13b06ac8e4671a4e6c604f409b6525e78da99ffbe7d2b6332cb5deec383865a6cb72391c1b2d6a56cfa28680bde82402336f94c54222621eae17a5f81af55aeaa064eff7d4799023c7842e666fceb009f0cc8c5cbc4ebc7effab35714c80d827c0d23bd447f87cd202323174a5a191d544db426d38fc2e4f096bb55ed10eef377dc4f847c641ff4537d9531e6d5bddb3123343edcd4668408a8d880b3f1285b7a537c32be5cafb048003452cbf901949c6245b1b5988f7e9ddd1373f3a2a14ef8dc262a8683f6d62da8b64f217b93711219cbcf1c54df36782cf203292aa56b56e8d4a8977f57b3b7bc3e7db4923d8b3f206037e872c784e23efc77fa7a2c5ccce85ac4649abd11ccb53adaea066ed6dc8cb466e19e81fbbe1b736ceaf7e63b4be2aa93910c2644b4f3ddfcd6f43a9fa0caffa46f1723037c05ebdf66b3d19a9b5d0c88f4bfd72e26e50310ab7e8ab750933a0356ae398826fdeabb71fa1d5c4cf3758a79ba0477dc695c787d4a7ebed445ce747785be5a4165407a8b0e31a2437ffa4bfc75e9f0b30146f2e902d29e7bd546443b5d41b2c04a0485f4216ba92f52236dbed3845f8fe8fd411b77d94baf21fd91f3770db011f2d6ab84cd35246285a0cefdb461820782ca300728be53e611524a94c7c26976518244ba94c992f06b33a45c71a7cdfa813162ed92091d321dfbf16c3fdb3eb5d33ed9f92fd9827f4d1c819ef001d399d6a021d220680650fbf0196ddedfcfb07793fae043bd1d4ab21697a777921cfe210319c786e3e8a6bd2379ed4b8e5d8ea9a76cff3a66394496a740db8ef30a111acc3bf3d5ac0bc166edf794244f82b4f585064fa1a5d1107d47d9e95f1fd112bca589cc196670d5fe3b7403cd323c58c42f2da7b3fb2d30a837466d881eeb883388bc636f09dad2d84654278b1e162e31ba578c4021cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
