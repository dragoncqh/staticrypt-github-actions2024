<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f82fb1721c144611af0af206f35bb82de435fb1c82e0b83d49e35af6568a6916724f0b2cf46c6845e80ea896ceeddfd9da42cb18e7b1c6ae5431bf9f373d9029045a9200221b6edfa1ffd41ed430ef41d061095e828704267c7a55735d1f9ab1336d8eed8079b90a05871769142477abf3ecbfdf61c828cfa6551c08b17e58b4eb455c5d9e9f9ede18680451b4416c81256568f9f4d0fdcb06112f566625eaf7560bcf8d39b1b6e47a1625f74be430d93aa8cb91e738627d7b4897c26b72a1da76d88ee2b1ada8a9995085a79d1f5662fa108bff222f71a1095bf350d7ac62e1d3cf619e5761799b3c97bbd2b141547ccdf3de402d3cd5dbff152802350298f5c72674344a86c940fe113a531c2c830b017e5f5f7e2b482d1f5f729c0d5dd8e4f037892ea5d9787eea3f573341e26ce96d669dbc79854636c7a2d4b41d0c90514d974ab01bab76c8a007e5f901d4c82c760570ce9b6734ff65dd4aba210b97a5f74047bfa6a6a818daab7576ab15b583949195e1f758eed47a5eec1fe9b82a0b0540338a4c6422d82b41139ed1cf4146d107c92fe74557d2e43be418187580260ac3fd43d9b464f1316fb485391c9d7f00e4d8a0717ba2cb04f281f9c8b54ff61ea3b541199e696ca4a3e2325a991db774918fd7b42706d6ba77141937b3350b1d7b972c42db7d00533b7ee8c72171c39870599ce591803a872b57774f2e1b13a544ab96caea3c38f1e447e7b83ed7e2934d744dfeb6a7ce6196b61bd9cf6ae3291915e26f7fadcca13949a8c0c439a653dbcd95034d9259250fda4956f5f22c5378dc07bb2d698e1e968de4eec700d6e255c1305aa88aa800b8946a576c98119f5243a6bbb50d55ea321e3ac87854d9de0e2bcfa0844f5e336d2dfe68b023f2105ed108983fc98e5eecdae1ee976dd33e0f3cea07c2e2f334ef39d455fe3e69f353f1bb4c355ad5433c6da326583623a3cc399d9ff99ac874c134b4ac078522753977dab43a131026511d7b0700567f31712803e9f4534de590b11c30d95e28e3f9163a1d724bd03ec75f174cc2bfbcdaa9358c31b0c6ae618a5bd425975e8895a59afa0cc244273df80733a11f7dc2f177fe11bbcbd776c01cac4f8cd10fa736654243f88ee08e76669cb8e25485b8afa3cc6f86a6a2cfb906c35d5ea49e5e46850721ed002a293932fd5ee167234944ef86df33c717078e31265bd1cb2d6b9c24057563f5a3043cab25bca39c03e31fa58f1709138287b5a61e60efff161ceada785b801ea99133dd1864ee8676ca3b7f689ee6b218830ad01bb0243b034e4feed53859a5ddc40d5cb64b93c1c66df174f3f786b7bc3937277c0b5d71d9da4a0650451b7b50dbce4f3a61623fc989496defab006321e77e3286bc7dd2ceb2f2233bb97a9879ac999f742f61f74ce1f47ef069d08a3894e3ed26f6c0624bdd886b24811ae66780da89025bffe2c662d559066e91920f0c2d0c56f12b3c632dd90e8624b48cb866343f0831d8ae369cf6d99eab8db4d8fa6014bc49c589453a02e608a0efa4741a8a69898d80b776a88f11b9b2bd6b0a71dcef831cfaded6a6751b6be8aa2668e7f97e5e5ac0d43ab14f2537f7283b49da27f07722bccb364b982058b1b926a10f3711f8faf4da2ad6665217fe9fe501c7065ffa3d9e6271fe1f835d46c3eb157a87fb6d8c1d3f39fe2aa02628ee887b0b1197dfe5a71e587ebafd941f5b206296c9c3b00df5746df40678a2024ad478442bc1ea659d1103e1551b672b659bb52b108c92227041bf213bb4a665270c93cb1a724a86abbfd9f305a60a1dd9486016b78be0d1c7c08f5b43ebaf4c819c5c4fc9eb42f1fa87fede5e143de0824a99f7b09f59dc45a91efedbfa540c60c73bd9f9a8454aea6dc0663fed33d36b4df191eb9237d28e8215b410c3a440cb48b76bc97a2de808d32914e03aaaeea414682d851b0818a48504ed205b3351c7047256b5406e190f5e18748d20cae7917d5419fe60dcc198964560009109c5194dc469db981b74332e8e5ece6f1b245d36eb9c2ec79e74ddf6f5f045bf5767d4b5769cf6f14159d03f08e0166b9b2621689904764f255b7090f4ba445ddb81aeb597bdf86b6cbd5885fac1f55f5afb2e730c2d9fd5ca0f5873bc71958d3f401210d7a245bfc2e32a098a64007d16a3aab37632e9d2365e96ce9415ab79eb37113ff7a084b4db327fa0e6bdf48dd71a79aae442d2d58819cf7bed2660cd45a6021d8ca4485660df409f53b3999117c28ecaa8e6070b0b1116b3ddbfa6e8893bddd34a69bc757db7e139dfa3a3ec61d3057e6e617864491283bc6fc83f0979716b4cd26aeefade3c79861cac295a36d3c296fe13bbee14474aba45f57b0fd0eaed400be403054452e2005f0300971e9124112b342b39c9317d86a392626d480be8879fba7f094f5df0125ddc42c498abfc9535b6ed91cdb399938583d1d8f9e929a0b126f1a3e4f74f259458eaa6089ecf96e839c4ebba1d2b95a44b04273500ac8947bb49ad14e2e7c6ce0def3514c689f79938a9368f9a014ef36958bd4dcd6930ca05262df2cb7dc157924d6d1b1a8730ff69af9e05d436e4e6a88f247fe51cd2c62aa3cf2618c27ed584533c513d67f56c7b966cd8b16679cd727c987e79de8489d8217f2ee3231cf3aa7a9ffc187c2e932d7f27ce2d599962e79bf5320e8b75c375bf1b61ce962cf429da0cf915e6d27f3c6ccc38f48f7c78900ebd3325cdf025feab6717ab7f460109c57036814e2df1497de8f4aa9a99ea9635f2df12ff6c6cfde4d141c296e603ce8aa066b5fcd173c2f4b879d12943d34ad2438943fdb5882d70cad81dba1daedd07d7ec13b4c5c66f5f4e368283b42ff79aa4f9ab5468d28ff337b128d5118568f3d4bd99849698386da8bd38eccda2842035324c9f0b68b85b2879eb43db9d6003964127f663d376294119ae834e90ad657f44e9bd5eda8e07513290a5e9145598e77413eb1ea2394bf34e259e27b251e1918d1bd80bf9fc5bfa94aab410f9437e5eb50285473844d83a32fbb88e7a815b6bba7dbcf6aae92acb76f6066fb9d3187cffb818a8e743579f709d5518c4fd048201bb0a42f6a76dac2071140e21171527c8a2673f879377c4d8055f8d4249e3e3e07e4c39fae6ff0631af752b5ea7c35a2b8b221efdcdbcc1714806f3ee57b75933200119353eb8a9fbfef3af496889496c6265a74679f81b6e3dd8623f9814fb0414fea2d4a9abb109ebdaba7f4f9c9acbdbcb593b2c8c734c233de6122c2c8b5439d6368c247d05471e6b7952dda4eb8c9f01516f6e5b3019fa6e3643e90b51f97356f34853df24e73ef41c0ed97a29e1ff399afc88278059b93edabc5baac1e28a8727f84f81e53eb591ad0db096023e5e78808895e015a962cced6e4aee6e076cf45e02b2d418a64fc4e6d7c745308a59a539a43c23542b2c9ffd85848cd5a79cb0d8cd264fa5aa6e885ee340e20b70792221ff8f7d48267370dc0a710e5dfc51bd56ee1585ebd98a67aa68e040edfda7a36c7b7db97f3a7b56a4bae058e8eb043d5610cfa0dae4aa3dd74b5e0a82a59ccd342c37818e00d3238fea8ee1efa0e81e9f1b2103bbd5b1675a90059223d294b048b1d153632b03e01971219d4430105c64ac8c872ec076f8c048222f5ded256d2d3d339088831f13cc20cec8a71984ce4500a0b2515a806a5e49f20e1cb19a170547fde02fcdaa1ceacea4769a1692b78147e4fe086d9678d1cfe97316ecbb904b005e5badb7bcedd3e2060cdf76ea9333812508cfe4f95b2b7dc7b3a56fc424edf39b57b30191dcaf705c023e951e0e4d8fda03dcdef0a23258c5ff7881deed2d636b555253be883c8d7a19fa0c69b0b92a902d41ce6446aecf98f468912a07df9d1b3a2401dd57995905ca36affe4fb6f4945f9e701af7b0223b1c897bb7e3f0611e860af9b301508fbbb06a132add87735cda8d8830e02a25411a10669d7053136ba5619de4b83f8ca2f15e18b6f99c33fad260ac29612faefd18c0ddb8fefe6bbb47db530797aa988dc943b4a54797bf14a597054c3d8eb759eeb5c22d0fbc42eb54e5b2b6aec037245de6f0481fd350bfc1a0516c8b585d37d8a94e48a7d34d3275299513c7de06352728819e31f56366917b2c1202c6d06fdbb8b1c2e92f9b984ca2c6835f79263e7825f1092db01b26bd88214193622a233025a3d3bb525317a0b30f4653a235e6bb6a2e3189e9c96b623c3dae61a4e80c75fa006869e17d1837478f363f2130669268d926bd3d1de7baca6e11c04fc772384d3709c10b5bf2e118aadee0346aec09a6211918525fb7e8f3f4d5343e73e6a50fd16acd144383ca1519f63fe012be90e6cab72df7db9f964398786918c9064694716d4938f21f0bf659e0989267f7673d0d43755312dcfe2db9825fa2e1aa71b79b576c1daa9f77a350a15c5c45a7ceef42f38b3056ee1444f872a798e0c9d8c2c3baae44f6eb51b3defd8c29a12960b51247374320ff1ae797aea6aff8da2d09320cde5b6a68f651d1ac1496d0f8b22ae1781fb9862914de0aa25c6c4bcca5db92fbad3e1a428b743a0b86647635ab79c70ba103b99e32fa59f655cd2ec5017346c2e38bdb984b3c10b819e41d8b3647cf9764d616e49fbce3821ce1cd06841b673551f2b3dc22e53214f043c80dd99318026f0b02ae8fb36622e0edb340adc43b9f5d7410deb6bfe1f5f70e58cace5464cf8a573b71df4adb9e8327649b375e3b702812f2b8494e574fe39ae9bb9c42b693e1dce2f30a735eacc6d59a1f878ef25d9a66d298fcdff374c771ee3de8f1135d2cef15aca649a9e3c0288ba8bb547497c49694a3be61b867518a7434dc559a763e4dc648fc5b80242eb991a4569a7b1584ee75edc83ece5853fd9b318603d760fe1d6de472ef8127cc04130f3e58c45bb8dbd85790528b9e28a4d3a95f1d82f57dcc72059b0f4adb0d433ae881942db72083dd1036e4a1adb85a27c1a07df5a8d37f99fa693785e2513b8d6861dca66f950983e8215d8ea55e0e68e346e630a14afd5688bbd3b2f7cd9b1503cda9bc1da136d66c8b3c346ef53d9b94feaec705eab24fc341ed536462cf48f3c0ad0007ea7f5eaa75305ab2beb5883683c85f92e3c3ebb60c5d15caa3007b9e056c9d1454a6c40aa173f1eaad5382a80a8f5bb9593e14c727a6fd55aed4e6a5870b4fe1c2b67d237c1262720160c09fe55219aba49754b5847f9533e5660c6b6f509aade5dac4707cccdbc0608deae4e1634ae3b478fc9a03baeb6aaa62bdd8b42b805f2c36bd4d28be86e3c1991cb844e7cb0cbe412a2766526c6b83bc5e4f965cf70446690cced8f7cb6a01d5c5dfcd4ec82439ab147fa5d7ed49fce84f06cf7635bb20de1d04e739c13dc5ed10eb4b87b92e7d722c3f9fb392f71be57d1ac1367b3038dfd7be5be191f4cd7d577b8bdc3916e82d835cd73d02d01849a25699d2adbe31780fb90573f79b9aa37a2eb8e9b8f7c0d3fdedcab5372e666fcbe7175e90a95252cd5053032ec063f48f7b74272bb9a895019eed1607e7808941cb3112394400e047f2a95985a9e9c8faa3bc0b5e296cbdddeab05248c8defb2548b714f314ee6575ad33b39275f61361ac712ffe23eed14948960a212f983db25bf0f6f0a7db18c1df28329d083b72025d936757ee297a45b4e0f7e13a809da9d7ce537d85231af2a1d93e3f9c5fc1eee98f4315f8207bdb10403d88c56155a3fbd55e2bff4bf121da55b49e39e61b140833a13576511b728d882b5640d4bd44ed83caf26839542598d07d5f202548188ff1b14eca652986f0a426b696603b306478ef45fe86064dedbefd08baeffc8f4c3d2688c87e83b7eb66c6c5554bd21506ee04ef94139a99e1da8dfac426a4649898c6850a3d4ee714465674f0316e20f39a0fda3300b0a65e82e605954e911b9b469754cd577da45c08529d22a15852ad27a6c827c6c056102743b67989a7f199afabe3ce8a7df0d98e76592e1fd2e81235faf4df198e3864a02a0650ff0da36a0d95637d4ae275eae31680d397f60465699257ca3012e27393a8a1f46387898344376253614ccdcb31d5d3545fa3592370d019634824923549877eda876b810c51abfea517be382a35548aed2d0ede375a450f86c1c69f8cf3931f085d2342f36ec44c875dd8fc1029130bf5708001f29e0bff69c556381e392c8d3dd1748250ffa1703723d1edeaee487864a2be1b342477a6644df83f39b4aad9cfbc90eb23b0e901dc5561cc4a8a474f103c6c58a93f6b6f4f8af1a70ae82ebd983731ff737acbfdbb508a2247ca84fd9ff2deee5e39a7dad265e6da7a43b2e80275e638c0d4559c56c44ba4fe13e374ce3ededcc673de88ac130c710c72a34d66a7082c30039020cc0d88acbcfb9e8fe4c14c0bc88789f982bd459dc943f8d7d923953b7a9c1d760199903d34c36453f39ac57726d7a358cca1391cb86be2898dd90df30658d87207c8bdf9b65fa8f7130d53df8009c0096c4d44cf0258638e863f684c9d748a717b4df70477fd23e87e97663c838b898e0b51b3952527fb09b70d858d018ee9a332d277db25c2cf4d8b848275d1ec319739a823c125b955c1dcee9fdb35fbeb341dddbf52319c6b4d33fab457ab0f634cf67a3b15f2aa797fb64255bbbbfd7c92a59fafa65407ae89ad00bfa1d62f8231f3da4fdb258b8a9aa1c4c4132823f8ef591d6d089d221e4ca44b8f14ef563d14b9761bcebb94be6ef61dea4714486aed396fb695f342fb1543d582dfdd63caa31697d366227a0749add6df5eab622160bf0473f1386a627a2d8c76452fbe8141510d80c73a1043d852c5f2d02fa00b7c6dbfc79c4a7d6a30077c49147591d406f1af1a9fb87a2597d2463c36cb4e53d3ec8db9e4e23b59b34512b0c3ea98199265bd23d1eb5ea01595451f8f8f74b1d717e1254943d847f526255e1cda477e9422b6e64d6e0bb2fa8b5306c1304006378dcd5ea2d0c68c6fcfa1b708d84a6dd7bc77211e224c17c58147f49d3a7fdd49017716d5da73c4dd3d7f9a5f1a3045e61924c124c966dffd7f1d26cc368a3fa9daf10d5514c14f1501f0238c0b94c69763bf2319088fd38c876368b2af5f38696789c8232f05a742dd53dc3df0e709c93094258435de1732e6e22a5b90bd12b25fbffbed34f9f59c605d1484df63aa8cd0b57f01fb111b6513f12adf24b9244f0b741f230d041e2b688c7d74f270f898a92e58ee383f7c44a35bc55885377d0d7a4a3b85f76b38c7a8c7b8a2dff274fb74977de3c6932dc4411f36d353a8b3b31139fcb6c3f629effee2bc6aa634f174f338a8a87d33c6b20915dbfc53a159dc049fc9a285138cdbbe1e3380bb5238af91f92f373bf8ba81d7bf5be665a4e546d06a2c2b11ceaad78467dc23c80235bfbb2b730f2758a076910ddb5b75b0bbd14b9347709c18f58cf0ed731ed2770069894386acbe10c6e4aeef0350d4e23335d122e520b8e4127195fd4c83a2315d1a19f098183a20d9b5fd547c71ca9cf46e9d9693c319f8dae5024d6234358a77bc697c80b0d51f5152903c6601b823a93e9bd1c99d52e55b105f655fdf0318554c9e8aec528703e2c181376fde34fef8d071455e7f32de7889f78a41d05ceb97b23427c149a5a972a905b7d356b6814ee046be29ab4aaed78ca987fcab8d6864d13d923e5318432602614670789737e080a4c41a7863202aecf9bfa89a7611950be6e3e3cf1c3f9937acb11055a8571784e39a1f0064171ed09b127f9dc10fd2906d242050789053e0b98065da5ea474ee594001f54bb0cca9379a05c6e2e0d14e3f558616f8e91ae453503d6b214fdd36b8cb6d41348ca8baebb98a5eeb5371537ccb569cd0daeeff7ec86d4c27dd02715f1ce80efccddcb1d7c8f3d051d9113171a0840a424a0d07e6305f3434ffe7297c4e12845ea818c3cd446dfcfe9d2e003eac5c267af8a6f25a74aff6e4a09214974e6ebc62f68187ce105c74be42df17659578572349df470d7afc1a8ceb15d916db70d5d0f3fabf496eb5145ccc42bde0228480f70a1890fa39c780e5116620d530e2aa2a4d58b02432c53ff5f803c59118dbb50b2c8547b9fb2917be238f7bc3708360cabb41ef46b5304adc536c3c35b5af053c510ac8f07d1596ffa1fa871277f1bb9bd15ae97f56701885047a0b0ddc169d818d86b432912eaa3df4af944e661ac6b31103bf5be9093a759e66db418667b053422d12ee33a565487c97678ce019ee0d63155708c9bce4fc73341d8a264b760f51b47cb04f77467312445d7749636e090dc4acd4921d971204cbd5f0c28f7143a173b2e057e07ca7e04fe8a3cd7c759008f4f25937ca15d3b771e9d1596e2cacb3797b4e9d13d76ec1771c0b7bda8d6c67e5ad72322c9779fe49f5eacec680a5d1f5a51fe0a1e424cc41f45a7c2029498040ad73cf38708a538936becf72e64d852fe59938fdef5a4ececd907964dc1198c7e43bf0371885dc04d17dba9b8c0c2338659104c21dbf0c1bb79d7821c29ca84d86db32f975eeafe0cc75fe00e65bdb25b6aad38c65144b1aee0a3ab11288edea9eed9e03bf69e33b89a3a403d457ccc6f6a98459f6db4b15a5f26bb6f151fe1f00bf26d17942b35c5830db2408761936c040f03270699e255d7ba69316b084841afed21d9d25c34ff8b40f6af535a6b44c3b199e5a2069505435136934a7ba3d66441897c9f8abc942a3a782123f3632b6f367c9812ad4baaac54d2f7dd5b0c5c1b62d131afcd89eb23aaa7708d259df5719f2370e4ead16f0528c549a7a24bbce7a35521da2c7c2da80ab5f0b6e17394df4c8929b9391d298b89ef1aaaacf3bb381831e0c54e7687cdfcd7bb713075f65f8c1f031401f51017a806c55977b4cf3780c8a001281f5168dcb6d36576ccc266d77c9bf1bd8f4119251fd1d9a08e333753fb2473be23978d2255b73022d6d30133f855d8617a5e4bba4b6a79c1e5337507b768ebdd9116fca912f494f55dc254e4a17c226c3762d5327332f123a62234419b6f60fa3b655d6ab4adb399442c37a5d746c1a7719f875fb906b44dc572782cbc7a566ea3db9e2664f77438552319ac6611abbfe05ca919be1eb30ee3d13b239246c5624a1596fc9e0bd19c956a770c0c8f9b393170de10adb12adc147409d9c1036b96759b2273bb11b58459588e5d7b7c2739167008551d8e3f83459879bb83b6614087d79da2b895d5414297d84f67c9976b2c0977b4d436083e9f81dc6f45a0c3b556c9db9a570044eb1916b81a78d8f8e835c9ace84c06b0040dea3d9b83f59234da8842250ed4903f91927f7dc40955055985103e29ef3b3402218019ec7fe8e975e567edde84a3c2fcee383c09d8b8ac955a2e73be76ed389ac08faa2690de1247d0a33993143454f31435a2f3efcdddcf282fc6fbfa391871079489ecf66b74174fd9bbaa50d9731643693d380c4217a9d9f661394dbc39aa70b669ee658ba5f434b119cc70866201e5cec180783cc3b269be2907aedcf3830d16d9b24426358d00068e973fbb89d4cfbf26fb08c313e7146e1db9e7202f25234f173bc7fb320b9ee4abc258758d2ec65d640a1c46b4607a3841fe0512c58474c905402ce4df635a485125517bff5f845552d9320fb1a7b73b3c334a04701c280f8effe381e9773d42c8c24fa32588ed4de2538c0d4e93ec3155420626d54dd90fc8963bdca72ccfaa9634a9cb42239f12ffc5c5768ce99fdae7294ca51f01aa08a597bf143a45bac65be40c329418431d93359e5933619b8a64e536bd7b54e161680ece9ea8a6c642545e2e36eddb6cff4c9183dc73fbba4422bab53747e44b6d4077db332fd06e69ef324d6c6f8056fdee823bd96f62da82e2d3295accb5845c4c86e1c016cf380141bbc878d78b14e4c9b1cace0720f32d6549cbb05a91916cd02d751702483dce4b00619a72ded015c13adab57a57127be9dd7fd727e694970b9b6f6745e2a7e046dda0a75c634dc1608d9de656f3aee7341150a67f956ce1bb1a6ad0c03199bf461eb9b4c0218db777076c7d806949925c9c510435022bbb688a5b5e0239b6dccf340259bce4546706f9cd76e2bd26d7ab3d98882e7da27293c7d9247245dc4e783deeb52c0891a45c66fcf546863fb78e3d8794954365b0527ce5e43ca722e30c2716cef92bf9e7626ae9bf73e1bdea886770c0c579133050695fd5401cceebea5260d5246d16d241e45e2dce120e70e6fa17977cf56a640b43970d1285c84ddf333dae60dee61072c5a19a74fbdf4f4bc90af0b491391f63d522133f9e67bc8b3bfc5fa4399acebe1bced17dceeca7b96ec608b771a0701d11e24c766da388ddff6b0520856259c59bf88fe67a6962d807c9cc272fb1e42d5da7f0a49b0e80b06d98e54cf61839e419feed959b95116873f47c891e0c3e1146021d2f7f59ebd3a04c9b037bfb3f824dcdf28ea678d3581c8510be6c3c9e34dfd054824dda1095d33b00d99ab841ed0c1e6d18894a0d763cbf31d3e741f75574c5c1274976058a5c859604d65eb855523629a3f6b06dda8e0ef28c30f718a61bf6a222332772b7f2e657480af1b048d4ff07e023ede704af8199e0f8d2f716908f1896753b143b15e609c37ebd6f80d94e246aced4c9c30a50d5e9ba25dc65ab07b0f1fea6555bb9431b26e2a3a32fe28b1953096ab3f99a280270b0949c5978a84254539770d222386a7cb9792540eec185833dd9e8f4e397d9f4923ed6fb6fd3681e2baebbeeef0a04173ca281c6cf234a7dd8cd6bc2cff83f4170da9e96eab3d5f3f0ddc1b9e24b00ee19523ce0573a0099284683fd12c7033cb966adb2539b21c24d8d8c094ebc8d42cd829d11f259700d6afe53de9f2ca287d8f21ae912bc3bb5ed4e97bf533d5c95fab9fbeac944d24685e9a04dd9c38e8ccd50ca509b9be75979c49821c6fc9345326d6af45ad97aa224c34d582f05f3d072b2782c893c0173a905d2bfb4d5570d653665f893d2a789a2e9e3e537557d7af5ccf18cb297c1b83b1272b890957feb4ea833ff860566f1c04630eacf36cd10c86cce7e9bc3c75aff5eafd24e6aac3e44330e819da0724c7b8e50d750a7366014a438a58c34344154ad30ca11061ffa22c30176ee9ab38b54131f44bbbe2e09231e4c689f73ba95ca18d8512163b066b57d1b47b861be870f8a14cf095c6e45d63aee08197f91b2002c8566ab9c6a02b93795d29aaedfda0bf762d5b850d34d94e256390c61438619ab66483cd5bcdff741105c63a969637c452fb247604b13dea72134ca9d6675c2b5c0c5068b3eead73fee4dc26ee2ccd04dc14cfb13954b13683234c0fb62532c485f68119628d50055419b7a3a0e981fb5b4bd76561db9a1596f1c169c8eada25b1734ea085e87ce6c13856ac695a1c0accf1bf1905f9bdc2e54d3571483f0f2a06d818d8af336ba7bf9d3cfeb56959fd436cea3d7d5c2d68773ebf32b5ec53ee9fc3fbc7b6e1c7a320dbcffa02f8a98a20dc02469cb2b77213ac5b593d795d9a3a8b7a6d22fcf6d73b7d886da0afd8282a5cdca47aaa04b6fa7e2126d1618d96f7bcacfe9ce9873faf5d8cd90e5bb4e3effa7088866a54dfeca376bae3605a40fa9ecd5c4455a0466c7103eea51bb614b79ff5ba98f0e2b5dea468e36378bd2ae5fd4f2704cb5bb6f99c140caf8401b87aea5228416fd0f641136ff3c9bdbee1eb3d466db4a27d621150000dd0bdbdaf6528110aebe6e7d525ba886902f8035ef2c1b363d5ed6a352b8e970b8fc114d73b0050b414cad47d13bab4e2ebb2cffb1497944c7e74990f744b5640940546c21891874b0f613260485a1cd389ddd16eff2b2712f979b7e3d45f85d14a43539d4ad1efce1a5447301be3ca9e0beec298ac3e2ccbaecfcb300cac1e29e6f5a4742ea9a69640438d61575888ac36ce147035aa54f2e0db9361c7ba8e1d93724a0a4f6fc807914f20fc091928e8901b190f01e18fd2cd9c18b8f3cf55e5c042cb37343d0a11c2e62b3a599d275d7e68d4411a761e3c51f2fffd63ac526fccbb7cf3650e7371eb51583b49265fc7eb809dfa5d7884db0029b84dcdbc60f5c26cf8e586bb307a50ddc0f97a9c57c5cffa027f903252c32a3aefdec87cea7bc76c991290fc439e218c3a974ad91236a75869a5af53cbde42e5b9d61a5e6c7fb2e4fb4ef8c59bcfee2fd057d839cc1dbef977e079297cb2456ccc6ae248959dc0fdcb84d8eb0e91667c7b17e74e2c0e3362a3f8680cfb221335f7cdcea17ff125158da664e5773db83dcf3496fd88db69758ea01a4aed35ae5f7a19b88e003543d00e8a4c1c7d5d449c2f4dc1d1b94daa9258916df7064932d9fe0aff4d74c69e319ad2c4afd14eb481b6bb954b5ebbb83a950f8ac374cb132628d8c07d5a66e970335726b3aa5e1631ab8568bab82701d8e09f4dc9548f531b7e2c5c7b54a72c20d594146a7e2f68403bd65beb4aa6189b29b2ce7f9985baa441e463340bc41f624dd065f084dc4122a26b9f0aae1037c2367906f9d639119ea0df3fed15e5648215b7111706e87b27fe7ea81e76fc6d2658be4f8c92887cf92b487cc0a752525cfa6fe94e2098d42a5563d441bbd8f1211b6e44787d9d31fb80326f5e35949499eab21c64dc044155c51cc043520f5efff1eef07b16c357ee8e4b8a6b992b95ab745e6bf0489a7c83d011dcf324f816edee074b8c3a9be952f88d93987878ed49d1ca37e3f386e6035ce32b850bf876f25c3a7fe92ee11978c3ed0fd82bb1fd6f903f20334b4b111978ca3f79a2d9ab0e9d394640fa2f85824583ec991378ce5260e7018499e1d7a6ec084d22694bcfd419975b0539fbad82f6fdf39e5b0d3079cd3ea7006b355e224b30a67715a7f5ee3ce774f16f0ebca84b67a45c285c95141e58f570e05bd6bd85e0864893dad5807c8ad2c1f6b858a87687d9f2f5e817f1f4eb5c5d5f62d0c737cf827aaeb159ef714e696efa2452fd8c856fcb1e70d377559df26d0e0fae7863eef6178c14a912cae4137235c03a3d3bfd52439b34c17856edcb06d12654618e852083f896d7f0ae877285bb4afefc5b98fa264b9d232950030bafa11b775fbf135674e2b2ad8298272fa6d8d4ed7b02a4f34fbae9fa2f82fc9448a01b905bbbe51b4a370457e0fee3c2e98156b2f9d99ff7f3f5e528dce3863aed583512a9b422f74d3071de0e623e08356a35e4907e456343b73973d805ffbf23ef97743daeeb163cb9c5bc6634e718acc279fe2b10e809508970a35dd245d4f3d01f6b996a1392faac8881f8a74024f1df3c586ae05c2498c024dab855c19d1423898d76a2d9d2bf087a24f47a83030f47f1cb238ceb5d9bda99d7fe1d629ee298b06f3058bcf5c78cdaff7230bc0d7d3e612615bf1ae0724fb619475a8a30ee46a407b4d70da2535c1b107a23926c98a50860baae4e9b0d5dcfcb65beed873c1c55c17299223265b9da5840f831bdc234e2b762fced492b1d69310f26e1b5b61893be7bd8369730866d4f9103889e3e3daaf8fab5704cb08b09bd13496968de4dcfbd7d710b37280748c1e5d0021ba6432c79de67f3cc5629c065a228c0c2d282e6cba4d4c0cc129cab57def46263ff987a3688b8586de7c57a2c4308419be75c98b218c593d0bc1dd4cd0ba8ab0c18a69520f4b210359d135131b3666d0cb8152ca06400259a5fd0867572c551a75939ad771abf2e0766875e9b647276128ef9242ea535d501c1a5c7b204d52cd97f7b25fe19b253f36ebf72afa83a446d090e510727df71d7b52bf9aaa75b6bad271ae08835daadabcceae42683050c9691d8af28dcad74e36d1db8e08ee87a4b52206ab32c7fa225074ba2eea1fe15db1ccee773dd19bac7006d1b1052a3b357fb2246be6ee5e5c05cbc66d542a72bdb10c57f59dddc03b5ecbcc66e2de56236d9fe35f4ad040f6ab15b4fbd9ecf8d255a4b8e8ca23f59deb57208f3b75455eeb7e4a867b11a18199be625f19e776b1c24f469c64bc14f399aba853b9a19a0aee1a9562f12bd36c6e40001758bd160d14b973a5d7f951fe3db0c076bfe7f2ba24f6d108d2e278b286cba8e138e8718d6faa5bf943708d7f59a10beda5485214a1880dd824e30eb16001fbbb37608796367a1d624207d260d6d691e3eaab263c8b67a5dc50f8bf4824693f77d43a7c12cc088b9fb82996d276917b0396aa7a56a086fe882311721fb84ce0095f2c56d6471c1c76e53095051587ea178e343f0d16f74c3d81e2fd674852520d71e7a7b8da38967254488cff53732cd4e45e49a1bfe1f4ab52a2ed0bbe9367c206749c4ad34cf01d2c9a55e558fe28b19390188653d96941647e7b6c0cb394e1b6b954a2127bb383b86423b1dac7303d4581932d83282ee869465779d9fe45dc69e9ae98b5210635d1d747bd8cb2a1803d74d30b92eeadb3ebb4fd47807cc470c8f5cd24d0345cd165293d882af2c4497a177b36978feaa3ffb7bf41532b24cc34301af7c9d70f563a12f5bfc0407d978b1e9c3b639732fa2a681718c4d5dd90847d30f74607c385c273138f9ba4f5a599148e42a15bfb3b176254778ebac7b17d09ce97179baab86237b93ec0a048e11b03955b1bd2ec7745a96bf38d56d381c9e74250583068ccee4daa4b2740ed85a60f2d7a798cb8854bbddf484ef13fa434cd8d63dc76d12b3fd4a07d34254f9cfdfe3185eab03eb97c4637550acaf3c9f7d88a4333ada1ca05157735b4c285f0d0e67e11feef74472c83f8811fb6b046228499905255bb0c47660f41b473b18430c6d402d76a41f9561a061b19a66e4afaee437643e8a8a6519bf448a93bd57ceee09abed6602b9f0da6bb5435c28c70fb883870ab03dad48f380807ee7ed63e5a08d03da3ddcadd1301e850272ba7a0cf625597cca95b88f1d5a8ae387af53beca0c4e932dfd74acb69d826cdd0d0f2d75550ba64752d94deb7a2c9e8e92f9807efad2a3f903cf78aef34a6a72a5a70683c176e3903b810d60f7838544a914cb721c4eca59953062550859a04901916953e114f3187b6f8d5f1a59fbb99ffe9aa220da1fa88b86cd9a8a65212379783997d5401038a09c38b5660e097d9b1cb0e40114df95acb022146686c37b0069b41cb30331145f90ffea48d96e0353ceea4f71ffb832bddc568c017ad95593a57fe7dafd9aeb5936dd85f2a536af6743b41851d6b7291552d1bc362cb23d4e2b80cf9bbafbb9e21c434c94d7db288ddb4bce531d132468a2d90c5737aafe26463fe2e1bab769534c8fd6fae6aad639567c79d3f746a8527d14ff1e55f1606c3647c9fbc2b861f157a3cb8b043f09aaad6c6601302ad5abdc2447018b57fcc3e0a99d41ad26408ee8b97ccfcbd7079a5d627d1e43cab2cdbc139eba417921f44785d4d9146080376517cef9f38791aba238ac9492c3aaad3d7b8d3eaecb4cfd8573b1681cac501776d20429486ad47266798d1f101a2cd6ba68d40e01b76f1fa96a0234fa082a8d12f1a607cd9131a1c818a1a4e00ab751cf05271675b5e470f21f6a7da527cfeffca5b8f24db1cb29f776b0909c4b4680684afaa5493e4bc88e5f34797a52cde6e7d9aee90f0adb155cd9b8dd464aba4240b772da225e6d45808b48256f5bcddb3b9aa7f74256ae1007d0c0922fdc9364568ba921dc7224bbebd26317063bebe848b30918c529383951dbb274ac6a3027234e47272243700fc1c67b827c45df54fd452634248631adf9dc85a8971a8e2254599704f91f8ae5708ca57f0506b50a58f0b3e458567dc0b5e685fe86fc3c56b8fdfb8ff4adb3685a16ef1d949e2f9344ec88c2bef2bff5533b0f076d03194bdd5fec7ff420527433cc7f39da13ef4e84b381b2805569adb6699f4e8fb0cc451dc98cedf3d722cd14521aa43ad1cbad4bcce3362f2005987a8da1664e0f396e5b5f95f241c820b97593d809bbe0fc9b52d8cefb557fdcf69a54af4e3427651d64fc0c07a8c5ca0e433fce8e0d64517f610c78a4b20042576b4e45ae8bf7e0351d5907f58514449c337e156750766c8af08d61f94061d5d17c15ae593b15903fcb4661d64820c4b4ce55528ea63ea747a656cd6c2a0d18f55776d8410bde65715f649c396fd6f51873a6a097d205449806cb6119ace6bcfe32f8362bda82f41dd46dbb7b98e884c3a155f43d5d52b94b9cb1592542b94204704f0617409034cc1dd321729dfc256a5c9bd957b6172165aab9cbd65e909cb7cc3ac992170e26d6279b4d57e6885496a8a2b9d7e469ee3c46ed7df80ab9aa320bbbcc03f37f3cc1279ada691b4b6747583a338f6048f1ac2ec019e87c4750c29b20665396e4f262814b891b57f3302f08d811df079fb1183708433c6b526bb83aff7a44cb9bfe80d0043e817fb11c11d03ecf63d7f46f03ee9e3181f5a877f8aab09e2d2aad9ed68a93a91e4455cd3d4f0dd285b790be63d2fe3d9f05b090170c56dabc877ee1087f9d3aeca757f10087b81bbdd2050af0ec3b59c747116cbdd181f880566954906320cea29358f59f38fd7a1a168276eea877902ea197387c256f8b1714ee26f43e5d4849ef6a4153aab791458b91c8dbc36d7e14efc2631f80f2777cdd541852f68e4e36442cc6330012f58d54dce63ec6d74e6701141b847cba210231bd1f3cb88dfbfb15e89ef705b642babf9e5c58cfdd5748012c47891277c1971312b79a209fd6070904fb6719fbb1837c05a858c62fd3cd439f509d9cdbc0918e15fd68d883b3d0e924e152a47d2297142ff5cc9685280e5b1155eb92fb3ae3b5052e224bdb41b03ac558916de0f3d2ad184b6e7b48d6ded5d0651025ba65f3eaee25c0339ded4904e0c6f033530c7f71837feaf87db403fcda775c735c6fb330482f3319c6ddad09c5c6c71eab41087ef38266892a94de7cfb78aeb2b218e806806824915a0e4d3e29a54a23bbf6c051aa0d96bb837fb810a45e536fd8ceb28bd91ac5571f76d6109d5995cd65dcda7f3407efa1b84f88748866b9b9c07b34e5b0b6e83e99622bf9fa77c3f0dc8c335447605d6088f6c5648634b7bb4117a81a85b00ae2d8ceec9595d7292c0b768c0c08de48fab344bd11f9ff82a8dc5ebffc9ca316998302cb9115c6061cc0d2af31ab593245a33ceccbb3b5552ee2d95236144fe44622b4d570fed33ebe797f238f49b8ba0a7b26cdab1748f84e94877b66f04d47a095a4addea6c2fccf34edb8a98132d2c67eb12ddabacffd6f36cb36996259b89067ab7b3ec7c41d61634755de0eb50d09751c3e01539da28626793e32bd136df380e92cd0d27f370f1b2af0747f37ff43b808d37e874f6fa545f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
