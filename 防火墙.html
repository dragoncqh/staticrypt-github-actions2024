<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf920fe3c963f5abfaacb327c0c9bb211e8c22efa1e68ccb6943988a357284e15d3fc3309c6cfd3092a41abc9c126a42f406fa4d1df50dc4960af4d4b8ba7c23b19210609f18a66e63d8d760d29139c1a60ddc4e6f8b5fca641a9b3f49ff9f3f28530e486080a2d290dab36fe40ec86f6ea8d9e1a81495d5bd4696ddc3ac605be9ca67d10dff358913a3a637b310bbb429d62ac77a41ee7e6c51633b509a3b65991b98dffbd87650c9c945e7634fcca5623a9b0d587a57e638a4b26eaf6bb4bfc8f305b0fe13a8f2f6abb392727e4f13811319c0721126dde9d26c0b15b1984a58b014db9ae7f8f183e8a53594760c1bce9dc7de64886e9df67f3eb4e6df115ddc0f47d62027b7b26519718e1197afdb8a8d77219e3c416efecb873acc43977f68451a0736863f7e8c2e167de80992f7e69cde24f482f59a068596633de2aede7b007e5027fd8c5549c3fd72fcb33b97e9b62554875c910bc84213d2f824a6533d55c2c77d00305fb5815d10c3f6d223379a9f8fde06e620eaf916de7be516e5a6d618576e4a7314c62a155ee0cb549d00159ea32ec4631f40cd503f25bb74e37552dd1752235aba8554579ac757b953843ec3073deef51b70cdeec8bf769e7eaedca6518503120a2b53ef1a7d019b28e25c9950e343dc476b6f3c7b4268b31c1b10e27049dd37ef9e966826263fe6a9cd119a06777c56fbe26e7bc291d355b8c09a48e67a0f4bf0bb8b3ebc5ba9837487621238b4439f3d0838d7812c8542b883f64f1e2657118f2924d0a7d2d1a6eaff05d8abe2b4c68c681769ef158f560d9b171683994ba871157ddaca4efe2a2637aa74bc08778e115ccb72f15164b81b558fbf8fb4e28cb0c40bc58b7a4cc952e67e8e29e46290cbe7d58c0b239b4e0c8a90996bb933d8768615b1c5e887fb7f7c9d4b750da8ccf2cdf3e17c8ffc28607f789a4d277558fe0e42bc424cdce963a0b31f1b67300ff8c790021514d2244a6b6753cb6512f23969519afe60b46cee6ec60a3f085ac41cf6b62433394635c680eb3742d100c666feaf33804951d99fef042f5e128991fb26e4add2c2aa7408ed8698f7a5fb329a52449eeb0d5317924da901535a0c36da0e322ce97e06a4a0a7b414d830398ff5f7cefa849de8f8ade18201ece1c46e31373dab2e71a5c757146863816fccdc1f155f29799209c302087ba3c8fa2d5bd60c3ea91b56e00589a7d2c186fbb49da478b59366a68e11b57e555491f0ad3cbcb7189ec50c35f6589c3af695eff02633e03d40f7ab53f4f4e55269e38732450aa2b869f51662e4187af6360713a6067b22f93ee31a4eb52f796005a6bb2cbd2725d32cf8fa48fbdcbc99092e30c38ea48219b45958e93d66c0647723b5a0a08fffee6eeb4942cee04a725efd61fd0431850ca3957f995f5e5c3f009214001cb2e787c9a802460203781f68becc26e15b1be8683cee3f1cd948eb7beb4d45f4ba1f070f10863068376edd38b8a233b624bad4eeedf0b489dc9435b9ce0775c31ca56b109a0be8b02b44c9f9b5249d628b0b41368514467effabfbe9f723f3639a92250c2eeda6b6fb5bc9e71546e23dd44df4d4f43a63e031c4d5b189acef1fa36829f2d1579ddc3c1fc7cdf8b49c506a754605dc4b6086e0bcbe71b2c7fb76aed29cb398812c22ea512daf93001f81598686e9f076f99790536ed223a08a7741a673e84440ea5d723ea5a9a287ccda498964c613e3c9abbf3c831d2d82ced53f4ee1e9296d8ed360a21d6f73a52c7d4be9439b4f92f44d79109decffb3ce615aae16bb701cc15eeffc29911bc36d0b848646ff54cea4c5b407136dc760b659b66dc72cb06450007be6a03acb4058ae8201e714dda8cb189da93b971c6c109c544e01b3785deffa95459cfe84718079aa35e00d419e7907c59609e91b3a741975bcfbc76da50fbed297051ce6a4716e086dcb4cea33eaaf7b748fd995ec4c21773ee2411cd70772c6ac13182d15280d2b310794847fe68a213aa0e4ee155def8f892c844a736348b50b51a44d1fd50fe3794007ce647d8dc9eda4933335c0a723b068cb18f631bbebdb1730aeb239976a682a6f8096818af41f81fb95da217d3243adb2ab4fbae41f4026cae43bb6439f78c802a88e57e4482ec032ffcb73cde9ea851adb31e552c21d90980ea4033c8873e3b583eb1827804fd99d32906b5f3c92452a8624a288a4b500f98974fec9d0d8bd15a6cdcb6b3e8938dfe6ff6c09c41a64d11998c6decbc0caf5f2d3047eea2105a7c67fb60f6b4946a536d01c1f1c8dc6e8db5f338a75ffc30f397471b5857c227aaaf1d281420c2485228b99a605e71e0f5a3b93b5bc926a89f6983af1531fb00228916fc225644b8daef904565e28927730db457f0ebf995e8a6ce5fbbc61a7587321b58b32b3de47aceb72ecafb205199c7c60f998f8689b3b5483a00c451cb9115ae346c76a2a99d3779c8defd271556536db992c24292efd70838e18a782808aa3f91473eaf8cf330bc6a334ed0955322e8cf8c720ecd3809c577e088aecbc52ea816ac7c0a0d6a2059a3819d8ca9abb2f99c69d28730d913ef44a8b3a8b9efe0c94449d176cb69ce9891e2026ed812ce03b480a3392915d45057822e14e2f70a9d92792a680f23f2da98f0c2b197be66da28bf085e3dc1427ed4bc2882b50adc2adf2f9298c6f64c7191b785342d524b54bd89b140bb7d389f89970971b41a6a34b148a036209da40f18c4352c6125c72f864cae23c635644752303241576768849503f1f144dd1837a35c15d6a4ece057e294fe8836473cefd79745cb4d3b884a5bff0a802ca3820935e53431b5fc089068f295a54f515d05fd502de4a48773744e8e8efbee0fd3113d70b887d3aaa642946b7837067a6fbc02d8eadce846a9798bffe59214b681373661fed14c047afe9e358d1a48d7d34b75114d93e1f88822b19d0f129cbfe11596f9d9275ed35c80117b59a68aca6efb33909d0af190231843a45c7a62de597118ae6020e8d3a72fc6167d12ec3f63a6fbfaca93f6baf328ba2791672ceb7d7389dc68fa90df7cfcbb6c89e46bf97697175b14816a88e6679bb0916619101cbfa099f935123944091a5b8279d599402f69e0e86ca556aff9c3cc599071c24d9a5a01cd81e7763d41ad44ce66b6ec1f57c3089ccf2b3b07eec7f92eb4dfd4271668a9a6eb8ce03bd5cc4e06e43dafe8255490fc041c240266813c5e6f1f8395b0b92a7174bab5da22ff347736cb0182b123cca03f9b8885754b4e885e71f9a7e473ee8846d131e0887867b90f9254cda881ee6b6d3bd0c10c693481c3259df593a0939bfc0884708f55350d0df9504a1055ddf055fa05d12fe6d6627c626e60e674df70c6ac21e67f7791a3804ff351421ed61b243a6d213634564ffa0e5925b4a6d4b85b7ee15eaac372c091c633d6acf9b9edc42bd3eee6a2bff61bd1a9fc3cc17907c0dc7c2ab412377320ebd68515fc381c57101d311dddca27ec14f7d136b5aed8cdf4b8316e308dbf55be651b79faeaa9eb46ab308ec60a56f27ed3d6a28b1932e849033f700f5aba94fcd0143e36ba4c013c24c4abb893b0b21dbd0ae49bb7a3c64b2f1c3ba60ae8358d66b05fa2d1f331ac74771b2d8abe612497150a9373856f5bc0b4f95ef37ec946dd53dc156d565990ad09ee2bc8a102f374e58977f92dbb7132c3f029abfbcf1ff80a09825249e2b44b4d90cf7d085994420fe6ddd60ea883b0c28b3bf900b585e7837894d4916cf1dddcc4d9f0a0b6dbce29995642a2a55585b5106c254ff260e3fbbaf4fc3e927ad3906356f54462771cabaf2391bb6d5d9c6fa4087bb6997196758a4ebe6e7904892c0b4fef25308b864c2d2a77929e84f3f72acd862ab640da612411cf16af1d4ec147929a333c4bceae94b337e73162e7780d4456f18d21aeab64fcab890620a9385be762dfdc7e56fd7348f278bdbe4dbbc196e221caf51c7a57caf3e56ef4815197dbd457169143c614fe3f5425181650f8d1ddf84e04300258dc601cd9b8b0c809bdf61ea880702dac04c47e0569ef79f1688bbcd10392ac7b7f6acb8f63de61189dde8817be8062ccfb905f0059422121519dbb452b32e989f774aa68ce6d57c032eb00dbfe4f11206a7c63aac149871601f64b7e683a544730fe0565b58f4c372ec7f90f066c08508745e0561dc9d5ef813d13ccd49081755b0d9db698e675ef677ac7cd3759a1620c16f18617e7630f0c3919ed24de9aa104a167f0ddf19848fd90c61ce3ce654877e7e8bccbf44e68cb75560e408e63c1302bbe454103535dc9af4d48813e86a2aade05a19e39576d07f7ea4765426a329545eed47d542394915718e8d0acd05aa06c994737214b02c0f1e04cba36eebe1251441fe927c4e0d407acdf312f9bad481c95baa385b8c0fa78b2017afb201cc8fb4cfbf170a195a7fea419179b0044362701ee1baef21bb3b32ca9f89a1f55dc310a7a64973b36afb8a280c4bee3b176e5edccb504eac48ffbd6942125d758cf5601e903cf44a60e8e135b7c7e7eb4f15280a5a124b317e7b839bbf4f52b1807a01d5937684553c23b6efe86b15d08662ac0077463d5c2b5bc15536ef8c6cfff1cb2150cf524baf24d30f70dc53d913a53408d8e03cdf507b507e7cb6465e976af8af2b2738944e0221500e3cb008a9db0927946f8456ff388e3e791f4193b7dea029e119b4127fdc4eebb456fc397fe778d5d05e5403420efa8c9d2f1eb60a0614f65ca7cd319623a342f73e67f8df3db53b5521dac3c83ceb933b406f8d9fa8d545377566748df6bc4f33e63dffd38a5657ea98a4e82248afbb30b47c641e7b5ab71ce012ab9c3133be685cda959ddc9ffdee8cf42286415d3cc5aba25393f0cd3205996284120df3c63527cffb452935fe83797b05159a757ecdd5fca7142801d1481978e6d6648400b401faac881dce276b0cde0a886996a80ecf86f1bb06ab5133d9f2f1a2abf7a01c1481fd19e8a5a7021a5377e5a25d3c46d0a7a72de8f5a7a849761c4d42f9723435c9e97b0209d42ff49666b210b6bafdbadbef0842a53ece841eb2d608ed149795d5b659a69c0dbbff6d0657478ef0e614c1c51545694ea58b22a655cfb6b172d54ec03381f06e92707a08a5e03035fd8393e446961ae81365407b84ac4665d7e17f5f5cad07d3fa356d664e9bd8477d7cf49b8c41b97a649219ed1618caad6cec62585ebaab954bfdf905420cc90807295f7995fec99d6a7123bae7a6e5f94402f8b51916dc2b5a2f72985fc89e3568347c943882d9ae216ae397f06453ee6a80c4fd99c655be0b70e90de516ac1d153ce1a2d30f9798ab5479522f58126f532b0a9a983e5ef4cf519cd84d00a44fa91473ad2372af620b6ed5710991c2a036112d56ffe4f108812a404227b03bd0248c6e247819b510dde09a1c7d9da56daec33a70467fb99339032f9d07f52695962a601d2a0e16557cbcb814272042831456023e656773b66155e1c4fdcaadbaa44d023080d97897f5cfae28ba4db6cb061d704523cd94764f709d52cfb83aa0db09fa11531078f166b92e0f717fba02a65503d37dcfe090c123b30ac278504379b59270b1d1497bc244574ebe80317ebd2818d84e02397a90786a1dec7162489af6d505c7e06612f24f6f7b49b741cc5b805338e517d6eb99ecad0f025b29f0684830043f742d4fd95f39f19651f5fff57505fcbc6b071d06f11ab0f4911ee0150d3fc61ea98f8b27aaea1b9311c2d9374d916b8321ed4d1c2bd5508de0d00216aea67b37d4cfd5a0031733df83873e3b09a2c5fe1211cfb620fb5ca5dd804e627e8483445f555759fe1d3254b71bdccc363c0626861a85e9b69bb784d18477155ce18e1ed109d5a119c805fbc2c606f008837d13c8cfb19993e4f35edcde75d454ec00ae78b9a6ad5e7285462c2bc636219085277021f600c8e0d315fbd8bb4e7f4547336909255415c68b6166cf4ba5bb38c73a6f5e622bc18bfa10e9a6aa40345f5fd87d91b66691ea65c2aa24af9cccdaf79b6d4fb5d257475e60275f3ac265b06f445171498fa3b3df9c46e1003a105f2e05afffffe7b00f88179ac15227679b1465a9e1c9bbd1cfd11088d656fe2c77d3f25b73b967398cff29d403fb663e7be365b6f628359deff74f1ccc4650367378869e34dde460349843a30fbaa5fcd73d77c1802019c20d451a0bf27ce6b29f324ed6b18b7442d4bdf0060da986bcbe182450cf36187df27a7d4b89135e7c27a2df2323c056bc8832aefa36e9e43c1479002b304e5ff8d316ff313642ee5e68e21180b6ae252ed71859bd0f743499c910e6f23bfc434861203c0e61ad47c9269459cdb0217f443520f1a5162b5cd61adf3aa97196dc38283956cb6eeeb79258b7435545313726a5201b29772ffe3bcd49f6c8241022a4a6592d282bb048f30511f21b1d62da3d7f22bb835d3e55da49a1a4c63b3a1ab96cd4bd4f87608e03da656e491a795370e4ee17a5113d5937626bb5328115b1cdf133c5749883da7029995c631882ddd2eae30fad61273e0306541e565377086af30ae46e2ee7600cbd3a5fe1f92fb6450ad56af2e548b552bfbbbf86ce6ef0cb7b2b48cec33897b311b21e77b59063325ca7943f200ccc390c40cd30c57f77a8e7ac595a7c6e1c83e8fd207045fad24db6af5a70e684ad87f882c5379dba0ed2202d83a57ebb17a80b6208e732b5f134fbc9f871a480b43c71883ac954392ec3b233954f4dece0e5748a68c1ffc0cb8d857f3dcc60115c8fd03ec0a7f1b39eb9836bc714bfec3444693f1b464cca5175b84f3e01921d458098306a93cefa13b23c267a77d95c29cd9634bacfbd83d9159fa33120765c95d1a64060e5b2239b24590ebd084c106bc73db0dbbf57807bb9b979a0deb7b2ee862e452efed28330d2dd66005c54add793190287a57a75b9edc6487749358a8d0b185dd31f97e22d7f928a990a209cb8052af753b4cbe8f12dc01e971f6c3c4c98d437a2eb45f052e4e5f5ddfba81d4c26dab9a26ec0ec269843b6829523257d14e6b672434fda0b692e96dc4161d50dcfd7d3c1384dd2cd08831df59e8dce9fc1090874cc4424f49faa290992c12abd8aba305b4dac9d5b84e44a9100576227fd74d2da9412c01709bde4481a3c36a649cbb10c3a1e7da69c683bab0c97e7fb0349767ea8091c736e2117643c74b4b1714974ee1dc0b99f93f6602d4ce3fc74171b1e79bc5d31f22a5f8b2d92ee530795cc08373fc7c65a6058aee4d4dfcc18d324eab46dd563d6b81eebbbc8487e9eda9db7200629b76dc2aec7795d7714f97b0dc32c25ca7125bc8310031680e7fc9576977b018c1eeebe247554c0a1f712a9e266f82fef270fcc510d4014203ed2896f75d46797eda42b7b4c7c6d8273aa040a27d451af4212e50baba704ccd62cede2c09a340261fb0f16d359c73a3e28da6b15666ea73e8f9f8996fc5bcdba6c817c22a54635d00b60a1d2f29a28786ff299cc668671258a4e679e24111311a4923c32da3c49d9447a6dfefce0ccbcc10f9eea337dd7bee9108a0857cb6c7836c0bd79ac7537832af2002d2d98cb064bd9b77be0322b865531b9a1ae9a0506377b4f735883d334b3b91ad9c90cb4f67cb25150e5df01f1c71fbd1810dafb4831cc4062f8339e2070e8a95ed85aa41500077ea2474d4ac8143b6b79eedc22fc4a076c4411bddf968c92f832c5dba6215314a5ea59463a2cc1a59da1b3ff335635bf944578f9fb06217136323501367b90b4c66d200b2a21c16101f759c249cdf78b67377b552bf53fbc74bef3c44fd9df5731afee67120affeeeebd767c57a94419b159e950cb308169383ddf96eb06e8e2ba7e35bb42ab15d1643aa69d0648a5f0bf4c73bd2412eaff85eb0875d40d7f372d5485c312336b8b5daf7a1fda881e914a71927c72e6ec8d2fee21b0b112e7d10f003984f30625ff1ece4706c9c2466f6748122d82c8cde896c1e5260b8a29d461b997df7d7ef7a5e9ada175e6c54ace9cb308a3992bd138a181f9c9458973433a3d83d26c8e6589e47e22dc0dac5fbfe666b600a6c387fcf1cb77cba7ee0c784d6ff92fa4eb132821375594ec62b7b05c7def855e49c5be555317006972fb2029fb26594d27e3bcb5359e888afb5412c458a71626e06b3d3372210da31ffd7aee7bbe9be1cc76bc6608f7d269dbac45b00b42f5108a1434c736093f78173e28919e46c8d59700c21735a500be1d53b3b04815218aa155fcd1d8bb2c6f011cce3edb59cf6120d3857f9dd4fd455f854f7763049af7d1a6c3e090f8add459ddab46b44b8c01501a50758749ad7259678dfe5df1280abf4f8fa7199c3f8343012c0a1c583273501ba6cc983a41be808f7199ef20997d8577c864f6e749c0fc149fb07ff64f56880bde99b2f280157aed0d2eb55e2c0efb40334bc8633b1a88e5c1b9b96f5fb96434874211ffa913e803ce0732d0c5612fb67f4baa72ab614b37ff852881b000935c384479d497123cba79853179a5762708aa81491df3e065cd6ce603870a671fc95fda6ac60dc5633004b123c7c29954d48cd346c002d1b78b1edab3e769864a06a2a494c7e31ff4d15cdf9d3907dd85c05dc65bc05d60d1f2b48e2079a490431de2b15ea258865f6a72a54f5e052ecbdc6146743b83715879f92d49a40cb0cc36c47d65901ee0b57e03e77a5531ba056ee36658455c08a5b434f7948fd2fb5492ed2747da54f5c32f389cb9d9fb674aa6ae0f2f2f5dfcd139adb2e2aca456b096c38ef689e1ce65f3845e69389ab561c5806cad1ede1b0e627daa714537d5e3389345e82c9a0d93fc77247b16c93fc9c74156eaf88186b92368c2ea66f361ca59d9e5ad54e63f7b60288add0b9bbf0b6ec88e8ff40293db45d079def76eb33d9094a9af38330d7c52a2014222125a4c8aff395483c288c3ecbef0c4ca2264e3046d42da0789cdaae5f849d5c02006d1d8b5014e148eacb9556aaa8c90d91f0b395ead42c71dc5caf41b36b691ea7a9785b486e650a25069824350c3ecfce4546891655f5e2b2d28675c748edbee24778a300f2ed498431a46edb68152b64c767a20d18d65523e17c7eff5a77101afd3d221b67186a422284f56ec593f75dacf45072dc819bcb751d4938b1b5e7486144af4a1096eed23e687b08d2dd7d4451445c3519546070606ff3c3ec03da4da8098d0ba80f29f41c47973f5f057e68bbabe79a73fe7d0cbd1a10cd5436d08d4271a905e7bad02d3eb8b275bc67a290668082a6eae2f61bfa812e6e254a53dcc5c0452e12ef4442cc151d79275892f664206b4e6acfdbdf641fffe5c7029f3e147525887b8a721584c1b5c667f744b8aee5d486382d488a28940fbb8a36bfcf952282e8e2220c97bcfcd258d91dcdeb3b2bd67258e576ba9495e6e887f9187805e6074dd784f5d6e795738062981e41108cc40d3f091fb2173cb56a93b33aa39eb1efc55cb7df42a4c83ee155e2ce096bb01ad6bf313527d4ffe717871933824ceb6d0a72538a36156c7344969d591bd2f9c9c8d6cba45f20b69c2954e153cf410caa3017e25c93d3506ad15c6b3e547e49270f233c4f07253b528e57cb5ba9829af86bf54eb81cd2af007b9e803b0f2a4239a3f9d7036ae37c365402b2c4d8b675fcbb19ca2fa1cef4c7956ebc2f906ba26c8742307f2a7629a9b11120b17af6d904396dda3789e8931218fa78ebfe7f644a7c10aa69c1a898eecc0a490edb7c7102b8f1f57cace3174a050b28986b753416039b25797bc50f650bb5416e8adde529a50ddcfb5a83c80569ce58a95e0c9a07bc30d991cf833567f931e8f33964745cf9f628c5171019889727abd1bd895ac5dde5b34bc9252781d41ba4d9fa63a42a903d648264cb09beb34f8aef06eb426aca63a041481a75ba9eb752a5b2f16d1d4ee0b77cbe72efef638cc1412737f4f8f30bd03e3d870feac1eb42d402afa0cfc6af01b77bd60ad6052f62ca297c69c6f18736d90bd4e718dd354963a4264883857c892598deb313c0e173ae1f76273426d1931a8e0fceca124d7d6f3fd56ab88f8a3345fe4bb0a406322ba111975686cd783dff9700ea1801b99a5ff69e22c9e5370d1df1ac62473f2cdaae48471855ae33858ba23cc0e9f1a73923a757c17d25a28158ea32b9fa7da1c3a02104e1edf157b6ec10133a9b15c73631fc9c1b2b5d87d46911e5d4314a49be41c26361a3a9c4db2692efd0bcbdc2c0dc8cae399569a2e912e06e30e455acb3983438a7080b16b18b8b41eb39108cf7758162cddb04eb6772b119cc055f78ecad819a322f9a175dfa3f3f59be3347e778b02300d523d70fa54921cce3f8d7a02c054f6678fbe4f2ee93aa2be98d8a5a014d4a47490c0a3cc2d326aa34fcfc4f160c5faff05c3205f74485e31672414c3cfca5b4641184273e7d405aacf591f845cd990f99276f60e96bb6ff3661db96b68d88245f2f8eafd8c795cc4b557862aad5a7cb890b1e70c1f94f74d564485bb91090d9f393282c98ed15a332a371cc9623a89a7215c09bda678f779b72e3c4c288dde769367a648b6297c995201b6ea631f978b8786e0baa09d1c0635a7d001735668307fcecfd72c8dcbc124a986420b4ab618d156b4035e981bee23c338a77309a498f89f4561d53626dc2ab60665c81af184040635a737e208c1e8f6f2f95c861455de0b3464b0c8a4240688a177ba5ae2417bea1a404c4183ec0844155157ee4828f8fbe9a4d4243f97e7e36ba3b6da38b4284557cbf5df008a34dca0eaee6a2dc120e7df72a9818211eeed552843356ca277c1b49f0d2f3e55175e4fbefc718fd79eba1892db4c82f86405acacbe581a60cecc978a11fb3146c38f68605abf04016b28ea61893d1f48d47c6fe75522a183497a31d4a0b3b28b79874b29c9fe91987287b15b2b511d37e0f90feaf41d4c66ca3d6bb741127da242a63eecb6fdb9bc332c4a4d9b56e7edc804c8abdede8576d5772246f5dd7f4d64fdfc347f5e01604f7f43d34cc37aaf1e14343798d2e249e9ecaa2fc145258d02ca883b220f48d8eff1c7ab107a52460793bf1a725290ca9b8f6cb5e85ada5c1a3776d66a5c84c49299382766b060eef21cc56d78be38571d204a3aa9cd382a503282c56cdf15e5f5a798d9e1ae9a862e495dc110c2c67a30f4049abf735c50ae5b14bf68a5975218e03c4317b22e63b9b4b6a405448ea41ba8693dc6441563f25d2b4630bbca0ec2d285090be8ce4d57ac53a9ef30b897df4c51271b01acbd88e95d8f6886a12154482988f46b995152d09ce7c6604116b6b8826e131ec03c158bef7c34cd9b053bdac20767e7e0d371fe908e9e878abf63d4fd8a45b1b910c209f76e7a15261ff5c9a0e3cfa228ba06a86f7cb71ad4e79c9913e37835e42f048c2d3b0be6b6f1652d7747bf1fac89f753a4299f6921199f0e0eba46c1b8de52adab1cfbcbb0ba82ee86ff1f958a5ee7e6c57cef843414d6d68f82ff70d12d1a1e7f435d13b9eadbeb6addd778cbc177da518ead855188ba0c47ca747ed25aa2d3731172e8f853279ab287bb92dc0a9f9a2977c87b0d05522e5ee32912e4a79903d9b3cd46126b31476eb4e7e3e763c9449f7b55f26c62c5e590b017aff556c266c797f55758fb454113eda5419cfd50cd197b8fcd41fce00a51993c3a7929afe0e3673839d83292ee8e3ee73afd74ba47fd881999f61bd2970563895b5487f6880f8894fab5e9c58b2ca82df3f3afd675a261d7f4e50cbff0cca088155fd9191697b08dad772599d6634b65656958bbb9b605d82c67ec84b07ca43a7b4fea2d7072efc7f4676c13ec47eed0227a808144cb72fa0f88dc116fa108cd773a477dea99c855960e2b9621f3522d8a993fb75e01ecf8ee53bb12e4f44a526c3516933f226605a80c874e1ec2fbf5beebd3a06e923f09f86728565b77714920b7d07cb9244b5dc5297418b09b2aa8eda053dc34c2735d42db717f4397253af0e87cd6ded97788f67591d6fb441a80ac7247ccc478a14ae586d90d0f4e6aab7b43e63c14024906ccd5f9d7e1e75e2da91835a57083c434785081cfd6845be43e112d5e00f28ffce7f9f756dacc8e1434ed116c30f468bb88b8728c5e0af8d2b80e0e59c276764a0375fc25e6277ab5bf7be2b570411eefb7939b8adcca3779d23a837b066a9a19c6c65e0c9476dd093d50e4b9893a22ba3073bee646b465f67d31b043b07b37929de5a496691776638601264a3c13b84cb49e0cff3010703793551320b1d19edc67cf18caee2e5198ecc77e30180e16b2a0cc706b74cbd9852db3f20ea208570109100652bc7e285c9d2648935fc29536e92d64b5c45af5b3fb6b75908acb501fca7a76a050a52e5305afe1b437564efed341d7fe19fa32322c7ae0b5530c3cee7a376183030b44300f6fdc70538120860c48a5be2cc461bb9f6ade0b6aa3a5cbed976466cd74e48a51989326b591aff9583e472f49a97e927fce496fbb4a3fd56d2a3ec2a5f61072eeca20297f8c60d9221da163e404dce728a2f2f078a3648ca305c8150e02fbbebdaa14bc7e8836a15e01e5356ed4c61729d03ebbe011b194707cde1341d8bf88a8cccd6cec10184b917ae3df289e899d7591133ce321c7257eb2c0354a5cda438532d11316c8360c7743f9860a98cb325b329858389a02ef516b5319368b99b44eb495c076612c1113ed7192230e95715ba112702a5bf20836315d9ed36a43cfc4dc0b5b03f1dc68f846d84879ee3ba8f365319dc8c1706cb703a5e147ed72197e2fb74623bb4a2379dbbe3d658485a49b1394196746b81e68467a2d6fc9b52b2751016265b5320336b3dd3ae6a535d90cfa1783c1468b5252cf306f52d93159ae24b2b069fea16b717d63977b16ad1e43dee9a1658d6093c7775e799948e9cf1deedce3774fad42aa8181b0fdbbe24361b5498f2a1773d301228f9ae88f8ff29cc6350cefb82fd701b9a912e9a55620aa88622dca70de1899f45ea6ab147b8d4a8a566ef9d0df80c97cd2bb7047fc3eb0396c75c0e18538e8841a6c33db71a2b37270b2219afd859cd87e7dbdd2a4f240c5b8938c148a8cb331d47e4d34f77445589b96ecc7c09c0901b2763a3de006cd4a1c10d347fa7ecf7cd395a0fc49288b8b2a1246a9e3160fb81dde45d68bf3d1b6da7a4c3af7907d97fdffb5baf533a14eef2e6ba268f8aedda0d68d30dde1440e93b9bd638289580c7e5bb86d10cef44f968d2fea54ce095b31796e97a790635b6ecc0e10db9e28fabdbc072ea82d4841935567d77ef3b774f1bfd13b49ef2278c7de9a26ce36f2727ad39e78b8e49dd09423280c4d0f13ec64e5fa960b5666951abc2b9902ff5c65b9a8e1b7fbbcbc015e86bb5fd5a5de7336caa9dd58c277064860452cde5d53c4bd1c85223bd865c7000b472c79e2079e6b4bd21c25a6cb7213f3caabec41150701af6fc3fc864efc5ba8fa4d0102124c2c4fb95cf0664bda3421a9775fa18e9c5dbad059f5e6d2b6cf923f4ed4f201f4a1f5983625aeac021419dd31f5287d669c319c23fae3ccbf81c9dd131252e106aebedd0535f403d0dc28a2edabac4c82e4c63cedab84230c817639f23e61dcabfe0209361bf2180462c6470ddcab36a33384281bb101ce258e2c3f558525c0a611bda1c0ae341893aa28222729aec6bc9269362f9a6b8e1e462d3318908871952ea16ce9eff190dee35d55c642f29d7a4873b475b18e8e8b8120e298ca463526e6a759403166cf596ca2ca022041ceeffd3272318eebbe8092905077a85ad977ff508bec1b82a1b49789686075ab4a086bda7dcc98e28173534ff86d7f0f55d3a368856ee163f61a93123b356f2ca69adddced57271126b85a6e7b0cd4254a843da400d50d1b99d579bdcc002583b334b88e46a7665448122cae53d43a5e2ad08fde4cae0396c9793ff2fb379d4db2321ab39b57599f6ca67b504462099acb28a8b7369aee5bdfe2e3949f15782748959ef1b6329a9838d7b6b0d0aeb6889eb42b7ca10760357021722f8e311cb7b3bca6c9c34bcce621167d5b31bab4957efad0501450064e867e9b00011e3b21c53d0b2c51ee38f01271bdbcbf80da51c157bbcbf3a3cbea0b3b144d0370a04aa0d92964fc891cb07f1db5b7db471dc3e8ba9cd340aae526f8b5b0f4bdcd1e148b5d2be4effaf99f69b3dd0d75c314404438c7b85e154f6e2c6a46764b24bd42aeb8f8dc3823463d07469ec302f5ebd25d998b073aaa6a71daa57f01f558c8cccc70d58a3ba52f859a224737ddc7eb6f30093cf7f77c487ebf25b15ab0025db007e008517e43018f3971ebe555d7de914a4c39825328bcf75b0f235af49a7649f9f96000502ad0b6fa5a0700c86ac0f73e9f4d5a72fad47a25a9695ff3e6f066d525049ddb3effd203f3619458b8198288fca75ae83045add9ae518fa3b0ebd392db3a466282cf509885ed0cc2098cb78afb5a09f49a5acc86200551d2009580da4e456482fdb0542ee227ed077ce7fc27100b4ae2f108cd9e7274dc18adf1a1f4926200c91b85d598fbb281906afae60630ea436b93414700e12053cdd90032117d73334c49a11ee07d305b6a2ce1e0921038809cc3c5366833649b937605fc47b88b40a98738d6bef54bc712058c048625cbe19d7c60c6480f00a79a2773be90de2f5691540df8816fc6d8141a8a184eb762024f6f5d460c4e928126ff0694cd48af0e9baac05a7652a0d51b1bef5b73dcd52c7ec64d7eba14d64d0feb02da7c997f5388d73abb5df8b3ffc90b03c8661c8010ac07d29e12d1e790678c72d6f4622960c6f2f585c06a4a456512dc3974e3f9506a62a30013ae26c7c8ca7c29b70fc6497db2721991d908f7074f8715c3eaa289c5a81388f0791bf9380003db816df0fc22d83b61639c8a864a3db6743ca9b23249d4427d019322e02d14ef86c2b6a4c8bb380a39fca7919c98b2fd8a25348df950085b9d82dc34dd03b4ac2c44618276f1452d3e06a4c7bf116e5af2f3001189fc8f1e1d6438cb32562b5806d412053e228aad660c21c3f1ff93e65e04ea4205e3800177c01d1e3c6c695752455efaa609c63b165da54b9abf51e18dfe22c0f10626c48358efa84573377bc27011317f837fcee92831c473b58be845359feef1523d573c9dc3d9b1319e4fed5a602a08324d50549976e501c83a282db6a56b1861d21a0d69e028d671b73492b1ec52b4bff148a07c2eb0122fda484e5bdbc8176d18e798418599cb805ebe4ece8d1115ffcca941be8fa36cc233dcc9c1f65eb948a9176c4f6cc8afc441e6991dec05be5414109098516b72711aa5d0834b976af38600472b087a8ba22f951d110f58585d1ed512cb1678ce887bac4e9433652eb0a8b5f831095c34cc7d0383d8aaa1768dfa5e2cfd85341e24675fc50e2cd65f222116db2cbb4e5d64dddf0c51280bac853d593e099f0f85d7f0c470f06de9d8f1d4b2f953b10ce63fa2e46d06d62aba49642184f1a20ba935f1c3e38ddda37588d81fa939a1c9bf2f1f4dc16dd22480ae999ec66826fad3b4e04299ddcd9f7803b150f6d41900ca2cd805fecb96cc03a476052bf87f1d2d1e453e047d7dd2f9ec593fbba7fb78f27f5dc779ab99b26d5804789055c54f7a1b7f69b177d84dbfb92bceb40a3420a29e35234125ce7e68c22b55e10de348837f65f9c523332468e905f66455719380990cfcc1373c45923cd349d97d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
