<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48da591889c8821ddd297473a8d20592549e0f7d61f7c00a9fae625790f880562a06dbc67beadac121f83a08224888cb7e3265db3ed24926c40858b6089978ed53ccbdc3c2abf617138f3bfc844f163986d92194dff7509656535b2e3c344b39d4d54537bc66bdc3c951a24780d6fe195299f9d18f61f22e561cfe3bf402dd71416521137821d0aa5d24f83111fca4ecbd35e6608942cfb1f62ba33ae20040093949bd9c876cc8e0f83b73b0e51e7537a0a2c04e7e8e45adcea9b7a1dd01657ab68efdc3ccfe7e776e3bd67af62eb99b7c70f48404640dfb6785028c0c98f0dcc3c1231d863612f3118cdee77ffc2991ea95bc2e3bf189e0371bec02c59327b4dbf7b8ff884ce1a9751835ae36eaee87866483fd8cfa7f7faf9e862bbff94d91b160b625d393c76a7849145eaac1cdf0277df6bef3ee875daa7362ac23c8198ac62e9d4602f1b423faff20ccf96d0d27ee04b86537a56e7c8d8cfa4811a732351b0efc5a9213edb3bd797b8f639886fe56e794402d0b65312e606956f271be0d47af84d68d5937a607af68961ecd09cecfa9be0f65363014f786a22b33f2af4ee66cf0f210c3af316284b0c2f59112c33c5e92d29e8f4d6eaafebfb3b3cd0c86cb38b8e7040ebc43930a7ef95b13d34299bb2c5c7725ae0cfc44da18992207c5ed2d7d9b4f2398adae851c0af73b33bad55befa431e545a8674bd299ed5b746e7a1326e1088ec126a6c45a2f97407b9f05c933abfeb4908cec1d171eb3a7ce168156320fbd17c2501c314202f1202b707da8e830e4894db23c1b1a10bd1c1973b946ac3ff34d42301625b8692c51a254da8299c3f6e5c2b2e6da4e304b0fb723eef02dd152e666d70a84fff0f4155d4c064b01d3dea8e4551f14033ad0e957829def4d95267a585cccc1a5b47632e7f96d9ef19bccc97ce660bc232583999e89fbf585f2141c8eae25a7f1225b111f4547ff04cefa079f26673b0f96dc1d918da1af3e7138d00290656f3b4850ac55e2f7d02d4aa64f3e79d36270d83bc796df053b9e1804bc0fab6d66fe0bee44af10e1cff117e3b33d507b4353a28a741c655fe6a538f7a556f76bb130b7a82382c9a070b3cd01c9828fba3fb62f50580faa07a4a6e629ec69d9e2e95c0b49caa8373557a216c88aac1cdd2461e8a3e2b3766ff102c0111bc9ad601f32c11a06d0d2e454437b59b9c59593b54ea697c3a1d12d9fb1a94fb5f83dc3bb09260f80e2534126a4a36b36e5d26cfd80ca4230632696d0a45b8929e32ea6449cf1bc09a4f6a2c2cb3286cff7b2643ee7fe704c2a9dd975a5a8e4e89255aa9b1fce5b25527c82f7c0fc8ae18888a8ee092b6e386dd95c4cf20b4016bebc4050f6a6530b4d32affbd05b6650d610f1963f6af9249c3cd9d455a0d4e781a631f4f9e48c9147f1f2e4c43d216f419bd37ecba2f0478f8cfc84e3ed2b542dcdc5f82c8ef61ff65317ea170e6cc6fd2aa9913fcc738546a1282bc5877532e05da49c9f2ccd83e254936b1bd89afef1a6c4cd5acc884f1526fc41f63f165a04f8735bc2a71a99299ef80dea2868fe0926f1b9bd331b480ce9ca65ac74007471819a6c79815f919f0ce12ffbdfd9e7364f893af5da99642d213beaa03f826eea6700d27a319109156467b21038665f4b8c52cfa4cffa41ca38de5d53d34aef700724be1b013f9f851a4299aadb9da530ed673c20e075aea5af7e3d6c78166a44c16b7d2647fdebc9f8e1259f2a0ea4fa5e18cae2e91866fe4bf16c4b9cf9d565479bef638094e12080db984f1f4d00702be5cc1b41db3fff5edcbe584cdcde06ba3acb7ad512e59187af80ebee5adaf92eed3d94e1fa985ce0c36e25c7ca928a2745753bc73629031494001532572d65a0d868e89a53972f01e4cf704a1f3f36c4a68a59017378e934703d65b2cda8eb333fdda1898c6681b8b73b3c5a5d34b8c3cf23c614dd8d91fdf976b9063041283768f77b00ade7b01902341e49a062cd4addcd979768ebdc8e04ef0c6471cddeb9314e9e319c67d9fe0c1ce2d45f8cc13f73b09adc310896febc509aeb69aa72b46cd2f9f90466d48f35d61cdcd99dbb09bee4ec07240e34173c977cebd930e663d94bbce3fdfa8ea929c38964c88d5a57b89fa15ab4797bf6dcece697dbf57eacd3e0365539089cb6d8a1767b240706c108a7b7952964a743784b85160d9257f99a41b2a97ffd3e052caab269d8b272ac2b9c22f51361d85b10eccaf1b398a6da91377496ca9cfe40a158617bb3f4612665ee07517f6f7486578a9d98fcd38be36e16727264c97eb0d11f6dba50dc959e2ad1a6e965c7aea498bdd287d8ee30e9a4f21d5bdffa950744222137a6450cfc78289f0ba486a9990555c259587f796bc673a0cae5fa633a4572a1070c5fbf4436f2e0e4b891aaa1fda29e3bde37dcb851ba6403a809f22f4b7f52d1286a01aaa7e37dbdf2d33dfcfd458e1b49831551a86c9027733352904d4938abc49bd0b84cabf87b007b1794ee58b99447f9e9680e50d5874ca34d72d059640577d31e3a53e7c4bc07bdaf4b64b53337f212ba7c92c830e157b9466f0b231054d2f18f8d1484a137a151efbb45501c95b7fb30680aea76ac33cc03edb1695694af0a729df87ce366c6ab3c1ec6d67eab039f005b301610c24cdd71b6692756bd05d1b2cbb8fd30e767d4f9a85e47b4766649280168f1299ca68a814b00b699bcbc0ef5e9f39be208dc908fa4c9337b4d8f0ee522b972ade55044aca213949391bef72fd472250b1ec5b7740d0077e463bd6427dbaab21e379f62f9b68be5869c5b2d7e6683dbd5f17b1caf11015f62cb8c9e230328759abac4f24e6cf644336395a7694ebdd5b5d41a1fc2e9fdc82499936a60165b1596d052e7b244a2019655eb136fead07a91593ce4669cab102daf66cd35025697cabfae10c3531d925c13b2834ee8942e0a5aa8cbc50479c1a3f9bb51fa9275f3e39837dc5cc13b9cebe61cbb0ea36729d299827007b63c5760b2aa985e5bf92953184cd43eb8138a6e1ccb7ac4ba664e2393e67dfacc7837311a6a9b92f324f36daaa80dd532ccab652859735a7b9d45e531fe2b249035b0720e4875e40a3c88104bc6228f37e1a5639926e9518534393d2c57c9a9937b6ade76549bb91bac6bde8d7d9ceb981122907ca8ab042425e302ba35e2c436c0681b61e2c2690926cd98b3d5a89c053c40ff44f0af9ef8d99bbdef6479b172dd779910bc10d28b5af100cea00f2888513447de6b1effcfc36bcb87952ce1a84ca834039e4bc63c3a861384bbf17b1c34554660da928902ce08384550caa066ae99c02c55eb4afe6be13ae978945886210038836ef87ce8196a3e87d5c43a7923a49bc0876a6ec6374af5266542d81dcec1ed650fbd40393dc39a64aeb0e92ca80efaac0556f97a0967faeb65e35cabab1b733445aa93dad8198fc9a2c64f2938c70ffda25f5eded131386874293de802461fb736fcf295de2280d03ca38f2c87ef49fa96f7ae8317a14cb198f4c1c65c4596e8b01e1f6ef3f63e4f9014cad913f998df5f3304396c0ce3a00a95030860dd6f593e663294d57557b65d54e12cd5fbe5ae214e71dd16b9754e474ea12a83b8495db75623576e60a03df3b5c6cfda3b5439191423e34ee3629dbb998bb7be7daae0a5f5d086c6fd06dc8a0c50e65a3a88286656871879ba0277cfe0882f543781bb649989169435d828762d817e4679aa286c0c989f2ff90fc4c77802c3194f1ffd10a589c9741d60da6c3ff82f65cccbce62e8f5ef98d0c953d1bd1c6ab0d99dcd0f043a8d6be51bb0d274944c46714d12836956cbb384bf33833f8fd546aa17a302a4e33e3605ced972791f018045c726f16af103c99c7334c620d344d1027186072eac986d0dea6a129bed6a0cae5cc081ddca98205457ddf44065309aa8886b9e7384182b2ac4a97b0d2589805b07b08be14b30c3d14a8101d873cb63782322cc782f0fa66a58e730d9a29f15d2364bb4b7e897d34b00396bf96d7695ef26dfecb3a0355612702db2ed5e437ef5e8efd651ebf3048ccd536c0578892212db8cfc4d6ce18f804410f0ed3196c150ba792d1d654cc613a62ab3901ece20112c35d93a018e002a4ab87efbfd1664cb175fca394022d7cff7c1a205b280cdaacc5e337bbcaf5bff34ddc30a7fe66896f68ba76946bb9d1246b7cc938f04755d770057634d78bffb56bd06e773eef0af2f1d09b645eebdd79c4f515da1bce7d596c7fb9ccf0924af5e7d3d25053417344c2f4d4abab991fa5fe389b7ddeed16e70717859b91e7f7a10ee0d050e7e819571cbf2a12678c5ba4187330b134000e88dcac68e8896ab9084428ab467afa42970bea42eab4a5978506a29f109c75279ded19bb9805d702f707fec44ba35873d8cb1e505b2174115911cac9f6a1b8a7ded5b3e60af8c5f052b3787b81f48ce9ffaf6f4a527991eb25f932b25d83318e2101728e617ea6b9dc09f85e11aa9831d3223ea755e627deb81c213212f4dacdf5d00d70b69afec2ce8a0a4f7975f51db1b608c0876a0e1a6528e8ef7bd6b3b7099649ec17c650d6c3700da2a0b964783f5525e9fdfdfb5d2dba58a21d800764303ec4111d8c09e909b9774479b582419fa57bf81c775e9615bd9926140b2387ef9f621eaf5e3ae6c586f395c7c3bc305f3ca47718c9ae30e13c6d0a2d35304afa89127839ff1b3c60077f26d969ee80b9fc832906d9787f2211817274a4914062c2e89eaff6cad610c839f1599aba223904c4802441f8ce17ffcdb0baceac5936a3677afdd0fc5a9e24e76ee0c3c32ad811bd42e7b2c83a629e4016283eb6ec00abe2206ffc13ecaf2a2607f101e27cf8d255cf6411b04256f6669d968083c90531a5b3cae3fe82df92a1379736a5ea032104fbb11f026417d33e4924d68825db3cf9dc481be35cffaad6e755ee6bb3f738ef0d77ccde34839629da676c77ba416bc617352c2efdc680c986e914dcb2138ad10ad3d23b9e8595cf33008aeae4880a814cd68a95db87167c448a4d182d64fae15debdde4ef59939ce67d5a0431b9ad94a353ca9db1919c5b223fa13e6f9890ee9e0fa8cd7b2f9e8b023f9c05f4b639558873d8a68b4e59c8eafc5fbd01c9471f8f37924bf18303873e353fc3b1061aedefdf8704cd4db1b8f9998dccd08adcf320ad1369541a19ea15abc2d050988dc75ab72130c9e50162572b1a241f99d3353ef3784d839bede48c0fd5a5908dedafbe4c0224273678500e84793033be70af33e2ab11a8ff6f49080f579aacbb8cdfa9c932d341b4fbe6a4934d437428285d4fb8506710c5ab3a26394d137d00bb3d5a2c3090ede4c1ecb1e32e8167a2dfae019798c031e09e0cd336fa30c1c3eb93acb8ca80eb70e470d5417662aca1a12acd79eea3e01eeee199a88e33f2a03fd4765683f860db53a2f1ddacb1c503baefcdbe4ba9874b47ecefb94efe0e38f143ccf6f1e45d5a27f39d64a19f3bc2d963e724845e77c1c08adf5063d5c0eda05f9f3a3fd5c0b382fe41d7fa8036aa7c0b321d58c8372f6db2d76a7b6e47977b45ca71fd800c54cbeb532d49f065b0f0be3b8733c90cb7390a871be7716817e39d7d6735c5d6cea00b60dc4eb56358d1902ac55b01ca366b24ef1d4c9a1d0d6f873c387e75a64efa18330ee5c7405de14a1832cc0d7b5a4fa9b9ed0871651cb2440d09870b86f94f1c75010ad5b4a24ca9b3ed80aa8464006ecef14ccd8f5c9aa99df2a82d028259e18873f9545315c2a8c60d6fb698f109a07ee329b02a00a2448ced276eab4d83138aa1f8851431ffe5f38d4c68b2c01e41f3c7153032d9d4088c654cbf2bb03314e62409f5513b4153f337f6a6e1268d1e7b5bbbae96dd16b192bc8ae9fff0ef4a9db65c094e1e96ba2ac1094733c65b343c3955eae66bd2678066c65f31b6578477aed8e066a155b40a4c19010c769696fc8a3e9c0f5c0b42588609147334030b0f7f639adc2021ee570e1ed0d6fc1b2397bf73bb763aebd06a37434f1690effb2197a8966482113dcbf3e066032e1954297ee505b5c65fa430f682860da00e70fe3dd4d6df4d498630b6c1d0a4290597fb6599ce54ca31f27d9af5610588ce518cce42ad2836e28119ca728dc2d3a011f158d531b7f8b716896cd09145b627e032752173f6e40a0a9a9d440aba3f92c7eb9d8746e7eba7d5ee44348a4c0003259dc14ad3addc91d5753ad5debccf1c46f1d63cec959d602a68b97ef7064868794bebe1604e55749bc580a42a42d0c56718dcc7523fc6da5a6b29e26941f419874d538ce3b83f7e38fbbee81b54195d5d94164376926702c29963ad54c70e59b4949746a550b9855883907532082c57b87f723fd1c30bea0f72e599bd6ed9883093c4f8e270aebf4c3ce7c44add2cc517c1a03f83a8ca5fde4ea6daffcd92169e79424b32125be32ada07e29f81c64b37ccf2ddfc7c2a3a8228c72fccf577c618bd42aee0a600cf18c8a0f5a16254b0d2f7c45cc6b75defe9ce01cdb0a827c22cfa6e17241ec82dc768cc8aa8915737c1919a24fecf2c662452ad6ece9b0b4e27410fb1097e8f98084c019f8bff1e88f12436d8ed7028a6d3989d8540207e496d5c35432bda95d8d317f91f7b8d0cc41244e3fcfad86d7b5b06b9899f0ebf417c259a4da0ec5742912a71af819e5e4d5a6dd41ba65da7e3b95fe7da2441dde6de8ffdec0173ede9dc8a95ef8902d2afb9bbb6d54f73a67b00d166fff58156d9192473552395269ffe69cd26bffa8884c06464845afa3ee278aac28f30b1d8757178adbd1b529f2893e09834fc4832f843882c567a2ca11dc41099b41316483f4feca9b770c8ba744abcd85cb616e7e08207acd214cba5738cadc83e1006e76b6eeb42c62cd10251e6a19434a51aab01c57ad123b327bb02afc4705b1cc5fdf4d96beacb88b5e75169fa205080ae95c0cc6c790bc6a371d0ac05b1fbf5151447da6facab8689eca42767e18acb3c9e61934f8bb35a3e92e123102fccf1bd1be5b6d10783b9cbd881330f7227d9a4436493efcd6644ab148d8aab52ed2763721b6cbe51930f2bc4b72229fc0c0bb240053f95fb968a8c2d58b7ef3f2586f040c8951a080391b26e7a8688eb318c26b62a8496377436ee5e7534ca12f6b3be69239d97d0e9207c4156c8fea87cca597dbad50cc5fe3117957d6032e8c95c69e2cbab2f733a3095602ea6725363bdb8a781250ee6d4af1a5fa6052d52b3cd24c3c2e135bd32108fb7fc0a7ad120b91f6359867a1e8ff698892d964fc87f80def8fef1c5a11956e4643c9b1e56336140126df58841292704ca767a5790d4f87bcfe0a3cd0f7c168b4a4ce288690dba5ca8cec1e6a2e7c4185a4da6c6f6f82ebc44a99a8c3d0ddaae97482febf6734470fbdb309934214868809941a4abe4ed6e8be2ee844c07a66d93b160a425bd5591d88a2e5d30eff2cbb827c2cf33af945744f50567b59d5a9c19923c79f6a841de2231d372e7bc60c918db111ff574b80eda2a77fc2050a0a38aa6f317dc13a7802391e3e0cc13b308d3c53149076f7750e819a4ff419ce2b1d23ace5a46a669fdf696f98c85b621fb6aa46a6f85afab62a3d4e2c90830ed37d7a041c1fc8a64992fa3fb296989f08449af302cc4b4ca4dca80d09ed29904db1d297c79a6ca832d22e67ff3c4a27adbd321b9c1e8f6883565f2e17ab34239e57b0334e851884eab45a9d6b2683ef1b24978c612e1f7ec57f620d37b83a9ff1cae8d78905a4053e4b75da24e1c1d58ccf4ff900da90a3a5b2dd33466704a2e1cb6b2775f95c8b942dd955b5dada2a5a30824563e62ed5c90d74eb302a8d656b4f771065098dd66e67bcffa711185f873ac59a539591026d2cb7c1637cfc3add39b3dad2cd08e3773db45317cf16817a5230f0f2c8eb6daa0840aa183b0a54034b7d5011415fba39464dec84694fdd4788de54a0667a8ad987424873b73af2160eea02a5871be98fc5167782d31887f5cd11bcde335d28df47d21dd5c65b101fe364ce2ec6d13a0380938917cb556fd27e9b4569b0d40f432c6e5799232fbc38be75061244fac424cfbad677fee30762c1875e625ad1a491496a3c5e86e1366b22562125202195d5ef1a3dcabf47a0e45e6b3b83738575a2ae6f99603a2c1e7ea450bc4f67e263ca130a7644f2c5396e4317bfdfefb87a693003bb33b678f46eba70ba3fa2af4a5aa17f535cb03a26c0c78d44611822f03f23df59d9cd536cce3f4fcff91aa6787edbe3caa540210b3bbbbb39c84ee22db432ebc2a0e83096b7cc47211de0f5a49760315087e46716d3c0677cdefa8f168ed713443f67e190cf0fadcbed72c0baa8e19afb9ee794667a230f8be0ad942752f0cc348107435eb3f959a44701371008bcef4ec51e3a919f4d30acc043717e7a7c65f6cbd1b034a2a865d1aae126caca6c4b971be3e0e2bc9f0879f9edb123920a068cc4d432cb817bc18460ae27d2d47cda78964de5b7df104928ab21650fd20b4ac06b13ce982d4561173042998827300a539af018452044ca1f5b5da19a2fcd94ead91e7e7a769db8344257f3b50bd14c119a9c24b34ec58ed6afe1d2cd13f1e2bf3e8c43d86d53b3c5ef753e82dcf38e4390ff2e4bd717eda495cc189c8cbcc0166f60a5d939010eb1a53d1fcd88eb624cff60b091c418f1a1f221aff2436d4fb1aa1a0194eb145ec5ef07598674e3cd6b3dee57c88a06128e8155b23029e9fe388de910f737d4184781f0d7a4c696835242696fe65fb5f16be6fd67c0a8c8c0b6987863392dc1dbb3394a0b82fcb867578affe36d45d1190e1381d8e46573f9385ed9201e1c592dce348cea41fd2e84129bc3f66485068f303d8f5860f89c0a1089ca8e50e8837caad799d0a75f65641623ce1a26df36f591c17a11281550951c35fa7d595328766f499262dca5a4a9b60e07c6ca37a62255db29b1bf477c75fc8afd3e4b490c6258c2c0a9608e034ceecbf689208edb547c356053578f3562087e15bfe6dff49dbe30a4d3c5b37d940fe4a7ab6447df78966efecb7d414153da38fb72ab41b50216531a6c7763506bdac10eb1e9b3efd3d0cd059cf411a94bf84bcbee7909fe9a63f570da088067b668d4eed7a2b46ee509a7ae8cd8e5fc637a370fec17d95ac87f6a5098ea6dccdbaa7832b026e76a7d34c1131b39fc7d183e314d3bf78b12b652e75d38eded8572904d1e2c3f87b8dbd057a6aae192c6cb80a60dc54f8a721d179f04c02a7f293055a712765dfbc37339648a1ed72dbf2adf35e903a938c3ad85e0674c61b9c9cf6403a92677ab70abfe5c711800560be036778068ace97b1368c40cbe12827f30211b95e898d495cb165610aa2f676ab7f714ba82aa3bde12ac97e0d4b1f645f4aa68d279274ff4d6da55f31141a9223f428108bbc1b5a11e207bd22247ec23cecadacc0cec87efb877ec69a171164f364d43c7e93221aff25519f8e9bbb5173775ff53574cdbf0235a27107919475f887a1102965ff62158070e3ce9986707161cc4a7d60699a268d2bf10f992701ca00eb413f3f6ff71b4892a99d6fbf40a5a623964e004a769da4ead243b4f3d3ce05948fafa2ad8bd42009517f6b3b67745422f1c6c0202fa1d508a8376631d7826def01a71f45bceb3348a81adf7ba7de2cfeee896151e17681a52f1a939684cb0b036bff59d9e634d0d413e2445dbb828ab8d4dd4f68d9040d9011fb6d5211859836ac67b9c5964665646ef1e21cdb16d804c2e3316cd24d98de65ddaaf6d54c1bcef15738be95bbfe972cc4564978f1219a8d9fa5fbbb9d4ce301e01bc1690ef1ffb6be3564855a225af418fc1c0ff2568393215cd11b745ae1a46241b1a52a264dc1b91ea1ec51a7480dba0a700585d6d9791f2d5d86d297f4fb4e7df2ff68de58bf2224b51da55593c7ac6d46ada966ee194d8ced7ee5f6983ba52e4cf6dab48c830bfc392c8db48b3453e666135a58b74b78840e8802daed6b654cc8fcdf9bb93dc0e8ac2f986c587d99ee00d74f680dce8d665554a1eef50729e889563d52f272e0967f671ac958b56beed594c1abd0e4b2232fa954939040516052281b8de078dac453c4869c0839115779c2a619b475eda2504b5e68456f77e1d0e073bce855700ceae1496e827700c43632d745d66fd3494f9c8ad79a6c5e52ccbbc394b6b46a47a1baf23912637dc0aaec1b3c98722fb52c7bb25752cdc9b185d56ef9440efd9446ed30a66f4099277f987246b4b47eac2123c1e9dd39339b2a235fc584fd636e5b02d376f11fd5f65db13cf6e2b27e7234843abe266c2ec765c172775a5075d31904713095e466a829dde282811e6c384c67e6f5bf1a4b603983d46ec3548bb7f3f469e6b80913ddcf28131df22d7fdb3e42711608b96414bcc63929c96f845bd06cefda4b85e81f4cb2b5a0a5f14d6899fbb8d18ae38d7357acb658700b26ad18035e54c6f1ca413d42c05671f7d519586f69bff2a8a181a26c868e1c89fa9de46112cf9e6ffae8aceb66640d0a3ecc0baa64f73e957c3103d9000815018052a5e80ca129665f36b74166379f42da9366b136d2d53d541365bac1fe7993dc7942041ea79cf67a8455de04cceeda024cfbb3d55a56c94353f91d4834996b8b4adf999de02cdb7398be991a1a396fceb9a946fb661bb2b96b88edf7f949414c267603868e7becdfeb98f327310216f0753e08e324026ca3cc660f1fc64dfb0c466294cd42379219556a7078492592b3889be69b6acf54ac1a6d00978032544fc94fdb207f671b2b0a4bf90b954f59e8608ccca6dd9b34722c657ade4cd2075f644821da9a971a136c1db18068b80fb4bc2b0a81fce99ef2e6f032a345458b7c71e70f11e22ee5e1d95a0ecf72c61b392bebbb9b4f1ee17a9172f3f12e72447d4ee5625a5e3873b08ec9f41c3eafd2316591e2ea1e32b26fddc872f9382450cefd21c429aff5906a9fe99d25f6819b5c1ad22c35c7b7310603ef240df7c7a13ae2e2146a0a29a86c04ca5493501898827d83a015da3c072830e68f51c65406847a7f05e5b08cd56277825bdfaf2940a8b8c9e5166b36cabdc4a21328e2123c0302fb78e908cbbb1cdcfe72c257e3897df9780ed8518036507c73f7f134d0b9fb7461c7b03e51e9caeb6e90907fde1244970c6c21016e00e4b5dff22b2d7f8d0c718703400ae34e0157519237a955cb43eb17f0dc5b3e524ffd2924274f20043f0e22371ecd45fda7cc190a66370d1f3a1dce2e10eddfee9bf7c148ace6d3a991a0a6bce71db522db9e5ed0593a1de650e268f896ea5b67351ae703fdfc792759e88ae439b3ca9f9791fb71b73ee3fbe946d41c9cf00d09f5e29bf93b2ebd9461754c11fa720853d9a9ca9d9e8cc1c917695dda7f51bee8fbfbd6f8d943bc4962795f4ee4065170135a06fbafa278f8768082c87976c4f4b7041895940264acdbd34a16bd3fb604fe539df74f64af44b6b1a9b9e1d7cf9346931df6a7902994715253709b7fe50305a76013ab19a114307675a8279f51c4ea10c1b6189b82c85c976764c909d49491ccdb2c4cd88117f860ebb233121672d1f60fd9a6d5b47d82ef6717a76a914aca5740395744ed591138f587441a987a5b481a31a31af515660cbe1714e10a707ea055d388dc47fa1c4a4973caa971c3b15e502ef7ec6e9b8f574faf42af88d1cc2b58a83aa7ceecf8446dd4c3218f0242d49bd75fb72affa899d763ad7bec350c7af73d0f215afc57e182107ae87b67d19137a4bcd97e0d065ebd48dfc24b1883d097790bf465be080e0348b737f555dd9a7928378fe3b259c17f7fa5ab32f69ce2e58bef9279727d186d9481104df07d84003f44e36077014377727cf63fdef34504f3f0a74485d3df69b95538e2c9849e72f915638ec5a5b20a244fc037015ea2985ee3b1682f7859c3155642d97e2eb1e5c1a82e924983fbab4119a50390e7b18e6e76f87dde20745f3e15f2ba4c41d628c97434fc15c0e5c641e8248c713ec179bcd82aaf5f48a4300e6684433d14db61540fa68f7b23830f47e425e30a5cbcc8f48d903346b0994d1ad5cfa81682d1204c78cb761bdedc9b23164890c8a792a20465efd09e20be27c32539c10eda5956612b1d399d86991fd8fef1c5209869822a0bfd7574a5e15fd73046cc641bfa5d7e662a62a2abd6a5580c841d87cae7f0dfa489e261c00109b8e586193df55034ced3f61abd57454979a1185e4bb26ffff6fd85edd55acc2447eabf9538e4ca39bc526734f70acff1993cbf08b51a8601c5a8826c408e674cc02adf96eb3ba65c3858eed63c98fda8c7a4591656697ad2f2463b97c1058ee159a93218d3e0f2ee5570aa41e79eccf9a3fa627aadf7bef4ddf5733a777d4bea4929e1116511f621a2b2d4e0e011d89372f1e5ae2ca906861f775c580dc2bcdb1b98461384268439541b6a28261a2015b20e6721cead23ccc8e281eee8331fa656707d659828c6d5d023c193884f0f6307da23464f2212b6c64995ccadb803a92fa6fb8b351e23660385fc2e2b1085e996efe92cf8daad49314296c2bb8688a57c485d2d4d75f56387e06b99e5df636c16e9044493f2ad646776f2173ea5909227c2bfbb8284c5f60fb119f00c4ccf67259b6497809e8e3cd5c83a323aa4103","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
