<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7921ea4e912b1a2d7484d98a206f1b6bbee8638ddf1683c26f05db6f700941c3e3e523ee02d36ad52decbf56577adc1559129d61b2d90ad05175e3e3d9b604bc119b89dfe5e28168f95950e3719fbbfb896d9d07463cce4cd096cb3316e2babd7c92430a3c891b97f7b437a34fc76044311feea0db95a2375e52154602c3a106f9b4aa8ac478374c69d0d4694ea4f04a907d0aa61af602ad1d072cf2431675b2a91bfd5b74a7a8555de3a29cfc3a5f7bd25dd1d38f8da2df0bd947bfa2afcb78e2a6a385e988f4388f1a1617cb3a38996ca011d64a8f8002162cb062de019dc343a4daf9240ea5ebfa6ef75ad8844860c21b3b7a9306bbd91d3037b65126ae8d3693c31a8f00c2730295a3dc09e9d456f4af70fe7de8d453d1a06da7a2fd7d399f7700c65c02318ee60baaf6c2442df8cb0ad17961e176f55b7f72605e4881eadf523f4facd73025505209628b91be0f7f26249b2c6e3778fb48b616656e99feceeb1c6cdca7ee28d0c7ada48f543e032fbffc3b6b362c49eb75f03ddc3052a1d19d0ff1d6e6b546f9ebfdca784ea021c613468863d103da9b6f2ebfe3df7b887e12ab14ddaba83486d5c6e9a11d9657f6f764c76b83985bfcfc4ed9182167310655eb77ca05ab96e5221f50b6b1ee977ffd810e6e0b76aeba4c0459789c80a762faa2a40b2bfcb8f8bae9937a1aaa74380d9e21a16d81c65deb94db8e8e60b0e8c495051ad2bbfdba76a72665ce4a4602ad912c0a094a2ffcc0dbc1e22b5fdf7ea555652283ec82a1605f9e87934e28944d554cb27c0a292fd22259f15ed7dcf3078e8ae12d2967ffb1c3830c85d9f6c2604f82a97fcfb1a1b41a8987f006889aeead9dab2c0ea2b581144c126bfedd618a239fe7f746623fab7512e35f6ce47766f1ca1692e25731773a8585faca5fd048107aab7148cfe7a4d9fd2dc61451b5976309203f983169eaa115b98edf8139bb9c79026b72ddf35bbd2211bf21f7b8c28e65d6c7aeb0cb116b942011093be89f52bb1d069ba0084bab1c7a39c228bb5ed33fba9f54e89cd8cc9c99678eee48d87d24d8d3b250bbc51271f23e591444ece2f528908c3b80b58e340a84e3c9bc07c65d05a94b66daa0e227ed38bd2c9e6f5f0ec8da24d8abeef966677d1cac710c5ef63c533281bcd1b64d9e6b6652cce3f0def998cf04f1f8a90db957eb1fc001686126bfa0071a18d312098e62bf1f3ad9b50f3c9de61a415716ab022331657206c468c26edf20256afefc32be76af0c5e63393a9c735e56cbcbff524e75f3144b0adecc5f832f7cebf586f6580f888ae4b5b3138750a2850e2f5a29240372341379a2c9fa028b905c60d5891dd7482c6d8558a87153cf63a1efbb5b275ed703524b980e51615af22ac7e7eae5a00bda8f32c1d6544ce453bb6cbd546038e9a60c8186e16346a094a7590d7e95fac19e0b8bd9c7aa137dc44378723e71b639c21aa59ef505ffa72be42af6c3e923a4835c987160f357bd5e2bc781a538ea51c80d4b33df9bd34ee3156ad6a1d0a4d39b7b3dc106eb31ad5e51cbfbcc803a7d307a76caf46d349022d4fa843d8567a6dab798b7f182e79b316d84bcb5e823505f1d5e99060f4c994b9ed931d425b37a97eaac83168b2206302507a80386efff7e6657873501b414a10eac45f4f92f1e1c8eed1a5d9a7acd67b05b085df3cf0418f53784fecfb981c13eb51a3a83ad19efefe1d0248176ff28809cd2d7e0e69815b4b6887024fb869a9deaf2e5d798f08a743b4d87ca7bb0b35db8428838ee74261abf443ab0ea84c663a6001b8578e6ce7305ddd89efffbd633b15af3571791c1b80e63b01bc1acb811b5f7cd3383c7bbb5db6a372722cdcb791fd0efe41970e84b3e6e6eb762ab52e05eb60fb185ff96d9344dcf74f8c94c8f679ac55fca3b7c75a259db4a42510d66321b9b604e6c712a491b2180ea0262e8808174a66b1f00474806835aa66585aab487c6ca35ba14e083d001fdd27581e53a441889c391783d6b449ea9e3414b67d2bbb44430ab12384b37d0857c948ddafaa02550abb727fbbbee26e00064b7d9232d670bd36033ae466c9a1e21342fbdd29cd49c45e79f15e630434e17e428a30a1d41834445b87963669fa427f53edb9dc792bd9f214a8675c25a65f56e74f8edabcb6dec6b48d8051e8be390914d5bee8a78e66939ad0b0a917f935d89e4f1efa942abd17fa6c46a5450fbe8c759d0599a9f10a0dc4d7e4d6bdfefc81e43571a42f382be17b9c57158724f3cc89de7186e5929a71eabdcf31ad405f11370ec08f39657501027f6a4549590616deb789d63a57d76681022cc722f714a0193dd78fe3c6dedfa5ad2bbb45003b727cf9a7cf61d72632cd38ab7f2897042cfe266598b1ce94ed30a45e97bda723df9a10338576cd30ef4eedbb5b830e05a67c17e6d338b57154442340af78010f98a53b2d6b300a520bab198e41657a834c9dbe5e0ca15588727dcc9a417445bd7002d70eadedf181aaf4299711f3088a777659f7f1d79fb10e1727786aaa8dc42db0bdbf0001afde226abad657b37e4a5dcb1b8ae18039c3f233d5a5af54e5c07c5a2a6463f0579f21110d4a98603848b8bda535e2690fd71bc1675dc6837198ce32e7f43301259b29a327ffb0d0a52d3b6c086a8aedaf0a3319461adb075e74860aeda3e507723a5ce397cb042444fd3e3329f48148adad633966b574568bd6afc82adc037ffe8338c4f7bddf4220f84c6dd4080bdab21e9603a5cc78043501924a32401d1d6836a84ba41f9e82c9e798e71ceba9684f768afe6a8f36ad8023b0968c7d3c275b87ea0a1da00e6a0be1e0aa7695b4dfca33819dadfea33b199a1516ab57b43ccf3694890b37442941aa516a02c9a8bb4d74e5dcc735e8149b4aff87178caf67034d26613284ad9c20d010500490db47b652ac1d849eec24b761888153d39dd72aea31168ce34fc3e24d1697c433eb394a0060c666e8f34e2dc4cabf2a4fe220327f71796bcd8b42b672c0d51d03642624719ca21422463df8a975d75b06e4f23aae946bce968212812f48cc02fb381a07d25a6cf867b385523742583cc1cdb67054f1aa74d511240c64ae07be00fce4aaa9bc4123e8955303fcd6810a5ba5468446aed8e9fffd6f38e94b9b66bb54b35555d724db1bcad28087f015eaa52feafaa168f6eb83e3a6387fef5fa303b7dae57727c559217a8c2c785538288fa91c0bbd7a320978cd76875975fdaf48a26003316f62769b57d8a4a3c33f7c40c9766d3491497d8d5e7cfda96cf39a4b1d98696aeda39f71cd82f9c2cfb6aa3aba52ec3f68369c8ea56d94c930cdd0dd5f7faf7166d7e4b9990c197ae0d28bf4f0cc19c9cd7400d56620e55f64880052f23693369ad307c63b4e41f5aef387c6899020f99e2c0c889e2ce4e60e3c0e7b9c314e9da4b6687fc0c24be1264e2291d3e3531d558e57fba79c35b101e843edc826f057b6cf6b8468bb6dd965b7c8bf4ad8e8e7911147ebcfa9f66226bb626f2b48c5a2bdcb40c8ca98021c249a459b688d381abad464620111649024b9bc6bf64f4c12fdafb73aad1042137df430acf698f520230d1cfe4120af065bead4cd1893e578cc709848fca9cf76dad526ef2330c5310feaa00654a56a9c93b7c9dfd86ea5de6031956ed9ffe704fdc0065b6cb37b552d15d48158942fd2da9c91208785ce17c0a68fc94f7d7d491e80f19a088a507fb07f2897a6ad222acea0c728931af9a712b9466f8138a11ee60cc7c653ce85e2ff516ebb7d43af267dda5d939d6f5e5c12d3c0a701ce65dd335e886188908e5a90b8484d15251a9fee779135229ab72cc27e1741826146f29f02eb8369e71445873855cdac729da1479511555307dea703f0e7bbf0ec57851bebf2cc01848bede37dcd2d5ee87c6b07849f7d4e1c4e288c6635724a5931d36bbe9568f8536d9b7acf1d4a84025f85c5a3c66d62c75d0007ed3b8bd2927dba172a47c35609ff376b89fa148aa72bded42ccaf4cb25a76a6629a7884649d384df59757bbeeb318dd47daacc579a9fa382a393abea71bad2c3239a5445b82b0d5befaef4fdb4841ccb24053104af7bec581037534923c71d7dd27e5ba7dba536bd48a2fdcc6c4ba3f04333e973b7be6a59c8cee7e5775899a8f2ca1cf8426e0426abac211439ccd1aeb44258f5a71f2231eb3c00414861ad8a435cb723cda58201a0a8782843236d18661920dcc6656a2f2e68d1990e0281b8f685f641b36222c6a7087a2f13652417a55a1b1302bb5fae586bddc5a265b6e0261883ddcf99cdeec30ac30f0bc3a4e302a4c153c019c962decdc6ea13a9075b1461b0bd1d1267522d30d7c1146be28f5aa2bc885bf11f6cb96f16777fe8e40b72fe927d4c480a16cc210f9a68aae39aeef4148aba539510aa0c0998f5089ceb07c4d7ac12763d2898b91319904d1d7d061ebea1a2289739fe8995ab47fdafda1ef62759adb03eb2a396ddea9c6f6e175bbbc1e4f5b4c98819452b0c59e49d5cc1bff1f0b10cd93ecc1f0bd5fd06332c9f0b01fd9db6ccafbec8fa76ddebe4195690595b4d353f9dcdfaa3e536e19b6b60a0ff2e22f2e9c0de15c8ce43cdd34e48d821a88d19c4ab3969c88c3531995f0296a3e963db3076db1dc5f5bb5fa6356ae78784a92df8772bc4778fe36765b3594e0f944ed2b212822d09cedbba3723725d163faaf281a14d58d0f2bd6c13cea84791e2be68c63abb07e53ac6255cfa9eb4742f22b8fded18f7db625094890a595038e2885075a907697353815baaeb3e4bdd1b04d86fc40e11e4dd10feee5b0890d3b9d4d4e0c98550136b59e794cae98e97d8b5d060b66359b16d85150b49403bcf14cb8af0dff74ba333197b05fea0117abb60196e6d530eb7e1c3756d58812ab611be9697f43c649c914486fe8774746950c78fe23aea4b351ef6bc24fb9f8c0cf6fedbab8547c2d3e7a3a31b95ddc821a788c1608c0c26f1e352636fa2ba23dd91c533b704ad2ae21a210c8ea2d0cddbb34e52d8d26f3711113490fe5383fb18adcc49148f720751d79915b8aa9e1ff83533e8c4cca050c51cb3f7f6ebebf6d6050eec7a4531301d03cd1a69d6b86f8809281c1b3c40ea0d6f5ca76ee32c1b9d411bfe671f92962588d5d39d2ef29f31592c2c34dc67f031f2ef8cbff62c2e9cfe5554bd3401d25a24438325dc92b16e9e1466d2d4ec9076aaa8e05b9bdc0bf28b8adab63751c89f439574cba4defde3c71127b11ee43c60bc0f3e8dcc8e4cc2d06918f0aeb2878033baaace36ce86435e8cf093847ddd2ef03188f3857e94917bf9e5a43671bbc7d62e45008537ce69a36df876c4b8092a74d9506aeb8da702068e713cf4f287d0115efff6876b9ada6d5a4833e881e745133e05bb4424451dfda8fed859da13ccf6f1925cc05c63a4b4ee950f23130b620e652caab80304bae29871cb13b3fb6cac6804a5eef8b3573e9011e0784c836e8d5304516c4640331fa3f9424e02ecd9210bdce6d16443a8364cb006b7738ca4545abe2fcb4ebf0407c9c402f577e5e578f2f4790787cbfc491c14f011c52f17579ce8eb0c2233c990df2c940bcc85e38982e0de466dea7b8a3aea96b733886fb9cc3b46ed22c1eea36eccc7f1335c9596fdd725cda27b333d61a7f0624bc5a84d3501a36892733c85927692fa9c0df22fc5ebd3c146cbf9de7eab8f876a6e1e81a0a14482891d2b5e7f0e0c3048fa166d0c87bb2d9299d7b4f02b63a4a691cae4cd8b899498f151ba60a79d495dc6aaea1bad743263e58e588eef16b0af28736b4b5c6465da13ae948eaf8c30638659e591a6dad505a8a7de5abb7f47e6112c44e23fff15768d7696d179f7bf9b329698e038efdb17d4fdab6c179325247f6a814e95c9be40b8e734a98c41460640787e2e42070d815c55802028e2237a5488de4b12508b0e6b89f43378719898deddf427f6e54c3c30f5c5d43470ed3b6dc31ca5f45b658345d902f534c025be727fb9973c61b8a2eec3ffc62df4677c990d289f0b41f86132c01d635266846e0a1a264446f05d79739e159bd46432e71ba0ec157f6dc9defe859389d5de542f1017fd06c4092ef173793c913a10468c7c9f2d5d1ebabc6f72bbaabe8cbee9d394cdee2906c1d9c9cf24150c341509e9054afdd8557a318e2dbf020f5e4d888ec7a2c39e171232f3397b86f3f00ff642782d4c1c8b0901c9a0215ad0c17133ee5111b869ccf1af24aa4ad85c13117076ba9c1c37a00fcbf4c610039c3d279c9c5ef9bed4a002fa2977f0d3f1038e50806de55421c03dd6cb53859cd3be48d9fdf5dd6375b40ddb16506e40c5987a8061fae525981d0cdec437e03eed18450de6a3ef5a701da6da7e54bbbea2ea8777da007509e8fdbaa5d4af1dce91a3b68a031efc8fdcdaad02c9caf4a58d95bb2ea71a2efe7925cbe7bcf40177101b1f0564ddd6ddf4ee808b3ce4fd7345f14aba4fc50be0cb2834d4110cddb7b3224093d878ecda6526fbeab1344e2a94e0a375da68c8ebe03ee3e4255fe7a757f4d9576e0ab07f68a7fd791da678970dc95777da1dcf6344c851b2ea35083332698782f7368b2cf063ca821c868a67617f0f9a549f207fbc47aad306c410b863b70acb8695ae585a7ff73b4b9a8c8423697f8d21175ff44f55cf2fe53afdd626dfb6a170ada0ad0485e43e14f52d17d9c9367822e5f1c13373a6860c3c899352bad1dafff3beb25887bb2812d34402f9f86370498ae9c078cb6b69ae90ba8109e421dfbde0e66e3a45571f5824f465f3ba151151b4a1c5d38c32273c1fab7b49ff16012a3e8d5cb4486a218fc8f55a4fd63bb947c535671913588d0d5d098f7f1f58d2d2c2df4222d024b603b1bab4e14d726ba96f276f18ad15e1b26381bcf2f0a7fdfb6d016ea4a15745df32b25de7ce33682e9831b9ed204190792836b4a62607e4c97eba6d9fb862af9b2a070b940fc62430e07fa017a735b4e4417c8478da79d2f67cf650b65e982b6c60066bc4309fb1c966d967ffff8443ec0cbf8ae7d955128f518ab0754ae73850c86d1b1af8fff9acb582f5e51e8010321d327f3b138a4eab0168bc414ad9e790db0ba914162fdc089fbed05506636e2a50aa467f66817456501f7472580260ebb9f7f787421ccf3adfda32e9ca6a2830141176f20dcc9b95fadb82631aa1cc869d7f451bd2a0eae3681a1d92ba97cef3434b13ca44396d1686de911af516fcaf1ced31c3ca5aa228172c927ff214d1852dd022c6239bbbda4a324d2e37834559c0cc0ab00154ad79f1174ebde48c330dd0f4fc99d3c1d9720bd3b19af79332fbcd253c0d7880dedea324446c9d4776b3ac52401bb54ec339153007982669254e7b18b691e7838aec38ce052418526467979681a3db5434724da56eee1c7a45b788b27896f933e38e1f621d15e3f6d400a9c12d95a93355582ae7b4fb59811a86ef9f3693884b39b1e1f38f4b0de76b9a925839122e46c06241e6a15191be55679c85b5e30e9efcadc22dcc231d566550dbfe47a50b42db97eb5a31c9fbbeb06bfd4b405f38a895215ce67880c7ee247da69681661fa49d5914ee9b7e74a42f05c0713c599e524d4004c3018283187c4618e18f4cb4830af3fbe3d69fe2c5752420e454e71cda9aac75d8bca517bb03724a81e013b5bf08e502112a9e890e7ee85f365ce58f8e1e64c57de6579ccf4fd3a01908227889b3c3380f5c6c1c440bf0e788b35b34e28e9f6bc801a9d6dc20db81f46ad4fece663053f9a293697ea4781ef5b8e14b35fbd8429aafc99b527b48aa74f73e9bddf3ab5ccfbd881b2072d7e962002f2760d7a070293c4ce70a4f99533fce09f0a535aac70b813767028766e32e33bfd1276196046e48da8b3785b968ba8a3021a3564894a6e9e750177bf9ba66db954e6c1a397af1bc733c318785eb6e9025a1d2254ddd1325b98fd4e15ead918140693af1e5e7d091f4cabb25886e171c5b7b7806115e02820670aa16821d282f98338877366dda1d29ac9e18cf3e63909605a279659cbefe4f0404c6e3ec777622f013592d8db27533a815a75720f6d78abe9490b278405b745cbe43440df9b89d27b21de2371ffef97380f20ae3fcdbcbca73a3f0ba207d9c1d32d05d8c51099ee0fdb91b2e5052aba409505c8d1a274a11c3bc22dceda8d8e65ee6812a3b217a614a28d754456a88ef2e91c1c35520d466f4250e3e1f76c63cc688bcce71754c43b713d14a1d994e88d9512ef34dec2857256ced7476f4b8740cbdc096a2c5145c50d4a9b0cfdeaff0656b98a43d95b2dbf2955a0bd654bee732598e307a5d775226cc1f206f7c2ba085eaffbaadfc4011a3c6f5e193a73c1d8a881508812a26b6f72139a46bb0abe866f6163d9982ddea2ee5688fecf3276e9cec50065c16a4df9fae8b1140e158a95697629e09dc9533de7adcfe3aaae711ae2898484283d2fb02508f2d70a0a7943a1f7a410357f98aa5f1e40f042c400004984e52db8a9005dd9cfeb17297f6c276ed23a6b291666dc8b224befb3fafd56416f4d45b11aab8d0dcc24ac04681f617f8cc153d94510b1d624924ac5e5375ad7d445c324ab3875f2229d14f6b4160546362c53d9f034c2ebcc5808d96b42eb72edfc91af500d8c0a54299588dcb69c53945c9c7be61e6a1432bd637470b81c73e56b31cbe0a4fa7f0a4af4377fc23e4736adcbd311952b6759af1ea3c0fd450acc51d1c911d2373191fdf6a366db2e10f601f6d3a13a676f0148e870398874598b7b65c7716afe4d9e5d00d8553de592285c9a6ee2a84877e347c240446703ebf160a83ff279a35971f7a98d06df2bc106e0e7ea7b0d80478021d12992093648fa58caa540f25c445f1ab40042ae4b596c3ee6542cb899002f0cd444a9bb86afc5d0da5cda8b248c123e5453987d29101aae6f0771511d4cdc4317c12f044827883373280e1d62f4f002ce6d00a4acfbbc969c95d40399ea0307781b385bb81701fa4f9a57abbd2376c327be6f6eb76281cdb53d56a95c24944ca877f5bb29a97af89e406accb1417166641ebecea03342e209ec8f18b9054d80a2bfc14f4889024e34afb87629b17c73f2577a7950507124abd1cf575f36bcad45f2d1905010714c4fb0bc62d85e3012d5ef25b2c52d68e0ff42e2ea2d9e56d05bbe46f6ccf010d2ac418efba1c31732320fc013c0fcf9846db94bc3416c844410cda4bf19fcc6523975bdfc39340e1ac08025f4cf856cf07e6242b20b4a73e4dca338c7b53c1374ca2d38a2e9d9bdcd3778e4ac020fc8443bfa913401468ce139f8cb27eefdbbf5793daa71433b49735a90a77e513e54fcc3717cb820bb0fa25fd8ea89b30482fdb1424f2808a289294a7f904a9d0825e1694cde1fcae105d2d90cebdc780a2c7ad870b3f0e5ef174c1f157f24a3842303c0b8349ef2675363adde49a1aa9878b804ea185fba0b9c0f03ef5f57559dbc4e1be5be268b30fb6e9fe52dc3a6c4b76a8e3f73cab1209edcab03028726d7f3467697ff954cb89c8db326cd3b6c3f10850234c2b2a47b666365dbd66d871e9e5b7971cd759a060ec20190a42cb9b3081338ed2d6e96b466fa445c0069513c2eb5cdfaf07d2e3f99fee45dd7127d4934d5b62ca5376cdd44297d9c9b2de45ae0798d0ad4717450e461a54a17e0847b71cf75179b3481cf17fdc04d9f8bf181da28364744cf5af9e82e57d6c7b38bf063c254f9a821965d7c7792433968b9e98ae436771a9f67de9bbdb8935e84274f1b4c1e25eb236727bae266337eb0e09b2c869299e873da15599b29dbf3576f7a06cff5575cd08a9da9508c90f4892621d449422c347cf1dd65466a209423c3a8d878edebc42cc03f28497100ff080a6649986ac9b889a8fc7701ec4d655e9087780cd0d2dab72bb2622c0d772e60d97445bdc27d77d7a4bf9fdbc3d221310e8f51c0ad845a40af20aeea1dbb883b913bb61ca681fe1bd9a6dc6fc63552f28ae2d039d5eed9654b9c6a3f1ccfc1c2b3fedc3a23538a772819deb063204dbd0261b9aab039bdb1d89c21ecefb1b60c43bd1cb57dc23e01127f1442aca9349b650a4960ee0f05075e15dc7a9c166046336051b8e7a404dde8ab5eb4234581b3f2d7f8c72ab3e1cbc0d51908f1898db47e72b6d715eba0462240497a8ca32a6b035853fe6b6f3cb0b8d23d8c87772411f24a0d4c076dbc4388a2bb5164b99482673c6625a517f15c043eac3bd8692da2e0c335fa55b97b7f3a1ab553637d8f91ea0e539a9ef5ae49a870fde24a384163bbf53ab521f9bdb2bf85da0e76e867311aac0c11328b3bbcbc784387e87105310631c2a0842033400badb132b193ec7798356fd5b482257cab139f6f817b0af04b046fbb3edb96d2bbc48fd4d18e592fa9d3802ab4397bcb03fdc9ec112308b39539c4ea12540c9e5ac5dcbfc9f36ecf00462a21a2089f8c0a517394f3483b26bef4734ec8b0ad802b57f75a7d20bf34bf6cacc6097a3fa61b8f80566b91d5abd2010bf7f600ee548306690897d067f1e94b6071d8fcfece7a2f465441357ab6390e221ca44343a12880c3ac6883f0b52e8c15f3ad0be1843f32da5e144673f13c6acf20a623710eb60c3bbb73139174caec763ee750a8e1ce3b3b05440d67d445b9ef1fb8c28398fac6848ad7540e76547f2f2883934a46bdf4d936b2266f47f90ae779dcfb824e8d036ced087e36f59eb3a28d948077c3ca65101ba67349a3c411241c2e997ec1cb30c7741e1eb88b2c10cddd4534ce2b095d93dcecca2fd2633a2c0a8bffcc84ad4da2b4fa91e9ff82276dd402e925d3570af42bc14efaf7024f55a9c9f0d3daf9479179ef0ac8dad0eccf8ec8dea7118dca0c9ae779051c7d53a3f4431dc89c7ced155a0adb663fee125ca9df7ce98bf3430982d39ebb0153219122fe03238e088ba8a87e2ab71df58b5a621d2fd5ecb92629df4cd46aa5ef7071533aa518d263f097902034b327f6337f4258f59d0ae0257b886a4cb705b1803aee94f03b73fc24ddf5826c1c184cfabe6b2f699422ee1dcc58551f6502976e94329cc4c2261a18df90dc43f133951b54d7bc7e37fa25f7003546316a98473c8959f73630111b4258b2fe6fad4cf45169b1789724776bdf1e73dae6b542f26197a34c1295e56ccc1a541f5ee37f07a3364c9083c0fbeb722377c9faa7c69bbf6b9e1c526685c6071dacd96f62f35ad56beca97e5e0000bc5d8ad835f31c00e0541ccf60713f0e3d0bc59919647804da78c2bc7be1f5744854fc1991658cda73707f65e4bfc66af3861a6410e3289e97ad30076458ea0c02dc942b30404231b962d40f07c900e4417001813b79fe4a1289dbcf817a48ae803f8c54abef8f2a4f4082906ae74a9c74c017d4c339d7f3fa5b34fe3e4a072e8a23db021188e52af9091a71a4ff2963ea8dbbdca7f17fe0682eb50e8649e8f14de33baae1fd983456b719c640f2be9d22495c04d7002d00bdcfa8240154e6c9fc1bed73c2345c3111d0cb7753764076289b72018cdaa075b448cd5c7f0c293d3b45e62ec512a5f69578c03e682795e9a18109e1471a7b6d1ec79d40a56a3d866117b1cfb4b507951d2886fe9717e4c300dbc78c0cb931812950e1d2968f9893afa6faa0fe37b54d543cc84927531a2a296c9da7d5c1f8d82859d25761c45d02f0d5d9bf4da586d9f64864b267beb4c4edfa1192cfec0b909e0c78ed8cadf1ab42dc61ce1099d43562956ba2114a0b34d1a9efd58203b0f9024bbb79700027b4811d6c4205b6f84dc72cd4af0773eb56a0cdb535d735afa52fb0cfcf2fbcdb0a30a1584f74743a8cbb8cf7971ea0158fc6352aa73a7c341383eb958be9a46eb653837447a485ba009f4ee1cc9a071c2ee09732599bc861f2058b22a0aa3a56930c407b6b20cd30cf7debd157f5b6189d103642b4481dc01d7daf8daa0069c876ff907ae57938caf256e5ea53777dedaa74e65cb94ff91f4e486ad79c7a9075308a851e92b6796a3d0d71b3c6b2746fb2f304cdbea0ae4c717aa038c6a6165c586fd1b724552b162a8bdced8a0b8404ca94c5adade6b63a60839b095ed5421bd54dc6f7593aa30a934a42f55769896de4722924d91c927502ab90fc9da03a79cd4651fdcce529ce919aa91f49b7e497b636bedcaf7fd6fdf96d312659b104ca3702e7891db2135477c9c4004afb4b461ac6297bcd71d27f498a90ca03a911e9172fd56208faf79de30614d772c44005f31ee6285d9fbfc3b4138af397d85dd66170fc4b0df75be57bd7a47bc3d9e7ed04d99093e7c1f64e30fd625199444ac9ac2eecc97d2ee90878713d0768bda4f5800b3d5484dfc82fb80936b2dcdd60d10ca931611f0c0fdf79ed042be8651386aff1b2d2775484c32dabcc84d0077ff99036a64fc9fee3c45c1ef48f05648a5aa128cc89932e9f0699e08fe71b4fd3d21c118b7fd8ca2d6356d0ecd65f64cb5448807603e37448443ab63800099d20ccd4156e5f5ed8ad90f001324854f746d9f005960eb89004b2bdb678f0e19296121f0f7b7454235292fffc2fd5d2ebdf1b8f040679904e444cf23b0a7bc89c23bcfab6948b988dd035c50a37b0f6e8d0b0679104e280443ec28c32c1378543474c2a96cf18e59fd5c5bf8b8a2fcaaad982fdc02d6c59cbd8e7bdc043be0d013356f0d64bd50410478eb445246403034e60b7d326850ec7aa570745db22acf87c51641002c2fd99b15d4481be0e6cb4d88bb2020f2005e7d8ddccdb4ca3ac9f2eaa6016f4ca18afe67f0d8c4f37792354a495939191f7fe16e28ec6fffc414b6d2fe017400e39dd2288e24f53453656d6fac1eaabe7aadbc839499f2c9ea1eb2782d975242c7272068dc036fff372f90bbac21e54e3efff99e4c75cdc675de562b715f138a9588fcbf165ac1717d348228818a555256a63c68715dce83d4f9986517b20d18d7710dc00c4a0d763911b185afd17f529aadb6757ac2b2e68412cfc675c1974c281d59450dd57f3a6bb22fd14d05b84d871919ec9397f4a6218e90d573e0da44c2befa9cc06e981d114acac7c0811185e3045d6fe677b7670f669c531e128d1d47162c13507bc747455fc533bfa7e1c9b41ecc9fcd0e2c1185d2d7a5a3613f8c621c19fe7e7df480772a6dfce210c6d3053a24a309845ea7591cf98bdd367a13710cc2fea116446687a946675acc9c73ea1e75dc3a3f197f1ec75b58ab57a09a789469bcfd1713b2c9d6dc68d66ea0b8a6f6a2d12ced511d69768eb9f16e3dd5a21e7bfcd816974d44a5b7640a6f21d176d3a9836da6a99f13497c0604df69e5f128cbc71161a5acf02a35d8773c455d6725590d51a5722d005e7c805916546aac8c4b2198292e3284ae212db369cdb221fda773dc5c7e331d3af9703d8a119cfbf30699c29a5a23c2eb21598e5d1f65e285d624777c1adfac462d09ba4d2bdfac2d4ea6c98086583d58e100faad8c3806f8bc17c02ceaf65092a974ed3418391bfc0efeab3521b5e1e4abeee99fe239aa0a280872e1260e57349ce236d88c44e25dd17d2cc8d2fa2307c5bc76424a6f44d0c9bdde5207f3e62be5546d309cacce6b3a3212c220715955522b3ca0395a368d728b088ccc619cba3305f64aaa63157559d9db7457dd9eb6ef23a94e1f5e16ad54318f6a51e2aced50e39d2b7d776ae23954177e820f2865b99f69124ec8e817b8ec3b82c4e3b47dc2daf3ea4992a1677952ccff0d71ff84d28eff806364a2ca573480983750b79d3855da821e2097df6ec308c43518c96f631d3758a735c62e22603a1701a0673a06768a46742411286b2cb0937c5791ec9a0fc601185a119448672153e9c78994fc1102f0259cd7fa9dd32dee75ca187b76916ac56e5f290365337c01c2300fedc16f6ed38ebad81bc822f41d0f334a2f66105d66c06701173c907b9c5ba7d76aafe6d70a2fd322456f5e81daf934d5aa23ce452334ab95e6476b3ad56a346627304e8693412a7fb69bdc06640b66a3473b32fc4e9018cd0aa2e82fa410075998c366a60cb117cf595dbdebec2383ee8e02bbf24c341f32d2512d10682ba73b816189fcba00074131ae1961251a5c64cd0a4995306e85c3db414e39760c9b02f31c683af99c23798ad147dfcb00dceac5d857e7a3f38b142656b855e6b460786c1917bc52a9d54c2ef30a70e74d2af71aa169291416add07a53fb94a8f20a760b8fe4f254959f72de2ac7f3958512c9bfebb86e005940501504b51e29eb150e31f136f702e81336654c7dc1a6eadfc6c3fe6a090aa209a303ca77465a3305fb081fadf3af20969fcfef65333ee188cf00724959e184daa8740e9596b6b35b736d451529d80a2bdb013e26b414dcd66c2cf16c4a48337c0d8abe6ea144234db60f8d34216c45c6f44703d1fc0af1e7af5e4991fc038e71ca9dcab5695680eed3e2478d470ff3571fa2349ca38e737c783b1c8932dc7e419187c4273f2e229bf4852e3f0eaa170157e302a5054e97dc84fdaa55f8882563f396b0c13b41652eb370f4945ad3e87263292e1115b1bd863c6ce7065173eaed941d3b4932c1e187cbfbae4baf92675584dc1a8dd859a1e9dd3deb9494f154866e9d0d7de472e7ae3d12e91f0920b035c87d1e1535743284bcd0d757207f855f95e563116820553440d99ea1f5ab56f5844146b5a0f6a6c7170d9fa9edbee53c969323527b6f707149021bca98f16d446ad28994447bff5c3b6d5abd0a257d422a157014773886a2f374df15bc971ad1a241f9dc1f2e4e2dd46ec61d1ea254894606250aa4d36e5afb11ec75b780d039936f1d5834fea845d5a0f5bb14753960de2a27c592709cbf00449caab3f2ae639bdfe65983e05dd22fa670208d8701178a84b847d7e5814bdd08e7a244ffb53f9609e42a6ff720731f2070ed9ac0778e43797a4451df4cb977fd88f92595fe06b756219ffe07b78f6dcf727d2b98ca26f74a0a1e2f9a2fd55e493ceedbae0549c7d23e2caecbd0226bc189b7d9e80728f990960ae27f6685755f416028dd32ced9d5688521256af8dcd5c94f7baf95523d783ef0cf33c38ad712c9f0818b71f6109adfba2d9a5459c8ecb7be1f1f1e667fd20d2b30f4d745afa60d5742bfca29f2406d0232716c7db7db0dce891e68623af925606f3348eb86f546f2dac200a99b289600822529c7754d9b1e5414765ba94fbfdbb73bcac59be8da643a0b02cefb1d3a8169dec9354bf6041b5c6da1511994ef0ae83a21de25768b880513d30727a2e74165889ae786901b20981e36d8d112a07bb73b6d7a351d2f375fc8d59350dc0b4e761538383b775e7d0a5d8ca4519d21486406b80bec8a26ce3a3793e54a4d5a990325b7c73d9fb3bc7f8ffc33f17edde32e9f4ffe2fe4697d885b5be73a01a6f12eabfd46be3a252d312f16fd97350b93fd44d4b936b57a9695227426cf19315ceb62da4b7bfaeb17cbf8907742da9a5a11d0592c9d58160457a396a0dbd0cd64b7dacd6e3753cecd2d68dd802ceb007b9e67d155e11c28ef020f66b802e7d1f9c725d7b58995309c7269950842d6f3711e1f836991190cf3dec6a6fa1573dfeebf1157ca8589650158013018cfa7c0861467cac241a1d4a3cbbe552ed7aba2560d9e56a4458901fb9b1fee038f46da6242c22a4c7f5004def2bca10de9383f04ca62224980a98996963497629409e40ceb0f7d7f2329c489d37e95b5233ae976a4c4691653d340b4e6228ad8aedcd256063e1396eac3fb262046584bb27f6bf94d3abdfa083007f7f991b87e81ad6bc728dd190a75926a8a36fea9b7c8d2289091e77f64992c8b7cd054aa2cd47e5ae10111ff2435fd353901c3eea697c3a8fee47e247642d5e0597ecee933d8380fe913c4fe3a4da5480a9c8d26667280581f39750c389b9afeea13dfae23beb6b1ec1cb1e6c8fa4de5286990e790c15265b99768efe7ff0d34cf6cfb91247d4ef3548573f5b330d023f4718e0c7c5a010fe884c49997c126e1af61d3a151c15a445c0cc433b1ac5b56f08db19bc51d79eeddc02a6b72ad712fd46ee542315e8845e470c5aa1ab7af425ff25c1d84ba86f6f83b74c55404be42e3dcaa5f455022be3098b6b934b7bbe422d89b77d1e2462852faa027d71eb2eba67212293a51eac577898dd2cddd50aba7de0d94141b6b3760a02db09de3118a225af994d228202d2631068da40ff00b4e31d8cdc2e7416024af47aef09718119d038004ecb23f93d6bcf3e9878776101f35da0298d31dff85b2b4e51475a6c370104486192764aa61ca5483f84214c33366cbb18e2ed14f1f192ec3c370da3d0dedb9bf87e6905b32c413da2341e1b76128ceb95d6678e3a5fe0ab4062927ecf3644920baab0e621f7f9249f9cdd643433bbf0a98b95228b95f292eec3db686e6d37a10415ff78deb8db7775a9f35c76e3eb2c96e7c27a1d0ed30bf4ce591347f6ec2c1378aa3c7b9568b99ec0dd4cb8d569b74a3fcb3026932a240a085bfea8f626b5caac0852d53cf7d638ea019b0c69c0c23a99270f4b61ccae8313a8f8265bd51f57f985c52b71ba81b61701b8a3c212a3c74c897d86373dc0f6f0e27b642be479a366a01be9e34d5664eb816a4db311d38c3bf1228b31c551768b38f7051b927910cf2b0024229f95fcea4c99ce96cf5714ad2d3b0de3a7ae4d04be4e1fe928632164e3ac389527f3535d0c4b442489456d6a1b32ad95df9ab88f4c4794c54b2fd618cf5fa5995fb4426d09e500bf3ef1eb282fd5ee591390448d16eef7c1fc4d05af56a438b8e4e6c153f5f9a147dee0b9fa267a09bafaf8dac4f40c8de7329ee487fac5e99205bd2bc1d7930cde05d162d5057afc02d3b51292bfbc223c96988b2f68802dfa9465ab3e032dee184c932e402ad9c9fdc43b7e170e598f2dec03cf027a2d80f8a1c23288f90f35cac04193bf1599194e7adc4e653993c7df396a6b2e7c9c5db811b6f7ff59db5306b2aeaecec00a5843dbb7caa08484c36a1aa34c7a478ab03e6e05598f7b9d700170df423386541128bbd4f83024f9f9ed48da2921a95fbc564293b5f6e7950cc2f9a14a90d7efc1308ecb278b88f757d4669261d8eee3a380b40bd79a65a6a2dfbb3fe252369f687cad4a5aa186b93309976abc89ccdbb82b35feca89f8cbbb35c275dff892a9b4dd90f958b7c86aa045079213cf8001ceb5f7ac43304db69c972afcf80f631c229e4a7477aa558ef696ea92d5fefae1b195eaf4ec280654d0fbffa155fc3b0663a1f25edb0963c42304a63ca6006fe8a7e6f1ae5c74e26eabf2aa5de3c08d79281b5f2b88eb1659039ae939147c0042d855a688f9989364a804e6b776277e7c456750ceb52dcc1e73be598e4c3da1571b275cd5f5d7adb6ec54abae0f67cfca99eb6bf7f3f36c752ba6fa235c80925507e453be7798c45120236b057fed73edc335690a5e37f16cb4cece83003c89c375dd4b843f9b953174fba85ebfe9b063e081683c55e706457783bfa2d288ab68ae256495f0983b4aa15169d2584a636d175ca3725047d0edac3f1ca66e1440d2b5891bd52d3ef61f84315b328c9c5b35b1765dfd72a1dd95e44ad631d056cbe42665b99d97f09f672eaf5cb870c37b589aaed25f4a4030f1976fe9ded4b1c1f5ea1ce82e3cb097d122c836843015532aef5b72197068f40a2757361a779be573c8ec1d4fa86608b222faf305c6a04e6e43597a6f2a6a2c33e44713dc86649f5951a401471cf63a05a4dcf6bfc12ae6b9c31c538fd284cb674a95c2dedce81d0848b878e23ee8d8d226b4326dfbf50a9fafa938f8173a24b79ae07257ce8cc5160d4a9ba3c9e709cded7ac293a028a4079da71783e5e9d8a43a4adb8b2fd729c5bf2f2f7f5d7754a2f1ce8651d45b92df048301cbf3fa88ced30f0e7a462f6d1448561d8e259f4d85cee3d0a20e9bfcf863907e32e40272256de1dc234d1d86e57f058d0e4c5a743584b727674752116878e6c0a9fa57c6317cd277bd67f22e897d1b4f9a89f9f59440ce4f33ae2a90d98ea6d0f9cd3c5da59f481517beb34dacd4f8a94bfff1f7c9b6b1d4a2a444e4105fcc982033e58a8f4498cee0e3dc6e78d12b13f2b4f1aba324d43a26bccdbbc22bb1ec8336caeb73dd5375a11c2f5ced867a083acd6aeaf1fe8643b28ebc5079f84019a1a0b0be621997ad6ef52221ba11ad9edf53b9b5e87206132f72f6b0cbb44cb30ca87d53d16b3227bc2c7564325debcae66a82a262e089a4d556c0bfbb91250a0fff358d12e9440fb284d55ee7352ec01459d22ffa7094fee207d5d98fecd14b78f238ffb36f5a7dce20c3924f4b241d7e483d4ad649d441a5ceef810f3eef82a73cff23502f039c882dedb839c1f59f3104fa7f83afac43b2aa9eeb11b285674474ffa8986ac7e86e37ee5447d7a32680d5e3d3a8e4187bf0861e0c3ebca048f976beeb4c73cfaab69004eb56331e37ec16669b957a982d2020d14299ebfa743ce61e82cd53cc14bbbe75a1bc5c9a5cbd9b078f37ba8b2d737f2313ef8adea17c52eafe32fbfb48917b210917b6cb77ac039fa55add59731e9a5937ac1ef127b234d0b0d01aa2779bfa2057064382f26eb0abf1428500928bea48522c6ecc3a5d9122ee3f7a46034a13adc671039d8e0925e193db19eabdaaf8f314f8efb3c298d821be4cd1562db3c292e14e3e61b6d6e5876ef888f8fffaed01815a26bb2ab3f1917ecfea01c3b592441a35faafb1f114786755c96573b7bad7913b1f2ba540a9cc79cf417e12b5cc1c51692398421a3d00b3e7957cdc7a73346eae996cdfd6cdaf4bd674930e2a738e8e22f006765e1d710181b5517a7337db9cb26c9cbc90f9749398c59ec6627597d6472a7cef6359879a0978d24e598b7fa40aaf247e75cd5d193836c822ed33067d7e694ec7487bbdc5e8f92da404c02489e48fd9e153b46951bb72d2c97a1e53ab9a269afe39701478c4a0e512e9dcfba2152bb33c2eed6ae1f88c9d7b2f7673727fc22e85ed979daa17c918e09f4a8b5aa72017235c9dd87ad74b1e6a75ddd81d1e1e1c1ef19e14a7ef1e4e6593140469640d07c10539725de1d4c91e28b435e3fe5924f9a792f2fe13e971efac5bbe0f1b4a04c5745939ecfcf395b49731e7e96c6df7ef2f02c3525d6f93d2397fa6bba12840be0638cedeb89bb61cdeb533b1e9cc9f5560bf632cdbd2b8830a5595ce8c1014fc4c3a32fb85873b4b8b7ca6e9271ec19ee3215453ec4906edcd8d17fca578291d1d2ef72b0e4d2177ab8dfcbfc7ade8bcf16060520683e62d884f8ab4b17597b3fae9d19f0ff8cab5a37670fe84889590344ba57e50beefc9fb68b5f215752dec8e0f2e86354b0df124d90718125a968d8dad9fcd5cd1528930d61cc85f8dc0ea74bd935fb9b6877cedfe067fa55bc42f00c3e948badedb123ed0f1a80e50bf57fafa086284bf3ed0f28ca1276e00633bac589cde2d7ed3ff3646acd4418f7ec4082e8f804cfa1e817dea175477fc988981dcae94d037bc19b4b3750776980139a4fec591ce48bad1227fd7e2deb5011f895a6a344aa195856021bcbadca0e6a4b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
