<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5b790e0f9034b18c2bf96bc2962bae6f15488c1bdff17f103dc2b8534d813c6e377f34317e0be8c988222882794c40fa3c43933c146b6ba3c9702d5ad9c2cfa56788f5aafa73afba3fefd8f982ef62840a23f47cdc0fe8a8a431bcc8f5752e934c0a657b7b3f8804d312abc0c3cbec7d8cf25669e85f55c84def1efa24ee4f83a0e7539e911126b22f6ff979a1294762fc5fff3ba7366ef0f755a510ddb2b055e8ae31f7d121b06c213134909edfba85b9fba31531e78743f1f68ddcc4740b54dbacb208691e64878dad62d31a031c8b8d0d71270be62e34a0465adbc029dc330bb60272953181c1b73261151b28c315f7f4255b4997b8d8d8366658970f4ccf701d4acaf2262af01d1d184e7f4570adce0d36c5a9e41b36ff61e7f7297eb458ec13d09596e86a87eaeeae4cd9992744387cefa55902f51341bd8bf68ccefc5fa3db14923715edc9b41ecfbb6720804103cae121607f6742dffedfdd2103828b0ce855e9f31b91cfa7939eec305fbb9966843a983da4dd02be5ac3e0db19f6b1653493a86de6251ddb70e9365f8b08c529e10257dfc03193440452ef160ea08da1b4a223bd2de721d20c3326fa2ace42f89aa431fd9526b583ec35fb0260a2ec12be6d8052c78d07a2e6648bf723905b66b69ced63cf1b1d2ecdc68e395b257b6139a546e24127d60f951999b286687a21b45a107f8bcf88c52bf008acdcf83f4a2c1240de1a5c031a48e932121403d30fc68a807a9accc95bf3c2e1e917c3d1e86571345dd373c3fc5b32cbff81211b270afdbc32b9d79ca77cded9bae66d5efdb40466a528519706bc4212b2b1c330038909710a371b76ebf3008b2eb4511bbd30df0cd4a151b6cc29896445fbc0d9f92690cd84ecf0885845e33401e1acd89a69344eb3c8a49977001913273dba5a2033d4edcb292355df4c65587b18351d19ff45c5ec08ee5dfb2987f1af6fdd455f2d9ef55ec5be2bd13b0dde91a464a7693fb8b1e508254c1d8c6d1a8e35154a6f12d1d6566faead745a742b03e1f689099ab74851356a263410a2018813872ec4a57a3d7e46a417747cc821c755e7aeb16f5f91f23187c028d00e8d0a5e2bedcf0204e1264f5f4077e88c1f17eec60a5c30735ff711ef4ec883a1ad0a6dc0b4914e385aa587ea919bf7fa9d99c92b1ee45e0930cd347a7f31bbd7986e620d3cf25010148dc7cfb29ca12e9fc2ba1f2735bbe3b7fd37757219db28907dbd07ab336c285d565e5d7057435e38ca90d47700517987df964c9d6b29d9fd99b85477f77a66813ea1f7d1f8dc220f99a439bbb06994bf51622efed24a5a54134873d3905412f76e501696371f3b43999df01a0e377cc925b372577a3a95dbfbaa1657dc8bc34d3b2f46da7dc387b0ab6b08f5a56194aac7e99be8957dc8a9b133296ef9536a2a4f952fdaee81df2e2b9f0d2d52db0bb8891c553a6e11c42333d979f101341fbbfde1e637b79e540aa1f7e7f87d7b071026b00934cbac114d47afc494514a6677016804544d1b85ca8cd3b12c909a9472e503c7c3729cd156fd9575a5fb05dc968ab8f9afbfc3795a82900ae4574b671263c28c913489a9a54f3a15452d8a1a5e801730003e2498541d2c0f9013ab0b9d33017eb05d5d25c451119bc2f04ff14f1df266a0765c4c856a0acec50b5cc4a45c066b2b4d44d46e15423745105ad3745d3cad014835a2173248203046bbce2eb04cb1144961e986eba3c3bee0eee15618ca5d6b5cf02700aa43cf04e0241b5ffefdcf133a402c17a5020370803de604d8eb1945393b3ca73bb1797474ac3c02274e98b603df4fdcf998328197ddf7a6c8c80ca3f9003e5e739d34a93bdb73a4cf7282642b15f918f59404c2cc23e83f8459133b17a750e3a5b8e815e80b966ba978334df1ddac2751446e735ad24ebb1276ec43ce7aea6972a273c481134e99b1cbea1ca0edb40bf7dd7a7a077146af47b34d88e6f12e34f5cfb4bb2f0cd254d523cd7d09b81e849dd277a372a02e6f790b51e3bc40b48086cec4d206a2bb97872f7db9abedbc81ee9da1a46fe598c438aa125c937cc836847a6418441cbaa6ce81f8c263d4a044fa074ec9378eedec754fd775e8b0ff6a3a2444e5067a2bf8caff203c5cbbe25a31c0f024953055b6590f1b21c3514fda7f5bfeb4b98e350cb479fee373f0892b2d5978a3f561e1fe067c3ee296b078bd360c5cefb38c859c045db9d657dee1c1e8a1f641fb199296fcdce5911232ad0b94f6bc4184d7b582d6d51c76ad478f2771057fa3adaee84a7eefca663d87ca74a7591be67d4d22fcee82225b196011d35e3f3b81208ab125d035bf1115b1e628498aa05da9e926ba36bafccb86e1252732c90d3c815f843e8ca7396e4f80ea0d9a2f94caefd5299dd5639997391630f1db88b5a314be3b756e40307290a122ff2a1304782500402ceb46710f6671228a1ae3c9eca636e88be11c9c82be6188c96b403fc83ee55d53154619a878b63bbfb5f1ac6856e824637cce798fd8f8193dc12ad153e836d20546fdbdbf8004e7ef7abc5c45c2d2f2bfca5c55022e52f62f5c4b77858a22246316a0f97439b240e91f73ba034eea28bea936e307dc76474c6f496512492d448a73ebeb7bcf1b379aa63e250c0ab6925d84af295b7ccccb0d916a26fc0792cdf396e3dbe51e752df0581aea385a5188498b458b827f2867af7758a12efd81c203cd89ca996428161b0e6a72dd07668d24741b8315fb4bbad70ab834b214fe49a443cd605e12159baf4ead0360bbc748267d6a50941925a5c4517d5efdfcce96a20a1c480c09e39c98302bbeefbef748f875158e3315f90ba68c04083e1009a1ca6cbe3a9e1e2491b46e655b0dc0e82b913929422097e57c0747bf46e31be3fb596e9fa44abb8107ae27eaf30cdeff83c5da2e926270492d47ecacde6a45bc11f0e900a3a80c9946c8e0e1fbc48ec4287ec22aad23822764a5c119ef2412f7917fb66f7f279a31dbf7f3bf2bc89e7626950784677ac378043bdea84c32452d07951337159bdbec28470e0ca52460d4fedc8cf2b34de8cb020d7dd52cc9cf6ee791226fb51d4db4b1b64cb9880fc593c23fbf343f8058ff93c84188c5a221f8816bad101125df7b84cfac26ce9d1c1db417fe28e386d48bc66aa7278ad37c3998e7925c8ed44aae977f84f79edaaf1b8d42a463ae5d916f63c8f7d8cc0018b8383b5d26f075575639657e33d5ebd8bd36591f3418c416d00b9ff31720e30c14c3fae3717f5f4736e9e062912bbef370ee120cfe512e0b8c03cc330e4da153cabb92ef45aadb929d2fbb27b410fb2c18d2de6f66f7dbe22f141e06054e580b1586599506439406f920e930162fdd550d025f3c35f335632e6b032cc6a19d397bb22603c2825a08ae1e70bafd7bc559ab77a2e034bd21fd0aa1d5dcbdbabd2ec5e193427a20c727227b0f93f1d02ff99a20bcdc4ec6ab18c56af5e4a3f1d1f380237ad0fdd0b5c180c2136b8e4aa53f374c0e99a4305b844154375ff34932262b11b9c6f5485929ae789c0f127891a18dd50c454f1cd7bf42718ab739ea75d6c4f01725047ede8ba8749ca2e8f3e7f15f07fd7bdd75ef9d9edcd61b7f30309bf5aa626c02d3ecdd14ca8d3e3ec52a895e3975e8e07a11c19e7ca3061b8559ba646382d4fdf906306b35ed05aafa4d1ddbc9ea8539b3480f747aedf3ed99bdc97c04b35086b953276c977b7b9c5585b4de258ffcd66c41546f3cf3502eed588c9e9c9412cd5e2a4cc31ebe65ece35c35d99bd38effe51e36d638a72fa49fbe1d5d4cada315c04e0d3b766e399db4e2d13e6d0ce117eaf810dccdc1bed4ac06186b8b42ea711ed91888b69edc3b03fc95085f157426509e76e0e9fae85916868056397785176b1598c10b6806eb313d4c2f66f3b8cd3f03b8d84997d1345cabbb49635ca440505fb358f7834f6a88ff31a7961012948311ccfcda80261e861abed11d6f39c6bfe2e50c0cf719f8edb9a4e45cab39ba125564fa4aa4afef033daf88eb23c640dabfb8056698b50850d75fd12257b4649f74ced0bfbb078a289430de99556274fa52c8c03fb9dcbdf37afda95adb61831d3113505af6d3f850f2c1a39db831c30b371c36dcd350c5d56c8d27f75e11b4f5d8a26dcb7e80a70520e81d34255452670275662ad723c35cf82b2c333d8570d32a269f4598eae2629521749cc0e9a1c15462cfafff3893e859deadb5164830bfdbd7e2506857629302e2318cf75c32948ef2088bd699bedb73ee6c2fd9f5388743adf5163a75050055d2b407024a2157cd4dfea1f72be3ec7d0529a4170f8d8f5563d7a2523dd704200eee338e3ceddfb51edc9aa8fb7b43aad395cc865400f68070f3a74e14e3578d8f573249de536ae8c68f272e951a03a2efcf861a56033e35ae43169852e806a4ca19b3dc9b0f61056c26d9b74def299d6ae511605761f96e223e729df3c2abd074d9bb76a526bed24a6db988562571d34c6998e301e985b229f715a53334f35adf9b3291cf86f8cfe71664617c2d2816b41552bd70174c2ecbe510f6054465e0d4b05d6ca89e539c6b51d00491f26a31dcc78e3178e9e618ccca4c86af18d20f13a10f94b76dc9989130efdb591f93b23921addf8b633e38434f31cd200d928e0e007eebd6b988a90973823c743f0acd66f8c6c250769a041fc0489befc61e5843c1547724032b4eb100d10c38a30b918563711ae2850fd77038c9d24affdef031992fff29e04241b0beaa0a7d61ff551792ca4f2bdd77270608fa523f0878f6c36e6741ca2728730f059dd35c4a4164959269a3d0c57b32aeb8e9e9e2f511915055ed974bf366bf21e975c7e66287a77954871b21cf361e918ac3b5c004ff425b214f369cbdf3ea705cad80d9e986225d68cfe080dcace5e8ed3bae2baf1a76bfe092007622bceac29baf8f6c5719b160c1b965ff9a0044ed250c52f1490f3637acedb0587ee49a716df234e179228705fe6b6995bb0ff61d0aa8142e8cdf8a9894e40d17cb3819c92536ed33ad119934b0a28c19176091f6d263f700768aa8d71e5ac213dc1f80d5cb299da891b7edfd2248a9526fb4ecf79f7496b4cee0c618dce26b5ffd34e82112365322fe9dba3e62530757821caa3763e54cf7e0e1d18b0516c6b8a9a9faecb7c4ee7c7312a4a66ffd455be1495d74b1a82e39962b87ea48e0810ea570419c1f237e9488cfeee077d20707f80eadb84f9d55bd674bc00081618fd2cdeabbd62299ec30772cca407954587531dc7511bee992be2356c91fdfa2a0faa662f58c964cef8ad42001a59ff8582d8fa1c019f32b845e7b55a261494a8100ac386f13a3d9526f47ed8db6ba7ea93c662482c266b9fd7e8b278aca1bf5564fdaa16c0efe0df652c79565fca471fc9a756683a8d18765997f53515254cca7ec594134aad805204e342a84f652f9e59eb1578c4e70970fbdc1c32c2ae4aa168e70e033c118cb0fc181adb734b2f39cb65d5da3a215ca45bdc358888cfde5d953427eabacb14e28eea3bd2d89d6f35d612c08aa4e0a4f2ac315085bac7db7a5824768441cf3da2083656fa0e976dc354ee3aad94aa5abf7996c655745b434337f9afc72906fe85d5b496515d96a526fa375173d01bbfd54f0e558bd75574d925ce93d1082da91fe13efb2798cc7eaa9964655b89979e6d47a464aa3e00c525a3c412c9e78a650f76f1b8e3ba3160c622c9a74a1ae3a0ff20eba36f70633f1c4974aa73860764e6820ed1b4e46e4c9c1b15d6a0c3f692ab71db12d91368f4e82e2caadfd2b0f8a7c342c5c89c25c5d1b08df52bff19c62e8d36c8a00480640b06550593e92a5224ad2f89f121b2d9ebe0c784b14ad096f196c68f9a37fa64a5c3c9cc23c0d58116aac4ded0123481aaf30e3d169ac88c680e8e3d41577c27bdf8ce05138d0ee95bcda43959fd3e6f08dc62c9203de97dd3cdb26838a5cfeb07d4175c12a6700b296131a754f9d604e67cb58c31bccb354b74ba82136dc190960ec06ad031b4ae76d52274fd224924e90dc0b58d99dd637fab385d71c12ca16f566273ef5e75578a5af40aa8c95f1187533ad73ae509d9470734066e58f5952fa123644497528aac77420c1ccbde629e1c8838eb3ac6100021ddda35cdd24e0115d985687535b7648432a43c3ba7ef3a8f26046836e00b880b25aa15f71633391113af8378c00977a3c4f94ab8e43b1991915ed0d26e5e156299e1012b383e33af0156cb4c3776190306e4ffaf5a3367a62007dc4a36f6d2ffba22135625b6a226ee12013d9a9e16111faac4d69b3a5697f76371862789f8b9e54a2b64601ce9850553cc7a63563a93f713b94d23e01e80cb5a3b0678c5b45e1fe7cf6a4f0e64e456a007d76c3c6b2c024ab2d6d8c340083b1ca4f655b13ec705c64a28f5a3a3086660e45abb5b446ad5117ac7c67fc9c4e9f7ffb1d63a1813f276c2a57612ea0a4d42be8d4aa49798076727a9ba0a653421131e6dfae2e9a09596fd81fa59e9c2d21aa52da01dd4e05deb912d82163fcac5e03328b48d7e70d02710d2251a85350197c637882e8da9bea27926411948670880ddbfdf259fa0d0b1134dfcc8243d6e9de0542d2b0f7e4390878f53f63d6152fab1f5cb5dc1bd80f876c3cb55e466cd0da0aa450c53412b0e105c33dcb9ec38d02fad6f1d12e353ed5d465a2d7159f91192c11a3c4a3dd40be51c401c4842265ddb259932c7555d81f85f68937af41c56c89dbead539673daf62ad7997c17ca3f876d0050dcb5cff345be0d9c5f6b6ae8e274f7388e3646b3c32323509e8add75231eef0f329c2e714612cf5d82688933e3c47bd0bab1fe86e0fb4575d34caa42ee4fde7242d6afc46792f5b3f1ef97e18eb97ae5f203a4cd358c1b450326fd92a3f0671f2c7ebae5b03aee18a2d32c5fb36b068dc01839d2ca444c15999963042bd8ac31b1bdb7158d2c378b6282d18cc312c22556793c61c0c8f16c21ac45d22aa0596ecebf0d48d01c12e7a145c9619d99d01e33524cad631fbf05423c5b7c0d4d6f532b774889fe97da309256d1d43c8964a2fc9d87a5d4159f85665d84d91246212bbee071a6c38930a1e9966ee06f425a91d7470c05e8ff8449003df29e711b23a161b802c61e5b5f3e4e31ba9ca57084f3f0565581f37ad220c6b32fb62ff8bf14e49616b22b2c58de11c11f7e092d5eb690eb5cf47b3a400dfcf8c6674696d7ae49935042c1f1d661fe45da1215263573258c1d6f7fc631c6d8442d817031e034721e07d5aea27b06ffa0884086f6a914a45dd1097eb35d32fd7fb572d822b9be7b899ef701487dfeb3e747d3a50e5c413c19a142d933b8787b06887452a9f11182811493b7432c1fad9857c2886d7696b8e4c5820aaf8c7b0f111d09b111df6a27479b1d9a523a686bc09b41b65d1419675e4a3feea22df05d776486a57003514901267bfe968b0a0f6ee19a422150ba7201ea8d17092093499867a46f452b5a9fc0c4c9fd4874837aa86ccf7d2f48fc8ea74c7b877a17b2f60a330682072370168de04a38c5519ee8b721083845403d1271cfeee06b1a6b99bb3b2e8ab4d7f1761de4b4229dd3326cbd04dae9584dab61c9b1dce5a1cb6e302240c3cc5c94a2787b8558c13d7687e53a9b9a8b5cf7b6b3abfdb63831c227626f6e3bf3c0653a044f2995351bde94b2d293ea421c749d3f5cbb332654508252b2291a00940f9f98192b8f0ab9cd37244ce5edcfed72d32a5e93d179b9dd7688eb954c7923e78875bdc5e7934da87d784c36107b453e28b0146d142fcfd1fc6fd0773dc1633fe58b7afbaa07f5fcda18f0c3609c8409273f96c26f71fa56cfa7cb68dd97d357c7a6d916df2639f666f8b708c8006f5a4a06aa0a6fd34e8b3c0786afb6c8264078bf5a453f9d6a3ee5b3d914c063f1f134ca05d58c0c38fb7489e93b744fdc47d431db61e3a044443dd0b18779d7be7c6299a745945018eaba0e0be1e36d4b0e78ef4a343b477d1fef69c8ad2c37de1515f2680c301530cd9e179449297765077e41f4aeab94e9922f2435b0add3ae000db388835a1d2c00dafcff129777c56974a68c9d03491225ff3bcac96a75e0e69c5397b396e48f1d6c52f42218efe67271ed62367a61c8da7ed5bd4bf9bce63c12e5601480d170c979655bc0f5fa7b413a78f4b7c474dd3c27e73cf0cea35bb6e15f30d0fca5470705719ee37b1f82414fe25b3159d5e94472ba39835f2aaad4854fb843576a654e71d127d354afbfc855364e98a2077b3be0dc52ed94d75732163eae4211f043f7a8870d64a994d6d45746d8b4ca64966f0e5b2fd28ca6ff3c4c70952c248e15ffc3edcb3f0cfe95c0e6ed176bef42f804b110cf8c262aa37b8fe3f87ea2f0ab10dab2c33ba271863fcdee19d1e3c8a13790b9f6e641e5a0f07038682d0ab8d2a9acd9f924835d73b868cc66569abb0067439956104edf9631085ce10bd9572e291f09a9dd2e3b25cc2c5aae5a831b0bc325f9cc67fb593b2f7810b8a698df97e3d18d28caf8d04c72abe2eccb49fe78a2d473a73e8374509d5aeec7cc6558e44c8da1a29e86adad90944420bc0ead49c274eec59972d892c44b773374334b0cb7b9ebb2bd8806b771b51b9bc4b35cf2c7e2cca8738831aae0f383f9bc4cf0d7ab11432a02ebd824a45a799d38a90d80a2db627ad171580995ec03e7adbca59b2e54270e81f4ed4fa3779df3f67816daf1d699165f66a656facee63bc21bffb35d18bc50cc5c4bce1a50147224d7519ba99bef0375d40e16b7d0369b92c304affd4d4260b7468bff2246e111215a677804396412e3656da8be3cc48b6158e7361fbf3e669383bcb1c3f4bf1f3e1a9fbbd6b603bedb04058964c4b037b28975b3e1d9ffd96f93532e4808a4e9381da9ad130bc994daf11d6d9fcf2a52c4da8d35a51fb42b4ad227c896b294dd2bd1479eafe3bd13f9f658d05f95d300a69b4024ffe2e6f1304d138d27066104db4256f1397ba7a78be02341dd821d98ca0b83be67a4c487377dfbf855a10f3028def8236451091bbf5d645c9194c854df871dd1c57c94aaefbacdfad6442421ef059d2cfc60d7cb9f654bcd2a6be88a4dcdd92d60f6bfbfc08b640ab26ce4967e32a6e5d9833e6ee06f86aaeafb6886ce9f3f03f9c9e4b664e0aecbd59b23bd18467a7b31f337c7298949be35066b1ba0b06e3ab25afc9b7ea835a529d2a158e2014b31d27d056ccbe72d48cb05bd4d814c425376cec5a9577fb61c8273580fa7edd045c6d47992472b59fe9b0da82828e31663ec975ecdba6416a3b7b9c9535cee4ec343cdaa3bb05c1ed3b984ff5578f8cb5a149925af9b608adc9a16e3a57fed9199d1974e421b1b3a4d2972c07baf3cf487effcc9cc5561e87f0d76e646562b22687c54dd8417ccbb45dc87b4e731feee379ab906ef43514b0c340f2ddd772aa811ee7eafd14e4019f5c39fc36035ed32207b94a2d9c8241be1f3f4235d862a4721f452e42532bc9c001a15dcf395ce7e848e532a4a8a95fb250f5a0dd19ad68a68b13c9ed11c105089508504910ff7b31939da9ca970601cc59f1efb6e52c26875f697147231e408d841971f1d4f3c930c326f893f05cc85295aab06245c924986332f31b23ba8426025b775f96c25b0fa32733f050077ab87a25be27ef0e146ff29b89f6d3c04de6bd8d3cc0455ce0c8839fceb731eb720a3fe29b81c8b9c543520f72ad7e96d9282b333e18a0dd09c74aba35ff63c2c0cee2cdadd711bdbb9b7ebe7c8ece72128e9601ca731ce09f0bc0c0bff1aeeff32468c6296e90a6b5fa040bca2ba186900dd41a6e19dce45f424e6f825b19055d667c3b470d67c2b28bfa3b4664980c46b4f8792cfb9597163d65f056ac37bb936c78dc9d123b67da2c6cb9a8ba941a09f459457734b01dd339b375b7e80b7634c88a7cfe065b036e6f9df638cdf611770fa8e006820c3c63337e77eb2f7f0767d4e1b38a65a7a83bf4e511e8f8e5cf463a5602c0d74f9479cf7c2fda0d26c4f12962eabf7dcee0ddca50e8f8507481d6e57aa318378566d1d7bfb31ce1ea59269489af72705d7d7b3c73d7841c0ee66deb665327f98cac406ae4c515d19195d956b97f2a0543e77e4dab7f12773d3c07842b70c685a39e87f4616c1039361242b88e1727208bb15947a5ff7779d28d24fea258a0b0df42dcb401e7823fed6b52732df91a6e754cfb4a42085ad29ca14077f8329a3833ea9fbff3bc907078f585f18b8ade0ae658a1e57c465499717c60672bbfde38f333c234b59e6b38fbee29e395afb3f56b804e26d9859e51de8f7da324f0456756e93a58a01889d68bad58a6145ad8f443aaf8065ef207e76bde38cc05eb2cf9681703d4f4e3866964c6f5c752a134be6a47396c8d02fb59b8afe08c09992e25c8585c3ef01c11ac11f5a8d6e1dbaf9a6d011294c5a521d228620f5eb769d72d0ff102773d0a91ac88fc505e4079dd59226f3986a95d910a9abff7d2dc5cd7b4f57af8f095f3b9063bf7347961f5fc3e272c1b4141b9478fae52ebd0b3e9fee44000d9413dc61beec775ee93e29be126d969aa7f27a8b02f6ff300371f31eea674c4f79724e31cf980f2eb37e4656bd88c3796597572ece04304cac7d756b695915a13e8a0f32b0b41d456c745731290856a6a8524dd0865e261228133c9583034765dc7f8e8c7a252a09407b1c19d85493c1fb618b12870ebc6d440bca2feca56a40a94c755811207a8647dc26a159dcee02ace7ac4e404291d92e84471744f220ac44ec791868ef745430bce4f38eb7707ff987ad3f28466cc42497528f6da75edbd6df5c76b73a8f4888802a8a4767af58c38ecdf191cc9fa2b36193956303d4e95b66804b8da46beddedb2f37faec27f3ad382151c05a0adcec7d460e252b1587d9dd0db73faec98474bbfe6b93f85c1891e0983f12283a975f226cdc2ba6d47dc6073f1113b8676a7216a08106da7b3be095b0291ab3cecf4a112aa04d9b3b559cb935b3187f224fa31c2f1f49b3e648b99844a27b7d81a46440b0445a8fda3fd2feba556380f3ee65e458119258368895a5884346862c2f80f33afa555a079a86b52b8525c429a09c2ada6142da9444a98f0d60550f7ef4d1d810a9738edd7ac284a590b76f164b0546f9096eeca002d156cb2d4f6a000a26059a2ccaeed04e40a7d408b97321e2f1fcf14b8cea3a229acd4eeabf5f81b03284716c97c82b52df3c07ef065f0f0d564356922bba8ad4a02d529e263a1e0c9cdca7e129aead421d876e20458db3bda63997347d0ab1d1b053c50106fee514cc4479154f2c7bdcb63ba4f6a3e5600b528d009550999a56d998b61e85c54b0bed19d0cd9182b585c2e58303ac80a65f3a9b5f1d68f879067e8eeeeb2c66eee52ac5166b82424cc28ee475029a1694b36801eda6b8cac653e620bb9d104e8d316cc5545c869a7a85742e985910ca0d3d8529904d9084ec2db425e082a68ecd83fc3f3665496158e4dc80fcf9047cf7774fd025086a475c3da9fb4787e65efca925ac07976cf277a71d09d531436a6561ae77d3e5ec43adacbab99cfbd67054c30bb28e9b24717955ff0ee7467df0f130db021cf38f3ca1dea3358e1c721cd3a66a9a7b629cb2f66b7a3cb3978a3cca0c4f77f84890a903be1bf535df3fe3584fa7da4527eea3e83b04c5f3bb742748571549bee34d8dfa7907329e77314d5a90f46e9c0c54a8f52595a8254837b616c7dc851084146e2c2e6d55fc3a54cba5ba617af37145cabd1d6ae4d52a01de0eac6f4d0c79b1c8e219640b8c45501df7cfc167925126150b6882e758700f2430cf242005cb4903eeef4c0b7421a2e3fd581bf987bbad1a3cb0b50fe8d93e3e50dae252f9bfde1db46b82e7ed66f889f26d382e64f94c569635624892776d2ba2888a9c3b6b174ade2071331726700c580728819a2586b370f691582f8286bc4994c98ab67e391d321482ba9af3322ef3aa047f73469dcdc4686a2ed3c811ed453cce73ffe3bf34a3d581bac3e5fcff46d42414b403aa76bddfd5228f224bd0eec7d4bf0af795a6fc4b81a603f99f57a49f2377b65736e8a6feb9501ec928d50eada38d65126851ec5d2ceff8fc40782af4f5ae4632401be19eff16e9894585e499011d015d55d600b1914215474635dc174fbdd7861a695206042aaf547f7e0385c2ec839668c0d5b4f389c77d8b2b475dd588ee37236d34b925fd107d4d9941c2a07c2fd9ea047903e1572d953dd0997bd054581bf1a0e4b30b41927f669c5ff15ccfb294cc84f2cac222e7f695e21efbaf15dbfe677b2a13951ccffd0a2d422d81af5f1e4081b498d81294c063b5d974d180679b49cce99bd6dc9c8708a3ac82ba9ff81c58663d4863be4768af1bc7f908fe878b9fecc68403dc0e5f020570027eb95bcb3f0a736115411152a9856090a57a9ea50ba672e70b941cbaef3b17289cf1a81bb4092fead889dc8901996a663ed344bef4c20ae93585b09e3dc09d14162a8ca722e6d8c5c13ae16ebb02dcc56d0a8067f31f2a8b70d8c99a87bbdd0073fcc5dd7785537356b92f393d5cb54ae9f2b3342321c330a47446c67efc67fd2204d720fcf5c6f02164f3b4c1878b5161f76986d4078e34885b2efb631205b2bd5d60f8f1d2fdc43f722dcd850ad3d0327033938077763b9934114e79f88c073b3f329daa4328cfd2973122743569ad95ebc07eb1a40d93e6332f7a8f4efc4af6082d1338e5ec8d32c889d2ee4c171ab012783e7914031a94c1a5affb1aa2db83bf0878d3d84c2ea33ee25181d8ec4cc2e87f1044e33f75a8cb51e738004bd32845cedc3c9434ede72f63eba9d02797627a03eb38d12a4be07e7b0732d192a9e02a00da4dc29c75e115c4d2d03639f13b5ffc1bb71fa691d5bc4d28025046a68d8689c78ec633d1dd93a8c91f909f5a285d48d5998eb06beb64029dd734bd0817d5d033eaa89be7de848f54ed785a96a5846ed24116ff218eaf722396440eec648a3b9dcab15f74dad8de6d6410e2e51eb03135607043c75169daa0e524bd079605578a316bf60933922efcc38e9dd1d16e961fa8663fc47eb814cd66ce3df4ae9f2595972b70b54758cc2066f22536707558c96fbc60bcb3b5ebc4ce1d8ff1b6811517767c11776c86ad5ddefa39180c408a25e53809a94575531b3f17c16796cc9226e1d20fee26b2f82138f830717afb30310867452e7743b27774bd0993544d8190830dd530769a8ab064e90bd0eed3e39f3870940af1a85b8e67b374285dc71622e21fecc23a5629680429240aa01d896bb358e65052ca6958452b3e0c63c4d2cae8830373b9ec7f8c806d8cd8fa77d5c5e6e478f5d689a7208928eb79c1e675da14a05778d7169cb46f71690549991bc3b1d117791b9f13212f326029574a003bc50dfdeb0dfa5570584855308d271af2a19c89a1d4e7e524a1b4eb383c58a5b1e0e3b9ed5d3e64a2f8cd9e9f5d79481419730355873408369ed7829f0da7f49930ab2db3cda86c4e05d2bde56c0fd349d09075d389b6e6a89016660b2839f8d1c98c31966434fe22fd2d88d6f070587df1d8ab1018a9e7688e83e4589f4874feff6929ed3107a20d73aa5f17ecafd6936bcdb1fa281fd1f01aa2a1bbbe528ba732f20f6781d001c7f0ff18f29aa7b29f021055f626fbc9dde9c356d437423bd5a803521605e279f50fad2d3143fde3fc6f6c626eae8401148153efe67ae6a574d3eed2dd140a096ecb6fe4f52dff278e9b37a3b1bf372dcaff55422e87238c067f9dd28ba9bf181add32d4207ff8334934c524e8fcf393e08c77d975b2b27bf888f3ecf0fb7960cc330124a05c48ea1b6b23794630e829396598706d8324db341817f26920b1c364494e69e9a598cdcc9324c4162ed90331612640d7021d55780f75684324e00ae41ebac1f119e8ecaf31bf08c2c4c140950b4537b49df7b984a427e0a56331d6551e52eab8a2dfbb4e9418b27ed652312aeb7f5e3193419f5ea93cff285d8c1c99c4b2fb52ddfc44552ddf52c863d8a754c5847c529a93eef43a52ed500c60babb3138016e9ae528631824509cf6a76317184e028d5469b2f27f53b18186b587776e2d76ec4afe5a1c4f8e243365ee834a5e890155102225b939e00c29bb62efe109c039df0e56577354e6b5d729b373e01942f6ac36758831c9a0a8e9e2d6ee3abc94a057fb6a00ed9adecea98c4ea78989cd4091ef1ace3bc036178753f0110ac4237ba696a88a9ecf23a6123c435ed35a7d597e5c223cd14c5d64ec3b1698eff1edbb98e035881414d3fdab5ce98cb7157de7ee9142a99fcec60f630bdb4c23101399a227815c72b882fcba039fb10628b655df01884d076e975c792104cfee200ac659149d7d5e9b6239f6364172394b7024e7431f605ddac0e4aaf013856825ef753e59f6d4ad06918243332d2938f43f2c5830c1d0b72c4c0c6f42fa2b0176979eac941f9c6545632331d09e14e84aab4548953aeb5e1819d2f52bb02620b00ebc41e24c3bd5e50479974a8fac07f21cf5da1e6e812c254f2baff7b9df6966fcfead3b54e2888cc770578a15f8cf91ddde940f6f45f96587186281d785144db4afdb75d0ab55a813f75cfe8d9e5812b56b6f66f8b19c282730a16c511ea7e6f8efe30352fa31b0161f691eeb7ab1f1af5a9d207ecb65f44a493a9dacc37e8289462699c71e07b45777e959cab5c82ee8a7a8293b9fc66511f05d8a04a7c89fdbc331145cfd3eba9fd9329f47878fd93331c72164d1ffdfa467140d6f4f38648bd6853079a7f04f2342dc141c2f065529c160c8370ff6757e1f30bf2f742f7b5148294f153014cdaaabc38bc588ec39952af9988ba13cc796c2e762328bd2ff109bc5a64d7b64061c20fb92c8dc66000e40ef8978631bb2c3d8bc2526d318466b39e627987654d589cd2b012d28d27f9b5ff347f872bec371480f04df16d350ea9c4f91e423fc8e6b1dde870c59bb9c6c924c41d427df42e4036c4087580cf38ca2ba92dc0d57fb52134fb6d4da8a793b3f0de53d87e52f7ac1b6946e1a62a7f48de1dd18a656dbb82e27f395b78e9874662242c6975267496627ff09202f83b15d8f0d83b42abd0ae20dfe801a37daa86f36f44c84b7a0f72049bc9e6f3ce0d85b544544f46d69cf783bd0773d74dfec85243c345e411f76e687538e769c2ddd714ae6edc7d3393626bb4f17daf23ffc06415740e482c70f152ac9a0f4c7505b02f7ba32346085de829e5f87ebe5e42c98cdde283b80f3dcdffd195ada516d7eae99b2081da2c339819585b5ebf64c0c698b2f2d61a02b4dea0ae6a30020f0d746803cf1cc8027def9706ee037f01cac8c955e10e44a9ca55028037b5f1d61e227879a886f65eae6db4baa5127ef9734d29d3185937d9adc4f94fe1d8f6496a8f4404d171813c67a0b2ba535865f884dea7eb9c5440042cb37857178879087fd6d444f986c77d7d6a8ed4eb0993ff2c10c65abbd411051b7568fc3dc416bfdb03d8599640af13cb35f98ec775d20784bbdcd22d8d508fb09d37b9ce64bd0d0250b2fe64627be19858378c667acb8172e44074bb2e378e506aeabeb79ba5acbdfe76a0ddfe7063ba22b9d4311eceac7eae89ee52a0decf621231ad297f8a24f519770860b2a7b7f2d55acfe359cfce2115416f96c376b06daf08e7ee1a8bb75ffb38b79230a5bf4ce8a828cc9a2d75569c7a2c0299ce363443c8ecef92e46e72c1a3f4d42fd55d2602426cfdc33ac012b1e066cb826ae545153128b2555217530f5af346be716520be1e5cc9562673d7e21d0e7d8c71a4e531ec70f9df33522e89c622ef1e239029df24bc8a5783163c71adee5798ff9922ae2f4b10ef8af03865cc857c4490dc93395553fdd8e74e58c5759e7f74aef441f317a691b3156b07106794fd1378c34dca174d17a19c1823eeb0dd83dda3fca44a684814fe0dfcdf87fcfdc6f57096e202ce05f1f87f455a919b0469c3848ef83019a2c7d3dd87620930d506cb97152cabd58d5deb021600a4660cd1d0be62879f10939ebbcfd333f5bab34b16a7f9e7135cdc79720aff4596237e0a894cff1d16e46f639ce692d8edc07355e7c37eb77693652149c5587708340b87bf8764657d488106167955b3c82d7810b4c8c17bc884d3dc8fcef9edfe85da9ed7c39cef22bea9a6824137710da329f8584719e1cb86f5b9078dc5c71457100e0c2926b0f946eda8391cb2ce350de2ef4b4750b4f7be6ef9e4d44e3e0d11bb81a34c80dab987b8edc4a4bbf4bde74ed9ccab4ca7e476841ecdb2d4ab29ea5824a755bbd66c3ba8d6d9b199c0576a937ce65e80c928b81e52a379706096f2c38d132b117cf13e482daaaec9a18b774f5204c330f9d5d7e718de58c1cb3c6d984f91a3d60dd487e38f2d49160b325b75c0202a4dbc9072791adc5053dd0efd983a91bc2c63237233d18a018e4947dd1f993cb7a9064bd98105ef73c4a9e46661cf8196f9fbc934f709c10f43508b5f72d0204bf5d2654fa06124647e2402845e8c040954ee098cd3b53d1aa7f8ef90d68357be8ef21f2c4bf553a16201032796c16c829431e768dc1c3c342179ce0948fdb2fb9c5f4bccf3d705a7776b59b02b0e8fee7933b29810114f43cd20da1c3869a42c831404d2a2f4f0843319b96431d656a33768d238540160a81feff80018d4b34e511d51d3fff3ef0cd3a9db1108020433f6d194ff2364617a5eb75fbfc600ceeb77ee276fa805cc56c1030865546761248603870ced581937542b5e450dbba2b44be654299424a0ab5db3b4921c5131c23c589d9079835549b7b2bd28c23b397a7b0911803e0dcaddb90707df6116ad690da50fb683321b55644812dc1b313c32251fa756eac467027a7a3b81ecaa86ba456c2192ef9df1bfa1edc014f571e9d7f29c8bff713ba10fee814ea37f6fe900b35372ea035f35e0ef3dc7a49f0e0d7b4d39f41e16288a1ac9cfdd60512a3ad3fe0bad09becf461ff030740c69ef7ee9cb570d98edbd2c3fc15c8a7b7f790aa838fcc5b1d4470a95367002fd76b04608f3e00624c265c0bc5a0e8d2af86eb7328b830286cdf9626e729f1a8f955d7eaa135e59a5f459eee7356c854d95c479f0a5d3e5565b54ae4e8c78d8df4b6d78f53007a45b7603482244ae8749a42d0ccceb5b25b487b3c7bc406497c15ea41db2a9027accf00e0d2573d8751f6ebdd9de55078dfd47c01bce635c752afe888a8f9e40638e9e4db3df048f02778e90e05493edf324afa75305bcc6ff8627b050a64e926f262c664cb230edd75900ff71e00f936fd24b69eab62a470a05d5d3ee86f9b5b65facd3d2346ad8030db71b62e364ae48d7f7eda1326173d807dd671a4a7c792f7fc59590564d8f0918df8dab8aa4736622296846931ba62b733b89f9669d3e3204b8e451d036ed407317a028b6c171bdd241ffe3705bdd7da43ee1bedeeb1c5fe19ec482a5d2765203921b58606687aaf0b618613dda8e2580ee0b15a3f3da13814a692591e4fc7fefd53226c5a2b795b02a48806348489cf2023f82e3271fb5beabba14ffacc4fb2cdd23018b7092ffc9557cfcff88a9db1e9269c3b763fd23338933e1d914b280cafcc20fc517a158733b4ba9baef4f4a6fa9fb5694deb5872844ea6ca8eb99e0e3335e9c35872ea363c58a233edd100e26fb49aa8a3098b38ee4790933431ce859b5254ab8ad1fea7ec192022bedd919637716b7c4ba904e5f59af4fb814248c8a57c509af2b6979e24b1f11b8c24bea36a285816f7c2a5213ade1406b8aa05035a42302e4b6497c92e2495a8661c2ed2b94758f43dd2255e689f34facbf748873f193c9dd00fade1033152be89e663214941c50518a4438076baffab0bfe943998f3fd8fdf72d644796292a5292a56cac1a4088c41947eea1be20b1f96cf07305c68aa47f968d7e6437ec3bbd2d2a9927d2070bb6ef616ebb00a10acd6b51fcea6c643ae707cc642cd0aa2d9ee8c9b5a55b23e430f0805b72fa231bdd11ad6601a19fb39307424a48badf77efbcc03b3c2643d221a2ff5669b9704ab8c5ce651b8a116a4cf0bef5fa6d77431482bdedab6fb5c120f57156e402dd2394d456f7a99e08e7f587d4c39765963c63b73f15655f7ef53488a9cedc790e0d5e46d6b518040b1bbac9ef28c77421e5cee4f8bda5781014d074bad91ce97bd5e4fd3437122ee680d80fa3460c821cc7c644e5b9b070341e52809ab6c69593c27743de213baad2e5fa292d3cb0f6bd03464a38d69fd8363dbd1f01e4d6837a4cd165cba026325e3b223494c5c95fe4165b80e3a1234804d41e48d5e668fe1f205471287c345c89f8dca7a1cacefb448f6ed45c6f33c12d86e9e0407a7381b578fd5fd8f1231b407985cf45397194aa8be3fb90d19c3764fbcb95f3bc6cebb5679d68cc1751c0163241bad1d98cf14ee414bb665f59f8d252764f3e75d6e01584231a8e2965b028e0d5f0cb3c0f594f4506cfe138caa462ea6cd1baf097aa44eea8bef851abbde41847565b83086db5e8a2db35b4cdc0259b9c87c4965ea43733f239d253792588088d0576c3393e9aa6b35fac718d8fa37e7cbdb068c5b88d86c22df77663f0cbcf974b1aeef2b2891ef2634a4813bcc35de97c6cfd71604c295fb2719abf484f5d83fdfd30a3e5ed31c0565b3f886d37211f13dcef7ea047227c1ab171c24b2d8f8dd59389f7703c04dd06539b172a905066605e0ec79702eb0fef706746b8304f1a2c5a7746460b6612ee414ed8a654883b432da8e47755fae755be961cbf36df39a2fc8e5d3d146ce3d540da20967b37f48eb175e6f890f53e66524b69f9608ddb9341cc5435f159fbd0839a35820cf63daab005f8fee71904555e4dd709131cd87fff52327887ad069530205cb922fddc7085a0a1776391b67ff11ae6f0081cb1c6643af952bbb78cdd2e4e80a796202edfc95a42ad3ad721c2b2a369951d82d61f78ad642a901826393619d01febc2a5554d87f13f7112cf80ea373900638caa9f9cf6fcdcd6eb5b66f09d1b0c1a84d67e52cdc278c37ec03ee5811730d43e067e10aae2fb09c959f18a4f64906bb6d372ce49039d42a857abd2d46c4d10be27bfedb56f05fa1de160f0650f549def92f1bdc45bfef88298a61fdc760396cda883727dd716a309780d3a92a7fcb144b39c129f9ddb44eb4cf775e06ef4ed27ec19f6a759fe4938c322a50c6ea1c1c3c56e16d4b5c4c70edee1b48b5dd585ce84012534908fc3810d1e82eb90be6669b446378cee8e558a8d4e24696f473c00b5692b2d97dee2ad8f653990897de0cb6a349c5a31fe2bbfdd6261d19246bd8d48d7e73aa32e9aa924bb71c46e26dbec4ef38e67a00282852d1f4185f507e8c300645c5e40439e49f9af9c34527f9eef89676c6e93c5f631937b70cf29fbd6a214e241826b34301edc04c3ee60d3749bd8ed7707bc42766a279991436c20a86e6d175fc28b13ed8ead89e64e73a33d568ce3007e0e66e01460dc8c283ff7a67d2e994d0e0bc83480a7fccc5d6f6e22d0c38addf43cfd0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
