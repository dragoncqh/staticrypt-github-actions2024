<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69cb49ca9b976aba658cd31804e771722b614b8e3e16036f657f4ca3ef9a82c51743251bceec1ab003427a7f9c97598c86bdf08858a1e0f742356c8112e759f815287f4842c19d4d274fe92f115c6f075b411914d9dd09e24ccbaf36278eb7fa1209354849418dd342bfc55300744c9e4ac5d2edf68d077e4c35e2145af9afc60af124e320a192d94efd0eeeceedf4982a2173a705be5bc1d6eee4bb089cd1ebe6f6e60b3fc94482096183c6dbc00444b2153cd7406e0a480d2303785e79497af3ddb4e778665752ed10b22cb9656a7cb5a1ef399bdd7f946dda5fb0a41c821b7c2215485c1b49206c7a149df270fa5a654a4612eb7d1b9352889418e89fa1ec3415adde8efab545d496459cab96d6312b94b487568c23c3a3df0b324da7f2796c0fcf96e40d928d5cb0bb3dcd0951f76576badd5840ffe4f8374e4a41914e3533b52c425f4892a2e26b298e7c044fe69e39605e31619a251a6cb4f06742418c5a479853882b92c183734c90f776ff6863aa4cf72f6e5a24987d2fdcc2638e99509d814abddcbf606ebd17b686bf6cea48a0dad0d8f1f2698286a2d744039d966ff9df8adfcde96fba4dc07ca61396260f758957069321c8e3f4ddeee2103850709c2472d15211ab7ae431748a12b408020b5c91ef77b18c5142fd9be49fd09044a3283455f4e3ec606a86d770e32d789842df38927cd977b322969c042e88f610c178fa31520fffd72ea28ac6b337d1d50c9df9b13c11b653d4aa1ada958367f6fd80d29ac6683ad0acdccba6627a1adfff222ba0312b2a1f1e4281326c59a97d31e1c8f72d44b5058f7d9a4c0c7969ec5b62072edeb1f95f27209ab6a1c35bc689e8ca62cba22adac33c1c2a654afa86301da9830a665f93a40aa634be950b29ba495f30a7d033bd88d269d5c804cfba3938eecf2c66fe0147a2111d58127587b8cd152fbf886a83be60d7d751af622974710d5b078fea954619cf677c8a64867c360e903d101f79b65457920ad07bb24758e4152cb36f5f2cd377993ddb917588a69fb945b276a9e2f9126afb2fbde9026f6b82478952df731f019d049532091ca108d191bfb92e22602f1f134557b3e367dc14c25e8b8caa42fa62fbbe20e8d7d6d48b841be55e197e9297986b4258f4ab7709ab08dfbe011b0521896221f427eeb9085dd8639772cb48debcb5c6ed0d6c04ad5a9ea7bf85a795ccb5578be5fa0c59b7af9cf7aad39904e1fd43f795fcdd4655e2e21344a4d50b9932ba09d3c86b9c22081b4b4312204ea429a34cab3b4aa4fff2b5c38b7c6dce15494524d27286515822d52deb11cfa9e112a48377b0fa787eb0071f2a0f8bda412fdd794f5371a6eba939142270cfcd5cec5edd46113245688ebadb6256624fd1ff49a54dba48f4545733225ef6f8d142d4c1a569e38462a10cb46d3fea3ab78b1fc54cf553eeac7889a26c1bda7b769d671442e186820c867bc8baaec159f06da61cf63dbbae42f657c0090ca2ade176119c7739d60e4b813a7dc3444cb2ea33a9c9bde9075343390f17d2b9f0d03a5fcd6b68e0086f643d7936384999ac7202ae52564ff2739d212a9538b0986056fbdad57a07638cca6e80635b00ada2fbca717aa7a9c8057d0695bb29c72dac3f67dcab8bc10f97dbb12f1cc882583f3cf14f81492f5785b56a72adcd85b6f873f6d97e81827784097c50b597fb198500167116a1c2f7a383a2e3d238da21ed1396f1d055bf3f5aa143f2407c7d269ccb125dfe079c907c8b4121b51002dbb45b4147afe6d80dc9e64df1f1b2a3ba1eaee98e3d7e3047cc48d190eeedc70bb4d5da503e01fecc06922b1d6d2f1d1ae387007c1848577b135969b94e4be20af4624c3452f34844ac60c65eeb198a098c54088b6410835509b07a85e48abade4346d1f86b3b474d18d48c6a78e15ef25d2f262e93db7543cbaf2258ac4b4b1e540dbe45012c7a837fa8af89ff41abaf4565ca433fe8958fe8c6a44e5a05279271f653293c4b5feb38cfe358a417ab0991b77b09b1d594a8c2f6328c15202158689541ea5cc022283f124113a9fae02052ad0b039c7ec2a624ca06d4db59a7ec71f5ca5324bbd798dfafa58cb92921387d99368e5f573d2725f7f9534156d8dfbf8c706aa895e9b3c2a11f9797f2396b23dd9e7a901f47e2e52550ccf22279ce75004b6f09aba3fd555208f4de7b4728aa052c27e6dc1f71890ba415502f09c6f33e716c28c3633c327343ba3fb64e46c79712d54683649a6468ac6a31e69feef6e63e8e9fe3105493c3515ae035d29b934b26674ab8c1a1ad671aaecaf0d7b85c46e575569d3752a5dd529ca631cdc3639fd872996399393491f9d508bba89f227485c443415dbdae6d8050d29f27561221a95f30ec4e96c3e6b3a507f785be1dcc5578465e074c668361476951af1dcb2d4b5cb97c4c6fbf90d111eadaae564d92bb15a24b343e754e13f4396e0ef9a0fd995c2057f5642cf0bf0b6e02265b98bad6d50d27f4f290868c63f5180cd47a6b665289fd976adc5bd0da2e7a442e7502de26642f2cd7bc78192e7f131592911e70387b8e713fd0ae4cdf4a319401e673aed4647afe8dcb9736dd77dd6feb632bc065529526be4d08760930d5cfa79334ab94244327ba6bcf04fdd5f6bd98df6f90ca8085e5c5b440bda6b500f633d8ef2f303543c02ec2f43e68f1b68637b15862cbd9912d7b91f0b36289c06b03490dcb9dd0e853baab77e0d9cac305e71fa18694ee41f0372f040f0b464298b16ad662d7fb535f9dddb5b3868f5bead36c4daf4d38257b5c814e8cacebf6620424f1c1fea315b7da296dc7d9e68e8fe085abe6225e7265273adf4f9cf0d7fc84354a9e687bf985960e49d1ca5d3ba43dae44f2031e5568d6c41783f52497777002f6e80a088ee5dd06f729b4eb09063d5defd5d2a09909eb3058e99bb4f22c123fb6d925518d8cf4740e8a7f10078b71c5bb7926aa6d48c3b17d7c686e7064545bd76dc6f469976a2b66e9ca8d73e7a1276e3031e1500255c4e9d951dbc9547ba1535d5629276c019f4feab5523f2884de5edf3cc701e8da88a3cb6585cbe6872064acf56875a426f57b949a0a630d51bc4a120c5e31af781c05f15bec88b7e14e991adc1c9724a5fa49e3b9d41174ccc6e0b52692504c704eed95ac79c8a272c266c90b77ae194dc7ae1a9cf59cb2dacda64b7358aabfb837771078ede6dc68ddab2a0b3703d8ccd4358e02ce708c05bb9384ee19300f234ddad8433c0c65bb0bea57dc5f5ea065d2566f44dc2102020f392f8f79eb7d8c63e52502488985a2ec776721cc20cb54812b21d0f451c5b42dd32db7410c34db74f26c1f64dfedb54cec6895cee823eea87c73acb20a331c5d2b2ad124bc438365532b03005204df46ad6bab8bcfdd6c299244372f03e8b90fae02d4087604970bd49080b546bf581ef43cef7cb89a0ad76a907b351377f8f42c149d74cfd9debd82d6dc449953861dc98bdc4bb6a8825689ba7e58aa8af39a43d1791b89861177a9895ec67fdf0530a9a14e944b1a9ec26defc82b38f875cf98b5ff938d6fedb387b51f0784ccf7feb641632c76b165cd1e7bf6527d44ec704a9f57bbcfca4749bcd610ab154918a6f9edf88328bdc9a05e8a9db5ed1494a268206cc06e0114eed8d4f3f672894367322217fe854acca277ce39f60575b157be9531f297e590245534e690524fe9be1f6dd16060408324eecd16a6295596e49a13c5f2e3921fb8e441e0885274cebc8b3f2276fe3d435596ab6be32b63256c2d326b9109e8410243ee8dfc62b489a4a01a95be31681b1ff775a7eea354ab13fe6d8d6e0689f913670a286c016985e314a6fb00eda35694b4964c1a54e7c4c0900b163605fc77566211924010ecc6325148fbc59a0107ec690ea61e2d70f7e1b0ab2b1387b4d351c9d8457e819eca25e9e43f6e304ecb7579c2123a418315c08cfcaf8c36fc4b21fbb7c5a30b1624f9d86638ca87b1c5de695b5124314bacd0e993835f4566b3d9a121f549864d2ae4d6b3530f4189eac2ca1c1278d1acda049dde8ffa850e4327458f7ea07c8a074bf09464f2765cc2758d6c264420d11a9c30b5216be8ac594b60d70f19e9c6a45d77cfb61a8faed38892e5a7dbf4e6925d803b211433325ec2eb937d081e95b90b0cbdd9b125c202ae0e81d83c9073f331ee38f26065cb8a684b4648a51a1780ec8f17a73417c8c6c387941f558cbf9d4f289b14b913122ea181fc8807ff3cd169c70dfdcae077845b0c36dae14e7d31c726747af849bae45c6d95b405e825e37bac4d5c0f938805091904b5ff7c3c20e1880fc20061ddc2d76b87ddcf0a6200adb8174ced1a665fef2b1d40b910165882a30eec7076ca16dd50f28fa660e126bf29fc686cf4053e836c885190ef118dfe9f2376751ee77aa84f3404de884340c601361c36b2b2c8e757230725e696f036d9db2a605337b687229cc03362e412b0854327436d8da3185f856a4e8f7e4c504874911f8e76b88c09449d20da5af944163395d1cb0bb74715f5d84af81b06bc14b8cdfee7c8851983e799600fdc6c36dda89c4928545d745964723b25e906644af94095e87269e41a7197ee37a4b4ecf6acdde4e44f96bc83e8c8d9821ea3c1dc4ba69da445e5ff0783849f4bac8a29a9461e166caa70088c79ccbca68d8b608f6d029461538d2ada766b86b8ec63de32ae6b1ca18cd7de1795b39a882ac92fdd5d894120f311632f364bb55b4adf47be49c46c26e3faa34094d14fb95546661da32e82afc51522d6928af9c66137e72c6ca4291c5fd7105f1217836255098d0870608bdaf96ef376d60627f72c85a2971aed31003765489439eefa549e8ef668bb2266259e966ae494d3730d3662c21c54d30418da8d08006f5fcbfcec3583c27e188e12fda29693398a1c4da5e198d51030bbadb610f8beac3bf830843a937fb171e1a818105a5e0179a9de5c3350cdcccba94f59bb68d29ea34fa1f0500208db62229279ba9b4565540a021356b9d371506a9914f53a4d05c987ef785f3a50119be871e0a8d908cbe7b908f959ff93ad5631b29288aa01c24af231072df65c107953409dbe5031de3962f03d59bb5018a03d2fafad91dae421ee1fb8a83c49c60a2cb7ad714e7116498def1382ad9f939d3f678b82eb90a4e5898a9fd46c5c38df2f86e8cf20565cb4dd19680e99f83633b8e562d52b9cbbaad41152cf44b14fc9b6c31cb88b488f0502df836eb183b3f922ff28cb1c9b406a0803089b9f8f5b1670e2de4edd09b24a4ab6b2fb6be22cbc4db8f5e94de13b3b2b3d24fb839ad2bca77242b8adb9eced119b2f2b5dab9bb452ab899676de27dd8c4dd909f4f5b7be2c463cd078fde0578cbe467cddfb0a7fe73d12914b77f2fb02992f76355f14c7c4056e4da3cc2f2f6488879459076f57b2c888d22c76399c899f8198f28aa008045b7030fc0b29afeabce2afe5f665d8089bee913e3ec26cc5be5c8ac0b32d2564897d6bfd49211a781c059bcad610b9e780cdd6641902852d1027163aefe33bad456239e11696b02d6c17e2abcefd0e26602934d98632da0fed09f77709a4e471b9dc6a39198fee6037ce9581ce9a41f1b332108d7e0d5249d4a82c033de35acf3994d9279483db8efdb891fd7ddeacda8ca1e95f0be691a63cf3ca287060ef22901d7ebda057375552a3acf3c9844de3647ec324c4309ccf0cc941d892856f7e9b86a361b560b7dab900c13ab1def46b25db51339fc3690daf89e9e44ac122aba2c214e5e98539305c31551ce5c32453131a7e295bf085bb2d3a18ca291431cbae590ac9d720efe28c7200315a5141e4c09ce7fb10727bd88c2794e9afeee9a307ff59b397cd7d1bfec9abc1a94c172e253375fce6ebaf7552e88bd86562dcf2c120feb1c450bd4156304ca448733b31078b938b8bd3a61f144ff6c6a8c1a5f60fbf4831051acb0df284c2912a03fe997836e4c5783d0dcc2b8896ac5dde6662db60e05e98f07627cb89d0612be6926e00969bf85617d84fe7183f6070233e3460fda8477c177a6f634953dd33f60286e0e995c11aa8e9e252987733e483ef865e1e86751aa5c263a14f4e10747ac73a0d7e34498bce1a0b97ff56ca794203147895c9e21f656cf9cdae56b26f5d53ae1911dc7fbb5fc278d68d63b228ca577f2695f90112d6dc4df4ad3a514c20a7e949bf3650dc4a612b2de166979e276e0f6f0e8fc62f885b8ffe31dc0e4f77f7559069236ed496c8a72c153ecf983fbc36d8e4737a49419cfe674313c58cdca2cac3cd83703323943a319d807e7361c4834fb9df2b9df4521bf838af79b946422afd95f844d1a66b27652b77f0e13d4e42dba5722eb16125b1e2146ebeaead671713a5d755a6e790c51beeee654a6b4d9b17ac5e31cb12d0ad34a5cad67a743b9586241147b1a56817565189302ea11bcf8f25490bfbc610da11a2b6124f7f830011206ab0cb9dfb662058a67fe360f57628f3a284d99f18df9c281b48a60df7ed113a142bb86f6c5c41945861c57bfefd81c28180ca44c5d7bd31e8d4fd699b15d7a9f3fb4935f010e668ffcd70c2942b0ca97d730a0a7c9a6ce53c5cc0847d5c1c9a0537054033c3cea13fbec48d85e65ed5fd200eee5d4541677287f9f7bb2be4f016f7ae1128b0ecc73a77232e5efa76d447ce0ca63bef3cfc2bd51b58e8d620388a66268a85a8f0afdd8cd01523be7a0fe4d8b1d31b0c5ec0479e612a082f0505f67d86c7843e3bcf26a2e746c088f96761089cd7e3026771d8823f524860d002b9a7df4431d4fd33f0926ca4253d814f8e702b8ca4559ed523d0f66c3f749a9f26b2bb52abcd2666320c36561b74717c0bd0ba26e5b9008cbd4c124890bd8a65c2805836ec6b064eaac9064b2f3e8356643ba1ac794adfbc8a8d98a771f253a6a91d8e0385de1a51e3e02c7a4f4e12ea0f5e64e7eaeb2ccd7fb4d4b4a3dcb80be26cde5171c6856a5da3dd13073828a4578c9c6651e214602f3993730bf0aba39551bd07424a8f68b38954770eabb84e2243c64854c7eafad1201c8092e2f6e9ff4ea4d376bc0953b533e8be06526db4fd04ce9f6b23487e1c0bb34f1447d1fa814ecfb2f318a7ac0eda1515eaf88a1e10b25f15af174f31098802bc63ffb265f5d5b5dfe9bf8298597ddb46709fa5dd6857a5d81588bf63418e351aeaf6b54a4583481e89475c8fef1afd67231832759364b0922f026179157aaeec16e518f095ad509c1fe930b61c25ccfa1e96dc9e16b54018386a2f364680506bae33c6c3a1422e2186967beab5d083b1f7523f1596213635ffd53848615b31d9d8d2b018b3f37aa5c2fd44bd359f8bccb18312684f659bf6531556795d8f8609ce13e34d1ba4c778642eb85ed3c5456dd46e45880ca85cae80078525f286977586ad773ae99ef9dd919600c27b8bfe5f2c0646206c0e931ae6928a49b8e29a963999b1dc21a37f842a5cb74c751e03916201e2104d597ca474ea0d0bd5b816bbad9b45a79d01a8c171bce7970a2eed1ac0b322e777a634ffded2f121b2a9bb795c73460a3b2db038b5bcb1233c89fe67538e4e07a01ec039b927dc78f29264b5a78f9ab50d2a7fb4801a60d8bcb50d0c223276b7050c7be4944bac068ec812a64be70fc4a16824e8b888123a7ad97d2ac824d90a96b70967fe342a9655964d212cd7b26c052f4e6908b0c98a586942b5a2e29cf3fb543a3c69fcb8bcdb0c6271a3a68725938667e5c9eafe53990fe7827aff52c5a212e6d692c8e5135a9c7bb31a8ed2965b3702d1514cded0a148a7bbac274e05addb029ebcfabd51e302d8aa19cb11a5bd32a2212b8b6cffdd6675bc73bf8ac154e5ac6fc7ac7b8dfd21b33c410645f4395f3ae439e4adc5c2ffab115514123cf689b1905cf0c3c13d0074cf51f72a0e838bcc23f151a7d27954e5726f59c5a590cd9803d4bdde62ef37e13ed2d60a3667c68a5beb2540b96b197392801a61156c15b437808b569318a495faeff42305982878c0acd8f7fe0658e56240f1f50c43af644e27b43d137bd462325adcf4a39f19e0d8643db1cb761d712d4b60bc9a8393b2b7b0e3763edd7ca9eb01ab730530b64aab0c8083e3e77cafcb5136599535f10efb5a7c288665381340517f5a89740c950c1dfd1ee115bf1726384d40665b8bab68939a1978cdb97d81bce250ae17470dcb51c513a0eaa492760e645a8ca2b5f8da21abb535ed10fd209ee1b01b70310141d09cc7b69d607fe2e1665c106ca90a935b26c6c1a9b605fefee409059909482a4767c4c10719c3e6133a797f85e6c5f5a652c9ad415ed03c1250ad1218cc2ac12ab0f82c07819a6a989ad5b13421e3ff76d652af58eb8e3fa4097ab65eb120662aab2e48bac5c838f06b930b30efdff51f42bfeabafd8cf5ccf77bf2f2320cdba9a9b56114a42d5bd33ca0e92608c2c812c69dfc27dd1907038c95327e24871144c15f66dba94fa6247c083a2874cc81ae22873852679a66ee1529a72a599a28ae2a88f9e700a25eb604b7f42ac97b85d822fdd76bff424da8e1f85e0fae9349ef611240d7cedb4e1c718d2eb5c1f4475c67e0995ed4ebe1e86d4918a1b5a19ce8356abd6ab06e4052de0f61f71f45a755023f4a47f54efc3d07bf9a750c90be804b3255859f2f5ffd9859ee18c413474a796d1631f828ded92f0b2814f3598e15ba86fd874d904d073601213fe0b4c851bf8f2c70849d4df07e7964d428dc00048291efd53340f45db48aff757be14ea8593dc52099bd9c2fa07b85986541b678c05c1974c26d682e3c73d3e3b1ecca2c6387cc90ee5925a2a39cdb732b5d8bc7e8ba6c0a2779c7bcd5fb3c4620af96bc2578f6dd0d798dc2706ddd4226522d729dc2aba443c35fd22d18b692af325947712a75b18ec231a84ad5c53cf830aef6d055dc48f91155026e36042453abc0cba6ab445197820e6bee4b88c7aa0e2d4ab39dccb731e5fa2ba2e48da536f748c6a46af5a9cced5021dcd564c174393477e4cbed3e02d594f737a7afa61f835a206d456b9af5d856b61c022cd6fd0e4e6004a8fc07fb3f764c1f9e5d4ec7c5e409b1b59d0a090448f2d9de2469e2238f910ce84fb031dda1c471e605c1d1cedc0fe5638ec78aafc9717225c363a83bb738c0d267f66a4914292320dd9bd93e02e5c5ff80340d6dd6e36b677fd1cce5d80f7281e694152b055802dad70e87de26e2d76d94ac3a717f208d75e7f57f956308cbac3f89dd491b0007ef65ff7b1788f531c690212049ced7648b53d4b490ba1f13fd79c105f004792665aed7359f63a4ab476eb862d093c635ef25c854ff398b1634402a52501f492a61e8442b7b398c902526411c37c0b76557d8be61fe2c8405d72fa4bf3de024d57e58bbffe8cf8276799c06cb7c81f2573fba26226f835f2e5fe7fc952ce079093341f1cc4ffbd53926f1ce711315d721907f589df53da704fd0baf214bc2fb3903ae84dcb063cddfd8feba67e765cce09ca7adef8059be9cde1ee395c5119dfd86c7c88d9b610b79e62eda64a27ac8bbc32865f403ab075a39a751f33dac702f2feeb0708774e6fc8112711d4061ec51da1918c8e7fabc7397427e2919bc304a7341aea0013f62933ad1efefce8f74e85146d23e6431d509b0b03d6f9b0ebd557bd1c68d8f7acb294285fa443ff20c220d1b04dfc7cf5e4243c94b3f50dce0496079bdb0464e4ee88513e68c6710f472f6722867a4ef59709ec068a7152134e0d9902dbc50efda7b510b5d353015512df9c1e638ea291ecac0b5ec5820d1b155fcdb76d748f58662569888d7d2e6dd6f5d35afe8c112781ce8f875392e34e5de1fd1d34ebe96274dba3e4c3a0d1cc55e03ed7dc0d66cfef30d0b4814eaf94a6eaf53ac4ba293ac356d7572cf7eb5a9fd79743d7f48cbfb654665236eb4592a84e1991aa7fdd506f4180284f09b9fb0a62981b20059eb2b2ee70e73fce38dc781213521f0d6ae3ffc17399394ce7ca5d5ee4dd5b12d6b3f8af1d4bd524c22070931a1f94bda1356e63fa6cabdede0fd48065c358704bca6be1b3a25d7c78a5693c2e4b2f6a3e6e0b78cd58372d5e57bf73312f29da88887a62bba18ce541bf02e7673aecf7bad463c9fb8a88728d96c8384a0534367108011f449b3326c7e4033654ea96e65057defedcd35874c7d64dc3c8684b9925be5c925b8ed6d43c93dd791ecda5b08a1b63a9862af45986a0c1ba4419bd801bccf054c631c7545363a496b14a9025c054eabedd2f4ba32be75ef2ecf90a3284b577a416834a64e650e9025b775fec1c5d34eba63aa717e3a3408c292fa1303e6fd11bcdd04657fd4343ca2295e56db5fac8e2e26e3a7036cdedc0e24ebcb76561733f6142d224e57579339a1b7506aad6f61dfb18789f619e796a0e436966240f949820e3084aae0953106f56a2b77c45c6155635a424c85b8ce8089f9382f794635aa2fe59dfedf9bf2fdd7e26aedf2c4825f763e0b68db78eaa8ee28612856df7405a0e57a3aadfc2a9f49757ba57e488a7dec641f6d31dff0491a8d1ef6a30aa096b0fd95917b71f68ca91a554507f24916315c36f91f325452f35e12b7d13cf5a33a073a9873d29e9c12ee34d5c32903289a1843179bb3a59000d010855e31f15746fe1161cf9dd2b93820471c58beace2e8ba9e17d72f5102e658895b42b1f345a0ca62186094a7fa2072473a1dcf2d010deff98ca025b803da281fe131c01092df130e59f9ad472f83b7a33d94236431e5eed48480578d9eacb1be807807d4626155e5b3aae7ebf19214e2a1fa2e5ba20061c5da8464b801a5e0f33347d0ebb0aab9c3485c9d857b19c0f64fda0057fc0ffca8bb0680b080c040c1ec86fd53cc971d0cb1ee062185f0cd4109219a4a101b3975d95867f9e4aa3ff181ba2fa6c6e0248af994cf06624c5029d44fa9122902c65de1aa8ee9ecff7413fe22ca5e7c521a452ee211644848614c5036ff52165d05ca35cdb11c934579c2b936a9ee8e0a6a6391952ab18328c6edfe585293d8acb740885c0713438fd2c60142caa933b99e62f6075e0f99fbb083447708e5264f744a7a6908a64f4e34697bbc97056c958ae8f84b1c0f474bc0821879f85f13c7db26ab7c956ecadd8a9c10375eda58b98aa135866ddded5f38c7d3a9904106a987c46834f2abf54ee720c5f4d35887afc9a6b5a05c8adbeb588fe0755e260b698e5703f0d27f5944bd1c4da3aefad43c505cfe21e6efced6bd28a2a59aacb28953aacf3bb79a32246387e565b2123cc5dcb31b50308c7c7df891e456968f2eb8cf29a85f3547d2a7519816445eb1a0e1d4cbe3e852d3d9300813c42ad688b90fbba5cfa05f550c6abef74f583b2a645ab68650ae513f8624c12a2e4466b807618343a9d08dce9458efc81558cba638819913dd35feebe6ad6ccc253d91174de714f1fe6158a0a0c3dfce5eeea8f7629b675d057053df2c4014519ec8839c33dbd05f05fa08f6d5a23fc73c5a9898298c04de03a691f6500e153cebe2ddaaf218439703298f652920a555447ff494f578647c316b9eb8550680854b26f188fab8fa44139e333bf5f74244cb7eef3b57ef685a78109055b7b84039ed57261283cb5406c07c24e5ba071d3b775731d648c8be2aed887a4615ba6a2fa708ec095a8eefafd6a33e089f3f6121acd27b5942e4e8a19b961ac25386d17431d47204c029cbf46c8d322938f7aa574075cabb0cf4200d227532d2aeab7de9dd859d7d02d34911102a734aa8027a40c6c14f681b717296849e4c252b351061e3f9f8418dc531aff6ad95cc723be08028a1e790477f0e880494b83f6ae4fdeb8564a4b74f40b6053c9d8a7e4103620061e23ce513a391ce6bb9b2c919a98a83a12eeb3004ebaa5016e466e18f806b5475e2479c81dc2e05c811fcae2546930a369b8008875d147ecec6e428fefdc9379251404a099b2f1e4d975efe8f0db800d5f3056c84ef25d3064581bcde226aa24cac26910149fac1359b58743a2d0dfbdbd6e85e0dfa4a4a92f8d2f733b98ee361b4151b1d5e31b1821ad3a6e01f59ad19fae52a5c8f72c3f76b5ab7902bb517da4f0b008a02fcf7b84a6943c5bde51af8b8487c85ce908c024b47e5cd69b1d5c19713168cc35b65c65668420d580100eb849a029870c66f52402417eb1720831b9f4e12d521143da2abab5826eb9bdd58950837ea5a96694e83ff7f8e733f1863a8260eebb662f43bccfcb0f36077f0bdb4059408666d4a177903eaf0050d6893008d5f29b6a7cb5d2e4547355ace76a2669eef55681f24b07991e292d611c5eeff5f8cefb9a0a65a5c0042d475457a8e892f3f18aac79814e48de3b40ffadb93d275e53fe1c789aa434b04acd47391c2cd86c7338970ef348bd129a926ee1fdf6522ede2e727f5329f3570320bc19e151a26df26d360be92f692445ef03cd088e7fa6e6d7b600bce7fc784c5bdaadfeb0406614cd760fa532b0ee0ac201cd297d1f9a56ec9d233fa777afebfbba4bd233632fb7a8e33224a8b153c12e2ba6d551b3c7edba03169c3ea342d41d359113fbfe451da19f27fba9d986ff58e1013010ee3568457313fde35a70bdcdf65a76cb970992deb4bb57e9282954c271c7a2de4bd533f89af4abe159cd480701cc2bfcc31e440486c20a83d6d21a5a12bbe1667a66c10d1fdd747d3b7883f9559f622b4ad7a112c4c1bf66565663e5cf7f1edbb24d7b9200933700c76c47ed35a3c3cf3a07ac540390fe6f5b78183c9a9fdeea1caa29ebcad9eb29cff29a2786e21846e3ae6ee0de33bbe37f06ec30e1811a3614c4d3ec89c57296e044aa12d622ee838bd758e78583136a5f6c44d9ce62fe87b3a6b27e6aa0e0f6fec99644dacf254b68edc9c3698f378a07ab355dc9c29e57605725e890de30178c3cca6cf51b7ba8abf21c1baefb3426cc524ec840bc744388eb8a73551c45f0ccc2b24f74eeabed40208b3f9ed2b3b221c2cc14db9908c86be486aa0f4ad6ba026b25ce37b763d0d570a1b7a27aaf9d47fb05682f1193aff28c1a89a32cda277d49ae7d64f783324fe57b7ec5dda35905698b642d9b7f84e84239aa613b2d8c40d8ea7a38c6f2e8edc8f1d3e02264c8138fb7327e886b5504bcfa5093121acf69acbf8ff21f95efd855661d00d3679e9d4812d917f02593124705c5a4fd00f34ba16340dc6c0377fbf40ffb74fd6f2e82c1c8e66daf927f0c6b9f304805b971e8cc24784007ef5fd849cb26acad3c4f16de3bd77aa275d662a68bd8955a5ede5ace1f7a8604e0c6ab48671dd77e49bb7ebcae1a276827fa798af42cd34277145c004e322272bda1794986b1c17aa92c9efbe2fcd6ea18b7c84028663621cdde766d1411d05d69fc180f6dbb7d7cbbdd5c3b66ef4aa29924bc103fdc28f525fa16624c11bd14e18839a93a830c9e9e332f03d8531d65feec27f9de51e1255603659df19fabbac6d4b385ef8eb35776c26313abed032a1e8fce827e8fa3937bf47f16af4cf8c313576d887046360e9892ad85eccecd1f9da1d58bc85d7e9a5bcce5c63ec6e58a6983119cf4326fcdd80f278ec0d1459138f221055f6594a72231e063fd9941540a7893a2f77e68dfdc2504667f4fddb388953b76e6108dc36289697815b21ba5685481fca9325ff6be9b47bf21560ba4a0e59d2b4343e367bc1f12b283cb1dbfd7b5ec4b0d592b6abd62fc28d85818bd58194ddffaff74e5a8d290f9c97579fc2a899f432b1f523072d122ccf9618389037325246bc0441bf2721516f24e7875e2384c2e43fdec398e6c6ad00dac32902d52497d27d167db92d55446f04e110b7749be312e39de95b960e4a214258861105b5ec91212e277646c9ce5dbf682245e9c59f3c78e2a98815a87ec535b79ad1229e063db6ac4cb7f69e7b6e893d668e340d8ca5f58135b43eab4702106decbc66e3ef9296847e88a405e48fb17ce88f6d5060bb111b650917594d5e51f93eb700f4115a7c6253cf27a322de6e50e86a5ec66fdd4a5df81d57fa5f4a1847b0d9f20b81b7da81eca78cad72260668327a51ee9e8ab7b6242ec1747819c37a1d9acad7bb857d05d0d153b2b11c6b796238a32b6ef595b3e31afeb7381b39dda40eb0c531680e87ffc902c7799246d39e5e940ee8e428ef6afce46bf1c4df1f3e8ba080326e812a19cbd90f61707e71e532dd3562b987c3ffc79bb2b0bdced9acff07b4cc20a4740591233b9d803b63fcb76d1e30344cfa1f5f05e1180a7085f2bfea5f108f71767baaa9b797f2cba5b257b3f539e98d1c730db53da6a7209b35975553248c30ae7d100b737c6833a5754afbc43807b0781f760cc5252279fee206f52b52c6bfda6a64857385e399d27d843d4c6624962d8e947779e22550cb9f944b1d84da26859ea116c22dc94b799b47fd7466cff216595530f2072eb7907f4cdb4778386c4ae8fe3e8f0d16990e5b75eb4c1fc3a10055b5862069031c2b5812b7b1a51332e61c891cd94008ddd0057766516895cc79f9af038b7c4c05574f4de2f945b6aa3315ff9586d0d8129445f3412f78c276a396f9196dc7cabf7993bf4f48eece8f232bfbbc53bf1c9941fd7ce1a494518e88e87f0857d9a81f95e8fa1af699fef3931cb8495af0ae140ad30b6ae275ec8afdb97bfcdce07177675c4c4166995f90fc8097d664b498db614d2354085a96d640c8b57cda50565102f959c164d1f3dd2331af47060a81a0644baa8fe51c71774a7ab214d8ea5ab94ed15bc5249f5c7386b78cede61521153e452d95b8f258f91b620f58885e4e0e01a24fc77d30d5deba58820644e890727b9363f6d5562220ca941b9038caecc2c9fc928c33fa4906d8b5bce5a45d468abaea172033006872639ded9bcd2aaa1686c081259437bff7e6ced47f709a91a50be7642adc152d53a71f14beac731ebb31f2497c5f583f1d2afa7627bbd57f0de46e5924e6eb943fcda8fabafd6ea9815ac3b0ca3be03458a1b997c90affc5576de602232a2426a51cc3d910804257ea9220752fb511c8fa634ec6efa95ece72855832adabf9c13df5bdedc578e85f753e96a1e8f17462665617f3560dc6a8cfc3cf71b2bf83e1ffe1d2c49adf3aef933a33b3b208b0213ef28b2abb33fa8eb1f01d2660e48bd2373e5eec01d3f1ed19","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
