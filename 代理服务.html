<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cba843a971751728d53e1ce49b9d7a28de5fe88b26fcd97abaddc8aa7f63ab6a71e2834d55480786a1bd9749225488002b7c0b26f97969d77f1c49b6db2f8635bd6ea4a35bbcb20eebe143d7c0602b8194443dfa9388a046549d9f9916a52e158d5974136d46ed1cf19e2a4147ab8efe991855e901450b48583651f4ddc9348ed10b68de15db9b9507c03de34ef53e83beac3e71a6bc91bdafca26dd8ee97e3b7b7d25d77c58e682e46425039ce578dd225c559aec5a3924009d60e674b57d05a7a39d89ed77c77be335b907c33e260787896e368752071f90225beddb13c52f897c67992bbd50baaca2673a8950a90f4dee8ae794a716fb7e53b91b6b07e899cf48b9260037df4195f4075217dd7c2d3bd09e56c3747f2ed3ca09c712a2e01efd8292c1daa6a3596a8eb29b470769ad55906d2cd2ce1b8e4ec745fb51b3bd35bb4db6ca508aa318c2cf52e29bf008badfcd10847c01d4da6432fa5987535cd87a23d92d0369d4cd2f1ee51e28f797cff8cc179a16a9bc6e6ba8b6ba021e411eebe9e516caa5a9dcb66c89dc55f5d67bf04e3ca6329b2937e77feaa1369015d5f565ed60fc228c9637349246e524853ce8dff35135a586117f46d36181609ba00ea7888984f6551f2b76e7d8d83171d41e5584513393d9b59a05a2f5acc14d8e9089ae626e4095dfea196717818ebb3dfd1fc7aaa8119fb8791fa5d0d9a27612c88cd4edb384d8416f1a56e1177cda0903b825ad5148633546491bc5bfc3e9d281433d7d2c45d16f8f9b2abd8712b3f66599549726d3b07c6290b75b85eb480b069d6b9dcc92a7e1aca0eadf66617645441e696622cc959eff09def067b2eafb9ea160ee99c7296d72e3b182a3e016bb7b27932635b4ddcb2a55bb010320d7812ce6f19bef52f08cb4a8c0ed29cee618d4718fbc68a9d98b198a89601603a8351e5a6fdbadb21280c7edc095ca2e34398456f776585316317603051a41553ea033af1f9815873fd183bececb53481eb0b50204dc85ed10b49cb4744679f0bb83e8c461e1c11ad0e6f32efe581da2348279a7c665d69a0da8cef97babba6a2709f593a9097e367a849466c921cc6d5b932612c0fa4e6edef9f91c0aedd37668345877520c6b3a15b77899502738d3839295516eaeae7f88514ef7d9749c25366dda644471975b33543086371785247e8330feae0ba960f88441036624b62de060953dfdbc52fc163cadbf7c1ec25ec369ae0f0607eac920ee67976c30e6fa2ef237c6686538322785f435082f06385de46eb05a5cb8e9b1856dbc531da8f0329f448801a2efdfd53035d7a73d1e237d2656c3a357395e36cf7939f3165b3a3065dd3bb2da0d3e43e813eaaabd000638c8288779bfc862456ee7f2121da6fc1096d24e337d308bf2803552c22fc200fcd6590c0ee43afe09b4436f4fb35ab63a252c27d3a5475f6d9ccd3e0d78a58055708158ca5611603e82403c87427cf9ca512970c7dbd1a59cba95ab10a0243f1cf21b22c65814c647d9e6bd561601b011aaed7eb28a266daba00b9caa5a1223d19e59f48b67d14ccc4eb2981350404e6bf0a9ecd29637d42bf23f34430be646bb47fc71f79198ebdd1612961ef150a88d0f68ee374e589bcde95deb5782875dd1d065a1c5fadb36946dfb5ced641aaba1297f8b5f27bd4afffbd300b2f7b1be420d0dc22121d31b5edf2f97843295fae5afae0217fb87998322b6095109170d2c676050566f74c64ec86dbcc863d43e838dd157cc72b811dfea76df6dfb387a574ebda0577ac9ac49adb7142316498442c79d5f693e078fbf84c09cf50aa23c16cb91b70aaef64455763c25dc85396cd91c0883b2530da4865dc793023943d266836b575b7a4dfa1392f05dab9cbb0aff7d37601c0f41abafe7cb2c63c7e9ae5df860702e6afcafcb6b1002c1161f495f94e46680e9729e539f8883fb126872dc1c036bb772ee55f0706bdc9dac7e47791a53de8e33e059598d3155ba8d82b6ec08fd83375fa462d201d527465a3081e39c4d2ab0d8d1aa427e40111d98326eb98dd8d8cb60f2ee37e49408dac629cb15115d8696ab107787ff610f6201eb89ab564ea9371c3023bd531301a7fd6b7a45b5a755fc44b1f9aa150964a35590ca61f4ccfb0847eb5a50d4267e8e08b3e463f86f27f733a6573df6f300ed55a4a892678580969481401bf7b20fa3dfcf7c95bc284cc732f105bcd80a9ac05ab04471429cc5b6226186e9d5fa8b947e6e9bbdbd9b18fdd91800b9f7a443ac5e89dd277eea7ad51226e9eeb6a1b3080fe57e251de6b3f95c52b211b8fdf4399ebdce1e0a8e09069aee0bdf7e58e0fce2be4179fe3e0f524aea58bb1037900eab35fd9519a74b53a8c9fab9850d85353acc8e5881293fee8382720d743835da3419d0fd151a3d05bda357d5bbe9da5b576b89d2edf8cd1f9f76abc50f9a97ef0edbf8b96595a11b329697215f1cbcb8703e62c1ebe6fbed9c0356a40d3f0cc07686e6096842caaeff1f05170759536cff0aa523c171d6968050a1c2b0c3606559f58c3975ddd68c3c3d7381326e81e47373453ef383c34d4de3ddd292836584a7cf86296180f15d0bf9a75e78fc72b3b0c86aafcc0e201a755fce2519df2177fb7f02069dd18aff8f2a15cf0c5483021d788b000a518dc0f68993dbf3b0f295c2a6ab3813b8eef3dc32ee7c579fc01182f0f31442ef32ed77638c9bcdb9505a41355f8602be85f8e6345ec87c5c3cf43bfb7e1c35751b9fee8829ba6dd89137d134dbd81adae80200c06bc3429bb5f41728ccbd66837b4ab5422e59aab84904681402994ed89e6f8495a7ee24bb52db707a55becf8c1329f42a0f5bcb75d5cc27c3e5d69f3a8c2303d3ed54aa8a7a151ebc3904ef90bab043c2ee9f0a119c8067337dd42fba6770a77fd31539d7809cd13c4d17b6884f04641fcab586c0674605120ce6dd5d46c401e48f6b1a4871cac622255ba0904f09244b4337e215c88336f16f380e178d8dcfac089097066bc2ca6d626393025af44e714cef41e3f180289e8ff03defa148037d868493265ce39d0f508b733842873a65359a82365083b80abb6663b3d237d4aaf2afac8aecce538cf70391acd687a2bbad5c0a298e8eace9fea38e21d6ba59b64632d863f753c57697c284dc00ca12527229e4012ee097fbffddfd5ddd55f3dc639e30139efcc3275ea751ef54a9133614bb77fd8fcf0827023b6cc4e9d465c4978c69a30e0bfcc19f087df164b9f7570701b265b4db1e8d7160b6cd06a27ae6c6bb79456c49b2ad0d7e898503a0455dc1248fdb21df8d8220999816510a49f5271419521ea3426038d451e5393f82c1a635b1236cc71eaf56f68f98ca0b7f8a6b16ca3f7fb25083a9e8cc96a4262cd4ddd036c4a74e8b0088b8ea6a0594f0e2ccd147aa5ccea12ae27ea925d627e50a4d82dfc722798f188851e05eb42a7f0094e450f357736f13d612c11c58f2a0e2f8d00e7dd298814123c51ee07e88682557148b9ae25c2481c364428c18f702891658234858f6a77e323c16cea3b912621db5a44c7c0d8bdfc69addc6fb50ee770536b5a5df74ce3dd978929d0ccb8be6df0711d7436892a48a27221dd66dc7149597807eda9932927c9d8fc74e857d38ceb902f181a14ea7d061dacd034d85fb6f2600e3725d91b6e6caa9ff29ac2a1190be4a6c5eb2621e181f54c295a57be1c56a567a98bc24c7ea9574391066eff2ed26d669b9b67925ecb23c8d3596a133c2e5be15fbc4dca979e0434363ecde2d612ccc8a94e914a4f2d268236e82915dac339d4c10709796587f0ffe23ffee40b264a4575b6ba53ba50603849dcb8b1c17a9ab208d1199e94e9af5a18b5e936bf162e0d5e9a0f03c3fbc55156817d5f7eee6924c251564efd6ad3aa16e831fa81a86c33a0fcf8acf18de2c854c695d90524e572bba774fa79f44d8e342d313d95d9cc85e59c4aacfc433cb3b5b0cf7c150c20700491c6bfa276d3fb2be6632af897ccf964078d14211b1e20c01d694a6fb4ffab588911999c648cf772908f3d57fc1e55ff0f3d27017e3aefaa1f9daad61401bd0608440530ade54a2a33a26aac57c37a2d945f7cbbdc438984f0d282c1a64a5f7bd95cf0b97f12427744d0f2086e4382c33941f4b8d521e55c649578f0de8ce9893e5bbcddeb77c5bb191c4bb73a4cfd918654ced5b6f6deadd4c71daa9bbb980a59dbf44ef76b0dcbde9df7ba456c881e8d1d8c9439573120cc76aee52b5bbebf32eab7224625aeca335cd0f49a52b0875a416a23e413bc16e320af490aff5454a93e27bac14f3606b74ddf8ff46baad88b478dfa85065218060c46b379072274d3fba6bde171fbc6593ee2a60f002a77becccde827bb20329a7ea4e93f168bc0b9c37d2cbc714c8f21d1c5d3b6851dc726c4230a33a434e0cc03565ee9e010fa4092f37331b803e522d324393ec35a0192175a2d16245986b3edba8cde50ea4d4f1704977728dd213845c1b5643e043b386dad1fb7f135ec9de965e56229e46e108721820d6ee931f8d3daa08bcdf207aea0c28ea11c9c604c2586ae89d0fe1fb0bb09ba289443979c0ee98d657b29a4881381d8fc519c1816d34b6db1ecd390091ebe03d97f80b9d3c1680fc31edc78e299baf23a6905c736c60d504b6d5d1618920edb0217e32a476bb927e3bd4dde36d890039f7963bb65d55f9bf1ed09bfc01325825d9d387974af3ea362046a2d522caa04f6d21fd8fb115ea531cff331bb0bb5fa5f86021b91ad55628d64a2b8adcb95e5e99ad32e536201c2d38903363184c0fc9db5c1335e2ed158f089e1505b8966a3121c6bb5ed3ba555273b7c31a32846b7b05f4aa7cdd1e94d7dbadede7527c4439bc0b7d5000793bea8502ee6288eec0b0bf90f7d704b34831b35e8a782fd12902adde057637c5ed167450e0072fc9658917fd45a72199e195071aeb38e621eced5527ffeb2f7a6c4f0d55cf560ba6888ce12f765dc6d97f6608eb220bc8421a14e19202e772740213efe7ca8919d327f6b7c09ba97fb8ffc57824edbf966acacaeb6df7c1a75b0548c30c16f0079b355345be7e8adaa7a7724f07fbc1aceb488196800cd3b6c8703b7b68302759d8973dd075f99b17e20089d6334c23bb032008ab101c0d96294380df4b72c838b02afdd25b1f98efc80be550cdb4916d69530f089f3237b86831175351b6d6708071b2abdd3e1d2c6e914c651b679feb61332a9ca8f0257c2998db9deaac880dad01772b06110a52ac49e4b86f312cdc7e773c2818d6a01a372ec2d321805a903bc52adc3e949603dc6b882a6e2456f608f952a804fa62d5cfa17c94d1a9b1d27bb1d4363e56317020b593b153981420b48c1a3d8bc15ef7efec6406aab6b61564aa9045ed97de06733ab3d2a86b543ccd50e27f7168680f0e3fd9949fe980420bed531159c178394aa4ff3e042277caaa62f72b71bca738577cb60fd8eadf6bb225ec3593e115caede676994370a916c565f21b996339c7fc817fe057376dbc356e7bd70404ed19086737bf261a7eee02e44b82a5307448eb1474e3483fe1c2f425fd5a3ef86e5ce46866e48c21c3ef668fd759c6714ceb421b33e8056e0da7ae55fdbd7971604adff735e3d2f9372389ea93e7d34e9db9b704c6745a04a3f4a03a81dc100ef1f3ae8e8ea6df21d7c72800f6ac5e7f0df0e2eac554b43f8bdf32417a5daa180e8317d71f4b876d63bf5de9acaf9d54970263051619475286c9a19bf4ec880f0922bffa04d25de30a882bbe9c4e1921ba03ab5eb3c2ead39c100d32d49300247eb69e70d7a1aa278ae6c9f816535e2f7fa4bb11c415f86b701bb49e55cfbe51d0474ecd627af6a7caeceda99ed63918921b6e39891ad413647fb9ef65b548ef82051ab347cb218d2b52842604374b7c6b4080575a02a017610c8b50df03f2698a41961cf5eb135dc8aa22b873b6efb5fa1f0969f6571058382d16bee8dc72807321a15c66cbeacb7528ccce2ab11db6243e58c2959bfe272360d1bb8ce0a394de999e1bba53a82dc18459e3bb109a920cafa9068169946b5ae8f28c44e8218f0813bcbd86c5e29ccc25bdf554c000c4bf5d3205a6aeea726d66c04dbd261c00bcf51f5f6bc250b8ce72f5dafd0ca9ac4d27212c3bd0575c74f4280544f05729476e97917305f33b751afe51b6c4137d2f873d606f171b09261bf3abc5d2ee4c4239b2084244cf2f065edbd4820c6ef7f422350177c2d8061a5e52f5b705f038e5763eba7573febd8d3a20db5e699cf156d029ee4e0b668ef08a1c51ba83904a037f192ad30a43e0b595b44e913b52a70ec8da1a2d5694a30f80453b04bc95e5cfd6af71ba88e33672bedc7ff2f9bd4d9ccf64353a97e3ea1a8faa6156baef7166ae892ee35d766f6bd1e8e53c483498d372119d48b144a0eadddc7798b8ae5796bdeecef2b4f98070c7865d0122f97c718dea35fa3208062153c9d9572e6e38b9ba1e54f02ab86c6184b4521f22dcd2d56d74df06bc59a58ac82188dba257c921cfbeaeba10a06eb664d6c0bd02d78d9b00a920034ca77840b9cbf403ea8a24a4a15ca4cd25e1c3775124c7a9d23c2d96b119000ce4346d7d00ef53d325ed2df4d1d3b099f8e608d7ac08ec51d59c50ca27b9a05664ffda865161c5d0c13fac9e07d5bc834f3eebfbbd30f734e2f0870e678b7b1339ca766a2485caab1c3818fca8269cb2ecb5e39439fb9dcd658f0e0819652909b54b14804409fee132df033b88c64b8a5684b91b8aea66e2884b81499d57e34637dffd13a07e5fd13c87751167d0b87e3549da727d1294b667742e0bfe5a96e981dcf4f5e51528ec335d68818a387ab39b2981af3231b08bca3d352f8a6cd4f45021222aa9a1682b6d97480182dca887a359aa18c1f96f52f1952cbc6148e2d2c25f90a16cd57e1a9d062509488763a6b5d2065a2f914722a5926d8fc9fc1c3bd9bf6250f46ebd4213d09f4ea8e115718f2a9eb9f01c1caf1f1a4aca6d0cd370177717684cc99985e684eeaaf060453c2d073fab71d3d4f7cc7be6946db894e76f4f959d4a9747e852d49dd908dca3fe5309a50ef6337b76953c5347914df7e5c836923d157116e4a0298f745057af4817e32fa55af9ad0a56f701773ede6e46b46b5835113fa8c7d20e01b95948bb88a1cf1d21785d6c981298e2a65d04f73419d0645c08fb24edf725dddbccf616caadcc86d1be0f23e75a94c7df4217ee5a66ffe90b57a55f9bbe23f09630e0b416523085eefc09fb49789ef19c52f90c1946e9a3418701240e84e120c72d4bf1d254f4eabdc9b1b403c8ada3c485fd854b3274227afe90c00d6d5d27ff94bb41f3d345785e7dced44681bb8bc97d9298a515acb0527bac9ac2f0277bc47c342c3e685c8f856c487df8a1e01b590f79c199b35a33bcb4262b4934187073e342783870ddc0a37921db6c67fe0848e72f4137b6deab5105990a3b8e5064840360d735850e495f69b50c32faf338eb022410de8e466930e6a65ed94339f7da66ce07c0295d6302d6ca51c3ebd5a999800cf444ff699a23a29007cbfcf5afc16ea20de6fe7a75163e1d10e6acbfb94880539df31a60eea5b1395cf984fa708f2d1f4db4361eba5f7951e0605f951fc9e6a53135be5b50280633b0e5ea5d7a767259c713512048db93a09c406512006869135eb878d46da21c7e60decca4b884bd8930343a58dfa24e11f5e72094d686fef18c8099e5a4ce8e4a7ba4bfbbc9ebf32527850e828d2c9a9a85462e76a94d33143867ff89f8324ec5b22082733649f2b61347a05cda81004ec3edc67721fb2ae8ac7bc0bb73afa56c233496f0b77a9c6299b383587a14999cfd27bf09428867c685062442f9577f573f53d19d42ccfa490ab5d6ce0c1f4085b2d05aa2b7c117701c9a8402c79299d5d8ad91f90396417e5f339c6f75266f16c0a90e4bb6373ad4fa1d247552f4a48d0e6c27b495d246f6a2f4e3121c536c0dab91032b9b792fa86af484581a69a93f1587aba7c29bf604eb616ba9e9b4b28478579bdc10a79baa4f81262711cb0356417e95e22fa9a524d983f37d50d7bd6f9bda6d5b5124aab2f4a1abf1c24e65dac9c7d6f23052de73a37f2e413552abe9cf5affbd3ef44bb6c777362f4a59479e24fe4bb2d935686a5d0911641c95c2ed42ca2b288ebd02f948fd68d402ce6aaca5ecb16093299fb686b4c66517b2fa240fe11eb7b25cc9f704cb949839e0b77b6fce546127220e1af8d22323c86eab115b17118b71e29c8ee5874a5d03d1271d7c5f3dbb9dac27a3a954c34018e90d3e0dfc74184ca4f56d846c53c9286ab3b406efd894cb4b8cb1cb9fd0606f665c523bd701219f903ec74150d556de9049c4d583864686d59ca457b658f6606ee2c76507f98b5ee4f039b8b404235e7560180ca2cc12087cd15cff93b3c44cd9e39c2939b88b49137e58260f297236e7e1a4c43fa330e20259b0e8f60f618451f22e00035bf5cb7fed09fd4e787ee1d4b719a2f027b96f3966d2e395ec2006d4c2866cdaab0d06dfe78f255b91bb396e9e9d9922f3f4b351521b70213f00db0fc7f86e88297387708f280d76688ca768b3aee50bb1a75723ef7d4e4e1f7cbff070b6c1324c932ac8c17125cf293d4600feaa0189b5e93efb3c83ded57fc44e05b1eecb2aa009bd82b9f937211305b92c9729254e6cf7231129ac9c370dda62d0839e90a508cef848099b6d2550098757bf935f534356f15b531ee9dfa6947e09c894f607de609b36c546c4ab09f5ab49b2b35c5c142092a11b538899b4fbeba4663165ec92ca6f9589ff554396647363a11db3ef08d27e0f9363198f436741156f40d65e337ee85632d832ee7a3995f154101d3c0bd7941b844927f60de0213ed2d9517b6be2ac5e5dd9a69c1cd52df2e1586e8b005af842f0b911175c3dd6ec478613c1ca788d5a17998a301170d895ce42c56af3672adfaf4004eadff77e751d8306d8106a89c7b6fc03cd7015a5d904cf4c1efc26ebe60cb186b29418d4bbc512819a0ea4c55b4dc9f112b29b51bac875aee85059518f0d43631669ad1d25aa2cf3c36ff07f24d7e53e6b3d9264a134c3e65075cb68bb4acb569895e521c03d4533af6d531c28a1cfefae26a033180819d290d20a572ae9121b015bb4fa5569058ccc390b72a775377ba2522e94412b7b4e065eb94b8673c4c7b09e6dfb27d06e8fc87da9b83714bf560cbdce6659f054c1b7d7ebc0fa367268dcde25427932a63207db8b645eefb3ce1af3544c3bfcc7678f703d2a86ecfedf1146ba668eb2fd3969b5af890113404da71252e201c74c0c3fbe2a2f3b16fdbc0ccaca6fdc28045fd50d6b1db2193c7dbae56d19ae74558b58a2620ba3a5aa2998eb5792b7a1c761e9c2342d1b365a869b52c12b50573cbe38a580bd689366ad18b662a5468eff4453e010fad0d9315d179fe623ccb6c62ff2481c4721d7d17d638d773d4650251e1143cede917cbfbb5ea8bf76fb8c9ad420a77f7ce713a6ee187ed18cdbcb8d8fb3e49b8fbde625c990600c8f5a46a6e74e10fbe81bb973d0a874b18768af96ae2d34f057df2e26678e8baadea93edf29e52262a5093a03f060bd8379bc5cc13791b5cd47f57cb98a0d7e5b68a3e511861d5e2582ca9625ed1b43c6dd11272c583b90eb5d5f3ca8392bf67e29a7fb6caa34f3d999e6be3d27897c9e108ceeb5d7c8767e8b063e2a816d4295c22020990a27b740220b19b8ce08ed572370fbb7f14a32816fcd39a696b9a454ff579a7e4a6d7f952002bd223f586ee24e8dc9bc29e89b55f92b15e12e9f80c97d971683f47ea0a2dacc81deb8d99468ef6db412b25e941c644c2b76f31e756dc1460ade517fbc4161023f4e443276a5a9b81816d39df5471847c1803a35b61875c8c1220fbba9de70f50845f4cf9c4b9489efe5e55dae1b7fb45cdfd43917630492a78611d27559d5de82b22713fc2f455be41ffa0584080b14ae2d7a122d0d2c17078d1238cd2f0ec7c16f561a14a8e087933615e9e8bc0e6fa35dc23fcfd76a38efd4b735c452cca69df6ca1dba39a55de64d89f9cb2753db287f51f3ee346dd7df853019943c26138449947ea22c1723d675ad890fe3892682dc6e3ab9033faf22e8f07d2363f69ae73e42865c0acba5696eb9c54ace389a16ea10c7d8a139f1c567b157ffd5d3e2ddb3d64a82d32bb887d3a4e974bf4080a7328e4a332ea4d803e9847fe81bcc9fa92ead4d44e7e501c08c517f6aaa21d5f1ccb7498368edfccba5e2cd20ada2c3f3f8e619f7c3a6013467b9d4edbaf89be17f2dae8317520b3328c38bae2a6e4bdd1ab82e07e8e68e51611ae5b87b5b26247d30f2cfb1265f37086de3bd2f1bf3adeebe3fb23e87ed6968809c3a3f457bfd7956fb14afe48d31d326bb8d51b0cdf3a177b3d5ebe9fc90844593f2f10d588317f38b796edfc8734b000fe101a1c3b26ac693565c63997c43fb58120cc4e98073dee49781e41945c30b7d86b311e8dfcbbaf187a36b372412250aceb21fc76e03e10c352c5d278065f92dc90d6fca4fc6294df451ba748727266ea181449f1ad920d4ea0fd98dc280a4d8a4e57ea6edbc71a91c370c9b6e27a10b6f03c565a86383357c13d42b4ae3df157288a5ee313dc4a6a75dd7d57bd1d189c1ff4cee1f5ebf8016d91e539055186dd9a46965aab3a2e7e0517150661ec8d7fb6ac9c4d6edab9766c3d08659386d24fbb3852fbf5f044ab6a6972865873ecfeda1e85cf3e5daa4a8db15e2902966d2fcf70085b326d930c20aa903851f005ff36b538b413fb530c89985fc7972c02e2440124c81dda4a3bcb0da8057ded0ebf9b5f52c32ac6f9ba13e451fc090e6f254dcdea8aa0e0f0948ad7546e04054444bed0071384bed82731ae1704512f23c9b5b8340b4c4b043d4c0074df0479ffa59410f59d3eab975ff32fec1041d46fedbe5fee04399687f3b91b32592a8c9914286f03674e73f61ee7b6de4cbc89765f6992901b673cbbb03694929541536664f442fb25e1a75f55cb92ada5ac812432407cb1b852eaebe8394772a8e75a9aa743240064d96718191f147c8b4de724f30f502a19688b5896e59573df01eafac4152741e0e0ac9cb615045b0e9fdb54b41465f593280a31f2801ccd0bac8e8ac6204e2b33e44ff6ba7cc1e58f40e5611186bd57ea7e752d5f0a2c8757b7fd4be230bbc73c75e8c50ce110af05e50a116a9efa37fb079473c8e047b18a05dd12654f32825c237e2eea6972dd0949082088459b144f01fb3994bd85cbcf3592ee6ea3b71bdf3d6e4d586b612bd2e8cbbca270ff884e73930fd8256c7360c4fd3a41df588d491b8b7aed3a25e65b6af5104a74b92fae5376d17e3e62a91fa8d331715affb5e505aa013dfaf03b22a7bedf7763eb731d0fff11622cfabebc87f4c352759db06606fb5c36208864af5acc3e9744735629e6b44972863b22c85a1f80d57834cddaa391f49e58dbcde57b16940ef2556a9191263ed9e6c947562de8568b72954596a7d874d2e5bf6226a1f667d29a4f32e513c6009105a7cd36ee85b42aad0a7edbc0f6d6fef7eb55f7acaac8fb087bd5641074b2a0d5930eb850ac72a016a98d2cbf825ae764e4368e39d72baaa4f046a5eeb388948a9db1b0075685efb8e17d367b9205e74074f7e4a39ddfb3fe6620f9da5e94ea5d7e44f71f0c8d8131461026f5f04f12463f09a16726a6bda6b5bd37e93ac1e4e391c72eb8742f093cbb19d2cf9b9a8db9839c1e27cd481820e2e55484f2160a22656e385edea18b772182c8ea149c70d08f4980d119fd369d99dbb5d50dc1a74825a2fd7216e8e52ac958abd4d1211eb5fdf24fca4dc976a46149b1f9e78a383caba5f6dfc128ef6bfebea93fc9c70a21c0ba1950fd3dc01b2715f0267a3f928afa3aca8817de27306c4566cc08378e21b3d2ac5c13674dfd9ab44130928269bc124f9473f49d6facf1e562cd72066d8744644d6ce146c6ed6a8ec59610b34e3a17a7a83df108a369cc0b1d2fb216d69a5b1ab28640c761a4bc9a6c0e5a63e6b627b68e5704518607e68067a0d4d508fb748da2d9d47627962db3e5bc6ffa709653449ec398f7651e4aee7de80f1f3253855ccf9e22cc34ca429daadc2d971ac560bcf0cc8481cb5ae02383d96ee8ad847283c8cac18699e3c4295f63376120edda40b1017fdfc9c351ab3ff06c2d1b78fb3fe44e4287727d8ee159077831646a085f3dacc084b325254b1676bb6b593b60e9ce337040abeeaa41b84e66a3e2d5a041c22b4e4d52606b574e278796950be4fbd4a04d8859664979918a288280aba57a96e10d560d329760362bab858f442f5a3d5f21fd425f5ae7214061af444a5201a38a96f4cb01faa6fa77f5135965a37f452b1d4213d6b3e69e7e6ab8aad1af4e42882acdf1a68dcca54a0e548146098a45adc3ece55144aeb7b65ce4384417202b563d9c163fdb0e944bf4072cb6ec18c2d8b8d10637af888bdf0d47df4c4fed2808b7c0880432f0100db1ca5a242f4888046ccfdd1d8abed13b0eccc1f88e9587ec730824502ace1de5ceb46404d20c6e9eda3a56b0ca26f90950941dc64c5053b45fb73f9202ceaae55a8e05397e2d6c87dc28cb7597789a1a66ef33afff043a41ab3f0ab59a1f18c5b5b3fe1c408c71be35a008824cf647510e9b2d7a6d372954bfe35121b8405e657747bffbc3672e4c08d4d7c6ea3fe1d97a8885320de4575589e17bd6ed0f7d0c5b05859a0605a085c2cde950a85163697fcc88413bbdbac6c0fb9152531521a431d9f97f270c471afe3edc889d0ef345b0a956397992c4058aa6361b99f7cac7b2c43aca0d6dc80e4c4e69afa072d4760190c7d4b016b7c1a15c8c933eb64f2b2b2be770333bf1877b1e5bd6eb22ad75859bc84da9a8323e15c69322fb2436c3511e58e6ab88b091bf19d651d202b6b6f2693c6b518dfdef7fd21831eb2699c2093fd805a9b5a7f5a91e2a35e9f74ae937f7a4bbd72394e7ae0a2d3949efdd41558c68c9615b780f516ddda4a4629cd812b8f32dfe72e9d7d2edbb956d7b3e903ddc229f11d8c28ef3ff66e09430be9c5fe3076d6ed5466c2a6baab55ae953c05c94e6bb9e9fd7f18e877855522410de3dc598f18b347a99a8999759fc56929ba709cb337b19058e74a99a62a98a5e29a6369e21db0a5a1ae842a30729249de03f0b3eb97e0e14e2129b1a73f162879d0d40388b0a0fa57bf64b695a3dc6732336183cb8c293edb89cc2c4fe82d674b81badfcae8c0feceacb0e50ec280b83682c8a20eb769be554eaf15bd1a4b1ab11af849d637e2efbfd56db4825e02533031ef9d44cb61a2bf194606cb93ab7dac08d1852c6ddc55ca8f48477055ef4cfc6ca580b4eddbc70e43a4776b162f32fbbd07874279cd8e64d8d9fa4bb38ac611788a7744d6273b3535ca288f1204de0111086360aba0d9acab36ba28d25cbf42ec2665cc1141d337a3f6d41cd5645a7d8f6267cbf50fe0d3b6b62191fcf06de909e9059466c9b8d2c639d7c25cf5ea306f1e4eade4414c93cf237fb8f222f635cee75d7e1ea94d05e9011659360c785512577a7cf05a85331cc6aabc6a86a3dad8b5c72b5c01fdf69b7b3a20a0643cbb911c725a0d766e46f237ae31ffa9eb6328e78203afcce6892293b271a10525458d42a84d9bef38421c6523e5cfadbe1984eadac655e0201489592073e157f89815fe428e2a1b273033621c1323dc5a90ab35af7c1d83b5b66cae0ae7b1319d1ed26caf9de6a29feb55640f16ae7310ecbba2797c97dab7d59858652ebc2a94a0a7184bc0ca8b1a25874d0610287938a51988a2de8227a44055ac04aa73ee951d07f8fa8623328df51d274fe640ff8c5b27f676e17f9c699bcee1f48a9e53c15016976eda4143994a92fd50cf4567d5da08832c3934620018209a30b3f78fdc1b1ab08b2c759d8a67bbcc700364924d72d881b8334277126542e3407526cef7ef201ad0d5b7c0a7aec2d4cb2e218385a506c7279b571f493821c85f2b01ef9460df2f81dfadd071256ab66beeb9fd3e48f5227f11dcb8db82b7f6c62c7b7a39420f2e87fc6d95479b59f6ff4bb5d70c8e1dce6d710c72381583404e6f15d322954a122915ef6fdfa2e8634b65c24a783a4060a97a24a602c066c21c2f9e3d04aeea6bd25414ca8d803f23666cbb68235f8353437d83af26e8f5875170ab07238aa3b0b04b09208e7569bbc51193b190dc56237350d32f8a38ab52271db40fc5348d6b9a18c5d25a211e59b84707eefc364db5db4bfe8c1d215005d8fbdfa05346775a10ae3d6ab73ed3206b8f5d35f4b43df7259f99b34339033f3f02d2ee00b6798ce13263bbb94a0d4e3b67843b21876c9d26e11c62f2f4d9422f96f9974716ff74ab2a64f919954a9a6dc4b38a86178b4e3bb6b05e7063130748c3e7d082cf9ff470c2e2040f4b9f92f3826cc25611ded50cd899fb3958edef633b432d5cdde2a98dd28020d5ff3b2ec2f4e7111aa6ca3e51167d97cbf1a332eb9db8e3a3477ea1c7bbb6560bd76e2d965eeb3ba687a41c351390d8cce0f8cb69209fbce59f6700ed386dcabc251a7a0d2dde","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
