<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1db5813edd0cadaaba23fa7c1b52efd42fa3d30c54b92d895b69be69a9c4d2e9cb2e6132b1bbee6f06bdf92f9ece032be3d396c4c2714ad6ef894e335de04a57a1e621d1c5ea6000c360db6c8c88ca960aacff9baa6e9bc7ded2d9218e2c2e39211ca0278ae59e5d92a601d9be3c20ad85305536082f2e552fcce623a7076a2092e6f4189947924bfe8d685588039e3f3b4935b8195a349564790337dd1e4e20b69ef511d9b149b333995586b20ead7325f9d55a34fcd8f6d4d3dab6c0360aed22af13dcd8b4a5034661b2df3c6078b491a1eff8cd5b9b3b000f11ecf37e4ea1ac0fc6c2332c8fa36ba3081f9da0ba71d15f6b91995318ee7a3b2f730e26ac9fcc8d5a6f79dd6a85054495e06dbab661eca40f7011bc31105c14d8e2371a629d2c1f523815e7d397c632cdf0c5ac14daf24f3f5202d80823441d364183643cf8e3c6e7ff29b6532d7438dfa083b45f770c6717ddbecc7972ad86f7beb8b7620808b76524445063dea8f5fa7a4e8d12d1bf73f2f5a7756fb47385d9f64c6a602689507fd3875f4c9c2ffb54078fbb44a1b7e5d6dfbd98cb68cef39648b8a5f91b244fd43109be061803da4a325e6dbabb27c442b052c894cf8f94d6b0efe02761080911f115f30e12ff61df92dc5fe41ff7981770ca22992b5f8babc34b6f538eca7735ef6a6f69aab5c1cf550695611603e9ac7a480dd4a42de42d551ca3318e41b2356cf62b2922bf156c5520fb1f3b4fa177f1d94e0850ed7beaebd6e1e930523a1ca97a277e80dfcab26ea4d5ed70340eede7780434cbee5f65edf4940acf0e4cafdb0d0f6e4bd6cb7fdc194005fefecaf9c89c663c10b0fadfd915050940e2d2d8f7a894950f078c3d37b3d43df1f7113e79e367be7fdf757b2af9758582fd56a1fddd77b1597cf2f15202b30a9dda49673610925c21c55d2965799f9d0486cc123ae51255391fdc91ce7475e40f05ebce126270d4e7ca3373c9e3089704734ca3f51f99bf127addd5ffaaebeca50f54bc6ca6abdc75c55332dbd88af11b115a7ad52118ef924442bde21e0f5f02e07b60479a0cfc318c5863cbcd297af9077ebb859dff11df6d8ee7a04061c8b9c0ddf3e17fcd135782a4030322b6209b251872a59f43a6aac6ca3deac05f4e2e2a2c396e4c36fb6aae5f2ff9918da3ff5377c78ffe09b5d8b941cea2a2b875ac72707002c3e3f037226a0368ae81b5203303920aefad872aa41a891e6b7a485b876281673461f5a7f4bd8be168d5fcb101b37928daf7dd1bc2bbc60863649371f1008eb86884f9b36cceab36fd0af38c4180058bd47328717d28cc47d10107cc8b30c5f7e730ffbef729d888eb289f5d6d5dbe3726edcf7fae8cc8d69835c31e3ff87ae55e54f43c3feed83e5774ce37332b51149b198854fe6806d0c36a93a5e0118fa634ded0228943b6d97f5b2e17f7c06d3c77d02b5842cb5b4c505d8d726df978722e5dff96d7bcf02caa0b85f0d906b14934193ec26db32aa5cd08afeb00dd7a902e95236185b320880619ff449a57265f53c6eb7692ee4e6e5655c7040a14e78d12f20db2d3824984a462c8bdad1bbae4fb030f615dcd69c72ef0d3233719adee51cf28a6aaf992b55d3963047a454b1751d2cedb3c88ead992855d5b080c9b1c631c307256ddf0f37d67ff89aa28265fad93f25988e52fb122ea0bb935433b21674f036318b5ddb3e301474d573b7573ff10f5ecb6b63dc3d636ac80a2abb35011296b71045305569719f0757164788136cd7aa45d820e48ba4354d5dcd20a32580ed9aecd84372b228684c21341ee7810c301d5dc9ddf27401e22c8a0aee0421ee96f2594150f76ad1e25158d086fe906164daa7940acad82dd36aa59b5d4445edbf9e42c2cc1994b687375c344b2db4c7aa87a35c9d0a605f53af4bb7d0efe28f1490ad7ac8363c1812495c5f2017f0706de33385ece0c4f22b6798b0804e96c75a1c1ce5acc03496a5a9980031ea7eb727cd99d40029f7077ef619b2bacb84ce85af2157cd506bebd89e456f12ea355299c335d66029ff5986e4d6bba681c1590c4e39bd4cf50d934b24984bfad8237cecc90e0afd0726abcbad21775454754efc85b7bff9c4854264c7688d269a2064ecc55f7ce826fca13d9195f439e3a75a9e0af81462277ed5fe0504529476df29f37d6422eb1179bdb3ca1c42bbf3eec24ebf430966053917cd15f8bb698416777cea6aeaa08eea8e441ddeec4676b6e5845069c8cee4cbe24951f724ac4f7e67161aee922537da16f080059d0f8427222cef945db86526d04f7a480a2765cdde1988cfe81c7c937d71ab8959407179066b582462bebd4e3b04af526f7371f1f0a63b6cd7124fb4c87384e9ab7a6ac96e453a07d63c7d4f0b0a6051140a07be7678fdca2b38436ea00050a8a701f1e972970996c4dc7051a30e7461c03b547e01e998b786eecb999b4774ee045088fbb18bf6207a64f7f3f79da32efd5d3e9ad90d1cfbb25227dec45360058fe8ee7a6145312e184bf1eca21279b9bb24d9667907fc1034ce781ee3a338ce8578d2fdcff576b2e07ab086efb1b12bf02bf83925bfb8dc876a36699d734a5c1ef08fc669ab1f34abda48cb9db2048f31ef9fda943f0e7f4c61578015b3bf6507bae1237d8c5f5b1ce816ef199bf32ca20c581c30f4f34c98ef5d4a91511ba14b16084a9251f1e03abeecb7d469b5c3001f60057baa15aaa7159170131f3a25867a06f3399d6d7a55ba88d35ee162ee3b19b9e3ea160f2ada06e8c2e55b40fb02190a14724a2d22b37f24c95c51213dd490abb4e8e9d36fa078cc9b9de54e78e6038ad7283532724ba3354c484f00d17ff8099d3eb02019989e34f9eb892a14f87aa352b8912c804236a14e9696c59cc2c869ce965d75f199d22568755e3141afe78fa227998e5847d3cb5967db5bac85a8b7d16a4b97d6fa936cffb0615447530d36c1d7f45b7bf9211bbd61b2f235a1603a65c63ed06d1eb99de0551e5dfa91dcb450d2d85bda67860a99cb3e1310e384fa6b8bb061154a2d5413fbad2def371dbff4dbacf41ee94758be26554c9a68b2617f5b7286b9691067dcbd4044571b231a764df238d47f68efd01f1370a7dabe232fc778f46e90bbcae4dd0aa57df7e9563a8db5c7836805a0dd388652bc1453448585410284f566da2c824087664004a067d995fc7da5a8ecdfdb75f35886268aa93eed7959962b07be1dec668d647ce86bf00a1a67f65db194977452c05d76d16d541453a1936a0ad3501faff43e1db6f3a7c2f8fdd027dc602f5275629b01525913a2edc7d56ee4f0a6b8a1b96609a106944216ad6670f665a46423f1fb4005084c010caf1ef891df72685f5b13c129a849b533c3156c6677f56f82657642fcc0582f1c326635f80ff25049885129dc78665cb9c5ea39b11cd80b450b7ee31ea52bb77176215150b1704765df8398c7cc386f359f7ffb8c74385b72e2b4f72b146ed63a3e979ef64958351ff2eb69dba625dcaa31b75d77b66ed5a9c202b07dfca76134881df3dc0a52a102438c2420ddb5411507f74ff2ac3613f6ef2e24130526c650fead2140e9b85c7efe1dd97ac68a686f4bee460371544fb05ea0b77a65a547aef3d90b6bca3fceee23ad21fac53e86205ce044b68304d70673fc09ef7c9c87c874c010f7514123a214b50f7cb872ea76e8c64c028dca5e2467efe15bab6bc76e31f5488653ddb4333382a110d1be8f247a969f78e45b793f5fd277126a93204503d2e1332fec38f9cf94d56d7d0ca27fd014c269ab45deffa1d4fa5a05f24ec10b301ed763a3141ee4daf045bce855d2e5a9864d7358f87ef78a581c26e8852eeab5780ffa21319825441d2d6e90079a81ba9cc8f0469c5817bc99f5367e46f39095911b54f04b14ea9e8c68b02afdfd7a5d697b74a545805001621ec92110e1f98270ed97c4ffe42806187b59ed42d66c4a5b99e2ac93ad021a601734d24bc8372d55754ade11cf4d0373d0a2d41b84f822b2531b49ebd26db9d578a8dabb7561d64dc4d8d2832216036ccf8c0807d7647ccee6a8afd86351b36f896dab65ee60cfbc04b94672862e59f39abe198be935daa7ce18d6f5e742c0804dff99c1acccfc45f21e8e2fc236766266fa019968957c9263a58bb554d77035f90e1c3ff6395ee6307fe7bbd2246502e7403b835d5b02f4fac9e9837a5b010f8776ac49ca6ddc17995d14cc9aa56541e0e8f0f813ded650a15ad5b6ab7980aae2ee3fd9d1da944e0c3b8acf6483e9e3c3518a92f4a6deab2c9cff98d7c811c0f2d0bbbff842110018f18e105ab76b86eb18c87a73bd509568c985fbf8cfd6890e0f68eec4337c6b628159cb9f58788aaff87a5b77f1d873749733af240cdb9ad2dab109a5fd5e6a71416c41641fe84d16c7e259f93c265b2899c1a622471bd077983db04adc4b9525e2bfd4dd138334cc2a72960da917fb7281dbb68be140babf0f310d2110deec39ddc94a39e601597a774040161453c8490294f30ba0a813ec783133b059172e9446c7232c7ee99972f156b4b40f064f7e2ef2af308b5ffa308eb53e9f357086a4fefbbbdeaec622851f0367b58e56010d40270f51e2bbc1fed5d60e59d3df9dde19ad8138a11fa6f23524350498739232b6121cf8fb6aa896f5ac96bd096cd7f90c5c48835c240e83a35e261dc0fbf571f92f39dd9e4fe660a6bfedfa1a3abff582eb41b148e48e8bb0d0f13eebc4338c000d537841f7f70669b4e38714f481bb243bbd0e72e326a1c09359d776a4356172f7167ee420e11f7f0633d1193a9ce8a6846eb53ce94c8a402be1d21a383a95fce20750796a9d0fb2d65bdf3ade482d4f0854dc150d162cc2196dc06d4559a156f4464c6e06c6ae9e154a5ff0f268f2d1533c172fc1a9cd5a5acf2e2c39b0a1984a3c4a1067b965647fc2bf5de98d49f357eb3958124447eb57118aa25271ea9c4dceef01e67db74b20708cf5d4ff2e72a89a4ed9a7e98c071bab3a6302fa7a5ef47fbb260f7798927d50a27f1a0145348dcc85ef148745a361c1dd1683ed06e166ffa5d974b56027efc917f26034255b2f729ed05b8a8dd47ac9a6bf573068d1b90d7dc6c62f7e0f0cdaed253b087b91142de698866089e57b8abfa3e8481691f1074e0dfdfce3aee6baf4131b5ca808a66d9174448924db728167af01bcbedac62bce065747a92634372cfec2f5ff8414f709404440a81bb3af50bd93dfec4788f1ca9e5bcb6a0a86b471f4ed8b5e7751618676a313d548ed33000b39063aae15bb2319ff83a642364beea73259625be8289877df00e5cab219b20293933c6177b2a35bee5fd0fb9d4a5a8ac86133fdc82af94206aa5364494f6661603870c79d747ea8f6ec1de25c38a6f2643fdbaec782056f90daf4353b42df32c2d2c6d51c853f6bfde9de8ce4f1b78e3f301cfa151e180fba5a821c8c6729c455119914bddcca2bfcf2245545d656ebae5f00a9653e6546eb2cfd770dcd0e13436c57089a6a9db7e9fe73ec9cde7295e911da3d61c48920f64fc4d61ca76d62d88848ba7aefaf45b8ef412e0456ac2f9d3128570cc45b787eede1a7186a27ce2aceaaa77379474743ecbe49a685601105e528052b8e11e3ee785792facd743a53b5ba25b0aef4d9dbdfd1fc1197e173af55f34bf3ca7e80daf561d42da270a0e2bed8de350b7abc03d966d00dea15125c90324c53f22e35582c4988969210558b4d4038faf82e0f05ecbbdb29116e51b3ea01d0f7ff7171553ce6e39b75eb644feed8ed51ba6354126713f2088a89b9f6c2ffd383107e76df8a4644b888d5fc9de6af8edcb8c9d3ee27d9a713e9a50dabd4489ef5f2bdaae5c1b35198430778ac12761234c08d1d294441495b4bf4600161eba9bf56880ec8164e3b87fc936e68ad4c4eee645ce8170780573ecd15b6c5c3a18e432f8aaa08486e5103e38a98e043f8576b52b54603582e2e871789947f1944fb5f3b078081f49f0c8112b2c0c2155dbbabc245a5a1ac59bc8fc91b28c627292410280ab99bb53e205629222ad18e312bf42881b1f3803293804f5b9990edfdbae7692b6af251073993ae984151ac386408be37c31d9d64f2ae66ed84a6f2e386a66b8e09b6a160e85543ba82e9d43fc0e3c44ab121a2534852e8c80d7f3122fd30095524c383078f52cc35c905a97e21a50aa9d2c7e9c61acf20e5dd5d716502bb22abf3255fe1c86ba5adeaa1349afb104dad733b4163b0db706fab46261da4dd5057112bc5ca4d86eb995b90fac87e766cf629392043c6f63fe02316e6e633d990a2aabacf0aa8343d64a9c8c93d66e5f5a2021a5c86f6b168cff5d92e23ca655710699a3e1136dd993d643c831cf18ad6f67a274aee5b6d0917806c297c53c45b6305c43bc7a0a460aae70b86002ac783a5679d4989b80f2b4ee875921e9ada974d9564bf537b2af632aad188bb7f2d6cdeb772e5d032191ee35316f284fa5dd1cb5866db0b0c5a2da867c82686933cbd68b26b2ad614d468208b74e7a2cf3c9855e1d075b9de7626c7d54fcb598ff48b2d8070767a62d78e3bd88d1eea86e25aa8d472508a99587d78beae317a0339e5369bd61696588590242ffb42dc69adcaa92e03b0dff8f85fb892a9aeb7e510c554210f31d98f168a53ba3e239c40a23fd2760ed791d272eaa03ec7a9c7c3409e9c70285aeb578bf99b435f770e963924288eb3fbaf71659bc3d86898c099c49ed88beea778196f2a5c53200835868009a938a1bf70963df73f6d0cf8a658f7eb85091976f77b46c8faa8efc9158cc8936fbf7daad1a293efcf379ce9df6c1105fa22aaf11d9a370ad3abda2b3307ed7f43f48de56f014e506db043f6a791b227a4a6007dc675b0cf104d8d956da1cc53fc510c88cfbec4288979ce4a8a1656d010982454aae6d45c05f47026398b0a907152cb7d6d268c080d14e1fba47aac486bb56108d92ccb7e85ed3940ab0db6e1fe3c902dcbfce635ecf4d41568ab9042316da452b5cb4612bde7a4dda8321a75445fa07a153482285ca3b86176b9fe43516156d319d7880f5ac028aea12c0ed8f7e87ba88a98a6976d65df7008a427db01822633ce0ee5741a078364d78e8baaaf19a6405f792210d9c35658bb3583d87142a9c6c370f94bfd107b86c31589271b3efde8e68390fc1ee4a479e5169548c3ade84031d68a3ce6ddd493f1b46e3c81aab2e96efd6a73ba8ee43d841735eb7425d20b6e165f9b0fe6e95b6b68c41e07b9100d96253b3c401d725e8c0a17f7a5b64a8b063812fcf74b1a31a061ce18e384c4fd0ae8b7169f8e4948435eaffbc5a8e9eab1a6d7d94a3293179352af1d4fabc5994264cb2fa8f549d8c962ce86b1727edfc15d1205d44b5b1378a575d082e819c22514a8a5753f0a9c16ebc81959496eab56ef772b4a0f57cf59247774c79de486f0828a029aafa08a4dd4d63fe5d84753991abf868b386cf62cd94ecbfef18ef27d11e8f5a35eae1554584929dcf1747c94848acf4123b0abe59258173b8548898a224d4f795762ee397eb4ef8749dfd323b09ac95c05928366650854b48f2161e378b5d1e1688601fa75a368336aa919207111cea6c66e5a53e75be66bd166584f516f77a959cb236ed47679f7490eba03e8b864772edebb06bf256c5165e3e248d98149541284ac3f6480828aaf04e69eea8fe5fa1ba33c1e97533009d3ca2aee11de397dd67fb317dd74bca01df38505f72a2a1e9afb2f03c95c28ce8be2b38b5ad4e2bb1c8f40606b430cb3a6b92cdcf623f26d27249139d7a11fea2010f0651661b76e562b47362729c6e3f5f2bf47bc5c0f1f9a042b42433b16d0f2a00360ae027230878e5b2a7354b4c257a0a521cadd3beda0b67c7085d8fd6728fa68646db3158705f30728b1ece835dd2669935bf93e8ca59691352b42e8d8b50bf092dc54000b6ec98fc1c46cbd80526a79eeb78a91158b894c0dafd63a99411c8d30ed3435d2607aaf52de864fa5ca90f24a2625e2995f39321f089a9cd876863c9144c441676220b83002d2f5cac3aad04c09c593af6c1a2ef5443e8011d8f48672c44c60ebb49b1de82447422840c50fca544ef36d058473b72fa2093db7bb9ddb600ad6e9bedb0d0d1e053825a0e3df486a0343d10aa738f2d6c7276e88db15bc104b5a0b3aaa30128b45796e03d222472d3d21db6b3dcf08a2785249ec645955ea1738e21d069840368a15f9a754591081644bb7e1af0138b641bffd7f13b749d1240ccb3764573e2a3f15c4e964045ccc054dc4f3e596a4c2c51f8f3e1e3e0aa9fee5fbe3cbc93ce58676c873b5d815e39afd34efea32acf7862c2afa1631fb6a8cf228f90a6e0e2ba41cb4db67dcf237376fd16bde3305f3493996b7a8bb895ccfc9fadbbd74e90c9c4a5404db83854f35cba948000b1ea0b67e33e9851a057b6490818d7d844d912191a056a93a9ae95a2c1635fdf0ad692371a2221a707fef41dc0926ad4eb59675946d028f2c24765eab4875f8bc9106a3883af66746e3f373347ca30387f1f9a175ed8a3b21e907dc28ac11adae3a09f2adedfc00772ca3a3241f9b34555b14d86a2af321c2c02a397f4c6af2968051032196f30485031b7aa2ec46513d300abf2894cbba64928779657f351638532842c5348b2c81480a5bb8a0db3918987fd0f67783e95a1dae91d169935f3bfa6e4e7769a9f6aafb5a04de58780a7cc2e3d4531245bb434f7fa1b6d45da973d6eebed653b69d8cd92c08b5b8380206565c9a632948f14eae9bd13ed9ac0232eb3ee346a197314328d0dd9a15680aebc5c5fe3ab9cb221571e53b2097bad3983b40cdec23bc8793139b66bb4c9a3d702d1867a5fdbb32ff252836e137a5710b4f78dde3027976411a551611311612747f21c7ed0e3d5b3f95dad38d410b8afe74fcd304be7877da011d59ab89ea2316f4fc6b111ca6b8f72514c297af570cc0349210b2b2e0950d9ba5d796b5e5a5ee9582f40e089d07959f2a218f94eeae17dcc1dd2bae9df0c2876d7e9fa258ba90e97bdf692fdbadaaa2c266446d370bbc7a2cf66d7d8738c93a5388f1fd663652467ff31792fcf26bed15af7ccb52bc4a649ba6c0f5648f7ad2ecf4f3fbe127b6e4134f188f62ed0ec374d7869e2975b09e7e9abe52cf7593b136a9c7bde6aa3dabc22cf7c4a8255483055ca7cd72a0f7b1d14e00720512253a197752719685baf15fed712ea5bd12fc289165870457cf28c2385c54c33b243d4463c152ef7f5bbbb6e81875886af7e34b35d33f6b5abb2959c37eaadfdd0ffb89921ca4acca84a7400b4f5822ec98584fb2229e5503245582f147cd63899e6cd9915933e936ffb27aa7ab900aeb0e352231d3af68cf76af5911b58a67a785d8099c73f0c8b76e0052a2f60a94e82f0bd91f4ec3dce29a65e8b51060d3a50f3b3bbc54d39d1d88ace1084e2c62f1c9127825fafc46b49de3f1c0427dbca30be08e21e06aadd91a99d267e1745b5d6df6089b7608ea045e9285d2edd1594f5bb5909fef34a300c0d4f369ab2c5df5a1bb787132660ee174cb8d05de85b9d5775485e7e431afaff123d447f7909934bb68a3bea23ee7cbb5f1bedb7b87ff5f1e764ef3102c2c9caf309f93f899715d8aa9d1cf76411cb3c764fcce2fcc2e589516ede6d6345c79d769624ac3bcb5946972b72ed5480c826ee59ec867a03c53cdaf896624f4e84662dd8f7e4ebf17f38e0b8b4aededfa0d27a269311e4b88ef3a1bd3c6e82f25a38a79a5f62d2b83f7a650e029d3fe01c16dc83e6ec151cad9bdbe347e3c68fd7fa356624ffc9f5041ccf31c286285538d66868e6ad30d24e50642c4ffbdf8d602420e52f77a63821266d6ed4f6486415adeaac4f9ab4d50ba109d9b9f1d152f689923151cdd9b09ed9c135f42d156e3637dca4ee2e22cdb873362c50cfecf03e9017c0d04c5ecb5048f6276bda28b50fbc0fc06b35756ebb48869099a5d52ba6b399cfac3d8884510f0a1ed05f71147136a504c7312d233e3592d59efc388a490bcdb85100f26bb91b9f8f9e310fd23d7e7d16c32077bdd2a53454435cb9bbf56bb863f4c7eec587786105a55bd015b32922964c2c740882311545c7f2aa7443052fa2b9623dc9e32ddbc813f6a7f53887462c399329fc05f1b1c3e9056b04242c7bd9a1dad731eb04ebdf8956bdaed9dd67fb056cb350b7209b2fac167033c9cb4f5aac0fb9d0bc12896643a924bb4c67ffcd6a3e65709620e71ac633c79684089899847c4d1427721f97fc0e939f41f0fc609af718fa97172bdcbf8fa2f01ff6a86380d8ee93fce95e2ff571bc1bcd56b66349eb5df131c76e18535ae7bb210fe303644c4eba921a0fccb39694513a5caad003d58dc6a1e21c0542f7dcc90dbe0e0ad6a0dd880e0a92fecc1c9fa056209000975aabd57cc3bf3f6b53b33227da8307a5db04cd373622dce140ffeba53feacfbf47b1b618fff8032d54ac440ce7f81175fdb0e49a908f0c0824890134e4ee7220dc818d7c279cd39610daabdb5e9a64b40b92cf976cc3eccfe79133a8fca0064db400b65bde847ba09135696baa2011673abd0c5502e8f03f7f34efb12d571e29562c5b55926fa976dc1b8b4f80396da8054d2091f7b5865df23c2bb72eb298593fad1722802b5a16f51a0d2f5e6942e42ee3abf49126eb3fd871c15f68e55c0706df462e0c2286c66bce2b0a6d7cba43beeccba77fb5557c2e9251a433830092003e4bd3fcd0a1a99c6e22731017f28c84d7cf77520853a3dd6fd41b851cb25f2bf5fce7d87882e360c5ce8ad224880c267a9e43358df0755eb3ac9cc45c3fed77235131ec6584eca0fbab3a5425f597189cc6735dc26e82ad1130bd57fdf08b673f2a8f807449fcd9c63eb72c00038a1b833a80691a83a19173906fad0db80213e08c3892feb369dfd51821f2abd738860884e70bbb0e54557c6f6ef88eefdeb8634aaa995db20ab59213cda146bce95fd3fdcce768efd431ec725c2641adeceb19c81583819ce75b3647eb369e0850dd5d13633dfcaf296e515b01e1355f5fc862b1499ad19e5af0a89e3582422c7a6b0359753bc922a7bc30d89822d319f34869344f279d7149295c95d7456e8d07c0cba71d7645815e886c05497772218b7f20e80f2e4d1e262eb619edc00ea5078c807a073ec05539ea617500f865096e6b5c9f6a7b23f85881814de263820653988dacf6f41c3486a0e5461a07473c8a237d5dd1c9895532e85ab918b46480f4418ef5989a52994f6fb9f0d63b05f29dfb7e77b2c4a2782034cda1891edd49bdc5ddba85c983510d8264f851c07105493b267e58e2ff0e9d978ca5ee7a40de8320a2d42f44f4b1f9cfd9a079ec8126f157454c9a1cc450c43ce1082b9802c090cbc0990339e554f31ccd550b877227f21b0845a801ba272af269930a59af6df1d7a1ff18f1d49d2b6c0930d7f92dc81f2ece25c9a6059a7c58117bff4a60c532d8fca66998e9af3fc4ffb2abbb2f521805850cc0e9989bca0e73131f35391184308073ada474e2b9914aee907a53ec71b723c8c8754df250efaa03085e6ec5a84c3a265be9b38be59646ecdc37349a4f1e7bee03514e8607f7e974a79169b6fcef0f132a9fbd76fdd8ed2e46428aaae6ef31a4cd57a665a5a39d675cc04a2456967b4109e1f3d49aac19138def2d459fbcfa303ff650f340c12a9f1ffab44c53cc3450856c51b5f2b8941954f02a407a93fc9606be64f7e7347bf074b0521943d3db4fd3f90e8a9b8323b0a27c912809e9d3f16fb2c0b23c941b3c03795d27c1a2183e58202f469dd87672b939eefd9a5e972ae5d8d7462f5e727509dc870093792fb67b5da1592e9cb68e1df34f59514dab06a0fbe0363e85bfea4440351a780a5231f9c8646fbe6266a5ae817d07cbdce369bcebdf56992ddfe0072da5122cbce12362e47e508689646e78e3b7e10b6b279578aa04d82eee6e95c2c23ed7e6d0461abf8a2d7329b2209ba4f5fe60dc7308efef9cbe63c565e507197a1d073743a1e8bb481dddd4b1f044cee92b5571d834e3a510943044fee6a95b68bf5d0011948b09a847d22caecd0f4ec27443748e89736d01931ee11440695327bfd311566d8d0f44ecbb2a89df401deda2b390f5ab927b2af108b4b8e97ceebdedcda065040f1646ec410cf15a396889f1aceb3428e82f83825ccc23d86f74ab3351d0e03d242129accccaee864fa0a6d9493896d4a142493c1de185301f0a819bb64fcc9d1c9ce804d2cf4c54745841171661f9208da63d4185dd8ed2aa418bfe70daf7eb7d9cc22051fa3dbf629acfc47a27418c9abd0fef937816e3825e51e892ddbc473cccc8013c2cb9bf9c2e760f3f5d1500e2dada8d3b5bc4fdf088df556a7e4560e8cc7533d65e0d7b104cba8a5d0c10680d978fc4021ab7bfd10a7e22da8f09924209a317e8415fbc59c6d04850cddbbe51b05fe8de5559ca439b6569910b524a82ee72a6ac5e3a674f3bc591f30e0be6be5242f5aad1d515a12e68753c0c5ff6ffb8d7d7e2f0b5c9bf2d587d7f7c6426fc4646a9e081cdddc5c799668622e056c5fce82a8131964d528cb61fe9bcdbae2767965ae45a31f4e31fe3b8bce314ba0fc5b3c6ca50daf8267cfacd8f19316572d4bc78574eb0d8acd106b299012f42cbfab7185b200ce6eafa62336b967f57f4f069f43cb25e2fe319156f814a0edbccaeff9a05537b9affbf1b8813af098e38967a7911095b2a35d5aac07a221264a32ad45eaf165033b5ec3120210a2ba26a45974c0c6bf346b9cb43d62ae211360e357e8bd4a7619e37d90fbe3aabcad8e00e8401b4cb3bbeab6b5ea97ed85b80420287f4162cb1cd43c460b1fa37f58cf1ff23b492fbecdbc6d4518a2b2cde15a81b191019b27f175d0b396b106e087954ebc6c43921eb8d5f85e734da1bd91c69d4f06d237c3bb990efbceecd0f278f1a656f7da3f9362204e12ca3a3e743c9e43546cc07266f3afa8c31daaff9a2737048631935a1e819d3657c8fabc964feb08988cc403eb7d5e14bc2d59b814325429106ef2497579bbcf896c7d2ba30f561713d1534e90c618b0d4dde170e8eb9dbd17aebe7f586b2ee36debe2c148ce4b70bb1e7a28c4c29c6f49e6822a2985f33c923748ad2bc00f581ec17be340c0503829109bc4ca8652632683f68145adae7c4b638839139442905d4f0ba4ce758ff5b6c79501caf60c6851566f882932116206c4765d7a415019446453fb3ec6229943a85de323e07c52b62f9395a697c024d4ebd606709c6963ad5cdd127acce60c1b754a76c668a21bec48ebfbe28939336ac787fc7c6f1b341824cd3b59671501f6c99635f5c42ed29e9c08d18441ee139987fe2b6df845db8264bd7e147093bb2b27bf35902c8626a5a6910de305cf865c764da3def271af72da00de4a7de082a106ecf391167f06847cb67d01aabf7d3df6f2bddd97c26c86981fa8c938994d8a3bae4de5f07daf93d87a24d9b8ee87847ccc64737580682006d59a6d5023aa8d833b88fe00bf5147f9f2dd95347d9091043e2a4510a07f66766338fd3428d27b6a7186e9b6b96686763bdedd90467ad6fb86b69f577cd59ab5d8c1095f5db92c5ebea81c8204139e5550afb1c5a643dece38728dbacbc59d30961fd02dbd828c7970bb80c8d73ba284b76fcc25010026f19e15db8ffb3c4194f5bdb527f603cabb61a1450241b81137ab56825a7a9bce922115cf8f92eab08c3aa60e591b64aa4827aa50eb3c59c4344c3894b614dd1492f83cb6f6ad963c6a29dbba772c6adf1e6430f3c992f118405f7f763e7ccacd04939aa419ab3327741f62b473c3b2533a5cab26af6a716e03006988053ec4bfca6f0759977b7f856a08071b7e22679e055b91e9f22369f9ddc0f292cdbdad1469d5e5b690b4abd18ea5ae2175500506fed0587a39b2b4bfadc5931015fd0f15dacd9c747d813b28375df3c7ef0b491d7f4794722a051deb1e7d4f9513b4cb018b207a12be380c6a94ae7686045477ff4ddd5d36af812a4b15b1949eb16987d8d7fb91d1088df9ff5794c28eeabe6d9b6df0f851a8bd5a700ad0f63b72a7c406d07e3ebb3fe4e338f00d6ae3a119a2da42bb30ce1c546cbc3e88b643116081a53f224e864895417bce5b58bed083f3f7199a6d3de53e064c3adc53490d0ad82ab06cd2f82965bf81322b4525ea4386df3d6329ad467b3a2c9a98e0323e209c947cd106c020c5630881d482f1b5006e12083bea2257216c4118cad4334c82bb5f8c2f6f5381387ba6a419b32d0a563545cf1c936b55b6855986663f42a4150c3dd9718c927f0a452d003f80a04354fbfb2b487d003dfebe1a92af58ce81b657f7e08cb2b85026a7583b88cca0988100b65587d5251d22ed134cab59890d721fbf890ea035dca5a9cf626ec285571988c18d2612b99342b369af1dee7407b08a1c5b23898343980233be23542d2bb461105210f03809b40548ae5802c4f17f994044d9297f1b53e51e0533e90b44246929dfe90bf2e5aa41c13112afae2e17ccd4a3f8fa2747d8313d27400bec5be37b70836fe6d3644950e935b19b3e883f1165d8556e81a20601b1207b2b6e75ab5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
