<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"68c119604ec114fa9b2df0f8a3bf3548924cb49940ed9b8ded3322ea6f2c6eb372bfc8eb02539e1eedc4843ee189d2560413e61970976b683cd51c7cb319f2a260837664692bf815a08c336dfd649c0abbaa51e60eb03f1237577b29b32a4fe853099243b1149b32458422a50e204d511ac476bbe2ac7f58ecf77b71cfb4dcefff33bd873ae74a6f11282366c5c8ba40e9206970808720f14ce07f46b7f2a6600337232619c64f76db9603c08113dd837901be4a2cfa05565839b2cd5af03f6464eef9a85aa70cf5c6345b7fe42e2d0a7da79b349c5d7e435931a4b25c095915c6dc5f63a3d4cefe49d9e157fc47b034280c064c5a8099de324c3eeb014d7eef3abf2a2c3087c7b2210aac3a536833e1d249c1fcea95694fc08dedea06aeb62f3b698977b533dfbfbf02eb8b13c51be8719a204de4f5c305f4b27cf3805c8b8cfd0cbef3f5f672cd43ac2c68ed50156c6b8c5cfeeaf72c9b92dbfbd34ecd7770e283012ec485aef4ab0c9145aa31c5131e668be20b504f8016954c577060c0bc4846c6fed911a7c05bff7ddfd4ef809ec07ca651b7899746dc2e16b47257e36a102b52cd61aa88397d3a66393ba0151544062ccea6602184891e560df739179061b19906be0a7e2d774d0c9095f48a726895632044953cf3af50590119762fb1a0c17bd8c77e6550415e6981c4c466c2e56b11849b4786721d342097abb99e1045816089f4b83d2cd2798aa29a21deb8bb521fdf036c59bacbb839c28c5baa30340d96f87067be276cc478ca6b1dcd489e3077be9f4c9a1e66230afa4980a6620150094a4aacc4de281f336d717c9778a1dc184023ad343e54268514ce03aa93479416a64c1693ba7edef6bf34999a479ae532be1dea61531ee8e8ba2161495bd185638b20bde70d2fc996b8fb8c47cb347ce665d86d49b1645cab2f0e5d7cc07e793a886efdac7249cceaacebdc7bbe391277810f3a295809fb6b5d3f89b44ea054e35f3decc99435e1d611ab4b3c9a4a01317685227d11a77a818c05f52f4a7b1ba18603a048a6bc5ee631d6e418d9c6f49f69ff4940e0a4e251cae01b4f485903543d3e9f19e288a5955da79098b12f40a0237207fa1c4d30e0c5ba59ccc7bad29bcc84398f12a9486300ab35344c80e2389cab3e5058207f0ba7b29419506b7020cff033980d0ed9edff29c72206c66f55a2bb12fad8a66234a8bfc2b87dea2550c56dc9d83c7223f2849894e876d2218092b0a8d99a76b176502bbdc6b36a4a7fec0f26a4cfb2b6e9533aa21e4456b0fb68aab201459d1e63869f3c3c1a6ef58899515f64bacf0de2dff31180206a9affaeb52a12354fd3f11a786cd90e4b72608c5b553f33deb8bac8881ca27189e9be373acf3eaa8ddac239945dc6300f91a2dff114a0f217133aa87680c4263b5abaa78dd8cb917028de1a0533c3481e32d4a4b8972198f7cb1978c0b307b7c37c05adc4352d98c25cb34be119407787e7ed0330b92a3af826aa77f24b0b52a2407069b37881e0d640dd45bd29642bfbaca67ea652be97af2721b08db09b0efcca82e31378670a94890d72261d52dec862b2341680d4476e750270a189e040ce4f9c1b649c2ee23a7dc9d24c41709d24d5a6555e0af0d250541d0572fdd8f01b75bd4511a8d700d6274b312e829c5de7688a1ce3a47f9a1ee61a8a6ce8c7d29554dd34a9f8257bd94c67532bd374ac2d7ff423b894237002ca8654b4382bde401835a713629de5dbe6a05a92785acfff388968e81141fe05f68522a147b37e8481afe39159431a0a12faeccc218505b92be7ad9df28c417be45348912d9cc152ec78758a66b7db39ad192883f6217ef187df9786693c2042378d948078423602e13c52cf1fdb1cea1a23b3d13ba2005f441f955e4419f2fe7090184a3774708ed035dacc6edc02c960dd40cec3e08de0c76a8f9f3478e405d2cc9b66c62a4138b584c874c18086e64c03cbb6c2a3f3d61ce522b64f38ae0489fb382eacf330f230727e1ce76a8917b7795dacc7e64000eb3ec5f50f6b54a232d3efcf7491c7b6bf756fb183925f16990fd9830388d3b7fa2beff2bc4f8594d97933d7030cbeee2daf658e5e356a84942ec260306446de0950fb88e90884abdc99ae2398e5d88f8daa1b8458191c246483a356b5af3f95c0fc7a5b640f194df1eb6a0cc6f5b060bbfa6ea342134efb9faa18fefeb5bf474a774675d32201ad5f35fb7c4a026258cb68548f3248499e3631f7073c5f9848ee4e37279dab3acc04ec5f1a23e6dcef08d143458e769f441397e6b5229d705f4fddd3a2b79089dba19eeb9dfe5fb5b3864713a42b03afe2e3e354b1fb1b6f96ee19e810be042e0f282165695648b2ce157343052d0b31cf46ace2c206060dba373ffb61695cddaa512439c7068c5d6df7019481227160dfb1a1b7808253a391438b6d82229ce201408d8c13fe47626ad864f4fff2ca4b489b6a42956e9bb4eec61d965ffa34fac8a928eb056a32db6fc158d6850d995a6d656d6a6f82f4c85484c48430baa53ef3a1ab03b8801fe678f9988c99dcd1c46a7db9bae9f53c6dfdcc59ac2d535b2832edc211d57db380acbb3a322986a2e1f109cbe44895fffc52fb0913f1ad8370ba1ceac720fba7c354e50ff6a92ad69988dceeac6af8af814a37f757b1bc39d9be66b6807ab5f669705faa3cb85f2801aff40cb1de2f729c0e7625233a753d3de18b8ed2e0e6454d0bbc3e23f1c7866b6e4596a75a59b928f9239921bb61a19739e2d39e9f53726f1c8826756169b0c82570ea32ae48fecf9fa66125918b2fea8f728c659e8dc6bb9ab2b9cc0e2dbeeed46e77c7c94e848b3021a06e463c3fc1dd15df4d5608f4af6430f3a8114400139086862ee69930cc907f377eb997ff9d1d86962e3271f6a762f6f8a0307367041b424b0e6c723813256633dad04eacf0808c695fc0a8a5f8f9b2de733f613ca325c0d6c8bc2e82329064492e488283ffa20026ab3e002388da4c7009dd48ad685d9fe171d404422d0ad0b847100cc4d5503e9c20921cdb98896303e0293056c77f91e885fa37255b148b638ddf8355fe3dcfd3a594c60b47d22b3eb48258f088e4c95b961ba9164743ed3172dc62974f33cdcb75fb0a77c4696102b79e0476d1b30fd52bb761ab76b144f1f6ee47ad6df34e27dc81a625d0193a92f0b1243037fcd76a2ffb5d7a5bdb22b47a121a1da062f8af2507775c11fdfd7b49a2b4b13bb29d9ce80ebd34d8544042ac40235cfb642dec66f5f568456e54d8549eab35093b0ea832a23fc6d8f1e3b0ecfe101723054e2d15624be0b40e6b0acc2d9f1860c192aa6806e4b56b5a04dc5a49c85d1f74c7f678e94f9fe3faf30b16d961d7cc613a8697ecb51cbc31ba400efb33d16a4611c35a6d64797bd9c8674e783570342bf7dc7e20991f4327e3655aaac00c99e1d121434a23ab4d27617c5c2322f46d6cb8e1121653ff18f096eabd021cd1898531502a1d5f1eda809d12f03dd5e87fc0795d3af1ffc5ab4f42971dc0b6d4f5404ab82c6d254ec2d7aa2d4f4c3d7342a8c8a8d0b989d205d5ed0803f2276840fa0d32f418ad7a4581e229e1c9bb449bfe2a57842f6565526312283e00b0eb35fdb1333f1fc06bcd48f3e2727f3883a63a93856b99596246447770d0a060f3344391515ed3e9406526337a2ecbb970e803f013279f271527e9128c37de3b73bb4459849ea1860e54ae8b43e6c77432560c5c02a1002b80bd5d685ad4601666ab6bd3d0dabf07908a2dce10d3d2eaa619fe35d960313fdd441cc577ee2d12081e10d01b44e92d32738d38f0fbf7796e6f066e87dea09db04b26e397e9b30770338e04c79940135b4406d8ab6f799d5474b947cef9ee0cb7ff67b26fa1315b35f64fdeef37dc9eb088bc074633cadae9e0ada3aefbe4bb7ba34c8f8aba129576c42ff17d57e38dd7e1b808df30e51cebb212f95f5d37551d749c22686189f9f181342c03c7ac926606205bc95d9bbdc6b63721ac48667d87f673a5dcffe1b74a213167954b03d998b32dadfe147b2a72dadbe395430ba6ae4de4ea80023652336175ea42d21014ea09aba7a3cc5831e231c2569e47dfd0256ecdd82752ca64ec457532a0d3c45ce3b32f45797595484cd74b4462bfc153f5ac90b8671ffce96ea6fb2f0fdb99ef2018fefa8421e3927e36fb5f172f13d01617f98a51a2dac93b3d53c536dde0f70503f32a5732426a261717e287b5d1a6d4aa3d9506874deae81def19e0e9578b1d5318b8540e4b1a7e7ec5af9d7bc6ea1dfa180e452994026b0672f9614c6bcb8a97c28245619dc0b1325a3b760626d9ad236c33426a2b86e3d21fb5adfbc0ba15af399d492095b946986550097246413a54bb608b9c29f580f73d0e0eb35eb86449ee758e0a42074cf1506b272feb26934ca592e1fa9ab53cbc46697d39d86708062bc86dc17c4ea04c3849406a071eff55f8702c51365bb65300bd095f1da2c3c420495e8be6a2ca70c79dae3771b9116472f8c83aa69fdcae0483ec601a36531fd45ae761066bb3df4cc1ae77a1474174b09c0b379e9970e66b6abcc66afad18f2061fb928471d1fcf6396b8d9e0bc6cea38a620ccadb258b768bca82ee5cae6d921a622047a58e8a0f393610aa81413a9c1f283491afd1b663c598a51d133ad0bbb47fd8668bf1d26a1f2e40708d71cb758eb403b6b883ec125dfba5f6d2a6b7e4257fec12cdc8fe33f032b8e593f1aa12d72e5c0a2423ddb8b28abbc54a9fbacb8b743f9a98f20e08e68994289c568de89b0aa4b7dad077e0cc1ef3335e559f1bfeef7ad17109f5ca0910699e4019abd00fd2e14ec63985fe64e10ec1aefc9af113467c973e786f81d93ccd516a02dc9de9ed66021a445ea75f1bb5831a2edd447d667be72bc7ece8b160c9cc03a692c82bd2e15585d65e5dcdde85abd6779520ffbf74c04920acaba7911799d3aa4d5200ab517d2ac7208b2e8756e4b5e7d87e9a87816f89551638252deb5e2991ac4f850b37bf5fb7fcdd1cf268dc1bf22ad994e666fccc3088d800eedd42fced6b2036aacc94f2cde85f110389fd5261cdf8f4fef4c397cb7af2c69811ab14ae089b7742022496c1c2bbe853c5fa129740f7a5b3b013518dcc7628e07ac1492017eab62c7ee259db157077902d211361649fd03d46cd09b40a18966a6083c5288378f6e4846ae512b4934f0cf48c555fcc515ee7e05039df148adf0cb3d60a4d9e4bd64362bf92bcd0a63e46aac20a59c5bd13630cc24e069cdde47d3e01fb548eaf6c1f8ef9a1595fbdae5b2eeeef043df575fc6205af0aa4ce0ca927fc55da2b0fa3ec7a845ea99ff390a67af92b0bc5946a7d1a8b5d6cac8646ae710b4928e68798b7d0f7944f983929b2fab4f4837d3c5fb982cacd23fe714b35ef295b20c667dc287ff47b3a742984cebfc9d864f14e944a117eb7c24f743843a205c401e8ac39ebbd9065c361a38fda44028a7905e70fae620a7ac0b2d92548e6bb94acbfdba9693eccaff294fb660d8800889c7f95f560b9c7d782aa0cf09751ddb5d0ddcbbd7212932f407a712ef9ea110f21195bcdf6c2e6d8c36bc40d3026ca70143ff8e14f28f1946cdd064f17d9599fe245d75808d981e79eca79b5a0dfe5b3afd7fd8b79f88f2b4dbb2a53e313a50600cbf3740e0b45bd3e860f5c84f61d2fb719057547fac6654d3b7a4a0d2f6841cddd24d38ab6e17fdde1fe86936c3526ad741e00735d8f47413a25225d08f3924425347f93e8e99f8a49039a7d2a0305c1f3df9d0ff097e2f0e7e3f0791d1b9b097878146b3885789b2f0d659d4e3989c141cf14838109720f0085b95d6a7907b788b1a50ba200e45bfcecdbc04560f811f97760554ef14ac0a4cd8e45a83b54e7250ad7d666462ed796e3164057347cdb3c3b014b37a2cb41109d7b089222ba0e07657ca085f8e0fd53d10c4e82fa56ca4fbc970f28bb1515cacf796fe0ff08936e5be2effbf0c4594753568210579aaa534b735478a02ae90aeb39c60939e36a39e6db8792d5a6241b4a37528fd7a05f2373b03ccb308b058adab5f906ffb4fe4e704a3ad9eb65408e661b43a6b6a84b73fab5215cd7583276d79e294755a9da6d0bdfe980e48d5c88d92300533c204cdc472cce07b4e8aef6b39f4aaa5d014a99d23d5a728fd1b8f538b24a83be283bb5615f0c4a1abcf197b97903feea24f2722b6d9915e6d46e76a0e89be8f1b295ec55ce917fd55a5bd204831fb947760c71e0d973e822027741773a7ff954c29bcd1af50839e8b4ee6e5d9e1081aa8d6a97998156f147dbf4d7135b2f0903c845383fd234bd089b8cec8427c340a1fc02ee49eea919415a9339c5add48108bbf30a6b9c91da77fb232c5ee30fb63ca7bd1a3dce4c5e2748f3001a16cc833485b229c310ca65c4b207ea289ddd47ea465b9b82af003c8941b89efc9b3b89fca6faa2b7c95e07f0ed078d35f90452de9b690c08a3a6f725f9dfc4c1b6265587b5bc16193a87136479853438df754562e0aec0f568df6f257e82dd5e03793934fe95b5fb169885e9320ce25fb7db5746a83d161b62dd22a5a82ceed575e15642f486a971122de4339cb16613e8f167545c58fd3691a6f582194f47a40fd444bf053834c7314d627a8685c6da051ab69ffd7c458bc342a252df5fa820e38172e6b6d89f3bd9377e7fdf78f6a42b2f45b6e5bf2ed569a9109421915a6f32ffa097d2939941b5d9b900753501b763ca28232e43d3c749e1960b6ce60cc632cfc8732297e7a58f716454d03de799a5c29f5fec679d5ef2420025bddf6d23cb3cd8156dbedeb9e4d8de529a183b7d5d94f28261f031bb6ee37694422f982bbce910b4b915b748564983be4244d81d9f53762a3b05ee6651fb4d7616d6c1565d4238f3ed97f96969e48e17bdbb7994a6e9d1522ad4da2b1d349b81d3c4fa123977e9980eea13642c02886da5d7c857a6aa3ccc91027da782a9524106e7a7de4a98a11c9a430de02910695f2575f090f92972af73355b248eb53090c159d295f5dcf51402b10df55ca572a1b6e611c5c865667c1714dc78791bcc21caedf8c03eb993dc7c1abc1753585e619a50b2eef20bd5b6e72b4d6fc79247f80cb4009cf81a2445f16b1437db5de7856188d3a29f2d1985bba5965622a38ed5a428a35974676c55b92b386a18fcad0cbc3bf4f11a9d1c31c7fcdd44f32f3dd1d2ad06b04cf6984a80b5101ab4002d317a1813e74ae77c3b60c564cbb71ccd7b7f43f98fd67bf8a2f323ec1014b23e33d63ffcf639df927b8ef3a8bd1e85c029f2544683645f103d60e9c1e5e11d5c321e3d574e60736930007792069ab533cc194afbf4b80d0de1b8787be6e448e8f6abe220d931367ba50544af00451d966c86fc1267cb96dbd9efd9c6cc5c9b84d723780d6fc84fb23e2e79604b5d33bcf84a5fb7fea7ecc005622c32586276f83680383bdcac21f1f858a3e59647e4cc9a94f44bfb456393ae8a447f134d0c85343a49b66a4c1ade8587bf3d378adcdb109404352dacee0524d628c0db7a528a6db290a61b28bcdce92174ef8717d0310857ca0eb7d78dd8b47ec1f1df472a02bb6e6ac2d8625df1ab42673e4da72e0746ea35aa71725de6aea350bba1a0929f8b7150d284695543171239149eed0d0f6c4c05c2705d100f44c81837c18fa7c1338b6d186d2810763707048c5e707c0afe14839bebe16fe5a23eb036d0ccc7e046222b3bb711bf3b4de96917eebad115bb964a5aed1522663ed7f1840935f2221efdf3fff8c4cc6b5511b8ec685c8691a9e4f00415ca979577b9c749e24c8dce81b1305638d5135dbd2d6c29d6426a0f94a24b97d6c85fc0c7f46fcd734e9e90c89ea2ec0fb99e37d979ff4e7cb3a2f2873d9ac797b2fa1a5f39966867ae5a43b540f9ac7408573e0d9a92875dcffc4cf2ac9a7af20081679b00e5a882d2bfdd16ed1c8da2958beb266bc9171a2af0317a5a17598b0561470992ecfcf7f039593cbc732da119b2a00e7531ac50d243f98d6941bd3995e170d160aa1126ac254db5aba0a7a4dad82a9467c96f1ac49c1ac51cee89773e03a6cc467cd3c213afa5bccb744d81fda653304d2e4bae33e72892cca19e090a57fef952b9273f6309b317192dd9c7f2a0a2504cf2dbc18a2ee70014cc4fcf94848538266f45b1f0beba093522fdf8479caf2a4685fd60ca4bc6457e0f02077b983b354e85f34035a13e6513bc6e29a4cb2e19ca670410ca469d7344b53eab525eb282d711bb954e95d16c0ec718c0263a3c8867d3fd3481aa6b184c4b8f28e1156262656187688e52d6d4672d25614dceb013363ed025112b6006206a31f4476243249349f808125b946e947b338d294dbcc4b8e1a516272bffa540622d89ab952daeccfbaab753790b4f4979c5859a5d5a8256bb21d44e85f77db1c1beb3431237ae395c4bba822dbead5817e68dd692ef0249132b8201d6879455d88ec2fa2874cb8d8b1e61b8528323f838691a6f0849dafa0f2104fe420809594d7e12d7f9dacb01cd8d22030801894d7d4ba690c0a0fa38d852b613d6fb301b3f7adabb37260014f62611e33052510e8abd8419092c4a93f39da6003573e82f678b3b4046b902932e3cde62a5894fff0b8d586b2851b3efe951b45ef03e5b7fe04ff388c252021cf8f35192c6d8e02fddd1194a03a852628514c76e8cd9718e860bca01292bd68f76e0a087e301780dfb529f5bfa771c2d2247d650d2df194e51288d781036cfb47366106d661e16baee04fe517e2ca5e121bd3c6da5e5f1ce40301c1bed5e2e1be3f66fed3b013035d93a5c37017ec5aff1854e52177bd9c812ade9bdc65b104b40007af306a79c361df9157dde65c503a54e94e2b928b36a9bc992f9d38481cf6ecaae48659cee66678c928182778e9b19e08be65a97999a237741375e313904cfd8c1863a5a9f18cfd69b1cd0fde9063890923015126abad578ef44f73e0baf0b5b5def05cb7d1bbdb831d6d1a67185217fc4606d9d89c2709850d3120e4508e004c9a5e8e69fd4dd49a8ef786d62c021494edd32a6461d72888fc8f492c10d0ac0f8ae81e0aa2f4d01c5ac64698fc535f7fc5ee09e0316a49d131e7db71ccf93eca685f12e34b71dcded61e006f78d92f8bb9a6150e7dcb778994b43b6076d17cb6218282cf35961e2d04b4272821e8df952e93314e7e1b46d843710b760db4ba6060189fa088ec17016d373cc76429ec8ab5c2238129397eb293d74bfa40a2fd4c6bcb11276f7a8427f9c09cd4e2473402291b60b50063345e67da324fce8aa775408e5b1b693207bf593f829c0b7f81aeed1d5d24feca799f6c0d0d05f6c107372846f739072f123d4816750e821419d7759f1d8f9e4ecdc42fa93aeedaa1e2abd2d11032168ae373f1f23277921832ab3230f503348373b1e5e71c8021f9d677d2284aae06d6330f24ef2f917781f9d23fdfd1c62a23032b4ec5cf73ac9b79ef8d9fc5fed299db00ec5a5c7bc9b3a804fbf390a518333134ec2774d83ab73aaeb936e0eb9fb93cd0ed55f2913f8ab1b916672d024882acff6d959644e35df3e32eae7d2098593183ad0be90db698be3d42802b40b8135c81c7a8a883ff40f24b79fa21b1f671e1f03b2a2281f8c38eae01df0d9e71fb8a6bc72be1e150120b6ef33b1bd25fc3532902b9480483fe84b5a88b63fd7c7473439fc4e1943896aebeafb83a5cde2f9c3c8efc703ad267bb69299b2174699fa3987452e9169be15301b9a841dedc9fbc5beba2f6b74aae94f4b1c6714f7977448fb16360f9cc8faca74b06398b0acb99ee26e6c40638afff0e0c3a9cbb90db160f14f638672eaedaa3604655d612c6f3180ad7b366858e17130e1a2f35ba7f78b9c23fa1c830551348f1f9520dfeebf017418209b9dc3868f6061ef2692fab5d7004817bbf8207ecd072b51711df3055e741a84e2c72ddf52e6e72b504542da6ca20a45342bcd14771b6a80971ef1fdc0964635f103a7b84af993f93820cf41afccbd143750c9e0f2296e6231839f9c51d05651ecde5e73291664eb440c24da1eb682dc0d3277b0fc8882d3f4c4c248cd6d3e99283f3cb18ddb8d8a08a47a3d8aa374f19cee804cc78a46778c1f60a30ef5b316fd64a26fb4c93f3acc7eed4b376dc3b4d4762be26b320c3f48301290bf29d4f03bb7123fa8296578bd625a1d52b4613c0a8b8ca09f019998f3a60b9d773743c32ca36cc6e38ad4409e14a43d631316091c76d61d2d7ae4c28d572cb2a74031f81bd4c41bc7d491fdcdeedc3a8dad264fbfbf18f0fb4020004ff4865e2b3cab3e3ad10c03017d4cecf84a712493106b9a29cfca2163c3fbea02ecb3620810a00a5d93a1f9c926c19c0131c9882eff65ea05d23de004c9eb64407ee42a8e94489ddc95500f19eaa8dbbf6566bf7458d0b3bfb7364c41473ea78bc8629c910b51848fb4b053d976cceca556fe7ff96be0ec7c7a4ac2eac0ede8c4326072e5e0589c8d47e3ff1be22f9e86f389abd9cda81c19b7816c8f15f23c5de664c32b77285ad5d18cec57d6f3dcabda5659da57e56310cf9f295984aa397cd0998f9b6becdf0e27cc272cf70ec631be05d8159707083ba25cb1fb1734565c521acf88513d44ece6968e65a46134d2a9047edd30b3bc624ee433ce54fee2b2bb97b66f416854c862a15d73bf02c3a7e221204ce64eaba37c20ac07306a84a40dd24ad25a891537f8b8a72c0bd00e135bce6d5d3ef5a2a22425181a8837567492835ae18c9033b017987804284559b5ada2f7ecb8552d9a81e533b5ba4276c10a1ad26b178f37f19d52a849e376b7fc058d20828c5a21461600511e0e0d06664dd4092a548e001cd49e5173775350b32a27692a29d0f5b9115d16fb81bf3e4caba2ffdefdee89bf39adbc345ef9c0d9467a8aab8422133e49444b074a901b754749abfecd7947b06f1985f16dfc3b29c5b0002337eba5292090c0c90a6c6b27e05dcd573585deb132c2d51c5108697f5bd41905d5dc9b835c3f2ca465bdce2d153be0c4c2c5ed5043b7db3ce3ed89199c1d13ce2d5c64cb386ce734bb63b52bf213073b90f7bbda075acfd27883a1834cd8e3f005d0978dd2a2dee783d468f83dc4ea9cdff0f8a97b7e362f008fc8cc13d46e7ca770a62499a3dd7ccd238913de28f80ef822de033139fb22703a762749d0629be9ffff288cc8f6d59b5d15f267ba887e054897c48554d1dd790173abbf2fa505ded3253ed793949f5e60fc4185185aea7343079b99a9eb9ff108f67770bc5f751b2e8c8d61d573d247b981ffb655b2d81e0fa8636bab67611845a2ecb6b684082dc0fbc58d9003f2d4943cef1bc984775465e9519d8890361cd144280670a8fa2665c064f0cfe32f856bd9029cedc1b3fae9216cf2fcdd9e960c0bc91436c982c3d188a17d29fc4a622c15abd1f7c6a76fcfaf79a8e1876cf5c90fe4ac566c756286e781cfc89eb495e74b9ced8fb0faa1a7057663241ce14eb68d312e57e74c5b5a22a5ecf23e870caa4b9533bd29a167a776625270318c81ee4ee4ea770e42e35242422f5b171c6e72cb355323d99fa490159d1edf63e66ab0ae093314bd8ce370cc210b241eda9ddf9476ca1a4f3dda5e4dcc6f4152bf93bd14d94c9c0e7197e942f6dcaf46746cbb4d49d08dd8304b79f09dfd1f2e57c03767efda84c959f3c28cd9d6c44066f062f4ee3c08305c4367a844c192b46729c841041a1e0bd2f238e198aeb9ccf78cb7cd40338b5191723290e764568c20cb4ac09e054df6ecb1f31064b75758d757818bd995668c5e2a52a6f46fa484c256c55e64d6f8cfdad840f9ef295cb261bff981ac07456d65bcca0336dd7f59a94dcfd9d396a40b942045e3b846504053d0852dc3344644148da0f8777cf657b03541d440a08828f870557bdb5ba10270dfc4f50ea736262af812178b8534b16b9460c65537069f640c246dab1ee7a5def9fb39845065059d853e9657cd0b64d6e0e3c041ab3c0ad1a91d6f4ed1b09f274d35df17dcec1f50f141af0b529d03ff8ae4b6562a0f87a175f875d277343167bfd2652649e485f5d8658ff4f49fa130103b077680dba0f4828148d1c4361652af62efd38d8fca085f570848f5145823609b89c792b9ad0cd8ac638c88329df31db67714d9fd00f193dfe6ea906f2b14d49cdd1e87bea71c2f0578dbd4e0ff59643a286b6051c63fb0108dab656534161c460a7b12737eed524308cff70e3a2535852075685d915963a2859b6b7a58e28880cd920e35a8d6c814fe458f1b290becffb093e9ed2d9df6f35807b71d9973add333121f2ede94da283f7689f36489549bda1b7c296d2e128af34534d1c0885dcbdedabdfa22b1f9d6258ee362dd7c30d3aa96d05d0c7682e56e73605e80f4716624fea5b270f04d45e528f7dfa36bf493a8a52596632c58b8a0f93f66d3137e14f320db59c71661b5eb3630b505dea6f8bd6f7a0083c37fb0302efc2286a9d994ce5f2fa60f19b67720855135562a86c2c11693e9649b841f1c726f52a536ba1a97dbee7e85f793b13169e796088e14ba8dfc0ed632703917c8224f323684c9641f6579699a8148ba829a859c6b075288385d065e815715543f2b3817c03b2fa54b42ee9c73df1df8cb3bc715e06361536add9e1133c5dd68ca20ae97c1943a01e191a3f43241279a0a8ceabaef4cb89027eab5c9160ddbd8df11fa74f9468c4dd8d098eb02539868a4cf3c7f4aded5fa64a158e147624f7ecc4c0be63fa2f19357ec5ddf143f96df1d32b8a64c8e19421b298435be3dd5ac8afdfba6cc26251019fc571629b1ab3d923346134cec8e0530dc5dc9148be90c8275bf3a9a260d2eb709eed001d3f2df331fd5b670cedb8c497d1eea0d8b576d0a909a533a3821b95ecb4b8a5eb01e4b75322a17ef11ceba36a1b360f7fcbcb03b93514f120901e3fc8592ed35eb079b67dc69a09cd61a41212722e64f8bf4269dcd53f022060945f2f2ff9aee4f329b7d356670e42a59c8e236e9a71ed3939aa6d87fa10cf11dbb4c3d8b7ba7ff010d7bf69fd6629fe99b4b5781cf131cfbcda15b3e8dde67b2903e5d1d5e190effa319d9f43c4b9c06e5237d6ede12a6894d66b1c58eb345dd2d58b9a730c6f04adb3dd40fa672ae8ff05089f6ccf64ea6c99118bc979e1b1c51924de616a9e2e25d1d660a80148e5a2890beac22f2a3042fe3eaf9e85e1d914e0cc9aa8dc3ad162b65cda3bc717fc3f0a6a36bbf90c4a18dcef226383de6765d01a97613c8f5dfb5570ea0e6abfcbff0dd6ceabc4fe1b1b05b1b0c816aa6da84e920fb90d0cc2d7a3a8d21b3d38e79f11bf6fc5a11c2241c415795b6f49791f27f8d4c25872cf0bfd0c0de1303987d45f8fc6a8b891435d8cfbdbfff50f4f74f5bc4cd0e1440f2517153d656f0f6fe38110efdb316f236e072726d657caefd5f59d176bb5f3b6630a207306b93d0d8c9503c2bc454134c033c505ed28999272d19efd775ec22892c9fce8794c2a46d732e0574f2eaf6c9ea2d29101c0a64dfd349c098ff9127f1b2b4093ff9d9b9e84d73dec41b78cffb21805181259de82090bae359026135f400f4da0ebf6d3e27c5a03daf5f3881917957fd71d215169a8731fd36e86b423a2d1922a910752d3b053641faed184fc41570b9c9b47c56a8f26d35fa0bd58173b436ede1b84e5ced19fb7b6fa9a656b34ee203667e41419c69decf102ac497a61bd0fba683c8567e0b0a1f69cb0c109696753af839694911239a9c01beb30f919a6076a6aab90823235180e08ffe8de52655f03fdca2ae8374404af60c3cefd111bab1e5041f284b0281ee85116336ae324711a7da58a0fe848b8e1558835c29d3aa65ec004a204c70461e42f35792b8b94c82e05edc9d95b95ddddd32d76bdef7f35600915453fdc58274fa9e2b9649aea1cc9c90d57249d00014688b5efdb30f5e6ebc6289f737ad88a67266c2b276dd85b767ec14d26e2d3a950e20c0874f7a4d6ed41ff2372ef8589f52347ee9948cbd85f1189ed78df850c41a21e2831f8b62dcf3d41596b02ed2d24a7c45fcf345178b3094422c181b951408a4dbde6b09afbf13345da2d1fe81d8a51c96b618653e7d9794be602834b5efccfa68fc9e814843bb14df8356a6f3d7bd614814e9710fb46776887a2237141f1cec0ab0a31c90c53a7b98d6e69f3d1b91daf0f739f93ab5801480c32885470a0666e00c091b688d8454c48ac88cc80cc219a4c8d990d48b0fbd3abf5bf066b4fa44fad669901f72a5bfdce7c3108d5e51ce37ecf9e176d4f3b4319dd0931f21302667a2664a31fd06e1a042585306f1327009e96eb2dc3ab21d85c2c38f33792feeff3039b54c01f76bd017127dd163c73f94e6c7ccee3458d55c3976d28c9ff2e3f67c7a633f1bab94b6dc19404ec2c92069bdc4e28df74064e8b09d8394aea1539c6700261aa029dd291ad6d0459f69a78575403ddfadd885b3021d58becd4c4d229ed85ec3abc37faba12d8b6136a82d2fb64e1ac697f9bbc6373f8eb7199b67adfb20414d7a2ff7d063084deb17cfe4c17b89a9c78b76ce6932f0f32a95e18c2958644e25e80c071fc5a54bfb478712d87d5f39cf297c7f7b5a50670817bd30422c4a3e43610d5253a3e2d4ab8857b660a2cc85930a546bb147affc27bb76a28c4b02fb11f1e95fb2aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
