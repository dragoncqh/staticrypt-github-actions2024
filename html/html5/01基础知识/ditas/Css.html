<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1dd0229aef81a25114f4963fa59fb9f0e62547d43cac2b5b2eecdcf5159855fab0e92c4e1081a006acfc9b8b30ea131557543b29e9de11e7cebb0ddb7df630672f3b0a2f4dd2ad1602ec3537dd278e851d9a9725b8ba08c037afc6910c69f880b16329163ccebd7f906fba594f1ca562f2c7f2dab1cf88cece5b8592831f29ec6655cac51a1b01aff9f8873e02341c4b625b36d4d680607c751cda792cd492eb48e47c6f1f1981c1d62fdc3d465b8d3c3b9e0e41ce52d6ac85878d66d5a885330d187d0cb09d459f070cb85649eb99172c49575a8df4de60185697e7daefcd48240f528afafb74cd5b735eeb75a681a5f7c9a6d2e29eb23f5090afa1ea0d2060eb5cee49594bd9d2dc3e927e8d93a911918b0c3ab68141c5078882e730ad7a84a63715e4d5dd1efda1b0196f7a991bcf0707a424eb6717f4b0d5078f431138f802f90da09e27a29a8febb4d3acb45a593fafb4c2fb365b16d9cef491d426559afe2180f011fc103e31653aa6a810c6e7569f396887c4b42f6237baddc45194176faab0a31ee456cf070e6055887ff7ae3d085cf9bcb89e2e97bd4e3bda87190d06c5c94cbb4e6097b0819fedce76cc9e8307cc812a48949ce657d6e0810b3c119382dc05fbd2b1abd7d37f11de26d29c3630823713075dc6941260a658d4097700f216e319ee5c451e435d2b845f187e837e7d0815db57a0e498e274cfe726830c8d7c61bf7c55209c7c4120e9d04d1863fb5ca83e2f6f2bc5598a3dfdd44cac6e6aaec0d5f0447493218d05cea206b35c18b34f7f816af09d19dd6606cee39850a28a8c0baf9f07f70851f3aafbb585f60a4fef7c2f2d790fa121d5cbec7383f10d1fd51aa3c4789784dcbe635c1378c30643b0d57abea666bc9cc48c6323f8baba7b41243d043591cc56d01a68fe1aaa029835748de787b2fb96ff14bcc3b8853772d35decb4ba76e306fe7cf2e6d4da65dd9104763d910900e78d69f7fcdb6765a1137fd6c5a991f5dbeaf76db42fa5497017a88e86bba94be0d653ea17570bc7434d7af6317aec1169545d8e30a567c793b6ea9d0c8fa318f887b4aa53df44fe1dd12eeb3f9a746b38070c3f2e5a5cb6c0852861b2def26751bd5bfafc610f47f49818121f2d41327530782e9a21df6ce61183722bcce9246c04f74f0d7f29898323b5cf9bd56b9318001b19f19897c94270e2c4c11358ee5fbcef47a51ebbcc2d9f52c6093430b8266adc899dd3b6a073db743c0ebb738f0263f62af9822b29a1fd44302fdd1e04b01fb367d043e9190a5a47bfe383697f99e4dd990fdc642e976e8ed51434551add64022d7ae5192261c7a19323dc17a75470fdae631ed42b3e500446640633a3a53ae3956bc10e9809b83282eed0be513f63b27879397247b3fe6f57e7f287bc21e20899a9b2bf8ec3d9b9322143c5695b1fc62fc6231b27b1149be538380a65a93df128a27f628da985ff45a3cdef4dffe4ce3bdd35e878227700d3c7ed5ed257fae2d1ac3bd92359446bef31250ae7b16418c1df8af232fe268a7c9ab780f6d9e2db8d621317abbb9b1755fa112e49ad2fa7632879ff0349b45a4afa49f9d4111dd3b5b53037388faeced8862e501d02636c35e7231114d6f8fbc2f4ea1e778ef2bb4508958e8882efce963163ec7ed99ffee75351ff438edbc630aadf0cb3369342d82d87ddb167616dd3f88409642ba7139cc7bc4dab60eccaeb89e81763847ec72c6472c9bdb0412ff11a02fb280fd2aa9fa14ce315aa4cf89217ddaef7e384cb554d25fc905a0095b714bf0127ef155fa7dc8f0ef23bf779f121ca21580df2e338ea303015103be44a0e9ffb95e79109626c142a04ea87ebb5df619a3e7ff7aff52883e7a3cca0ec7ba9bfca8e677610d6f73d449dd555829c0b627b75f828783770f4bf1c89787b4fa74010d5029ab3c9d853e24b92f8528e455048c6e633332c302e7bd1d45bba31c452dc05eca5e3a4e36e17556f35064b2f5dcd378afdf4ed10b19cdfd2cac142876fa5b2a2a6891b9eb1b86adde105cc8e131a613603193d8adab047c7b9ad9f6957c1b35597ecb7cdb375d9a684ccadb66fa062c811f48a1c338197eb8228551e1a3811167826ad6b39af05ac2695e8ba2b9d0a855e15b9ac77e7498f1005a0282860e16619c4a1c4adfc80db1208f5d5ab0dcdc42622139ab7771fb91ebcf522e3298abe6cb873c3214e8ad9fb125de47af5f760a3b4f92af2547a1ae39018f928a8b177e2301decb99abb642f6780ef8b1b5357faf6bb6deb17cc9696db14fcb29150786dab338ff52e05ed1ee93d7ee3442811227a9f14df5cfc658d9d6a8249c0c0e9e9b7652ea38a2c06f29a844806b2d5aa8787ffe4c8685a0fbaebd4f3815cf116e7ead795db78c8cf1b4d51730def933d0417d66fa0c311266c0e4d785957567ab927bb3eab834ea8ce0009099cf30fcb9518a5ede275a76f2df5e2bdcdffcc0401f91aee419a9c05e2e30bcf45e901945a2e0e10959d7914ab632e30679c61f4307ab1a4a1b3acea16b75a7429b129b4741b1d3a7cacec67983d59a1aa4c13e1038bce37487583eabfc93351314084d03bc2893ea0c3b4e5c837ab7a65d2a35f576e5ab1e4c0003cf1cf97a7ee5caa58b9a701b590ce4f51d36efe88fabba0fcf70687b9ed95838034930617d19213efa35df4fc38e9285d0830f218698664df071d81c2378987958fb78ad173551c873922764597981c053ec6ed3435e000621d2f74c7d8d53f6d130a20d369f78b423184475a4f09a98aedae9b3ca6aa50cf13348f26776d2e8180db5f8d883d7e4ca4678c0454f087c4c4dcb8ecfb4c5168b9474e75545865643b5b96f0f64b205d4c59a193da3117b50eec09fb5a5aa4159f2c4501b76d01981ebcdbfd64973cff0967c7c9464cf6d15e2df8b1df3ca32eef8151dcc611f3d183522786e18f438d4168ffd8b8ce4549d9a86f83bba2c4c0ae1c9cafca27d5b710adbbae4a08d20203245be7a8b3a3b0f15df0bc5daa14af73c8042025b1622c433eb014791cc0274cdb57b5deeac6962cf4421cac978dac0f48d33eea498313af0f74cfe948898072bfadc634f1d90f1b596c460d119d647d6fbd8986c0c4b5f408862cf621082bc92b4f3a671faf4d3d08739314fe4b63d120a19ec911d0d6f253f318ced44a510397f0de9b6787999e7e27def000827e8bea4417d747bd050e576ba8d45efaecfc21cfdd3c6a16b395ad12bafb226fd77051f1265168fcbe14d0d3a5aeb3dbf5c55a2e6056d5064eb7027d529d7f496595f26cca2f7475ce156e9fa121e2e1c3b40267c3620a02dcaaffbf859c8a6afee323adbe9051bcd036e22b034fa42c93e1ddd484a2954a3b1ff15558d3763dac297600c0ae3acd69e93ee8c91fbed0024e3a9e8da3dd8adb9d6049716242aa033a8b950c51fd0a54115863fe62cb34f97acd3703f0b21f3f8097129d534d7bc971c05f329de792e206be57b313806ce99ce7ab3498d343e7811ef791632052fbde5cebf9beadafdc7975fd968cdca3548946674923bfa9dde51a554387e8c479871dab6bbbcd70a1acfc3c427a1b51d8362a5ecb583f3b279612055570c8e1aa921fd9734bfb19e8d72749940229734cb99611b567ddc3f80bbeffdd64ebf967db418dc79cfa5b8b1e435c9de68707d268471835bf3224a6219e5766d3b9444ad3b32c66c470f9b75c72a8b9e95cfade63ea4e3ef41525828779fa161f0dd6b33aae67a17f6abb7aa12bddf3d301b76a0a91dd1e50d8dd0aa542af18671ac5bd483d40fd5b9443f05ab604492db652899dfe18974ffe19d2628632e21e1087e2dce437c16c1fb34a9579c7bec823826a0b5dff7fb6a754a90a02deb3c03e38ac2fbe17c4406a4870f7d837c2b9352709b8d67ae373033b12ec87ff52fd54d343ca28b4db0714e12f5607306d00b60df02d23c36988563234be9a08d1d87958ccb3fe421a7e800ae14f291a753358af6f229d312082a590b3b4d8d7cf4c4069719c8a8c510d39ced771670cb0889b080c6d067f49c1b82aced98d667deabdab7247dfed7ed7053e99915b1d3bbd956ad418a0c77c44aa94e0cc55d6cd6279daae0ebd6ce64ac50a03145f3e8c90f08162a1b6b1d5fbd12ae2d19cb58dc6769c12bf802ffeaf46c521dffdd819143f7ed04d1a47c565edcdf1f58189f0e1e5378516d93342c8b99c971975f8afee59b73158eb644c548889144847961e9b388dc755da981d8301251bf273b28f6f2c14438a4a7a9eb0a6b877d7a3fd9f429bc129d6613bc259d9c8034feb0b9ad777335d80f9c13226498522f40840384258e03957112fd9a0b01383c48b6bf27fea8b79001b2f2d6801a5b637e3678f92943dfb7470115dab4b2c4b5f0709aa49ff5c7d75f24d58695cd4e1e7bd799695ff09410d1dc99fe8aa28cfc611cb3a34fa098298b7dd059f528349efdbf9512bdf9873832ec09b02134881e0b92bbcb38863dd018b76ad8f8edbf598e6503fac26639cc65c586a1f566a7f6be654aa4e22b1ff80e2fb778b8d66dd0d31560473be99f67d5e5c98dec8b088d417bc7af22157b9c433893de75bc1cc2bc5ce9278b928ac8e768cdf4ddca2a3aced03c8f30dee738b4777b293718cbee9b2fbbc640c2c6e862bc2d01640b5a71e02d91bbe044b8f335ac8b4340e2ea11b3070fb25599205e92815edbb7531494efdc1a6a2c71934cd09c1d1137617d4a415c2b6775db0c18b628f288e21186f9a2364d37afb4541008431b2f2d3e3cef2552c4cc34c14cebe3770a912252fa9eaa24741e511c881b7fab58af2566c168794d06a072715a575c08b89117ee0ecaa1e96d377d033c4d761cf7dafe8d80100336504587fb85b49e2a377199a57fb259256c988e1370164d1592902902693ec20bf6b67d3656f9da96033f1414a0596e9fcf8b320810cf1b9aa8e9244934ba52c134436275285a9ba80605a8133e2144d90854ac374ba0bc3fbed17a7486d9a6e1c9ed87e402f9cd9602866f9f702534162320596c0f2663ffbfc2f2af38b97caaee871d86d1943a491e125e0e3cb81d9d8adb9b56194b6d67cb0e8ed5c9a0236f2d7f5a466c80abf2a3dc98397cf61f9c3c0bc7e737285e506956b4bc81c449f68e0714c9fc7dc98bad6b5ef1c19b9e65b5cfdf1ed2e28eeea708f9efd8e23c003cab5061c70ccaf90dfa1f377e348bc87aa810f82db2dc1ac61a292084f1b75bf06cc70c8308ab717d91af24e91877a79f72ab47065846ae89ad9b28d51c99bd69434dc0060fcad4a0c9382af4365d98f7bf4cef803ddb23e3d3085f3c22b2753a429f3363e5c15e04f8acfba80dd6eda7cf63c80321262ca4cc4298ac7bc275d87533626fc758783a030bfa1623707615027b2de8922a17b48756cee6fe4c25b77cd095fd2e6fc612b014c4580f6eb67b3a71d4c94606c8339d9685de07ba8a142b9a53f2dfbb931011dead124fb1b8ba29e004c71ff6dc116294e1c56dee52282303c7b63854c81503dbeb5287bb5040864d3ec10b7af6833f2b5ef120f2a2efeacd5de1db505678cc025fee92fd0f190b0bd47eddcb02a2cac2a56ecd0d09287796558206011e3f1449f9dbe9395e6ff8ffa64becafa120669f65dbb001ac460274a12f1feae70f0c276192bc965c73463cf55f133fb2ecad3d8c7750d85eed4b8fd47dde1d72b1d0e29dbe3f6f1867cceb773792f181968c3f25da6c406557f0cd4c687b3ccc73e6308e5d9682027ecf486aa97fbb20a83b829ee55eec92f949605b2f028e34540906665914d6742c35a2f28c464f3c48bbe230b0db8630d8b3a67db45694c2ec35eaf4a50168eab86243a4d2f44310ee2f8b1269905ebf708c557db0992317807b3d8083d565626a09a28501c3e19abac8be64c8a26578c3c3d2adf102f63cd71183cdcecce16ce635403efc5317040bca253149cf4a9779e649db86dc03ede2e31c6cb957f04dc96978d122accb361ff2e6bc453a7e80c89fb53f2cdcfe968ffc869f235b68d6a5514900b6356fbf66a00da85dc63050bb349edefbbad410023ab67f8d9daa1c172e8e7f997bf04369bf36fdb988b884de3f142c1bcbc25f0a7becd9b4422ae38eff083b99c56a18bceca924755e9c65517aba7eb33223d6a038c86ed9eda49caefa97dc9fd1faf16fc4ef75e6cf23248fed92f3753ff4c6772f30d1bb2ef68251c428a7e0e790a9cdcd2168eb7252826f2b5424b817fb03aec9e56da9f643fb93bee69214cb88343b69b08e9fe32bfd88e6e71eea3d02dc964e1f198fd3c05879db9428366b9e6641f2193c10bca874561cec78f47938db6a9d19ece80fcca60564bafa79fe727bc0c453380e35286d071bc491f6d876c0d1d71b5a069c7639709c65d961bec9a170e309159d5966cc896002e46622367187e86967b54cf6d1fedb9876d7c92f8f74c567e74a8b765c15032a322a66f4bd3c79717bc720231697d82858b9030e2b2146a6f386e1fb3ab35276ae3d899655f681427d0f341844dae300ee17cd4869755d427c83a63689092665956e5f5ea52c17130ef94d1866f7fc7c23b351ab812f6db059ce2403243ebbfb51203c1e404483bc70710de2cf745e4d00ebb053a175cdff30236e47ddf9dec717bc3f2c910912bb78a15b070b55c75b5f290c02440bd1e33722f11669ed389a336d2adf5a389347d68af13f94049df8a5bb8d336df23a044d0d68802340aaf0b0c109c409377a3c280a6b9ce9742adb44d0439e22c4dabf875762f28944e680509a20e469d91b6a4f053bf6fe477d2169ac11a5dd93cd3f0402d617605803e8cf6c14f60b7c71041b4fa1d1eef8dcd304e41d691f50245e74df45b3f4a222f71943652c24171cadf34638abb8e143634c32ff8d8ee77f240a0e062cfd2f425c3622d5d75eb68e49ba4cb2b7c4a81563b2f4ce910f6bf303ce0a60ccc4a9191e9a76be3359400ab18d4baffc9da49ed00a52abcb4557bb20941025ce143b9574c437474c046bafec42e796abd9e3cb11e2812c4c017dbc3f42c6133af82c553514a0c4381d58c31b03d1b3742dbd620edac4ffcefbce966db18613d86b328e6ff07088fe6e4f65ca0718f5bee85a39a31cb9acc15cbeef5f81100f768037de2e8560ef5e1c5af9b04573e519285e966673c759dff4a2a4f11389ebad9c9ae29dc246b3879e9c8800ce346980010db4873abf6c09055bbdf33df93a22e85f43cd1e16b07c992cea473030238af65b011d8ce484d39bf8927af1bc683cb3dcf340eff71623783afd6fb25a9334cb27b5d0254d0d40777f6af36bc8e162f66475fd32ff63cedc9d6540c9520df26fd48e572f2b15f6affc5269076a7a417d74fd9b2f9030b26c315f20a92a601a9da6451ede11d68398a3568907870bc5b8a437036c1d44a5e1f4bd7da54381113499375ffb4f4c71bdb1c24af45346039ca143339d682ec070c04b5d79db7fe2c22ec9a6b82cbfa01f8a036201a380767056c3df8531be35a05de9d2460601937aa041990d9bde2cc8e71dddcb116415e3ea0ffc6bb0eb328167fcab68cdb2afec5702cfefa54cc153c48a896316d0482b5f69a9ef315e037143f7607500377ea88ef8cf7f44e81bc9b95a9990c4b22d9f0643e03f849f419ba3262d12e5ad3fc84c54873d4a8b921c6a5ae3393db042c5a27ba7366d7b2f6860951efd8b794de20968a6052f9460ec85013ea554c955a2451d9d61427af48a4b4efd559a8cf1ff35d10fe36aff607282856b6e2654b33ca9f7f5ef5ccb37fb5f2ab2d95d7a947de5103082b603043e7932106932d22db094bb240e75f9e64d4ea11f76633edb249e40e54799fe7fe3dc5c3c19f3b7528ec9b8443106175d00aea1ae314de40d3e20eb1d79b3b93fd284a0443cc48f51c0a98d4c05ef3dbefddcec25db5d8e37a9fc05ba62b99f1ef45e5be378c60b9c61cee2e879a4f45eee109b6ed21d7d409d74607bd4e455f9f31bea0c1d832025c0ba57ab16503a816d27d37be7a1beaef194d305440ab1382a52daf09f299ce3aad15c1ad822c8906c41527e98d310196dfe9aacf0f61f4328b803f149ca3c2cac605f83425611a86e4d82613f8b272e0866c35585b581c7d3d5b612366c9d65a881dd7d646b5b1c0f3db025c0e94e30773175c9a5d4a276679609d279b0e136ab800f190e951e4b1b885523ebe0df0beb9f0861764901a8df9a5e01210a62d72753f33024fde9bdbbd1e03d6ff6fc29df9d838b930a89cb8195dbe7601de969f91f775d4ea7f424485798d89295e8d6d27582070dafbd8d93477b607be0867cdce926010619e0fbe5178fc0f891d528cb8066a4d6fdc6269254aef3ef0ea2cc751be5483bc3efaf05a8e25d27e79803ac76632371a33213393c538a48fe6e8429470e89ffd920edc35a8d9f4c8fd38a8e3a726e5cbf207e7c6e4643ac2659faff84df783f2da07beb657237da5b32aa02c836888efafad0ccc39af5f53a03cf5269e686230778b2a12ebfb6d35d37c330a9eea1d7b6be3e09d0206cab68bdb7791fc360657cfe7a76ab05ac34e41e8b724b278217fcd7b7f9c31fa91f739a8f0453085c54edb8c22ebcdb97355fc412c84d386b071567f1cba22b9e028bfdceab00480e4d6c960926e417d848e8dec58e6b4e7227fb503a7df31b176f0fe69c16a9230aab2ae3c1032c9853e72ec486e1c7584dd58629fef42c7213341405f1b108b45381825f333d85c2aae423137263230b216baec46b25133eb17a6041704404f1a6145b334e894a231d244b93cf864c64ccc9d115b3b04147f9201fb895cc5e643700cb26c71bd7b4168bc8689c8f39220f57a46d4ef3595f24f3fcf6da0a162af3580d9ee7ad00b32f4d564dac5f17a935d719910bdb8bfe7f12cd36cf0c4d29f974ff5d47651021319d3d06fbe444c4e27e135fc211707c4f4c47ba65b57d651a4e2c9e3dd8565339702acffa3f61fe437a47dcc09dc9fe75dd38337c7986b9c39434ec48a22772c9c9efaa51e89a538b8e61f4e76c83fa856158117555a2c1db14eb932365d16881ff91b7b38280d6422d0b8b1c653b3101f513cad76a76cc69c585674e633f6257a4b2f61b94b028157f7e0e25fa34ce195af2235ae3c049833b952f03f2a7ee330bf7aa01e02ea92dec552147c06cbeaa53cb7ffd0d03f3a48bdce4e2f4a1e93c653c56ccc5cdb373381840dfcbc7de43edbb80e11ebdc5dae0777eb28cb7069f43233c5042cd216b6dc3d54ce65966b824a2b692b86515f6fbec960da068871b16505ceab8894f5e69d7b334dc2ac7c38393fe43e35adcb02263c0e7efbed15ccd86126008e08a938c9779dc18ed9a226f3bbe69fccd0ecd6d602f97411855d07b69931f90134f0c3cf72d21ea013be5c7062f7dea804819e6107f9c21775e6bb549142c6831fe6e3698d8cc8ad41cc4437a7f863d39baba040229069ba78d46c88134873358161c4465cd7a9e2d31cd3648212e659c9418ab72b4002fc38bc86dc0a141b5ce50f6b04f1419cc350c84aba2a4b52cb350ea968dea6238bcb04ce18ae65f844010313eb4a53a5bffb868b64971c9259c120d27ce6ceb044318fea8471652c3fd9c77a98ce10869bf6c56b3a11e510030cbe1eb25db17fad4874a8b74a2d7299d48480c9547f770720c805242257e28ba0dff02623e563ee0201e21cc35a12c0b53b31127edf6a91ca3449fca6452ebb9100c1572dca293280ea9a542fca501cbd522ee195af503f880496e6a46d23fd513cad307b46ff71856c05420c419894a73970d87ac99bc4558c68835cc54a6c9b8f8933dfde91aabfec3ba0afe1bb70713b883b18fc016fb3b2182ecb2a0b446856e14cd315412b9b204e8f559418b849710416df1343bbcaf313c82fde18580c4ee52eaf71724184fadb482b44e861dfbffeaad2661c72974497ed632597721af0b47760deeeb8c9057820a9664cca1049029f66c675ab6cdc23b2d0eae2fabbb44828247851d0b05187f99a03654b70b9f213145631eaab6a684c53b3823290ea20861c3a5e99f44daabd087a393571e754babef8cfe1cc117be91fb922af1240ff2fa779dc238c68f7dfe00c50a49f27001f87e1ec26762fe17f52393af090fc9da39281ec8df875d8ae7eaa682b52243d56bbb83a832adb0e4dec2c2b5cca165b972f6856235871ee84cbf9cfba8fc7af7cca56ca4b59891498a503f2c2525e68e1b0ae3ac33d1b2a3495e64f05f829668c6612adc542e0e883ae32886b6486b7e33ace02d66e2c0d0f7ba8757e580366b723156ad00e1e1394ab652d9252263b998f96c659114ad1023542f1d3c103303709ba881f66d3bf3c4cc6a1fe0c49a17b23d623c9961853f6d4aa0aa1cb5ba11891c95a632f0146a54e509f6c975b3ce4c172c585d63f4c44610116d6603edc22c001c4b2bb34e315641ab76f04358bb1ede45693f8e3460d9466c8e985c9cf88078bdc1febf933e47582f9711ab4b5ff6c69e359ee5b0f43d2d69340342cabaa77f8c416560be49aff67ea64d97963c33d7f52ccf0f2fd4b8e1131488f970e67aa843733e6397435ea76ca6d2e6f43979e399fbae94228a9326d4e4519004886f89c9cbbd053f643d1a46523885cca80168c1e4dca289b0821a391a2d6ac2fbdf9bcb1bc3d07d8d5fd2679afca36017e61bfcc09eb0a4a001822d64907920f7fa35a8ea2d482939996c076bae7443cc79482a1a29eeca1e1fde5704087b81cda7e70ef05ffd60d9f080a27e935c69495400b19dd992752adb27863e1c3e056de385f7b557e14516a00bd50e476edea87720b928e29e96390cb2409f2ca1e8deee05fe0771779c72f50ee9219e606bb7b2268612bb3d06c6708c7c2a8fb8e843ca7f0fc4db2ef71dac598c1d078039e6360c673c663a3568ac4d7b322e67a4b4775d60fa633ea4c12a2c1fced9856563066eb83fb2e94073d5174a6467989772c5ca016ee4e22001c3cb09f3ef018d222aca4672e4a2ce39832c6bf49e9e898adf21072553073d7e699bb9ed6163d3627be7e64e09035e3d5b3a93adecca31a668028c3c510396fddc6ec69e22b6a4fc7cbb791268ca708bc14efd5b8db0fe79de131956da6aa6d21633f4c3aaaf30882380a88c774b79a9cb28bbbaf59b6303fef244f572d3a250011e87ded41c72fa981424594df9e5e920ea6b5cc813a85e1a5b24ff11f9022ef57c511d8c334f7980a5bc22394054b66257955b41853f78eafd4def40e13f5d44f65efed261301bdee98816265550a1c51c2252fd31acae8ca7f0bda67393b08147267dcb40786f154e309298d17c1de56c008bccb526d14d1148f22a0bf82d90a5977ba3eeba68acb916376e2876992a7886013b2e0ac41278c6e36526d1d70a3c020b13dd0d4202b8ad26d1d85da6d47df5c76265bfff4960c0ace4fedd81f86ae8762938aa8ed45f6d19b36ce3f517d8a89ed7f95612132223c8f1a19d32e8c2288ed8892b3192295b738ed3d221a2d8dfc725e5d5439c0a853b4df806fbcd22a4d92c28b31e908cea9b1c7bd4af9c390e13872a652dc0401827e97ae1824f47a28480043b7e46dc4efc37982f89a8937cf45666602e34996ce6560f873b20387826f800f397c9d95231fdb7f374d49ad3a2335250e339e367091486b02711496d3b2a66577b59dea804087d7755c0c3e1e51c185126a764a33a1d0461914a8aeeb34d9d43a49258379bd25c427b5bb3f3dbf7fb06fdfa1bd3dda38833d95cb3ed17013d901ebd9ad69c4847f6786a6356e2dba6959b58f79f82d79bd340a0f055c333dd91626122f842b5612dd34583abe8186c265433e854a20f907d09d99bebc819c23d65bde7ce756a8198af5ab439fac99ca6f0fc26aac8941371d573baaff81733d8755d54bbdb2d34eaca565a9db5700071ffc10e9d88a475c853fa749cc81a93261cd2c8e5bb282578dd174630454b5007e1375d16cd772f094c76f9b427db65aa635a9498ac8d14509f6833a19ebc86ea6ac6aba1ef9a037aaaf352cb469c45f82aab9bf32d4bf35003ddcc84f8e525e8bf4b2fdab9aef9a71dd101b4c457c94768bc804d7c3060a413163357a353ec3e402d242378b9b5d851f5b285fcabc699bdd12ed01f61c0371ce7353c7ead812afbe2a5cf9ef84fe6b7e9b96ba833c3029a09947a6e2d75f7a786d103925d4276937ef6fcbf1f1e4105136b2479a9a5f07b27b0f43bb372892ff0eed568b68adbc3bbe1fead35e65a0e94c87b006a9e01078e921476214e2e563d13eb94100d26bf40e0404324d30596d0c063eae2daa58285d90a5c1e0ea1f4b2873627d47affdbc12343e96c18959cde9e45853f7c15a7f0372f88f17b46c1fe4cf137839844d7be694781fdbb1ffa095ff37ef7fc616a76f5b39138a68027e4873044a1fffc4301aa544114debc86752fe75693a9987721c16d0b7dcd19d08503b5b5dabd11901b5f0ccc35399235d07947ec1c49349734ca2bc0a206ed9e539a81e15579b21235022caa5f192049ad4e45b2e9e6ca27f55459cd7bbcce050ac4a9b676a89f313807fdbeeb626022748cf05056dae6debf94f035b81563753ee4fb488befa140a6358b1c7754cc07986b8e89ff39187f0bbfca9cf48fbaefb85fffeb86d2524b7ec4ab8485af500cdd35bb9f5b188fa4812d84467a406492abae784fee0e2d23b8badc2a48b5439150c45049fab109a716f77ea54621a3889197f3f7c7a5f66f779b04ea4ad754e632438b603926dc9b04c6c6ef4f0a98b68237575fbb66ec306121932f6b20add79230a8f76a388fe033a8c39b5afe95b6fbfbc889a2a91472bb2dde88b0b1b0eb4177670eb1e65a5c0199c287eb85c60bb75055c1e45ad495a61616cf53f4bd1339071bc991f5d378549a38c206bc3f22c67e1084796cc593ab3bfb4db457f83da23d6b242cc59d194b2d18e8deff319abd38bf9a54343a91c2850a2e05b3363db3a2ccbc3c64822cc746c24e1372668e8c073a1dd10485a35b20449712589c5b42d9d515f87ca074213137b2908c2d3cc08b5c33f371dbd2eeecc8927fa14fdf993b313e617c02e2e76bc705634a794dfb214e7574e93aa5bfbf7f205f6037ca6e8099e0955bf5834f457d87e23cffc54b2d035440b3e95aa73b2232c0f34034cf5977e26066b901c4d506aabf8f0923a062a1d0cdd5fb17f2b2a52d8ba97284a029806609620d0e0ffb070e4adcf661d104b80db9b8653760fb1b2c47068a0b88d2cd8617406c921128e9fa75162808c48991c9dcd17e1e5757a87a1c98e2bf56758dfff6d6890e110bbe0a273cbbcfc081362f2f173781707948ba616fa4390915b19fb765f6a0f2b59e40d00cf18d10f980b54b92dc83b4e69a98b9d30d98f0c2e1c8a4915171fcd2769475ecffda9e1546f583658775ea048b08069d548e343ae822e185cdc986934b6d0e58bd642caccf84d9051134d4c4b4b0a4e3a020fd7c90789c274a5b4399650560d42dab10f2ba07953b431b93f961a4e87c2d86ecde5f11c689f60b5078ee0377af9f95f78915f26c31b2dde384e9eb0d47418d1ba4d89657ad5a6ed14399dfaa671a875b2b26ae0d4e059dd6fb6b79db8decf36ecdb7fa87c713d56b7ad90d1bc646e86404bd7ce4dba4ff66c6fad6065cf262f4d24720cbb39cb06e7db7373e8ddbd4bddd2390c844964b2d6f2782b761331597d2af93b773295e22f24e3582a1f9efe589ec6cd63fc4c527f67804c597c922cbafc3407c043d76a6a31222938f0f3200ff14014fbd214d35cf3af5dc0c69f49b52cf1f85b321a9d1cec34d063c9540af69b2eb1c731fa5f783a9d38e456d3654b71023ac772f2186e08aaaeb8728e7a43688772ed0679600df88ed3a941ac29c097f421faa8358a549a695458c300a10067e37d290a5776bb63d30d57621e7ebe98967b6e764bdd602c40a29d703f8fb00e0d2e473ed8c2ba1ec629e275ced8133dd0111573393de0ecea3fbfc01aaf8f95797b0747a8e60acade7f99eba62c655b6dea6df4a0565c45a666e12c495f98ca302bf5541f4f55cc502983df6bdeb7bcf44833aa254fb29ba39780d93943ff276ca47f45177d0a9a79efd30584e85365994173289789825db40e0e3b6202b4776765a66511c55e8b4884e5dec5dc865dda13bb151876ddae5ec5cb4be3fe7874668c60714278f34b449df4552cf415e6695c2a802969182def3a9f08a0fb643b85e4fa72c06223df5658ebd3fa287b61efedfeb87e53ca67904790c6146e16f3d04a5f4b9397f84fe1bf969e02867da5f3e8851833c444453ab7853170efaef4768db63b8b5126c8b0bb414ffce78ed2446275e8d502e303d294e56545fe02004015aee3192814fe18f2301706570ef21539ddda0e60618072292ea182e0e674ba1af18e241880d8bddab437b1f9d9010c93b37883e97282b492eace6d475c8175dac386fcd27be1cb37448cd74d3362569e0d72012cc4cf08a56e6cd94d2bb6bcc1d208bb5a84872123a04cda003cf29e7d52708de822d5c2f79bc2dd07a7be528fd9a204ea8796085e1a987324aef870d37f1a72e597988609c170f255637360013d0200ac47db3fd3760fc61763452354e6233f795601b2cf53734679975ff34aa0417287402a515124e8bf90ad9fc3d8ae55d3b1a00635290ffca2576fcf85b2c0f3587c10b11563ca0bbf6ab51b659a06b46c34110378902eb6b01d699f8fddec01ea72af230773f4bc089d13f401a1d54176840969e17b536fbdc9165f59a48275fab8df29a629669052419f19a38c37d273f510caf73775cb33847c17a432a93cf1ccc945f2908529373e8236ce6f48ce1aebb6d20e9e40e51d49af542ccbbed01957b4bc5b565d31fd9e962efc5765bc896cbf702edf8328ed8cba4a832918717c8619283f77519cb45af2a9f9b19cbaaa1ecb0354df124d3cd42e3e00e77c8a94fdf17427a5497d15ceeb12aaf2e14b6a2a81c0bcf0747d71bd1832e443f6fc6a57692045a5b995ec7caf6f7f466af09e8f87eabec3d719681f69f3178920fecc444e6b8f485a03b8c3e3f2a95d230d4af33b4ca26d879f593ba213627b7e3757738cf2cae52cfba35160fa3839465bb30ac66ee20301a4b66ee705599da15b95ee6195cc2648de7437a5ecbda84e02609a75ced2744f241f73dcc13ceaaae645649a52053dc845","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
