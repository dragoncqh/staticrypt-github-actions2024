<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e3a95f7a404a72e57ccfef8e95a72738b72beb942d6b749642282f8d38f4aceab6ca71fc731669872efcc68e45d93d6f52dfafbfb4f509039fc41e83cd32fa53c5faa631a476eb1fb95eafacbb4b02cdd4ada462a697c7e7b6283c041a179f8dc774ee5e04d47009a4419996bec39acc738bc3fd76c0dd80905bbfb7e19ff601ee9c578428ec7e081c17d71f7cafefbd56e1fac2cc44590722528c47bc5671d34630e1c4e0280e82d3d76bd53567e8581546fdf4f4da59675d640dabbc8098f0bbf15d48bc9e8a61b2547c9e8acc35a820107634ae26cc71f5dcd5f55a89668843ac53bd215cb8940e8bb1e0bf938ea095f8f47cfefb74a7416e61d53923d9bd18684a5d5b8ac2b5840bc9127f538c4158f3efbce5900a824ebd00b3fbce820e9e52c4207d598c0f5203cf5e599c4b63520a122ced57acc9626633590f9bb703e4294de412e2ba47c1b9a50a38b8f99f732c1a5c004be7c920158d58a7f3f0f095b116718a8b999a0697a5e721d2973d849cad5140c7ff77c2d0e951c70cafaa965d0c51caaf0ed724efa0e63e00b607b556f00abd3818727093cadca58dd25beb627050c5ec5a3d5606f91c5b5a2623d63cbb2291bdbc5218ca9533e72cf135ebc5e22d13ad9810569447400ba2441efa6605184e6f62d582904f50eb33f0411ac1765a981a10e42dbd93d9a83e72a5218214762fd52fea98ba47bfa9cd13bea4c6b4ef1c8d8be17b6e79c8b73bde427b96edab2018562259b527635f434f30330b779cd05464320f3a11ad91f4657d4bee4678a723234bbd6c12a9cc4fb361a31e86ebb5858a6a18f8ef4fc27d31b40aa20b09fbb80c545b4ca3c9e8a498984c885a5b23a1bf25cbf8d6e0b9445d16caa3306a270e10313598b62f5aada60242b1c7e883d6e77c7302255c9163378d5b7a9fc645b558529d173a405a4a145106dd1385b1176a9580a5426ebd677f81695a858a5218efeaacaf3eb3c8f918d8123391b7019bbee55b3e3b9e7ee92d60615446235e160ee7fc7fbdc8e2dac0df779d695355199bf07d2a2b88ab36cdeaf311053a3bb32b03581fb8fc40542be308a02224a55a3f00984c05da73b2220e531248f894268de9715d569bc55d45d5cd3959e0e7e1c7a2900be7a5866ebd68ef276ffbee04af36df76c42771afd349b23bc0cb12945fa756ef3099c5128821a764e5afb44e0a6ca5735152ac5f32ac82c1cf7b920a183f6c0a46bd1fedb8c7ccdbd8ac4bbd43879831056049d61d7414895c54705379e7b521246e963498b7e1ab7d481433eeb19cf45deb0fef41f63cd7d7bb7be11f0df27235812271541c0c4be54f7c3711816dbeb4ef4dcaaaf0c0ff54eb9325542a97f9da72c9fdd78e9682a0b246ba778e86064207f2ce23895d638e2a6afa35566d8fbd00c7869304de247ec779b9472da82830b11d2755296eb5cc3241ee865c0cb26726c63d4ac011ca24ed15ef1f48dd2e3083a8d24bbac9715d872c6dc78196bc36adf12d64042538ac0c29427221b13cedc6882735862013fcb40bb10a5c5b61b356b8c71d5752199baa11ce021e6f21a03406ea64803e464650451545227e15028733c8f2296719a9b6111c7e15179c5c5671d0f50e90918dbf5b77a13c7c59386d634c32b7fd4db7e93364dde1f14f0859615d5ef84ea982f4f3d32532f15f05b854f215381aeedc940a2cb9c26a9a90adde3fbdf890acc0212ddafc8ca53a62acbd11f2cb35c4f5454eeffc49188d9dd1a052a57c8ab27bcf3d38136c6edbd9c67718cbd8e9b609339ea8fed8b2f01ae496d8420f928ab8cddc35772a2b8df255a1710c11a260f6cc07250ccef72ddea9b5777616e412caeca7d7572797f3c328fa2895ff9167a71df7de46a22c697529289d4e3d204ebe0c96675aea26048d09a9b926e02eb37752d927ea0202d4e16c7ef80aa6bda2674805f8e43014ca816f9649efecf32b93ab4380c98a709b71babd4fd92f6b9d84c2f42ece89993ad0d3f26245f22bbc46688b38606e53aaa435cadd9664fb2885d28ca36667bbda9d533b7a6c475427df9a193c5a77ee8ff2ca1bca40108b471377863e0cc751a27b58a14b7b3a3a03fe7b9da6bb0910b1fe6af42db3f393800bd63b7d6d4f770c0779a88bcbf5659e6fff47e55e225a342b2cc4ef3e4ed9c588d2152b5655651a8d27e764072cc9815664a2d9a13edc462026b07ee668ade04b91a969241006db112b850b109545b92bd9018dc0c91beb182ee11d752104b94b107b3511fead3e6f254186868f3d83a0baca29e066c78f0a2482c6f6148e7ed38db21e2ff7f7a3a6e196ce1047c60f0d6f2ef372eb6cf5f0936aea4d2517c7b3d43c72a6cdd444b11712f3b31c6b8b425ebd67d1ec49570cd318d7221da49fecaae8523a93f73a4dbe36d3bc529e4cdada4c0bc68721dbf8190bf53a162356e22de9b3f5449dec8600a7574f2b445d0207c635288fda2592c35d5943d1bec01ce3cbe075cb7a0ac1cb3f76fabb767390fef2e2f552cec9383e98fb1535acdf7d6d43e2151866b4fae8d33c438789ea623366f357b061215e51006902f4ad341250ac574d1885711567abdd7ae6af80ab1ea87ea8c9c9cdfe7f3f3ff3c89a66e16b7a9e5cd99821413dbea064012555d075f020df704c092b313e7b4cae232de7cd30ef74c4b021e2498116da7200f37ab3c2c07d502ba04f316083b8ef4db4c7663e06b88516715e04d1ad2a2adbde4c352a67f5100bebcc9e8c00d20b6f90173984d7dd24bbef0453bd1e3fcd8651fe4cce6f2d40d94830e1177f5a4528cf67d8a49586f6ae7c618bfe40a629ca6ac15ae39e6e59703a534d0b9cfe5ff48e93478b6461ffd3f4c30fe7d69dbdfed8d3b8758e0b81820b85c4e3a70174d9b0e92512c3a6a2d22262079669f26ff04fef57eaf2248f27cfb743bee655de04f46f9dedc831644761baa92538ff8c2ce388eeee5d9915ece04017bfb7740b317cc1446d204706266c00062da5a4b6aedbd61c70e2face58d4b582b0760fc8c28e20ef374109580b1a2890440f12033a43547dd70132ca8d9dc8a056a78b9f3890ecd74dfa3b02808c62419f613896e27d3e8513961abc33b2fdf80d96dc0f74497fc9eab83d060e21623d35f08d9e6b755d05206ff74dcf71918ef0c55b3741610ce5019e6e2e425a426d752074546824cff200ddccfacc898ed92d09b3edbf3739203661ee113ef1788b2a029f3d037597ff26ffef3c07ed99d41cd2dfc186f5610fd9362b4c0963faa861be605fa1cfdf113c59ffa3cfe8e99056a8fa9f2b31b96c8cceb11fffbd36be987de6362153ec67c2557172d2bf6b33477b9b866d986a0b2f5926e8a15ea26fccc1881836fbf2e3968ebc42c6f69c8f011930d5fe9af15e9f2020a1b51258d7a471ebea3ee0e365d3097eec683324062d04650dfdd6fc643912c66a363bc25247334839ac7fcfed852f46b591d31738524765a701b3834229e080d5f424434a1bbb38daee5fc53e57b6d0a0ea89e333954bd654d8b2e62c470348e2c4c5366c0df8e27830162dfd0d90adefe54e13d7f57fbc33289c60e3d66b2adb2dc14aebdd23dc71e2103c165ac20886dbf9a688283d6d15af991d25b1f9c8a2c00028e680059a727dd7e7ee0f2b5f96064a5efb5b54a4558ac98a682b248cfe7958a8817554a434ea980b77d69abbc5b57471b4c3a8c7a1282bdc93c3a4b643167327cb0bed76ecfddf6d0886c7f2ada3a7a1f89055457605bfb7e9cb112c9a0d590c84ae218bbfbe59e9f5640046e5de416b65e1eebbc7eb8014e8d674aa8771ca61f78b7f42380323167c75e9e859748f1ca56121d71caf814c1402257537fcc3e027036e3107711dbb740560fc6d1c2111fb73f7ff717a89e987bbb4f0e335815805b123455e7d60688b55aff45d6823c707b3e7cb000834670208822d967cab24fbce1bb54f076567702c3331f9c85a3be3ec8acd09d459cbfeea0c8c3472caaea449e89802fe270d9a009af5f09be27f782c5a2da670f039a38cffd35034446b4c6352abee3e28982b7b3cce7a376129ffb87cea25efe7ab158edff0f0203ac96b0290bf2f0ed5284d870777fb6a49c96a6e5682203da339fe96b318f48095f0a5e93078a38ce0a36843cf066e77d53f4595ee4fc0159de4e4ee6415693887fc9b44ee4785c53aed937771b9e3a0bb93c065557b3fca00aa745c4601e6d477c2e2f014d4c501e996b0da481afeabf9931435900258e257508dde0b332d35182606d4fd411feb50b46d60896d9a9ad95561a6639b9370905b00dc6d602bc06d0ab7cf3eb1603616cf907a5809dde3e9258a247fc5c3b5e562518eceebaa9b50c1a4d1d3f93418bc02ef1f193779a7b09c6f38609ece534d71772ef8bfc6a3a0e62facd892b2ee5cd5ccfc8a4e24ed5f2e9998ca2e30388ee29de86d02b20d319b14c4c14298caa4b330177bd33c735b8b1440d1fe5ef816fe4fb46fd7c6de48968f6262c834147b9c3ed6c435f9d1c545a821cfcc5de56348b3fb11715bd611d124f55610deab9f6b76708b991b6ce88393594d948f907ab611cdd2f46d4e9f9c238b3f6594a077a9d827be66b51bbec3605031f41885685ceadfb87d08c5245b95902f5bb7ac8e5b558dc1bbdd37de7e2cfcf3c53104e7062d1dc3e801113678c034be21eea918d616f6a0a1f534b66126eb915eb45e21d6d79e8b95b0e4a66d597a528f121460ed36a984447d00f0b0b87c7c505f929fbe744c4b748d6e70b13218a844c7e4113c9be402060c0bd76d083d8e8b033e954f4dce6a9c4d2a7b12d8ec33bdc25d85a6f554698ccdf004d993a9bcf41bf96014519dd2799a60eb325c6e631dc50803a290784862e2d2210c82ebe1998f363af51279e2d87afbcfb490e424ea03f9bf8d63dc4c36a3e6c5309a166efd47c1fffc42f99f6a396b83f45023a454c8e12df098872a67235b463f8720524d045d76c7933a69521ad628d23b315225b30f41b04d5b8515882653d4b795886961763b801afae748793ff697c5449b8842cbc11dda5e9f9a13677106a9661623fabc7403a8e6a63638249e1f2f71587737ac49d0efc96af585d389c32bdee8600cf9521f95ee3dfa7e452ef783d1266bb2fe5f48ef0c1591bb33514bfded54f1a3b749e1ebcb45c7c9d9afef1838a7ed3b2d61cab681dce9b6107dc6924c0d03975f61af79107f82e4cb126ca3f9e18bc8cc4e4f9902db12166df8b069c001c8a41e4052641045797e1fe44b8b08af39484b0fd8ff7b76ccb305aeb0cebb0f4cfd0a8cffd6174799fc23c6f7fb1398cbe9c95e86bb2111fb6f50b8081b5d6a93335cb3249ef22e3cb7f992e9ad2e12438cc2de10a8404e57f171ea8ca24fc38ecebd43552320110c779194ccb2ea4c86d82e70a10d134fad1d9d619014a9a8976eeae4ef1d7f0cb85f7a0d791ba39d6b628e2858591104f323a1de62f3d5bc43f0ba81589fb79c5710bcad7aa49a896d8b3c8571bb6cf272212f8b5cb31a389ce00dcad8e86e2642c370b42fce3375395f908b3fe5df22d23341c0f33141eb01a203c7ed11aaaffec68ecafc57b6fbedf390ef95f6defd8593380a5ad29d87189ee09e9a14b1028bb8a7f0842d85270f71652465ad1c7d4f244dd11c7b04e9bf7332d39b1be4ca2b1a6b4a5d60f9714b6551137d3e568ed338962c0e49391e9c11c68ebeb13408e1d54f0eb6f9ebf07a2c52c3f5da5e959f0eca07feeafc789a5705a05b107ad0f311d6b77b7a5fe8d8e51c910dd7b8a1b3f007733a60961ce75c503618bb08bea72150851b764071c44822194820d2cf07c1ffccac298f599a0092ff15dde341090ae5391526aa46d36fe9e0dbd2f98a412e2d7eca4397f09cbbe5addcad6bd6f0b4caa88aeb6da96c6012139891a1ce59a6bf042ce4e77e3876007e7d910e47e3ba1415a7ca26b9d8fd528a85c569a92a2c2b54b9a9800a8133eef97f1ee90b36a2d3bec1940af0c2d267e51c7872644a72e3bb4cd170799ebd259598c28b28ff505a743bfc07e9eb31298a7a87b3b818c3ebc8c0d51baa730da0c030bc86925c3eb102d65243110dd0ae9eeec2a401b9216b8105291eb74fac06243bc750cadbef04f5ea9d9cfc814849677b7d307c3770d76abeebf0bed3a53228e96e344862c4dcee4beb7f1152566a86f6b2cfc075b2d65a4e3c0bba4c4edede3c812f9cd4ac91c17548f26b027dca075a734a5f2033c948fe80d463b0a91b9cb9dbc1b80b3ba01ff038cc822fbdcb76cb7488381aead05cc6b5df8d0bb5c3c5468601b47de12f4a96eb6e8c47e9de20fb4daade8826d516270e64f8b29fbd182ad70bf132656b60b4d10cc05f6d5386b9cd55f3fe04f0ba68027058180b9eab344d9e24b472e2fdec9295ea92607ac04c3b2df3dba72e852554046b5b02a9bb4a3ec6686f8910d58d4d2a76eae8832dabba4cd2e793ee5558f83b52b19aedc5636f2283c39baf190633cf03a1b99e746bc16f9d2a1822045f0ecf67da34778985be4c16d1e91648bc739e931f9085a3d9b7f07fbd6cc4ec2919afa221e24a8979961500e5bb9bba19a7a9cefa156fc57e54a013cd7f975e3336c3f76a55ffb9edaf336398b6ce223c2a97676d646ad201a72435bc37696ced16282d082fc20247ff47b5191fcc687314eb06b5f687f563045172c2bb04e64d1649df40728f03445706c5cc8b30346aa96b47918222226c552cfdd202bfe36b67e42f8898940caac12d0fe70808c0b12872968c26156675db6f2d67119b36ad5aef5592f6ca406a3db84cf97195cb6246e8cbefd23412778cf1cdc305ac848b9987c41bcc4748e08688c00b2208a9c2b97a429c74d0695c8470c75b291583e6d4555b167d8b40d43f6f6eb9592fd5d07b836083acbc5a4bbc47406e8ccd3e89858080407c79e52f4b241bac62f6baf0411a574fb9c35b2f99ee595cebaa13dd69cff3cf118b9c37c2bfd0a39db858d8500b5518c26eb600957171ad95b92d739ee500462d568ba5ce3f1cff59b9deac9778e6f6167273d4f3f8503df2a665c26a3e5bc375f1009f19a1ad5433a2de9aa60f9f981b3270985931f3b05a454c04143d654b05b1049b76f54d058ddd4a757e7374695e8ed12069d89360fde864120ee2c0e34a24435dcc0c14dff69a3c885422d2234fd5072e0a68b6d55b5ac970681d0f6e0ddbc2d76628cb010a3dbde50a4d8c011670195fe11027fefa89bd7f498afe0f02ee6623b2860b039ab03d34d5a676f524e686b33615b39ff5da6334a36f7affb44a222e8052dfe45c6b2749798baf1a0dcb368395503deaf834b56dab35d12b104ec7b898ec3ef06aa669d4bb093870a9fabe8866636d1295e38284fbadb9e3a9220eac3c0d1df6e48a9ccd25757deaa8597fb8245634595efa84af6174411bd5514176e404e9cff34a6ad150359f56b02cb56540b637825e1dcf5d435d2ca699d7776cdf9acc5d70b6960b81883d97aeb77675c3a5e7c647540001d5ac26d666f935018371423ca8492782fdee02bb6fe7ddf9dde875058d0fa66884da5ebbc59807dd20e1853c416b11d8a39cd042e90cb61b1509bc1d484a4ab7c76498afcb4f4115a3664c6707ced4b70479b4903e1c83b66ace8248c3b13fdb6e3dd6dbb54172bf03f4f328364161dade072f42aabca5530c4679819582e666127b44274b196f2cc69210313f36f640ab00d5129e29ec921e217c3fa1cb67a36e9f8ad54d85843e31bb4942070812589f43ad63453e2ce0a7ecaa97ce37ed366c3c968f2c6d6518a4ae932ddd4b83622da933f54a18296c0eab238487e54f98e3d0fa51737502267674f5baba36101da907ba432645f2a77b7581cd8d41f5b9743b9857da28e03f0068a823b27a3aac11649bdb465c5364fc5756ded3eb0c363be5ddb195147a9cf639c495d2453596c14fe3ff8f7c53ee9a818d80c5b58429a8e5825c2ade9379e4c1a859f01dbc1c41a40c7ed97c6222cc605fc8254b60a5c1dbaaba1cb77f252aa06bd9dc7199e8297bb86ce46957452dbf44774b90f3ad87eba816b55660bd336fa4ebfe77766b8d6796a68a35836c461a7bbc5ee832b74d00d64cb21b97bbc89fa045fe2faab750d15769e10bb716462f0c02464affd25c53d298b93f7359cab1741bc76749d1193520f20f24b9fdf852c3fe69968bccd1e72daec01af52072b6cc05312dda87ff246739c536b4f417b54ca56c252dd968dfbc1b7e16fbc91b387a2fb4b9c92aa98bbfb55ad0664886badea2f5755c909fb6f455f54576ab9c2988e307aa8370404e7f80ebf7901b193fc0234921223d8553cdc53d77236153c66876d2326152023dbab526a6f69fcf873808b28a93e4510461d9bd1ddd158861802ac637605a9166ca70b5a109a036fbb68f9f3ae255b668d00e39f97c0cfaa7c0922b4e9ca600f57f238a44034bf9d6f34e3dc6810b154113de4a88c1920e614cb7a0262818921f69682cffb11bf6713606c5202a0569f6627f404dfe3b70996f97794a096d76be8e421bc6a7fb3f843358bec2d8d47823cff6a5e2ef1d35677d2c9da0781f20fbd1bcda3d44421973def433a6309572263ec2c6856613a7ac755b77a99b09e851e0afce5696f2e0a93c7dbd63f13065bbde5f016e61284ec673a3e18d911704f43e3e770231b1912ad48f3e864e99550efee6c421bdefd697ce1c90a4e6d38b2981b342ba1dc4741db109420f41902ab8e54cc25b5b0bc6567bf39e277a7c8d3e80c100f8ed07049a9fb3cb34a8129ef9bc5fb6da342786c0e5cd17351d22187292bd0211d03fa22ec1718f25c84583e4d2fb71b3ffff22bcf0986ba101d0ef1b5f45798236c716d12c32b072e968ba3ab63b4817b51c4c67a6337365a145e334c4e6b31b2e4ff0ed242eafde33c0deb7b2acbed6f4f5a83362e4660701bf8cb097a48096d8e5360e4445f8b94d9c8b4c10a24da9b4ef146c4baa8e91cb99924e67ef3ea22c0f6289fccdcd48e2c215582ca7d480f905ec81ad44e9721043b955515a9bf37d99e0beac50141bbdb0ad0a056c4698b4a9b2f9e45b79e60501afa67bcb89acff82754f8af1ff2d6d67f445234aa51f374484e4b444084d980d4339426c3f50c9a7f7a4947504c36df538ba2dd17366ca1376d2133b0febfcdbd8ef13e20e2e1052f1047ebab5c7d3752254b981d5c14d8916291c42b99cd811a507f05f0e3b167884a05e6b6bb3f422bca065de23011a3dec4d497d8e6204e19a00576dd240376a980cb34df1a99731a2471a8f03678fcf58e976d293eccaa28030becdb07361c3087efd551bcb119d5979d35f8de998446d0f0c86d88237e817cbd57c8ecf8e72431dffe6830030ba0ac789528f6f64e391ead6bb5468c5708be32380f1ec8a12262489c34151f0c5c8efa90e3976de29d267ee5bfc76c355d6090037f44b9cada126f3bcd98bc5833607bc7544e89e92561d009d183c388d88116d90a846ccef087d45128bb7b8389fc48cac567fdd83d3bfc0909b1a4e87729b302378807cdc3093f8e08c04495acbbed21800096c10551a9907e6aa13d10233df9c64364cc4b023b023f069415e1a71d342df81da0b10a85bf178a748413e2ea584ffafcf620e2fa605b426cf30527f9ce57c9f228267b954b819aabeab56bf98bb1d1afb833f45268ccae98c5ef3080860a40c7ca1961956e627c89e5e0a83d7dfdf9721746b10f7749c8844bc7035cc48d8633152d242c945847f4c3a61eee4a3170c967da4f6b77058b3f2003448eaf894995f252683ad855b230a24523ae488a510960200115c74538ba7324853f3535eca5daf5e86d700a46d03e6f8e55ecf6b4a1c1195b008698968241532e0dd35a2665f31d85e9b51fd853b69e405981f99682cade7148ddc4280ff9d2a8d40be78f766596468df5af640f374eabff06799de3ca1c1a11491fc0b419896729b18b8212bf5ebb87cea9cddcbf48597966aef945a02ef6972697a39ec4df1f4d0f1d62bcc2cbb86c39b32520b57344e73f52d19be65c65edaa9ac8608713aa3633f3ac42b451ede610ebb20ac037f3d6646c017138afc30f895b5f6b73f849d775098ac203c43b3a056bd2174564298b5b4fb9031538a103359fc2fa160a85309d219b517072b60a33a3f7080361831d15afc9fc982d8ea5dd1fcaf179a2aeddd4ed8fe284035af903754b848a9ccae6031555f75027f179cc6e9c3978f7cf511fd59179207c72be4d21d9eaa3bdedca5f388addb145057dc5fbb67ab43ff159866fea3e394d05dd0233d0f403e7a6fc102fd93bb7cbdb2b899dbb38106367f03452e97f3d1ffdb0b698ace2bbfd2ca298441122803b85ae8b12f5c10c9699de517e57e5eb9e9eb956b45f88210de9c11632492ccf13b244dd169528bf9e5539424b89fc760b38a776b48f9af401686e87b8bfa623672120b2df8f17e75f908e29c0d4f2f15736b935b11bfad485f97089d1c4139bbf32f3060c3962dd1d0b858bbde4ddb2415bdca2ec3a317e1f56552468ad1365d164d54aefb105d50f4069c4a478f2a10816ec0b491ddc5a868b7fdbeda8287f7c05fa4083e6a3a58b91da44376dc0b542bea1a7f0fb1bd75765d7c40cffe8c61da415b0ccdbfbbb1b8dda9861b49bf2a72e733cdf3d36b2d4cbe56dd93abe2a8cf5e540037982208452de3a74479ca5ae5706612b06ccd64158ba154cc5e0a60bee1b84b297bc4f23d8fd4522e06300bfa1f213c6b8ae8a5c05b45c7916f01bcd8aacadfd50865ced3a89adaa9f803cdc1a1e1f710b7b855c06160574bb67924ed15e470a83c891c49dae82f002a055a5a06466925f3c77559a6f39f5d722b07c4f1690a2fe8879868a87d6952535330447e14731320e6f07995b7dd2aa30bfd32efc00de4b0f388faddbad14900ba65145dcac4113342f8f6d8d3b1392c4fed44f4827f540bdec42f0e1e3f66a2e6de38e759e08fb8b319e2458791b75248f3013b43107e12bd787d7149bdb8300743a0b280bfec525bcd1b994d263c89b528051f06d1c40e0904de007b0aff51c1606d5474ccf533f93f2b6eeff59597e5bd72db4e155d1fe69bdbb7e4e4506af6f46cb20b52f2a9bb7fbeaf96a4a2e4c461158802880e6978adf72756118746734723ba15d799ad8b807d0e30b6b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
