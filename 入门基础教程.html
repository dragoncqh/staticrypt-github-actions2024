<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0438458afcb88d6864c062bc156c3730497d6c3bde9801e5ddc0ec49a076b949ef374b37d5a1cc98c471693dd242b68e245a3990d90b2dceed7a93a8a0db5225a53d14cd3f0047b33cb03a75d3dce44e2dffb95420ff5cac7c45ff23189c619936c7b229429eada773077674d3486e41cbe944be885d256146f4996f8823c939afac453bff8b635ca61e0d73bda07b665f38cf38300cd47fe43cb0c50a25acb2c8e4e095794108a0db9206466fd90fe5cc282ffe2e2b3de835c1376a563fb396ab83d1f8144475935c29b90db9c388f300921c0258d0bb8a82454049d7d87a42ed93e94bb7f5c8b3bcb3360119943eeb6cfa7ca4404181038f3360bc75911c2cc445eb9c60b35d3dcea790261c419f359b09717e91d1cfa632c32fb389ab533a4b88af6058953521e2662f4fd3edf16bf6aa758e1d0eab4c2e4b97ecea9f4800be40156fb524c382553994fbc973ae2c881f63101a3be44f3ca753b691b4f711c36fc20fc5792e29d72125eefe09a940bf31dfe54dd47ed57b0d439fe2ce550e1e5b1b71a8aa621186cf716cb3c8bd7b5d806c0f5e993190096a6af525b898c1f0bac97b16963757a5cbd18f2adf098289f4d0f61626d0d964719ffbdcb2a0cadf94a4c7a3a6815de29717d3d6a88fe0191e01f039845e98b321324cc69914cc2914f51a61b86909e8c6ddded590a9652fa6a0f8d31e9ac9b3977994d648e4b93fdaa2ef1757362af5251fcae3d2e83811fa433038c6291486cb315f36fca13e5867f49f39c91fba00e561382abf334fa016e976e167eeaa2b7346830d8fbcd93522b72bbec7790f1bef8ebc2f8cd594f843e63b6cc9d7e2c0fcffc4eaac65c37b28757b8dcc481b1563f5b9516b5e0212ddea198d108617569d3e50ec8ff4fe26e40107087f7a95cafec7cfd5e222d35e7de57c9e860076f6a45e2209f9fb85c0fed41c79f28afb7d4101920a2a932e3f49dbfc779e3091be2a6c0c4082f26815fe91df2cc44b40061d8cff1c2493befdf12b943afc56ae7a91631b1fae9ea053bdd2a7b07823d0f6df30e2f3694d22e8982da54a44216b796e8248aa385b3a6bdd4ef487719545f54fc9a593b3aacd055342f0b8bacb934ab52442de479db59a96e0bcaa10fff6dfe25fd40203545eeee647074bf2d43e3fa03a5be1e9685c8aa96e98ea9fcf51648017f9d118e7661ce7abf5fa1791d1ada4c2488f6bcc15cb0da6f4822fc55ab7b2decb734deb4517611de4b72385e9267db3b09a25a5d3573c6718cd09cc26e5f162477199eab3bb4ace8fc784b845fe25702c2450a7e2f27532717bdcfdfe2c941c3fd389a15a7c10a594615e2b64f6cf03437d24e50a0555c86d145b3a2f8158a0ef891ca04bf7a86130ce3e645beb6e21b3da0b84d0104d21b25b66405bbb51515272a70654488f5a4ee5c7924129c6cec2fe9572d39a0ccde2b7ab4709cb57e0e586274fda27171f7476e0d91b638e40d23776b00c27a792cd55f9263155684e4f8870b5062d4896d298946d8c33b4be818d24e551ff8926177eeb23dc0e98c937c05af9e9825824217207ea99f4cb14641eba70b233f9783bea32ad7e0aa90e7fd981e39a619d87fa7393fd03c3bc2fa8fef039900299a395717e4362898f1455df3ac1638bf6a391c04e31a3b5d2e9465dae932d22cd3866944592406bc645ff8dcc5cbafc0f58e29194cb93e8ecd23cd50e85eee8b6a1d38aecec58d7836305e27a5377cf594126ea096603fb402febc24f90239417bcdb0911e5eefe98e01958fd4fb1a7cd984fa0bb5eccad61f6f9b874f21e9cd9f34b2e0c028c206b235531eabab783684f197c4bb2a992a875203178da8c2f0a248b02aad02649b23f832356901d3d10c54f328a048ea568821fe7fa65c336a64b706a9f03bd5c688bcd46422b5453845fef41e42216078a8969f5e5036df96ceca26c3d8ed525e018fe44bbad1f720ef298f906bd5bf3a9ff4a1f7eb1db22e113dc3778dc4fd299cc8edd7e8e93bb4ee36414e3dc9f979bc72c4082b4804915d1e8983276bc8737d56c57e66f3cdd2cc4b6f6740832030d55c60e8fc9ca20bcd5aa7afdcfeeefaa9de5abdb59c72c830b4b25fdeecb625c660cba98a63e9cc631e8a00cd452f907ad8533f0591bda30e5de696c3c01def7eafddf4aca1d5d1a5f4f9d733e851e7c31a041fe5d316fd1c192d0f5c256edc32ba27b42f5867fd140f68706528a436f2c605e8356a45f85d79538787d2a4a1e2cffb0ee03207dc94c27820e9e478f807777dede30c0789188a21069d282b43b9674e4e1cf5d53d32cdb76db97eadf6ec3be52c0d50d3a38dc1fe81af473d9d831d0c0aa55a58cb2f477d5b2af9958f11fdf83cc86ef64753caf6a1d0026c43b09b9b54ba2ca41654be7a8c1a3f2719c24aab636b63864fd8d50a41140443a65a2aaca88f94a835e0eb9188fe20b4ffd5baa3aa0402e6faa3efb80bdaaaa7c8aadd5740eb53828bf66ee9f771b287a78a5ecb26dd826aa955e250e92b6c82ba866933075fcdb323eae299339c0a4b7898089399f2c7e4d12182ce2c4a56f3839f86aced15a26838abd0327282d9cf42b9522e3eacbbf78adcc939b1a5f4e4810bc0480cff1f54e255ca76d4def3802d81351dd4a5e9fce82c4f1219ddc739db71768e3835b96cebc4bf7baa5c30e2c3d4c6c4c803ea4a5f5ba44ba93e24f45923ff65068e14db69db4a651380fd7834109a2172bc5b666904c8b761181d34092eea39e3553f98ddd8cf886acacba9aa45fb6d6996109100fb342a58e42438ab9e40f302e79af72f3c31df64963926c275bffbf14b137bb13a0755f89da06a4faeef7f2431a88f23ce1700a326b5695e47b142223a6adc72e414461ce93f2706074ac75ee81b89ee6950cd84341a435eb7327e5668d5454b2191b63846144297f5d59db3416b1d9c62e3958773cf883b0f3f62e2d5a7bd721c7578358300866ff7d2caeba57e4eb513e7dd0f85b0aa3212019c8b29f10b482875a685796eafc92e9c3b7490c85c7480e6f86bad8ff705383f873f957ac6ff1e5f6af530785e7d9081d8de024274fa805fd83037a2e7e4ccb5a6ef79b9998cf4e9d2c4fa84456209260eddd204124fcdebe9e564cb8ea1e289e6adc4d15bb4644caf917f1504370c32cb19ff9f79b2862243f2036c47c9f30cb59baaea954b24d7129d1f6da7944918ddfe4028243dac91b50472916b4112f13e6379749fd3162ec45496f0ead191658f736aecc5bc7ef2d020fbb9da4bb505dcb35d5eb0ab96a309c8c06ea671edcfc68cc844f792099396f67daccca0799d5b56bac639ff10b686348ebc5b93dbe12994995e97324f8359774dbd8e8418264d7878b1833b685facfe0f3e5fba4a6c546be9e780ac4914dc96040395f9cfd679ebfc40bcf01c604e26cc761e4b2a81fccf31205873e68ec170c351d486a45afe96b52b6bd900096f6b98b21994db84570438ee7625ad75cfea43c8ee78d588ea0ae1e0940f86823130a314911c42d97e232b0a9d1da997e95702765aa99e4920632495985cc3520f1e829eb3c3da25d445ba92254aa87d494eef0737e96f1ec0edf303da6953c5fedd5ca81990985bddaf390fe739380b5353f28aac5fa3bcdc1ba2f7ef3049a954a271a0ccda4ec9b8af0e73c0a36b624b298675f1545d6b6be556fef4f18d87e1981e7f818b3ccaf1e8e12a65836b40b9c421b3f65fc9c63dc96ba984267962c678342138716d212abb77a7b9d8b3254b24bb8a8e05d8642c866d816a7bcca01a70149d6149a85d97fbd5a2c1b628f34a4aa666dd89307805ae6bf3592e326f1cf6adf1e22402b285865328a80e71b0fc811eaadac83118397538c739efdb07be9e08efb45d776fcbb8f5cd82f1cd2e7cebb0dfa223a8217dd989880b0cd3c541562383054976da4345dba9820daed8d975b857dbe9a95963886447a538eb462c7e405009bdc9d04b7bc86aff7e20490dd9cf265d4f0c5465a05272caede07be10ad8174411d368c2ce41714298ebc733157a4c4506dd87590fbbdefd0bce1aea2aca698ddb211a8b21addfe31368f6d5582c73bf5676da88ab235d2182d38bc0ce0a32a22958fba0e3746c47dc00b256acd634158982f6f2f886e4b912731636cdabd343f64ce8df8bbfa9ba3be286decb2140ff9b01827286c3ceccf2164f3049d18a193cce97e3b339045ea16373a53ab447acc47f253728852fe262af4d04c5a531331e744b100bf6e39f3e15dfff808e4f0ab1466145fd2f755eafb3c288ae55c37cc95bb4089f75e69f4028c1ba3f1576265bfb3e7b032c53018a61ed682f623c4548b8956c8a87e36c7893eb3753df3b4409aa51adbe75130edf0d65798d4db503ba44dbf87c55b90af0d2828588d92bde88f7b708c0c7b1958f02440c94429c5a6a7f8c41211b5608931617f12f67c66d9a24d3afc159902e6ac6c554e2545b71f21e582b148a69a95c159a6f60e350e98c1d0261e465af3751a9f461d396e1d6c23fd959548347a2aa1ccbf0c708ba8f48ad6a8c984775a44a4a35f4338f752196f754e78f8c91a38af738fb2b63078097a239400340bcd1b6b0cf8603a3b45c66be266634af6c129a3f1600257dfa6b1438a9fca4d63bd70c17bb8a5bae167649e1570099db2296fc1b2441b4474bcc8067fc8196e115275e33d1910bb2f93ee729b6fc907621f79d4569e2d4f625dd0ee29a0f21c7aabcfbbf2de2f68007b5819ccbf68230c3664711440c472f52b4cb7abfc25048bfbd38420725d0285d59719eed81fffda1908fb86215a40b5f9816c7ef0e311fa2f587a0a03c7d68c836833732730f2cd39bd93771bf24f0ff85490274c2c246e4b744126f49073f54c0f3c3e64faf11042831f4a6cad09443a71467dbfc98d17fd7ade97f864310a4d8ff32cb1c01a4ccb2575727936e3c5dafe3c85c5c2b9d7b0ff1469dbde7462bac5847302100313f43e28cf0c14527b0b4884eb9a0977529f064ee056a6354d8c42ba4823caa4115a1fded8ccb88a2c5a81c7bbcb587c7b6eedf2f52f70d54ebdc4fb148a09d012cd26870816f6ae057d3ae683fc32b6641d234a74866223e8a89908c91012e34a867072c30ab3c930ed8e8fe4e405b4c2fb91cb863f655f7e92f26b54d0097eb2465cfa56df2c33e35c65708fc706998c726baaea37bb7e25f222097a4824e7a7f36a827d52088389931b54fbce79bed85f67015f76eaea1520755c9e459615f994ffdc40e3344adbb69755c941c3191d2a89e20860db1d8c5663d34c2caabbf5737c18030e6dfb2595f2d6b2bce8d605b3ec0900ff17f779d2c1536c78bdcd95f842e77d32c794f953015d0cffab1abdf2ab610c74aeb34ac9cb8138d04d119242e54ee921b6a56b3d7c8cb945d340e036dae34ff6966cba4a13b251818aa713a04f05553beb9691fbb8bce2e927757a22cdfd08bd3fe4913e5b45b5e919301a79f54b7a2a4fd2bec29874d02c739b0c6dd04052b41e5940f8b3af539de8a8ca996adcb5985eabfde3931b7479012872ff19114c4c804064ce0e2f0ea79fa8094454c9189908ed4e55604504d972dfd024ede5c6200df498c36d77c0536e18e8076c19cad732c24691af7e7977e5b6badcb49f01219bf714b5defd987874ef78868f62acce00a522cdcfba73aa8dff48eb00c267cf855344e2e6231772ac6e110316c0792b50e67ba8a382acd5376ab493bbdebf16164fcca2168f9e0639fcfeb84aaade1e21fe56ae7384a4980c3a708d5113ed386dfc0c619645a5897fbe7b6b8c0a85625d493acc722d95d51a221b3b31f3c3f97612ba4325f4d2058b002821faaa5148e696845e35cf4695a6d32dd9418b5fff1dc55fc8a1c52ff00d64f0de69fd916e590a1141795c7fd39228b2ef599ec750c8382c5a755c2120ea94273b7536de6358a83846c8c2b8baad3942a0c9273d05fb4a3acfa9ac640fbf78eeb59ac0af4fb21e2b058fce7655cd033886f6746091b5c6aca3338980c734dce67cf7a567e0c5b3bf5063d4eb38396564ee16d7800188f881085e0c91a8f8ed8041e7739dc865337a83661fb4a61183f0d5b8672bb64a62b8668b06edcf187943a7a83f66637c1d16583fe6a0e62e2486f3232d8ac07ed9a621477e58acf862b7ffba6dfe8b4ba219ce117ee7977342bdc08418ac35a9fddac191d5bed55578bc9afe9a589fafe763f88b727e4cb80aa376cf06fff872b4d8b85e350377516c9d078c6e6379b9d458e8722292ebf478c4d0b8e11e065ec9b13dd9c5247cf716a11463c88f452cdf7f2f487c264efc9721d897db2ebda036f455d81ba4fba597e048240bc2d18f6072a03dae9bc88114ce847ef7ec6546a3f678773cd7b78805f3f1ec4fed35d4734594aeca504c905e9097282ae7559121f89e630ecd37495fd489c007b0964054ee982afe33f6468e9465e2b76a6f98a40e33e3f0f87f6858e7b7bb2f7e4802be7f2d767331d7af173777c02938e48e3fdf067c32e4406d30e1c322d8d903e11d517ee16e1131a78800cb9c96a7145c3965724e357ba1e659ec217c0faf09cc53c6ce53f7a71e24d079545558a602f1c961bc3fbae64076e7c9b125c1dc5e11fd4f260af3e7e76e6a9d62fb0a88b668806021dc14580cb95194fb8d2a0c2fcb69a05d2dc8e966f17417e64a0479eeaf85f7f37118d693f819fadbf007767665b1c75d5d6ffce82bf9061797af2d1436096e44dad75b94892b60ec4ed4845a9bec4334ec810f37a2f3414a358f69f2474bdd0e6a0278ea67ed6130270304229a14df55ef92b416478fe0a099fc0e570dbb4cc8a99b31cfad20935bd9f6911f57c61150d8ea06b013f0b17596a3b6560cf7a41efdf261cc547f1460b08cae6054a8c2c5d1e33f52fcd0dfc90dcb1f5731193398e852e8b0af183d5758d1e5d365d22bbd6953ae3c8c2f17bc7b7a8e2cc1a4fe8ac1c989f257014452e7c8d1c77f92c5a2d1ef9c47e9e6e53c6e08f212b8458f0cad5f9b8dd76c3828b70fcb17c6fa91b15eae8b1eaa3dd01013244b7d12239bcb5a80d7e13fe32ea74523feed16c7af04e88c8c34bdc643d0754f55ddf58fa6652f99383c4860599cd69ee07b902a31f579fab66b8194ee865490fcc3613c5c72c90f6559b7b9e0b67bf36680f7d97a4df22d2e9eaf777751d1808c0e7d837341edfc9fb875f3af5fc1f22c9c3e64b05b2a78d6ebb183f5c4c05f444d1a56cd5318b3c2d39a120702d3d1cb02cdc5fe82ec8679bb0f83b4486f8fa2f3d81adc95f02738be6112103fe32fbbd30156cfcc002b78cf1c0291a30a2859cb1ef17fece312ffaa2b566c675fcfd6a29352cadebbb6cf305764ec1f3a3936bd0ca4e65544cb109448d230c1565341e8d194a98a62740c08e7d346afbd5a0e597ace47e957af204e9bb870b0ea09e260a2207a4c4ced3a697f4c29b52239fb2ac34f9849054f1d2ebb39a5004b50f19a1933fa2aa03ce0e906535f2d71f79b0ce71ad9c4d057a419b365c0bb8567bfa6b6b9a8c116b695d5bae8c84f04b20acc9bd5cdfc59b5f6a336e233ee2e03caf390bf38a15d41aea233a603919fb2644c95de0a8b3091a4ac7e27d0adb3bf91a9bb317bc41088026cd27e45a1dded71d5d20bfda4a0ce46e541979fac9ab23e5b58bc1366af6b55b8cb494ca7558ab77928b996d923e4e385d4c0a7ccaa6e80bf8c03dfc67d854a35268e8fa8bd06ed018113a222e501b79345e13eba083436b1e7adb3e3f77711b671a98be270fbcf0701cbe6847e1a73472074f68e6d919fd8f2206e3f1e019fd44d870fadeb8296f71d99e496741d9f070b8af61455795e03323620d813b941f84adb353f71a423053584ff720648040fe461783302ffa98aac256204c4b5029b60cfbeb2dfccd905f4f2109e12b729c3f9fd72d7ea0c1ecb38d8bed700f07c39a63fee340d52657bf0f93f8cb97a1b1d25aaac1f437dab0a3a5db6439239bb233860eef11149d7cd78c54fa4c24cf84d5b9e89ae4326e39439bae385f1c36ac439d9bbff3276e8cf51973a1a7d6bcbbcde282ddc9dd5a4ebe8e614312ec27bb5977d9cfc0f927e427c86f6e1c5f4b4c5fc1311ed888668bf162276608e69037d1ce1891018d15752e389ff3a9cd36b6a67bb6b6752736a1d7a2fac047e3bb09c88008c55a84b9620321d73a1490601b7560ef8448a775b783a5067c68746aca53dc0b8eafaba922cf080fabbbca35254b8835ccf2a425b3cb792514a95891ff49588e756d568d7225ea4884beaf2292924b9d2425b3547ac47013a48273b78c6ccc0ba99741214a9a21247c7f3d01726e0b9f6d10e614a48ce6d3c6833103e64e436f6e9ded8ed8b443f4b4faa380562f4dcb2846ac2dcc9e278e4a37e0b7fa9978ae874","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
