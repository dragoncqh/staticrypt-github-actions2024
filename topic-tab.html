<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fecf4fa7a38ab834663925624e366653bf09e6c308d71e0345dd30644b0efd8bea9fe132e08f2009c751840450d3d8da74ae10c5cd03b3c777a2dfd98bd1228f09943e8b24b5f48d485ed2cad6149352e6371ce71546a351c5c78c54f03d8fe1f31aaff98af11267daf57e79ac357f4cb52e2e2f6a1dd6b284c69ecaf90a429b665567960f847d0f40507f9ee05c12d28e5f9fd655c23116f9a1465d0721160de0766465ee5a2559035caeb0d320ec00a334ba26fd98d4acb9b84b9961530e5d66fb7c07c7df8408da89a2f68fa94a389e88c84948eaf96506d450696401d58c1ba288fd5be660694f3985f92580e07abd1d50645f5232382df247d9568ed3b941ec1e6a370c13eeeb30a8352ae8be269f89eea4b921355f895ea45871b54bbc6212327105093a4752837d12a0628b7615832e072268aed55a91993ebdc3298ceb02d5b1169467275c4b2dcc1bd5059b856b8fa7a23d47aa2c0588232f21cf92527b6f9a21d2410d60646a116aa11f157ffdd1df08abdce3b7ddefa916366f54e29214cb5b295d5133844815daf94d2f5264675c3da7fc0e1adc745b30b93312231a78632a4c91082df24456b1effeb0e5c0f9f27c838c1cc1ae36ab041862b2dd08113685bbf6b9040cac80ffeb52019c763ea21f69c7408c45bef2d3bfa37d87743d29a031bbe9abd3357a1287ad506bb37db9775677570a624917026d2cf9f6c9bd69ee44dd253947aeebc96882caf61249193e4c738c69e87bb64938bc1f1e973d7a2fdb5575291ad130cbfd1c8340bc52726f7806fbf7987c86393b003c5dc3ec71fbe1915e266402924a9b22793690ae99e645a4e5ef561e2194b6c4bb187070679042596df8aa9b3df5cabaf976b6d7e87202519df3132a6a0a0847c81b04da4a58f97c8a54263621e1e5a873984dc045135e3d3f0983551069ddb5fc18aefcbf5a04975a005c317aa8b064d693c4285f15abf5f55cfc097ea7bb50e95f8787777caf8a15ca95f9fd103119ff565e39a70abab8b3535ffbc740dce3b8b7d85e0f965406f63d6bc829da1df1cbb422e807a2a96716f416adc1f2a3eb943e50a41914f2f77ceae756ee7d59bbb37dce75fc293e6145a006e61d6013f6a7a52000b1a6537d8be75496b59f2433ddb7f639bb436678b81c9beaaf19ad7cbc98d6660cb18ad5f2f87a157085a09481f8605eee56498e0684e87778b6283a295fc17402800ff756d355f7e3dc46cd5591b1e9c5923995a6061ef90d31265b9d71a6404fbd86730eb49d318a4ed2f911dcc8dc15a8b56ebf8cebefea5453bd348eb6bbc8bd4af4013670f6dc2d9e3882eb94750318ccc53e40123e16d36e9ca565c87daa897fd82c324b3db63673dad1d085ad472c36a1cf0dd2402a6a31ed5871a959b3863d7b287d4f1b861e71376e34c8b7fd0aaaa67d91ea078432e7c2f829936c93e9f04e643ce5cbc28b82d9819bc39ab5f451db8669c565df6f67e4ab64b21e2c29856fa5e190c39f61b498d6de2d6407d5fa6135e200e19660fef89cd83fa3504c97323633bb1605e62b0fd2cc9fcf78b3249338e63bfca13b446357582db9248694b40db8813e131a7ec8da599126ff9ff4b0fd30c3d0163c6cf696e91ab6a49948e313bc49cd5d7487319a431b75ee6506e4a64739dcef7c6ee6c771f8d4207907782c1c5acf2c6ddeb04347392a7a5624bb7c9e0180bab648a0dfcfa125d5a5a58a6ec62d9cca0c2e2e7a24fe38db6c881953d9747f1401043fc689aeda8699fc4622f3ae1a50a36698aca002f9f45ba44edc70d1bad6b5bc835e8a55b9f992772ce6dfd47c6e798b2a1895e70673e9e92b26dd65d0231f837e2f093a6405dd37b517dd22112065325222850e8a426b4a4f1fc5ea9d3b29a961419ca97c97dfe7c9a48ae2a8fe2cb3919170f68a5467b1e0de4bc066b64fceb9692c7b101e0bf649d284f5fc84796295d3cc4e34efe0b338d32983684a2e6a8bbea1a7762723b011fa37a629f8a0ad285360f82cc194b919e239299396c0491fe2d9565ec8a6c918fdb9078a90f0b24976d023a53c88573da71bd85ead5799378bb192e95c04582e78fff2ed615174ff4d5e232f35461fff18a983c27e832267c1ac0b9db941a361357e7301732522eeb61425ead9d22734e23ad8f927e8bdc66c757e528a3e322c8a957b2f756e85f3116b892479ff60355039afb6ef75197556e5d0c3a447f0a418e63c4fcf1f168f106be78fe7d25fde09cca835c65445b4042cf4407e31ad8ee5b652d7cdaed8df1192070cd476dc0253c2d1d24210d6a5e97e75cc29aaeb8fa8efa5934c4ed6773c203a6c66390d9b2623646d6a847d8761342c80a06e03f714a9c20aaf3c1dac85657d121497230a36afaf03cfe19618dfbd4b505abffcf9d58a853cd2bca51119a9a19c16094cd49f89c0f5a3d2642e1f870d36ff48ad67c9f8bcdba864081839ddb5ae9aad8a747ab054caaf279ae27c516d98d7573d33d91b29f99e69caaed5ca136df4c9b579a05d7b9268ac5d87756e38aa80332e2225bc00a2997b6b23fec1908c6bb2be4613b4b87aa43d3e6ad5d5020d484e13558a6d5705cbb774bf7b38ed100a9138ae9cdbc226cdd2436d294197b645aa60ee5ee152e87d5e8ffb504177efab567529eebecc2a3a7608c37564a937eb23ba0fabd9ddd19cc2c7790955f04e9a5e3167f69fbd015afb811f61ed9d7670373a7e9e2e048888d631c624a13b00fec045a8caf92be8dbe5446da0c05a86610cbe1d0dfa7d88ff927f2c77f57d473e7a20cce8c8682e9434be94243ee2a732d20935794b1afa491f5d86c80b707c76df6c4e0593d008999c66543c9d1e7d138005ff23dd270d1cbe08eee3ba62742d0381f8fcb26455149bc8edece5fc92fb2ee804195842c2e896ce577906a50e1395b21da7ebae853dc700f0254463066624cb8ee599f09c3b5b058da7a162f68f018e380d54c2562c9fe9deee00835f044fd472a91c24c7454f456ebc84bbb5320a9e8f283602b6efcc21efe8eede9725f5ad594bfd1b957165eb161f94d1eda30666cd50b1ba92ba7286734038540812323cd23f370f7bf2242d2921a2fa0d1e1d0754b28e84abd73ca224cea5b6494167283d7757ff27071e2b5eca5107cec9cba207b850f10f00f7f9960c0332d1c2b0eb656ea646c113f8b8f14e6d75ed802d3f54c4b38df1c357bf0dc33d9014afd74ccbbb7ba77414dfc52122fdb93b32e9c9ebfe0f93b250f21772c9605ae37bdb3fc51dad8bf5e9a45a54c973dcd6979093e56b30ad55bfcb7f9b4d6a48c423d19d60aa47b66a8cbc7f36e42ea66152bfc8d517804d96778c1c275c82b9279f7ffe5de91256b163cd94a9321dc1a9a68913b374f09f2a96ce995417e6ea9cf3f2983aabd02bd0446950f872ddba610074d4863c106da2eb581bb3b6ab422aa21b15e75ce1f519cd171a517ffd1370a59c15f361ae511a8c4938a6ee412a5326c49ad65a6e4bfd3baf408e4a9778a1ba796e15f50b674c8649457096eddf44085af49aac293c7ec2db2f13ad4b990ca9199086c51ced275e29820be9659d53fa422eed726fbfb1ecd10f6d88535fb3b5dbf4eeff23cd13a91d457030375a896ff500995e290ac4e6620077d4d5bb8487d4595325bd5abffe9eb833f12859f1d2f5d3fda5f77923ab2d190b98e0843a9d8e1e2e5ab11d18b0ef7986a95f6207f96e9e11aec4a67d7d0c493ef5f643a53f4e293afa73709fa4e8ca7c92b4728560291d84562c41facfc63672ad43b547692c5fc5d0aa18c6fb6b2d67c196f962e8f794c1cb5c060b149a6528a75cad37e867020b43f94bf9bf1411b53978ad4bdd24979a72ba5d12398e93a87c6152669d62439307689fc258a8837dd985e0ec7d859a7db9b60428b95c7cda20ec32dbdbaccf17e473483feff6727e5cc60ea5be2b3226b9c61a8eb8be15db6c6d7a164fa8571559f602c9cf8c2bda42b9d25b702d204e2e7d6471781746086be2c33f8b1946700ff97a76be08b079a6da5fe5f37cda9e145863c7858d7a7c9117957da17ade319cf6671e84b96225e9d056c0300adfa014eb93037fcb49fb389992d6451049b3986bf79e644b57e8f35264ed6128754aceb71df615084c87f6fed35de2d9df190e2f713525da90331ffdefaa36b830d34534d4ffb9e3afc3b26cea0a85daadf4ab56c4bb636460bdd9fd5d247a9701e70daa4069d6c77e772dece6e55c5a6a551a49802e08e868e8f24e82d34f753c2c8fb7b63644ce2b69c74c17f3d3979350f599a45a9ca922fd10c4ee15987c6bb87357468e704a3575b2697bf25ef8894dd44f2f28396b996b4c8332347559f86b6d831fceb5df580a359b4bd85ccc7b7d52f9f8f7542d0d78cdab633fb9ec299afb8ef41aa4873b5e1a51ef4179937027dbd64603e05cdbf521a4d329dc61009e0df28d1bec7280fe4d178062b1fc2a91afdb3b939b4cc0f8c44b8636accad35fead30157c00a6625214e8c7891483f13b3d93ac997f5e82de60977b25edb3be7a48d8d04dc8381619b463d793ac32692eeb20847b2148026f5aed50ffc68e46c236659836bf560b36db8c7abc37fe555e7dc71842ed59a627ecabc4842a3ff5f53a1ff6f46dd4b5af4fbc57b247db6bd2d3b4edd27b6bde59c7d9e211e39af84ac4ca4b2ee2d6ec0b464a60272f29f31100f9e63406edef5f75e95f731ca96a255016502bf5e5e0a61533b357d64fd8290163010260949bc3bd5498e0f2d3080acf644039a6c4a0ab97eca76c7af35adb13e6a9b60ce247bdbd2128d142d48c46c4263ef9cc8665866e6c88d901c1b1f58b265f9c21d09429f329e8d6fabd2a580d441228ef5cbacff2cc759295aff82f5379ef94ae4a5aab60eedd776284d15ec3f5be1c7a2974802ba9117652993489ac1ba0e5b14eb8918905d92ae713747dfb9a98e031b1921e636a62e275ac88f739cbf680355e917be95c43a4cfeaa9f956807e6adab7bf2f52774e9251496a716c85f5ba920af17b16fe4018e0c8318789499b949e72f676c8e0593562bb1e521fb57b92575c5f337d3b67448dae5d299641e33141b31929d5137d0e98cf38bec2a7b351049fb8b507fad0325a0975561ec424e4144bbbc68540aa58e16b8de73512122be1957e0d3688c8fba1301f038f1d9cb7261ca6422b3623f12163b47f8b4b57105f6671f296c997f3e1bb3807b8f468aa01ed5307124d7976783eccbfc628ad90fc0d500e66114c0541ae13249db68c52ea4695b30f801aafa3ea56f8e9c98d0b34a3a52e16b84d77af482118375cdf58e9b40b15240669bcb73247551583e23e5551bb187f7e7985fec4cd99c0c14251c048a6f2fc771c9e02d7a30b044e3e93ea95329de6352a73f2c16df934bb336d8c7a03a57ad12f5dd73afec97f6cef2603c8a0919ba620983f30d7de835dcf44ae2d044a4ca4e2e6181c06f224f407d5cd3c47c9ea7b0a5abea0bb3ee695d2503037317b32e6021c641fe8ef52bb98017d6a8b387c48efb721a55788dd1dcdec4cc84f67664628eccbea6c672800efca02dc1d7be08874ae07070360eca881f3b4984f598343091b9821fe3dfe41b77ab0d77de4f090e965aa6b2a4dc58aaf7e2c167a1ec3779501a56faad0df9beb22827dfaef27af899fa92834fdc7c62d0e4dc8829f5891ef9076a92914502ba0efce79dc27ccf17a5824d79104c03831b98750533936bc8bb35a45d2411e8d9f05dabd1a2a5fb44c3288bee43562fb081bbdc50abb3d4b8845d8590392696c48ab905771405dd7522de0f4952057c6cb4fd2eb01638e2b23807ec965afe9164eb48a49ebef17d7f925271ebbd80b7c6a5ccc371f26f54e350746332ee20b9462e562288a31aa887149655a1a8b513e1df7cdd3f8c1246d4d46b2928fffe345f11e99b1ce788d7b6d7bf371106a68730e2289a4f8698a8a210e65d7a64329cb85e52eacd258465aa781bb2cc85546f70137eb55454008dc4db9451328fd05c91839937bcd677a4508fe7f47a69cabdb6f2c1c426b562a6a0165f90e2d2a0b33d3aa7ee3e1d18482d6b8e7d951503d6a886bc9813cdc3ee607ed50dca3ad6505fa4a7c2d0c43a1802321b8d833908b0c242d6da00bc7172ce0c614ebb5b040300b94977bd3773690302bfdaba28b205788653704c7d9d27eac1dc530ed38536743f2b7407b3e9bcbb4885c7845160bb44c4d0398fda1b4b0f46be04989833b0234aa05ab24122e9f28cf4e559b3de6f1744e6f0835a7495f87d4efe2163caa8ec5e8dc19c3c7b2bcfa5df812a30fe932ff181944dd72fcdc9a0f4f84652a4d239e5a62a25b77c8484cf596213deb9c2858c53c330368be5e7fe4902ce0fffeefde5d64f33ec34a818c6cf451de5881d8656ed9770ec1688d379217a159f557cb2de5b27cf16774e7a5c4982d108a2e700c9dacd8f7191c05204fc8b5cf958a71c51f67f08dab490bab7d5747868467ca5ee1ba7e9e2bfdad734b78c0ebf3009131faee114ba5b1f73f542e7c09bf76b9234a82bbb5d541540340b2e3faf19972cc7e9e943aacde48345de502f156ff92411a8f2d4367777cd0a8098b28897b8fccfc0f114b59416ccfd291c2f41b6fa07c8cc1eb72cee1d29315ff4e256bc194f8f0f676240e9b6a1fc3b0040425c0bc88e573f7c1362101f8f18c385062a9c2ef3740efd0e4c84756b85ca3fbec8a079c758e2a65a5a19d35ed49a3c8bc64a3299dc2ba74cbac37dc33c22eb9552deca94a7a8472739f3e1568b150966a40bfce72759b8f755c9997ca29576e3cd86767ba2d5b00b25773b96e99468acb51f3084f22d6e4375ba1ef1e7170f395cb872d284c13c0a5ac04b5cbd6fd55fe3dbae6c5ee327bc2d83dd5a2b37ed9d53b8d38eb4490eaf42f2da6ac5f3ee6213427064d9f3e3e69b31398efc52bf323853757cf3550f3a9ba5c9946a0647f380aaf9844a5b295361a1d581556d974710625c597eac5abe7f4862bca2c443a38d8a845476a391f14b55629db7c03d9059cfd835319caca2d74f95a1dffc766673895415646979d84422eac8b1fbdb06f9fd4225f68484a202e4b623abfca2890a0b948cd35f051fc69f8b9948872ab65b8393ba14a00c667f06988bb7d2ac217cfc93462816d7472c00a598a71a90809fe9cb9dcd2b425efae501101e06e977e7ce0331481d0b2e3ba4c4346456329ce2e318328c0713aa5a68d5311e2f475880ac68ac27c314a763610901d6ef86caaf86ddd362b3bd5b961ecf790cea50908e6598c9dcff93e1d88f1a0e17d1ca4a9779d90498f3a66f01f2e4904bc4778044c4959cfc84348f4516e0681ebb8b5affce703eea54be235f9548ce881a2059f9c03802515a4d7c140c1004a1e09acc64c3afaa227e30bdeefca0b5aac88be6f89f4aef916548f185a5278abfe41bb4a215348f96e8da5f5a4b4ce521814f99c8528a8bbe5a9d34ab4ba65d10a930df4200a0465c248ac19cb894dafece7ba3b1272a0f16d30b1a8e43920e3fe6d21a8b7588bca8e8a05c74dad725ca43b2bac34c668518215b852db7953e8047de4a8edcbbe7ac8918c1465bc86ba4f76fcf9c45a492c3ad8c6bfb0e3d79ae3ba64389d1b20ffbd6a9fb9ce8b1ab2cb5e42ac304537db34a5fc774e1f077d87c34cddc851282dad590e55bc8c8577a7cb89ee19f084ec678a292a4514df3cdaabd86688806fcace6d861fe06ab1f295a2470eb69285edc735032f0c3c8a9b7a571d4495fc475f4e8df271651953d1e24f85b1e6276e79f60f084970aed3bb2f959fee8200492e3f592114b49257a6f9a53293700363e588a85f36e129f401f366b9e70e18797f6b07827a44500de7e11af77d7fc4c6bec6846d6ce06d11f9fa91a82360522769c0c3eed68a2b92a3a34f86f243017d845cd525cb23a0d49d4bb2699cb3b077235dc598069d2ece46f4026fe5d387af1ccca6577da854daeff36096fd9c36bfb58446ec3cea45810a868ec2347a40a9fe192f22ea046c9ff0730c83fd2ae95d402a85fa53f324287786b585a2fe4e5b5364bd5921d292c8fdc04d13f84743f876844d6d7f22b1750720c1bcdbed1290fa1fd1bb3f72bf3b35f9b2fe9413a1fa4053c70b2d5f127bafc92bd9ea8b515cb3c27bec7c9278d389efc060686e5fe0bb2aca07408ebf6679de01de3772114372eb9237a612a27d168ce24d1a2eb6cac139f396a8b76d5cbefb0808c8a7f4c51a2a3131e4fc0ae75c741a5caf037619c1ebf1f8e817bb12fb434b52b36db34fc87cd4f96024794bf8ec22163d96ef42be42a928b4d6be6dc1b6c25f6c860c78b2c89cc6050e55a99784cd785ff8e41ca7da88f9f5edbee2d94df67c86f56930e9b682d9b3b42040e5213911c317b5f7d88bbc99c5bf8e20d263b5e70b698584d85df9acbd120395ec39574c630bace1703c5996e0e87c126486e7b4aae3a298c6127124aab23c1d5e3eed373a87d1c58ac46a5ed13866312db164cd43ef3230f9893fa228b5d7e2a082a00abf6a09f084333a8982249417a6d61b0d112d3cd05bbd5b933fc87292830ce004c9972b0d3bf81bb0054ce9ddbf8dfe901aafa2d5faaebefe3420a069496709e58a84f4de129acefcae0c4739ce8a50f59f830c6a6b480d6eb765b002f0d0a964a7b912ca4624cd2c17b48dfee505754a2c9ce087fe858a839aeb3c1a070c1c99d1477d4888a754bc3bfab592fb6773c64dc6bb587a67f2dc3fc4e2fdfee018076425b175b181fd7a6b1e13b7555044f49ca47f2a936050746e18b587d1dccda38550c3435250c8c9637a806e83dbe66141541c76e7c499f9b6c2f9a852f37bcc7a57999b4139ab87143c357bffa2540cf6db5c4cba301f40180f770ad537612565e71348ec3496f7e118e8bbb86b4d668ba02f480aa2d6e2bc0819cd683ca16e77125b5f3696b247b904131e3b848328f6a3feb37c216070fea82718100ce1333c91d0219840bf955ef1c68c6a2646698a301a1d5dac686f8dc0b36c4749e79f57ca6b0ab9ddf297b5132691d19a40da60d835652510ff143ad7bbfa706d6756a1b3889bb9f5416aa4f7c343a2357d2e5dff10ab5ce969253294801198bc49a786e7d54160d92050cc06a106f0faf747f074d1fd9fbf55d3d46ee2de215440bdd534787aac0e3fbc0b23adebbd147f1202395c072d12edab903bd9166a07e8504e7bdbc8a890ba0b1753c5ba2a605bf675d81edb32c4b1556808f10cd253350aa4e235c3b9e8195c7c39864ac9d7e12374da3fd88d49315c178bae2aae9ce24aaf1b07ae57a17cb51f4b661be6eb9a568c5d8a2f5895199a6183711450e0123d22ab26ab3b537a5c1b7ad8809441e363779ada140626a26befdbbdc02bf6b9434b03ea9f49723ba06f31797508b01222905be97119e004cbebc2b6c8d32f268b52735f01d62ef6f36188ccc9279d374058b0ee5b9c5541283b07474afd3912628b01049b04ddea52547d7b0d8d5441e3929e81f4753d284ef33cf5e7037d3745d3ddc6ece9e678695a160f21e0c58c32fadefee69782fd4194a63a8dfc4e97dcd03f5cb84090148ba18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
