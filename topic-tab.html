<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f7995ce958084604313f45957fc44580725eefba87ceaa947a02b33d10451984ef06e0d5ec96a45f82fb0ec4aa1f4e3e414440b690e526492eaf39c86afb7b926986d5eb43076ec17f5eeac53ea1d1bfa34bad37b2930cfae0758696e4184d1118fd1695d25b83b0d9ca3177c23802251f3e3bda2f61b6ed59b13a1ba1c83c4824302cc83908ac3f693cd0aae5faa4fedb3ae21de73bb31b2d10503b0c20e556b423c86a0d14884e03b5e8def1b965ea75ddc01cf999ab22e20237dba92e483c3b31ef03d4087f2a909b4554e586d9c112eb3b08d1b59fa178b7f69c8a6d8446a6310e1f8acfa01778bbd1af6b72c1c581729e4cb1b9a766eb0b52adec64849bc72933a54fddd21097dd9b4c49295daf04ab614fe6a3626e62d2129215e50d0c7bbbb803eda79695e8fccaa9c46915ba3d6c93d4ebae3015533dc1f619c4db069dd068a5f82d8363c6d347e8171e3e69a3e0fba157f7fa18e5da28b69e61f5b625fb5e42b7713d9c4f455cd4ffc7b6624f4f4f87ea85d48411da0827eeab400261823c79b3e1f5b40d2b6deab5df42decac0b51ea37ebcc888e4b02bdda06978ec8b87baa4cf160a1a246ad6431475727b6194376d5fb6f7bff21a7570efc354bb5c0144091449fa2c8ac55494b7a3b10d23a6a080fe549040844f16af2ba1f84d4f943ba5548175a8f6d5b9e4d123da22a1d42671f4fdf6b9e8e53617f1c408953d98d98ef8912b9fb734ec72c1576f7dd351e197324110f2f28101dd15ea51e49e2de62954b59550ca47a67d7ecbe48f8520d56699ab4a375fd057581ddc039354479aa333ada6105cb9b3a4b66517ca5825dcef729385710211e4b5a4a7ca2c4ed62975c063fed547db26f5d2e35b79a3ae65cba43ed37f2e43c886cfd438c87b3e4b384590dfd665b804ed6670e32e9986f432bdfcd1d30b8efae48a5983b9888b91c287dc10959ebcc8f73a09b86c94039629f9fa8ca5f403f8192a3bb155654c2f315a2152893a3e50bdc3a503acec7f070c41d6a56c670265c650300a07748183a45c56d16ec4ff636c35bf088c9192c7c2ba30ec3411d439979212f0ce2e99d2766f759b38865eb71f524e1e5c8ae9fe7175a8bf287d57ee3ac09eed67d4060c1a7e162049f3ecbf0ff962dc295021df156b325bf4a555b7132b9158370e81be042c98ffb29f30282b5e709507c3f17ac7079ab14f9b68045246f9202c3b769ccfb67f6920bab052b070ddba4bb393c278fbb83455ae5fae552dda0a2bfd748f55fefb8ee2f46f6a5d4dbc36bfe4f2b2ec1277d2b4b0c7da15450157a34ee7dfbacca088e3691ae11e9033d3c34abaed20df65f1cab16b545324058a3049f666c431a4f3d6a528c599a591bbe63a45890d63ceb2d3bcb4372049306cd97412009e4e3eb621cf0ade82ec2655971a53234d93890b45917f9dd7883774a5f60624216ff2fe061af3d526f591b3ae13c76b2f044cb016a3af59a77afa18b1d69cc05d1282f5341981fb542b9a30b4f5873f3bcd5ae886bf6c64208b1c82c12be46b9615f9d92baca194f9947782c374bb80e6dfe1614b2a603756e15184c4a16cca421d7c052f36efc97e19e2d199824fcacfc1259130d1346c84d754a3ccf07a984a29a90d147e7bf32427b7c32c90082124968d4a5ce954a04abce0d5fc64a5ccbe247bb3e25a92b8dbabf0ffb814f5b75715787a0a9585621bb14346839b40789b36d322ab89080699af559704f7bd346ac5dccdce563508afd4e93ddeac3d1be3837da07ba41c78c271a031ce6759f37b66e7c41c006bba487ff880604a7132c84ed937888d0e2e2560b157bf3e4a032006e58b114d1023e8407db6d6e586165634e446eef4493d87fb053e752c928db1d15edb62acca28523f93ca434d3ddccda9d12e23a9d4ba05273f712a3c9ad17c603bcfa7071862b0addeb55604c9d8fe556cd0a2651c7be3b4a1d5bf6477dfa7bfb3f922c4a1ab0f212a012c6627657c80b9a5c6fc2c9876bc6338da2dcd60a56dc6447c95f38f6b4247e990105a76ca61b1ea0a9170ced3c57ccb2ddb5f9dd80aa1f141747890c57e82886809035034450d2fd793ffbad396b37e85ab9543f58c9dff03c380ca218a84f11db279308fb2c6d5d9fcc274cf9f68fb086d776b03a874e919938b97c7d563eabf2b8627e9fa0130f0df92d6250da0e0e5c16f988e7a79e2aaeec1016e22b83e08e86b5430f62603a5f2d849e3273fa4d0b3a73aa1dc94dafa2a720f20ce9aa5511872f6ba980697a6cad037f524c010f431274a46aa213b58a0d2697a983489ac9e6a8e3a624c6442e765449b105269ce69b245682473948da199a3d4ea962434f5fb0548e7b09dbfcd42ffc3cf929ed3a69851e1e292c82db793a0d0df8d05f060a94c25d497781bf4e8c4e68c5e3d3949ac0c7a20353bcd8232576241c1586a8e34dd2841a472fd76c7669cb6f20dc7ef9432d9b07c1b621964d9192d462c041a817067756cca2eb3269e6bb5514ded7dda81b944782d9fcee09f20464efeb2ab4cd389c20824228e9e51584a898c4058b749c179a53de5bd6e4eb35aee8ea907f509294ca7a19ce6fa29b48a5cf14098c8e416369465b3105aa2d4eb56cf877c2eecd9e9f7bea6c3f7711dadcf24616e7fb2aa1c77a6cf94ae6c61ab005d4b540975a22cdb5ca51cfe7daae2cb1466c950c61cb37f52c307ad0f228eee45fa297da1df8f14135bc19bc05c7eff214af79d00986872c6aeeaf90017e44508c1dd8a7af55557ed2126c1172ea10616ca1a545c1d88a7843c532652f8340e2034a0b3289f4f8301d1ad5eced1ecd07c3eef479a3f6431879fc2a1147b3117e3abc82a50457d39ef58c907be2a46a49e0e67addf593ddc49fe96b41adc63ef2a25e786b4dc0ac5884680a96dbc8c0d553861f3a862bf1fb05d6830e6c68a0edce7bf5f265908abed39a53d18bc83da5912de776cb25b1c7a7581e962409ef3b0f8415917b5bacd5de01b4b256a21cc5844f30fbedeee01df1d440bf1538574e553a1e4e0059b2b58db8966c8d4be92917c2937f8a132b2e4351521e1f0a9ac657932f87d60e34624c78ae1ab3b86e76b838a9d2551147fefc22d645bd1a55711dce833e1c707d9473a1ee1a9ee9ad3665a19bff0c484000d1ee63c58abe8d2e60271b7520ec5de7299b17d85cac97a49cf67999949f97566bbf2ce7fb28f25c3afe727790c36cc8fbf55aa93ebde3f462b016d6a6002d027fc40f88de96fe35b96ba2961814c1cc5f6f3f43045a0a043b49e2bf14fa7fb00348b09cf717188bcc03b8d35a16f8e33cea2846c1d9566845e05ceb6bae97b75831555355e017f47e81235a138eb223cfd02bc69b92caa797ca8b448d3aa8647920b6447060f99d8a9c447e3d58da4200a0bb94d0d3cedef0d918c7a15ee7072b11e0c949e9edb105fc2c1a1529d9fdfadd860735ac28ac6be88780180894294038c527c386403b1a44b71f868d60abcfa898d789dc32855c847fc9d4c7e736e14e89fc59e9a0c787cacf4f5e3207b501e9af7dc5c0808d429ab9ef64834f347638718f0f77e1a5367e1d855a1753c8824f0a54f77ea8540bd3b7940061826b763353e327b35e1305159edbe16640adc150f15e5ffc009c634d85ad7658677752de91793c1d7df1304450f6eacc574c4dc97c78598e01ba0c5b6247dbb18857ad65471b02890d7e8c55e891e0cf366b044e34551f6f7250dfb779fc2b39de32d1642017590b0b9eaeb0156df3d9787774086d811898f9908cb3e90efe8d0e64693e5a24401b5a00b95248a1becad902a22974b911bfe079d740d2c050dedefd4be258d1573b5f3c23066e54acb2c49900008983663a6d2a877afd66055ab55a269dd384992f3028041c967753e32e5644d6d9a7366c4ca492790ac7d5ddeecad20a66bbb01e0b8f47d3d656ea3bac4202d51805f04740bbbd00acf8cf44900d6d6438baa84e470cb0f2b4e1734f892e182b55e596b2575be26d7739c78f2a33322223018b8a1e0758c7944ebf61a0446eedca3cacc9a84cec567fe70cb46284ea7dbf339a116a41b3dda185cfe58281b4d9de5f185c06799a67b99859444ede6fe8abb0ca90c4a280251da32cd2494858aff144d688dbbc24c80e3f9ccb57ee2bcf0716231da527db9c6cd11f90f160592607b6d1f59f992df88f4ee6c077d9e91b72d5f57b579c3ebf7df4e0b7accf26413566b5cc4b1926f4c058c7ea1dfc4ef78e8306e4323d75ab7b4c8e43211d012d70a8a70d5650b683db2a99b178e86abc982db542e852f5df7cbb36825b2db33062362ecaa5dcde9b3240c5cb86ed150274f4619be2465c13ba98a0b17b9f68666623bcea17868f88c2de7b810b95fc8dcd44bbbee04959ab4deb5b551a5cf6f5177d093e054f3dc83104bd78dc3985f2ebee822a07314babf6d291682d2b2ba5f6536ab27669d2fc37c8ac17e07c2180b924117504e411af561c7a339d5934fc90448be8a911980df050c72da396f74d4559debe6e1e160974c5b17deb25d1d458ef5fd896c227429c06dbbbf1b4d74410e909dda47425cab07a9741ea51ca77362db87a37aba9391d6b9201fd9bba7fc0111d862c4c920b741a3ae44fe02cf52ec68f15f4f457133a18a8906dbea3f2434b9ab44122ae1eebba7c01d80b2cf4ca20d4e259e715fd5f7feb71b21f38c0513deb71a90e1e571ce8108726c6f18144ec66584268c1991f9a13420ed259e9cf7dd4cac90b86739f087dd673a0c1f227edb08a23147c00d36f26c51c78ddc5c53c4ee59fe7ce10f4401faf4de84cc7496cb63774880d59f696b4d0bb809c9f19a0d600ef8fd4b8dae11da12c13169415636e597f227908916932412ddb23fd065c5447161baae80147bbe2b78dac7094dc33855d0cdd623c5ba7500f81cba476be1edbeb6864c43ea602377b7b76b119365b5f2bd71c832c47314de2ac56d23bbd00fd09613b2125caa425d66ff26b6eb50aae564ba50503ce1969d273ff76693baa5b68eea6caed80d291f7b4d14f16ed3eff8af101a3a95da324d834e562030412c50f8a991bfd7bee6e3471228c513e05238a1c31b37970c3eb7306d2ce2882a6ed087b6742034803f62e6280f559908e510bd30c26beac55d47b3884508c0904316195063f25a38f0fd198a93b5623204032a6a30c3b56e46ba74921ac6a71a80de2485703817ed5431655018a0b5144748eab8de5555352784c486e62c96bad2e9740cc5e273110777e0c0f9cfa57c7f6b9ab3a243690fdc14f65b2f2b4d33a8d8c0ac9411e5c6f93fc41b1a2bff5269bed23dc4f4d2f2eaf541d710286c3ea2394c8ee978fed3fc2650520a95d8396fc4a56306e9cf99db303796c3e101dfe172b973ec0ad5baf668074a2e1215f3e38287fb40e3775917adaf068917c256e70af2da9692ea9b6db5ca5ccdc9b6e7a8626033898e6d0c7ec38b1bb1505c7c4c2734624c1600f0549fdd73f5bf67e947b2edb05e53affff36507e9a636cf5b49976593869b92161c8507d64bdb638aa74fd91d7d3c887a87bed75d0cbe99dcb3ce3df82aa2cb1883e4c8dc23c50be1f657e8721ba2d1cf1fd3ef6ef408341249a3d6c1d3b73fe5f4c5baeb8ad3a321d934498c4b4e333b1558c3ac19802f4fe7faeacc71973f7a1fbb7b65c97bfa4cd21ce02c1e5a4dafec56b2a64a084a5facefd4d5032719eea11d13454a56da09eb657dae11bf574ec7c54c1f6bcb7a7a97f6b975575625d0a902200eb8e9ef5c5b0053fccec40500ff15a88df8d500db1c76415566a48bbe4c0ab390b946effee7e1e758f3bcc3585623d6b67e17496b05ac8a8e3e78d385df6dd571ff2b07bcdd6543fea65acf0734984f1acfc0aa3895864445c8a2dea0343a91cd7ad830e5f30269550541f4a84e88d20cf9435498e2c485dddece9b186dca267af5118a6e09fe2d8ffdc1284712b6099f03ed8b19733c8c182594e7f53934db43cef49c4c2ba8a8b5cafdfe01c9af098b54a69d3a25f7777d7a7d8ad6db0ec4e72284fa8b0372d1fe5bd3e8caa9daec76e537e561e78f5d9a0f3b21b7b8d382e1c9d25b2783db3d52630fe1954ad5f9c05a68984a03bae2ab0e69e479d56714cb7a16cf70a6f08d2cca0444c7d8f8de5e8377775dd6c6d0570ee3291865941b74e6e3541fd304c4c91ba2882fa735b51cf22e56de5fefdddd2e9ae52f56fff2cc6f18186209d299d19030b04f8e1eb23bd6c4bc67eff8db45b63ae493d553d51e30446c1c3ee654db63c743c29577f61f3ce6a89e01e7197843a56f6694d9d021f32fff5271cb9bcff650d6f6ee9b6b3517e2fc966697e45bfe60ef1bd6cb78a0d894b08b909fb51dd2e636d80907fa5a8b2a987adfeddba71d5ffa5d9e6898578057229193583f779e804a34f6e50586ea51db6ad5a5f3ce2f0c29518373ab995704941011e193f5d876d22d866199aaeb594c21410bd8ec3f624065e21e3768e10eb1c622c56620214f1578d3c3e0ff8c146941d7e1f9aa89a499d23f25cb834ad4373371fdb05a19823b59fb0933a4960c02c4949a7dac08693fa6c079d66ded9bf931485b5a5e87d0f6d7a9c11986a1d1f011f963625f722f60550f1fcd40ffe414882674aeed0bb2a8f122c69033303cab8cb1555c2661b0b384f84428c85ef754f8c01a009d37c183c86ff8b7fadda78f0e2c6dae678ef63f90e48a104fda41149d4a744051199db51c6b335d720299a7c24f617f9982cbb6e4d2a6a8d7135a404b19e1fb7fbfc8f4675fd5512eb2d162f4c6e7dd8e217c7fc75330540692715bcadacb8bd1d2d20a216e81d6e0cdd0862156311912c99d0de60b0f47409567099a286fae2558685b9cf7cac982df890a48387c3afbc5a55b4fc4917c2657a5f729187191a66cabaa138e0cfc1587c0a1b4ab859a0a0285581b0ba16ea7a85fc5edcec3d099e7a988095b302203a344af32f5c60d4e6f33f9ed5cc2a78c8945a6c9e78d6a0d38fb246d985c9506ad5e0be999cc9cba8c939dd8d4200ddbb1c17b3339b4026f8d687e730a7f2ec7b92c595b1b2934ce5558fb974834241fc69572e0ddbd1b7dfba8405c438ec08ad291624a3d9ed79ca9bd7e400116af481b29e57bfbbc24410d4557c3263c8ece9726111e59a2f2837954317144941bde4fa789e2dd971c042a7801f975b56682882d4766f9d109664a23e06aa261743802861be964bb33b544df28a11f2f96adc3a8cfeb52a5d97329bebfd32029064bc4d5c378bfe36ff6e2c44a67f3870d1c1b2976792b157c84cf376875fd913406f98f3cf8e4a03139fb46c487f04dd8ecfb178cb8ef8fdc6033104a29cb1518a3461d5051f75ea10abc8cb443784a0479a68bd47dc07a2239234072d740ad398cd6bf86efb40a1067f7e9b9c1af30f319da46c83b0bd042bd547294fec73d5b918aa70baeb047d98cebbd8de18204c8cab1896a56a52d2dcdad44a4a4be976eb12a0b5d690cef6a406e2a4c01f7f46c05f300f1983fbce6fd11b1ed0102cccfb8d9121e727c771777d3d23e42dfc02dae2615d8afec63750fd4fffb634a69029b8a76c16d93d2012e63b853367539ff51b2baea34ced2e2b5a20d95fb17864475998ef7b0aa5d7c4927d6ed3dbd095da39674b521ed176485dc15d607dc0382319efb7d3062e9d8c3bac6f164f768b36b9af3321b2e27c6c714bc4f94ed7d624924a0db024ec95fac8e9ef87e769c11521e0812d041081fb0c0736000066ee561fa0f2a365d0e1a1715cbbbb8b85534fc13efb38575cf735a3dcc9ab46ad8dfc4093132c6a1d9bf5d4699d751c1319e9cf25aa2f5ced8f5d56673c375d346fd6c27e07d64f043bc157da4a4a02fbd16ef811430c4aa05f24edffb0f1bcf5234980839515597604b7d75ce411b9f12c30ad381f97307ec5ed646c936044ff61285f3953b0ef89b75fd012b066199d8372dae127298612b73fb2dbab037e6c473f49db9c5d3bbe6af398435a8c5a45f4e0502b686e19cb42344cd8f66aae00546ec4bf9b0329ed0565d0fd67b3db996c412a18f99d9fb3cabd85c47e8a4774d93d309c3ac2c5edd8598c1ddbe2e816ac869c23040129d85c73815b9119a6cf39dda438f0ba7a9a9fcd3830214ad93e0ca01cc0c1c52cba4bfc07ea718c415032cde7b00583251d66730ca004db3e4cca16f47dc0dd54112a9478d08568f9df27d573d1fa4b7854a3006d6c30e942668a3517bfffd10b2cdfa62ff1e258eca8fa8deabd0ee2aa2da3b8a6f9e40703c2f088b9e8ce17f746b044287e55e0b18b67662d097ea5a30a357c64a56d86e963d9e3dda69156701271774bb110cc7b0ea39e996f60fd19b9166a11f2163d00c1316e21f0239e2df26b2ec444e122ee47bbdba93526a20834ebc12572e5bb0071657c51d122f28949e6ea5912ebfd753faebf4131027caaa670536f9f6a380dfd077c44e771be76587d0d840931a2297f6577193da63c5c45ed7e7fd6b3d482c2dd35290c991c9d435e77162d52cacc1126bb945b19c2f3b078c9f942ea34613f4f932953f0342c8dee0ab48edad78bf8ba1548d72c54739c3a7018b6a4f3402badde9de9663f362f0ff09c968a43ca7c73f77df877427e8ed08d09fc29251fa389e025028b45dae08e2a0d01d4c9f1fc5ceb3f02caedb1e7129bac27ea3af567410fa77f98d851080ebcf74af748e827b3cd2e2caae548577ad520b355c89e9d5c94e4a8d25d43edc27926101ca3bdf4744b888ed5d7765dfba8de50a9ece3bb55eea989e47669d313a8b5e8c58ac6c1eac7a0ac85b4d295df527355fba108b020ea3a25abe03418e927f23b6363fa04fd23c5a113e39f699667a3116e551620636a38f37997b2158ad1734ad35bd718fbb8ba7fa225364723413f14dfb18148bdd9859e7590e712c3c07f847a674b6b29d368ba474fb42d5f6228cc8a406ab92ee6d7e6c7afc247b1eb4e30280ab5da832f00ad6c482bd1a4d3d3878d3417e1c9f906a28e59e8c30b32edd5800dbe8a6425d9cbe1f682d9e8adac8dcdbfdb24f227df038f4f28a1496d8fa1d6dbac74598f61546c08d08ce5f2741e93d0da26c957c7b52c7378dd7a7ec3d867bdc59743dd10682fe0f22d96ef2b2109f0e0a1ed399f76a5ccf7df9f1e2c6ca22fb4172541b6ca2a5f04bbf30d24802d1266029f5bfd5151c8aba5752235712e07251f1b274bbe38338e6e1955cee1d7850c7936591ab09a98c27e5723f7d70721560bf234666be0ac2df67da639eaa90c3cd9097dfd26af8b18f7986735bec4fd3ed580332cd023c5b01105f1302faa207172d1cf0f42e28c9ad9b92336b21fd7e9caa78cb4aea6b0c638aefce86c4f94cec2f51609f4a07ac5194a470e0c015c938d92317d11da4598c8093a12b4a0110a988da50ac6977417c07d86945d97c695aae3cde3122fa4106f534d58b4080fe41504b8fb4996371cbe3fddb031099245eaf7136b95b4095c4f96d00b9479eff7fa0687af947c3998bdc691e9be62e5e780e07b22058dfdf6bd0cd4fc40f561bd2841cfd7d0dbed26247878758b5d91d474876354e62c598c6230a8e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
