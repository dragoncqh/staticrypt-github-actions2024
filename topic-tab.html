<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d53918c47900b1ba25c67f2e78679198a9ab1f6451405d69d5d3382df5280f53e275fb8b99e984724a8006a17a969dda2e9ae1112969897a150fa39ff32961da145bde952345d90e6e483d5f663e6999f0c14668b75c5bb01e7fe26d66f0a41b177d0da582b42e4a36e43ea2bcb125d0648b3f4cae87b6cbe012245c8b77cc4e4056f77c5fabf4a054f1268c0a2cb0bd1a87bfdc6ee1bc37356aae2e2bbd1ed9ae82852b8a7dbbe11fa9d77d7bdd7e2e07818681339f5ba0374ce8ec9ff04e1f3fd5a78e3878a9ca26ae0b125c60e3c3c6848f4811aadde2967955afce2b9a55be4f0c24fc849e19cca929f7f74b89ddadd5944512a16b82fab36913788fbb4a903135f4f25b8578cc7f1fdbe5439d00a922e0c5b614463b5207d4ea7b5cd7b12a59bee6d184dce399082601799ca0a65bd12478eb03a534e3fcb71d2e824833a0ba49330fedb696e0d082f791e6eec937c6dca40eedebcf39534a4706e3c59e7b577828b37ae1c2a7a4e65329d1aeaa3bc9104bfecd7638c516f72edee9d0ae5e55c3b6851f4b5a84305188935d45576605a76fa1ec35792d5e3d2b58c58ae266b17d1b1a936f2e5b77c8ed27130765b78b3afff46f4f4ed978f4541da33299795c604ab414e5913e9316167644e319aa37905599131617f34c686717913a8ed1bf1977a2477e3c51d44215edfadc62947b6148f8326b4e99b2c0d8dc7194568f906763f7a221d8bd1ef0c16cd09d5c4720aa3be3e6640b2cd933693f6ddc0aea7592df07dbd9a58a0cd99a74628137f4fcc4d6fb43ac2d4b1b481767557ad91527c6f126e258de58db1a0bd9fb7ba3b6c536508dcd5791f21340725e548183ed54e409a9630753674cee31f05c61913f22bd36541570c2ae83dd1469e48cf9b22ae56710f7f69ba027ae7c4679ca6d7cc941bd859f547036edf150bb58b558af66c7f5ef01017ef4f4d088e8f354eceb5a0078f02d6f891b3efc8c88259aca87053b665201ad9945ab18c5678f628ef6d58fe04f351792bd20915824d7c2287dd60e41a2e9e4b00ba6349c42bf7dec99a321aa9151126cd5549b3f6dbfe988c08bb98401cf85f58d5074a55de84590ef178d7a425ee965ef910c4717837683df3cfc5e1b8a3da0e1e73298c5c88a78dcbee48a40aea4128872ae728649415c571f211668148a47bb109349cb29eeb389d0ae88721b01e7f6021ed3095965bcd584be5a262fe2fa0757e07e754396a17ccdd4b74101a1afc7a20f6d44b677a38d3939dd503de79c0c4f52c80dd1ebdaa04f3462670569608853c9fbf7d491b734bfe63577f3f42ba9b6b9522d6a936128fa942f42982a5e7c8cd75301d34f5ac36633aac37243bc353a6a668c6a7a2708ea4afc914f6cee0dd81376d7e229ddddffa5af67429c214f46cc5f3aa132a20486b7c7635f2871bd81b4a47f38f3747f85db0ce889493dfa97ed9197fdd55d8f37b90f33c765413de5c5daf51f2dc857fa9f935516cc50c3c00e8e2f7e6d0c1dbf671ea6a6e3957f3f3affb155a49f9b3e4d31055f7e7cc653f61a9ba4b2162974e48cbaf800b42a8eede9a7e34927c7d6aaee155b61b050aa2d2bcddf3ce47ed7964f078a2e948c0cfaf624b526506f225a2fc5793034a1c8c5a5e8a80468f6ca819b20d6cec8d14dd7d9d514b76b7631ec07b4a32f2d18cb6437ea6f70cff39a02d9e2fd824d50e4ecf995fcae7713055cfd4cda8e05776fcb90a3e11472549f8302e8d1fdeaf4f959d48947462fc663ed5e15f5dd545c58a37fc875cf63e32b41f7384beb9b0f97919678b172c573030f17ade49fdf17c11c9fda452ab9fb3cc641321f29cffb5edc1f260bd6c8ec2db6c0cf40dc5460f4f04bdb380093eb040becfb62525b48fd7b2a9d9b9c246de186b24812805c6bccb3426de45f351a09321bb1fbc04efa6ade2a801a7da5fc33904942f8f4fad81fece9ff8563b07961854e69f57fdb0fc1416141da237b69488e56ce29d2730c80e69354397a987aa07fdae2c2d2a57552aed4141318ad0f82ca8cdea3f39feffb3a644085cc601350ec74aed1146fdd14e0c2ccf5668be6144aa16268cf6f4293ee42112ff46e221c9afdfb6936d800f18bb22ff7a14ff694bc1b539ab28d1544cb0bff4701fb039a1859a2323e89b7f3ffd9d9c3e2f1a90e582f304c411c7471d3a0eb0bcdd95fce567666aa53f8d6725db7a1b31d5c081bfa80e16f277915b0f0554dbbb2e7ba6c5cbaae45fcd4629b34a5239857059710b15e86230d10dc65805c71d3c9019ec081c47cefe3c253ff4006aa1196d1e28ef73f35474dccd90602f8a77fe4b400923343e94543c66327916ac3cd9da1ca22236409b11e4bf6c4a68b4d8dcbb919d077dc86f75ec54b1c38517e0e3302e6ff11d4c3bf138d73a95183d3489d0e6cc5aacf412c4e90ed4bec0df01d6d44af083e9334c1327e3527cada617d275988608e64cac3bad91a97929090d050f89f54fbe5a12511d863c7955bee47aecaac61c071e60b6b487b363bc3951d4d4cb6f1a1fdebeccb0ad6a8564adba77e7c4f4d0a3cd73dfdfb8fd263c745f09d45acb103db5ae570b3906ed9e778d618f3c37e3370ef3e8938fd93d20c4f7a72f425ba867c6a6e7c0ea2a7019f5de7e301a5061de8050361616992515f752bd392b9587ef75333ebc7fb11ff8ec6b02460852cb1d4f87740d1317e0675f63b7de81a71d129ed65853c7906f090564991e04d687e15d9544a2e33a2e93aa9dd056b5adbe4701a3d44bd40a75469ac51c2997775bc753b86c279efc1dfa0921b379700bcc3579b61be80136b07637f5feff1020f3ae0a7e5bb7b9c33abcc893c090afd12d539f5b2b3e9286344efcbaf5dddb3aa5431ff128e236a3eb6078b6d3decaba63fe3d054933109c65fc3e3fe3ef7ae42a758c70c1831f20252f5e7eb91fd3d713c6b5bf89618d6b897cbd5b191a199f8777f527a200f546ff02b56f1f64032c9c4e6fd3cff9bfcf0500462542e79f5b9ad56ef7f89f3c4ff705fa7973969ed50fe44f9aba824c333243ad4bb3f9d796f48b23d9d4c147a3d1703052116635d2227556c3a34933ff1a96539c64a114a421c03b4cb54e6da2a692cc313557c28a018544894c7d0b8d17d41f7963977edb1081029cb15151aa592d2b9d0b621649a8b83f964f80880659f430250abfab45dc780173ac2be86203064f1f2100e6ff1db531e093d829f984a718fc7d35da960e20cabbe34522429dc382f50e59442a86874cc977ebddec41de4181ba595101ca39d37021111c0977fa26aca25f498e96abd4ab0fadaec16eacfe1b779faec0b479a2a035fd4e6c003f01183d01f0a893e4f2fc0fb166880e55a90758d30cd68fbbbab2ffd51840ce935e86016ae5cf20b0079b9b9a25d3507b36ba4a61b1642e8ade21f2494b1184ba9f96297b7bce5529fbb5f121a9845604adcdffb912ad02f665c6576e5d45dabee446e95aa36b85edc0c563d5876934e53bd6f1e43eb46ec06035cf2a1a8bd6335877bb8374b8705d7945c22e84298905105a80ceac8bac7170f5efc774a85912d51d5292b41bb5e206860da46d6c0439d5b3790a3f07703b28c12ff7345330dafb6995eb80f9443d498cdb0542f2f641da25f826f9e0cfbb545219a3f8e92082a6c21f20dde6769704633b63b9969ea1a456054363ab3188bcb3665529ebad98a2baeb942e7d4cc11dfa0e544cab1b5b473e0ba12c1b21a34cb4c57d50fd96ec1418d4400340fc6266231743aac85caaa8706f04dc4da94bae4353d2ba70d365dfb7862539dffa66b606494c81cf4b85ae7caf70c95c4927365bb0d8a6ca76ef07f1a55e2d6c6316f69b82aaf21d561b73962ad3364f1359993a2656887b16998b98c47c59a282720304f84090a9398593a7cef63f9d56a1fc01db9238bf69b94eedc3854d3be67f6af9e3b58e97d7e42274c4b2f6037b861dd04ad0d97f53c513784da2e61b4a069d40175ce4c15060b29b0770cde39d92914a309c38947c90b30915c1e5edecfe1cb62bebee7f5f561b97e3e7b073fe377b7ad0266699461ed65cafe9a2e9f6df27d168f5499551db02a4871b54fb3aac772490c41bece2934170ccadf12f7f528258ec616c7b915e60f3b2c20dd528c39d8c2298bbbcf95ff6683f9a84cb356ceded12a2c6ab276a55763e8b48897557748893f559f04396f504182669b0e20263598e5166265f530a1bd1012cdbcc5d270ed2ad1a3f75f949609b9f36012fea980f673a7b73ea6b4144b0f2cb4b6c764a7fafca58cc3bf002fbc73ad282c4af9bb9e7cdf4be0fadce4efdcdd3bdad57050c2830259423cd567f2591be355b0c9bcd4e88e9b15a53430f976a9bff0c41b534f7ff173687339c9aa667076ea636f52eb0116d62e733717fa0fbcfbed828ab510a5f76400c170c07445d65cde6fe225e466601c4eb2fcf4ca53f66639fccacb79b6ce4ae34db25654612bdbedffaa8e3836f29d80ca8a28b0afe63240bac835614b871b8d2764893cabe321b819954766fec056b1eeb6285bdf92b824e72d7117e8eabc0a6d5f2b8821272774c861b8a9eb6bda26c1381e4671fcf933a3a2115c45e9fe515bb7d1dd390e4519b9eb5774a211c5097b5995ceafee5c5ddb69676564accce50fdb3909652ed5dc5ea08ff6367489bef613692edd3b71fe0a1f0b77919cb8987367d0ab40dfcc226ca7cdd7934444e7098d5e751749d81aba1a27a179309db11309b750005e8d12379a2619deeb65af7a6c9a1b17f97f737dcf0bb5a9046ae92070cb6f9776e7a16c45e8130136c1d95c78476ddeb45cc4160c64c7172e7c725d9afeb1e63e6fb3cdd780741c0b69762085097bcc370b88a23054dc0be4e2a34e31dc1736e02647f65ce46b5da8c489695efa4eabb4c8812a380fc7db47f454bf598e782e9b3a09fe1fa59e80d93e5ed122d293c5dfb5a30003b2c2c96843fb8df1c97e908b70903f287537b87566e3f369478a563d82e5f3364ed08efc83ec1079c573e72d0a8f8c3d1b729f1297f801dc1b14477a2877ae8cc910db9793a1aef417803e413934c3407775bc5d45b01197f516c13fbde6c776f9c15f300947a0981a544eb8347fa3e02527e3ed1c7c98f5a16279c596e653d8a4e242925ad82257991c9e74a7c468d8830f20d320b4763fc3cfd79021d9886755ad9c37c56109e968ebf24c79e0eb75cfc8478c7a86b32e00edb5f7af892c4cec43dc8c64803716e6a1d03a10b02c288cf1b48cad39342a9334ab9b833619da0f5984c708d3fd355fb70c932269cdee6775741e5d8a6ea9097219c9c926ac37ee54b4d3b91fe4c59c47ef0ebb311d8717ffade671457d26c648715be920300115251c265e6ace2a5b5eae33b483e9fa2cdf4fe5fe3e67c4958bd429907b2d72121b0da5e731a5f080727d8eadb41fe3a5ff7e68d9b293e1387b4d5e5e94c80191b70462aa693d17387dd5b5a6c27a31dec6c66c39f02d07959e4ccbf54763dd8c2033ebdb4b23e47009901b484622f4ee177a1f9772cd6f3bb306025fb1e2285b384a2e297686169b5bfb2ba6596db08e1b27afea4c3808674ca4fdce0a21cc81d299a81a86af4d6cdd14d8574029baea81293cbc09d6e293a7445aca7b8405c5eb43b789a38ef93d89c4b291b5c564c3642013673bdd72a72b16e22f7838cbef14bfd92b157d48649b0863fff85a209208e422e78e8f2e0a3ccc24b80c7c84a0c52a3d0eed0e3e0c7a2901885f49c190e46e3e7331bcbd99eb41679642307e9c5aec3eb11eda67bf0ca72a6cc39640014798cb976c7c621690894de7881a8ee2130302fba5137d35f458972154d1427125c2b517575a1fae1cf564888275369046cbe84671b4e78e65745937614e84f60f857ea94e4a8c98f16ba02a956f18a24e54c4733f4b4cdc58d4a636b35a6f38f828b8cb14dd402113436a94d84129255c38c2dafc3721141a0036d261803b0bd4bb81613593d0710084a3f43ac228c067acfa0428a9190c1228ca402042cf4a9818ceab89b9f8078323aaf90e3533ecfdca7e743280985f6e7bcb477cd99001a0acdd35fc2b163642e0ae191157cdd4dd570a8a28b2a491691067a768f397cfd71969210192b903cf2289ef4f562c9813d302da450b196e16d403e93a63d717c39d7c7fa959ffef5d3423c776b4d74c85cc8031c3a16dcdf515dea35bf711631280b634d0d12c7b840ff264ee196e449965167dc2fc800976d3a3359619b97f0e71107de25e497c712dbb5a1ef1c4fda81299c97303ef46ed5b6e56524f9f1be4dfd1752da4780b16d0ec81ae886e11d6e04d53e4aee153b526a3d2eed1da20c990be19db0558cf0b38772166b102231776022437387554fc4bbbae56d4d9ab7edb046e255125284474fa00547d4e9d8039c9f2a4952027bc79ccf29f3cb7b98caa835bc2ff9f297b9bd30f412449cff8ec07248fc02c12160d61ff3f9d450431aabab61fe440e89882283ac468981371de8a2b0fe774acc233fb6215363c841b7f74a1ea2017e22b1908965ea84d5ef7d586bdb31bd94a6cc2d0e59a139ba174d100845c0b0bcb289a759e61b76019771ce99b477a6c20a31d74df58e4269b3ef7f701ec1566d8d81e5bbe158051e3a08e771f2253ed03b34920e66fb8de57b3e1f25acb4870b6cc54f8b448fc90593caff2625599d87379da289b63c121bf07d3c9acb09db5cd25cb37ca8430c1a724e7afeba02d0d53fa3b09f703d7e18e91d5ce2cf0401d45ad2d811dee2b5fa974e54bef9ad89a9ca17b5dcbd74dd92e66bfe01294451efcafa108eb3d36bff2738eee06566d32b61a98e9af5675aaf315368e83b0240fca1bbdbded2657f5d4ca7ba8d486473fc3d2925c7fe98ee747727a749ded170676b6137f7fb16f2515edb07f3ad6ce6f36fc93e307a81ef9ea5acf76d4fdf93718040052a3d00aa4431b5e3c83b40884cd6c1fcb71a02b187960449fc6e685425f2eb285c6827c9ceb17e82e928fd59d224a62f104cfaadae1c998fc072a95d343ad778b3513bb741bb06ad33ade6bd4504c8f7ab56996f0fed5f5c91c5ae9d9157d208db08cd8ee3c9bf02c81d297fc1354ae1116d8e7ff8a8b16156d8492ef47dc2a7b37816341c889581f8b6ce1f70f0963b08352a4bd5b0aeee2d6bed987d3fe8e5c4ff3e25d15cc06c088549d0a8f99bf2af02c35f0a0208f12ec8470e0682e9b242027164b40401e57886f71c888f358e3fa5d84dbd536424e6c5c3723c082d4e8a5e65534155c5b1feaa67b8d984dadec86d2c4eab3ed3cbc3be5d7e6077ee76b0a1f1da5e8690a8e307c1f7afb4634108ab58163aa73c918c8001490e7d904cc6186d23bfcb1ea28e38bcc38506f88abf5d824d42be4845f4d22508927ec802cb4a798c66f783385163fdd752d342578386eb7ee80815911c9fe027e5e7f263547b9d847e9caec98238ea77a9febe344e63829a5319d1bf0b51032bf424671f677026025e0f7d7f15ab071d12061a08a0e19283bb68961e9de5f3fad646d5c6f35c2cf6a17f64d6324ac6adbe545805f310ad75e9bf89885a6dc5d2ff64dfc668f24e717d01165fa95826ddc8cb7f6f0383a73aac44fb4cb81f424905cfba2442ae8858f9738c97d4779b9c018754322226d1d7ddf30e9cdcd3f22023e13c61e4cf1fdcfda8d8f0b3ef0d990d89e6b4cfb6e9a08c3dd843bd5b05172b75d52e20ce891acf8b165e1502aeb8ff4d64e7c170d5cad4cf77ec5fc9aa6941e54e5873faf8e80a580f64f47c4c450318eb71700b03ec7bd7af282e363b01b5d9c41eaf8a0fedd16f596741a81c59f295ae4ab91f7751e6a4d86c64e1d2d0cc26d98b7b4feb396979aa36c69c40cad9b16d5c4eb38d4ab98de7cb3a95abc52c52abcb21bfb87872c70fcbdf43adc97013187f6750e3ec76d5a6ae72f2412a0c45b52cd22bce289c4324e7ce1dcb71d6a4ded78c7d0c31edc4ac479b8b5383833994295952042296d7c9dc9ce607d4335aa079336abe8550b6bf35a369bf02bb810c8f66eff7b5e913aa5534cb751db2466c565a863cbeb8131781d2e3f7b937461decb8a77f9e3179d757e845cd10bb819f64c99336aad1a6f2b4e6d3ab45d6dc2bcc99448fc8ea1b97c925b193736971f4a3d37c456ed6ff0261481700b278349a6892e422554ab53595f89a1d77ae8d9ed4732d44780f226f885700ac10bc16efdc8a421f773d494a6b0953840253e1c1d2204aaf2f997b5d35faf34e62cb6f904ebb3cb5b45638771d2be38e1b7bd10c81352acc6bd09d7cda737f8e133c255fc48fe8c36f6596a6185a3dfacfca7d6e929fb892289048be6b5432bc0b3969e23aa4b1f36af63d8b3a13728e85cb3d5eb34383d9e7c9032821182fec4aeab38f39183b908d53dbd6fe88e33373b88521bf7f019d8a7110bf991d7402251a68feca217f310164202a300bc971383a557ab4e17372670342da73ea7a71c4b4a71fcb2ff8dc3463d2a074f088cb78eb9cdb69d991ae889d684ee486e89b55c779bd9bdb758552793c0552649e106367902b7841cd9c028b2e76c4ade42a43873dc023469eb2dc2e879355a8a15bf87928f43f03e4605ea30fd19366b5979a8e7251dbb23dd53408d9c27695cc1a81519053ba7c2d6b59ca575d82e7e0f6045e6af17c52f838ad46de9b4fc98c698a6b86bb6639233ac1ee17f8f9d1fe9e721429ac12f67bbc46948cf8666546548c40624bc0dd35d0a74f5be9d9ce9ac0f1133c9c908d3ac9af12618f6a65a432a84a1c04067399babc411101ce91dae5813d75e196ac8b8d4ee9c17d7f77232ea0f871ef05d0075405009ae8a396bec0e04dceb22dd6abf7ad7b6b5081725ceb43a8dc23b28f405602d68d08edb1859fa97e929c9d949ea4e004c6a2222a5b21fa67f7f5139f629a1fbabbc000b3075395a2df59ccf7df960fc0fcfd72f29ef90f2066bec9fa5920fe599ce4e46a19645eac1ffab26114adfdf85db7e72a77b0cef02332ed090e4cb689643c021326587ab516435aed1a5a8459a3c52bdd1ff236a5c51e6470a82e23f29abe783474126c127c9a2bef2c13db9c5494602f16e47d11c943f10719d73095a39dd4c72f27abfddaaa9feff1c030d669f61c5cf35ec34ad47946030c725084e78f26c8ed69ce64b79711c2baf1716577ac138d50e324b0c09849499f8a816ace5d84431ce8cf8dfe83e48a87f0f7a4aa8ced287b69f3ddfb890734107e71e5bc2580f29a4002e151dcae301ada26879f2f294c4b38ba615033ee914b4acceb5be194dd8e811364b997a3099d18bc81461ebde96b9fd415a72c5c212012791b4f8914d6452d48c14dedcb09cc409dbdb5bc78acae715a5965e022bc254a65220a31affc947db14e606d880e3991ea0cf54563b436f060dd0a8633b0b3ab51a4b25139a7da892224b58283131bba5627f8b1503e91706f0c4df4257d63783111c1f36c09f8c99e585e120af8eeee704d4cc62f7ba9572bab433bb353d080abd4a23864fb2e618231b45959b4e3d04e0aad4f08a8208044b34bc8b5e2f31205b1e05e015fe3b10e02f805c91","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
