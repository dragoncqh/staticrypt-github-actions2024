<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66d736d0470eddac1ababa736cb8adff448f7c26f9952f3e1b327e03c6922bf40028e176ed2386286d3721db6f737143c721b697f00550426d7771fe0d099a04ec5c25443270141f4405b143d2782230bca42e0d7e68896f65815240292000c402c19465ce4b5bcd94e4233b4d095acd2b82441308ae5c1b7545d6be502425fbe1b636fac4742fec61b88cb24cd51647ff0597adf5c2f426581c99a067336cbe1849bb56cdfb6a5dc68df90cb4c9331c73bd0e5c0c240ef8d1e420599f96cf8feea205f68529c2022a175ab98ba8b3ecd21b168d798f598bd552870beb4ae1061593cfecd3a330499d4fa860b5a486bc94c2e9c2d7c68dd61200b699f13792692090176a663024ec1c8f1af0a783186726c41b95bc6456d10d2894b292c95c02b3c3e38bac2c22a9c062b669df3e480b06ae8fcfa5ae09e1f5d22a0144cd6f3120b29a7a445ffba5ecce17510da501084f12455e9157887fc98bc5bf3354d0c667603f11d03a63c52cb7e47ff8fcc5c192ee4a113e5eab31692058790ad380fbbe46e4bb00d120aa5b0367cf060ffbb1b75875ee8a09e5affc2e00727fa043989745c571aad832d23024488315af66572e125e369c2edfa45cafaee4fba2416eca3d2dd954a7d0c9df2b1201e3e3d65d2e2ba4900d7fdd4a2e8f94579e3dc6457701a50fd7150a6afc3ddc83e2e18269cade48a3c8e097c2a1cdb647c48501549345d1ec3586f34bd732e55e4774cc9181814861af33e90e931b7ff51195af453c6a6a6f05d67e3ea8a2b65a8363947a137f482a5a18400b3bd114eaf4d311fc95f327648f25e27594bc59bead64823ddc4438a90b9c718631f3f2e4f3ee819684d10f355d1a6598e98e78c5b1891ee6b4d06c9131fd792e8c7cc4dd05d7b6af736987282fba74af5db58ce4244239b5b2d33275b29c67edf9c9f62ae77e42109e47b7a054e5141c12a81370f24ca3549304f3b62373e9f791616cb2b05990f3e4f154e851ab8e8c7fe6d303088bb4b271cd6b623e3f31e21df190fed26a3b3e9e48fa1498aa2db372fb459b4fc2a793c408e9428975acebdabede9f5c0d5f9832aae6d4d5f182e96ce8705b342ffa4cc4ba874f7487244046001e001461aea4eb4bd5840279dac95261fafe45509bf1dfb09532bee4bc5687a89a66f05908ff25d1d8d31d893fce521d744e456779e8fe69e60decb94653dbac5e7cfdeebc6d626e089acc28f99e55e94d205ff086789b4716b6976e654216aedfaf7e57be965f7f4196a14d518e7b5e06cf2ef6aebf4923dde8d4fe5690ddafcba80b10ef0cfdc05c55e90db1d1d2ade6c25ff0ed5f0fbdfbdb63f86a2657eccfd1f981a5c5e78eaf2ba2fb2f8261bc8c3373df5e5aa92aec4a2e3b7792f21c3e9414a9d302a8f76b2915b3cb9562e2725e15a5ccd2cd480396eb5e246c5721305e1c40f54c23df9710e033216d3fe56ac801a8f97cc9c23dcc912b064d74613937476936bbc170fd5124b2197b8882ec16c2031e3d95714286dfc03769f32d578e441535fe18d5854585deeadf375310247077a3999709dfdf24ee9963cdcbec9f779e3f7d5d3a87adcd9dbaa9bdfecb666d52755537d93b2b985a3e00e79ce78411e9500a5b0197c05db5774f67ff1475c1056653944a270effb8fb58557f08816219187c50bff33f3ab86f305fa56c21d3d98839d58fb4a703d162e9ce4eaf42e85f49938d82c6e4513329e87f17de3e67a03bede760fe73fd895e6afe707ca0ce891f4c22132c4c48e0aad3a53867c350e1c87b72f024f19e50cdea9a19b7848aa3e0d1c5df1700c07cd0016ab60046fe32b1ae1906c24c1bbb1855a41086575a543f493b48d01ffd26dd4f6a242e64df6f29a945e93167d38de06b1b72956ffa8690b1c5b795b1ca9c6fa2af9bfda18a30f737b9bc9a686b823884ceb14e96aa32b99ab40810881c275b0ce4e9e03ff72419246631487ea5dddceb0e9e75f8280aff1e04a740d2670220b18826519430d0afcc84244923b726887c4b5f1f134a298ecd72f975e336f670844bb5a581f2731aa49552c9605a4c93881e87e5d93b295926708552f1723cff64b6a7a3ffc2096bb884a54b95b1932d066a936b4df1c38f08bd044322d26f3b60919da7efecbb98f57300d10fa3bd00d18c09f6b6d3431c94a5d1f89cf30199aa0442e889f32d71b119f69f064b08c218ab16f86c57fd5dc67e7cc37b9b58bf73c10e3b802de14baa5faafdd745b3725f5cf28b17af06b017c8248dfbe0b83fdab76f1408a28a06931477c6e400b220f273ddf00a16997e0545d3d375f06a4d2ded7dca046745151eae95612a28d5dcddcb06a8cb9fc8ddb17d26b45a1cce018e1c7b2d1387dfd0268d2aad1f16083ee2720bfa0a02fc9e0f479fd320403509fd2ef9bdd7cd1890b71dedf2e82a1d6d5978beb1f52d650c1d4b07b86509a59293d1d76651cbe6c1bb35460993ed4011e29480c6056f38dbb19bc781a0f740e2785007716d5f75cdb3c5dbf7bb03032c4b4d669fe259d3c7a1fbfc99ae09b24055cc0222cae7ba2088491a3eae0fb1c406c553ce9e954d0b81a7367ce5adf20e55db43bfde0b4f9b453dce928afeb5bb68ed24c74a3f77aead941f980894457a36cd668e36d73b135f1d87f194da7e02d90836f9ca853e824f770e2661afca4cebd1a9e2a32d45a05e3ebd959dad2145c44818b5efd6a13952a7322cbfb2f9057173266e98f5301ffa3154ef905a43bd72bf3691abf2de09d9c3012783c0793fb1dc877d78632d2336cb3c931e34158918a9e1d443675f554c2b98ceda4f1f45be57ac2682aa6897909cf3f7558169c398a6999024b700a89cae51f0acf4fa827589b3864e2491c0929c348602a313d0ee80734374b507bb3ad89a5ea2cedf00160c96e5f5a60637fb4fe820d68a385351cc30cb0fd5c67d66cd1e8e6b90ac53383c065f69e3fd8ae80b44745872ede24c2074492a88d4351ec683ba712eb467a8e10b637e076c8c0930b376387d9a598f924707c852faaf30c5f4db27bb70d26583131590cff212c9f52206daf75feed20b99af94530fbc3bd5fa6f6475fd8d73000082d6471392fe75d98216fbb5ea521c94d1a063cff6a2cf2e3ad708771cd3699596096a09ec40421945a97c2217dd0b6d8468cb0e31f1a0ba647c486ffd0ad2f0da3decda1b6e8af1f585a5a53e574c180d14f22a5cb15a88dddbc6662c74078cf8720584e366ab5f6b2e296b3c9b29cafe5bd7c6ae640943a17b7c428cf05e5f7d9275a49229b511985cd3aae086329a5eeb958536ff00433bc59a189bc9adf2ae907360737db135f12b7afd98f30cb4a5c8b66d2f23aa0366a402d6fe40c1882ea86cb30eed9908ecb2215a03afefe5e79fc212ef213c526e8c1819a9ca10c6573cb01a2102e3372fa136fd5103d1eafa49d8ac3182f8f35a1d106e22b3bbf91d0dec8573f7f58218b05c7a1c5a6707327c36d2e9fcfd40b2a016a1a9fed182a908bd130726b23553e70677f6093c35ec9da47d7d73602864a91afe9daa1f92ca52fe38987b124f71d0288538edfa865c92fffd5cb24d141ab1da83d26b4c3ffeadcaa6ae49aebb5870ce7cbb7be1ce9188826285078096d947043819fe207378e6aea054fc2436352fb67af87beb8244b43ec43eaec3ab700ba055c657e8861eaf34e20a591ccc3f4d5deea121e2a407e57eba653561e4868b8cd2af0312f1b1493fdb40603f8b79ab57beca623cf2b9fb14321a187bece9de35d30494bec2fc5406c54537f9c62f91e31404be6fdd76c0c27e26d63223ef304223f19c390600e6aac18726612cdad08c791ea2b2fe01379df81ed0d0a5a11ffd6a7d8e00e26847539821a088f825fc54c9f7d7b063f2e1657da4178369d94d80c0c8f262d9673163917a085c63c48d1f8c26b750d33f81dac915b11d845a3ecd167e93ce1d6a9ac24695447a5feed5809c6620bdf1873c792ff80be8d2d592a2bac41004bf81f76092cbd60578cd113f0adcfcbd784bceb53c4f11518bc6301bb3424f383d873cf64f68d086cc25adf9a0965f8afbe7dd4d77c9089476e80f008e1cc130c38900eadeadca4a32552574e5ea79c0662adfd013a05ee65a7ae2f9b40d7ffc95814cdb96989bd6b803645b01009cce6fd07350c7a308b48fb664c390b63469f322a08c242d38635b41939e082e00ec92a9530ab93fce8cf55a0d7e2c31208e3187c4ac1dd2d434049d92b4dcfd63cba00b0323ccb7b2da57068306dcf920ac5b175690daa275d520e0dd25f5dbaf8973d9332a9fb6747afff2b783b687c377f6a86008adb39e6100a83f090421803bbed640d8f47f58c892bdc89fd0bb549f5a8436288d145b72cf1f8e4623664e87c22cab63a82ddc3a29f7c0591e0deb8edd037e8eb83565103df200eb6f77ba8f51c84392bd4be243183ff2a6cc310be74f0ae8d1ea3c15241f69b9a11c81e10608578c795e73ce15408ed58a1876b719565b1f3c5ecfc84416fd49d43e34a525497cce9c51be13fac84a583ca6261f60048810743e6dab5a8216e3bfaa393236078441a22c2d61267effe8fdc1ba8d564b37d72d77e06a9bb317d3202fae015d7c242214691c31b93e6c0f6e6cffc71f753f004145f3ab63263c7e9f08f1ebcb4f0256b74333574e7b7cf83211c08c2696fe0074edfbffec189cbeae617b9245e3de0affd96a164d79e5c45b295f8408c46ea12913d55e2b4a3e4482833f73cc8f8062cc3054d8491b08e8cfd0e0d7a287e37405eb7099a6c745c288f2a83d53b6071de4dbac2c7c9cc73e0fa1664e3ae24fc3d5b7b2e3d627e3a578cee2e1741c62ee608d8e6d2855ac946acfec82dba5aed0af1dfc8a54d00b2e8fe334fea1ff730f0d31b4d7beb7fa9e87997acc46bef1471212d8c163646e456d25c01aacddd849cbcbbb5344d99487d247ce3a83116cdc0286c0d180c2c715e91405cc560804d0c6e2dc1a4b2c2daf8c86c3034f8f34ef25ff519d33a9c52f2090c80ef3acd355afae900dbb00d1d2b7342c77cfd333c5ed62d9319bef41f4006ef903bfc3629126ab803105f4ed052f1419f2a05e127ee4624607092f5ff257f3626440eddc70f037dda3912a3a15eb5387c678a7e655dd550cb66bb5fd092664e2d6b228a7d0ad3a54227e41bd791426c7aa6bc7b374f8cfcacdfda2116e87532e0e93eb387ba2410d4ba01d0d9acbca4c2a0806e44b936aebbbd0c767c6488c19347c99bca4df8f6eabf7888b6cc1823727bb91078188b3c513a7acc3d42b5e4dd8cb30610167081df957f94b3b55b3a466315db11ae782ec7129eb404b924a081c50152ba2c209d0c0e83eb383d18d91705197ca8924e7ca9316701d539be730a050d5ec7212eb3ee7d10b6b1e15113e51aed8735da82cf26321f461d5d4a01541a4a5f23bdf8b44d98384f0ab98280600e05d4661920f623de8273d33aa2e33b11c620064341f83efbc127ec265277631022e83523f2535b533c3656311570bbc47e5cd70a9475c7e0e67a51b9db729dbdf7576915b76af0a55aeb88d694b113d8fda6eafb7d37441d88397c067c5d15947cafc1beb8792fbba3d890bfe9d43edc19b32d7925ce921a3efbaac88e76e225a4a5f44dac8d6f2c6cbd424dcf71721495e7b47fddb1ff438e3494a7aef55d2f4c74e179acf42520a8c0928596e8cedd33a5d36ec1bfa6e9d24a12c07904b8913f535730f585aefeffdce4a09cc7ec8c1b6896414daf00d06049dac60b5df7c5b0ba1b5921a836afc84ad020d212afc26fd5fb29d5bd39b166ca987119329f886a8b1eafbf3c50099030b089e00eff753a31ff5804e12fc83ff2fd2dff553c6ab63cfce0b4f94c80fc3e3dc15fb9fbba07b31a08152764d271000c23ccd156d2751ffb5967be6043d2d37d9df15204c549dc1d56807ab0a2815e1c51491742ccac3f3656c6da9fad23cd5a21d17f82531130727eaf459b99e443454081f6189894545febb0f8d842e9b3290d279156f4036a2f79311100eeb6d45482e8793dae492ed3b208d41d8f15b00bed77b9bca1ff64e81e854aa1849a0631372dbfa2567fcef387f03e060556938d10f83a8a3b6195ecd4ca2fbca379300d68ac47a185401b67d00bf45d82196101835b5a8f8124b77d2cfa308540f85fa10c21200f53f59fbd7ecea00764f7ebc8d4c40ab429ecc1de5f690ae3648a48b702b7ce8b8c1bb2a40c1263192a2f6e3ac6893c5308247cd69fd81912c8b600d905c8534b278bc66bfa98813b4e3a68e4406773a04d0ba5b738c84f63df57289dd6d971b1e9f516fea32716c834940230206dbf78cca5110b84c6ecae61262269a28665f46b3905fc8320f0139e726d5f2eac231f7bb5230eea1d4cfb0cd59cbbcdca582a803cba32968da52ccff9cae73b3632a28955c4c47ccfd8268cb960b4a1880ceb600123b094f37918f21389f91c8e0ac492fd6d84336f9625633855db32631e991c83c2043e20c018a869b1567247a91743dfc9ba180650ffb81e229f3cb767fe78022a2a29ede7d83f011c3e866aea3c1f09df7607d3469fc55daea041305c50eff5725acc832893077b7374d4fdc7e10d6ee5de5cf37da7260ec9d9f486b4458b493116f6eec5958d39fe2325805737b7c879b9f4c31223ed0a57f8035516d7e77c0731fe872a487c98ab802f9c1da00a554851d0a2ba0c4ad75f2b4d804c28a384cf94dde0915e12cc9713f645ead1eb191531fa5dcc732fec9c2fd3284ed405ae04cbe7646e251eb18e1499f64b11155a4b5ce069d9b51c1f32a551ed43ef6dfc396b0249bd4a7b97e3c8e4f83316bb402f200d562139ddd9221cf1bf0e9c4396688223176d05ea2f43e123b9305a0ffa2b6d3567b8b3905cd78b4d4294d1877cd0a6cde0f9dba9fc906f45fa5ef4c777451ff77dc5bf753f92348ae7c4be3b986236c308bd69734c267e551bd53c6928db30124dcd73dca4f20caca896041a274bf319419481a858ee2c2778481a5bbe7ad93a8c17509fc676bcbcb9ee07cb7b0a9bcb400da87d8425306d89cc3013a8300b3cb1aab7de3f93d08e9074c351d465f608163b5b785f8d5a6147c62ea6523cc2229184dbdca274b4c08f33c1ce6357407f237bc596c48ebc6024408f378e4be485f06bc94da54d84f90f22d2ce53be11205d4fbfe7ab8d705936a5d197a640c336c729f4da5e1c357cc8ce76eed94174dfc9225aaedbeb5360839696a30021d2141a44ccb295ce25266c0c1f01c05a19a56b766bbf4d95d2d09f7076bb4e6fb1060f5ffb33c8aa0fb1093ef6c2ab1ac8574110c900420b1a9ac6d9bce83743afcb7df196a1ff6be246e1ae08064cd51cfb1b45e0fd71423efc7ad3d7e8d3abcc95eed34b4e1e721a9281af20ee72c7d32ae0389d3b8231f323bb4b759dbe549b897df1b5c66636fc79c2165ee590b4b15023ae5f2f7189897dd033af4da4152a95cf4f6d38c2e7d0f544b1c0682890bc13aea47161c6d3190fbb67bb382f7b4254070486c147f3c9ea3a7f9f4c1ecc12c85747e0876914a532b0ee0f4cffe3b7f19dea439f546a6cde7f92f664530470b6140d3a2ffd0b816f0751168126aeb9d98037a589cc890a1fa5134ae8fd224d14160f922fab9f8013a02e9540b79141b18993abdae6445ae04f70a8b1fb1d6e50ef1986df09f717aaf812dc4d8322ac625089852288f7cc3243f41dffbeaca25f48e1a6a28d7b628d7401b4930ff14a1f0e515ba8e819c570adbddf22da5ae0ed93fbdcf5f1ffa6af7b31f43e7281e9e50b0f38d5215d4a0c376b3867de5c01bc59343299afb4e22555d7656690d35c22773b253ba2f66c138bc864e9b9a7575eb70e53dcb3f515cc3b6219aeed835fabb6a705fec65282512c224be236cd195ee5077de57251ed8241dd193e1a9a087014054169dbac52d697174bd6d062b5ad8e06f5a79c246e23b3a7a5209be727152f33603be2e52c37b1877289953d2570e4b0c40910c2acecd076d11e866be3419b89caf95cd1a1747b148ac9120a5d089e2d9bd171f31fcd8ed8a35d8000846eada7ea18b70e9f24cc662fe709fd36ae635b3df83a01e3ed7f60c3914c1ea57c594b79247d384876c0f1c1da9e51fd29c67ce69b428efb1bbade57282210d2b173519082ec735a3504c7fc42c2531ba4bb7a2792e02e8cef1ccaffaafb752efac0cc46cadec48fbc9d1fe7d852f120ff5a46753b8a1cd3f28e0a49911a70d807353e886cba3be1ae7f72a285c6cc7a63716a6eb8ce3e517b7d0c46dc62de327a4eec8f4b6a88d4e3c4f24527c2f3e98c59b2ffaec5f854ae986248a12213f2fd29d920a74e3265dfd1f09224b79ad330d35c02cf9f72d42b80728b32476204eaa9aff6cb0d5929fcbac550e6449f09ded81daad03dc54ac8f357ad6f0a6acdfcd1b5cd76014e72cd45900c4449d4f31159da5b8d0b600a99ad577fac7b0e534fd594a95eedf9d18276076e6a88d8d40224c284365fadabfe11943c695bb74c4e8267bb07dfb2ad160527707bdf32bd56478879520c15d9e13cf2cb3bbf3fe95d678dcd8f52866d0408579446190a7d0f440e95193ba3c0f502c3c7fad8938496f29069f39f325c7a77980e9010d0c6a6466c4806a9ca97291e77a1fc33a34cbc81313126f4d04a5b9615314d950df62b77201d86e64d7ce2c02c4ac50d040a7dbba3fa7979dbf682ea7f9fe2fc541b9e7250b23ce6e8d70e6f60f412fdb8d06e612829f271a0c8d9185168af0ec3fd7542e7f4ad0971c0d2749c878bcddfb0bc7b38c2610c56eeab9c1c4b4ad0a3604b1e7ebf224159e8bc55b18c79666c11a68f55981ac14ec6dbe7696ba98ce64565b8e03e554e4ff3c1eeebfe438021789e04f0b28a17bbd08540b24a77aebf9d66b706889ee355e214fb33b40491544d758b46c3033cf552aefa7ff369d9c8940638b07d4efc5946552c62d8ed2430032aad5b680d3755c8fdd3e3b0b8ceec855893119656ae3ab0c7227cef5e54df95c7bce59a01bc3f8f88e38f456125df96e5c24be5690034d8c75ec39b617bab02e2d6a6f084b673d10da241e8863845486ee4d9e31bb10640f87bfaf5801162678a29292cd537da2722bf9f8965d3ed30d1e3c57959745ed8b28e3bf1e1899afb316a630017e2a7cc7349927cff8b121656f1de5e18b7a18d41b657e9944c695a1667d5d10dd6fbe5968c569f9fe6408f31a841290bcec4f7c6e32cd7ec7177053b61e671c92770f701ed9d8a920208a4f4253994d6e858c6e33ea6a93e0cdb04faef1ed9dafa649fcabbd6310a001cf24e7dd355423112eb07d07b05f3ac03d8f1d1fe613c9be014016596a893c00b3cc335e8b146da8cc58182ed377114c9f95d842a4ce21528eb8448e62b617a608a96ab2b95b6a6340d3f5e9fd72e8401412395e37edf9f2ea28b3c1295f3748f03b8eb8bf63f101c07b3a70db4f250b1aac97ffb86c9de3abab9efb0f510c63fa1bdeb31a09b37a702031909ffe1f694b6b1ad9d60e7d0bc2a06f316e81a6c43f786092ded82f77594d4a63246d3d9180c04468469bd30a3a083b98dd7b9ea80929b65882e39df3e89d3b245773ff982ee9b490683c4474577f91d77fa4bf668ca2d8f15fff364db8c1cdb950eb116e41870b17bcb3103fb679e53370965974604c748f4d0915ea2dbffd49d8404f7351cf5724b35fd4a676d5e95383a54332c52701208b9349a01f5540db25e1ca2363cf562699384b196e708904d907a481e4d7d5d243bb99cd51d74eb9664802356e7e837c70afc744ed7c1f9009beba1a9b3357382a9dc9fcefce3f32a8938fd9c7f0bccb36eddaf9e5b1a40fcf62699fedf32358eb536284b68b1bf609d86f8e75b6496c65fbcd493df2286f60104d52f4a6d861dbc4db87c7675dac41dca34382e6ccb44dfe50d4b95c3d02642e0d4cf7c6e65f47b3070bbac48ee906dbab7797b61307d4dd51e399cfe77c9eb032b6664d8c30629affc66f123f4fb33f7e1ac1001b53524a52819f208a25d9003341af84fb6242d786f66eca1fcbd91e5e6200dbe08bdad1044d6ac0322b98f895d7be876ffbe09e0bdb75763da56d6f8c98d9c999d86ff59865ed0b3504a0ea20b872a8e405b7674b0504dcd645cbe2cf0bce01fff09bf6869a36c58ab71342ab1a604f52edee00d6b326c5ad0bad8342763301886c7e6b044677c4a71206cf8c005a37a48fc35d40aaaee7188611afd641e672c53901ee152fcb6045797e515dbeda77902bb5c74576d79ec9042cf088d1b9a5a95fb866b8079115fa84d32ace05c1cb7d6671bcf57980a62715ff9b52a135e59c474da23b2a8f21bacaf4df1ca5d1c216bdb6fffcf4579c8a2b60321129c52e539f9ca585ea1d1bef828fac991e221a8af23c45b31412d6289606530e5456619aac1de552ddd9a7023bf1bbbb758df731058220ae9cedcb6bf4a92f08c5a5d615ac67ef1456e5e9fa17c843796f4c7f1b6bb78a7637cedf9e6e09db0f8db1fb469367c021199e23872fd79947118eee9c26b982d808a2c648feb59e35c450ff1e1dabc0eef9ff6a7f8596782984cf5a7075ff2408215f901d9b6d2cb460067ab0ef9a45b632b0f20a1d6b4d5f456c518c0de96f42ba882141692dd187a5b3583a2ede4b199ba458c3cb1b54762bfddbcce582ebf2bd27bebd68457b1a1b517066c8925f0b29449b71d8aba5b8b127c537b1f155b22d92cb0b7c235969c10aa0fdbd361928948494abcd13f992ebeb8e7eb064be2d69b55e0f9aba074613f9c0ee9a7c96495855caeddbcda4ffc7cffbc5fc3fac14d8584b2827fd8b4cac968d02defe35f73c2bd73d05ac7c99ba1a23b7cfa310980be5b5df7db86e18aaf361e3209a8ba542a37f02fe44d3319d75d795ac6dc3c32e7bdb37076f5e53f48b878a6289fbc6e9b30a1601d2101b37569afd5822da692e4b45404b68dd52e7b0bc220aef709d610eaab9873c50f1ce80aa7087bdf1a1e7656188dd97d99a1e61e6a1ddb52a89743449a1c3c4ebb5280fb048e5e750c9a9d529f78dfb050f1fa4f66f1761dd79bf97a5a06f4324baf81d054f0f2f94fe7118617551f30d4f08d225479160f225b0336358f8c4c53699a32c27937cebc291eab884b8c7d41ad9cf37f042739fa353846c28326ae397461f9719c25a2fd611fe2933d93e4b6ddc1149b431c81c3430b060e2e3a86b696e500dd7598ee67b3836fa0abe7dd8913111c510a528799f3ab51cd80303cd9c85034f8eebf00603252e5b67f7234e6bc02b5aad752cdb0aed4759e3fac3f10fd3e6e58e3512af732fb8b95981c16dccf8b135b25d07f087e490f279140a05ac3983f403ec92007cfb9623fc8b6bf1b055ac6e97ee61bac4126bdfeb8bc924cbd02ac7b2d61a115aec4550e41defc5d92550c0d6c7e4ead577d0213cb69a62bb22b7c32e730fa766a45b2fd3039ad2804bfee1010005e9b71cd7aa89f27aa218ef54dfe7120fc368124dcf8b12530fb59dab24ff441f461d09fe0b2b4143ccaa770613775e390e67314566d529726ca7aa59e89c02d0fa7a6117dec022fdc8d683934f6fd700ccd084c0f0c386db74247d33841b0041c87425763d328eb487d3f6016424110b301692e8d6f6addb5758a5decff2c0f45b273ba218a05b3c9750173215b400be88c73af53881f1b5e8757c8a454920144628cb9f1ba6a77b56791c60eaa54224612a66964e1aea1e1afdd6f10ef1a528e947435f706c238286c91f4fb552117827be550a8d689bdd22b580cc1966a1944a00ecef8a22a1fb385ce28e34a569acba5d6ac8b13c5ea52db5ea7633d4713ef10023dcdee0d2956a3e3220c8ee0486c9c652b80dadba100cbbd8596e9924596138df78cc81af9611e4be63ea474aca8d29366b90f31e448fbde9f443460b0dc27c2f6c59fe19aa8f01df9b90584befd4865b0bcb3cc70553f0c22110105ce75d468dfabd3ce0d6a975598ec594842067a2adc58e24b430eeaf2c3327c6df410c24e65009fa5fe5e4e036cd508bec73c5bf6bb415823494a2b9e535510e1c047b2f6d6e1080ef02a8f4e969d400ff6dbcd60a8ed161fcf87f22a1679f36fd430403eb4ec03bbe804eba3b9fa926816a16741417271f86adc635e8c72ddf680f77cd3662854998ce95c7a52e13d6179d2b675e7a04bfd3d8319122d947053c8e2127f08228e61326b1e2fe440f688485f39f9b919a687a789b4f3b74592ce2491daa1c8598361ce2968f998cb2d10c3258e2b9896cbaa1f6369bee9ea66d750ccc288bf8fa5a3fd2b885cc3c288b7358006279db3dcc7b15ca9f32e5eb113374ddd993ca2b08cb59cce10e9e95b6cbbb77d53c0f40e0c0717aaf64eecf21278e7a4ec7690724efbb46eae007efaf41931efb8238d452f1be7efd583d1ac500cdd5f66d0125415a101d645fe828eb6ac386898eac25f2f13f4c0a8bb65349b27704113b21ba33399625665f1f73909606e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
