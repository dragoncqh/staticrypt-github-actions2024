<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef98b5a966f425775006a294e426743dc4f089cf9ea5490a4e85b39b5b1e667acefa7d54adc07249a89a3f4c491f00aec48c0da90b550434b8d11af3345bf3783230680abc926d37149f5dbc928a20599ebf132199e2106efbf1eba7d22f2d27a6163760e24d87465da29fa34cfd7528a5fa1caad80e481d69224150c677e4077c583da55e25cf2d8f975b88c46e68d7abaf31e41c7683a3bb4d857ccef08903a80dadd5acd46386f0a8bebd294b619a0890462ff3fb3c36bdc504cfbb267390f59ffada3f3de587d3bf193e79aaee39606dbca8d6af3a2c959958fe7d9e8c8b44d0b5fef951527563b5ce4c71daf4c96094e222b31a08f708b53b8e8ed0795e91256fdda3ab68a5c383c0f6df1d65d876529ef7d93cc5a99e5352116d379afada20b9ea781588043c6a144c4883769c4c78964429dab9f601bca33e533f25ee33d73501e6823cec9e0b4b040da97f17ccb2500da3a3652284f94008db8c307fecdfa71cf61d71f36b74527fca5cf1c2af53cd777f8735de67f1c1d1632366eeff0da74dff35dc16bc0b2d1c55b39876b8c371b3e86c9227f2492588423d941336d72c520ec0df12ee351417a43a147d5106d1ebeccb92d3b6e573b6cee6b6c1884c2901bbc8ed6b42c01e883bd082616fd5a1bccb85d6694778855c9ba9cf2e7eb0e76ef33e6595bb3aaecd1dc00b0bfc99e6f078e44b8592df825f2aff3e9e06feb040e37bd00ae5a730e6db8d17a7a6b2eea2da23968c64bbd78ec51e88ece2eeddc1245eea56bcda40ec943a50ebb0ad3b467d483e2dd75e98bf86cac16da9d0d0b4c9098cdec850262cf3e1081a947f570cd9564d13d4f44113f8d0fbeb43dfc1e61ecac6ff05406df39d8fb4663f755d512737ad4892a5dcfa2d111f0b3ae87efd15d223cfac3dd8e237a1da37288dcc890e7b355de61a640d3852b43160ab37f12d9d4c74d426d117e792e6c7079190f7b2b4803ed06e2996d5ebac113383ab22d9ef1fd4c06a6e59f1e9bb267874fac315f114d74217755789ef0594c2182adc9193fde5d233d609c1cb24228e138017d453448ff9d89684ceda7fdd4d4b038d7d7598442fc135c4219d8c64a8e70f4933448afdff91741db01afc9f9a8aee7fa1a3f22c76827b13bb0b7ce0ad86e4cc903927a4d26c621bdbef7b600ff3adee271157aecca01153622cfaf9ad060b1d421a6b818ca321511de20207805aa606998c5120619617afdbbfb2b3cfb4f2238ee9a0f603c30aa2b39bbefa84cddd26297af0fde10c660ed502ccd929b06b3335c754e34de9061c1917069dceb7ff8a8e6c25a59f3cab78bba69b7cacae603b01dbcb9931f79d7d340a95c7625a358552b879ffc37fcd566af0e65ecc7f7f77d82bb1cd9ab8b08ceb9373d6ee541d5480cf7ab0a1dccfff13c22aecf71aec02b4324f044c29efd5d3f5ac5223395da4d380bd49d43c5fa7da832d8053464db4f52636dfe6eefb92d9ee751a93efc47037bef6ef6c9d0a0cdb2af1c667bb91969c943c35fb1eecd75354c34c5d51dc0b43af95b06e908cd427c6e6e1a0814bb09a65fd8e2c8a8e07dae78a980af6db0f760874e4a444ef399e200c9ae14136c86159071a8f2ba1aa3b39eeb91ed9b985590ee328b5577866aa90fb47ddd8db0847508209157a923d04a9bfbef4ab61a7b6a55a09f6c340171a72fec67edfcd2835598e377d56f4dcfda4d3e34e0abc848adf7876718c35b7f73891616b4f480e80e3e6fae832354a6861cefe6fd5a5c133a314926d0a833a1d2dec08b60dcf1fdc37593d803fecb2b6e0a0fa6ad9671817c3ff71eb3e8539e17f40725aaf13d2b9473b68abb9a6ea2dff209465688ea9502b6d0ca22378c5c6c0fcdd3db1762d3fc7272c23c4f545c68e5fd74c9a988b42bd047066708a7a8904dbcbd90d9db03b7d0748340ca9fb300e6f140b5650c5b1285564d5560595bedc357d95b683ebfff94ff9a4936fb4042b9102a99ceba863a0bff2ada639632376f1105e0a31e1c7834335f4e9d1bd77e5ac09e1858853dd407b1869c37994c8dd76875075cab2029190f86c21da88566af094bad4ba6c0fd5eab9d52c8c06be1b5ecb1733896f61144f32fe9cc5d85f8ab9ba3f54a50f5031f3d18c9bb38fe8fdcecf00adb950f638f1d68743fa0f024e31fca40e7d1c7be6f3ccd63136919b2607e582750bd4f18706e173c69e4a31e7d245a8ee3cd29dbe6a533e490818ca3b0d6d76a9e0156584134ec371a36b8520cdf6324428bdd300bf634ac44cdaffd4f23d341b6b5a0ae54432019749bfd715a610c8b84711ef846555fc8fe58a58d3fc00879d45ed2eb609ac48fbb530ab2a23b144dc10d2aa155799d6eaedb7cce606d4988f9fbb1020e4738456707ead39534199c73140a597ca9e40cad235c78cec7e106366d794f7fd42b3ebc745d0e15b02e69f67cadf7b2f95df38c8d2160e2d79f8a63e3c589ce701cc6dde1a6577f04e9c72a386e7b2966d0057bde368ceed4a54f80547c9238dc36260797a00891835e259594912463b0948d0c7e07dc1e376b192658122008e7c33556b5218a2ea922746327c1c7a7bffe3ba6b636e5c2b417d38389f46e5900b3816dd72cb1cde5d67f779695d2a06b2dd9faf217ab26a60f7104b534088bc98857aefc884afbd86eabfe8d24fa8d491250396f91ab61fb46a111aa2b63bdea1a6edcf922c46d4fe4794333633d4299a0788351304eeb80aac6844a66943ac4acd8123c594c2b5ec3de336e48eb1cb4bb9b266d5f76ef1b561ee30b7dff0d42c62c5302f37c7814c623e350db6f20b9e68ba8583668094852dfa1ee2c79a0f2f67d00327d62ffaabb4cbe60e6493735176eb19a19540896473e5a1368cb5bce1e1313c5a07a225a1340b60384ee056a5b3cf07603adc2cb1275e492129d9482187fdb6348a0657a060c1d7f23402c446eccf6ca503cf76baaa8e57a72f7fb9f4ee1b35b08856ecb980687b0099cbd5e5bd99791fdcf2061fb43cac6916f06806fbd5ee57a910ab14df6ab95c6e59face02a6f5e15c93932de1efb1d648b66eded501ebc1b7a8155ef883f76f9da3f1f729a34c59909185edc1614b7bf335514003836296ac76df77184f258e6faed2d79f7e9c02e911a01aaaf27a57b28385f383b301db2fd6d5f42d844465998d3f478032223b078ac432a794e6efa64d8d6294a8dd483f800f9b971274f63920222eabe769bf17302416dca22e6e10ac1b68dcf05ff2a498323cd7b805614a7ecb8d4eaac1ef2e2ebada82a43caec978000ef0e0faa47d8b3e5b2cc32c7159dbe191ca84f0266b5dc69f0effc0cbcc33081d44a8a2f020c8c0a34bbcb91d0549237211a8a349a027eac0f821f7100526c08a7289f4a60b82b6d42ea5434f76e7750d4c624a7cc82c20fde61b5f3cde567b92fcaf7598c9b8593a08849779353562e96645f805c13791f45e202dbfce59fe7aa66babd42ebf7d09e15aa740ec1dda67b421091fe336cfdfd39cc3eed955a8b1406275a653221d60003e7e5bf6fc555170aaa9516a9e9ec27cfaec023d4d268df677f2a2494e9d8bc3fab2fdc063841f5393ae3f3772f4489e43ab20f9528b2c05c55d3553c118d81049beffcf342954f6e5a4dfcad035bc905698ef9692fc177e46022254ccfebeec79040c4487bb0a6b5a692b3c1cc86b662bfd3587ba138dfd1a6a0433d552122945eebf7876521d6cc860687040bfc735f422171b3d72e1de9bde7b4c7abe7a1a713286c3783c050e7e2262085e99367ac0daf876c1a6e6ca7c08b5fb6e4f47e09af4076f03e9b1de19c65f363b03b0f3bbf8551c7a259959f4827c06a3441993fa6c0bdf6006e4eea0c76291c02fbebf6460ecd8ee82fab00293a3983b1a845afcdbce1ccc33aeb93b3227c3cce9cd7e633290396262fbb47a6b719ab47665ab93ef4174a786be5b3e4c9355f964c48b5a49a6c91d619fc6ae41f02f7ff2f43dd4ca14e92dd3dd6144e2c3e2f2da6cf15110bd28a9f6421fde4a935d514d7fff85dae331ff8bda107ae8e26dad8f8ed0f592927e925217fac15fe2b76cae1af34a1d71110961913e7b6202d5fc40711d7c0c36e1f5e9a17629aedb565b8cb6d1818a4d298321ef7644e0b2f827c91fd4fe83bf0bfe72ae75809e72778acbfd8c98596943a42c6d9a181d695fb663d31fae430c1caaf0e763f875e78916d88e84a3876b2992d538c25aa3783fd83c7ed8f335a0c63758ec87a3f28793fa2e5b9e4d4808cbee855eb14cff596614e297ee37fa121e0b56cc4df5d15be8209d8e4020b955ab12e7d969b1f5a0612cc2e156350bbd6fd2395c189984581304844209f2a4de9daa52bed6f34b9ff322e90834021b76aa1509edeeabfc068de89a13520de4748965e63e7bf3c69bc8159fb707a21ac3ec475fdce8443340aea2f4766c56de50ca01db86b28a847f38f6527fe295c977a7ef753de78920c5bef4af6563dcb7756efdaf0c69b8e04388c8ba0666d39415257b77d25e917a76fa7fb61317f157ff192b0592b87dab2e6dca657079ebd74625a56a572cc32a9fdacc148f9d0593a03100a7ea6c15842f055962bce004cbe4bd31156c163dec963ec4dd521c66aa3c75677b1ff4c91ea43781f6047c35cb78c31354831e07352642c0401143219c59d4e23c975cbd946960e2f9d371a3620e4848ee5b84b42872e8b061951e88ccd791d379de794464d5d510baa2d4765085863d6c1a70440882e0eb50c582281979e9cc942463c68954c74dfddd4f4302f7dc6fe41a97f02f2120737f22c9484658c51e68971400378fda0d10e15a3fc5722e1bb626f8b5c6a2f4589231d67bd2794d95d4029491ca9008781ad47a4227c6499919aa8cce3baf13e5ce45f61651c8a56c512786546551ccdd498f7c0d5849ac334c25e0565e653acdb1450e0ef207194adbabe1f72837b1fb460e9b9da145bd03eefa3d4f109319471aff0f50ec2b6a10713030b9de55476269dbf424cb98547ca198e9048cb47437eb0280d0c11de187fe9a0d60805ece8b846ac21b1c8ec46a2e67aa385d805a1a639c319f0664b3197594e5862164a991595c2f01bb00a683a0d7ede0f682f7664fae8154197dbec05a14888501e11c84e8ae3f01547a9155eee0e8209bc57ea991e9911e7f8056881dcb24cf22a7d33e675d62cc47f1ff9bae5d17d2dcbc283836a1ce59f9f407fb895a8df5395f7a772545dafbdf0c892706cbc169d840233c30024e77353e551c6c4c2a0cd25560a69002ce65d782b95370f82936fb93a2333828f69f9995ce0031b9f94d91d8ee97e357faf592f756a3e3f1d4271febbeb1aa82555f4dfa9cb95a1927fd09ba896c4d59a90450c70f3e8a885033557a3b6629f062f7cce66c94642c4cfd19ee41e89015ba1045de1fda79471f2baa54eefcf6736416cb50b1f878b0d19f5b2a13ed658a907be9e2ab2c97c9d6f980a6f581fd12228fdae60000ce51b176400e9f601f4f2540c484f7033292b148b38428ed0e88dd55e7de49719d3ee1efe4398601447a9ab0cf5ff3f10ec01e359b504c75192f6f255501d96d4cf048c7ea99d786dadf942facf9bed788016267e96bb6b15cd4e479ea467251d4b597e872a4215fb267ac7a9dbfdaea739d5b7fbb6d7547530513bda7b92b3c797410e13b6d9e15803ec1a9819d159101609f95b87489a73f662ab8e329546524b1d3cb7e1e5b94875de50630cbe1aa66f3ddbaf8c29661cfd831574e3120b8c269089b56b45c9185061cea0c73648a6880d774c302dbc929d9a14bcf987ea59e8ca55c1419481074b7377d47412c7e1f275f0797ac8322598b6bcaa74908d2badda06810e618a1908b9fb64660baee7afa34938fa6da6434ab00a67f2de99640337e1653efdce3e8f00f99309270f0271473abf2bd41ebd55e4a469957982c4be3f624d4313ede34672562ec15dbfa7990abee9ca8b578993a5221f06677c7b59d89940cff3c6df5ef79eea728fd600b8f7b59e87fbdae27c3082be2e9f61aa7597a930239b889fe955a78b1aae74bb12170ce6edcc9fddb33c34a3a3dc6b9a5a52336d12cf8b2b37e18338adcc885fc79bc0f1a7f60aabf180deec4669900f33affb323ed93457fdafc3f3388c9f7ee4c158bbfe88f93b66c360d5d66e77bfe58279f5eac97569b6e6729edc33e40aae92b83735c96c115d758a67e2b300e900798652949ee8725291c0ccf688b4d8ec1c6d852551f22b1191faf737b86a264af4b30874110f3d015c48a2a420a6f854541bc24809c6a0fcc894b07afe10df8a677edc54159dcc723ebbe54fed293bc4dd154c063780c29e2d80d27ca4227f07ae484c4167b5b3c3a3c4a1526e002ce78d8a05d7f15bb879b329609a37023a107211aacd8ca2488786f25f693f9a12b8f61364470fb13064b73791c34d8d9bef6314dff45eec7c9679b8df55bad9c3c6d1b566b9abe2c8c3c975b9e5c336ddbf3b3e433aed4bcb3ae0209e12d10adb1592cad791d320041ec46b8e729db0064c4a0583933a8c7151f1e18910feb3edc12fc6739c7edb976143a874f0b88145912adf8bf56bb421cd105e7617e0545e5d2f763e186e7686bc304fb6d31d3797f17fc00c5485dbd9857ee6474e8cb3973da2b3cb140c8a596338ca230380fbbdf8c226e9a3cdd4dbbcab21e8a7e80243381bafde503c2275ec446b615433ea835936954aef6ee999caf919d5293ff975d4e40be311666ee0697f6894c63aa4df472513313e7767d305c9afdafc51e61ae9f43e8f853b08bb8d16b6fa7907cb1ac390006e829e074e32f894f36687e743f3c2766c2d898db4f35a0eb4ae0009591151553029e5590f6ea9f4bc8270ea30457b9812e8700c0df7fa0d87c9485e0d9d01b8210284e4b510a3fc95bfad7068bec57b73be20979f10ed44c3056d468e1bbe19ce9929a4f17bb1073a7bd349a9ab0e2a70a67e37af66b80a71ad0fafcde05d92104d03a8f32a48912e2d22125e71fc810d2c7f957b3f24f2b8ee2533f709788290b2a7b44a39a86b38c76a345c22f68260e4ed5d800aa4268723389e341a8f2721324e0e30b39736a29948137377e92bee086ad00e7e5e302f77e43e75e3c9a901d5adba7f97296de86d5fec294347ec92153e203904efb3f49a995a37804a201bb7dc0bbd64d33b16a7ed903a19d27dc83eca5921d127756627fef0864942117c23829768ddb092d527ac03df6dd6ea7beb27f78ef84e23459defe501e357458e34af4b5a426b48c09d05208f5a1b5ca25f5306ac2e7c02d21c6ec8c5d6123420089b71b1feeb854fefed6bf1624b73b285e70b21c4716cb43676186af9591bc46f7d3c3493f8bb76b7334e7943553f379cf1ecbc7cf1bcdd78133e850d43ae8ce83504bb2f88e405d2440f08f08cdc3a73e8c8b90ea5e476e7a477e92d7a8456f97602b29c40f6e3ea3189421bd299e3ab2b0370e2100183dad0775578d125a4312fe4c9ac44fb0dce52ba02a3e96d4eddd296ba224fe5d31a11901f8fcfc2763009e4eba81449842eb418d2596f19529809fd33497c67e3940cff4a869a5787f6b1800601019f8ae65d41627a4ed4fefc0407e96960fa8684f67b54056abff4cff4c65d894dbe00779868be809d111a37fb7be2aa2511721c0bcff9e7110e8d586679337f6d8705eb946585bbcc5fdb2df94db7ba85caccc6cae5e6305ecaae37bf8f57ffed907fc16fbd5f2e30c561e093e7633c22aa2a1f2189eb98c821be5c06ebe6c63b424456cf2e367cc5ba90c14daba3cca14e6cd54a56637044e4aa9a419e3887b399122f168cc60de87d1612717b7f123fbaa7a71fc84f18958fcd89c7ac53022f4d92ad767d261c15f9de557b49980f26c10dc78b469fccee2e341dd585bcc51935cb351fd4253a94bff349e9a724c22c7c68af03cc2d1938d6d0b11868930002251c33163f5b481fc7b5ac78f4aaf3f14b8714f72312b85f4a0f928fe7860272d87ee670cd623fa009d710f8d194794bdfe28477f796e1866444d74a35a16725d0d0038b5f824738406f974492bdc5b8b83c7685908ed8c22439aa530653f9c0343e1ec9a8f262597a0a6643b95e1bf607c9c65d99629e0b7ffdb5e419c96e337a6b050122d3e2129d32fb744daf5bde48f58bdcaab865a4d62c9d948055e15a95b80f76b0c56f3e590425e2fc9891e6b953e44b22d565d06451320a5826d55b21ece2801ce164a444c66ab4eaa54634dd54840516d00605b59f72f5c54b4f43dcd49fea44b86d2d83d48e7ae1952057661190fd66957781c1214497bf5f67261cf77f3def9fb0e5be069439f529d3f4f006b6fe41377856e3c46162f51c12486491aeb3a3028acd56dacd1ac23ee2eec1d9d29696d274c77df038987bfa78a533804111ffcc13635443f55ebeaa8941a5e7946e8fc0be8a7bf8abaa48c555be156b81cef99a6d443ab538047e68ba41447b474eb553fdb1c2784b9268d1ba90731ddb7d83e55c85ee056d06f792e44f171073861cb3b3201f6356512b60f720ba97b806d6b983e0997843d42f954deca61e7f575596285c88ff76b405023d7e0ed9ba747f9eae98d07bfce723199f7014570f07d6a89c02e859e3817b54a8f0f501cd47ef82c8f4c5e1883827e5371d55d6c92327c809cc2a9235c1246925f17868d4c45eebf8cdd37e5ef048143603e69d9aba54490ab7581fde6b3e42cf2fb48b476724de6ca329b3ba76965a23cde0e9ded5a1d299638888e7ba4e1d7939e7ff62007f50586b682055f1fddbe20eda2d9be7adc336ac5216b21630c207d8208e917548c438a93a27f5ccce438c15edbcf55c74d2361e960896b90278184c60e2951653e15188c6c0130a12876bc43ea4a25247b936e456c778f8b99252e9265cce9f9677acfa98b82953a91ec8d1013380b195a5b88d20ae77e472f92c1248cca8402f5e81f83f83f7d715962e4ef7c387a285b80254d751648d48d45a0e490c24969b92d2a980c39b431adbb72f01a8650aca29857c8fd40c055020d28caf649fc2a3384c48b524ebc0d3992ffc9df74f1a576bed442fc6a110b8654dc48e41d1376e17927e8d37a1b2c2cc4556f5d7fa53a9ee7f9c4d17e74589b99abfbd02d1504ab3f05d8ca6172a4a461ccba2d56575c748183fe386ace54700488d9a8d247645e725847c18651302eb76a86a0e29612f9e561300f94443fced85a1be378f4fd8ad61c52cb9b89e62a526f4c0f211ad8151f6eca8388105b2fdd06cea7eb0dd7e08ea76add79c47956b8498e5e8c418e6843faf65afa1624e17ef5e23c967af867f872be55f92aae7d519dfc2a2e1163f44fe0211f41ca7c56b1d39b3b82cb64421fe90b621206ff994b26d3ddeb38096800cf7d25e01e36f020febeff398342713d1bb67f56e4e5ef1483773323cdd486f0561a5717dfa9b2a5835bda327c8779c5c463bd7186fa621ca5add76ef98837a1472e36f9a7f32b5a3d60283f7c3547162f35710692ea9126e764cfbea7aba87148b1379b47a925869e88d3bd8d9077786db7dff8ba6ffc6ff5980a89d6ad858360adadf6ac8dc49dec5c385969f45d2c0331b5a91cddde88902396cc8decdd1244a294f5e7f61b84dc1e00f742d4a5ef55b92a6b352168aa5d63c14654e180ddc8064c340bf3444deee859ac5be481e8d222c45839c1f35c10d71281a6e50fba2f7292c3bc69c94de843350935d410fdb14247fc4626593884e17a6fc3a660761b2b3dc1b09eacbf8327c783da8b8b27ce28b994d615cf8b115cc20fbb21fa5874faa4300ccbf5bd341e36f5ba61a96383bfa709989c25a656b8d899dd4270a0ae81c4a4e6755835f5a630dd56ab48742e0e749eb8c0ecf2208c70e3c7535b4dc7dd2af4c4a79ba8a3cf877760c52e04087e61eb4da43029582f23fd1fdbea609c0b569c646e100dee261249fffd5d5089c2a8cd9184ea3f9a701a10f3f614e70b978690afda3595be7d168dc753755ad2e646d8d2173d4de3204da50dbc26a91c7996769e65d9a313e6b993ef445563e07117dd653c24a929de90cd370576ce487bf6a3bb9daccf58cb4b2f025961acdb6dbd528f0fa0bdb04a602aa40a1f9b4ac84cbfbeb1d03a60ce9769e5d31fdbab07f52f6719ffa8997402003f61da0984d37bab40267004c107c4fb88e1fa0e3ff8c1816ac8f843cb14830c9f6515452ca1345761201541d84f2d8bcaba6831c893e36c876f5ad57515fbdc380fda448adf8296c5c194976b2c9b4740b9817ef6f5c293e8f9154f639fa29fca84483f7e370f20d454d67070e0e30b79e5af2519320af2c50ca9390c6e6779fe132fd6ba5efc8423e6b13d28130100c52f394a16e32f5c4a1c8fc4c3a99beee499c77001093c88307e8c9cc086dd58889a580f62b0cc9315d884fa83fdafb9602770da23ab5c3cab3bb2b6c0b276b8d1807792ff37b8a94f343a46f1599cf137bd5baee4001a98a9224ce514e90a86837faee33b663806ac1fb5610a7c1887679f2ca0732e22a3cacfae42195772ef77077d728e74a7b9ddf2480f70ba763bc4e825d336fbfe8c5f65ed11e1a59ec36a95f6b50f4789bc8df71528f38cf0da5e244f0fa63013ee9f5bd37f81d8f1980b560c57f94d525033b3a8b7ae247355a127d45b1657eedef14444db217d65c16b3b318554058d45ef2de40e97262e2e5f2edf1de1c6ad2cd200178e0601d7254b69d7661390e55083a9d7fd6f496c0b161320f3fdab5d4d8cd9e9572695f2b899c43e6128f6ed6fdacb71b8d172f867d2a95d07920022cb34068901024d71ab685b02943b27e2a929cf6d035ac6097ea119a6e5c50377efb109d1eb0100a812ca7dae84817e34f63cc86e23eb7f832c6de2777a918735a7fde0af6f8470b341641bf1730674524c36bca0de532ff3376d0fb558ef05ca3ea1a2579beea8f4b3c1850ede191f81a6056cf71a3898aabdff59e282d92daf72b75fd63aa70a5f1b28d22ff3f6dfeeecf4116a59769a9383ad6a7e2d96759c1b3e2673fd3938e8a9054a2779d7b3da52e2cba5504ded6e8da1aa39dbab04a3a29b694d152e41a8585c02a3159fae13b6746502b5c6afa0e79220a87604ebd278c215db5f8e4022769c191fa022c104ab424c71ff6b1c4250578a87e7353cdcb9a08b0ff26b0f233cba0d80d1428b673d4610a93c4e185e6373e3e2e0a804fd0b21c1d77898a8c2c6ed8eb66f635c21a353e90624af67d61c63655a1b87dbda7a13efd11dc1f309d3daaa4c51028cadc28a73edecc3fcafc99a407420a61262a9f38df1f89abfa18fe17fc5e48ddb8b46d7353eac0a55f54aede8bdbc486dde327af921145ac063c0c36258888c446808843151175b1b98491a35d70e88b69a19ce5fe73292c3a74436d2096c7b5cd51a5ab4fe9dce6559397e98030ab99587118f19b51a394bbf78cc58c9e8ffa7077ba31ac86e15f68e1a6d8c522c2c0fce79d17d85ffb4ea5ed465024c1aea0360341b0d8f5dc99f047ac7df77ef71e93385374e27e0794a75c877db041c8e401d0d277ab37372f5aa2fcb3e55ec70c9f56d0390e324d2a52223eab3af0ea7649de86217d7c79979338df8c1eb3263d507942ffb4a481ac6d29e0a4290ac55a34be8d6587d7b4d27a8b213353ed07ee4253688a5d6753618a5947b83568b4a75ff11f2223e90e9929e6b482a35fd8b071f3eb14495e25a4993d0ce9e16bf79a659376c81645a18de0989b421dd51a1603cedc1760eeae311a34076ad3ccf25bb8a11253dae98a641dfb7af394775c38a01ffba56a586cb952dcbe91ac6ac89be29e779ea80d1499378db459b8dcc97d0577c96b241cacf4c3cd008a80bc0346c890dcc7ee6690dfdb3a84cc7211f55242a8e2300ef5b0531f8fc75059d002314b3aa39588eb4c504f9d9d08ca0cbdd790b0c82e6da3baac3d5344032946486ef74e4bd060fd9bcfcde5ff10b3ef39d7daff2be217d42dde1ebd74119a7108e2479e3240a2f624b96044767f2fdfa3be70dc677771d25be6073171895386338462138f414a6a12cd5780658338be4dbeb0d1d7bac3a76410966849edf8e2b9998a51bba7bb7b6db44c52ffafa273da32cd837788dd086b2fadb290d50fb708c05d7a8f56a02b9f7a78aec9868b21acf499b097973f70aa9e62c7ec0689640a0d298a75fed4eceee3c092f45c39b0c3f9866de786983a813d3a24dae37da9b1645556aa3a82c35292a2b6e4298830908f047b6e548240bf00811ab4bcbef045ff1da7f836fae4f0138f143039c591de1107d409ade35e41fa7d2837445247bba7c2a5eca715bb7d3e3bbe0dd25e39fab84cbea4e109dc602b46f129a544bcb05c01b80919995e3374e005737cafe4f4b414ca4b75ab2b3a9672471bff247ee20e4f5823ce733fc4b49a50ff33342b3392f8335f1f491a60eabcb498eaf213ce1fe2e7e3cb5050d43e69ac538d691184486b1869e6da047e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
