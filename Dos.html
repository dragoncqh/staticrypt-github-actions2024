<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f395bc238d3016088c41f07ad1165f85ea7ea82b5c40dca54002c397c43a54801fc0917e4b44d826ee7f995e1577e88507f3fa0cb8b2b5a12e76cdac082c67c11c57ca4b19cef6ba7addfe5ae33a4d81690d6cdf0cd4bedfeb0461a05a0706300e5a8cc48c1d19bf6da168a9a36acd8904169596bb47a2cd0955ecf721fc3199710de51c2975af1f91ff4620f318023a46d5c133c1903d3ad05c8a8fffd47e2fa5594e43b6d3bbd4100208307bb7663e6518806f9a0087b8b8687c21a8dbf55b5cf6435702aa159521d539eb07527f973f2f4143a7fac27c6730b6d6033c0229ad7de7b977b7c1163cfa97e2a538457554d8dd109fe3060bcda688e7685b9a0ad61964a0edb804843557b3032ce8649cbd29acc669205cb71b1219a9f16baa28e0fdc6018c3a5f0d7784a2148a1380795380e3f761548ec55ba060b2f389845c3dc5d20b5f9e553d52706d3a73c71a6af182b32042b9ef9b1f8ae8f6e7b715ed27f81551328e983f8164cb41eccd145fa68d1bbd776c40ba21575a04e93376b2c3e76935951e079d4328d683ffce92e0f4ba59a60ca7d0530091772c4d93cfb8befc026b5e6fcc081bdb8604d992c9aee62f475ae0813363537b64eb21fd60de0a275ecf2fd878a5c68b83eff75b2e213224e02036d7796ab80b7c76b91fa983d6f33acbe9bca80bcb0beae435480c70bb9093a89023cd368a380dc07130d623b299d35a1939a99d82aa866e6252817e26bc3e6474571fad0624840cf1d51c6aaab417b6eaa0bbe473cdee1c731e6e3619abef033aadae3590d82f647b3b3dfcfb0dc4118c799da1d679309da137575fa5666e989be496f38f5b6c778581346af35218a88d294dee298fc677a22e78d06971d9a25a9cdc5431b0856ca8758b3440bb63646c1c817258544f84592318a97436255d28c19c6a6f6df57b370df53099e45a6063e4bbe7c03768d50fe29165dec0528226ef6a6d870925083263205a03ab6a09737c77d27ad4e07fe14b86c4c18e7d639d2dbe6d8f3e59f6d02366a3a0f2a56f1b7f0f227154d6f6d22b84f537b95cec67f616b079519a4cf681bcee9f59942d61570a97a58529e3c6f6a9a2127d7d2737a640a926322b6739ec78517cb64776201eca2c1424a5947bbb85e827edaeec56f1d8a3bbc4537074dd42eeff45ad6369d98e5d8ec5f122501a3f6461827f990be47b85e4e6e2a43b75da6e9fc95c25055022fe4c24ecdbc2c9063d9ad0b9ad28a12c61337618d1a1cdd5c8c963e436cdf80d52d6845faf0ea6118f1e552370bb9a3217d2cc080c8887bb5d77bfb9387dee228a75b9ef4f9c4f4b3161718066ceac572b61415c41e98378d22b05210706c8075b6070999cf3024e6de7c24be905183fd6b6309ec5836dce59b3c39dfd6b2c825222e68312d2a4d90b2049f1997827106d09b6a71c7556582b7bd8aa1ea9db6bc53582048adb7670292e00d6349c6fc57caf992e2586a69a76bd4ff39be61cb6e79ce07acade4e64e97537cfe792ea041c30502c4ec8ce22297ce3af66eb5f6b169ea8570b36610aa3cc4381f0f920f8308415b79a0936e159c3c928edb0b9bbde99c23a36c1623d2b71ff528cb7755ceda883f5f25c0b682cfa33cf2dd9c6b6d49392868ff3923d04fb05bd91dd8cfc523f07477af1e993e0a0705b63c1f096e06d02c5f054d2fbe520a816c668c9d4e5eef939090dc9bbee8f0e96a094ec88484ec4cb73daf8537406eabe72139cf64bf9c87f701021d7c86e89c70a3253867810391ec76b63cba77e7fcf53c78ad734b33462e6dea63c00ac48919fc62331671a286a125778f302798d8ccf6ac44b9b11beecba9e496190903bde435823fb901fb322adaa00830a37bc85c0b81511bb342a86075c6bbc4d74bddfb9c071879e82e413097325b5e106de3f0f56d37e0fe648fcb5b3e008b86db03ea57eac6703ae7a2bdfae0081ecec4df03644fc0faeb60e442fdf8b1d5f251e8f82eec1e10751a0348a866f1dda1a91adbaee15f8dddbc14d3f0091c061ee679bf62199dfa50bc7dcbe0c1d64e6fb93f7026db6ad9a93a63a5689e04f7abc543c6bc113b8bf9c7d80cbe6dae4737099dbfba024835d50c5e66e2dc6737ad212a6cf210e30b867beb28ee46a8beab2feb9e39fbc8fbd638b8bb4f3b03adc358ff49a54dac0651bb57e0a641b85c43101100b1684a3a23d76a51ddf23baf656eaad4b142ee0409d2f69e0443fe7c743ff56dfc3b8fb44c837419c5f4c2b251df1cf3b174bde74244cc6b72e1fb8971c681c478844834e118a2dff53f94e36a0604fba1cc3711614f5095958e36c55bb3c94791bfaf153406968a8918fdf1b53240fe7672e1c48ce806a15bac4d1fee9037068fc78f6aa4efea28607ca7f352aa446090aaa3647ad5e97cfa8d675e62996be5dd884154457ed53c03cc12e119dd2afa8ec8a1dff7fa55de84ae28fbfcb78881b2e37f43246a2e915964da55652b2bec7a0f3751b1d93f3f9bc281ca88b25df3d828f2e4c8566654feab5055a29122be244275a9ed96587ddec6aebca6cea0705f68d0dad05b99ba9e32a9beebf0cb55e05ac27e9ebd42569402f781f71b843125ad0df2890988df9c4026fffd54d8555f44d593729e34f7ad9499837eb52e6f3b0b19f679296ac62b3c5f001fc917bbcb5030bac4ae3251140c7800fc8cf398b84ffda3f26900abd07bac9a7d2715c5712f40b0943041cc1565c42aafcd5408ba00ce713372d8c610477ac0e934552a89d22338305c53f382d5a49f323e3c9b41033d6efec2c89848169ff07a78246efe69689225df8ffdb275fbd77ed7b420f967571724160fee9d97d9fa7a396b4b6333aaeff3e24dcca8c2eafd703e90d7fb2df438525c18f4171591f2010d32410ce052936ec8bec776de9a551d97b87c3e5ea7e424d9cdc575648bcf248bbd75618a587bf4ec68365fb637f6fc051faa325065aa3cb925ba6121da436a13cda080161eda996b9b730fae15f2579e308ef029c3f6e575b6c0948a204e1c1c02baab4a2b9631d6fbd4b5cad9a30a85bb577d6ae9dd0a03e98b673e52cb55fe203053c584601fce4e4acf05c27492909e7da8a6506e422a35e998565adc7e865c574b4db893f4e47aeb5d26c526f1f26ebf5b38816eb1a4d29fe3c72143a03663df57da913e2591ff7fac96d7b99cc36a4fba0170b14a3f680fc1fba8736a6f467f8cd6f821812174f771150c0f2537fabed3f2ce9c37aad0998b0a2ab687f9418f822917fbbaeacd2f40941f8789cbeb222a376522e795a71def46784eb4d3ca95873f15b2765fa6a71d39c20e525a45453d334fbcfa5c3f775aea8e84081ae249cfef60f7f1db75f43968606e244c0c6eb0eb65ad6b1a914421b53f7304092298e084b378e8feebefe8b08a177bcda6fa568d8de692988ae405c3ee9ed29ad130f7f0eeb3923725feecb962a6f0a615d27058b72dc20e12aedc138893ebeeb72da577449eec4f919273e05ec1537be400ac0bd6fe2e0826d7396c714135f5acffa5a8e69807f202ad8ee8e4a416e6b014ab6aabdfc244fc6892883fede4c0a552a39fa04165c5693d83c1e8e98b5d7d46060b8302060fb67b1afee1b27a120bdeafbfdb6f981f37af95cdd16c67dd922003ed118dc271843b3491bff236479636c4d6351d887e01b5e18edcb791d1c6c84768ecc4e493a5e61d7ae1a74882394b4e4ef4912d3cc39ae56b4d880fdf9ff4564e626fedb397c34d8ba177590f37654110a8ee509ef8c3ae7f8787cb6e274ac879e6ac1f17eb154587a8694d9d85db874f709544157405c72ceae4d96a54807e407fab7a1e24ceea2ce474a798c6f461e2cd1523ac3b01d5293168744153ef676825ea41384c540eeb9f1759b751af425bd7ebb2ebffd606e237e8666983eb59b2840d611c58a757d8321ddf1a4a649ebb22dc4ceb6476d8aa96486920faae2fb470fe54e12c71a2735eafe4c95196da5bc540b21b31083d8b75cc91aad89d439dc282ab3c6db5ff927033aee2cc5ec56bbcc41633a695c94554b5e637a21c789198eba914f917f0bd45411b46d53692337ab523a3e496508bead0c0c7cd4ae045195501a7b8ff63aac88c8025699b0fe1cf254d223656a37d444de233aa6a647d496f3908b079cfda81e7286619e4896fe54b004ef3dd5e1252f31ef8a879723b31d928e6a841bc9c3b4785d2a5e089005506ab2dd194c914c32d6dff913aac22174710e42bf3aa06e91af3d8f5fef0698b08e774eada1362b865c3c398abbd4ae4660ed8dd7e6806991c4e94d5e52dc91466e4d8c4c2a3221b3ff07ae7b5a6e847a618c4ff080036f950645585d97d89069ab8fedd605642b180da0b3f3221357a61f0f605ef1ef010929783af89c9c5d6225d2d815465ee6af24cb0a193dc365df0b42d43757efc6a43611d94c87279097ea7973e161199d34befed5bbe854de31639bf32201d97f55978b393ea68588a9b33e402e32fd9a9f8e0d7b844235ca6298956fa424d792b48b1430b30390ad6c46703c60ecec31a0bbdd26cc55ce3ba59f243e97a90cca40dc0345a02988654a009c56230cae952d6f717c67a45318bfc9f49814aa2c4a24b466d79c3e2d9e4b297a83716d40098e47c5f92566c0548d25e7632f80cfd79a92ed3f5482a80e375018d4f0e5efb8bc0f05bbfdcd8ed082b9aa298ccb8f55f8cc34d3674b32e94e789aab548c8381731724847b34cd725c7293cf062f26be6fe14ddf2831523607934e78a29ac936f87f8d35d19c2c1a3e314216ad19f19c39d5d21ce13a1a8aeb3af6cb0acd4819f9885c1c875bc6132e29ddebfe0f608f17b2c993599850299a115ec1949a785dfc8b42d2c9c677742d29b980bdaaec836b5f0b6a56dd1a442312cdfcfe5fd543ebe2c14e8baa65ee8bbb2bdfcaa40a5156a5b0925403d493e35fbb6a7f41fbe2cd0d6325f6afa815ebb4193fca30fd03d8acaf1285b4356032120e821ba89ebd440f5763fd75cff13a2f0311d809bbff67e776847412aa334ccae740ed44e2b9d7f6f2ed1bf64d51de63f1c765fe55084c97caa7021ca5e76b620115f74d8e9b0b4006df038897360f1e45c4a589387e2f8b92e80e50216a2aed71e322f520f4277931edd26714cd3449ba91fcf4ee3a26024c47c4684c1c14a392abc0141ba634f5c10982e6fac4b34c6e210796c271505f18ecf8dc0f2c64b099dbea77a87addc24e80cdb3b34121a027f72ba10a8d4d202a2f9a1462835e8f2d67fc3fbf65ce1c71ef9a231f309bcd057d0e292fb63a1b0bfba63c916c9aa3714a2c7a1b115d24b14f92296c3bdd7de5484c861c949339b7c362e1bdeb05eed25cfad1b50ee8a874c52b531dee7ae808a41fec6f13e31a633966c4403fdd69a30ba64597e9f1560a45603521ca69c04998ec09bf60fce19ca3c9206585fb1ef613a8eb47def161c6666b0a01f9f7c2647c8efcc4e9cae1b09fc4a02b9cf8d9fe801339defafb3506efc7ed1d4c660cf1d0b658c8d982d22e6599f5929beb47b8ff32db9d1d2a93cf742534c992e4d3e4d12a0dc2820c32ce6d4bd9ee94602940138791547e4c037c811749fa9ae4255d631847e602b1fe1ff80f60d6da18356943f111df5954a67f0aa7b33ccb4862a7eeeb330c1c250eb80d8505d0db9f0546ffcd99200e4a75f4f36654e639c25de55d433ed6c8c95b458416d9c97f93d77bf4f194660a6a95415a1149a767cc0961337bf191558ce828adac7a400c0a21eee4741ff039703e2775c0f657a426d8a4b6170be5510d6c5119353682f09ea6f6cc6478c9a7ec680473b0d2071b2fc6dac3f11c4e9d9ae450e9af869c5cc207a6278ec917a44c5d7c4a617011821334e1cec90d1b52462c5add5c09dafcff077be78c8c2f3bd64a816e8cc82da5de217bbb5204f9a3c0209128018a708c9fffe7774f72b605ef651f3809ef60792ff360e56c9402e9e27b1cbfe50310033f2ae6d7a630ea726c5e5bef0f64c61335278e5924a7a824a98f0b6c933d3e3715e14318c942f1d55ec13da351fe6350560b257e26d6f3888a6e58371fc0072396c0f737ebb850888bbffb0b36e0679c4e286ef91ecf32885057d3f7e032e959f115027115ce715351b431e49bb0d460e521419a8003a9c820b7cc535f10fb41803860711d2e40ca5eec65ee88a2d496b4685bb89ba008c5855c09d3224164e6873f6c182cdebfd6d70f1b509805e37d3313224151827b8937c5fa1dc066d0a41f1080550e93a70a20e25ffc6ca9d9a81ef14187ee3ab5164d64bb173d390cd1e87677f7db3a8e348ac237a056bb689ce98abd59acc6c880e884be7a302bbaa92932f31ebcec939554d488fd58e3b5df719407918a013c616403f25d22442756fbf35d19d1f3e0be967e62934914bc8fe85c50d9465acbcd907b785ff958fe9f77e200d479816c1b81d21e53a37f49c2a8d0fff574f8c1c135e41a26a12a06215265cea596bc5a61638952b5afda182f67f147148d759d13d7c1cd222df9d1e84e6ac7d58dc4af4395222694a2ee23617abc9b045c15d91479460f1df7be86d2cb24394c0fd8a775a1f5b8e04a37abfd724cc2e137971e6f7f9ca201fde2e0543bd2ad1ee885eb81f3f04b6d0da35d753fd5055f85bf0756a767e3222a44f446ac873a1c3e0feab8cfa9bbed2036dc8ffaa24115a93a9f5cdd63ffb718c07368fe6b56b3bcebf7801e136693a6082cb413b18a7c4e42c6cb3129b9cabba44d6ebc037f7df4af75d64aea510d45b3f172a938ed2e28defaa0f0c93cf034499dc082a3e828f2865524c9f4ff2477d5572ae01d7cc0980add6c6232cedd222e0e7a39a93309220abb997e7fcb4e3f83c594d37751c04c2fda757e00eddf88e235a9baf278951901b06559dccb3849bc95dcb32ebdf70bd83993fff8221139fe1cb385a51d4c56a908bb8df476d6ab93b96fc9ef7a638b2bdbb6771e145db36438e7ded63164ef5ac095a0b580e523366383af98bd25e761aee8e22972aab458873e82e3891635cd7a8dce3f4b2795004abca4de0a1f32e2391bff328ad132eecc9592fba311bfff92145a6275d8b5ca6227137a7661a49cc45f052738659c11d7630d9a9abb3a07493f4e3965f12fa0e5dd26f0ac3b99e008357345b764e424da5720c29361568e97add51474a385af29cd5bec3f9e32ca09d9e98e3b2f42d9e345c0d2c69b6d7584bd5c00dea48babfd06fb9fb582b105602ba4782dc3fdf9cd5c3312e5ae6e3a362dbd619b7dcbba69e2413d1ea244cd2b9b342e2972a5c67e3536375b54441f2663dcdf145d52c41667154ce4b962509ac54d034942b84eadedeaece4449cc19c538b9fdbd9978b3a1bd1045ef414bdba5f1c479af9cbc3f25ae9dbe7569e04cfdfda5bd1187329bcf54fba29ed103d60e5d33ec74e1f0f9f1f875890fd93401c4937cc3488b5a2c6f42fd920a99b3fa97e5d56593fe34e92fc748f1d81d0acd987f5ecbb4e809fc3ee62cc570dc5517d6e70fd33e47258d5aebfb00c90bceab403066cec99e3d56c1719243d9b97dbd04cf1ca83ecd56da7b40a981be16b83c1a8abce0113b691e4a7c74efda41ebeb61cdaf95e6bfa8c8d3ba1b38468b11b99cd813f20ffb154ffe44f8804f9ac22c70a060dee32f959117869bdeda1b329a33deaa6b0770ed9fb4a927d5a0efc622914ba5185809b27bd9011ed46317dc048c4a3668a38367c874123a2341ae5b09ca234c8c8f0dd7c5ce87b881925785d2afc3fe15b14fbaf926da0e7340bdf9c431dc51e649af3027d6cb9af174229e72de2c5a42d667d7a00018bae8147634a43626b6a271d786e5ce75516717124ada7e3a404e0ed0edf3af6f44746d28a25ac6bc78c4a12063c269b2d8ff201ee2b83ca99e484d08e97c6917bc00121863f28e39cde64025ef5aac2205db45b355d2660d15149d72c8e01d7e95cd556cd2d219ef618c0c950b988495384c71a91e7a11d0b2d041164fb6694d6c3a3d338b8659b438b249eacc942162b077b3bbf4a9ca46c4571cccfc252e6feb2e7d5cdfd9383c16830e3d29b484f2051b2da010ed1488a874e3dafd290327ad48b0cc7a768885584e81db47107197e7cdc21a7b86eb16919f95eb9aadb5a9d950b9949f4908bab1b933d0f83ae2379a1c970c811ff184874360710a07185e661791dfcea5ee2986da504883b40a7e6fbb1ceb5b4b62d96afc8f7fad912d0e664b25a98c08dbe39d3803956753b31781d66b4d6995a04a644f60b8f950be07894615ede638f2ab90c1aa561c0ba2ce4dcde027c78c3b129365f02366442270e4a8c00d642ae4267ef3604f6ea3514cc8c473b858c9e4729edf4cb6943ac117f586eb834e66ee47228a419b0e29e6725b55c9c1422bb0c3feb19fdd56a6e9c1599398411c450e5fa74ab357e70ab4b03e229f25913802d865471a8696ca06866c241623ca65572be7d4b9d75586a811138378775ca4b20ba3784a4d5f787864350bb5a6988c22d9a223fe0c86b92c4ceb794c9fc916d4832550224165f7e8a967b2a5c38d6eedeaabd1abe686580f1cf060a7a5f64e2b64ebdab872a7d806110aecfa914b4c9c247858555e0330da1fded1f9c2c9bb414f8e3c0c6bdfc94f7196b61f98d6e5427656a65315f098b1fcd804989fd54cdd22a4b49d9d7d2cd5d597aa8e3a28f65d09d31861023508381b280c565283ed4af813c2e3f8e1d0c53b224e96df1df1b061bc9c781bf799ae7ef2a00ddbcb2686104f168d3e82efe027b176b3b1ab7ca047d9692babe55f973b24a17c98b45533e3b3640eae17697e48e7d2217016f8255fac24b6f1e12dd3f46cc835c812e3c0174d4e9eeef11543791a5685c3c09919ec92421db46f4a2ce842b6b8b664b464a2a01548a68024e0d1694d472ad627d7fc940a00063afbf3d7d28f14d5d06e2d5905ade896876a5ad527f7072d2d5cdedfccde9de9b7ec421f662fa62d1d4067aca68b3d1e4c8acb3e722f7194b84902d13352779a67c01b9cf75413167387c34e97ede97d9c1606ef37dff48e355f472ba9e95aaebc98cdf3963eb3f2d670494cf06e756acd4090a0190414f45c1e7a061419ed80d348054f12f62bbe5f26910c3bbc6069446a4e7db013ef2e08bd8141dca595c073bc8c614a07c4902262f7f410a42d7cc18e8e6462e8f62d2dd90f23a569fa9a0ac4e978d5667d0491cd71ec2f2be1a4073e5ab340c28650c5ea47468d89ef42ee489d00a745d8d2e3f0325ae41c643ab6c686a8370e6645992b4bfde480f6c2f67bb9a1ecf3c1103094d17da1bf40db131422b5eedd0e6af842c1733a59db4096e09724ed7772bdd8f59c73c3e0ade9a4ff1d3410ac2a1c9d77a0a84054a37b4a8e99dc12e288e50e181f50f23d4ab25655dc7a76076b4d538923921a5c93cc74d3518ae43ddf964de443f2a429c3921fee319dc3a5f6fcb933063ee2595c2ca23f624a3a0baa7dfa4989abc8171d8fed3ca1f22372d3c30b27d524cf52ea628e4ce11fd30c5170190832ccfc220e65191b8384841fcbe927312a5bd4a6d1e2515abc40b28ef9474c33b46a3022a68afac1dcb9e714d52d2473eda9bb5a4be6b940667676249d25e9c54abac27298d5b1b3676c15ac34c6bfc3794b77d3021ad39ab33a7142fdfe0047a7f290c5a5be523d0cca05a0c99c0c2c21be1e1b188128161c86e9a3c380a2c5fc343fdfbc2d2c43c14390aea62d7820fcb15bd2f9ccf623d19afed983f45a2eb1d2a4f07a520d4df6f8c721d6644b00349c9c8e21a532f67df33b8db7b7909c09fc9b06fd20f3d2ceeedd3de6f97abafccbfcd6b5284fef0530ab92aef04c6464c64da3f5141cae85f2df319307f9b58916abb1d62780522c0c9a9f350562ce05f1535d64307af1fa6df4167fca18be616e8750ccda7cff44ace311ba419a53223dde935ca824c4ad7b6c43f79e251af2477ea1b83c9222ec4e5c4080c785e5f25428121c68a111407ab07fbfeef649e580f20279e4c3340831ef1b2028bc18802b090ef4040c515f7a767219088e346b1a96ecd377a2e5da60d4549e789698cbd5cb3ede2536269521df5bbe0b79b9b02203303f394d967dcdaa073ead4085ce25e9c97dca8b1b4c0ec395e20d0545deed99ccd56d6abeca07443414a3bbcce344fbe45b25c40f36e870f102a371450622307410c5ed9dbccd6f5c47cfb1a7c7796e608550c4f67bec6bff835db09c98b0c589c2238d5139cd11b7210fb502f536df3da60efd3a711d3770f12f58dd0a6d5a7c23aa975d460b80dcd84914d96268c7cab164f256949f4505efa53fd00bbabbdf90fe36586c4109bb8b0217affcef58f675c7c5aaf93d6517b6bdfb46b372ca8bd0585cfdf0c04805ce0205d40392fae27ff2e5d523a0f708c114f3a7b4912a95ef80674ebdb134afd9c199112dae84e6e29c574c755e883f994b9100c8b406ae7e187cccdd278c7ac2a4152e8ce95f692e230cd5250c4aba7c77764ed4f5539b3fb7a667d01747a01af080a9ee04ee7e8a74fe1db5edb297457e96ceaf4700719592d4b63750db1c36ff2d74bd780234f2d5ca19560b387ebdec003c2333fe3da647f011951bb0490e24e01a3fa3d3d13b463fa8711454778b735617d9fa9f97eea40bd75f9a77d7a17d16c7cdc4ea891284a5b457ffdd9e99f0a47512b3091f6686435d4ac1aa5c54891e9363097c863d4e5cc3c3d509b500db70f49b217abe14676947841b43174716d50ce9d326a51ec7ba56a9166c5288e4b3709819b66d877d717e6ac530525b4fa094a75f1cb39710649a19b1772e6d122004674828c710bf050ca8f9318e6613adff01a276ce69088208312aacddef1ac6d72f05c28f4cb19a64d97cbfca5a82800f2af67f3350b1e14ff4a664281a091d57a653e3a16fe14395aadc571b46e363f6b02c0d9ef6a158de04ee003e6b4fea402762336e5904ab38ca9ce72d12a373b51e8c18adfd9be84d7a485c77eb3ad84ad76e96af2a866a8ad709ccbe44453c0a88091c9cd1c1a811de7f802185afcd609a693cac212eb3dacb82ce559672d3ed2cd60acfaa04e0cd29c40852a16deb43f71465984a04d8deb16633fe4739e60c030e781dd71203efbea64160c47fd7700a369c5f7c12ae197c70b0b9bcf1e81ab0fe65e33cba688d891c9f4188e6b691957cbee89bbc462b58b158fa6977a091ae6655bed68c421ef2828950659dc9bdb638d33a27ced7fac2236d993b44de88f6f34c87d86b85ec5ff4af8b2bb7e88c7529676113853d8fb384a0dd800f0e0782f0089e12f380115238aaa8377ff3ecdc87772fb4f8773331b6e661795e31956b28127f8ec6be73303010373d878c27a2abd7d8a75cafc8fbb943bfbc3427deb9d85264470dea735551aa5da7c929501d17e012f68ee809c2096b4759c5bdce0123077e7790c7071c385955ec1ac7f0836dcb842e21e29aac1ab85078b3f4680cc80ccf50e5556fc765ffbd535a7cf479d62341962682675b23b16f87f649967a38e202c3180d60a5b13fd9d1c757db80ec7f8153a32c4bd6fe2da12398f7fadd26a13f311c101ad08640df91db0b075e3ac280e09d75c9903c8454967be89c49d57a84a0942f486cf65c7a77eced9c13e16c15ec065a7bbeba34e077a9a41869a9fb1041c351497585497e34c3c63c309025c1b36adb7a16fa169f44fa4e8d79c516a9c9c28960bdf90ef8667bc6bcf7547eb2b9bbaf0ebf1db3afa2cbff575cb9731defccaf080a5ae585ffac4f66fad696b353376a13214cb35fafed2c645d567e87272b9f88a13c07d1f0d1e3bef211d0a4fc315860158a8841760ff4a4a73911e3610b6750429681f1149a22e97967f45bca8ba584425172d166364fd97136cfed7114ef71ecd147cc027a7f36d7ca91e4e18d5e796b66f66b610f09ab83106de8e12ceee2c19d25981007fae580c1b441f54235cf9664c83c4639a6d20830aa888329881319cca069b019683203c4ecebacc2acc441098cc2d5110a118b049fe4a66dd67549be47296c182e1ac7d08f86c8d127ff74320aba4185e2c8f6aa16fdc5fb258e5ecd8e123dee96771e13621b739beb0498288769107c8ca5a66d7a1aa3d04dfc863c004a7c4fe8a55aa9b0ebd0fe3d36f73fababc200d900704548f727b34f6fab7e126fb8596c0008385149e15fc76ae01deca482f7db20e765f707c43f820a6f80e3f7bd4a1f94e90074207105f883b030efa0ec746975e114baa2a2e9940ff3f19f45bb89b4b3be97b9bf861f7356cac956196c2e84f03aa4fa2281b50b1019214af8b571e45dfa8c8bead825cdc6e4a5eeb5695f1883fc8b811935fed327436c6dafd892f96dce98061586909e164efbd3e35ae6275c888c2f6cd3f09d37db41daf3a1ec8b4a7ef26b56fd5905b31d74318391f30ce3adb784962dddaf52bf176f4552844ed5cd5ce7d3ec07afaec5bd1cad034d6b351e7e1b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
