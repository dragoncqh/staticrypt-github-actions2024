<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7d261598e9d13f3b707105dc76ea04069187dd7afacfaff5463fcd829bace50847a4bbfe81a8ebc16c8ea453ec5a64f3fedfedbcf637f2f128d4c914df73b0fd7cfdbecbabb316efe8b1ae73e8e4dac3cfb8d833990306c73f1d6f7e43cff3b05d2fd52a066988ca6d6148d489226610167705cb30efe008a79174b328217b55d88923941db040468a3acd3fbe9b5c58a470fbab584ec64accd8ddaf16290fc3f3f85e23c0ab62d4dffd509dc8f207bf528f253ef4bce9b8e06a5fbcfa6b9d9bcf29fcc39e41706b8c3abdc5c8f2bb0ed632794e4b008e4c118a89d54442da990fcb53240aec2077755dc8b37e6131c59603eda18f92d244c80882bcd6ac3401b9b5de4104cf46db0a8b58cd914cafa2c9e05dcf498b04941d5b0c01ce4e0b878ff47c960090213e5865b6d5dae6856fe68521e715d9551ee8a238ae4dad7dbd59c4bd43eb558768a4f6964defb20804f294a199f2b320b9e6ab10f2e13cc84ea2fa67de6e21bab1396489015de82ec180bd3bf089187a995f7dd16b9cf89c93fc35c809fa1fbd493eb373f7577d9e1d9639cec64905a6da242532f95a4309c7f64b4b622a5019143f71e4510d7388b8758992da749f5eebd2dd30317d307ca834fdfadecc11657d7e790e104ae3d1a0e1192380c967cae3340ad7d19c3d47cd5c49ca29df6c1c24b900d79b903204ed5045c05f5b36b8fd518cd6b717c07c6ceceed4f8a3068f2fcf755b0e7e9a0135e044e5bc6fcb5e93f8b5fa5ef4c0e0b6df32087becf3e3d247e07b8dcf3fcb4ea714452afaffe8e0eb9fab83b545871b930ecdc31ef26b0a62ba8da48f717cd791591e9fe12179de6315cd9a713ad491bbf9f21f1edde2eb5ea71cbd9c75896b8807c573123ac9f6796e849dc0c6b8977636f3ad240d99a957d63f1992b76b1969a6c50ff930ababe91d0f8292a077ff04491cabc6d1d7a24c28b830c1aee2d30d30731d82c150a7d196acf773a47d47b8a873ce7d63b621590c8335857d684b9f94fb765c4ee13e46aeda2c335f019f207e364eb9331fe62fa1ec3927ce28d8327cd62b4d52e6cffb801b44f768c60c1137d9b6a62a74fed72f9800aa490dab85f41094c398942813405b7876ec01eaed2fade13bacbedcbc764cdc58c53276d5b3e3925bdc65e86026b66af6ec2d207cd8fbf6e3e1c20c6918b8212c41e51701413b4fd5b6ffd24e927429616004ec3c3a4d96fc94d09d9959f1325404e9ae0b015979619f49cf0e4ba132fb5512b22886b6eff75a8e292689894e624952ef94b5bc346c11c1dbc7fe952640e27ac4a2f38b906662ec585a0a9af19a7f2b52e16baaa0661b455e3372ef13d5e0d69f8078d2f2f8f6fda2758cf2608a2a8f91b838e7508ead717aefe237f894bbeae850658b83e61163a7d02256eef0e306ba272a76a2b9e0648c877f3173bd2788238ce6ee3f38597edac54b66f8ce756cb5d1729f9e59ae09fc5e6b8ec746f66cba50081a47391d9b5ef3772946fded5e69f3a28cb68a0398f9209e71496f4040d736b5fa0adda3dd41fce342fdb168f1071b49c784f39b531e091f4015d7c9856e696e64fd1a2988f7aed199c42a66954c4ff0b672a5302532cfcb8a5f2363bec1d1c2417f269793ee528ece4723656d5a56cfabd2e1b26b4d4ab3ac003450a23df60a7f47969dd1d74fbc08331f6d3aff60ed24f9df698a3d86503cf857e6aad114913581aa70957ff23775f810557bbf63cd27563462decc1bd50df0d3361aa2bf32cb25263d5a9017cd5c8c0ccaad5eae09740c2fd600aae4781c5f0f3c8d28bf911de6e6bef4da98f165e42c588677a2e4dd16323414bd775f72dccf51399123323c08b45c9d90b36be0689b24f6136d5bb4519397ce334f421e1063d66f64ec49a97e505cf3977a20e22b3319cde6efad0273594058dd7784cb8a29677d206bfa777010973193c522b9ec608feaf7cf826e41b191c25aaabcba90d1a2e5718deae70eae8812bfe8bf6d1e817e0ce8b733d453e45e7ff39cdf3f36217aa129f71bccb07873d628e65ed5fc92ceb91597dff7c5bec78001a91924f50b475429d1c6714f6dffb92ccadc6076833e50c08082e729584f63c14998bf9fd0166f6cadfa6ab151b22888122b0d82807303906457078c57b0f259bd3c2dc6d94c3c1d7dd25baa1a447613865cc709495f3d6112d70a08c000c79d7b377b6e019b349427002df53cdf5181b22472c92452eed0ca782706056e27cc4ccb96aba3a9cfd93eda3099572c92aa473c1b74fedfe640be3c3ce246f7e7f3b387d47d9ce666337426cde2d877295acc2423727963f07f68737b7559b3c7f6f999b0b4c06be066b6ee0d810254d75013383e775c05db0a3c6fbee7053c9687ee4992c27e6e2608e87ae8477ed169a0ad9f151a81b1f57fd66bb213869efe38d69fb201e55ecc5922ef9882120ee02ef3d3131fba3c66415d939f09ca8290972ab9106917140ca01ea0ad9603c84bb33e94ec46f68051c7d6f92b29db5fafe8d9633542beb83e0a796250adc45f44bc11b4131b4886fba7a3b4d415e48f8c184e3edd725022e0876e22955a4d98508e21dd38140526977be5c6868a412cf40d5782dba0556dd6167844ca1251d7040c0703327fed072d0e00c651522f709dd8cd9f867fb58fba100d8283dacf6e19d6add63dd0c6a5dd33f10a7a693238b1fb26e392883b5ce05df7110c4dd23c8f350f7daead4b09c588a3e63ed6c603e969d91ed10f488f98175423a129a2d4138d2886bb7720dbe93c1a4d38b3be23b5ae7eba42368c336b5584a23d643fbfee96ad433c03b3b7e393f26a0730ed0a6b8be414db407cb46ccd1a72304a81218f57947e8e1f4a444e05c2fb1d5d62e634d4ed1530df8bc28d956d47966964f90e1023da56828a61f991b3860e3136b126fc503eaa9e514a0b18219abf823fa14d653bf60298e8cdb0c71b5f7bca53b75e50594751888708d40e7dea75b37d6e9a59e5e803137849cf240298a81cffaf2c1c912701c454cdeed1b4949c84fd797dd891645fcd04ae99fd6bc318118a0f2cf15421a0496b1f43b0f29acb7d55dc6a06be3c948c787403ee1c2361bf02369adface2d77bf40e987b3bb8d78ca0dc4678bfcb6890452517af2c933bf87a342c606c563ca7a588feecb572b5b56ad6c9c2b813275acd8bc5f233082c08561be35d3aa9a9bcbc42dfb888f383958aa5b3cc9eab9ea13ea1107a00ec5b27aaf56f8c9936605d18fa3212f6e38a373e6ae5d07e8773ceffa6fd03f9fb36e8a7a16915de83d7f891a2c756aec919f65626d022fd0b545baacb2b626891487b8ff156629dcb0858d3a58a3296537af174d4b1b78182297b511e06858184d640700eb5d4474f9dbeac42193b4e44f33461b0d346f09c4ddf2ed86c6c524eb76cdc2d06e701488343c8581c124ff0f3698182b4e2a8792a91c56a8c67e5ad724f725ddee7d24adca093fbc144c07787436f5bbb7059b5d7506bdef4adca18b46a046faa93837956ef84119b7e011c4323e50dd81e5f80908899ce816fad81b4143a1a5634f1c5d20998208df081d4b58a5dc169036f139bc1b107b459bd63cf130162ca7747133804ae1da506243e305b5da36851288b33b5de7712ec8e0b4784bd8640430a06de0e4edde0bf92a5d7a8804e9f0da3dce82b80511ba7fdb554332871c1afbe8a0f4212e2448e1c6d415a6d7ceff245a1113884503802e799326fe7f2bf5f0cefc222759c8eb4cfc50ebee475dd68da3793c731103a82197a0203f9b391ec180c69d94e7d5492e3298c933414fa6ba201fa2ab1615203b4c7df0f886ac0b63e98ef007a6a7b6be2ab403d9f7dad6b891cc0de273b67479a481aa2f81aa5b248fc209b67add49d3f4a0e64808ceaabbc222dc1232232035581469c5787cb11f53d6f38075851f833bb66be8e9ee6236e77e071b2f3d1e487a4fa7b7520d4837c674587af5d9831f43de9a7cb1c35a7ff08d51609da9bb981462fbc489dd01a0bbe9385f5fee6ca064fad8cded4d28ff2f2924582caac9c94890740e318cb634774fc11bba7bd1381759f769642d18c67302345e365d6cba1eab8d033e5a57f95f295e28e47f872f5703554c80bae841aae94195bd13471ae0f072f111ed44deb562fb09e24427c33d13b2b74ba7a498f4b0a6a179af4c4e23cd496319a373a57068ed0fe5eeeb03334fd68e70f02948f2f6359a3659c2e035e6733123bb034a43fc3e0dc5c85e4be7a68b31406fa63dc3e03b6a5bdd845d5fb69e48bd1d618f353e730c732fb6ef376c117dc4162430f95fc3afa218e7a261dda201c3872d88a6c8e36746ed30ed3c968f13845d1570cb4c563e629a41dd021589de7ccff68dd30e643e86d90ec217125845bb0498abab1540d22b4db52bd71602786f0cf4f213b28d19bf3f35cbb0b48e3151ed530daf631b208799ae890d0821f756760809ad45e5f244ea8d03b0d222af0bb084b83bc4e02ca7c66b638707314ba925d654721524d09f8ec8d271fa04cc42cf3968966c2f6ecd2c846a662e28870f96f9409a0e03aa5ef86dc8a40c6b854a52bd5fbf73bb6971879159d126496aab2dd2e10bfb03976c7f4f0640bb5f5b34dfae38cea880bf4681784ed620665f7cfb14987a447e38ab4d98a5cce6982b832b1f3527f3ade8d78f72e866326ab9023c6005fea35f64416ec9104bff0d72cb371fa25fa6a3315fdfbd8b4ef4de994f23c814d9b552aa0d762fe0e20b45ce67fa33efee5cbf9c9f4a823d4894ff746cf23ea22283a65dface7c1e8cb062d76b5420b006e2f0d0ee0e31f79a5d49ef397d54ed1078734eb17bbe24d730864b2a941b16536c2b893a5be17fc504078d576803f669ea5d217feabc49fca546bfa30ba08b4370031e6aaed6b644f6949da52feca7cc10e01cb83c50468a47f1fa4a8eb49f66f6bb88459b987bd7f98b6f7d0440e0e455c5362f05eac9245ea020524c478dd99602cebff4b8386b537f258b018bd8eeb095d01c8bb18c6c74d69f80a5ff6247c775b604c7ef7da4f778715eeb599b66b4ffab57f8af3bdd82fabada6227a7b1a8314b9cb3ff1c17d5c6dec9cb350dce4278048a71765c214ce2b86e1749446bb4f676390b1e8e9f2444a82912788c30263e953cdf98cb8e4fe574fbb2f41826bfc1681319729b698fadf3f14e1c611910f900bbfdda05215b14d7ec2b84c5d5c23163f430c950ff1252be7c4623e6d90b797e0d1c5a5ef745238720138376c9b8904fc947922118259088776792f56525c364418d22254a71f13dc5b82ba356b770e79d7838c91b53508f3ec2ffddf955e321895598a4115ad83b1b09a92443b66a0aeeadb529fc715b04d688528d9b31348a1bb8c1c6dfce73d1e1f04e5b340b60698333d18c34abd46b028f8ac0d85020ec06b1df264504ffac6e8468af984a51d478875c906d64e9e28b0476e2ace6306d3f1a6323da2b2f7bd3cab11f3cf823a11fd14c60d823d9d64adf2beaf781550e4184ca77ad089daae1cce8b6db68aca9e90035aa667505010abee5a78509daf6999d70dadc3228505ddb98ec8f65f00f3040863847834f9249f216e1ccde69e4c6608e7acc095c88116a8abbfe140556ac6fadd29c64a3f7c51cbd4e389f778604311f7f2b5ecf9883e53e661acc5cd81dcb899024ad39e0888df94560ddac6626b56d2a1ca5ecf2bcc7c992e67be813f444de680fa2f1ac27226ef113980f7d59e1a9c319d6d1827265512a42e2a4722bbcd75e5205f06193bca68a8e3f3497ba12c139d2d01298c0f4d8a62e2aef09df0937ae2f87e76eec79aaf7c8938c2abebd39ec361cb7bfd124451ae076d1bb5866ab4946ee917e128af636ed516e7f586e4471d84b8b8269df03109f1bf090e7653d937e6b0e633b72c178dff354d891acd62a93b454e50e203755319b3c6c9290941560f74cefab94a5c6d36a87d636e4d539b5e49098c060d33f33d89f674cb48e04b53030d5544dc223593adef0865cce7711e3b1b1ed75d83789440389e30f6f218f4711ebf7da39881f6e560428e533d18db2e6ccb39594e1b0725cb292bee6360df6016c8fa8921449a8f923d1383c07e392df537a604166edf195af13bae865c5b20d4d23c8e5ebb92d3aa946d3223ddcde9c11b8d0619f9d02fdb710d02847a78c00d4b68e96aa9856db068354fd22f9831d89a89a10cee7e8d4456edc466cb019be13d176596f9d3b55eab700385d292081f5a5bfdf3235aeda4bada882df4de9519174260cb4f05a43d61059a9ac80da9b9720d738199b1f34a473107b6de064a87a888feeebd93ffd1db7137ef45a13223802ec1f1fd2a3e32d88e08db0914a7d2714e342fb9ff923d05ec4976c92fce7222626d642db154943df657c220c14893f79a1d0466ab141dccaec13943debc886c0cbda07ba9af196b3138a8559854af704dd9cd6c78d173c6afc8f4d43da45b279e99055c8848e6e2d75447aa55f7573cba4080ae65d357ac5d0e0c124754e7af05c4ab69a8ed21ecb833b3171b3c862e284249acedab836162da5d77e519e4bab5a631cbf9a88a1d90d8d0a690c451e50d53ee761fa6654121555ad5efef3e434bc7d2edef05232ade3fd0b1c9871f762c1d2dab7445cf046eb73283e7665ba08debe63fe822bfc6059b5615b16e173c5f077805540a96518297c971a3d5fdeb81a4f17ae489ac204a3d7d1e614ac7754846456b834ff803f9937c2b1d2e6507540ad1ffe9e61ebba4e03e888a2f2d6dd7c79dce83020396d3845786ed994f31881839b55fb1e6db5351500a75e0ab2236fd2fa3171c0d26f0c4adb6aaabb5cf233d9b2d76ddbb0dbd6da8c0b8e1162a1b2d61640c7a100814050425e122f5d60cc26853a0e63ed9a3e37e83f908070c0684968d9a942f5c4363632fea3728e8dd50ce49dd6c6635151ad180743d6a94c01d8d6a363b78fd9594aba06eacb0f14f72c92cac914b15e7e29a4b8fd3e2bb6a5494d3babf40e33d0e5f50c3ee2ba39c09075bb0dfc67b5c1bb91a26954b434b001babc290fc1aacf4e9c75862f3ee07f8ab1b1b23b3d68fb874ca138c9b4ecfc7c149df158b3dd85939360a59c8ae07dc7e52a493a9d8bfffe036cdf8c0ab5a4419d51d044e46e62b3e67f3a4d0d32479c278e283cb0e65c4a9e6540fa224a5b79a864bf2d4fe29e1cff2f0070c7a14f92f499c4aa0e13d5493f8a6f8ee71a6a852ff060e63fe66e6dc9cef6cf15b09fd315de4d57e08d707eb94b99bddc71751e02e9622a0fff17a440f61edaf22a9557abcb65d5609b05eac55a2e3c097bbb6b6aeb46a14c35119bfb3d95c87e6c57d7af04d84b53e824a21a47580c8743bce52e5208183eceec2cdedddc659def8b85d10ed79c3f1ae4f2e25193fe1dd7d893c013c72dc5826d7293d8b7d71938cdeca0275a980741f299cd21e17e3c3374276e6624303015fb3d966aa892c0caef2e12662d7f00226f0970b29eaffdaa44fec243af7337100199a4d7ba5009f62c50b68ff1fcc610c14ebcd6368729176bffa741c38ced4e53f1f31b0c0cd003956dc97e40d9dbb041d238ed3c99806bc23a5a86bd7b355302053b52ebb64e088e04ddedecbeb5c5341fd59de21cd31fc119bf1ead0a79ad5f726c0913ab36afa63d37a3b7a01547eb0c6353009810652eb5aad52d60ae45c9f23259edb86a957e141496d4ae8397f9ef26d805bc7f702854517e385d04df6d95ce994350d733bba1b4725a52baec4ef3aa4f0b63754ff85e699eea2b2a9b24e019f8612cf0665b3378cfac00a45f7005a582cb44f537f677bab8c5cfc92a3406b94812079b4832076c5cc919f92c18df290753bb5f48a3841135263fdec3fd42ac43529875e8104006e34c2ee7a16ec7fd15a211c380407319633941d3e397e069a6efb889c04f24ec70790b3e5f4ddc3d8bf046cde5e63b10f9b737356ddfedea8ac82fdf1f52914a2ad89064e0844e5df8b7bffb6bedf267656d479e929b10434ea395e2170b9036c6d63f4d0bdc9228a067761fb1a9d25f7b16e4da513fc904d9e8e347ff6486e1708200643e2047356e08613ef6ad0c906eb7cbc0f6bdb415e49c4fd70d37e90e35d99281b4b32a5236e27b2a4a70ce0beb7f6fa37b1891ae32292093fa550c5bc00b0ec71d06bb5e159b60f46234354ac3e323049115ded1225aaff83b97e5ee1c5955f12ad8755251a154776cd8fb7890bd52d854ef9524156093d8c2b2f1416dbc17fa653d81ce3d28752fecb4532edb27dd5de1d19b254687489620722c604abb48cdc5d371d4d8dcd7a1dc5f6c0751251528f370177d62aeecc2535b4c78f644cb84636fbcdbb57baddcc8628ce847567574d263c06325c9323748a8e253aa2732c0405b3b56e009871f952b16f3aa0df6b9a739ac77e908373b55c61c1e7e36794a5f66c48ecbb5ec794f0d8f33eca64d5cce4a166a212aed52cb9c5301238f7b8beb784822740832139a4f3ec74c0f82678f6b5b29403ca9266f9550a9505a3759a9c045815be028e2cf0d57f277c5952250b416818b54e94ae4e39587e44bb9f454469812ef4702822aa19c7649f744d76eb78ade49f8130993c7046892611f9b3b2a906f5c859f164fe8c2e328a8bf666a497d23696fd790071e719be48fcf196933949a96dad67e69a63fca07ab381a819fc6b900cba7377cac3c580537181799ca124c5b203801450b14ef96c96706d531b5ac36f57bee66b6bf578ed882108c9d533686a7c29f6f3cfdcfca962acd954ba8c337f1645cbba95b242206a9d1e9c5f117b79dd0e58182c2d0bd01823d373c860d04afde52e0c01744a97d8779ce106df78e19fe24d7b00bc9629ac3d1c84393ba1d01dfc82a2dcd4cb229699420097ec3de14a747690d188802629a204a6d414686db018fc5b69a2f31773f45989e085da7fb29177d8339789c99bd2bf887172192767adfd36e62d69434b83d59f940385536f575db41353342b8e4064c58a21bb022d7d2e89c6316e05243064977e668bb3dc8e98e3338369551dba078423bcb83a3d008aea78281580bf1b9ff69982db6f616bca5895f395b18b16f60d5f5c54eaa44d9449ce8f637a2837899f0d96756a4a189f7e636429a76b8dea135e70bb3d6fb7bf4c86613065a946395460902bddf0ed11b6b50d5b58f9f1513fd37ae16191dc1f797a8437d14814a5dbaa94e245d7fd5b8e1b989b7cd3ca4e199e3e7d2826a4e3957cf663d5b6f2484967ca1dbc61017ef65ead8486a7dd5c06b051f7e802a33254480c490022984e4df27646a12e48d76af0f2df43efe3ccf4faa182d35053f7fa80de6ca33480e8fe7af9e6344d2e895c2ffc141059d1d7e8805d16ca506990bdb70101ca19b89a647acea931ebffd67ffe8e89df3c8fa240c1a32c74fe4d21296b3776c6f8c3cb1cb9fbbd212fa3407d9e3f2ffc47501ec27baa3b37f99b5e0d8c07115e07661d4c615c91f9e989692f141d401b4bbc2553f077e26819f75415afde5dcf15f015ee89ceb5dd72cf27d0e37699fa80fc65299fbb0f7c4a8371e865d49190c33eb82ec149848a6b2d31e15cf407314d3ad75a725b66313e9b30094ae06980b7a55d2e8a97779797f694f29b507a1488b009183c33d5989b541a166859c3de4c7be686c43093a5206d39b40877cb020608da764f2fb59fcb1abfcda6e4c8c370596d0307406836c7fdb0730f5f910c3d075dc1c037cf9f0a61141a92804f2a520a80313b6cb3a5f69cd76e392d215d5d916f7cd1611ac0e69e6cd0c4a388ec1228f3924f11c8992330a60984eec3f873b37b4414ed5c4d84a013d650f67bae2ce59e62264571217e781ff51c6529e671694df477a3c3d3ce48eac9601a27c495b3846250c3a8ee94871e6014a5909bd0cc25e8804f24dc6a06802cb5cd7b522960c5540acad0ee995e63ae29393f151cac000b418128f4456e45277dc953a768427177d00ebbfe18a4c89476862a66a23eba3157cff87a6bf2166985368c3a6e555dd875920e6fb22d1f0063fbb9ff717fa4b1f0167e793c73effe049512c1eee8e9d34859f69299bd8613002456c0857e7c2a2c78499edce346ed41cbfdd8c16d8f50698225d414d5870df47b60589d011428f48af0ea857beb7d4295fc772f0a10f8d1250551a6603ba6dd5f86d37b58f40126e8c9a65756be17806dcdf22525ce6fd8e9a4931cb9ba92aab1d32fac23c1d102c5404a4f74a56f4a8d1a87a4d6e093ec772c3608c357885bcd4288ff72117cbbf8fd9322b22d5be0b439d3b92f6af7d6df037c1ab2d93bdd5b36da7d42d35f91b9298eabb4e39456d924194f1fcca508b6447abfc8ac3948372921e30ea4c9d9fdb8a41d73ffd7feb960961dc212f7cf0f86b3405390fba3af470fbd63f53c724690c7c670602b78dde7f2ea49c817091205c4cc997cda6894b8cc5e974c5b9b306d532628274b276a5be515bbb97cf129288dfb34c090676148494f3912eb642d058b94fb9fc45ff7e37290dc345cba443111c9d7189dfd442a9dcc23a57cac3c6035434737c56bf9a4e5841135bc610f178d4506e8f3bfd5135ec79b455ba4decafd0e22e8e1cfc8097965c44a7c076744f3ad18023e5f4cb3e2422948e1655a54d1579b1c8de17acdc3328715a55fe7d11502d3f84631f9bad683af4b8d5ea6cb111b33ce2241a99dc4e72a38d174e191509446ccc764fdc9cb7aef8806d4cbb17ed6cf0f77c706ef4313997cfec1c3ba137855dfa5820671f376dda36292b5391ac6766aee67ef13c921f74051d82155a6e14e05bef14e079ef01b9f781cc28e8f501c8793fa3d17c43a6259abe9a51a00810b0a7d56597370014956b4f8a467e52a5ea63cfb4feb37affc42c1303e611118f4965cc29fded2442104eef9e5f52bc8632a780f2925b7ccf2b94b228ac8cf6d86cce5ecf5d4eff09715ca997edba8d1f4ac959b509e72ee45c93a2056754f2aa769671a3042a2c091c3753cb73c542b26d3bb258e3ed7b05206be0ec495830561257e925980042838d0468c9e809b2fcc262ba7bc85c871003d2af6b07489c6ffa162eed849c510d7c7ff1aaadd18e3c0a15aa6f8339209d288557e8a93e2a2c6779230212706f7c737f11294da6ff285570fe88b3de07c0d2f85da14aa20b7e62933d4f231f2884e2e779c3ceacb7b1fb38c9c393fae5376bea328b62b8516a9c53fdf896cdde97af6cd143fcc20c6d10b8bd5a29ffab62bc72821931467e79a920fa70a4a54a3d253cadeff7d7f0af73cb9762aa3a63b1f7843023442a12d76d709f27d8d95e220d5d7882cc2cd315a2b6aaf41afd75d95e2ee73d1b868faaeeedd2eccfbbb210a0ec3286cee9bb1d7c2431aa0dec9bbf787aed40da78f35002e7aa45c65d8ce0090a39bfb085140f250445487528ba381e45868f3fb7adfa205274620e94f8f38afc1001ce9ac2d44810250b784daf31c8d3e62d8444c6aacb74d46cf84c0399e81418c20c124889a189f5d35929feb65aba7b10b96c229bfa89c6d6a031d90bc43423ff6b3373ab26502c56543ccf8e1af03530c082bbd6e9a23ebd6c63a5791347ce8e6572fd2011236b8db461e17f5a17584b2b2b0c9d7b8a5023e15308b1e2a8e5bba3360f700baf31a3380d9cdc7513a9a2c0bbea204d7f9f3f5b42e67ea5268472b6ca43d4db577d4928b7d23f996dff05bbcb30b6cd45918739bcebddbcec35e2cb9cfb40bb2fa8889845e6ede6ad081a1c9fd64c0aad6f059d20f352313230bcad839025df2ac204f511c9d9e5705659882b91845c87b82e6f1ff3437526cb44784d370b503496974b765820f93afd41c58deaecacacb323161d8fcca59940ac38d2d6dcd36114837d731725495424b61a5e630641215962d03b2537e9dd48234f4acd29769f3951dfd6fb3b170bdb0a9e2700b13e9c2bc25152effd3875e0049e6ed2ac2e27dad1c671ad5f14abc3ad1e2481b27837f2742763f3d5f6669378ed741c0d201537e7098e36eddf66831d3175e589bd82819315178982bd2bc25ae8462671ce5be579bed8ac3727f57d17a4000c96b66b2ea35c2bf8ca51a7ff649eab4f3fcc9e7cee70cbf92f74a7e8c025659d14ac7ec1f8338a9f7dc1465f980f9cc9062dd8f6f0db8c475e8ee18d2bd6c15af62d728576dff7c17a4504ee2166d6120ee38d157ccbec83d069b1bbbc788300cd4de37daa230beaf856b94027d052a1dc07bc3cd43b73b907b637d8a842a939fa5dda60751ceb10c5aa1b00bdc3f1b6664d251e54e3abf87cf0bcf688e2f56e527bcd096c48d1673d5128659ed7e648f9997fcf2d688b5ab645560783d694a1ad7b32027313d6b4cd5ff1f9fb07af0c34475c7ff25a0943b4c68bdfe1bb4a1cd40c83a48b4b69ab5b55d49c817e52cfb96ce19c6b87b6f50d96798deaf0bc4a3770a925548c072bb0515fe9b0ea482f63d616b5e71777379e8e8d68ac03c2665ca13ff777baf3d254c69bfb5fa7a1ce01f0686369d3dc9629a81e7d458f9a2bcd3d84d3550a2a9a3e4d48f09b8716d704c0cd66fd3be2c32adbb38319766d4f30f331fa0cf7bf594df363d7095a40a5de5752dba5f562fef781f05b923ec73661b602dbb726b3980002d205c6a80f07e4ec82d5bfd9725e7c42ceeff036b7c756d297e3ddc5882146acb17a7efad64892c233a89ef99938afb0621fcfd1d53db8cd489b33459ad348c238f31cdf06ca30190e3a171c9097459426d4f387fafc58c5359c001ef50a9e92a907d082ef6df446ae99eb61e61989d311fae52dc0bf041783e973d72dc33b8cb0961e09b6441cf7daccb3e43582b3dd2a73b09ef2d3b0e54327488c7b1f75ae98528cab21a2c336d209d369c3d1b45096c8db72ad7cea38d82f9966a2f669faf5f4c87f3853da193b9328373d0650b46bea5778f7d50e361c1fc1bdda387defadda17b4f18b67f595d302c860a38d168f4c4875432fa23f84a5908d969d44611365230a212920d7d6fbb9e212907c7fd34fe4ff92e9001ca9a6d0f31636edf7fa51f6e369b2cce580bc8a9fbe1e40b10cd00d5913f94f25f577027cda5e31400c917872e0230b644c7be2be36ada328ff2689b42dd366a1e9595f0e1049f7df238807efbb3b916841e047799aff3d847a252da385b53b68f4f520ec7de5c32439aedb5bd3dcf4ad6d7906ae9977b8239ebc7e532b71e597049f5db11a5d9dc157ba6a3f1498340a6c48e787b730455aafe42839173a7f41c9a6e2f07c79ab268303e544ae52d09f83545ba79f83527820ee242e1818d588630530ab9f09116c9a5532fbdde224be1daa1de5f2a003a3710326c655b577387733873afa0ba55c455a277c975315cb9b418937938a17536d6330e83e3afe8c2b41c8cfb8c73f1871444ddb92bf44baaf525366d9840d01c6afc803686a93706e2f88347dd18b0b3eef1f768dd0b7b19d0f43920e67aba21d3e829559ddacfe647c67e055d4a8dfdd97d49805c1ede396397e2597b419a392bd280ae0c69f39823443dac8c03d22dbfb58c1b5fa7db753caee3ee57d2f1012cef5f9563388b49d3036617297fa0acc827e8b57954b21a2bb0e6a8d180392910d5e16243ca4043e3c30f89632f12bb2cc4974ffc7782e128a9e5fdce5d14c2a3a0d35a46398a1317c9c4bcbc9b68514e38cd249bb7d5f7ae14ec2a060e0c56e087ec1a89d2b9520b95433793b9aab78a9ce571fc31d071af8147480d8c0f77fd5658d2e5a646d1107e962312d2426c39770a75f9d57ccd3a71b28647a4993f447c00e351b6982f655457bd2ae7d067ee7a873284d2b83a9bed6253ce9a47fb61a7b50cc9d546d2d01e1bc1991cf19846d034d81a2a1d4343f1d691f94ed8af7e2344e02830f306faac02563405140ee417a4e8259f3b496ded26a61b9afac4ce452883d7b3c3aba2ed82af59360a7f75f1014e41ee0f6e3e9fcc5116e75cdae47551f8e77b5cc7354696bc140e50b4dd0dc7902223052d0e14128506fd8bffe1a44e6e52a2ae2f747691b4781e49d22e12c58db98ddbe3bcc907256fb207ebfde4e454e735e97491eb97bb25c95448939ed9a69f775987e37cba04b2c3c1e9a02d4e5f6f10cee7839063973477803180f5917ff4afa81bc2acd8f9e3ee4198003c4f5636f8a147ece59c938a25c52bd748754360464caad66b3684ead48be03dc8bc3fef9925c08e27b8e21eafb4ffc1003242f150f77bbbea9265d8ab77635ce5b62b8d539317b1ef22eb9d036ad7b3023b0981514be9dbac936132dcacf85721813385c03df612b8c644b4845a1f6f193b38bce0dbe2fbb5aeb699be9d875e2e74295c064af70233e5552d3dc8722cdeb814f57c13ddacde34479e96efc2d599412bacc5c272c993319ca8dbab18e355da7408381190ed3dffd69f7369b108dd7eebe7c4e477394cad1752227ba2d922f73148954397c56bb346fbdb2b76a495db36c293d1979810407ca8dd2a421b888db2df28a20fa62eaa38c0573195b95dd59b98e80f58ec17654be38bbf2e183f3e154d772b29c9414285e53628023804108b79db4f7045f7e2bb7c5ffa2d8fa296c20d98648942b2324de2f86dc0952bcc09fc5f288026befb5419b2ad9469a3bb86da0f01fb58bea35e88b50da0908caeeef742d791489b405e578f937cc23bc92f4b86af4b2d54ecf17ed6783a385e48e8d4601a6f8ce5d100ba70caae1872bd787e06303c84539201b7ffe8c418584fe37893eefa67f6f121a0fc5e321958ca69bcbfa19e92d370140226f1f53ff20ecb6a2b36d94965dcfa044bab02e6dd0edc1c505cadffb96916a4559b5b31bcb4fd0e4472dbea5f9420bcc9202a478cd2bec7ca48253552481c26ce7421c8ee7c4721ac165f58489bc7aaacfd7bc52d19362c9e41197a06e61f8c609a8ce7c7628b1c207bcdf7883fd42e2dc7e63c8d4094b4683a28cc5d34620948f931dec360f54a9158c921ef99e37a9b1d44c7307e920058b36b2c1496d5c3834a49bb7c9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
