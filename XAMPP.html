<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0954c9a923d07726a9e1feda075ce766c9ba89c0a2032a5113ce4d6d2f46c5f0b7e359bb7cf9c0eee71446c7b5201523bc6f3935636e2cd13b4f47a3d569f11a966e71272c2916270d1034d051e4dbfc47517cca5f9029fd50bf7a9bde2f7c0870bc4bc62ba4728c51b2af5d3dd5a7f5e697a788db51fd8d1e8924ec98d1f334babcd10f6965a7a2e40cbf77c74288a1830f8aaab5ea8acfa5a972551806c2444f9308f74e6bccca9d7a9aad2ed6f6ed2bb0ac13833eb54e796339eade376507c6170655d577cfce27cd7c0b34442d53236b9a7a225442f3aab38381aab1e6e1ae2284a70b05aafbcb71f6f95f8c78b07a3842072a16bf24680c08b8c337bddbaee4fdb0bb060ecfe3b395a19f1e2958dd13bd02ecf9f88cb862a4b492d8aa4f20ac199a1b48c250d42f491293db537376c7c347915e28fa5ca75d3cc30af8927ef18594f830da61dfcd5009043fbbce5307f620123e5bc72575f7a7cc614d1298a88da5a464c31e9f0fcf8b195f970ac12357221d6266447a0b6b803c70e9ee513d798bcbf6a924d518c6434f4983b07bbb5a2efe9b8f86e871ce04dd2f9b856141bd487f16a45171d3ff593642152fa3a8c12406b1375b884a787f2c5767babd94f9b00c18a76fb4fe1db03d109c25c360f198003d25ccf92c53b6a8b9d390aa7c8079766263cc3b64e87f1110b903bf781560356ed7d16367e9b6d2bd7a36ad96f6c8e736993e533465d5bb4d7ca3bf7727bb8b00f8603c377b0606fe382d6fe03020e37330ba7685d8bab5f286dc156d0a7308632639fcc61b6bc04008a0fdb2b0df9a9460eab4457471720bb0980f76b70228c25081e9d8227fa50dc7bf424f443fa8c2f52c4a2cc52e37bd634d79e705d0200e8a8d666ef7f6d3309e91468e54db66104dbc5aedb43c15268ab042344cda630f9f1c0bdc9a7901c6d1c0762fe6bdeea3abd424f4e75f9abc8626d85007e4efbbe2340744f02d1ce189f99e2c229d86ba792ba65732a0c784490aa7fb463b6e17c1d40aca113287f718813bdf0cddc036334bbe6ad39c7eba9c365b9e3045d7a00adfad9965ef80755481e397440d2b44198cc4c3df4b16fa933abb5d9fda7c395d2029ac14acf590d284790b8d40f27875e6a03a63c53daf07d3b359bfd2dfd3f82f327dd8c74e93267ca739f07e7e862fe31db3d2e84baae30d2038e0a6b12076fcfe5bfee6b9992be003857a3d1959e874d0c679d626f3178b24006fec1c321a727766f2bdfd2513c49b44633bdb64c8412de7238db2995377b8826c798565eaf60b52347e7a0217e29ee8fa74e84111f9d77d87d90bbf68bce342534606ecc30524f7248758cb5ccccce2797eec9c34b13b8ee8ef52719d3944ca2eea391cb1d3567a680ac6423cef6fb5e9f74419d6538c7c3fedf551eeb3a533051c973a73d4a56a6eccc3693c1d18e883ca1e82beb6cb42e7e744119bb3f97255a7f634bb54439e5fbf41ce380b8176b117248b63a93a431c0a17854e7dc728a4f3e95302434da4ff65142889ca9e4b4712e3e1a3887e75717f88f0bbe7a03179f8a5f0a1469edf853200b2aaea4b42e2b25652a802ef984276a6986ef4193ab5cfdd7665682b5b211c70de3e7e85c5738bdeb59b83554d8505f058b18aa31f76f5822cac1deb28bb1ce0b5ed2cdcd1db55c60feb1e10a3ba32cfe0a17ea10f998046065929726c055bd864b7039595ee2369ecf5b661a00fbc49c162ea5e71ae607336519af99e8b3d8682cf6ffcf0974cb9016b55a5aeccf27a95b7d9cc2eb36e9c2d4745879fb8985730d9d5fa262842f77cc11fca4d902d32b9a938759be47bf0089268655d0b175719becb4d3a86af693bc59d4f4c865994f67268d1506be9899cd07a6fe9a28a7649cb722dd3b807ad518ceff2008d7ecad0573c4e71285429bf04b4ff772185853ccc153f2b6e1ad78af0874399859d6abfae10fcf096032dab8bd6bda588fb84e05ed625108e1ebb8e1473b15b5e090a7f6d38a78cd7ff3f8148f28b5ad44430f632f77487e92441ac2082904cca68627909c9cb0c6ca39fb72305cf4a0ee92ffbe10620f699b3d455b8d1bf4b8cdf8ac9814d91a940c2a3c09f2020a36eb0e55807925f3dadaeafc618f31839932063a4681297cfc8b958e8ef798ac85a3fcb69e72ecf1234eb0d5eba709fad6f44eb56f56c7a13ef60a7cba43e9541e59b4a15d1999f5d2d879aa6238fcff752377d97d763e226e873248871714a7cb3e839aae352ce7e46b8ce101613c74a725e28ca0bb88aab64f971b8fc3168e6f5ce3e4adff7d09aa2cb2e6869445d509478672bc0dd810f55cb5a836cfde01f382e4eac35598e0a49dc62776c9a91711bd154f3956a32930c067c9610ffc56347cab29c69c19f5e04cfb50e362fee419b60b8e6c55fd797235d272950735487b2118d3877be632727182ff751ced9baef1ac61aac2f0f6f530a537f4d0d5fd3c748fc738b5dcc3aa4bf6fd32b0293d37912cddd346547173c9afec8334ed34bf0f5a95c161b4a3641fb78b8cf3c000eb0d745cc658fc51f9c90f765f46385663b879879f126584e86deb83c7af353e52629cef2b88910e69df2936182f6b3729b4ba00d19a5066a7856e23123103b5ea8d55245e90d846b37d028a2ffb938f4a3497db8d744437d7fb4721d129455552f2eb86b62664162710fb501f5f9767aca6fb24e047fc1bd0d92cfab7817d56d51588f4e9b3f5e4a57525ad4f1451e85cb583336517ac1fc038794cc69547cf7f72e3e9d6d1f50cac2111273bf328f86bc5017379264e33dac351e6356e24786fe82ab1f0658f56438212708d0f62f548a62361077288aa44cd1ee9dac45356358f6638166cc529a9c48de0130b4113ec22d1bcf9412240789f9afb31ef1a33be4c8c303757a030ee2da960facff79eabd09104791f24d062657b2ce2905b290544a9a7b333e2f62c571c71d4821cbd55b5d6b6242dfba8455c363b32952e2a4d519febe319d2d3300dc7751861f6b283433e6eb7ba63a782ffdecae15f73936702d29cf28cd95d7ce4c1d9a64a1513227f58714f3c2380969b3951d924102ac001024902bd2d09bb71bdea12dbd743512571de2df298b7f00ae6e644350cdc0fd9a451fd6123e9e357b4cda601aeece85a5c8ebc88d9a3e703bb4f905630835f511ac16c160128587c78db9a43abb240045cfe1d31f5494a485813f0926d540db8b44c48272429012a5bfe4f8a56ac53446cf72fb783f215b7af5e221b10edc2ac8a5b9821b49a2dfb59182faf569cdb095acf724372494e8b9b29be75d6b0d91456f13ab7559867931d49e17531552d78b14137676db0aca9d3c9d5aeb6652f3ff47331dddba1dc4cb2da4d8ff02c8c5fb11a7e7ec8296ceda47c08acd0223e50a36c605bcff93e17f8ff6e93a47f29e192e3d3294b5f14f169335bfbb1cb7b1ea576c8f1e48c25973125b4dc8b78fc22e5b4a974c5db69ada313b3ffda4a95c2dfef1a5d4095bcb4ab31d1d1892c0649bbe7804f9c73aeeff0c84a28e7d89e0f5c9a440a209ee3796395582e757004b73168c148f270b82cb53550d7fa629335d07c7cf4459682587f573fd5b3f50866b52da82e934c568367701cd83f183b1b39dc68e04f99ff48168e0bb0d497ca992a8ac220ea0d0eda8739f177ddcd6a5899a85960e3853ca5945f7066efc92f20fb21ff79d7c69633efff797ba62dd987a6c3737a17d69254dc7d73d0f5fd5341373dd37e89e6cb7be6d23fae99924338d48799862cae68fe35f0850f3adf92246a42b8a8b6bd6df743b9a1f04bbfa2774dac6aac5f175de5af98af08a5db0f1978963f342b7d90949ccc697c0162d0171f28763093bae8837039dcfa6fe2c449cb1ef68573691251857961a0d3520ade45f4259b049adb155f9c6f0e8520518c0363506be27c05a3af03da4191f812ca74d91af2d45864827b8dfbc25fb50a5bb7a0438046ba22897dd6ad0e14b768776e60b84ee2829bd7c24245c0009543bb1cbb4a6fac768660e5a01204b594a7eafe971d5283d131848bc36aff6089051f1a9d8604c715edafe323848e93849fbb9ba321fbb988986697a2d2ea8949bb994797c530f1f65bcf72b3005e3265d8996f9794aa8f9b9f5bfe7dea0203832ed3b0c0678f5d319d39c6fa38cd570e684021db5f30d38dbef745cef5696ca3e60e553d9fee10e31e481b7f041ec3a5cffb8ec46fb9306e65e17c99559cdae82c9a9e72a72d00687f9bb2d5bf0d701bf4c3f58777501999650f0c691e59fcabc04f4d2f7d4159124b5e218aec3b3e76af6b8ee0b2cfce3eb73a11477d2d11c6c9912b1b684a6bff99ace15bf04923487bd7cf02b8615c19a37fe4d1b449a50a3b51d9907b205504eeb0177f15208c5e1803b8231b925a7e6594b78687767577a15ee61b233f7e8714df6caa5af247ab2fea99a544946bb308aac25dbf6d098ad93f9ca8595ba1d22999e83fb4eed5a6900e8a825a2e3cc23f5a6c87c85bc37eb146ca17b6d06a2e2a17dba5ebd4498b17df2213609fee49d450aec3190f52cc5293bd234de5f4e8db772e8a122ec50eff1f1d3742bb40f572dff10b39aacbaeb54edd86f04645264f28ec73fa4fc621fe376f15bf05e3d637101d10536dd8a92531ff31bffed89e9905a357da3996c4c8fa918a6e22a0e9b0243f4136be12a685fcfb85792f6dd146b6d175d5c093ae9b29b3f10e4a4dc8306260cfdec7aafba1fb21e9c4644310c1ba896859384a0c58691a9727d44bcaba26453317927360cc10c2bb8fffd8c4666eb4cdbc7c012c56bee0c95cfb6936b684f0d94ab442afccbcf0e363136d905a5ec925826fe3520c342eb7afec8a569d9f79879e85bd6a959cd24763be8d7a6d47645f69ac608d726a49825e35df73398482a06b0f2475fe937aaf9e8fd5893e73597e837334e59fe0290555adde53ef74fd9669bb569e4a194d3a2932ad2db5d1cdb8d49e18c416f5974e184931b583d0b0466e63be35a9b7f6c482909d837c97c7604377d0ae490f23cc6bb062d01fc9a90acdbd6fb005418fb8152275f4b3d312ae15c7c685b446ef13fbd4907d9283016c67aff8bbff83226f171d8c7b70cc10740fe49d617e871e221873f6b1865be900aefb95b293595378d3870d85f22cb9e63deafcdb20824d22dae0a9e2a46de19c71096e87f8abee34123da491d5ebee53d006fc73b307ea70404c6297a74a4f49f9dbc57494cc3a8fbf593e0b5bd79512f40b6cf4be3682382ace291d889dfb4250b31517983f1b5ca3f2c097753abf3064c8dc00db027a3e3d25cd36d08d3b259a3f48eb3368f9852dbb98eb36b03b48b6d9bab17770202f086e0adfc1e9b92b9140967b54d5a2dd9e86f8a4452cc90388917d40a5ca6fa0751756dc74479b05b398c17dd144ba59bbc8764a48c2bee30b02644674d35cd2fdea014d31f0433c6a4c059a352ca12d3c4ccdf7e4dc9f7ee8e1ab10a4e7652616cfdee974c805ba5ca022f600b8807e488857e498b3a287a8394a7e9e6e77746aa4cb9fa0fdc879092ae1a62ebfaefd61ec879dd32af62b9ac37abca50ccb38e15641eb23566307d77c83e9611b7956a1067e86be27ffb6c7ac0dfe2a3c4cc99b9d917ee1124ff1397505999d5d211a871dcbb72c91257a472f512b11dffb54d54ea78eb93a8e9e23bcaf9be486546af7270087add2e74808d5aecb90901aa58ccecf54c059e82c6315819a4347d83a4ad1bb331ced339b910560c05110ff0201c5f5b2cae9574967f60f10757892b4bab97ec07354a63a876e3d12c442b28016c8f25c213149c0201bfd11c58f1f5bcabc40e38e8c83cb02f4109aa8d58c8c191431ccbdbecb263e648785d421ce0d2eb0d299fe21f2689d7374e90c880b877f86d6069575b8095d0dc59f5f645aa6dfb3bd89dad8d8e74b2dae3bd34b86591686b1987c70967d93edcaf99e9dc7675fd80b38b88d057ace295485569ab40ea14431b90188fc9b3e07b84617cc740988a517d30a07c75f7e632c061cc7ecc2f18e1f7034a90cc4d8523167a5cfb484be85bb8ce500956520a16b54cac3d6a0420f466a98a713b4b37c3a2a426ab0868fcf55adc41d688b16e8211843b633ad1aab12416c060a7df9556f2ceae5ab3072dbf562daf60969d6eeaf495305ad9717e8c8b6f3d707cdf4374dc2e17100be4d93e9c509bc8244331075a9b88f1e5e1d6f18c8a0ec120d3378d2d295136ec6e4e332a9374a7feefd8bfd1a957ad1db6ae25e9578c81a8c13a33e899f934c879da7bc09acc75659910803f731b72a5b53337b0362d36d500c48e5ff676005f256811459d2c328d42c60f168c9c05dd8219db2d451259e81f088e434a23f753fe1cdb56d008c227271849d043a6748ef2a994795f4f159d3f7279372846cbf54412daae55d958e7d7b6747259319ed044b61d9fb3bdcea11e7c9667eb24eb712ddde4b996369ac565aa452c70f9ea0566b2d1ca9868fc37002050d58a0eb44da48d48fbb9c18152b59672b1e6b816ab3d25dac451188e813f9210a9ac11847f5aeb275b98cedece64c7d209888bc3d58218a94600511c1af3e9fab8636b1aa0b4bf784f03bd5712103a996c91af3d231a6b90836bdd1dc9c78ab3fc084a9522da7fbd4d6756dccd73bc29df911c59ee31049ef23d85e1ec80beaee927302679a44c8124159efd5e6ca44fb28ec5b63bd7f5e98f53b5f736909e978b865f5ffcb591504639158d8ca1367a81ff3043a33ca4d9abf531666c2da52bef23c15ec5ef5b1043fb66a203c419942d1406d077cbed85e55ebf449b2df6f73b70b1bb625ac39266cc8aead90b538511ba7eaf64f70fdd0947168ad3c366288a88fde4f97052b4f58484d7bf8f73351bb1ae52983ccfa11a0a1d775ed0173aaf75e5b531901ed315b2533338deef2c808168f122fe7dea47610787bac2f98e620dcbf1caf1379f9bf5504fd22c8fc49f913f1477d12082acf217432b0b90d31f8ebcecb363888439ce52059b605c6234ea9f515e1314ead373fcb71eb55ebf8559c6cf13c7cd0f47b7fc8a7320505706f991c8fc430217a036bf062f76200049caa1659a88bbf4fa3b4dc5b622879ba77a2260b8321409aff0607ad865106bb1b95fb97225ff6f3f49a81ab66232d2302a3215d636e148ced53e8c06980077fc8cd999f5e2ff414cae030bd83955bf5e4a480e4428b687c9c88124acb05c6cf42eec236681821aa341868a304ef570aa545ea62bc61d793b13f25cc10551a2ec1b79bc1625c18052cc558a792e7549414a1fda544909f2e2002385bcc5ccd4046966c17f25b19eca1a40aa8cfeb8769c58115a31ac37f87ffd65d796364774be171159c1d99fd4884f3db969d3f90184f63f20b488381d5a330f3fbb9a3a0842a89c83cfabaa1b2ee2234164472cc420863a8e2bb3692eaa365c281648cbabba4fd688d18db1e5948a720a1f4dcbaadd48b6b9d3aba1dd6c14459a403fbba310aa54880de2387b7839c3bfe341950cbafed42771a9567c543476ef326dc6fcc5afc7ad3f571188410f3834693922e14b9af1f02ad4957d222bc4ccd83535f2f519069bc531c7bb3d43aabe66081440f28260ce5066f43c7079a1850fae82672e626ee42e25f50c0f838b6cb9227d8e529bb2d32acddcb5c804440bc69c1800c2f0e396907c64043a69dac349abf677348181d7f1cfdecf3f15e1814513849e29a3a7b6137c5b58d817077ed39f64a6770e342b32c6884eff7611d096733cb4706c5442d310635241fcb72fb9127675a9d1c02cf6f48dd56e0a577e7716dcd89788857f6e7c04780410b950f164788464b42c9d29894077dabfb664cdd0be2066c7643629b43d160f4f34e83431f7fb9483b94ad12a1306ac971bae9538e881e0e42a05d12e36ae6e01da4d35ecf598ae7e455d6f8233a606c84b00526b9b71ff80a59fa25a326473854d8d6f69cfc7010b8ed96759a34c2230d54039f839e9d71d0bd7889d10a2b422d0d3dc0e5f6586587b2d8f50e78f9448119304cd047347de6b4c71ae75738d687d024a8fb0cc7442ad7cff43094e4680ea9e51f1a3312b4cd65ba64bc0c1ac6bd77685643e9df844a3bd41236b84935ee06a67c1e2c42e696a68428820e5466b3bd7909fe99c6ea1632478e2b49f08019f22d2c438072bfd97366905b203d21691f535699764f0309f159eab35b5259c78f69dec07f3b648a441d010332c1e8c86cd362ec03ac2aa5900d89c87d8d40e8db31fe7d4e41981e2cfb14b6e39e111bedd02723a8fab5707ee145ecb90452d971f27f0f86bc004c6682ab2297bfc38ad1bcbc30af018f5f5249163f27107323c25db6321757087b4e42dd8b0f2cc2e1d0282cb8c46c4def2bb44f2ea2a3a57374fee24eb7c3f8a93e2ff4e055250c1a2be754afa7f317414ecc6bf817b0f10f36ac6f98926bd07ecdd445a4e86664e7f3d2350b8e798cf39b24af5cd1f5648809282f3edf06c388f70bcf0549c6b2377bc263bb6980892156810e479b8726a13478063674b37abd3d12622efd65402a855242bbda17a49dcc176c00316ed6e65303f90f1dc4519e9b88d923dc5e1393a36cc8c1d0f455db700327b61b19156e49d41bd64ab6426b8657b4641b8c1c555c8c6c4d7915c7ff1667af54218dbfb2e7046e91f33a20d169c024d87a768a1431ddbd514b58b797ae0c116ef39d4c708933a16521b3de6985c001b0c6c3ebae397ec50d62a70979394d515316c6efdec54a34babbfe84eee04e8efb10971cfe2ed5f4ae9741a4e2a1c2ea1c9533a280501bc8cbbd0d93dcfb6a8f07a68c1da98b2f80a0ba518ef4af7a8f6165bdf3912f7aa13ec7f91897d229fce9205f4f11af115782399548e93c85fcd79eaf427b37c878509609bd1ad5629ee516eb184e79a1938f3376d7ed8e001474f14dd13c219b6b97b08826cf729562f0bcad029f47a3526875b0c652057a4b3146acca61b08d7380820b3b8c0c2ef70a23fc96cfca129d91d3f7152fe815b9bfea35ae5c7737e807e4421b1048e5a32d6dd75334adb9109ab1cedef102e39c438cff8a649dcae49f69854d60bbc3ba2ba9d74606b07672b5beb35787f2449f0c0d4a89ed6574d0870c88654ff02f5a69c61b1c2a3b7448f1c667730a4cb3fe7dfaf13f585b63765dfc7d00b9eec2caa1b8d64e6b0b664a95f3646d4c2483bcacf5411bd50af3a9ea2c459c816744e5a7f7f287298443f96ff7c6740a178366303f0d63acc208e2ee0e28be8c288e76cae678d939c7fc5cec90101d83192646e7277e1e8ec13625f9e275f1b92997db4f530dca52932c034fb5dc61029f3523d3e959b93559d708301202dbacaf96c33d27b43f35b41f5179852041e6b27fba8fda50fb5c7d2a572ddecbaacbe484ed96ce48ae3e39af28e90cee64d82382e29c4008d00705fd4ce5d177148ae49bfcf3e80341fa5665fb74f54dffe190646b1a7155c081dde2c0efe9bd8cba6abc61a370a476e70c937f1669af5fe0ce3a5034d33da275fb001c7133e19c7884097f29ff40317d9d1c1e2f4082967f352b5b35ba759e72ef397f1a1b8e303c3db6864b47f65fd3b2224f699c739494e541b39c2aac5b1606562e7adfb7f83c33f251f3152ae894cceb9917945182f732948a7182884237b10180340251dffebc29049cb08f8487ea83f6647609e339a7e039e0f41d19110327cb9a06636c2f5c5c570f7af70ec3334f6d9ae41ca8da88cef47256373da42e92cacdad55d2cc66dd2d37c532604b65d23643533b914ec58366609a59c78fa17238cf7c483afc19a11b9a239255c4f6188eb7ab7b4c99de8ba83962b81a27a96f8f15684eeb056760922774ecef60d57a85d225c08522ae891372ac62e7847363e1b1ac8a93b42767bf0c2e02ef98adb28e0f67815e3d0a491879edb33ff62c41e9435cce08446c01e8ecddd12528158bae844afc3813b136ed8437177904fc09afe547272f8bb8c44da5b28598ed6e37ffc3a95b134f8a904b5596bb5292d6dcb0511b33993e50d7edc5ced720c4fec0ac45ed7579d41fe6e334c94eefe23678abbd806fd1b2d1224cf00ed997ccbf03944803e1bc56e707940486fcf6955be52ba517df5729b26cd17850e4c4c943eff9a725618f24fe3178bd02262df5f89bec72d21d1617cc3746c42d73b003fd76dadd6fccf16b8e3849e581984df2ee4751934a1c64b15850e1f107f7297b74c1886b697f7a5d6405ce3f5a5c970349b5ead401850d4115a12a94621ccce6eb3df5919f7809cb9877cad7fd87c62749a99d733c391bed8c050e1a8e7fb17f2c0f70c5c72b74b8cee8fe3c0eb53a26a40ff344c6bcb149069b71184314ca016eb42686234d0b2d1bb01027588ce3b7fcb82e4fa0b646cb42c9a9e4d2e1ee29235cbec5be97d88c3bbf9e2e970415ad20be1acbb3f8028930fd0b6947349dc9c54bcae7045b90048bb26d30bcc9c6b96920d53f2aa285bfb8eaa29f3156d928cb79476ca7200489a9975fb5e3f4119d500eb97e2fa50063c2000fe748efd5ce71b0a8d1354006a4ce2c5dee5166b2442cc7664e0845d24508a88c860f91572986f15448707240ce9e072ac1f4e87700cbdd480c443b2d9296468ada9aea1cf7e6dffec25846aa1db054031485a0ee66b1fe4df8a0df0853ff9c49bcad9b9fe1eb20b233ad1ba63ebff4e90ab53aba108f01bbc485b6e7f29a905397fe2f0da973c6975e13e01c0a2afe4c24a42a044dbbf819140d4c201829777df11beae8e861304705ef4353b83866133e4dd341c9191caae11a10c0892d2a195d84212d6c7619e4547737b81639332ea36e54493cb9b0f466a7e80d05849c1957f4ce8af643a8c8a2b6b0b1bcac20e6a474c840527803099bd70dd67dd61a8700451113ed90413af3b2c733d1ad02359690a3a8d8754a0368332729ebf4562789d34c8ce70cd544d41b555817e7db0673098511dc5d1a6498702b50b2fb9c8719c793cde2407577c78a39158c4d6bbc2eaaa6a313cd71d865b204c0efa007c06d7ade8b4a6d9869639e79c8e34415712369ddb12e8c1858c732b2ece59fc724db2cc6d65aeeaf161c3523f589e33f9b7a0672bfb73a357c69a44e29c6de5e42f892fa941af27fac27d583c9931a7f1b2ca5130017b5978f73faca82bcf1f1ebcfec85dd5e1ee2e3f4d2c8d903c0728dce064e01fea25d891edbcf2bff682d79fec55fe3e140bea807930ba99ebabcc67c6dfcd38e9abca528a2070dbb07ee0a50e8743051d7d4acb71c1de1207854981ccd934267e1ebbe56b70b2ed0b61b766730f8f9dea0ce63736a53ddbf6103d53e192213f88cfe76d36f7672aa723d6a1a0187e7f94ce53b3e60077eacae427c66b7ac40a229f6c54cbbce7956ad5df9af936e8561faa1b300c34b0adac4eb92cde2878d73820c78cb4ba19b007978b756ad6362d214914142f981d4720c98ea8eff2b6cca114089756280c20da4af8c52bfa7e0726022c01fc8e46772c9e978c1a1517441a6a1b2e2c583509026280c9f7990dad3737fb6b85fd46be105e9889c205e1d1c63dd69ef022b1e2ff5a7a567232c07bdadce87b1cac34bf5f66e9698e4fab58707be126ee18a9a0aeb09f7dda30a1eb25cce81bb8fa21d28920f5cdf20a10221263ec3729c5e9f169ce70818a846a5873fa2c27e2dbafe9b0892c76c77dfa2086a9b492b132c49a444f199195926799f93c5e2ff2fa1764b3a2c9a5f94c3b7a0c67ca312b45154f417c0cb253b8906bf43dcd47a8d423be2da8c48a29aaa1c941772f42e6d0208ec31d1e8b38c64887d9af805cf3d538fd602a7b17f2bc31106fbe3e8cd7da7efdc476d4e40d191a547a39c31024ac35998edee741edb831a7abfba2ffaeec341ad546f513b4d219763d30bcd63e53c041e1ebc2536c3c74e193f557d6915172315d2353992ab7920ae540017ac90f50790f221a36c5db8b24ee06e1055cba440dda85617a879017a3189b0d11d5d6dc4c5a1d91b975cd8183ada0e4bd0fb4224701ae3accf21bea9460eb348164f41044e4fae98aca3ad90390ff2ee154edf21b0a82f21e29df41e585c478401522be929c18c757673de81d0495639b9f0817ba23d7a52dc096839382a86b1759528e67cc3a86c94984724d931fc2a2d54f261f067da81862bbeae45b75d804913b823f388735c1daec0488e11d7b2ecd7aaf2df6e1205a9dc70375332e401605a0395710b1968efca1567fde4221fc526972930d4a95d1e8ed41f9d8468adfc6a107651434d7a8929a301bcaadc68059ceffa08bfa9301706ea03548c088456663c19874471267b98c3a3c643059ab1e6dc2d81dcc14cd405ce608f8c6b7b0a0ec0c916771642c8bca6ceca8cc614eac1f7e91cccc1c2d64b04044858c26153dd490a9052bd9d4048aa1b170ec82156680ce80bc9f9311081060b01a169d8f85e194b03f648ddfea04b31dbcdc672513c84bb61a2971e0cd0cd02ce2bdb7481bdcd03c6976969fb735f09189d537bf6e4da0d1c494e6dc9a611903d8a128a230e5a6498ecd9c50979df380f66ecae6424c16e515e0ced84d697fee6eb8e83ac6aa1b9e6646f459468532e12189d55c7eb27edf2dbe75d78606b9f8ad3695aa95981a5e177d932e82b00fe05d5abf2c9924d291c65fbf3ac006fcdbfb961bf48c3c6ab58545c3766300e8748db9049c50d974b5991703a3f98bd03b2313b7bd5724cfdc0d2a555d6a6b883755edaab74a0a0736fb590045b6e707c8f93c1dcbe90f0953cb471aff74e89a0e40ed58ab44e76b0c93862210e6aca08f187bc63bb2377933f8439eb61297312620bdd22c64cea87be822f47bc5e5ac75fd0b2f223aac1764ef798678ba5c2913c0eb7f716d5c49c7993aec9666f492bfdd741e7c1b86ba6f6288c50c5a11354c4e34efffca6be13bfd520e61a3a52f55ebb53a45dc622ca1c6681809be18d77122730b8307c12774572b2cb6e46b0e2e50549434bd1bab8afd6d6357d238ea41a2a2298a20196738416128358346c8b5389bede090bfc5744e81d8f7810b79181036a683f49856b178df29ce880408c338b3334003618bca5aef530bb7509e0e3402a0787be13891b516751b1ebf040e18bdf1a500b859fb0bfc509ff223f9b0d7bacfef983a116bd1f9dc9dbf2aff19cecd745462dd1f046c88d5914ba2ac1bc819c9230ceffcfaad6ea4fb77a1c4afc2fcd357ff51e502fca11039c4b1a940ada67430febb463501c6f7f1af3ac7c656d5884dd7375fce00e6a2407f594d1456c49bdd1cab47b0b94aa1429479d02758d071b3fbb205f50d0b9fb04d39e1db9966c88f995b9b0d2b920d874b89bcd7395c4e240a7ac85b4095c27eaee2cc1ad11a62843ea8271d355f0322312ca7670ec8085ab66019ecf58d3e98c6518c3c94cf6caea6b5ac14145ab61c0de1b1ba80b1f2052902528ea1e120d757db7aa341285bffb68fd6311fcd92ff424f5f0ac2cf095a087c6b29471cf8112382fa89c7c986ae2e5576b26dda547d900d54fc9f1db8dc075729bbd5c11c4e49f05a39ba27500a021e7983f7cebf0c833e943b4812194d88b5a5c31342ec1180cfd9ec0d507956fa94a41567ff869bd70dae150c413afee46fb0887fe932036b9ec6a712bca29175c63cb87d1602655454ff2822deb84357c52c3f1a59d188671063cfa12299c5de02598e43aa129a6fae81952e5cf5a21065c7b1f33a275f52d59369e5b09cef2d494bde1b1d6362bb34bd0d38d98a1d86089209783049b690fc19788e0586c329ddf1c855f23483ceca7373262ab599374d23191322478c42c04510e23f3b6e5be1f71c15fc26c9e45d2e7b97700d49fc5bf058dcf7f02e0f0c4f8d0fcbf03ee874a398d9ac58fe194fa184685652ea6d82770973f4db996bfc82c1864e3a7d5b9172e8f1505e7ffc7c2ff845edb896a75d0d2ed1b1ea7d2b7d36ec5be75d0a46ffbb40e24d453f2ef7e608dfe07237ac568dd3585f1854cf9335bf0f0ec49b44a06bab8d9cabbd469e927126e0b052b2c6fdb6bc6355226cdcfa40dc04ac1e2e8928a631a1fc67d1520ee8fa68aa0b274a18ec1fc881955dae4d40c454129d6ba50f83836406207f70ef8e5613d6ab9140d5144c524c2faebd21768d65a86792439b2eca04e9455d8acc1280025efb1ae89939a0043d2765b8eb336c58867fee2d26deff778cb03d6a05089f7843bd3dfead5c9d8045ccfdaf9abd8651a2e0c54571db3075c68f3839b40dbf20d56fba8b632974ca716247b9b25ba2f87056ba46b632e42b95316d465bd8dcb9fcc69df6ad1c1245ed84499e1f79733ff384d963535b31f372e474129296c179b712639f2507af3e6f4f71e83381b84a5c1da68f2513b25f02b3e7b55fb1ad5a2eae7971527ae99715c6e051ceb601ee1fbe4c253d0c7e6dc061e309ae4bc8ba8686bd38f4c61bddb41154cc622a5b38c0d894806f0c793acba9f09d08e25cef86a070fcc74703d219ecbe85d3726d82423710d0087d2d75b29068a6ac102d56b313583692f16d7c6670ecc4a91e269201d808f56fdd6892f8487975e45ab273f94fa7c89d051cc323ae30094527eb8f441fd49d7a76cc211eed36dcd5f695845e41ec2584f8cc960e8a25fd9d21656782e89b74d308ba478d8873f783bcf9e0586cfdb1256d266b674337d488813687184e8b684f13103ade30b27bcb0e63b43d60e60a58657459965ac8e89b3401f1f0224ef9192aad80dc06df362a4bead487750f2b6e0dc6d6930798b645c8b5649566ec8ee90bac9edffe7526f05b397ba97ddc7f39575ad299abe1a8e210258b3f9857ef1937a6e682cf20c7673ee74b62e577a98c69198d0fe299b029729ada87d23b244abc0ec1cc59b6b7e3a8c025379e6dd64ca8e86547b80c0cbcea85e612a9393165c78e64c160978829bc651c22584de02a01fb00e0539650cf8f564abde098646bfa95114c0641d1d86292cf76b4357aff21b47e5d5ceeb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
