<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2563a864ba09346019d59911231ed0a1a9c514d7e412f28b74f81ecb92c26309e0c1b2adad74eef232b49585eceaf5353ad04bccc4d446e565ae10eb399195e49bd36fc4ce8694e567743e2a4b7bba2987cbe8d5e2091c8273f9026d0059b8217346184910a875f542ac98443c7a39c03a6087aac48c84b1eb9e283f56366aa6268136eed9f7b14d5c69b17273ddb15eb54be3e410c88ca185657baeff5270aac3878e969f93ff85b633b8df761c1a608f92bca80e9cc572fb0e4bd04473ec8b8bc8ab9af20ccd1418a9440d677a6588c633554424015142abb4037826d1bb6c94308876cb0841efe7877b258746789ee85bfee389f4eeaa278c49b7169d9db72eae351556c49a053cbd0699650155a50549467967d404e4bed9bd102bb953200139663ae19f109b2cb71731fdb2ee0d37e881417940f24bbd3d9f36da104a9c78900fbbb839c158b1c5ae9183d43aa469870da6b741ad854fa9b2a23ea373370d78497733ba514129b54198a61ac6a62b7b1ffbf2673ce2ffebbaf6bc1a55d25395f22a257412ea5dba09a34804809fb3af090a15eaaeedd9cea3af31da779cf07113b93e10945d4115e53fb9e271d09b2a405c240c034ed627549bc2b7edb454b42712c386e10aa0b23c218637b21f87438b162bd6986441b94a994ef27c2cba7ffa628d28afd9783748d68d6c77ef131031ae1272ce6da06218ee6a8c9aca7676cb51878bc579c13e65c9f0ac1547ad132bf60196d42d8b6541503a74d4f98dedf94f285536780861e11d00ab9665a89a67413d54d31b960e93ba9b3693c1e37bb1a0e917a91ef6f02dc32ecb7684a401bdbfc4c036c6b6e6f412dbba4d1e4b83a6cfaeb25b3b5d87bf23b9d435892c25c9c7b5a8fc14528c1f2f251cf47f199fc449185c91ef24113bd29bf305a2a6c4bce807a974ecce031313fcbd721ad9f81603bd6e7c760f7e59f4df4b351821011d27c2c95a4f447ff12cbd9af49470389e27896c7d61d3cd53c780c8b2cdacb96bba854f4374f2b1c25e4396ef8f978addb782f442d458840c84f2b3f4eb4f0fd586ac6cce1e47b736ef8040a7e6e76e0f5116b561c77aa6c220b6c9f857d35de096bbdb9ec87dbe7590b11176d7911f0d6652f5f6586f5e6306f95c22fce2c70e3e0bfadea0152f66d30b89578eab179bcd9d5df8cba0871347122867a0bffcff65435919da7f6bbd83d5bc6256e9bdd4018862eba6987dc42cebba981daa7788369da098d1ea883d31ed9f15eeea4784d70a1acded82e154f270b0a6cf68bea3866905bdc35d7e605ce12df725e353b6183f44b0b02e38f4831bddd52cf63a64beaa5ae5c6c47bfd0b45f34a117c0cdffa06219b317ab18eccab158d7d85c2dedec2778e1d13dc2c52757a0223dfe47ed622864709fdba1838aa734f8aaffe69b6847f14840c6da4e467b1c512fb338948101d422b5bca76cea03a02123e33e1e3c32cdfdfc77bfc5ec422016f0d07605a99120bd46cebd3877b6fa701481be3ec023946dcf5d4067cb8bd50313e0181335bb5a9d2bee507ffe8a0c4bbbb1b574e31184d3df13b80c3a7c80f246009c8c5a50abf7953df24f159aa20759a1baf3ec636c1cc38d4a5d05b880bfbae1cc79671d719d89d57d39f344fe32db96338fe36dc91d6e550fae2510712c4a8a46697f2a9bac45080dbfcf395a1c2a20b84d2d9d29dd28037d7acedb32e99522fa5817aa32a7afe59ddafca4f90b1ab7be35f3c8466c062474e3530f0a58c5372b929004c4a24377ef9efc905eaf6c3e8339bb3617e4c3afa189cba8a2aa400fff1bd4dfd23c4ddabcb5002cba08b752449533a263f30129d1758319dbc562e8865ad846052b99b6aa28405a331a706fef6d121e3fa1d5776f7ed7af7b5129a6dfffcc7c2835a851bf05e645b93c6e3da5702ddb5981d3b53a3252e888bc0b140397eda04d5026b72f57edd97677f24804aac32813d035d6fbca28f1615735f02b388422bc6bc7a61c02075e0629409a7f16ec77a8a27ada3993db6177c4de7935178994026fccce95d5e2cd7417ce1114461631fd02143a68f97590d698f048cec16df2197977ded54200d9d0c7fcfc2f4a0fdf0e86c2c7b329ed5ed1e63b7a1c8827f405f5e24133aeeeb68902247eb9e6f1b17ec474c656609d706f3d10c6eba0302da2041b968c30283fbf26db99f203f338cbbc6fac61a515361abbba35acea958b653144c028317d33455b0d21840a251a1724fddfc38294f893d692f5955ac7955ad85298e61f292c54e4c1faf0ccba7ab8c28dd5d01f93026a576d0a7878427dbbbc6b70c9070d6bcdd790ddddc996a87810dcdc8e9c1d00f0b50bd213030c09fb1d4eee54ce4158798ce0b4d45a7db58be295d68519d9b97b6c7b0b8d5e5ded7b1871511efa7c1ab698c458439e50c30a5cc7ff3eeff22f999390e60577b1dd96f81f038a98cf7cef46f5ddb19b172f67b87d213ae5aca54346cb5581c1338830fe9c0c69eba66824a69382d6195d1a5b19a226434d036531268a903d9752d2f68e848b3bfcdda2807062d96fa9e2e12bd0504d6da514e7d8e446ecb1976614343eb9bccded29d72a28ffa25d2353ed8771338750ef41bfdb467457115129d91f94b165fde1bf104d2ca1075767a9fc434b80a1da0295892f33af3b17b6b6fe187c88d9191d61c477c822b3b3185f300bfbdf2c51b1adee7c3329c3255bd13b6af7519db9b86f123b540cb644cfb9741091f77ec97a07dd732101aad61bca185a6dca1f5c012a5646480a97e29f73689eaf62a728445633c66b98549d629405d07304259d309267742dc80786b4cfb55845c57b3366926ddaac841227f3e95f8688a2ec9e548885ab3260e934d116549dc4310ede7d6dc085e4ee6b1b8d7abd265532cafd16d0649fc5dc4605701c4d0ca09633aadf3c51ecf9dc30df5691069095aabca2cda08adb609f71072a181c16838a3183eefa735e68a09ab926b6d65735056a5ef19fcf9b1f75af898674bb2ba52f537f0de7845fc2bbf6a39ac11d085ed7ce2a4e56594320923d517cb02c668ec7db3cc79314eba3c1657233d492f363c1f9d05db8c40924d1d3b4ec9f9e165758b78fb5b6ac7683ed7cd053b5343cea9541ed3f3dfb53cfe1f248c5328f3f5600f4b4a041b038f9859a6fb42222df6abd5694d0db6da27ab650b4e5421a76ff92c18b3c6c44e060a3a589dc18dcad10d176ccfe04d66f1bfe6358d1e93ce734e49c9e50c0764336d3330e00a60ee8174ac707e872225082114e0e23d2be6d9f16def6313699c96d6cfa05fde46c9357d57528562644206d1bcb422cecdc7fb141e75914915cd46474a083fb55577d805e762924d6160be20aa55ae7015dd25ca1368252643efdcfea75eca9b70366e96a04de2bad68e529c39ebb63fec59398b1a0682e5087497bdcddb70a5600915f650defc90e37ffe4d8dc8e1b9551b8812b3f5e7ede66645518feac257c713490b2a012a0cc49d8c4aae5540b24b8abe5718ee9d7d48d5abd7ecda4c6fd2eaf462e50323a962324ff8b6aa3916ff43f7e26e6cd0c3a037a848f5139fd77e3e2684c798034c9123fe0a5665bbbaa1b6664e853805c02bd3a3439387f166c1cab849a4288225e4fed5fb87dd60454d7a3514848399e5d94a74d7ce698d0350107e7f3183f27a30a6f3da35087dd6a50e73aaca530e583f41a67af7747269611404811066395a87c49b9fff733d75b5e884aa12bc4e59785c286568ad4da712f5337e44675527508a6638d4d712f0600c7fe3ec217959c7a52e9991b58271cc98c5e95ac9629d3a8f4f16e762142466ee6bccbef3b526dbd2073f6c052c527ef7039cb755456bc48850e2b8d85eb7ce4b72dfc3b75cd1f77772716c243331d85c12beedbafe6b04d8ca1f71b3815622e288c4c04550b2ea97dc5b29089e427c8acc25fb027dc30fcadaf6315e312debaa6536dbb4b18135fb03c6cfa5df1f7334927b6ccfd19f29dbea40437e1a321f3abbaf23f8b7092f420770728e85669fe461e8477d40218c82598fab25feaa1cddf879cddb67dbdffde0f7f5fb300f17b459bd379d41c1e385be45510ab13f8b9291cac2e656baf90ec4ef664b7b556ccfd0c0f41d67893cac887ec773618c44b90b5bb4ada7c1b1643808363a7e49562b09cc8697c1cd2460c1d54563964cbb73bad31709e59eaffb9ade53f7886efc5ca74481167fa6304334155ec7f454d4873fa194398a10de4c2030270fcd9540ae0f248de9d10c5358621642779c0b76f53f97b4ff7a8af9cde9c544ca2bdb049776eb2436508fd470183bc1c9959d3b93a03a23f8443db42ca3807f875598e74f70ff7fbbea843671340a409447ef4ddbf8b721a89b76c890938c7a25b9f239e2ea91cb81d17e8ae3dbb3567e642b5c3f093aadae182335bc9f1795e740ed605d219208722090fe57d6557c0dffc2cdeda0ac76a5b711701c5fb82dba39867aeee9ab9e37edb31f752dccee16f3bfb154675ff12d04f4dae4e7915a661b9825875d34dc0a9c28a11b80d6de38e3552964a516929548b29611be7f06dcec1151c41a239579ab9d79a00adb8e09a7133ac5b861f9cfb4407fb023f139436641623afccffaf5410772724f0ccb80dfad9a143adf05f347227e267c25ed93ab272634863b5f89271e92bc861231dbea082bd5b00e2537b412fb86714b91a28dd8a3cbb2bd038ba1dbb36e4076af8c6bc2b865ba79968b2c0d14cb4f15af21b43866b8218808ecf395ce338463f7d2d95bb145822dd2729971d0e3b2ecb0ca863ab75edc1812c7bfbe534288364dccb62b446c6156893079cc9a7cdcf550796caf15b97a960bedf121c27fd32a2b4ae1b7bd8a1f5604f9637857083b7ad49231de8c0fa895fd0381f9f39e7e41d019680602ce7fd94b7660c1d8307e475f0ec74003fb85c93ee2f72b7af5ea9851e0b9f9cbdc65df5a677641ab37f32dbf36ac3793e761dba5b45855b0675e6460befc8d195337b9e3cacae7512d992712e0a1dcfdcee952f2fbc04589355d03e1398f071b6232012dac3eec2e0dba702a264a5d4db0d382e12aa0c5962af30db1fca28f5e578b595d311b66f419443a8c687f89f1cf9d72b5b4a65be5152d7d79649e78f06065932fe7ba59792fc560d6dc262c8723e1a387a15c0188ad1cbd9d6dbaae9d03ba9fdf61049e321b3f4148433a695d3c2be7a034e90e05ce659a8e3bab270a5f4714d19fb92ca7ae7fed5930ce7c13edf4b8de97fd0b0e56796e1c4d441a95ff428a3799fba6de7c05052677646761e3139510f1c39c1d717c0ab8a31635fe486c6587ed8689ea61b0e7e716a8e7cb57f7f8570c83aa524665ddd006fa607abcf3d41b86334cdf56585e6b532cbfbc3ff7ac0b2d0bd22ff736777794a749da1644ca5b5ea61ad5fe93cc27a3f30fde7a1a0004d0a4bb95cae0f53ab22ca21ca577d7436689970e9c689e70b83ef43a3fd2e8957f678c6c329114058ae6d4341190cb022808b4928600948b3554b35c98650c58b5f7c412d70beedce238a972312c0c2f2c2df62b7d4b48f74b4b46901ebc4cd4abe3d8c01728fabc9ad43dd166235dde54d7e2c4ddedba045f31287827cc59c108244396e5147154f811870bb1c65238cc5ceb2e6d4f34502a48733282633edd8f4e731fefa0e9e1155f83463f17202c9afb38c270ad2a4dacf414ccb24fe535ce8519072092856f3cb26e091c8d275a43efb3f010af21f4feb5dcfdab59a2d85b610d7a6f4217f0d63f4d32bfb704d6d32b3b9828ae5b90384a4a5c6ff907f2fb85b759811b8b0292d85d8816c909c323aeaf44b95c6a775601425a92353238a7d90f6e94fc812dbcb47a302db91139fda54104c93da9ba7c4824c8502dc984a974176253b8b7d6d0c35c0a5f4c82a13362ea064eb0f17db6d45e94efcae173c3c259a73cdb7df9b7e4515efa466239bc568f6c6877515dab6f54f63c2d33d86da285103216100a38b54ced319759d0aa7f56b85f8ec32c90b1cc938a975d4e72f9fbf07a67637a6d3537afb48ba6e5704f24c8fb3056262cdc6bb4b6dd3e6b5875a1621fe69fb1cb226b2d1e3e0fa89b64ca01d8a563d9022356824ea6e366f54988f2d7134aceb5ba44fc7874246b9e7a1a2500696d4ea828cacd232be1154d4827ad4de5124e17b8fb28c09a13ccc6e0d0c64fa0b5a4ccbb3d1c7e29fb9dfc84c179e2cca6b5ee3a0d1543238cc2868dedc2c9eb8ae3067e55e6e26cf4c07603f2360d8535e7a3e0cd00bc66b8c94b3dde267396ac42d680525651bd125dcfa1db6a856eb4ad43528059a0de9fb27ca35d99a975c0c7e52936fed2a8bfa22b5488883229fba7f378f4219cc94e4014a821a9f5113077ccce958dcbcd436379450822bf57998f955cfd784a86cb12966fb4a1fadcb17df8fdd874876881d759e0d7e13c00ebcf5b066d68df6adb593ad3e03931177512284ce7072828b9a53f82f88be100460a91be61522e584c49cd4101f177428ec4d02d69edf6df4c8915b796af8d7c36f1c8e6a5937c258a550d90f80b50f939938c4fe7fcff5f2a090c73b2d7685b5b1d6ab0e5cc46e505ec791992b700f89349d15daf39b4f66d07cdf61ebce9c41e144a8a9c8ec45de3d1e23a2d730ece6b3c50b75cf8137562808e07d53cfb2faa201e35bcb54fb7f8a1a129be8abf89dccc457959c162d6bae2a3b769d60c96fdac268d26fb0edf01249c946f937a550917097fa8bf529f2d89bfd5e6b5d709ed7b26bb585dce4125c5af50871d3b22b9be60f8f128186539a61c83ef12c83f449894a9a44c877938fb46c920719ff92ac1f542afc9972debd86b91b52d0112a976077b39a3722fcecedb0ef68347cae5c794de2da976456d2c490e1741aa08c334d8bdd4c3f44d20a9b606594b7f281f3ff8be837dbefaca5ee5029f8a1003238d19e092f9037fe8c46cb954e6aefb9892ab4bf8795c4df8c3a52deed994281d3b686547444a080823617b9794c6a88bf693cab5df15341f8f84bb3756e8d783ade8324360f0bd5ee34926af155df0d5a4e12a0cd78787f2640a34db22f958a0890b064984ba01a4f3cc30f08dd93558ac88f54dac7a4ec419fe89c1fcc199933aa1d04075d75f2cbcb5c9020eda4b51be4e0d45e1dba0d9bc687bdae4a9f14be560142b7b01721188350f93ee750c4cf428bbc1cf8a4f8a6319f95c533f066e63a69954a2a6adddcc2356afff18315b021ee78e16349fe094e643d5d14b821ac262c39ca1b4c6905ba7e37cbbba64a60141a5e49b18b0b8cf5e8b5def868ef4b29d2950f76a18e252fb485711ab0afc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
