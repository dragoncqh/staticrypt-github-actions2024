<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28c1f51a12cb06877f56b1c2ceca6f2ce10a6cd1229d02f170bc5bf7bbfd32c7806678fa430b11e6ac03a9f7297958aa05f06ce5eb028ea3f0e0bca41e1757d4af07a6dcde356b7b1fbc43f61109ed1c0af3b210e97d26f097b8e48b5ba1f6193d4fc8804fd76fc1ef7c1e6c24bd4cc9d13f1d180a69e69d7c446fad848802dbaf213144c087161e35d7f0fa1606ffe8c876aad520a7dcd221dd73cef1d1f48c56a84b866c3359e93c4e0b47b80f839ed37a6b48dfde839e3cbdc422c74a4f474ff2bdafb1090b09f32f69606c25f7e04f73fbe73d2582aca21ddcb615ecac29227d691904dcb950cbf31bc5ba6208d8670d5427e73016939358c819a45f146383f55df4588c0108de77b5d7334bd77880e175600ee4bab2195f45ef580c03d354e01be0c4d919a9d22da598d3f41c593f2769090622996a03b6bb7f676920aa14909781c4e73e815def97d30686313ccff7ee466eece5b81ef5aca1f3e00c34c7238db66e20b05ea68fdcd1b03d0628fb94f7285a3b28ed6b966480bab1c6889c4453e184760c6f0c3ad3f4e6ad7e8c5117c281cab25673b356afcad7ae2d613024f8021ce64e1d6c234cc76bd825d2380a6e635097c7b8ef42d25de8e19a5c1998edfc6ab6078c1e2ae1e6cddbd6abeb27ba314ca6d0258cd5aa7a736e7eb2b7deb9b412c7aa69334a521ae9cb4983a0386eb595f1a3eae8a415011ceaabd73b4a601ebddead16c218aea239a95678910a68eb752eac5162402bf050c8f484f62c11b4cfdbfc5204bb4e2063006f20107db66a5fd2d2d61c4153a930f7af76dce5be5ad9baed75d4248eb5bcccb36c3ef56b73d5127cd4de4ca371240f646e69b4c1360224b2889b22214eb3d7ff036d1254a7727fb6867cc236e249b59a97e5f169891a3eb990da6283731dc8fa58564857291ffe1b051991ecff3f3ebb664846719ad6d4178e7b5cb92a7bf511e0ce8be6d0978951da5a9978dfeddd510c35bd9c034a6fe76fd1558d9730c44e6376a275add9476b335da2ce074c88d95428a183c8d4669db40cc88575fd32b3a7fc591bda691b74ebc4838af588284bd48c521c7cbd88e2b0ad43e0e6fc84b447ca32dbe1cee4bc9f31b3df1b13546518a25f75a552240d046b57d1c92e1462ba5bf4e4256b2eef0f9a134ad7c407a4ab1e3bad2961abea550c2588162774bc04385af1b4a5fccfdd596fdd6e3115a9362c02d919f5207c34fe6ff5bd65740f67bbd8c808c9c00d4acddff4305a20b0ef6593d9fc08e6fa2620ca293eb25bd679701278dcc3ee10a63a9b60f64ccdad22300714b8fb506434b3df9cac659ffc91eb4bc8d460ec8834bf8e0eb09c61f0ff940546a3e7088c292db9ce8535acb3a66368018f1bf9f45a674455e83bd983826ef330c68c1b08ea68e37abb81cb0431aa468d166fd8f93877f6d0d846e582f10d9ed0fa84016343ba2337244d2e55b4431741a309131215a10b5dfbb0178d6f75058efd2fd5cb438f544e4fb1861f30aec168c5e332860eb6c0eb4934a3f4d18656d2fb3cc0eed71b2f16b1af14387c2842cac092752bee0f4e310e1d11fc2e7ff39d9f305286f7b0915164d43c40fe1d7b98da2e5bb004c37c45334568ab09a5cd659788653ffb8e408ee62c3d09a78dbf027dd17745611e9ad2da05ac110f617b0456c46a24dd9ff420d5ad911b89c68f070d490f19265bdd5ec9d94b6d48f7b10cc50cf95657cab27f78738c9d56006a35e9869f57915535c440c69bf91744dd958138624a20a265175598d17278924a2bd1b85ae67bf879ebb4073b78af95c7f88c26cbf4e932ec8a40ed8666d0df10c3c09c49c9584d5ae0e2afe9ba6cdbbea9ee80852980a5d020efe5cda53a419c5e7c141af9069b3a903c67220970d73a33bbfcca74eb238a3660b0ada23f26ef3d7d127ff3173cc2e38742331eae8d9d0d437cb2bf27c735c7377587d6560b1a4f5126c6677c0488efa835e83713872e4eb9acf76da6c57ec4250f30d6b6a448ce07c7e2dc06902aa3568735f5b5495f7f3bd6d6ded0398b1e3bd32bd5951f8f3f81a5d9279cdca6a952b4dc2a34fcd09717e5760e499fa5cdaccaa9798fca3774f856621ff120833108f552f55fe3e5a72e0b381bfa810c74f521af1c6097408550b769aabaa9f7128c53d12c6b793f8ca0ec23808e4fa8188f93c8fa65ab302417c8c8c65149bfa64148af0f0a951cde326570e21f06302cc57b56fb4b572957726edd065167af29afb1aa2dc42dd58fa5b42f173a4434279e6fcc0225a8455b21b96ad0fab04a03186a633da434fb9c12ca0870855d892ddc17efc946f1eb84f6a0c74f8aa854d71bb9a5ac5ec35dd5a1815e3880e0bc6aac1d33a34bc05be3e6beb8fc706ec1251a1c5f20706eb1a8191d983b45860a918146b9b1c7e79e08d89db6ac33a45900ff79a3b04f057da92774e737f01efe20493c0bc1e5d2e018e8a443910f5e45fdcdfe50427ee8f2ad4ca0e500958cb9d2cf37a6cc6e280ee0b8544029ea9e549736b53846f09a20bd00c9c76cd87361fa8bc84c2313c082536bb75eef1e3a4bbedb29728936e346efe32cab336a7c395e3f4b71fa7a16e4ff6509d457d64eca94f97bb9d1702be250b3723b552f6297743d01fe66f7ead886692b6ab36b91afd0843fe766bdd1d33fb14a08f02a19b998e3e425a409568a68898e19a0fa8d63c7fc49fe052cc8ee01bc79afedad07d9acef0a655030a51c6adeb1f6b3fc7c6eef0f32b7d151d8c4f8d6238dd3d57dfa88c2a533e39e147e25206773900919bc22bcb1a7e1a9bc55a0e86541941ebb6ca732d711fee4b1c8c853fba5063252117c1acf770342a45984b2fa67d53607fd12af1b8d4296166bb967ef27967bfa6c3f839d76cdc30db0422c3d1cbd1775062dc5a87751c975b821bed5bbc39ca3542effdb42dd5c3e7cdf8b17dfdb4b4e2cc68932fd4f95335d9503d8c7f9edb044023fc6d3fce15f8066187acf1974355784844be04d5da9f23e788b78e0306a499837f76ea83acb7059696b59d36016dc0b3c320385321a6c9c032f56a8d0895cd7493162a2f6b36d17c2fd5c3169f3bd87acb3363575c3799c3afd26ed49a9742129f1ebac47832bb71e7054aed20dc463e9934cc042cf086542c5469c5f206820994c57f96c9e9ed360597e9499e0b8dfebe9ebf84984c90ab53911bf0148cc3ec2b8bedba5034364a82c7d41099744d39bf26373ee117b24a6e2c61530828deafd3748d4ba08d4fe0682dcd7673cc65b1c371854f074893d3ffbbb9a60911ad8ba6c28022101a0ebc98aecdc693ff46e4129756551bf23d2761aad90240c88b6854143251879596341bf1f42ab385c99c3d080f6f44b98f2c2ba3328569b8678998b2aa45e5b6e9ce475d859111107c9528eaa77b580266aed41f2e4577dc8c1f1b15fede82a7757abe6cb9768f209100549583442e90c1d216fdd38206f364f32a209ca0cd52d006fa71ad8385b44415b4031990b112e63099edceb3d7638c790d201a2c58dd990201e63cce67cd607b1080b28a5b2efc4e3305e0b245c3ab9a73c5a5f6238000b645ad30a8f01c80cad3dd5c28f73bd090b34364c1262aa70dcde7031277588f71796b10e7b0eff12fd177b7f2963db603537a7ba1b857098e8039b82d98c7ffd033087801d1a8fd77af1a98a4b2025969f085ee6a9c7524ac1eef21bac79233b939b7f9e11a8f54759d1094dc7acc7eff85f743562ae3f61782877a2de417197594368221135fb115ab25a1bc01859eef01e18c5e7b15f51bad0dea783a83c73e1670b62c368347e69e6055d9a1c91ec87b214263370a29dad6e39a4cba4ca0ea841ced189a0c4fa66c6796fc659f60d338cbf658eca16313363677b453885db4dab83dcf6cb26e684a54dccdde5250839c765c5e8dba87ae9bb0c39049523adc3e35e1b85f900e5cba24eec291ea0e54be695feeb1520a57edcfd0717547a63286290d348154b3de956435102d41eeb94402993283a40cc1fd50881fe94c00b7039a32a5a2b78b3d189f29efebfb1e4d0d76d88110ae469427e6dee54734da3b0888641b1a39c0238ffd780af8ccbe63695051105e7a81e6468634712cee016816a3410cc19c5eda9406f8c9ab4d2e0dd86ca6e428a73eaf1671b9e7087180193a2464475a6e8ddbadb47abf053f7e725fe9c79787feb64eef35504b3dcd7f3747b4709328fcfc55f1cb600bbac4ac19c92bed3e2ef0ddebbf9ee5cbde603f9b71c42ec3c63708974a2788e1b6aacf263f0ec9f5125fcf730f7e7cd26d31ef5e3e6064012b05e96975224a1b9871a808cf6e6990b557874928d2a4cd3975bab70263ac156b73a5a55aa351336baaf6aef758a3d7af3dad031bcdb35458d40fe752094b21c3a627874e95e736460969992982b75058cdb7270d6e3bf39c073a962d96604b41a1022b4505b776744c7ea5f546a6c957cd29ad775b7c223a718e348f42e5f0c70bd8344c1954e2e1fb6665b4bb0c59429a6439ccd6fc9a63acdc6f92a5599da351fcf7c4253821f7fc6e59ca1df5a3cd35dab94b76fa098123fc56cf3d6d358444ee99597cfb0052be4f74e8bab39477ab030c1a9a64f3fe583c91f5a24c1671467f1a96878c83fd14e1aee8441cbc2610eb3cf11c140f0952a2b2710d16f4fce2f2b71b2573659c139128fcecf9b9e766c35514f76ccf05fa229c48c39975dd25f6919631cf9b203d6b8aae3c889f5a8126671c00bb7f39ccc24fe1d14d299808a19c80d605b04efcb5b683d0d4a8305dfc86a81a35891a618f62da1fff3480102110ab27d87e49c8456393d2789c1b9f56e7a335f436ba6d6c76ef07604b2eae93810ce539f515a99be28ea77f8a58417c6443f3d6200d0cd8f50a6d6f2682b9bfa6e7fd92a34230c57cec6fea0ec8bfc383c2aac83258b78127bf2dc379210107d4fafc34527e5a744023251405905f0a275001163f5c115255d5160f0963dcc3bf3762ba5dcae9b1d42082e3c3b1c1556db0cc1d348fbfe362d89b276aa83a62448e169ae80807e5f28f4d2fc65cf0add4809fede1837786eb60acb2a9cb75e6ec805d3a75aadaf3f9a4cda597a63aa2726d8cfde506da480dee470aaccbdf00ad33f6cac3907a09340752f8566c240e4ecb4881273cca7b65c7390bf3087a128fdc800c06446e33a2d3156ef8f0e4091309f52eaa879a2d984ddb3bf21de5dbb4cb01503ad52e05caf908d2ea25842ef34090286ab533c5d9533d240670469923e16884488050a1ffea6a1ca753ab22535556852f19ebe430625bc48f335aaaa1e713e82ed81123834aeebe2deaae5d630e93e480713402d6ecb17439bce315e3ee2aae7ab0af6ce7edad2096d21d54f48a4e5c636a661f00fb628155ee7f54cd320b5fa9af1b3ff1d83b1d4838b60aaf112222a3fe1fc9e0429b52815f80d9ed9193b3b9603fb55cec9a9ef41fbc2b547c7ad4438247c8ec177a6d7c786db285ff12ee1091e661244556831c0cd7e218fd5bc399244263bba4de90e8c98931fef4364353de59d903f631e299d2eeca78af5c65304b92333033b5727c14e939bcd48e7d053197210bfd1210c244e0a59b6a1f269dce738f9c7db945d13af80a5de4c65ddd69f0d75c956de2891be2c7041ba54b54ff99dff03222b173b434306e8637b65bdd758475821344562295eba33f80278e1b7c4ed784e2c911c073896a936cf7f5298a58d970ef787918bd9ed84d2aeec423201b3a6000afd0519e688e108f25bed4fd9493d2836b008a3b260079774a47a21d534ddc4c599439ae29b930f566827cd390e56d4049d66fc18a6c59ab1c80cd115006ecbf79104522a3e12576523fd5e40c0cfa3ad01551a1215c1ee63960338c7978a3b6d64da8faf0e64b5486cf56cde973ca2c685debd3b6b005642f219641977cf55fdd43fa61e5b500b9cd5b60901ffec144848f65f268a6e720c93ee0fcdbcbe6f200452fc94c53968d243dbbd5c30d79ed7ac78da264306de8c24d75c017dd0fe09aefa727d2e14bda69b3c6e96d48348a32fcdae46eaad3bb88ae9a2f6c05f6dad9efc45d7092b995186e3d2017cd2f366d9b45391afd3e5633536cf2a9fbd2b9e8a72b7010552b42de45dfc54ce9b33f80a720d7020a69390c2e2b4f52b0da72293beb4587d0e99914c9bb35ccdf10f39ace39a5ff2bb7f212f86dd61c37a957c47fc53ee0749bc22d3c7445eab61c8e373cdfdcc1ebc7a2515406546b58829be0049d723d929c28cf13ee432055af1bee82aaf2856a79186c73a406810e1d277e57a5dcd6ef26f60ef13bea70362e0e272623bb6ecefd6980e9f4ac569789f4517d032db89f82694cf69acfc79a8317fc9f393b24e1bc2d207be25dc2d8d520fda6a1fa795587882aad0dfbf27bcaff681ad807b4906771c3d5f1dd11b342f2100257d582b61a03fafd425bf88110ef9eaba1dbb48d22daf2be1d5cedb6e43ea188c4f344f7f5849eeb5d68e10f6018bb3c7a30bf79032329b9e6e1aa711b5da4b3af76a59a7b23d1f996cd52bf8b8b4c28a033d99a81968d3044de95f90370dfe778b31341f01db3bfe17a05deebc3f27be0655c41e96354323de8a0b4b543e16c88a94e9d0e96436a7a4f6754b0be05b1dad365bf1525c8e79055219e30395ffccbe05fb7acd1e532804e57641bce88c02f049af59e54e700087999b16441611559597b3622a9cb25f566f2271508c7ca876efef2d80206289eff9f83b0861e8bed5e76b81a0c3190470798da97f91316aacf7fbcdc3951dd13728163d202d232c230742a707115d8a26adef0ad3c75f4af358af40f9700cd4ac5c35aa96a718a3efebf75f0e8b1741e5c3b30214ec00cbe8dbac40e6de5d30dac997eeebfc6d2ffc060640d93a326bc8cec3d2fc216252b2e3db8c47a3b82d7be686da5015cb931e0f86fadf7aed51a8453d4658ac4ddd2e008878e12ce10d2cba0a2212852b16fd4e28250fa9ad8890ba7a290660d9322af1b4aeac7d5278d3671279296ac2ca533020e00c26aacdf8fbba8a17125f783481de40b338ff65f0f5d1363807bab7b167d0591f9f564875b878bf75f0d49c69b6e524799822ef497ac8c1513843eba540f04ceab225f8a7059c9f752f3acf132deed685a99ccc04f1f84338aa6fd96fcd755063653b79345f3cfb7352db88319ac13defdb57da22be5a1ec1d7fb0ef1024fcff578c6111689b7e96de500952f63a1afd4727b03f5a0d16e6c842c79d6fcfdd094b7aa0410204b49c3f1e4a14d24e1f38d61f22a2d2c549859a9959d31764a9825c4379ba597473253cc9d26d60334e6b7c08ca0202ee41ac63346a5e25fa2f31f0fd21eb0e8f23d16c441aded5d414b0227a06ff35486d6e61757f597474dc7d9e6b7f98f3ce3d757b8f72dff58efc5960c022aca285f35b86275e356b2c32ed82f303460d820f5ea01d20fa923594e295d376d2ebbfc6d46ef0f4bc8e387c826db55d642b6ceef27f777addad00a8b1712732785b1775b734b59cb138235f92427a5ccb4e016556c8fb62a780feb25b97eed65b3c98ecca0a31f6bac1f692ed7fb4b02992f465d460dc93acadf2a18b9958609a03c17f028dc8d962b420c2493e492233b31c86d8838f17ba65e5558cc92b9765636e6f1dc745677b02d0c1358cb3e120f6e0dd59ce1ef16fbeea7a6ba01344363367e229b13581ef8e61b57406bdc0c14c9387e49ad0bc3cc536ae4ca8f493ed251f1f754fa982355270561b193ebdc1b7174dd899b835cd68318d297598ab656b67ff2d815983765e8d084d0f68e330adbaad8cd0ac33c95eede1142019fba9ee2c260d409a45bf2ba53e62387b2579be30f896bd7de55c7ec77ee206ec7f9bec7495c1d0c794c1c9d98cc16dc59a35b110b277512fc2869f5c06c9a4f70101e88a30bb4aa935b2f5bbfe0aa0daf3cee9b2dc99c9da21c56c1934d1f72bd7052642e32c6742861fc4bc0d99ac07c674efc5b9246a8788e8b48bad410c2371780baca48ed86f719e917e5636b81d0dc871035e226f4ecc3ba6fc8035ad08064818606aae5ffac0bfe3aff51fae28962cce48882b531c9ee336a302fa427a999a40e623067ebfa8db707a3264d5dca750f3ea264d8451117d11ef70ebe342edd133a3b60663f627a8454483427e4fb798e50680dce6eb60af4b56946b564e4f3fcca308cbb60cc5ff97fd43904c5c2530025a229ffbdeb815e48e910ff17a5107c1fb68ee80c3f9e15b9b2465d50ef07159d45ea31998b91b33e158b2a8153c93f1cca3072619ec651796f99b843f747b03f453ae7ba9303a55866f3f9ceefc556f0d2c32076c0289852cdb2a1112493dc399c6485a13236e05e2c145819ed44ef14c527d924ecdf84e07791795edd0c485e0d98e0af68cebeacd716e6e186bd7946084d5aa360622a871d83d8960ae34a5cc9415807e375382436b1a91e2ffaeb7f9e6a7f5ea2d8be371ca1501f8feaff7d7184b53988ae4f15376b7f2d437a173dbcb94bd9f2dd831ba718941f1bced97c883fc7f2bca2bfbcb90a0b9ded16ba6584b4e1003bc9880d87488fa8c080e10bbe9b4313cfeef444120562e2f32372c795db057c74f788174418ec14cbccaf202eb9171fd210e103b935b05be4e246a94361102aef0cb429a3b69aba581c18fa4428c443d01a80f9b854533647edfdc0d4f5757d9f5eca3bf82500f9b4ece3fde5c63490fd7a45341159e6f5e4c3a3818ac07959419d44ed02e449001419588812d2553bfcd3b597ec73a127bff6c176bf9b4f264034ef4508365bd9944d79cd61cb80f08f39d5f585392e813a82b81fbe4b361f5044ed4ea33eac3978b908ca2fa7d8844b3de362b07a0ff1e699b7c29ea10256615e48cc5ea464c5090cf73425541241200d44e58c02e303a1ef0cfdafe92c1877fcd5de9e2e550a3492db9b529877a353eaa406d879cc23068eea864d95bba8b90a0300bfdd09286a01962b4b6ed2f6bbe2ce0f309a903d4c3a26bb7ea654453159917cf433ede2b2d14d7213d575aaecfd34713c432a734fe67d8238bb441cae45ee37cb30a1cf1c41ebb40190198cbf4b12238c0200974a38c1193ba12d01bd778ad250116877d00d9fb340700818c3812c718f1a089bead40eca9178275df98b5c5fd4b3b375716d69d638779e07bc5da310888a1927f4cc1755de094d2483ea50b353b05c659c3a042ca77f5a91d182c1a16e4e7fd0e6923d9427080fe49c383007c5c132f329010714703b0852756e95541145de8d050a7fed6fdff3c48b284623a0267ad3b92112edfc747492137f106d66ce3fcd9e99a3843ff5db9e3e931b6b41196747b8e0a746a37464d130ae32657e8f4c15e136b6923a75ad8299e0803838652b57966696152a20875073eb68dbdae8cec5f1c3e793fc05fc0c848247c5a38c6468ba2e12702127397a7931ea97d70f2649a52a57c8e9abf9e13c31cfe39b9b708cee6c203f75b4fc70cd52ae93fb1b13c48d79e1a88f55ef2267e85738880d4bc0f3e1ac8c41a6a7c09722f98552a3c4275081000b06f5d0eb9f4f30b8b20d36a622cdffc7766b9b560accc4a4b5a4516138d74bf643080a727e51164e52b64e9baca291a905261d7fe33693a982baa8303253c6d7a6821a2d55d85897d8d1e7e6659173af5c3dca097c0bdfae987132bce1a00258044bd3e8e03114b2f684d053a8ff5e94be2484c63eb3daa78ae8cf1422b4bf8b6f2326a7a16bd7bfc3eeea8176204a5ccac1e49d4bce76e923645b53959f0eb8f84e274990a1525eb9002efff517aaee78bf66f9334693e63f7adb8ba615c602c25750bef85d3466aa3d15d42cdd86373bf8aa6050e352ec2d3f27103506925328047757853e78781038934db273755857eea2823826b34a3effe904e3259842f0b2a6c728a7d788f1056e66108588c9488c26c420f01a0f244916d8d37fadc8d25fd0d191b3527ba66ded598f94da436e741c7a56c5d3a232977fbe0a42f8df86b16dd6204d1d9bbabaa608e27e5a0d70d7c65e2ab6afd1fdf995be87ef9a5ade2aa70b6235ab06f9c3fe59043d8b23a6e04f842a28663e4cd926deb51d1753eee7f01fd23275138d170630e140c38e5c9b8cbb22d5b5583e7ca8fe73429d8cd8bbeea158d09d38f35c4a33421b11afa827fe5fc235d82760254155063b6cd3e5caeb61f0789d46f9b15996a54fd230e49786196849b89add2b814cd17e6828d7398ac447bdca5982fb582ac43664e5c220790194e575e99a6877191e529516d979d4b0cc5d35d1f1d24cec7602ef898997721b77b856d2dd09c6d6d80a775196c5d64735a96982b81452379984d6dc254cdc766776f38f083d606a18ef07c674a976f315bbe5ca83c2bcfed2180a67d7b6b506a18212f46fee5b16207e06908561cfb48d54f54f7e748dba318adbf1a760989bfb04a74694b1b2185598db130589b09c3288f48250d32ec348b41e828a20545acb9a3589e6da7a93cf3a296230cf6e7e5a1af1ff812f1ada53a5eb66674a6bfe3dd47281ad00b7339c8e194745c2c285dd216988d6b1f46d0d0644332e30486f101b330a432e3517bd22f54fe4ca66f72caf3873fd1625d7a860a5e8dfb445cd3a8b32e18abe0cab9cf39158d029709ec2768594c4b46d11558295ca20a7a68a69f93450215476ada834589c85aa3cfef2160684cd8d5bdc2ad227d435a155018fecddbf6b3a9b2d56d8c37e8d05f8d9522b90f5c4bde55975d93d2c27e605f028b3cfac244f96fd6309238e3dfec8a202cfa6427afe50053a1fb9ce111235c011d180099f803ad6c2250dd5607a24525d03a4fdcc15199c318d4cede2865648c701e32ad8f3d9bd3585b8415359cd5d919305652341fcf3e59f6d2d2609e62e13ec62bc48f22dc9b457ce5ad557066d18f3332885a3871ce5227f51f60b92b2cc813494952909a8ad331366fca2edec35ebc6d737a1cc8b91f69d75afea1c8c3ef7c69c365da6974cd24a326ad279a72943ce07752adb89aa0dcccd0284a433312cfdbc3abf6c50cfb8caf407d037e45fc35fdd98cab915a99c05ef73f9516caa0f9c7971495c2267d52c2e3c7e5741ff4605b8e4f6bd5a72a142a421fb45ffdbb56a1e40874373d514c08e259e573e86f61a7b88f9dd953bcad70c3afb3e2f92e27fe0cfe2a03ab7ff1a8a8fb5abbc8857feb6cec31a4f31ff3931930df906215a8cb5f4c232ca06e1a7cefe3f91f1ca5e3d7702f785535ca35a8ab34a29fe61e20068c74f88e7d6b82815f7e4bcad95a74eeb53ddf83da9140e58a1ba7ab9fdde0c21e56f00d8080ab1d59430045c74796b1d82358e1db16296f73867a600608904916fccbd1470d2907c0cccfc060c016568a929a87463aa5bd8fb3b70d6ed16eac77bb3cb46b3a896bcf02e200ddcf76a8cdc184dbf1b2fd664310f8e89ae2e0b5c523ed0dc01d71ca82e2da922835aa858a8f5faaa079c3f9867d53c4bd5cf811ca6f55084e3e3354e1a9bde0e68bd8d63669913e08cb1788809863a2ec588c13dc38550538a9b20661797fb0477f04fcad0ba63a18cd95f98ee427986ba8451c03fb54c51ff7895bc8cf95e9abd0029392a0c138e82ee9cc9f3d0f493f2278df0255ee3b0f07b21729b157b1ff16b21e49b9a0d8d2b47fb195bc3ca15b1392f51b8301cc68313f716d3f3ef1c99a63e9c97e9f37a37ce65ebc9f95273ebdab98ab00a1b6e8830ab3eb8ecacdf55448a527b49bb7b62ae85a3a6d3058ab3851fc1156d1c873372ed95264c9875e364b60b3e576f6ca5a4264942a33b6a21d73ef2e69cee0288d7817dcd8c88e9bcd34e6b56f80aaad342a0459a18611e4e51cac78dfc9789bf83c226185930c0e1e0c9e6a270fcb58bcdfa0c41682c93bf37f2b3dec6f792560ee2f94c0ddbd2ed9f657a3db5b016bac9aaaf0ade7e55022eb620a2bc5e99d39416babc3d0497e091ff9a522fece4bbc0322cf23bf241849cb79c5f7233681fcc60a3130f3aa64192dacbde5c8c3d33e665027f60af3d341675ba29e8638a4a037207f084a71a9e19ebf480a50dcdb6d495f9527e6f4241fa9ccc28054cf0b340d93548ab8ef31ee6c1562e45e2a4e6fe0f47690fb56fc909f3c458805789888586904c4e9dc12543f0760b7abfb9fd975624afe3f7985894114fbf3e7883288fddbf1a7426691659eed53dd6738c2a5b8c5489d8f7e687ac1e1f8c4cb6dc0369b68afeac14e58eb98e287c7b299dec0f6cbe81f039e12508d92ed6e71006cca7037c477592caa10f19ad68ff0392ef6bd854dd021b4e34f8b826ec86bb66a2df43f0db7dfedb14762ebaa42d97e5d183a22ea45f73eb91d827a434953e232f965920b72ae1a55a15f04e93e3fec488c00e621eeb5ebc4253b2a25e395b918334b1a5ad237307887ce3d6d6ca99d9e6ba767519523a8fa727c6a77441a5cad4f1868348c22c4534df3fb36c69a2c7db198c44cd27108891d2a4d5e3551434950d33f8e5d9bf09e69dad229fdeefd400fbeeef775f7b0d1c798873dc9daa2926d1c6c057fc6777c4460fc8b9997948e3d21cc1461133640f945ca5b3d0cc73a869d1a78cd2a2699535b675bdc6277adf83c6cbbe254cc29a191ba7fce890e63b1fc1c8c3e6c5ea612a74aac9cdc5bdf6256bc525b1883707a2516d5fcefce43e7d901fa7468c3ee438df8ef11817ab69e03d2c76ad3a2efeb3c2fb398b79120d15e37e1fc1a22296d74f9093934edb58958b563bd9e44e8586d874ca99c0cd1000d891d77e529027464d086fdea0569a72eb5886d7cf014ba55bbf6f92403f9ceebc08702b2cf701c8c289d202df8ea6aca560f87a16febbd45e78fa5971a6686d39636a7a39e70891068cae170698750e05f6835aad85246d6b8cd319045f88f0a7d4b1949f181357534a1647714c7dbdde6d62463ecccce42509d1227b07481432a8843124fbf9aca49a4511a691743251e0c9c0678721b4b3fb7858c005a00a259c15e15f53f287348edd13feb799543ae933467f66ea6fea83c7788e9e311f0bce8bc7dda39939b8d63d65915984593d89b9b512036c9c7136d1ff6bc62851abf773ffa98af0144c74a943215a85caa12288fb9d49488903f949598ca895a0e427a5a55cfbefe2adfd6f2df77423fb5c9deac0d20ed8d945771ce8809223f52eb456f6c5fc0b8c4cc927529503b15d964414893c191dd095a60e16ad12ef083f6f0c336daaad20c4d9a90deb70f72ee5547a3c840402bde55123bb2400172a741ebced88c6f1d74c3e7de5880709442fe41e9fdca3603abf02246d46315619c8bad166f202ea6cb5492fa6d680be2a0df51741f134682210130ed0692d71f4d9f51266347441a946f8be9ed4150cdfc464b56343892b0b3919f00ad874ddf8cac202c2a5965ec31669d5692701b455d2f5f0e5dc19bc421d338acf64f6b7faa1080fce13e4309d3d8af0c244c72eb633bd3b87b0e8c10c68cd46073c53363b19066899c22100a9027fe76c5ee9003eeffe74a9aab86176aecaa96c5b433a92866b508893ae62976ccea1a337a0aff1708a0a40d0d8cc15ca54ebb65907ba332ceec84ceeca52afda875b4d780e246bef7148250597ea779ffd90ebc8b5fd473e4685f386dfba8db3bc77c0c7b65e0e7de866eaf0324169c9aabbeea817b7e9e8340e2f7fb0bfa4fad08c63065a291af6ce79fe7cb0d3c25b96976425427a919682647c445fbdd4ecfd75baaceabfe127abfbd1d1d53816e4d2006f548083cf5410fb6970a11a2888ee714d654ad2c2e2dd32d9c28b2e9bf217a51139c67e4195fe9f9919e24ed83ab4d1f845859cec22534e9c91834f88ef4f6e1590d2123940e680181af15dff21156bbfc5eec48c759fcd112f7dc2d971cb50e5d19b7714cdc5555a0078d7aa7b02ca547195fb1d66883e5096b33f389a704ad503471de88e60e5984dc73c651d788f081dd195b44856b827b00cf365ebf800aca8d0636b0f4c5c562ac5a20170a4660e5ae62d66b8029a3810d34f608be04b7a736f7a542b98899d39b3de12d0fffedd175d8e8cf7e1be810f842f73e2319d0b314c64efa96e9256208f0744aac336364c2f02fe00521157634469c0414e9b120d4c06e5314cd7a98dc10babb3b197d0e9d66c1df66e11b8281abdc83e6e86f4c5448d27bb54ad4186c06037ec7a810ef956217e0460a66972bbae0207e0419bffea58adfd9071d51de1d77ca961405f6b92360ce079dba6b42ca5df280ae832c00134efd951fa19d43cc339e69fd20bf42ece25d5038038adf749dd3a74d00c474fcdcb9430634668f4132d0487b577d484b00537bc2512ef15ea4d1570c4f796d06a724acbd4e755e7f97def4efc235be7131736d40bbcddaa1c8ea26d4e5439e0898b7b63112f5e4bbfd74adee462335c0b76311362d2268da88a364e88c5476de1219d6eb31d04cfdb064d4647b987a70abf068b02d4e91b2a44697224dec9bcaef1fdcc4a468a6858873991cfa826a3e2a707aab21f0804836b99fa10d1a61c7ab162b017989be1dc1d9e08a3304b919685f033679043115384ece67bad1b808ad573d9ee2b29778e8d638fd36c968fd04fd71cb71d9f4b442412049e1cfc95e12aa47555fbcb85d36c2dd0bce309aa38db61449dba530189f6fb90e394ed5708d9a7865928bde3b049b3cf1b3a3e9f2080dae0dc05f46162284836a5d3c784b1b5113196ddf3a56113dbf0e7043c7b5c11f992051be4bedc7ae8c039232b823c8d01b0b5c691527435925e701cc39919bd0e66292a909422aab6d633e229a1d786cc192ab8691c0dd5c9e068af792ff8d7f96bc1cb6353985703b2312e7864f4749176edf4b8bc12b983ed3c241659e5b3c1f272401595beadc5a575fa8936797a4d285b39fdd0ca04762d2f7da37bbe85af5e6919d413cfd353a3b50b1c3714f6deb7a68a4c26b1264644fc1a4e1b58e1340c8687d5f640d1d0dfad03f9ce2bf465351d70d1e4b938d894c01d1ba1e798822e1cb5e9746fcf65046dc0ebee9d19b7dd437df26cac6aa2f661582e7f5cb74d995fa21057d6223d21ea2923cb738a476103ab7f81f92f9bcdec31c3c5569c0c9903550cb954d395e28fc8fac0c72d24dab3e92097d442366e4f07986c015535f55a3e0936c38624e71aaf35de32248d54fa3c15369f6af8291f093e14ecdb18a8013591c5d1a50724a6b5c371ff77b2f262165bdced28b498fd490973cf309054cb391c4e33fd300b12c0997fed86525509b3749ed3ed3566713772429e2e07cb5cc37372d0c087c9288af4cf40ea07759347758f5c4ea0c783a3ffcad87624daafffea1640361d3fa71589d2c4de023582036d600aae1f5c99a43c36889c9a6488a7cad7d8072f7943fbf96d76423bb45a1674ea4c2a901f3f57ef11f4c16878db9523c9f34bcbc12e9dc2e4e5036ca254a9e695f73d374808a0607dcfc72eb366eba4bb3eef0503b73cddda8589e09fdbfb5633934db0a8b10ffd043014640b71fa4f6fc7f4c7603a29dd41fd1f88de0a1194bd9aee0916f32b606e0399ae01b5226b91727e9af80a5a73c560f293b3e5ac056e67e274bfad4d48f8832dcfea2f78e4e641f9655939221050ff02b3c731b38f36b37ee370fd8b53c3fd0e4b0d12d2ad25f4b7cce51c5ea165eb5fd4a30198c789efbae52436c981d1039eda43a8319bc4a95ba327caa833903b5e938cbae82a481143964b1c08c168ee7b3686dab33a5ea6ba44cca5e5b4405dc7d9cab89766dd32725b813ed5406ddac9b998efddc3adf67d3fb55f303ff08acbfdb245ab4c24a261701fe0265e28fa5deeb5d85544ff12a460b149b937a81f4c634ba80f20f78214fa3296f70cc463658fed4e656890548c24ddcc35dac51275f56752c134682e5fca963a61842b66a986445e0a8c3701dc8f3960436fa6e58492d6c4d88ca437dc50f95236516e4e3f67b806c6e44fe6396d4e0727be9e923748f29da21778596275dab1aa41324ba6058cac33eeae0a98e6af1b669ebc60a1ee173866571848c1a330bd993fc131efc3f1a44c400cb301ba4544600eec382113ab269eba24454f4676940b28a13fd73bce2ec5df30ccf753f0790721863e2d6072ee3a6f8b6821550ec8dd2da16a7bf9ae9176487994292d65a660c31777d86f9529d7272a2cd9824592ccb96222853886e28e0f40ae72db9583288ba232e3c0db3428255fed87ffc21cffc44e6f1ab49174966163f943b1b60551e023fa1ab1622a302cf64306f470674360c6811750a3155fb48a22687fb29cdf33684ad2c2aefebfd8b6b6e0402d3df963714f6e3112a577034aa33f3bbc013ab4713cd9dcbe7fb203d5bd201e2f9ff40e816d59bf08d8ed5afc83e7cd8009e7a1a15cc608244be912c07845bd15ad8ca4cf19f9d2dca43949734148434f1a42f385babd1433ec7f570624ea745252647b8a648d7d94cc6893288953015f2d2c33fcee8f4053328afe4caf4d67857204d516e8395829aa9795d8ee52c5580fd4062491b285bb4ca09a05196e97a0ea0af0f5515bde5f264fd89d6a6a3d89977b0dcb408208328d9e9c83f2ed6384fe02064666114d287b410036205594ce3f2017e6eaec2f59636e255d04384bda9322e7049f0a24848d4f858bc7d3eac38deb78b55b04e7c2b49d8629f7bdd6cb5e9cde5960f9762579d1ecd79e0ec88dc0f5523521c8c8fcdf1064c534f94e87269583700787509a22b2e67bee8ebe903cf674790bb78ea02acb14a5c98d9ea4ececb946661ddd1fb5cf4843e433a3bbf6bccc25474193a0f28b549770e0580a63d03d1a5966eb89a714f319b52ef45ba75a14e4359917ab713eebea5ee487a64ca3615f254121729099a3d726a1d0390385826e4730ca5593fa37e08333fb5a3b7dc81a01731c5b7882ed18029aa6cc6562bfe92318f7b0019bc00050c1190baa1ee2666cbd315ddcf7de9240248f8de2a9edaef8e67c3b8b21df98f8b4fdf83f33e0b65df086425aaa5b149a598836818c23e877293ebe0562204dddba2bd7a37766b3f3682d5f0d1111dc1f5097ebd8621fd8d0c34a87974571118e64863a12d16c80873f1f2e4e47f012040e7623422ccd7d24855c4b813f18dc92cd7f724589a0521b900c9220ffec2a06470172db050a9629976aafb8fa5b1e9969c6c80e172e82ff041ad212054ef08f1f3f8f04e16ecd8841ff3252cc9384b763081a130f3b1f82166111a5da200f6f182226d20255dc7bb4bdc641e7080398be21078ef7b8d415ee3e0a7f2e0e2c38c5f89885ff597623434620340c216a76447625030c6a6118e59b1c4c0db8d32ff92861971a11ebe364c1484cb72a015be6ed0850bb1753fce909586812ea02bfdcef9d11fd559a44c61e195104aa7a0a4d33627a3b5f774b3ff78f0f830ed08a031498412bd35b4a468dbf968afd67a13bfb4ab31cd7bbe907722309bd300e48567719ab387506010d4972e8be5967cf6a56888391b949d32ec492fcaf279fda5aa6c316b3132d8fae914704af15644989b980c96f60f1f0487c46211943d9302757a294c1923746f3db92968d8a66a614fb3f5c3a9eb6f39a25eb3ae2c013e817f7b38629e79f98a5b4f4585c539e8877d5bf22ed87c6a4e725c232f22c0e3d840c65160d4360c02ac5a8e445bbf14cbfe5ea3cca853d0f78d44030ff788b1959d1ce6152184d6f56978413e00dfdcc42b992ec25c68aedddf147ef669825d61ec9bbcf08996bbd9363a440a3ca02ea4c9ba0091be75c7cfed6e580cfaa0087e4ce008d94819778e152fc899826d46d81a4fa34725ff867c3c88f9691fd9ac9c350c713fc6a060d45f68e2b88ed21b6a9c20db43f5e0a189a7ff2b26caab97cc40bf9de7a02d5aca20d3a4259bd94f73fa3f919aed92bb987fe4dd9b40b108426e26b9a6f86f16384b65d52121decf6b2446ce53bc8c150e96269930dd3164647271d4c1f89687b95949ab28cd05339a6766af24a72b011069e06ee73efefbc1843a752f8c893ccef0a800a586f9c127b6ca7c9cb152d4538bf69d3f00678ed19365f7e6e5a3479dae726f4f56d364bb864caaecf0316ea2852482ef46e7f81fc35bddc595afd20c8f73c56c9b9aef0ed8987ef55aacb5ad0c41a3ca466fa36c574591d8007e86ed2ec388d95982a94f2d02e46be22e5f377534b1ef664f4a832854c353149ec4b410dd2bba4e9976183b2b0b66617a49f6cca61478223d2fa48b70c9ebf539764c7acd57b57cd27160fef3bf9a8b94062e4bb1150504319453c4542867d05426d20bbd8fdb3a331b3574f829a21f8773b33a66a9c6f991c169ed93576c44fbc6be081cbacd235e16050ee47e9977e0982a7711fbe28071c677bd1ae1e0a28ff0afaaaea8866f2a9e8cb47c4dc78371399a5db63016cbdec62211ccfbe4d3f4303179b12881d2f08c2e9ea571ac7ac807e65eb29d14c2127af0f67bed2e57c342133d86d08afe4187f8f4a87cda86b6a0fda76f8da065806dd6de6c7a037c512be5e4775c02d6489f1423907aa2fd03b321fa679a89f7667ff5f3dbb0e3c7339d9aefe297e3816825d7b0b9a273319110cf22833e6e7e65b3a5abde77adbd1ea6bb16e5ca6ee4e5c079870e986d46b4b22279cea5bd488e495a40e1b402c43a081a5ff26d4265809d86123ecc3eb13edbbe5ea5a55ae26b97f35c07916a56f12298bebccdbcc82846092a737a3da80e31889a5dad7a3dda510ef3dc192b69eac855a8d619ac286b5e23deef241ccf399a5cab2b0548773b4fd51c01d33646dbd979f0f5d04ea3f82c5473d2744e3997e4375a4a43778076cc565f5043d9f0801e56f0c017d89efbfcd3b82d3e95496bc9c01c954f50b35aa1daf8f6349afe38e57f72acf5d5f81f88575239cdd103d9e2dee7a8f1f902c7145164aa008db59baa8d854d8d69babc4c47f842c306e1a2e5a680f16334e1ae369e3815da2bb8cd8283718cf7d53077de3a42fc52fa75c9af0d4df6cf4d56889f2d6a92ecbe9ce753b51dda6f2443eaec72a1310b5bd8e1caf4bda416e82d9970cf853e27de9349cf5d6497961855669f3946ebd6732ab12ab2f27fc567087ed60668476b4f9af457d6c50a2f5da3a3af71598bbe45792733b0bae9a8961cf1bcd9a74bf5571972f348526b4aaad5abc3222894ce5becfb5d9e142743ed85f7de13025da0065c6bd0d16964c822c8226984b4ee1556658d3f65c445ef76bf0018804ad41697af6e84d3cbbcf68e7a4ceb8a0904ce6c02998376b8f80c8a3d9d33af631a0fcfd706e0a1588896c2a42ae790d250db693b220adf25ed575bfd537f3d86f63211401cb171deec5e5a20f76267576d291590593cdb3ea2d87586c7e38b614f95dc826e011858f4ec42da74d906b9ce7cfbf74664574eab87edca50403928e5449d0791639a2731af8a9b1ef00d9323585994bcef00d42b2d1cc2fe0792f04d5bc2991bafbe1da0cc7d8fd915ccba18ee7c1e93e2ee766aad0e594ece665108d7827506cc9253accf70e246ff699877c2e8154d5c4b3cd0c54d33e701d5500ae2412fb4b26a1a9ddace30ad7f54b0c111525b3f3e35a941752ab1220610095a0a9744e3fdb18794e69c5daceb29db548c62e5451e732df6e8ddc07f1941557d6baff25f3babb31a25eba534c27959f7b22ddd859216d91ca2a6e9db7fa8d6507402b2808504fa45424b48e0f199be7572ed1e0ea330ea9d00ba89a40fde7e8c721b1e99a641221014cb98c2921ddd409878c6ac565c44a0cd1198a5433ed11c5d13e771751fdecfdb3e49cf0c79c7c264d0e5e9d798974ddb9db351fde29dcb503e587777606c7c4920cac12a08efec6bdf682a262f76be7f0c5718f21b5873148993af250b2650b207033b10068b745f8eba952577b74ef17eca110091532292c8f940ad5614db25cda44a042400a7fa13b7624594822d156f62d9b45948d0bc8fd61594294b1aabed0af8b88efc60d074124e0ffb162463fb85b6b021999e5360691cfd1cc8f8b86fe6ef8c468a12d5e02208dbc45626b4f09c3b474fed5985dc8a2f1e58b3c97f41bac59a77a040f4aa0550d61168e6d6b4e5ff8a7bf5b46468f105526af408eb69cd96984e16e8af878382d2a976211bb8a5faeefd5fad59098a377483ad847905486efbf85f35be40c61b98e8b3e5fbd9854b47563f77da81d74ed2ef425d1bc4038178c2459ae4ed0f7ee003c5eef4d06d0b15e8a8b50dd390128877a79e38d04ffac9fe1f203816adb1e53402fbf87327e15e6571bce141ebb69456ce472edb13fe8070f28809f2130633f92fd22ddba3dbdb17009727539e77dd4ee7923a55c205670648635c7c8b0bee7c6c1d3595a225c3573462fdb6b5cba43c6bc5af0101e5c3259cf06e18bb0361e48fd46079ca96737a5463b594a54f2b6a9f7638da56c38cfdc6664fdbe91b9d6cfd0870c2e0c160f21bcd7b7597e55e755be9f5c7abcdd2e77b3c6cc24e288ed8c30ca6b1c0d6664d8eff3bd68cf98df79f63cf4f733ce4bfd70a225f56d337c236e94f106fbc791d3053383b535869191508627e410a911b3089bb3dfd4fd9fea1e04d0dd3d0079b57829e74c95873cdc333f7e04fe96f91353459b7386efe32039f4d69d29ecd4bea1a2fe164bf1eafd081ff54c2e1c5ff9be6e8e23d678fb7d8b8462dc013f77d8395dadcbb1f552e804c9b3b115fcfb161f90442e5b971edd442edd53e5792e53cb10b8c21d9b916dde9b605d5bcb2392e0f27bfd300a9c634120564beb215f67bc2a22656c2ebbd27b9deda54f8d8e204c734ee208dd7d24df8c729470679f2b9e1a6e295db1b269f4cf9267a702cd131f0257d530830c467f5f4f85b4423c07c4f6e1c04c3404f12749975624835e770b54e708317bc3d846d92552e0726e9f0b9963a130af91e4ac569eb1d107908876e50640556ba60096579e051870ecb42f21d4ed34954d24df50f368940d58e87d723ae3f7ef025e1f017f0c5401e0ebf77107227b30655895ce0e72d74a247213209c4523aaa990a585909d962fb07434da3717252ee77e6471606e900cec01907ac6f56b6f49b223cfc2dfa51261887f4bcc3952b36e7f0849cbcb5dab1939c5022df2077946cdba33fb9c90255f79c3c3e40eaa7d7f7dfb74c694c84346cdde8f72c592de5706b337b2f01ddb80232822058d6fadd10edb536072fafdff72986534b3674680f01eee67c336429b211c6afc7af24ca09f5e1123f322c1eac78de123650a925fc90101dbc64d05b471c28efff4b4431d62a55440c0f6472419d75bd9f612e5d1b12c4e3fda9845ef26415ab05aad796acedd17f5133338e88971af3c7e7deba3412ab68719e86567216484da1362b0de0ee0fd2c379cee49f36a530278eb78c8dd45233d5b6144c8c9490ef9661cd47baddf2b2e235edf11bd1d1ab142daa008df64e5671577a4cdc78ec564e79de1e4f437b2eadf68bccf9774b9a4c7aee916c1d0636eafffbcba79bc469dcd5b3cecca2bbf042131f96a8cd7cd67d6b26313676029fe02642a1565220c6a43df87a4f6006730e8d93a22269bf0a76b63e28f6addc6ec8ec0e801ef95db6cd99aa0aeb82ea7fb3beca48a2edb19db7da98c996a44ec37966d80d3380d162fe41f4a8840a9821cba4161d0b4f52dc4377a8b6feddc1495b4b609fb6e2c557572db184e9b0480d177e28c5dbaad19e1054dd8440c17a0d7545a7e0b97d0a0a3e20eebcb1e4640242f022818dc3a4d4345a13b2b34ae0c373788bc55a7a79f9868e94fb1d2ca587aad92696fef8b839211f146526a8b0ad6deec044a3cc8de63b3a941c3b7c72c4bf810ae5e1ed6dbcdbd969d026d5fc0d6675765ab645b1d7d2a24a15260fdce4441322f53f204b05eb30dd26bf4d5d710307e230e28dd0f90b901d177f4ba0ad441a11190571504e565c790d8cf011e2fb5a71c2f44243f77198bfe8586","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
