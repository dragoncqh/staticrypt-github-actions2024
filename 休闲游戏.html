<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"413c5e8b953305a990946c8401e13f4afd9e21b43c6ab9d98dbe0950572f40511f6d42fa110503135de844d9f836af2ba3ed20f512c916cbbcb62e56c6bab3975bb2309341ba3eb45d5d42c24fdd8b01b31f6cd9fa630ab4cbc727b07b077b0053aa219f2a4d978b200649cb9b436e919b857961a8f174b58773d27eb53477fc1715cbf73e05aa2843ffc4675aa11506189058d191bbd26821c2082eeb4034cc6d359ccaee79823c8833e76b3dde50af7bbba1c97553bdfcdb20303810ecdb56b21e3d957b2fb4d54b2b4ed2b67cd9cb4c47f0f2cb3f92bcd9f1a1a1af018c7c7eb7697ef718685ef51341fcc55efc5777b74f0125a3741a5a7df9fc04d49ec8c4981f03622cf25e32f1d11157ffa5fbbea541b7a85aaf366bbe7bef8bf8ce7b97a34d72c08a2b192e83cd9925ca83f22fa0822c4462b8985d91ea3e120a2d9dd07e4b27ddbae7b09fbb09a2c05dc69bbc36088f6d515f04c64b563fb10ab1b9a6c5313243b07e3afe7f8a6843ad179d4b89cdb379f1c281fa8622c5a997a9cd73c904b2fa8741a8eb08112193e7774e448d8e579e009652d886f7d57688f803c447393aa6dc854b7d900d3194f078da1b1133b81acff0a307657b52fb423522d20bafd07711fbfc59af8452373f61a74a55b50bf92926ef03cb6cb906006e3259a366abeaf992f44dd51bcdef3d49a0922f11190bf3deb9eeae5f05b3a121eee89ac6ec47e960aec9bbdf6b85871dc63948a9e468be44dab3278b56aa3c368f434bec76e3c11e2418ee16d560773060e2185bc4daa3cf4fb7b61ed029e416a2fc8b5aa31c3be2835040afddd0810d61dd0ebe0fb0438c0c09f4c06ef1ace1c6d4cf6e1415975b1fd5eec4e75cff4f6ea1eaa079a40f6672af2d8dad9913c9bf7d207a790fc905a69e0a67da2d56ba593598eeb763e338db3d3482dae4a208d1f3d3f31715e0ebd27c4e7f8875c12b8d8b16658ed162ac848a0d20879113fe592fb0457f42b6ee02252d05f4c7885d42a1d59b2fa378e55723bb78c8b7e0f58ad5ab668b0c42b738fb940ec11cb1ed412566cebeedf05dcef71391750450a2dae5a3dca1af03bf2c05fb074932325f1cb138183d5998a8e2d6628fec8fc524a0443ad63f9491c527b1e1d64b1a50e45a63060b8aad14ad23cb10f284532a3bf6d8671dc7ba8dea179aea88dcf0f1ab583370a7c34d2b099ca2997873dfdc34d429dcf166ae5167af9e8902a20cd91e1acaebfa614696298a9ebaf40e643da495abcd02dbea7a92bd67381d0d4194ec46f8dba58fae137504930a2c2fe5f15c31595809d8629b8b0f4351a5520f5bad3d2db71de2ff85b973f24caf21f7ed9533425a8956abe70c6b83239c7ded8beee00e9ebb7e46e525058d4760ca253eb2276d9af2b3da5d367e8e39483d339104957a63b6f70a75c94a9080dc6819d48148bdddcf698668795c1707b9d139c94b67c8c53519c91fdc0c09c3f88935effbdf587d47d0992ecb670e66f78c8cce4243f3c7ce4884d74a820e3e86b2b6b13d50e4a44a7e1aeb0125e22eafaf9b1317102f383bd1cc0c44df07bfe33fcebfa1a7dd4f1f37fdb3f5c8f96f7304ab1132d529ce026b7e80e6565f140e079b1f99473318fddbd082d557e24e5a63b63db41f18fe7bf186c13a47fa454c02e89493564fcae91fc75376c5e59db76438fdef61a54412e60e739bbae85989cde852efdc1b6167556ad8fdd87328311d53ffa44e5711cae0eaf3008eab4b232a480e86b964b9919ced1c937b14e23ee19c0c8ebfcc31df8d40c40bd28eb2cece01953c8511e915b1349a8b586f7c2acf2c2480afd1eda5620a9a8b35a3187cf66c1696911ff7d3212f5bfe0bc1dfa295d79b927024294495cdf04c35c6825c18d2fb37d772a7f6dfa80f97b6e82c2f84455c4b46c5ddb35c40b927086c990a15f5dce6189514e54852fb38e41967b0da70eb775efb6df03529a490b97d188e2540941b44ad9636ed12087757c0fe05dce0757bfa48953893db035fc95cff852a76a71cb401ac51f9e3651f79300cb012855b3ac1d33ed039808f4776d2dbdfa412e60424d4535dae3df73dbca44dd72e214af2c4e276a82781820e245d8f2b26e7d3305b8294620e97a5fa55c13d48ac3dffa4e0a23f037b4fcb090a5e3a75396cafbcc9b6bc43089818a451f42a528927e5ae959a43ecfd8be4a470cb9fb321d511b05857465ef02513a8a3242aecb393569f6bb6032af26a990bd9b75d8a81b8aaa278a6b7dbe1e2742a3513bfd668151ba1e7c05581f60809c27783d0897a9172ebe27654852e45abae963a8dfe106c863a46ef4b33062d87daddf0cad10fad9fbed9eec5987b8f3d8426f2525eddbc578ee292fcb4e3ae6e47e3b7859feda238d534fbbbeb05c585999c21eb424061ad7437df70c995c7594c9249cbdfa1f314519fdf4610d64c719b64673bf5d1ae4f2c9cf2cb265e821c67b1cf8f1fc5ab7df624b717a1f14506c04ac997e3cf7cc8b181fcc84d8664ee0fefd08161457a1c8f60d3234c0b929b7e2b44acfa484e1cfb42334def901a4b0428ce539d7def763fb20b061a0204da93ed2c804e5079c98dedecb34dd72fc272040db63ab7e29caa7aac7bfa22f8b5fcd61f934bb320516f02d297c572adf0aceebfdfda9ecf3060a49af53dccb2f6d2133ae91632ffb83fd94fc457c877988ec57c39ab72a558603da8a8fdc0396c5d13b490453bbc4d7fbfa0d0fcc365d398a5cc5e047401265cdf9e6b6f9a74e3ec18904c38408a744e0cf431adaae27bdf41d63dcddd5327f9795fa4edcf882046e90c33feb5eaebf91d70689b11de0c29cbb72eb8d3a85c10ee12793d1094433b3382cdefca7547b85bbe21f6e46968166b11ffd2a82a448c696b63e61cb88ccb7248f7e93bc7953197d1fff1b28aa1bff7a5bee2e94214371165306870fec96e7c77bb78854726df91723aec98d7c63759d5c815949efcd9b0dc09bd19a479d8f23c0bca2834278264136820f13c75516bb11d53f214239f5ab0ee806e8c5ea6d032bbf02a91f8af999b289db25a19250a5ca9838986a0d1c0ea1c58782724cb9458436e2d4fb3d3256f10f890fe8671c690a4fa4508c3ea50954105a6c6e1f4c91fa31b0eeea57e9ea13ad185791effbe15fd78e6162b583ffc0789556a205a9fcf2816e168689687f629fd851129cf501c89cb1ea128eb2416d1db04130838004e215438520661d410b3294476761da4590065f662ee5582397fbb4a8953808d35187c87cc822a76f6d307c8d787af072906309d92f5ca4e71252409bf2d4afb1de4f1fabfdff678be37373dc7ef7b7df5025b6895377a565f18dd1c960d87ef693edb3b6a15ab646d38ad9991a3d1fc5135a082e1664d257c95733156a73bdab788335991fdeae113f37db51fde7b38c1425c9f99340c4e1bbb7b1b7837e550ab471a7b95ae642032a577e31349f23ce970c4fd2dd4f63676ad065efa5b20ecb12a09593bcca75daa9789177c74a0fa90786873ca6eb9f9c1844d8c1f1125be38e8666abcf0ff82f575e314b5d1cd746819a37e71f6d30aa5ffda2a3abebaacbfb490c1fee9274875396ff175020f9aace7440ec4e36f5638740996b98644d7304d75b1f15fc50896713968a0939a7635c4f8891000517b1d61ed7dd153873b608ea454593f9de52c7127594ae286640c0772ee663fc162acfc01045e348c68a9fd69bb049b8a1b7ba19275a1fa1bc0302d0120c5b22966c7e64ef9c44f968cf2efbf48077e3f32277e70731057c439c6cd34dd5394df4bc592fd03da1bde306bd33b5340f571496abe3334747cb9ce871d8af3821f7eb59a1267a59aa04d5065aa5582af7a7c2342adcfe3b72a496cee3dc7365823a8b9f364260350043744ebd559ed48b7eca0e0dcf3c2be0645f9abb04d98071fef1f12c731fbca9b80cc24fa89eb9164c0c79865b412e0cda68c291d865a544a7d9e7db47e1ca06a8f28e51a37a38a88ce27b730d7c4d337e98c5819159fc561afcb8b6a82c126514b7a2b0d82be498171960800ec37c478db6337453be8df65f455061c6ea152d07b4492cbb120abbe4e1b05ea595c9a76ad3f61e44aac0558e2f422775b4023d6e2f4d9f0f4bfe2c775f1aaed5595571b98ee0d82f5c1876c27e435a5a4c7acf457fc357565cb4c5d7fe2b3ede36c9dfc497f7b1d3ee92889bec36b30d11ef4719dac4161663d270c67bd10deadaf2706d839a287506004ab6f68abdc10272aa5237e7a7f7dc34db91a149d467f3caeb4baf03148c972242e041437bb621ba6629dba33b4ff4ee05b56244b6e534b8cacdaf735ed7c4b07889c1319f63fe797d2abe949af9e1a3bc295fc0f835d8db30e8577646503c830a24b58d429e00d7112e874857b735a2619b46f42f22aca8b75e555a07da7d9a7fcdcf8660e5dbcfcfceab3e9564e9afaaa48a78b6831b721632c2a97842cb8013e2657ab63289c12b9256bf2d3ce9f594b2445b7b78bc82bbfc723d50f6f064e530eabfc02867dfa14159845cf87a024325f4b226f2d905e286d14e65f5c45a31f479ed5edf80a27163eae84723b706c82ce7599f14a011c54df00f1d6c4179b6b643252b298414dca4fcdfe2f3c3152c591d9d68dcbba2860122c98c80e96a1731eee1ba824dcbb09e51f8d62fc2d3022cd57ea5c73db2727479062e1ba1a40f167144b2370fe1a80ffac862584f411c7f94c70422dc0e2b6ec73fb6110571bbd7d932aaab9f87331a828c7369f8ffcc3c6e0dbecf60722105e999f9e63a2e4352e01b66049827adb1cd861583858800e4263c142edc55d6d6a60e37fe03bf4faf5ade6869963828f857cbb485cdf50d5aead69464db6a50be797177242df602bde250602ad45730ace20e83cbb8edab51812a02b6d5f95c7f1e5d401360d410f9cd9ab870bfe10094720ae02b992f77071b9a69a147acd3aca186958b15e070106e5b630f2df9fceeafbbb80faea7bb5603223aa9e8be945a03c49edb838dd3acf164361d8dae29cec7fc47621dfba6448560ae77f59b0dd96be53bdf19273778dc436e0367d14189acfb80ffa3d6477af229f879c0b42f139cdfdf55b7ad719404b51b4f10172015e07a8919c85c61b6c9d32c25549bb201faab8b34ce90ee7231ac6abec2b868bc9676045192a9178398092524b2d0ca4ac5e6756511486bfce8af0bd74263b7b24132e356f4b770392a8e5feb3beea59f791b9f2901d66ce3d7476b48ec708da34ba14d5bc516418feeeee7538a89fafe77c62b5e58ce0243933c2763eadf72a546c24468997d777ee6e0f079e0292661fe6b6b8cbf3e01a3fb26322d0454a7b6f833afc0df0e0f6b71510a78fdc69102779b4c29dff5e7307cad92a94265209e47f08402ecbe31f16034eb509f823afbe452b8915f38009debd369a6082ba4dc8bfc505d6bb1f69ab6414bce01fb5a711c7409a9308fd90875cc8455e2c66f595e4f9f4cdebbb3f95bd081a7f29fc55495efc980df38dd1bc0f3b6ea68594481b8a1dac5919d2298613fad841653b953168dca9cec1e4ca255b4a6e022f5badffc9eccf871ed21818d8973de2813ce2470a74c24bb92cb4da7a07dc3e62cfa2bbffe2247d62eb394d37effecbd80ec67a13b1470a5a00231c5c6a90a113596e6c925d19c48e18de42198c60f69e0f7b572c74c4916f9e61b8382934bb2978df034210d6b8cbbc13721b149ab75103ccd8b95e19a211eb1deed325217b83e0a5d3ca9dd10f5f15bdd74f6390c99458f8b1235fd0df30cff5bbbc18ae51e6c68f67387ceab18138fceea33f2d1cd60f61a30badbe641e20eb1f9046e458194f7acd3c21ffaba60d0c370f37b8dcd513b83c95217253b9924e5c94fd92ec97987cc22eb195eef7a1273ab6bff221f1cca9c1192186dc97bcdc3c362c49c0433b56fbaad51a49a3886ce6dff75a2f50610439dd50bdb17f79edbc5b92b1484b90c3d2e90f208ca490e9704f92d8f6251a2c68f3b63c05f9b988f7f8e38a654c41980d7e3dc609f71703a06f607abe3dee3f1945a2092171e8c5e57cd8356d2f16d6248be4f25ecb63bae61e1133569b6b5fbbc9290441c4616c437134e37b285d830f2e8c4ace0c3b6b9025764a08edb958d144cc5a18242a5ed184f9dad1bb8ee6cb6792189896ecb6ae9a55337fa87a9eaa549251c57b1b1e896ef682cb0291aac49964f2424c23121706ffeefaffd115e9fcd0e592994d071e2bd209bc4dfd8df81ac114be6a1b199d8ff9aa21f46236c8466bf6aad6c45bf4670f2477c4b1ac88d0df822bb3d6187003e5ff24182d0f357de6a4be2e93830f6a731292078a6bd10f72b293a2f7adbbb390c175f5db8d5d7386c6db061060df41bd4ba2db61ff377c229adcb4ba14adf01839221ce9d2588bd613f12ba2f6a079ef4715bbc566dc31411297892eb4f8dc17b8165531433397c052cafa0db68cf381e32f5908fec7ba3646252018055f1976d1891a97aa3c790e2c0c629fd796ff8316d6ac816d1a6e7daa4cea50974a222a52733f905ddce3128a649a7ffc385068844facea2b643e7ca79401a27af90195ba5d2f4407272ca31bd377274936f5b58f2aa8f25302429f4780cf12f2c79c0f8942a958c42461073b9fa249572cb8c2860e8c0c5af0d1d9a43822447c559c9046ec16de4057376214891b3fa90a8858c276ccb104835cd352ef5e2cc8a9a6fb88585ae1583cb93c3ea410f7033bda8cffdd428438e73a431e1b5e395eb5bbf9fd18bbfdfe5ea87408eec05ccb6f7822ed14ed6b3d441283e44061cb8cbd1a1559cbc906970d295788d8a3fe7c48989bced46419597312cf5bc3ef0a28824fcd5b453cefc201da2093e2691eed9049a576ef43e1832321806a698ec8a07ee865d504a0e24b247e0ebf3311836dbc92dcc3ae103cb777b978c4ca1e772acce47eb4b33fcf018011e3a3f2dae4431bccd0d90f170e0a20225df3474488862fac73017f5f3fc57804078bdd1c372c196df5c5dbe1c162362d5b87907b4f25b96feb920f709f76b44d1196b2a1b2e76f4800f3a900d714de1d7e3a985c7cab8f92947666791501c19ba106985cc8bdd828768324e22d3773ae6cd9877ea034a46589e9dd9aaeb922d2c6db53a4062d6278b4bee9ede12985c8cd354cc1522b52ba0a42d1569ec38240855f6dfd9b247bab7d7f0c300867dddc01a1fa678cee639220499dc56bea0526da0d545d26b84311f15b80e280eecfdf37e4a6a013377b231237c61ac773c3d7979c6ff8db6fb1373d4c83f37c2c27716b94eda35dca59a7520f84f2e4b538cd90d770ff502d8f2f268e342a3b6f991409f72f877ec3eaa5aadf2a74bdf916b5a45c0c7d77dc5687c1146e432635f4c1bcf230a7bb9dc6a500aed927c061ab476df3316093a95b70dd828660e261f5c1e95317bba181b5652c68f7c4f8a5bd108e28cc981783ba36553a2e3089b4457c672c81375b47971bc46265614ea503eff910c577f24200f83a41b1a050f8bd6e5aa24026264ace453d03183d6211214192a6de6e4637de3d66f6825620d13e6361418f8bc73408a8f58e954727fc52d8d7ecc270b2d38b79585d8550586339632a7b86e98052895db36b4236c53150cf71e55ff77af52bb189c177dad3b99d465e7e6f80e4c8b1f7d48482a13d2e3c9752240baf29338359be7edabe571bdd068a3d669d92b2f8a5c1bd5910814fa6c8fcc8dc16436a6037165caf9bd995f6b8d91e121dc5fc077fef6137f123fa2ea67a53d4d8f8aa2f4eafe9df12f79d55f8b5c10bc19eaeffe792b3e463c512737195471f89a42be144e2d01f70784c5451b393da03a0da8e13f8dfb91e3519ebf224b4a8c35cebbeb20e5c8e1c1cdb55eef8e539d95309c2087ca770b1637b4bf36c3f29cbe078a9dfbf7092dba8f6bc4d350a41b587bde959610aaa2762730952f5fdfa1f65b3ea83ffc42101a05cb73c88fb3988ddfc565f731ca044f1fb2066e3d619b32da9c87173869cf1639feb2f12cb176c2bd68667002322265821be15c2d0cae26a79a3580c205db44daea1b4f873ae862acc4b59b4f4861c158c100b8574314d2da2057c9287ffa7a39ad88dcbc71a43273fd5e1bff2a23e43e2e0c5de176a39632993913b560c6a85e445f6a5c9a0e7df69336102dec1c0b74fdeba19ba9ab71faf631c1d1385e31d1d5bc237b75eb382f1380eba86688f0ec1c9cf508a69d24da5183d5f1bdc953dd43d58cf698ab1e6344332bd3f59661d06fe917c53f329fbe686345406d9e20b19d4a894066adfd72dea4657a1dbe9a0aaa405e55f3bb6b38c3ef25336f9da85db9f0c23bd677c6863033661a4842348df3ab6fce016c854db7b732596cf30fb9288ebd4dac172ad67e4ef0826c781d77b17b3e8d7d105d685bcc708496a9a7928e4d2e73da161f55de72f9d44af4f0b9be140d4ec15df495fb83bd6bf9be64b13c4414d3cf09c5fe3da878fd8083ef87079489b1e27b0582cb699120f355ed917e5f9d1e38dc5640a945ea749704ca151db236a54783f1ddbeb08a51ffadbb3b972cd7912bd600ed697f704c5fee8780edb8ce5188d9e1a92fe48497a46428ea87e4468857800e6050f040f3e92c5f827777eb267c02ea2d5c3603166cc2d84caf592d95f09061ec5bed166e699663e8acc3132ddeeccdd19d8e8009b54a368b9a79de5159e46f3dff0b585d002fd149997ac158d25dcc3cfcb4dcfbb18a5866f6f6fd877d1a447cb2066755876824c45be9a2085046321594aeede2712d9042986fae887588b5b81c13eb1315526f91f87598813181dd6b333e0a9641735e42cb3667d496c856c5955f6513a38390c455cf41c6964be2e5d110a46e0b35bcc8866228744ce4cdd1494a9963e80211afc55ed86aedfc6eb6186797c0c9b2ecc212dd01fa9fc6c5c9406996d8d511ac82a5b27793ebfdcb1e563d100d5bdf670dbf18af4c73e124bcf137c67cf4f2f765dc517d40e78fcf1833ba9456d5babedec8505da926b11f7536f0a1d39f5cb61eff83f51ae5a28ee3ea0ee03e28244c7ba170c7fe89c600dc7535e8513673beb763d12befb33cac904ef6ea09a8cd42cf89f39cb470a83a1de9eeca26a93729bbb7ba99903c5f92d74cebf90c5f219f138aefde0bac38b29d7bf47bbb5035d9d57eb25f6e4db57574d627c1e01c67f7fc027cf960a4a4c154e09e1688c064cf845dce1bc9df3cc7b4cfa3b2231af88aeff988474a03a5c3ef98423b5542b490620d63eb029bad8ec5d5ce104b614ef64258becc50856c94051da7478ef0d86e9dd1b540aaa90a4df1868d9a05698f9f83446b655049e395f8efb45da07ce99d19fe92070bdee0e836d106b7a0c81673a2e5ccc85d4fc38d23a94bd643aa6ba58e3330bdfeaa62db43f5435135692650ac41fc98bfcecbcbc0ae521751c3a28a29ea591ef798cb90600891ea45355d54d5184db5e492cc1fe20d4b3ba9c656d0281b281013a847f9baa0592c4772d5fd38c8278fce046413b4ad88fea14b2f89ef91d4b6e6a30b7a2ca77b9a1c4cbe6373ac09d61e9b45e704ef35edb6ab656e0ccdb6b453da1667932d113258c841330122939b26d7a6ba53132e83a22164c77cb592e537bb73728fe9c8b9cdb83eb819f49be85615ddf42f38dbe1e204fb32aa173530492499e1a23fda8fb0d9bfe668a942d531a33e2ea7885b58c6dd2b94e5affbc8489cf127fbb9978c4cedfa1c09342113dbced67f0690a2e06f753bb801415edd837d3f33d667f9ebc68525d88e0e0b12915d5684c87c7752174f10733be81a98f7dbcb12eea04b28bfbeef898297d995ba9b36fcefad26eef9868e5cb289baad042aa2bec88ee350a22de6bddb910cbd6d767e15e04173a4a616376f1b0d6cd635d10c379aa13732d89e947e98b67edc2f1d52825c0dca8ac196f6c324692a9cccc154293f6b54f2a03db0ea7821e36b286e1ec029c2ddd8af5dca33c1c1c9612df5fb21eb2f19e5ee8fd7280d3d27992ca245f1cf7bb8ddcf76a13d57d860911581c34bdc6f2a0e13bd5274bcba9b18268bcf7539c57ee2ee8e8f5034f69b18086b0de8b1aa4881a5892d9183ee69bb70fa2457b80b66af4e5cf4a7fc9b658b2308181b33fe30e8fbfe460133fa0e97065bc8bdd2a0af143ad8800ba2c4e1a3a992a860eef5fc1df987b22c829542d1293dbd1e667f58d872f333715cbc736a5efcb4f559ac32212b6e7a19acf9941e4580f4b1deab9b5bfb53bb240d38ac4e1fb9aa0f07042870254b5c4c84b29c6e8e9ca9c2cadd648ff42fd3ebda87794d446a38156f064ec1776a46629b947c16f522ce93b5a8501df5e202e3c3159a7233cc3aa5faa06af363f3a6efd1d686f95c09838a586955bedadc3a50966c80d0672de2205d14fd0f8df793eaba0a1eaf4d1a8ec7db797f637c52aeb24f43c3abb55558afd2cfb344d5a28cdd60d2933e46504e1f055520cb146131d7437041a0dbcccdb59518bd31fad044eceeadc174c8e1499fc35961619f5cefa4dc476357761d0c78eca00d93a2b7bb2ca9d33e6d9f56b26df8777da11fee74975be24405df25f7c45caff68645bf5b2b1ee1079ce369768073c99fda9b630b319205b083cdcbd71caa3f1c6143729ef6ed101443359bba307e0800941833bbb6321e3e92a472e50c256b58e9076cc61ce085c7d2d03491d33ba769c85ab3e42a53c60c093add0a2d79e5a4368cbf748d2b828f2269b9f03abcf06dad43266a11426a3d995e04bd16b68309e533c44d5ad5885139d2abef6b2f35dc62c11caaba89fa77fb383798d2ba24babe103851f84d509290128061dd83e8f9215d5537aeb79e5ea62a56d0eb8d4b8d1d7099f5d119a10098901a125c80d963e3064db2a8189bab1981be9d2fcfed46b10bdd28176bb046ed5739fe8580251a31a0e779b8cde184a239849f7cb7a3636c6092997199239f59d1d0e4d179dbee0ab619a855d8f70e0eb02f6ae93243e09d7536735f489c683a09c650a3398d21a502f6e0fbf10bd5e1768ed519f8490b29d9e8fd3593efb6aeefef6142dedff24f61523209bfa85a5ba6a8ece9de6fc06dcb8b1f30812069c2596a5bb22a663f1675155564680da329a94fbb12d2eabf9fab8a75a2097223ac9b4eb6db578d04aed0d65e77f9505444083bb3a03bf85c1617d8ed030cf3b1797e85e265354a3e5e91deb634c0a16ca3082493a52f97bd07c79ee2ce6cb7ec5584611c13d614794d85b6293bf616f8789f93534ffabace791a9f57b2d60b7f38b494e56c2ad3d83673aa778f723b1f1f61970329ddc717f40e0b3e13df05a7b54790ce615e12119f8f49443b485f2829f1d2d973d9941afe210651e1517cfb355bc2479c88a0b6cc8ee06227a0079e21a791ac49ceaf33b8de1ec5a8ddf5f01873273de32d3734a583dce1e40cf2586155061ef0e271d4acd9f69f2ccac61146a86f73d015dd8888d7c32cc2d62c7158e0b13af23ea7ba21c66b43ad26fc5a18681ff4672d260dec8c9b1750451ac650806cc5468c68007e3428063bdfad11fe67baf1abf194617ea1231e210b5cc8378e356d458f99f39af7904908f0e30633085e68b6628cbf3cc6f810c2dc24996e38a81f6591125c0a07edbcbabba7d69248a3131ee38d66de145c45dca0f41d94e37f467943e03750eab9593a96885195a3e7fef3b7cc200d8123ecb643234e93003304b9519078c9ea87eff3ddd3a8f194f3c1b6aaefe95697a991b1c7bceab54c73288470bde0fc1ff764e78b01924aa4d101a4e44449dca8d4dfed85ac8a2a3fc98e960b809dd3347ba44e6795ff65f758205a6e88db2a7792d9c4476030d8dc9b707a9d118b5b697abbd8d71498f78e84aa924eb04d8eeb5443d1703da3dc7f3d1c92b0281221079e98f0c270aece45696d3109500116460dd5e0685a822175897225e6419b2e6579d8a2f8669995008c982dfcdd5037673d9e486e6d00dd596376acde0f39fb35c2ab3261cbf56f02d07c89228d3b1c5e59426d00f215b2b5e33235317bad2853ca74d7eb63da4a216c1ad25c1e22d5f3cd4729093312d6788d625eca46447089bfa67cb8ab3327fd4c73c60d9719217394599f296dc6d5cb11ab676325a024e164dcd84e47fcf301fcac9d9da5ef07f99e8867a6baa04823bbf756b68b76ac4e26fa51dd15196ca2c0cecfcb2bf7620d69cc4c0c765e7b8ad43c75ea3edd84a1183fb8411f289af17c9beff70f07ff0180f7c8f2b655a9e72447e233fabf6cccbe4b1459f17f183530c4f217e7e811da6cfa02454d61249f3ad03dc2bd36f22f5740b1857c4139b1fde573a40385ac1f8388946b9859b06f9c2f1c72158dbf50ef70277a54546f3312cfd364f7205856b9de9c81b3b415db90d3e3cdd96168e98b6f38cbd6d1e37ee24cc6165a857b5fe4042eb5f680b243944a4d416098f347c0b373ea3a39fbd17f45222be6d25b7e1006e9c311f9253e6d6406f34456bfb9bf1b69ecbf0e1d686064683b594bf67cb31ad9a68af4d507fc58a20e5caac32e669bbca0fcae7d4e6474f45de340b0552b5b3f83a588a3326addad00ee7326d45d307447464c06815463b053203f18b3f307680903706641ab59eade39b6701b14dd6e04327429f736728745c4d1b57c4bb1349b27c0e45824e934b4539632b175eb41c533a4dc35a0d0f59408ce6d55dc2591952005fe15e5a07637543530f0774e30a80506d1833c2a2c280619a4130cee0067eadba97abdc821f612c88ca4ea0d6a52b5915cb904a26ba5f5219810028ff2c3a3e920c636f5391bf5ec04bb1d91f7f2068c9a90b531e17309bae66b333664d219a5690b03f8e9c80032a3b869171cd4aa8dc5754f5d96a3f1a6fc3d77467f34cd0952f7c091d97b4a12c1ab965dd88bea4b1ab76acc7b9496450bfbaa0ca002c085372af6624400726ea1ba5b4a1fc76fdde9757bc85af9e854d1932a4c0c1d1e96d3d735750302422c8ab5ee0b7668b6e5f3075ba37b84fbfb7d318b11439ad08fbb9594e5b8ac84f9901ddbca8c6f8102d37994e323fe7050d6194e5d6bbf7c297a32412488522606d0a06ebd16581f6a0f0db1083452a9bd249f44488a66ab99ecc808da32f20567cab0d02b4485845378f6c760732f078ad2b1a4a931b3b868ca1835228a8c5d09adbd7eee4ba6c0b6aff0094ab7d8fcde21a66cd9e5e62340070fad68668377d00371e0a5cde93741f0fdfee950bf087f6fbf966a5d90764ac9c99a3f606fbfefbc2122cd885bcdd1f80d1274b188ad0bb83a3040b41440bbd6e38d877d64449e8e57c63d25a77b06680aec7e0b29dfc1e9f364717204aafcde21d1d9cea0aa794af57739455de3b3d53a54a1ea0124b4f5c4c873be9f0b11136f34d691b4a9decfa16a8542b96f2762a27c67b90d54458bf22d85086d6c511c58db9689ba5816e977495e62c15d1faa4d1e06038d8e390bda7359bf4ea96596b5a5b59fe6986c8d0e25a6a9226fd13ecc782cb832b10044d0a3e0b9f93c95a7e804d83cd7d8a02a888224c6a021da08d029336ecb3ee6ed27a41dd9cfd9075617b3e1d2c77896d663e0f98631a1587db4fa41edbd6b67b210f4eee0e8091266d9d69cb2733143827b045438dbf480fa0ea4ef4485dba53ded25e8f75d5322988142036b4e426be1c68155b092277b58767ed7aec0d8cb23c55572f225abd0464030d20d747c8e23f36b512f417c3f9df6107377df1c7ae8ae55c9ee5acbc72a03c240a8602a7cd209d0efa88fdf62d13dfd61cb47f88c0541133f5b0ec0f1ef66dcb1a62f6682a00480159c517c22e3c52e2482d332488be372860db8fd439e442c8efbe16649c3bdc3c6faf927661e8786a3f66587ca4152560136d88efc8d78b8a520f3cbc21e7dbc92bc0a7979aacc88994611b3adb0fcf7981f6919e61c6bbaf531fdb21b9dac2b30325234412ae9715c13168320a49040340b6204a4f6f02cb264d1356f53a63f67245ee04fe6970bc00dc0e117368ffcdde335a7021aadcdb78b0d9fbcf1aa594164b3620a2f95fe6fb4a286e77be1e412f39e3f6282051b7e6c1a34333a290127d37449716b52a423e510d2f0c9300a66951c65232ef0914e08650a81ae287d2be63ba464eea1da5ce0b756c0abfd0607b26262ccc69f2a30770f85eddc929e6bc7560994b0bb10035b50de5c6ed690a9d05722a352e4ff122e11dde04d6b9368a92a21ff5063fc0580251487b7d2ef4b158d066ea0b7d4a6ef57cc830bd72c531269bc717135f1f1242a5208fcee241a12d7207d2d40ead2da4a50cb5be9e6ca7976e8d068dc2b666784d2261e2da4182265813f943e5c5dba7f08b3d0e8108f325bf51ee0cdcffe1cc117f7f9ac1b58f9a20840b27dd20afa8c69d97050322d5756b6e685915a1296d65e1a1592111dee7da16b26c29ca66f91cf72587378ced93b83f4a8d05b1525d410185c01a0c8ef1d4b447b524539a2270060820ec2ba42f89eff6353bb90999138b979db2ee7f118934206f398e42ba122f30cd1156dfcd08e22f71e307598baeeb60dcc4da0400531de32c843865df13c9bcf29fe8f0753be520a01241ddbd847be1230cc0c10a942f0f49eaa0fca3d073086142c956dd29f0d855f156ebd0b0986239114a9de58a6edd54bf1050891cca76425f374f3d4c60d7dff787f69f257408a41f8f1d4f11f4a82486f8d2b72a3c5041260d96da7ab94a1562de473940cf03ad0e7a22154f15e793cfcf0eb722fc2b37d6f79b569fe054b10371786db29f1b1d7f2f1dd3f83968c0725b13af913365880886edec3b9751b691f03adcbaf2a7c4b61d6e99e3529e0c09cc778d9e9bb93477ce503cc57f3644a1368989b4029d0861f097ab422910d2b714fd257eec09791fe83317216177593b0517c891cc173e734fccf7b5070dd103225d33f0f525bb3733b2a9e57bb6e45e1b3d2636558de18b368719ff69ede9ebd65425c93c12ae8987b3ac0279641f075ceed53206af6ac1106ba545527ffebcc77b0c2d654a18378e6cc1f4cefe1e4f0d1b30a70ca1dec8630cfdd1393d44b3d0981ec37a18fa42003c783fbec75a2dc053f54fb86b221869c54e6da3ecf221f87cf8ae230ac6534a31c0b64fee41bde2e07b470056b8d42a8be64fe3a4d860f8b3388b30b7a2f97604eec911a2bc5b315a30c3dd08fc023e3c87d862f0e61f126d9b73c093c47de9dcf0a218f6d895909259e73c59c2e37dfe4550db8fa0f3d59da42fe20dfbe5c6a257fb8d491c00c59788198d167fcdb0dc34225a3263160ed80e8e2a184f9f3b6028add689cba158abd1f5ef05f059aab1f83369ba7bceff56cc7aa9472415d529eced72883b6b768d639a118ab7684663ceffad84ccec4f4ab041d7698c84c3ba5d59489eb7fff5056daef9731ba33261421f846e89ab55b5edb3e6b9d2316f288a04230467040e2c9184203a0d6e010bd0274129e772b96f8d477b720c7a2a10a8b5fbdd7b1d00d19e2ae6a6a8f9f8494fdb1f24c3f1fbe2cf215cea734be63ae61e09a5faaddd68b5f536ea997df7e5e48b0bbac66b15b299ce887b7c62e2e416f0d6b650717ef15ce545cef2ba6ced2f3d956dcddcadf2ef648691368378dadae428ef5a0ebdc56800503786146f67952def459be3aa3d25f049ec6c7e902eee19d616035f6aad063824e17095da263ea9bed265f5b218c2b76fc81318526268d43440cd37730da1cf7c4719240fb8afb28b1a53f27da5c2e0441425c20da520042ce7b35f2e8fbf9dae41c305a1d2b032b2af1123eec85d3373c09825b4e929b5bde2200148bb2672e7812da4c45f9d3e14186df4caf61587647a573457ad3da72392e1c15b0d5fd31837365cead1140f4014bfd6cca6ce890b0b0085b18888bcdf948c22d72c046d8eb9e94d7cbef498d282aaab1eebdb9f86ba976681c2104a71396039e7f351f7c64ad9eb1e8338346b16e2a7d7fbd82ad4b43d1d844567a85c5d598470d377771695e61e3942cd51d0a6623b2723e17b368aa8da00de3ad5067fdc08071e34a046d12a7de8414229a778f5252edc2425514bad3c3bfcf63e08fc7ef80a9037e3a6e37f4dfd436b82d82584aa238cd2fc5aff4f77a5ec46581ef68e177b82a72f63e265df9a52db32e9e2debbe10eb1808cc339475ad76296553bddbfb8c4fed5ca1929d5a8dd816d15ea58f6ea4e3d0dfc6efc53daa266679a196ee5c628a92d14034f8db840266265aba340514f35221e8f32beda53c58a494b63fc83fa982ffa06fcca56782fc9b33423941b3d8bc32929e0a0d3ce82ad132639a7da8a9a5d631aa289ffb0f1647aca1312e1c3c6dd2366d28994c5ec250eaea1bb60b891418abfd7086e103be728d14733c557ccd406a4675990a7c85ef2e01eff59a4ba75755c177980a7e4f13730f552a45b4fd2c96215094c323b36d6213e97a45d35c1678e82758b1ede4f61274bb61ea3f6e847456f6991852c1824c127c573880972e074a66d230f57269bddc4451a80f31cac8d7cd5cbf8c31babc9a3d0a7bebe82d603dd46687c2959f16bdcaee64208400229db872f3f9676f902f1ccaa0eca8d55d503f6b98f3eb2a9e4e18d28c1e69e870f15d7977bd3a9b9d14edf0a7ca78d948c850fd0bdf9f065103b2d3fbdf394c5b7595a5e5114f1facbeab26189aa8c4f0e34018de35329e31a6006361c9df64cf9ffa70e4b54b069acf3bddac032c4ea089dfc9be433913723a325a4d7387168770d607d399e226ca9aaad182bbf7648ab1af840b659a27073e5abe46741633874199d4573514bdfe6fd0315ecdb64a81a066ba6ee0e9aa14369b1a4688bcb34742d175a373f6d1a60969b911b71145d474f5036256925fd9219aa30d9e250734d6d919c982178a8cf92d351750b4092313029eca1f9b75da69484549d3da2dbdce52c4ae4fb85db1a275be77b6afee7c522325a220610009c8c71936778573877872beb720f54f891632d28c2b6fe89985ac1ab7088cff21d2eaef32d4f8a5bd8e5de2e9c0a8bb840133902e0de11eea9d7fb39ab901899fbc06c59e28b3c9b8a7d189a625300fd508936c45fd40144ad21695777f1c43726f77a2266984b42325c9c86b7a0ddd711f283f02f8494a2cb1a0141296f2125c76022aa7b8d632d582af4f7e6eb28faa21a24c216e07ccc8c449ab7868de70da4f37873596995320f0521605708a7258f62c548aff14a0c8350a91f47c5eee695f21d32b5f53dc72adcdc455893869e954a3da40e5ec859d4397c4dfa55848ab6824d58d2c0eafa99b749537ffdfb719d9907f4a0011c065fcfd61c41a1572a85c099e62bfa161748fa67a434c5928d4b3e4629de5a6b3c3e86566457ded7ad5b2e6dc5264922846f2d280bffd789757deb0ef8cf2065c8bdc6839a23609a217711ebf23b64a6c78d199a2725a21af9002827e5027829af6ca731c346af0275a19be5618eccec209e949af1a7c46aa34ba668273a7bb42dbd0dc1d14fc1758e0a8fdeb3c1225cd42b163dc8b37efa50fb3f6fffededf15efdb911d9abb42c9eda3c8b77cbc090a5f49e9803425aca5bdb3b627773853512de00a49da234215f346a5b78aa352b292618e7e87ac180b7b1ddacef07e0fe02ddf252b6e3dcf63c7dc03237a5584d4bf7a455a2973e139f8e002b306efb0f5fe20ca069e19a69fd0fb66f29f82fed44e6c23620411be010147797d3974c4542cc8742890d5e0079efee78a3017bf6d3e4d85735d1b7805d756498a85b0e63242787c7625d76aa52006ffc0f0dda8eff8b1a4d409af1d6824c5fd588fbe5c61035b17bdda86f4890046b093e4ed37938929de2dc62ef574874c14bc78695db1a32a61e5b70613fc84df121965d9f75e29bfe84b8c4cc14f6200bfb4047fae79a8c4505c3adc1a2146714e2aa992445cddd9408c6b6ac2f85ea2a33f0927b2c60bc2a8c9010d361c529f20bb26081831f0b4e0955b20db0de515be6d9e2fb1ca3e5dc42568a323a8cc67549d123a12ebb0faddd6e124984e3931e6cd6357598eaa80a06ee2256adea1aad3ebf44ff071ef9e5b15374a26a60653696dede4a8aeadd93170993fd2d42017db30bd6c864ede777b1e3d0543e5d96ee1b10a4d5f62deb963134e2f22c61438004915708f537b38f7280e5e4f37c4a3ef9ba444b4bbac53e4915c40a539da7a1467757d594c45a8a6b414816794f0e7a1058e30e833f0617c003ee39c0ae7adae0b4b4af4f422b5c425a746ab339f9202ad84f5202a3387f6398139692827a91596a1a3745d6b23fe689874cc596ad404409f5fddd2d96e77ab8fb1fb0567cb3b3aeded44f64440c35e57c4779665acd8ead54994548466bbe4ef6a85d5959319b21ef9750da5af241287873f687ea9c2cb5482baba3a85f869ba8ff6f3136362e0ca0441f3e0e64d96b6bfd869f241465dd71cfb0760184ae5d878d678dfba75846eb5eefe6444451c27cf49e7ddbd85c52950fa79cb1cb62ce8dde8285fcdb11692cbb94b946408d7b8d586864b24aaebe9a874594199ea59505d14d92716bb4a84ce3e435a51a662d4d1ed69bce0f06b9a0de2b2625e058e906a76922a0192b51ecb12cbd9e1fbb06158bcedf766977e56154b156cb19e58a94b1d6423d9421f90def67af2d580d93c9d907a6ba2d92237797044a57d8647089d4bdbb9c8dd46847c767111dbfb4de81326b51b296d6fb86b964269536926086076f543d482baffc39e865c3994aa4273f6aed136f14e4ffe1278cc0859e07a4d0476ee22501d06969761aed4b6d9a37617b1290c274384c8fc77a52d0e3d7fa67d9f25f81836696805fc10fc7d55598eff9510a6d36459b3c2410ad13e04fadb83ab198e4f0b626c9dabda77ee83b272ce64d16933906268eaf3e4ccdc7b381ee6bc45fb0f85effdbf6439e3e8337c565f55630b2eccb6454e3da09c3bdb7e1fb1614263940514802c6216fcb752bbca6e5ef092389c8356795a24532113487fa79686db0f2848fe70fb0e39b21f81d70ea80e928872aed271fed6c1a94006f211af6cf37f51b4bcef2956c0c3c8e183a9ba3f35da10110c7eff94b42d33217988c4353b1b6bd32e0d65d3458ee5e77ced0a9f17d9125f41d64019ff4c3c48b62efffbe3a2deb7b0d8dfd30084005b1ea0d89a0495d7c196eab309f42c1a51d0e163cd116200b25887b5698391657c0ed7243cc0967f5f0946bbb28b049035e7614a7709a135212625a3523efa9846d2d67993b1865577379bb1986ac3a9ac5f7c7a754d0aa1fae6c75016696ba956676d3e2651ceb4c2f18b85fe089b386cb43e96848048a4c2b9c578db53e0f4b381f785dce76d2c5d9cd5c4d4dd9694fb4bd31b7ce456c98021e1e597f003287df7082b08b87e39c16c8fc7fa806c624595714279162ccf05eb87a95d6fc9d65b55fac68e304f6c52d20b851648f6bf08c2b0738d804e3b9b4de541583a6a5acae496b4371cb73bdb9e1763dbf3ee585ca9a5c858488637d1e8bbac8ed85a60791ef36e5af2d23d285f4813ffe93ebef27022b331185f0c22c3321f3f12172e95b290cf25ae4a53976c338dd1c2be10ecd67604347f0d94ec260f57cefd3926d4c0e6444f9e90a69332176689a5c74733a23774dc32ba0457b0c246ffee3ba04da93e6ea0bf476474e645c436cf7586a1e403a3724001300751878c2b1b4f896ff35d946f49ff1528e0804ad3daea21c4012931930f9ebc71f2c20cb8eaee2f8fa6d6b7394e17d9d2672888e85a04292277296881924d0afe940c4e4b5fa9c0b05054efecd0e40f48fd27be30fd05eeaa68099e73bed5343209041b36968dee6277d31b31b24d61f77c36f5ce8a56776f1a475432943d897b1708cb7ca33a1606caf3c602e80e651c899a73944f9988ae529e9d332fb0b520de1242469093944a8868a3adaf74e9c9bf4d4b20ea2c779d64a8635acf65251fdf39caebbb15d15cdf9d20a56a0f7ccdc346e1e51004d45ecf879d451d3a4d55d55882db82527d151fd517771527bdb1936042fa82a7107c14c9dc62f5a16d0db02c025f8a9301f8cc4c412b873efa0db1e2768cb23bb5a2a93b6227e366cd027663179c66c5f0e8d9920f71e0414eb9bf1d0adbbfb0670b03a5de17b746798d1d6860a757de0c60a6b4fdf8510efb045d36c2ea7859b1ded237540093efb7ee327dfc949f0be5e9790fcbdc917becedfc07db6deb79e1624699197012fb5f31efd136bab397e5d72e28894ca22857f4969acc8690bf2b6ae9b6467c746b5110db221183c77de4b42a1203ff1ee31bdff23c7b0dce8f50081be2675601010c9d7ba5ebe62a4f645c18c8c3f092ff67b4ffcdfb231387bb5981c0ae655b716e0005c48bb96d28ce844fd66cacb7ab609e5d51c99b098ceaa85c9f33e3f228580fcf5f890cc5333cc9ec878ec4e6bd2fac3fd64dc3b4e07b51a0dd912b431bcff4a9d55af485c283e9deb0d4cadac12b18bff07e6259ad34a68b52e0b73e680b7b7e6dbb8e702d5f6b1013dd250c15857b29ed27f0ded829357a8e96d774f172e8f2ba9838802c6a0ae5485c5a0f58c80c2e582a28a86696721ffc59c1e2860ad0498f158416e3e698b0eccdf9451e7a6ce98ddb24768a60736cf6bd9ee8d81818ae913a98bb7b718d748e5c9306d4b734b2377b7cab5ca67d4e9c118f148577d8d4972c021741e08f79950c8688a4bbe4462e4d915922ae58114bc00367e1e2cd5506c4cdb255d3e085accd837d1d1386eb7358a77482062b529450a89e86bdc94c31b332d9edba24c02672e7103436e66ef864966100e540b1f356d8b4a70a626a211c4976373ed3b2563b2ecb3dce3f7a0f45c228c7e484cad9d116c536005c4e6e8aef95083ffb80a6ce1d49e5fc3ace263f9a095604218a18ac062c649e1301e8c8dbac1d46fec654ac8667ba891f056b5be175d1cd6c2745cbf41c555c09eb91b7ea5ded0823b524e35fce4e74a5da66bded43717065a6f3158730416d81bc8592ce6888cd33170fb2c445d5281932d7fe4bf79e46390c97bd9a3d1e6b8a2bd92404edfec7cd51b6fb2f1dd58db5ce27405c80aa51f786a7b6b9e6d20133c624d011eabaf206632e4da818c5138a93d19b0f48f7da56587ebca6c718e515922dcc1d1633d821ec57bd251cb4f710b083eb9c944f47bf8e173084e068b73c8be4063b1a6b11a486b8ed6751512f6525e055ce68852a0fd6a5bc80ec4f50d4f6ade7febb51cef7e836700ef0f0096df16631b71666c306380acfb376f45ccc6f8efc762277885d1e1eae95273131a224d1f06ce98d094359f3c4bb9522129229818f7839c3a6d1f696744f1297c29305fc928ad41edfb4610b894e96e242264d624fcf588d1549df18d6c2cfab6944bd9f560f5f43c79bc43902adf46ba55f9d2c0a4f8a611fbd60e1cd7cd8749d51649afbb795eb7c20ca4b5781d8e02b14c0e41ab114bd11150d928ba791bc6d1f9db5340c236f8151e0131384e2ee227ec983e562c8f3d14bbc952a75b3fb90394144c7cf97484554e65db281200785d2a9f4ed6fac5d12d33c235e3516c5b96ab9f2ff169d64e1b03947edca0f026025e453c86e1f526a44f2b6800042ee88c6fda1561e50f32cf74c2bc926503100811409c96ae4e9a036a57c8706af01f2f37c22834dd1e17b5815a2c5b2f002561cdb7b7ec8fe6bceabf2f30df1dc8032d0c508e91d6ffade2dbc168feee3ff567a52e58bb309cbcd343f7f71c31ad2d89d5ecc0d50dfeeb09229782dfb1f952471dd70caa7bfee7692d94a3f2477a916660c2d7f29060b471c9ec738fb289aa53e1bebabd0169daee9e057bff78b3e654176cbe60777e5855252c6d2df2eb088bb58e3ccf124907acae7b4931076595bf287bc47a8d782b10d31e64900a968b4aa45871f5c7685fa629a97fcb41ed7c2f6fe15c1ed818ea8f1b78f2bd2bad6abacba2d7f4c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
