<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17bd879e5ee6923971621b06e297fff12f4bb024e499ca699724f54b8ee8621d974ac95f3aebe03b30abc1c0325cd81e68841f0be11906576a74bafe134909d0b086d9391ac26c019a2f09251bbba08f4ca45196438d2584356535e1e6af06f494b4e5c0e28da021d7088cc3f6f2b53f92d6baf4d92c967f5b3041919e750666a204f0e2eb27d381e7fa1758c005d0ff5309052c5a15702f746f935ae8422ffd868738e92d52fc4885bed61bd4c3d0ecbca21e787b428ab29431b28332794358978c08769f0128543bba92679a9ac4222f1ecd7c76aa26109ec240edc64e9e06c9a72a3f4cad050820efb5942714b70768703f9b9308c4ee1f35ef33f3a34cd8fa939931681e74e44e6bdeab9965ce8f88c625a91042c4ff686ceb9110e31f3876c63e8259198d178cebac3556c50c130506bfd26e86346f8e5734efa3026bb0b2d30b2136a297c7feef6cb1d52cf649919329298bccb4505e0f48ad08fa8376455c8cdfd4dbfcd537f07a421c9a152b1df87c76a09ca30b5750480f2a5d16801acdc906235ef42cadd829a66b776be519506f36f84fcdb096d276aa0ed5612e37f07c4f10b07e15bc723795a64506af8d2d39fbb00f150f70df6bb23f23e96deb63352453b5a430493fadffff85aafdda92b27f53ac57cba2e09c588c67e6c15265698ca76a6b3df1f38043c0b71104dde4dbe6ac10979130b57223501c5af3013c871a34e8d1ed41b5b93d49179da39f3b87c696dca6841208bf484c3687b361d7102bf691db995433d5ebc5ad08d3dacd899ccac4a829adc2c501f261f76869bfc62d6dff64408a01d803ca21449912d7bbe1da7eaa8ab5431303f705028348d7707d28f14b3c11f8eb00ad83ffb863987092b7a4666014d1df6af848a50b3cc7f2513b0fa49941b7aae979ba6f5bf31069b75d19198a6b424fe3a831f7dc629f7e7b7481ad1d5ff620261bff915cdafa40fea7860db12ac05622b990b9acfae6785b66a86a563066681b68c2da4a9a4744db0cf5327984aa3b05db2dae1c81da96acd07ef4361d958711a3e30bb2d6c6e187453e5d9d99e7311b2c13d25320719579c912c462a6e3173fe3f889fe1dcbd7f7f9aeb3e44ea237f427f7efe36d673de9f1271d6ed3b2b377b73c3f91fca00f37404706e9f6490e58e8dd17508a6c909581ff83698f3c9c082bfd85d6499d7009ab6d5ecb60411d822f00b7b3e5f3e441f07759fa60f0d454ab0a86a7eb9d3abeef1c1eb9a6f8e0ccdae4c2d1a5bacae30865933d939132b32ac4b701a2a869f99ee98c934c17bc569bb2fe4c5441798e8a22f376a0e2f83bfbd0b112707887d134062fff04576ebf0cad33733355a307cc2ef565e4d735f83fee2aed525e327b05655f583ca34ef55beafeb657382c77e28045e78cb21bc3e47e71669f408cb88bf470021081a85bd908bc7ec26f2a064d1e14a0be0b8e239dd0299c972ac055e1040a7d86616c80fda790b5abcdda1ddff9dee3def6efdc82dc6e6f92397e3d2d23edf5039d77c059f004ce7db43660ebfddd10e8f5dabc912041835dd04acd90c14202ab6d7e010e50b94b0246a3ef78567c641d1e870d4a0e3fae17937888e9f38651bc91a20ffc8ad1d047f0c91d31ce6abee374c063e5faff921457d421ed564c8f6d27f37c54f5b58eee82f12cd099872b5aa8b802f3de1d3bdf7598a96c6d8d010cc11a69337711d562a7d72e22a47a5770015bbe8629fc2d7e010617324e365ac77d02966f2a3d0f73abd8957ee6fbe3cd1192484007473aed12fa6a15d15726c1eb55cc51cd18da39c054e75c499d7fbd6ea925eae93067a5cde053cb444338b9af109eaccc479312fdec79e6143931305943e145f77b440a3fed5016b353c5d3e08460d3d79f4c9afead8d365141ccca831592425f3c1bb523d07647b7637164c5567a2eded89267fb05b03130983c8242bf3206c49123b52d3877056e37efc070c378e38233753c48196ce098b6cc02c1e2a2585ff4b536c6fc0e771c8c2ac22e35b4cb3dd35aae5d2951441303c9716e9b6b2d6cd7697d28f665f0bc55a6f9b8fe2a8b4a0028a958c2b99aa9566a756f69f66fb687d6012841e8ac3656ef61a3767deadc1f766475e2dcbdfb6962d4f3a67bcbdb73fc4bdcdeae078df5ffbb2eb1c6eb6be57d8387fae8dde460cf9a21528e5f9cac2d9cdce032f55553808c0c7012207c3820c1390a0e98ae9ddebb620cfbfcbe89d1fd9558994828d177ae3b32112a601e06c522b2b0c14fa73e4454d75ae0e1d96fd94c62dd7a0e62b856898a742315c36db6d434e96bea034ea921d35df153995bcaec410bd73e966a10732dd3d440bde33876acd89e99d6e60afcae69499bdb371895ec991d0d7951198d0847468e75b48502bf542ab84bdc250fb48b67da517cc8c7226a57e878bc491419f03e39c6ddcf1ad48d8b77e30cd74f923f8dcf9034153668891e96e7e18d76711f9b0cfb04c7ff0024a42d0a174119af657a98f7367a0aa7b7ec4849171d6cef18c1babe5f0ea164dfe9016e60b3cdae0ba7e27e168f98ec4b028be61a848bfb97f8448b53388664fd986d1ec767df69431dd84eb64bd98e9d2ed6ea201cd2d705e92bc7ca581f0d67433320639730ea56bf7351e00af45386fddfc17494b3490cf30bc58de1a3330eb024d56925e5d60a6550202164f9f24d5cd79baa186e66ff468619e1f581b06fb6546998519693b999097b13fabe0d57c243e0423f4d12c6e21d2809b717c67132acc320a9d77e619179b5c8343ee7f4e900b5d7b7b18720306a99c9531fce95d167cd4ca294080ed07000e29013858506f684ce1b74b6e0f94cc3d78b9458bd80a24fc099175b53f1df5b1105bb92e6d547849f2d68b6209aa1f3907f9eceb3fa94978cdb98b45a3bd215f70c4b36b2e17ac2b9dd0c789372c4a8d7bb7b1e1459517057ef04c8800182767d13f17f28f8406be4de14dab640b2638d7ffce8fc0036feec0423b8fcdf6743cc4dbf93d72a6570170678c0e4cb6229960d015695e7fc46f00606cfdbe4eebcce87bcff4f92517980bf698b473123591e3dd3d2f9d3775b00ef9c939c0962c643c305b359ae76b8490d9ec58c48a089f13d61a3ab1d1eef5f300b2a96c71d69091d5a0a107bbe4472d4ec4ad5bc3495d4cc1454c078212458cc42ac0cc6623f9b1c7fae037898c47ca01cb78cf01ed1c87d16ee55d1fb3baf06f05293d7be95006cedc566745aff0fd04b45007fcfbac2c549dd7bb1ed5006162deeb173dbaa0c7b4ef142c738de21b17c2c400f9250499ab541672716d6a42402887ca1ffa4d44b52d3a1fd3db4d553198ff90c861fee5adb4d85d90ea9a86b13ea1f4433398dd6ca65aba3c34220ee677ef198bfa565cb3114f94c205c66f8a78b45d1232abab177f1574dc75f93e55f18e555aa1ddbe0936d08154ad096bac05dea480e6b8a1217920ab8ba7e51f9c87e59adb72d1455ec25cb9e66443d84b193b64b7cf802f58b6f566e7d86ec3c423ac291caa87d19e91b5dead2a0c80f4a2991412dcf93a502725b46ca789b26b49b0f4f1a5a207d180eaaca6f3421eb0591d2ce67a506ba4d07add7c22ee7741e769bacc95ba71d9b43b70929fcbbb279493c62a244ea833e766d6fe8bb2b542176cee3d940d753d72cccfc92077d957c3dd71dc4a2ce1fed51365bfeb5a56d443aaccd1142383b56d2b6a07834dc0ff756c5fcbe122588f1dc5d21833eddc210747d3c886399e7761d963c96728a53fa500355f0711799a82beed313c141baa6f7e14465145f164cd516121d907c71c52c3d8995b4066a536fd09fe7b2fb1177f59d0380d3599a745cf463141b1d0e021628039da0e6d09d7e2badedb0925c98885edb68ad2c505523013ee65217f833c93f39618b7258bbaca19fe4bf9a096cda9d5791fdfbf687d677603fb646a219ef9d96c8eb7d2512fe81dc6abf277895b77120ea7792fb527ea374608119257e4569339c9ea423685ebbfa06a5a2b664e60ae0ec83b97ce2554d59cf931259939cd118ce985f28710acf4758fe47e34a0dc6dcdcd4aa59e1f2e365a5cba69e2192be466c92bf4ac432eeabc048a0233d854657a0216d1ce2dae0ca79623383ce5d7b3beb7c1ed1622277d14684563f62fc294c3d91df263488a7c20a8204550906645e71c322bcc6cd71210105caf66227978ab3b7ad34d96d5b9e0a55898417f77ba69324be5b2a80172838c0a0a0215995f22d4b83f411ebf4549e4d56009a0a9b90b9184f38d0a356ff079614348e09cd6ae334656c0d2cb84cfbda02c9605c6b94816f26b4d443d8829de469a78cf4c8efdfc7a55e689e21f17ff6d75332707988744a38b32112a7bb39d38b9ec2bafd569aaf7163c53058d34244d4689dcea57a422c5b88e61831122ceec33e3415323aeccbc3970914d065f989bb20f49bd9dfe609df4330ca8b2e81d7622738076c8d64977e6c750c224abedf276356063f05f0f2e38d1b634c0efa97a8972396e779daefe430abd7627456ddbdf6c9e1a47eb49400bcef2fecdf3bb56b70307969b77c1e1d0ee60652c9fc145f1f0612c9c2c655450a532ef98828f53a9df7fb6471f93aa2def06567469c6559f691f9583c8b71579b7c6329c7619b77291afc164347ba6f1a29f9976844ac45a074b3712fe28d0ce4bf9b75a745e58e3aa6c77326c61ff350f761354b673f79d94600cb9a16fad34db4de2f45e4bdafb7cd991398579280f1342baf0c1cdefebb22300039b89b6ef7a5642034ca633848355cd3d7f19c798336a6324e0eebc7f68a24320a5fe7cf13b49d47b1f506a5657a608c6bbcd2636a8eecdedced376f2be99b2d2cc010a6046e16537ce1f1ba7d02e246e51886ae2012ccb0b333ba45ea4de0ee7e6fb3fba9c88e47dbed360faf507e8f26b0481fe401957af4781562fd60f8067cf9b81ffaac7f7f9668c747a4fe29d7198a2d1c0f5fc8f96dea4da163f62bcc6acb96c63dcfa67c624c8bbee93957ed1b271d820476e520a4aa105d11b67ef803022b639f9a7253462b91c1d7ffaba6fcaf3d9003236c30fcae5360ce6129468832581e97f57ea5f0e6bd05168cf21a8c422555927b56dccb93fccf68da179ea96fd9c5430bf831897b172d1893c96dd7d0213f0428ea5d996304310fc808726f3e903eae4bb2c0ecab2d45e8dab683162511c1c3188d2a93ec0a3e4ff381303b0964b03a8e1effedbeb7174c51f7735e65b4a29a79c7ad71341891213ebec8554b3d1650de39e5420c6d42ffd929e7543b55e3ed51ddbd26ac068b27d6504ae543812649239982cc0b7439ab3e33ead773e8d9beaef46ee14e46cd06e17e2eadae5ad13f0f2a2be1575cd1ba87ef60c69c77a9bd68cc9db692101f4bb9ceff7836606d0c530285b3807b1c03cbf40a912f6dcf42efc493e2c0f74b36647e808a22d5e270b98c970f9ed48b263705e93446993f5eafd9b3608abee71ca5d795bbd4a3f28ded7cc76d04ece2962e24c3cac27ec79b5a9ffe4e742ed6c5159d8a953be62c0279dd9691f1262b5276a31a28bfe8175aa4faadae40f8003d91fd0a23aba3ee464fc87a7fff0a512a3ee9a21ccf51b912969fda456cdd7642e3f2508b1f69fca229ccdcc8a85fd4ffc03096cee113de4661d8a656d12af5939bee8e3452b720db785bbb94ae483555b37c07d938809da4c72e02a116b8a492e45402a34be75173d01514b626d4de6612b585e88b9f9bea5e1bd59ab7cb695782dcbfcded095490b36e8b944ed40b0f48db8f3f47fa734c70d1c1aef350be90c336e92de8576a2bf7c10d88ba5b196e606ca4090e37e8e919ab06e1da6516a0902478aa748d63006b89d8e9ee76089eb401cb8a14137dce43eedc554dd6517f1396f50606a9aaff32f61f47d8d94bc82b9d26c5ffdf5793af34822cf3900cb14f3a3e9aa8e7652a948cb1ae31ebb45e9eb15b9affb339b15b92f83ce871df674a7bd06f03b9770f0520c98931b63b04626b9a2ebae24abb0df96a7911c68a319ade6eccbd15b451c0601dfa6fb81ccb558d31523bbb9083ce8f882c8f5ce5c83f8c4b92457cc272619b4c8e4a6e4e396c6f71e2ee52db4621ed7d02577fe0834de0a87cd38fc707f359c11002351d1741c9fc5f58d290960fd05d98b810aa5a543e85f7d842b25e8fecc63a1f3cc4bbf2695d8c7d8166f6c69e643a4737a70fb59a60943eb08f13200cb31e145578d22eba6b26249db2839c5183851190d119ee2decac541563e626969bb34ae686974af252fde3b2120c9e48c06b8f1f5459765c7539f9fdc37a4b7e121691963c5a6e0d68f82b02a90dc0a5649f88885c51bed3ca5e9a09bcfab9696097516b6eba3b09c31a0aae7923c7f488dd64c45650894b47aa0db35527759ae108dfd35ea1059298074872bab54b9984b5748dce703e2bbbdf36086a428a2c8a105561490a617bc70849843a92fea95224310b4a6146d48c92b9a2e4065d4a8fb6bc5a5786f82550bc818cfe92e7111d9c6df3083e915635038ca42a182c39bd7f8bfcb590e952fbc24641d058d7453549d650eeaeca352dbe3066e0954ad108ac29c9afb490613b332ee26e9eb455c9ff315abaed2ec2a729fb5874f1c219d488216fbcfa5a1b6f2ef11f65ee2666b4adbfa53c16f8080643b5f5cf1bdc3de757efe2cfd824f38792a9e6e0418c36060b2313564afc46f135b22dff2990bc387a5a1320fe2f297ab21540d559b7ec52e7f7f4cc21e6090ed8511ded61adf93b49101cd92173093b515c55def2d7ee0669ce5bbaa26b8f012a6eb1d4b581c256c7aea164481b7c86fc0ba60de4daecece7037b6216996ff6de97ce3cb3c8d268ea7ad8d2f7114289a2467a411567919a3895d21859b657738816f0ea1af11777cf0dd92ec7e1852fd96e10c0b32b62466b12f15a424cb036bee51931c78e41587c3a33cadb34c4ca18acf8b5e649b4d628b02671e6e80b0228a2ff7c0627c3f4e6207d7f1c8a9d2543b4cf1bcf2ed6cb3e7d84a399274be02fb0176eb4959d3d4bc45f908f25d9b534ff00abc45dc4724729ea9611c8a219dd93b994edbadd44bbeb6e16e1fe28a34fdc14a80441e7fce9d36a9fd544338b74b7d2166dbe5063f85a20bbffa435a176e5db98f4176c47a22eafda43dbd749236c92ee2c5ae7015942a8223bd55c6861881b7afe66ca34454eb9221632b5176a23e87098991bfe81ed8e988559ff0bd9af9f079f66dcd8ac24c5168fbb0cb3465de9200bb21d90db62b336a06bc83a2aac448ec69c0ed81360b89151f233bb1ffd2d216ffc83fd2768dac17900a03eacdb793b141c6a63eb8da97a8091d7eb386359357348ca54076516fd73016f1c67b4df0b879fe32f064850dcc0b83b996f4c86d3b3bd8b0d108b3e1cbc0cbce92f05c89c15125f9939e37ade455f34c70697fa3e2c554e547bf51b9f8c14c47037050dec40c74b22a5ffe95d45dcba8a442af7354dc0c848fc079df17636f63152333b5efb36e3f1703eb8262b53588665a53cb71a864f0d180c28ab7c460cb1f72e8ef1b7e2ce9ed64bed1594ff232f62c1b78e051ebf3dc62f423fd269e7c254882bd04daacfb9f5ee03a0a359374b1726b2136fdf7432536fa1f3f8906f2f72299d02fb97b474e4c4701c7d06d5f78d6ab5a484c5caad3486703d672955d5fc55e2670a9a03cb499338885b65bd65eee4ab92c1075cdbc0de920ba01c0c11c70bd149e1b0532db235469ba1a48030bd2b81c27ea9cbcae372f453d38a87e36a086d844a844c59f945d296e4ea31f825881c1b874b5968f7336391c6d9e895617a2489eaec0df1e2fa0c0444cd1cf3e39308d003b20837036ab5c90d5599390182012f7816190eba7b1762c40a33cb124325c89ffcf61110e800e50200aacccf3f1a0a7f1f522ce0d20dcffbc590175b47a12ba832fbc0b5edb258485c5cedb707f482cc4252946a06860d047c45992891e69033be751a0637751c80448f7ce9b3926f6a4d35bd6a834055d1109ffb387993f9a86866d0650e6c43b16388e6039a752688b0b8694a39ab1f42b85c982839139a3457d8c879b27cb12c1c8f7fafc95d51df397e8b6305ffe9007cd5d9ee55fd50bf8b6b781113038b62ab030dacac30bd9e99d1dc836d22d83bcd9ae4a168db8883336e3586b0c1680adacd38e6c15b4d26c6b3d538840b9a85196f5af46eb427741178699452ba846e4bed6cc0dda30692482670607540e0cdf1a6576558db7df4786f36b4857b6925ec2a560090f0742efd0407edd29e3d1279651e81dda5c6d527b7ce8aaaf0a0d6e6e224dc5cd8245dc20ec13469786bcca219d3acf516ae803781afc1542a0c260995702b624687bb6a8a503734a625fed984f6ae3244d18774d6fb4430612f326a877cb848e8277f8c0800fb3c47efced66c70f0e5eb996b67b2a1cb806f1278f212ca37b7164d418e17e5376f3d624c8c94391f3df4ed277dce37dd9e0b2c78c20308965a834e66ef955032b6919ec36575e88d6d10c0a736770f96bddc9bf3857f5c7bbd64e4eb8efbc58481ee94dd80b1c774a06a61c9e03800ceb8cf31b5f232afdaf463705375751fc7fe6d2d1a5eb1621024eb89d07066c5398cf9343f61bfc97c507abd089beee4574ae18a44ce575898c9e36b3769ac58ff8cd36482bcb45002cf3dab6461c24ed9c9e6e51a97d0d1867d64afa3f4702f4e004d652dfb9d572c64a4e48acb09d72e2a3936097c7fef2b1149bdcd2e613872f897dda8d2d2ab1227183c6a9705be4eee4c9e65e467b196a852d96d42195112f3c6fd5592de837269463e3fb1dad875894a36146262eaca1c14ba9e79e0c32637a923a2f0d04d31ed044b1ac32faf2747c1c5d6576cd9416dc27280f26102824800aa5d329709edf6e2bf9cf0948670d4f447d9d1d7c4893feb390893e43d757dcaa9e3409a8d861efc1e31942e7ec25c4b32d18ceb65a52be55f65a110e5f4484bb77219480f214d5c8a8d75c1cd0b94f455be262b4f0c0054630d9cb082cf851d778f2c73af4a79ccd451e48c202ab9f696dace0a8842fe4b04ad730c0b09cae266cd31839d6039d7021443466a17326afb19cc76d2d4e1ced11633609cd43efd722cdae252da83805e10a9b0fbdfb09eb5eea35d09fc759b5ee9569524a7cafe53afb85003850b8cdf8a364c91ef45a25e5b0bad3b3d91f222974d2f43605f5159d75878b6bc7959f820ceda901fbda042e25101a90249ec3e7ed035e7c774f1ec4b4ed54fc08d360993ea2ea609fdcf81e6464e02d36f28b252f08c2d9b0418001da2229b32d8a5ff57ed91379f8fa47cbc57427993e1d55e4603aef5339841f4f3e7190059454aae9fede4ec532ad2382839307acae3a55358abc7a8dd45beece9954c569634346e2366f010c6cbd05d4d370a667883522b65114c81eb6762c3a52d46c9364ee9548f21cbf6e00ee4c44cf5a12035057643789c9fceed4b8be5337e0045a677ab4aa758b10c3f853d3c84ed1c268532a2d52613a3a88c16dddfb67aa6725b117fcec501fd51bf2fdd8a6c935aa9e79f0bf1b3698e0269755ecb13446ae16c7401b0bf25b6ee3b5759ceaf2f4a17d37c905e5ffd4c83eb411b46c960648888ab070075d73b17b453b159b0c03247960cfa97f9a702b19517713353adafe41050a5c42180ab463ffa05e67f6d01a9de96adcac960b9f5962d05bb38479a996e2cdbb0bda52f875cdc8f59c9952617db5194a87010ebc21de54d3f3f7a5161793567d85dcd2660b4f6f3db2f93e5fe4c13973c36d7029044812ae0d60b92af3860ab0752c55c41137ba91ba5857f32652e4139c1d48c1bdab1730e8dc97fadca07d0e0abcc8a5f516f1e165ce8c12efc19b80d2968e3d014e7e1e8cd14ceba0798747532a960d46f0d38c54fd5ce5beecbb84cbee27e18ed1cda48ec7b05f938aed1d8ac7837eb7cf91179f2cf71b45bf69e511164e6af520d9d029d6bdcb43b6bd045be152df7b724e3f6df783aed256d48e8ccf1b65b4dd3dea3943674ad806845d239ea998ee70c9980ffdb0e352356583f1af7962c2cef8569ff808d64d9da73b44f2eea84df45da7f1a0d8f1f84323a4accee34e11380a908cb86eba0df9f2cefccb6453d148ac38b9fa368d71697355ac2d8ea5b849ce328ef9153e8db5ca18c7ba866387bb2a0b59f1c08e2593f1ac1069bb810df46425a1ba684be0846b1556de22f0c606455ddd7b7971896e654e9cf6ccbef2944e11f6ab05831858012503de2e2010e485da45f245f60a2adea2e3689987abfda752ea35ca49b29783ea2d4892b7856c2844aac9e4a2ca415639afcb70420870479f324659b45b1bf475411e84af682b3c845203f0a73d7fc544b150da6dc4c3f8aa778fb46c6e9481a767011fece91dd0caae8445ac4a00c3a76a3ed2d3bcee92c3405c65cc384d9ee27eec785bf70d5bcac6cb46389e438197fa0c0836a6fdf6a8865c9a85f73d3533ebe2f3f99d527948f51c3d0d02bedae25e313f1ef28c52df24d91d52a6efb19f4937002aed3ca23d8229eafdc30672f46aec7ce022e12b1ec48a24d0d70b045c7167226f164c187bec1578977b9a209ce7985e9fa55243afb150df324ec2fb6f39714e62ef64a2ccfa2fc2ef1c7754fe385bc4e3da44238d6e663d6403edb4d6a59748833b2848282e2fd23437394944e13454e4b987c4f7bf441b0f5c605b91c1ede02b9fcad77304ce884a36d1f56e698e92f308775024abc5a1a4f1994b0a115612d58837c52803353123f57f7e78fdc653bd79afc7c69ac6a39139f56a4011004075841b396c8a797946e73d76b2b4be27999dc72482cd200ecb476b77bf50ab6469ed1c10bb40ad71d9d55489c720c556beb0041ff0a1b542b28c9948e94b5ae33cbac456ffa8003a1220d04347d80eed22c98aefae478cecdc05c60fdfbf8a5e871cd23d668435bb374a674c40f305e0eef6cf8b3924d46cdc479a6010c01247db410f9cc9234b7c31df41fae93476777390d5c01c6b066b32ccd350a32dbffbeac574595367809328bc42df316d9ab4101268f66e410c21aad9f8ba655af8b88f614bde0996d414a781456ff65b46e429e747ecfeaf313aea7dd89dc8c56295480bdf2a188254e24759a431d4a86770c2e28d3b1d2cc5c400925b2e6ace99d53642a7e1500095a3863cd3933e1054f8ce48b99beb996fd963306abd1e258e8a610f57f7a18512fe9ec20c27df2c705d9358ae89185c3eaa56485b45a567305db9fc41c181ced7d87b410f9fd05ab31ba9aaeb10a5ad08c45d5be41cc3a6d0aba25571dbe6c8268f0bd2fa71c5b40d88101e467a9dd29faf3d5911655fcce82724537faa1a7d8cb3ee97494ba980ef3bdc28f153bc61e62bf480661d6a7c8c5b20640aaf69530379d815884819a90000c9007fee1e644f9fa5713ebf847f52a335b550b7424839cae9029af0eb06d2835c3a039c6a104cc8c7bc1f5753a4d95b762042ac0d434e461cf65e8b8cbd58bf848c26427a7b2b9c547198ab453c830525bf4620630a1b1256e164c0a604ebbe677b6d7d0978b0eaa726ef4a584d81f919f18d2a516a3dd4229b06463319f60c8bf6102f62bc3907257dc7ec0b95738b47cff8d03db6173c8bf2a381cd415fcafe29b76042da25f2f697add071a3ea2b99f184056f4154303d38c00e78861432d538e745eb9b2db17ed501afbd8e6b6da2d459779dd8b55c62a595c15b13ab82b67420db3981a907b7f072185a60f6fe7ba1fab3779825e4d0a658f9d9c9820cf3f2c9529675427aa0b6c5110fa03e357d2773fd64f62d6e2fa3850fff6893c89ac0ddcc25f1ee3b9bc2f4048798c11dab4e60905f0532e85da4ccf1e25b167491b6f0719029fcdecf64fada3bce06632e813174cb79420bd4cf882e325cd4afbcb09ff79e50d3d9c7eea56b470f80b53a959493b047b019b8d6b49dcf76d74f6f8c227604502cf36680ce796df1f1a68435019bdab6f874caa2e103a462a81dc51c89419994395863ffb513c70ac1f526624a0f4a609b847206fbe74cf5cdb41d72641e0b84e01c934e431e06db94bd23f8b782b6e97571ff30ec4e9ea7a47f874a8d719fe2afdbc2a4539d5f677754abe59e4484a0887aed4dbc7d02fa74004dcd1da66539274213ee941f8307e3e2d8007fb1391604af571a0611c69c19185359e41a76286878773ab6238c00f173f49f3857793593fcac77bf5bc8cbc513be12cc6a90f78217fa6e84e950215c21803dd9453abb15a89118f3d46baf407225f9856deac6f2c2d4b56f36e7ead4249bc5f3046ea673224d29d33ca984985434a2c5dc2003ea5ead5867e0fb381077f9ff96d98889b1a1c46fdbfec991838b4e47339159b9bc2f524af641b1b0063e6614cb563e5ca67ab02c8264a521e550b48cca32a67a843030130b73fc011548a5c376c2f74b91325617def9aceedf7ea610c9015121efca4bc830d635136a5d228df102645c1669cffe777e32f5745ac4b2c51745de7bd898b9c1032051762bb3ed15ec20e3a8d75f5693437736c0eeac227f9b96a122df54b59dac738653ec726aa3874262d9d30e89bbcd81d00e67b697b724653ed07e3d733d6a19076f30474f5e31caa96869cb2d5c0a9c8ef91fdfa4731b67c9251bbf5e0372bf757089dae3dc6c3e374a7519734c358fd43f2d7fd0dbb222fde0ad2add822f06d274efe115d9c53314f41e8990750e69b9cf248914f89c0643a36392271bb64dc2196b0fff5ece5cf94e86dd275726a11c648b85f6185b29aac038099609fe6d44c30b5ed4b523ba83753ab1a8356ca5a0081059fe8aa3c228784f708568e9a9bba59a3dc38df0d8ad062006d49621854b12120e3174f5016165396916ed5e2f6ffe41d8000ba9c25908de0ae762ce3f8ebba1a2849088ab9fbf40073d71645c119fb2cd1244ca56e0cbb4b5228b1126fbd4e1c22f453416d68ba8851c3c481dd94e019565da45c3a220919b76bd7ee7081cd37b0466328e90361b0bf7f905ba51ac95cb4244731c30e00f66487cda0ecb8c4e8d7525c1734ac9a5be57f7e4617a16b166ff4436372cc3f6adc46db790ec02b54753d9702a9354be66bd3c5f59d6839c356265e60821f99f3fbdae621001bcc8300347db8733e17ea1885767d8d27171b9dfbab9aec1e7c7f8da4f33572fabcf0fed355930cd83879685dbbc5623fefc2aeec252ce191347661844d25be7cfcbf23e9baa09852b1638a0b96785b57eaaf0c5acbca8247f3d74fa6a94e3cbda6346e4fe3f2658cbb94abe1583d5c89e0f494d3a80f0aaa91837ba65b1145c5903caf9c62fc64add2048ecd729a59257bddaf6bcf85834ee0c1450e8f3276e8d1c22981b2a57beb58970175e1c7797a32b1222760eb6f9dc637009cc47fe328b37f1ee59e03a54ebcd74415b87622b057d8944501448c29d67ec5d152f7cee9935168632dfa57b501ddb24cbc4700060ac55c23cd1610b0d34705a303194a4661175044258fb1e93731e13af78f1b1ae3e1a6775612e462692a2bfa02758232ca5785d03efb1010c422eebbca75953536cc10fc40d3da048ae9d75b6cf3418c1811d64d780e582da8b037779e2f6279e3965650a4cf0a524888a4a38d98747eee8fcf8b2a1826c61b67f6938dd3bd9ca637486e72fdb1f69387659411d9959107dc0b38d314e2d76bb32e73eab78f3ec196412b704edb533875e923b0c0282c0d3b623b60c48edf6921835abf464c5f1c3d3a2aaa9e6748b39a8c08bd56445de0b23ca3020ac780d5ca1b14df10790de06c55e3e5c317b7b3e0e3d8be57efeb6cda72f30195f914e6697998f077b0e8edd02037d37f656e8d63aec99c263b06f7a9b1e540f221eb1fa74b0108a414632383a409b8728152c15615fc84f07edd7c77521a9c2a430bc19a21e64cc27115631e0763263bdabfcf5d2ae05ca86cbde44168bce76f000a1694cc57a98e87772bb27c91e5cd98039388daced23b4e76577eabe27c1e0d64131b0fe96771052fc63acf0882f3738eff3843e759d15551cd366d984f46d8928b2ae58ccc228f5195196549f30b791eea4ed7b34a789bcb58d74680d274c0f7649869fb569e025e0b30c2e4a02e8ca3780d67766e86168ecd42cbe2115901aa32cd3ad283bd1f0d2aee6d9c31de7b24e9c7508798ebb4ed4bc874a533d649be44626aa8f272f0b46870d36cea4514538552d5f7461b3706b7bef4f4b8971bdbcee8dbc7052ffb7751401c3ba8098fdb6f55ece90e4e4591569ffde78cc16d1df7f6b323e0460320a4c1f85bb51f519741d839033eb2e6d21a74f26f7451b4f46687343cd02a932a467da33d39f048b363ed116f677d3acf8a61ef2832c9c7152b731b6459a9a8c93393ab3648029d23f2bae5195533d309589ba1d8c8d448a4b9b6fd849ac0bfcd3e4a9fe8e20524e4fda0ab56cc100fbe6b6281546fd7913feeffbe4843218b51c7ae68ce7fc008f3ae88c10b7b6a24dcd6e9d6c6910ed41c180f7bb6393c434c5d1902578519ef6eda5d704d645eb5f99ea1483be39695b81d099bec91d2083c823c86dd0fbae55643390d259097b34e26bb52a38f7842a3a86ebbb3da859c229dd006b82fb1e7237f187b962d00c5bcf19d6e859a3620ffa5f40c11cff705b0db450ced47cd1f17c1cebcce2314e4d22f634adb4ab28684e6b572c8d175e008b64d1f81662af3b2b1f2d4a7bf07165c8290a936617ce82c4bb927a6ba9246c37c978fda3f5ea67d51a23e3ee8d641e39a96115e2072485b0d2b97565d7d4f198de37ba09e3a2ee4500214be46d0932b0e64c5428448f0fcef42e825a1f1121a62dbecfdc3a92dd4d7487e54c1f37991bd77905a9b80d5a08f46f062f46c30bda60472de5e5e57ad15c2b57a760f5eded58eedb11c4c52ac5e18467934ae9e5ce699688c852a9e6881749276e5498845400e3f0207c94c93700b5830774ed49d999b089c0f4770cea0a093e1aa4309cf70ffd489fa736a019f62bdd94f6b67c730ffa6234cf01a42f35673d40584fe774389d19904964dbb28478e674d77669ab8a5b149f1e0f89c69d58e8a726cdc414d60f275b50381b055e2b9c7a968d0bfea975f61cf738a692946461903a15610fe4ccce9ca907a000f741058ea945d73cd864779bde27d6dca5f6feb47b15bbccede0c394e4ffaafe27d68ade5957757c13a09e5cb299254c2af1290a6576185d3daca6f5d73d13ae4379cdb10ab2c87cc6d2a2167d2ad8fe964bdcd92638d18597fd4580512e923046c8b243c1d498016e5525c66e9867d363e2a24aba993f1bda7a10ea6719d13ddadc10ad38dd59b8ba12c945e98aa4c3a934d65a8ec292b71751a25bac603d2d4ae958a14e953a9fce7063a4660d432320265ef31d541675321712286cd51c4985bc670d3a9d1fc86cfe60afad026b48443e65efc7bf129e822468cd3a4f40528acb549435d2832d50a939215c8ccf99c035f89d8a851a618dd5887cc4526121faa07cc4971118901a126d84f7d16528027b7b0ab126fd074ab2457173ac985ea5f3e985693a2cdc076fd1a764dc980c853f1d2a9b1efd6261e193f06d3009e265464a671ed95273074a62d8aace883e7b326dc1a316ab83d127c2f415e45b0f3dfe63bc7e2e4fc02687e545e300668157addd8d8bc91888f0d1fa0722453a240d4c309de7dbbe966416f647e3a6af942da19f3534c2db0cf6dae266961db8397f47870526883300ae89aa4d69671b8983e6b6caa46a85c6930114ca3af286930138ead1708b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
