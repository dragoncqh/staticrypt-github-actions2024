<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7afe2f0d47ab5e618ec0f3d15086c67750dff0b8d73dbb86a83ae1e1673360db9eca909ec083d175280fc75181b902094bd7fc516a6ce868e83afc73435da4133555fb5e4d49cce7751c05d4172b5b645b20a9a92943140ef6eba16afe6a81f0534c0eda0cd6f5806831a887929caab599f2f04007d5917c459f0988504e0aba44d5edb3c0e57628322192b2d3264edd1e2d0aec84ef8564db801af9dd0b17a8cab49ccdc6b9e222b242ee889b5dddf4101ca538d9fb57d39c887f340d539474f7a262ff3aaf43f09a399301eba26d2da1fd051213c9ba8ac174ad8ef071f23893e021a9c61dec5e8947788fd83ff266785a6868d7b63977e9dee638c7130decf034cfd551a22b6c6291480a2ff39916285c5584aa3a97802fd70d292d18e294065a0865c90d24f063d38252849af87145bf4cace8cd1faca02d96e90892dbc10a458b1858046fbdb4a4adea615dedf57f2f079837fcb782a047608d6b382d1896b1ff990e5ddb00f86485862fad04fb3da522cfd2c149f76c71a6ace7408f72c48b8bca72f0aa63173e261825d78920025af3a7bb59fe44591c78cb3205e78b60805cd2eb8e47cc1f35e968825a10a5e40971304d949baa25a9fbb931cf96dc731e0a0336a46ae45543bcaf26718f6ea086680f8dfffd66165555f5eeb6ccb385286241503868bb1fec388a61dc9af7030e20fbe900b6565df2be06a516030f97c7881e3793df2dc5fbd93be49e0e70d76367af813e351f927797df3546b8520902cb07d151f0650122578fae81859a632b28e01d89f7745d26df44088d60d3fa85f8ed6bb6eefa2dfced4e85ec1761552ad435257df34830ae60e15b80b57a36e17e68059b1bf91e82f522fdb026c507991ce9242da1623accdf3c43e40434720e16c9880afbdf64bd23789e16488adf62012b79c73cb03b035b307d442a4dd608ab584e1c54823ba9d7ccba0837b426b6ddb3dd0d330044776cf7cfbccee0ebb9fe8b8582c234cd1e751038985544824213b43489c3147ea89cfc9ebb366f45940d7db277aa2f40f220aaf64e7a5fe61abdfb61e5aec8fbd6e47bb988fa2f2407fe9caedfff240bba28e1af132e614f62c16e3597882ef0a16fbdedcb03a3d0ee51d2a4d061ca9b3d4cdfb6c40536f04e76e63e7433529e00a858c789545d5ddda33da2ddd753d9991b01ab3837009ad7e554765b326dc08e3414015a9367b47462cdeb2540152c520747b0bb2aa4dd0f4c908533106a2cb0af1e8042b5a0eecf1872cce9777b353cc7e09d4b9e169f3fc283f7256c19e9132beed9940bc6723781d2cc9b9a2b177396e4eeb2e296ce2cedf264e24d92be54a2805d6d76d76ce895ed3ac9afc03dc22cb00a5a22b93636b71c5f1420ff608b00d681592d15e0a53c7a39256b0ee28dcdc19e20c34259f3be5b1337e0cd108c7c410390181cadecb9ef0fd6ef6655c0fa8bb6cb88189935f1f0b2c2a1aff3e74bcc085d47514b03735bbcf4dac6ae7df5f9073183e6381afe203f262842aa6ab08ded56429023ef2ecddd81a1180b84accdf0918afc139c05d502d93677a3591be9ca2f21e12a958871a34ddc98956192b476b2d7d9e395a41e996bdbd9a2a94c8a93df7ab16c0d5e2300a16a3fa5e756add8fb15025081ababd23f4ff2dacbf00d7904f0d264fb3293823e97772d234c01167589e2f21534245ee728f447278f7ecec9c9fadbf356b1f1d117556b39aaa21fca20b6c053e58acc6c84f4a0927600564e816d5d204a7c90a71a5f017dfa043e69ab21521bb7fcecaace439b56b902e0025bdc6c0a79ed1c54d22ca18d80789509ac7121914ce40003bd1b90b314c2ab542f6340ed271e1ebb882827f0915b256aa32164be185e3ee1a957912ea529b58f17bcbf5dbd54dde3356fb2b23b692a539c365ba974e759f16c322934d374875814373546d71c3fa542223e3ac3f901be5a63236741567665d6d620bb4a33881fc8845a31d3d49b93c8e2e645f4b18eec68860d33a74ad4115d67d5d1acc9b2acead409800ace8b6b4b576b314748be802b6c6e94e5df6612a7b3f93fd4a1e7048d42232ced2a03c849c9902b875bc7ff1bbcf04578b6f30c4cff7e2f3a1224e9f575e1fd2d320bc46360189557232a593a199b06883ffc0379a09554ed6f670405d25d6b6dfe13c7c8402117694e013587398927c718a12587e2223b3d2274c68edbb103d5cf64e65bbc93d0034243296cb25e3a1070ee6bd44eef7c1f4dea4f28189255a155da0e4a2e3a1454e8648e3b980b6b6170c0c0f50de283bc7be55028505c32d8c23a5ac6069728ed377de95c4bf981c11a92770541a00c86fdb859db5ff2b8534ef80f531e4416fcca596259405dd05faa3d6f33e60c92261f06da0c16fb65a60a401ee1628fdcb3cae177033c08cb122052a40101bc6319f20b9deb971728fec40288582a6a5894bad78bcf53e0e2b4df58016865dc053169213531c12954c2568e4b30b86d4b622a4ddafa4afd45722d69ed937e07f99ac651eede39783c365df514048e762a69802ace66e34b01ce2131e804e544198dca9d7ab84fc735107a302a250db07f228c973250179393d2fb99d4a658fd82965af3202d562a7c12a3b9c1e35b4493261e771ec2c13ad0ec4bfc73c1be8abdd1516f894d983a8e15a435da7467e3d32424bf8a638d0a425e49061d5e1d5f85aef75fbc1d14dbe528b7d92829382b6c4eeb3a76a5dc73e06c03c90e6b264a3c1ea2d4b80ccacc6c613364792eab2599abd241d133f6e2045ee6365feaa08a911a7379f8632960fc88c2aac3e71a92073b52d1232fabd282db2088e24cdbf9e64918d0cbdc9682a3073221d1620e6966353c09af6e6d2a151efce13266e2aff7ba850c57fa70ada3aad1555354064e1751f1a31d1a9422a4bca0374e02988e021a89c3acf5463b1f15be5bf2d693c67c67c474b398b79e8e720118a6290e7c80d5aee4f0a677cb8adf517fa283f144f881f63af21422f92323587dbb10e42984b2fb422df931a21ad93aa4a36aa0a02e7561bd883deb527e65c0846921d858e8327f67cabf26573731ad35562da69a00b8477ffa6cdba36d907900240519c23de2ee0004c042054f05a8671b845ea3d995d0ac0e77640e8411aff4cb03d904b4835cf415c3b160f92bd3391fd78e5d15a6a8e74ca566aba44495eea70086199c112d3199e799edb8e208dfde4141be2c0c173bf8dca66a84245ecd911303b9f9da769bc6ba5c5de7d52017097a8b96dfde20e3aa2b2aebd9063759a119aa5de4d28ce678e0f2b20c47cb277cc0274ab50b67f0e2210072fa03e14ae5eeb7b1207e8b614193cb8b81d4c027fbdb6d52ef96bc083daff5c322a5550cba39de514970aeb5e724b9ea3dd6d864800497ca75d088019d8ec005685f8a029b22ba73609381a6608e679bc81b8cb87dab177b5694ba1856c7245ad46b222b876a317a01034b788c2098be59803acba12abe6de22de87bfeac5a73a0efa0a99a7b652f378fcf96bd533d49ab5aa58483a67ce7fc713ac66bfb9cc8490a8c912531cfccc47f02f06c9cf1929ed1231c223ebbd586d609e284a24b11924c08dd9bfca3cb675380fce046b0600302c0453fb91ede7c18dbc53e3a14dd8e083d5aa3e813a3c7213d224c46928f95874b117292d5597c3bb1abcadc7c095bf1818fcd16af737fc0ce87cc0e56cbee83717114f5da43e8a1528dc460e8d720ed11300a86ecf77287ce4d6c7b1baad82e6c2bc16d5fe50f1468b027ff3fa683f17b7b144e6230d06c62c5d5926397adaa2341dced2a67b5233362b71801fb14dbaaddc6d11a95458baf96e43cf438de0f52e373e882f38b277209bde1268e5d0ff9e34de2b0fae5a29818e77a9a5feae36a0c761eef6b7a53ddc0e8e41f704810a3b6afb5e4abac513bf1ac8f4ea5aae70f016e19eed056e3e517c460e2db1deb6a581bfd8004285e33b0207ac49b3c8e10aa84066e96ed5de9940705fe4772c41d65492d7940caf6e80fb209d9581a45bdf105a5b4041072c396689a0cd162162ffb18bb72ad3cc7a5042d3d2c5a3d7648a4846f1eba907dd0ab41ccc1dbd24df2860df75b325786b2d34034417907e9016e115b9bdcae735a653d32beeda0205389ef8371466c917bece4428ec08febf7fcdad28dee4f04e2d9b41fa0125432efc04c65f8a37bb58f2775bd54aae700fb50c3bef1f6a5589e5a3cdc7eef851b41e9135f81e163fb397e5f517f34270f0624cada25e50a39bded905ef2a16a96cfdb34df1e7e8b61ec2ea990dc9dd7457cbb0f5cda27cfd99124a7675c1a90107158a8c966782aca5627a59c63e50b5b2638d4d0a47d8a14c93d1ee5dc1fe8f98022fca0fc8a7c7a9d76280040f1e3a6ffa02e95bdc822a28598a283cbe6c4ed89317d1ea8672b16fb84aa456cfebf7019c7cbb236bc70ef4378b1164a96c1c99d314e74e09ac8f60ebc37e588fd5333d020784ed44ce8baa4e97c1415171cae530d8e96080fec4b9dcea5e8dcf05b61c1f69c909224f921a53b3f87fba16e28e3fc5bc68318df8dac281c130366b85b9dcfeeaa2803ab6d7d54b544c98d91ab9ed744289dbcbe262c4e8aebc0b41fd4546859f6f17f18b3b5ef1104f42cc4d61b6fe26596b5fa1f9d436df650ae647baa827d8f6824430493b6de86d2ef89757e9a6642fd2d4ff8371a523092f23184c4adf9c500f943f896a8dbeab2b26b9fe4d6a69e52fe91a1fc3feee36b28d2f7cc1bf68ccb381a03b3ca42910bd1d1e92de4d56e22add680fa85ed2dc87fd2ea7fb26222ab8280562f8056acd1759b23888a3898c6620eea5161fa843c512995b26b8338458fbbaccd39d7d4f8abeb96b54f5a756422887f28bb5ffda24cd5c95e7ee6c48dd2fc3f695c517ef670f29c3b8fd344c38bc02efc99eb37a3fd2a8ebcb37c2cadd73a697e18c8d7d880b86b79023c45d270f5525562c69636830f72db1a28d1d0e5ee42ca60ec9f27b3daea231da5afba976e8465b77ea28d038465339617fec9a94a24fff5cabfb71583b544803cb81de96dc172d55774b7182d7a491292a75c73db1e869f8406224a9140c3ee9067622fd2320ccb6c0521dc8f2a8d485ec4dabd069295a123f5b9ff8aa90c16b4117af42566b5fda5b6ce814241045d3ae0d8152f168a0ccca8463f7b6399830bf7b0493a5c5e3160758dd3909ef068a7e58066f94df054ce90aeb6ef51129cb6a645f0b68da688de96395e39bc09a8ee96bb62b6b44d0c12f162bab22ffbedb9bd1d24f72fd3606a88dd52cf0ba8edc14404c2eb0b67fa5d9cde75a3e327924c0fcac58630a99f529a263d65947cf35cda9082514f52faa7a4d99cf5fa1b2f3c240358543b9abe9a0dbb620dbb7992c8723d3b40fa2da12ffbd8bb340fa70d27dca29a0bbdeb2ccc31ed0fe2b120476460ec3f9f3a42ef9de85ce6fb1fabeea214c957252d031913c2dc4db053daf6ca4ec511405a41308b58b902aecc5ce741d94f5679ec964b8d2fc991a8e7701d9c59639df175ce1725e6e0b02f5cec3318e61775d3a7970fa11a2426da060bd852a208e8b86eb26692878ad82f1aea5c6c67c3a79bc19c99f815df2bf2e5dea11a8ba2237bceff532cc1a68154813120520d35b866848f05c4fbe7ec30bfd45ecb94700727c91540dea4ee944d8ac7dde435a21585d69bad8e19a3a7057aca7853dc45f1aaa87ef86a048c2d35ebb0f0537fdb49f6eaa9cba15ddca1f258b7ccd48a6304425aca13c0aa595068db31c66373c174ae57f561c44f5f79d93cfd3483c400024f48a155b9da336ba68588b7ccdc0bb8b5d1a1105d93900f04e49213d404d25aa2361675c87a28c7863d849fbff9a323dd151c05c7cfbd70f214ae3dd87c0b0be247512b3189104fbde1ec7d25df3c765e96e26eb535e33ed64e7d79674087f5c36557b9462143e21f25cfe25a6c06862f63c8566445b760abefd5f253fc0d8073d322324f0dcb20886208291306ff49846779eb22ffe7e7e09eb57f25d29c5cfe7ec40ca59f32ff0054721b48ce11b7f8ccc7e32e22dbd5a102c1cb400d8866bd625095e84b38cd38bc602de06afe9d3820872c12ca0e26f07da4bc5d502b864d0df47949f695e3cc203a8f5f0426ab3408fe793d4e984d7af568404d67b5c526b094355d27b990ac8005e2cdb271cf8932f7c0c7dbc3d6f6b68b9587c2bafdda43c8c7b2d5453e91eb98585f696414b40c379dc4469352eb01ffd2db49d6ffcbeb280220f39273f8fba590891e9d6442a5ae949860b12849ab451aa29f3b3e9a7acd1965f88e17140fba51c2e9b9b64eaeeab8f8f76896daaa1251d8d9c097b37d71c1ce6052468e264d239ac097d335427203b9a9f36c0b14b866caec111bb6ba053edd73a7265cf8f6a1f94a6e5f6cddb70e679b29207c809c071c893935f1339a1123ba5ed9892b7fcec19b889176824522d5ccf69299b90aff731ae9e9dd1ac01aa8485f21b639f1438b83ab837148fe9c8cfdab661bf21c3a1281978fc890f1b0c61082c13b4b24832776622d11d370ff639bcef56a79dab870c574252667458860c27b8fa4dcd20b40bc37ff6220c5820b04600f97bfae1f8c4809f2ea7c826f3e1643579dc6fd35b81ed15794c9f3a650403774b4dfa68dccfbda4afa6e02365bd75891aec6a762008ea9953566b30a45ae3e3df0333b658889b9abf420d3d6e3b4f915fd1a0382159ae204c6fe4968f2a2c7d0cb3ab380cb1b33dcca97b8cce9fbed79cb6c341d44322ad8ea29c69bf49f5127db2602b2d5bbd14c1357ef01602eb1ce4e7d0d0327b5bbb001ca8de4b1df615991a18133cda85087f6db5ab1221f06f592e32b2baa5e04082cdd7d0b76d213e00534bd91c73e9661b94dd886f025917983a05c889eab353591a4e624532535aff9cc4de3dc1a17cf6e203ca303e3e057bf2a3fe8df863385215253fb05acf1a9661a397065b8c88db1f7b632c0938201a8e22807bbce370f78b631f552b91cc35f1dfa00205eb1372f7f4cb33da894d0adb257abc9482897afbfd7190f7bfb37f6b050e86b9fac7e9bdc9d32aa6404d585508d06f54caf8e70495441825a70a45cdadb00d1e59d009e807ec4173edc2d72719a235da6e6e3f7d30e10a57b2cebcfd3394899073b1916592ed9b2b19f793edc2523cc122965a86fb9bb63a39d18c025caee86940761fc2f830b8b97c6aab153f37f7df7b27428ccf07e46716fe71ee2053f036bee6fdbeb2480ae3dd6e8227201f161d5657677935bbd669cd00454d9f94c1311c6ad2cdc0a40b4584019c9d8403a89f3f47ae9e6690dcb6c7d1935cae2937f08f78f79f49588d0d3dd6a344df38df4214e1ee7558f45a8f3efb2d95d9a3cc40343ac21c42bc0fd9e0097782ce5897c183c8b577cb3c5f6bea49fda5fa5691b48fc185e5a5f4d3237826ebf6ade4c293d4196c5e92c9184547d5b0c8d70352e0fcdd7c1f34777bee8b7b1277a1d0168c7907e19daac613d5b4ed61a707f212572cc66fd10b5895db41fbb07634785c11d7c7b10868d7bb8c04553fe7b3b37e259a373987dfef13ff6d9617c1f1ad801c061fce5b472ed28099dd0488b33b9b73d4f280d67c2cc9024beafcd1a466368bade17d5ff696bc29b6223c5a1afb78a1a2c66ca650c0d5fa3b52aca3d44680e2e0270b77efb9a567914f1fce3636b22814a1d14f36e5e6607825235ed0bdb906004498f1728a9b956d50141318dc0fdca9197d4ba1d5d4d4d01747944c4cfb477be4bc8f45192f18bed714be698613577d7b8e0598436e4dafffa730f3daa531dca79250c6517bed0d86426a5cbbfb60472fab42e83947d64838c8a1e67800f79df2ae429b0666d52bfe4777e110b82d16f90a71e7ee8f29c3af6970e0a8291eb3fce7d88baacb003005a5fddfe994429fbd97371ad543d118edfe827032256b4184f53c2256e4c202afa9c5fdf7ef9b43e8a2ad0e428fa439a61358d9b35b6fdd9346aac197a58ec9ca9f3a1476040ef5b931fe495168667989f76612550dd0b4268cfe750fbd950a6ede452226507b252064db3442586c6afc7cb54e3150ec5fc02e69077e4bf3d2358d88da30b8554d2271e423f3f0c8465b1edf12195473d9db9fb05fe405b4a9f30e474b323f4f3782d2a8ee94714d83f46ea2bcf17b5976eabebdaa369feb852a3a6ab162d4589d5d1219bec3cd5245b9d6f39311fbea9951961f2cb08251565360b574d507a868798c6ef4fe92d2c680e1c64f87a3c15b87d7afc1c954625706fbccded7ed8312a05fcb2f04a1dd4f6f5fe223fa6ba7693fd3d76efe876f6bf08df656f07489abeb632bc790b48833d06586cd4f9fd4fd3f6e5d67c33bc47bee42f33fa2749813e8e4ae47fefea33c3230260411cec23c87e89a9e591eae908a1f9058a5b62478c5bf0ce8e2416e53fb9138b8a6e55511aa863d5f6d333f05d69ad9e86b094d5f9594213052fea3432a4d770666f364d19dca8ef64a09325e8f63dd976d7388dcccc0930d07aeddef055d1e973255048da7cb85dbb6121209d576023f45682375d8132c0a250ddc0cc51269deff9abc19658de80c21dd06691dd8c0b6297c953eacf3e24560da566430c9aa6fb8d2621ddacb4eee2e0bb291d136d6e36c7829bec00b9086e7efabf47d7c550e756bd72f50b465e15d88577fe5b63d68c472950f6e2a987800a88cb9b6146ba8a20c3d6051693dcf9e2f767aecb7dcf166aea9f02685f34c98619e5a9f596512ded5d4f2c9ba1876a200ab0da3593aae86b6767f090fb488a7e612c4e2c5632ad72ae4b3f034a516721b8f311e8fa8adcb2e8ab9323696142a0d44d48fd8c7a41b89ee8d54846ee66e33c080bec5d1b9eccce1c1e8ea7f1af4a6e06d2a7b27781eb02c0c10f5141140ca2e1ade172e8e49b4134d3872e792caadf1d690f343fd7e8fdf3511564415b69bd6dd0623f440eb9b9122b7f8f941981a5832b68b3bf3c22722b15c0297fbd7535b44b37a8d10c9efcd62e1385ba0e91483b10b8b61d1e80104ed81ea902604e09c253cad16a99a80f0db94b4cf9c7770d38563a84e4c3f9da2a5153e4484d3f466e1c50f501990831224b86a2923bcb6e66dde05a6a15e4ec85baaa75b77a71bbccae8ac74987b1f5c9c94aae0e550d99cc4fbf50e130687048885313788d16dcb9c5ea4e45c0e561247bcefebba3a6f5cb554e4a80b7693a52daf1b9017d2be8b677131f97bd38bdd4e3af6d1beb858599872f20ba084e8e0cd133fe61db8bf9b70dfb11ff5986f4fd4c7ba61251477f0e53b85431ef8c53d7fbf7ac771974e5778d6e2bc37f9b79ba00b516875231e515d9b506433f561729da47609c369c4e36916744fbe27d5d4a0eed41c5df8c7bd649efa2a3900877f7659c1d38e0fd1f34be52b449b56d8e917ed1ab89bc4a6e3ecd136482096d109dc0ddbecdffa886d3de7e08b6d13168ec5d806a658c1d702ed6c573a77d9c071b9072edaf703a1e34042ceb0ef1f4f6fc1317dd063aca71df55da12cf451b8b68f35f5bbed9298db78126a92771b62b9b5bb005e891eaee38a616254f46997acfec1a29fe64bf5ac412cb2d514523a80453d74af69058541270310312c1b289d5f9ea7b9775a445a56117475a8eb132843cd8bb549ca40459dd7a5a04692b444e053b73cf4355951c46e4d4fb26d529886038456779ff2130580621aee8373b66aff3400e61a43d68bbcc38335a7e5751217cf11ed47c134214edf66b3585453b3768a58d47b9bc6021c8030ebf4a01b277b0c174b762d2b3c1853d8a2c32012a1e4c8a46f9bc309d477b9b156c90bf9a15fb604db3e61ab0651195e83ba60d5e1416db627b282100032123da508f98c92c9b49a5e6c0fb5126502b803a1fd10fb53512d6c174e9c530","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
