<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c16cb8c4ecdb0f33535ae6ab9b2da1a9a777b23d25ddb8631533a00b69343cb7b8ee2cc89ad10423bf2365181190cf59f2b90e567efb3b90e42cf9b048b24c0fe186202ce2b1b6fe331715556d76e466b7cecc54f77927f2a7f801fd7d4be376f724d903718fcc66ad7b661c2c3d5e912a1126f9fce2c916ee9f6843a8a025623e7ad34a7aee2e7ea0a6c36cbda395430096e284ee8c3ff7666a6bd4d8fe19ce724efd45ec52a7627d64558bf4acfd4620a62caf5bfd64a634c7f3a8698b5fec8ff283efb86bc1190c08f7df09f60f961384cfde24783b1997c7bec720ab3bf778e3454df814739219c5d2c020eac4dd3531c392247b1fbfdc2c19d76f47c8b5e9932c0de7064a65f4ccd53141b90dcb4571d46be541c9cc6402c7c245cab123565d3e4a4f424eed3419cf431bf1ec8ad97cd462dbb63db0234cb0f3c8adc4cffdc961c501ff5f8cb738e9d7e65198a695f5006fee86c79f19ad6216f3321f561725b8f341d36a3892ad6c1fb6c165bcefb5ed584cf14e3c636669c8d8c6aca2c7fe8010c87451ca860a6624bfddf5ba86538187e8899f826112a9cc1f5b0002acd1b3943a072e2af0a20f63ca252b867a984db4c772dcb574c7e7d068107cce9ff32815791248cb1c51f985ebd8eb2fc00d7c1860710c08cc3151dd37212318364f3e52447aaf741cb4eb599b18217c617282dc492863b4659ed00dd1365b0091ec1d792b971b8c7a2cdfdff1269326ac15efdb9f159d289b8e0668d8561208253c645847a8dfd13dd7d0012e50c7419994485c4cf0b04aa3b0b3d931006341b3e2379a2f279d318f0a42f14acf003218222ae9a29bf4e7be6c2be76f0a26a6a9fd237c3a9c034c200ca9c4804dd41daa4820e7bac6dec51e973edf8a23317bcb23020c28e980f37add55c354a6911ff2f65a9c6e4893cfe9914a5226f5d01d3b9d5d88d00bbb0365a06a4603a4e1eb87cab128926ac4777e195e6b5bfcb17ae731e2bed894969e7a1ff2e8557af23a7fe78cc741c0efee96a692ab3b5b3ee409b1407369904aa3d839ca9077d3b88a85e2798d85287a3544c32f94ca12d74f2b527ac6120084d16e368f4142cbd1d53839d0cb079fecad520a04882716d1076625ab8e94ea42eb1f8c8988b0eacb19c24763cbd63da8238351fc74450d330b6a14da6beea0657c706d098a06cc8955fa3b333d9b61a2b2239e289488fad9752b0d0ae0789eb898c88040c07f2ddb49ac81232b239bec96b86d874f7dec428a33f34a0b024698da1c77ae301eb251cef53a687ecb37d66195c5a8467e195e3170be3bc27fdf9dda7d560efce1180e8146aff52da54e3ae231289ea39afe375dcae465c3a62e2be3cef0446e09a966e3c3ec8562fd4d590cb13c1e5c28df926ae4c44acbae31075e3079955e9261749d48ffb511190a3a8c9cdfed2278ea3c6c63e8e09266b3378aeeb4fdd802269ea75237a632d0f6fda8d9b3e8bb1e038130858c86aa79481ae758ff98e06673f000b9e49d563803fa2a99a2c4323efe57fbbdcbc4b6b2ff74a88f4e6da07b86ebb507d71c70d8a6a9330f1f85a1689ec426e279bf17d1b8c59c101fa4d451597f2794a2047924d4d767a9dce0cbe3a15b7fa9205c235c8952ca71f943ea5881ebcf112715a1db0d96ab4f9e9f7252e517d864ccdae6a77b05fe14ba9bd51547f57c396c40a41e53053fcf62b39c2ae4a8bdea20bea28b9ddaab722a7c184007854e56b20b6ec885239a02d291c6376a687393b25eeea36fe7946906bb807227fe52b8807c4d0e2be7c97f9dafcfe961b1b2ed96d2c095488b3e4e6e63c7b5fda834722d5ce3b056bcfa83db82e01f2edbaffc8fba576e6eb6ad3f267f67e1cac283bdd8bf15954a084116cd5178a8d4a2ae4770bcbbd43796029ec23f6340c40efa0a5337abf1aee94865ec10f68866b546242fe49cdb1475558a224128680e170b8846bcd1630284706cfb3f336788950e850469994b54c57ca65bdea6a60a3b840da53b2cc136e541a1d622a033abdf63d0c95f00da8f6abe7b52757d28003fa147aa64434c9ccddb886f46a27cb8749b66957a35c5a6bb26cad6fd3b12b55010dc9dc5f78a1fbe3314076c129f1f6a1e885968c1108861059c6491bd543458bd9e010515b0633cb53add5ea70b80fcad27355f605e4aa74326db4a07428a99da02e52549bb9b92f0b39299a26acf71ea062c0cb475d35168bebd65c342c7053738e00b80be7292f2ab91f975cb6c4a1d50ea5d0aa4fdeb46f4652cb40d97253460a1b6d30c141d3109854f3a5b3958b71e455e9f99a67a65e55967fc9f8907967b5c26692936cae304ff7fd1f450e4bf034880df5897508458d0ad72d9448a9ba9a9ef0909758efdc9b2e9b3d189f03dc091cf91b1a73d832940088686411a3636cae33e8d7df419534241c7763ca2a71a47029eac376f30110d2f5dd946a8b550186a373c1d39e63899653158f17f96f04b68997b5f517a490effbd81f0be4473e078c3e8c88cf10249753a848600404547e2453a692284fe5757b6b80bc5463c0b106d5b58e49f0c21f2d194d04dd98fdbbeaad9ecbec8a2ca567ec197ce6452276e25148d7ad196dd9e8c9d8ff035bdccb6bb1b7aa2dd3377cea8622766fed235460ebbcefa8719fbd137e0b677b456832857f64cc7fbe21f6bb3a9cb5cf542135dd517bf818f47e18287f2ccbb684485443199736e6afced0713694a78bf8109d3ae5649b224e3507b328cacaf9713eab4e8de5bd92c09bdbb3ddb4a42b786008b64873b523530ab9fd8e04d6d250c9e913775a2c84c900afd6afe548a9d4589f97c1f8b1f55058b62f0250755d483d2e80ca228a2074227d51500c5f0aca9cc1c688cfcfbe6d80ce0f0dfd4f774e6896137748a1172557fb09b754efb1e552f1ce9a09523a315e381c1c6ba55ee647430ad67d6017fdc9827063a529fc2583c6c063469cb5ba9b06ec186746148218759e82cdcabdd3a5f58330aa0488d35457f064a6d729f35c0020d75b52218cc08223131fb115c7a55c09c00e645d6d819740354b948d99aa158a6c317c716b3f4a019f833681e98025764ccacc84aa9451e44d3ae723936e7207abae0729105de2d13d6bf9c63f78da5ed19c204c59afebc08c772ef417d040dca8fca33fad7ca1aae475cc0459345b4396b168db6cea66c547c0c84b921d7dd6bc4deeb342a7ca27851bbbf5eeb792b82f0f4e934d5375e845172529c33ebc04c5d3911d32b323ffb60577a459aecf54fa8519c3888014c3e5ba1e5581d9d937201691b0477d316ff3141ddea860c705497e865c481db1962c30e437ac52ea3e172d0244f92920e4491adcf5964a3d623b5f28ef84c19f208da95c0d7390c9d109f1e73870b32e8d671f928a320f75ac6500c48aa89e6b46d43caef97b5f19e70461908fc656e0ffffcd47f679b1cf3dbe3417ac755b2b5725aae71987d7c950a40834541fd0468fc1a35691b9daa68b838773719edc6e285ebd3a9abd232fd6caf5e52cf0cbc1a30fdb3ce4e3b97b58a5cb9212c923cd94cc75ff8aff701ebd002c7f81fa03172f24bfa28cb3854060e03931e1bd59f4233ee00933577349adae5bd19e6bc6260552b75e436778852410bf27c72e7583d5540a399cb6605aaadb1c31bdffb63a29e52b4e6b55c79990c154b30f2bf4ed9a4043ab14d218b75fa8a3d0f68dfb940cac2e16ef112a4719369aef0eaaefb6247f6d22baaf003216f9ed06b948751b973d249c3ae2d85a6a8abf5dc417cbd7b31af558209a3800a78d234bd98e71361b2e0d7a4a58d406181ce7f05a0d7b445c5cbc1d56e46a25966ec33c84a194dd912a4731dff9a0ff5f422898ae1ce87b09d7373a1af7743d23a581ccf54f2d89b9fc90ba628d1f0125225ccc15c977390f145d7544aa194d23055af4bafbcbae62c18e39487c38693256da3ab3af774c2af7ef68372a8e084aaf15b60c05d2d03d124e050d1e6968de7520397089f48a051616cce75336cb912e3db4e1c239a064b272e79a7d8cb4aec76ef66d47d12b897c0abe160538746d2d4f5a9dd647e25594bb7e3846831e04cc8d2ed1de093b18d8f066687ff44ae23c2d17a122d7a6c3ea87149c715291572b23ee8d68360aafc1997d05dd24e2fd2f5aca1eef4f83d5927c7f6343d7d50aa58d7ba0015cbc9975c6e7e38d3399ffb212a3c307c1ed87be6b3f1aa9561b8710917d8c9d9168a3ef393003ce405ce3f3693b50825b8bc8f609a4ae23bc33abbdd55795ba68d4397583770ac46d89619d02f875722389d39162ac2f75290a8c6a10de43fc72396abec8949d23f29907abe0eb37dedef696c758f18c2fcbaff5b667baa8789d6b160cc7752687e4a0810ecbd12efe794141e7334290ded34cc438b161b0679233c8f760f80e8f4fe8aea751074506dabcdd0f5f92b29f07bf2e1ec142d0740aafa8d1829e324583a34eed562a7e0e6d49b8cbd8492c787e87bb62206b2f7d089cf2d26e9d7db4ce8f15b0180658816f7f39f18141ab8733a6f1782306fba0df6a16d18c3245f0b29ee80def04ffb019f0b62bb91faf7f66ee00356d0ba616a7bf19d5c0f884cc91c5ef7f1de1a330b5986fc704b2c2166711101fd85adc953f17c7cbb28b92f24d3c37b32405ae5f4b6feabf47dbec9838db168b0f529c23c0b2b899d15f23641246e3bcc5ef760a35b41f9c0f354fd9a789274b828ea339ed21dd31afad3f6f8e62d6d8650f2654abff158d2588c62a62ec0aa6d8d03d2262ee004d9337c767dec76ab8c6f15e8a3568bf843de7afe14ae72a85f779ee559ec1c6c62854dc7544a5da14bf4aa2208d378435b2834ee0f17b0ba0a71aa2bf5a18f4929d882564cf457887e7ea580f722869d4a037ac5ae46dbbf9f54c4b5033198715d2fa02b547efe21a52d5c99a53fe5d0b1d1a346c8520798ec276a13da8806834f42b8803a283aa04c28faa699a159225fe7906aabaae736bbd45e352d367f4ac9d2625e426137de6d9ac1aa5d209a67d54e89196637a47b84a33058f20167f8bbdd500176e78c3262072ca119675b73144a6f513cd71e30c7535d28b315d0fb8f1a249fe9edee0610351720544ac3065960130f87ad9a1cf12cfe15b479bdae2208d131323521855c586aa29210d3cb0607bee6553e95c681baeb2eb4661808de5a47910df5695991963c878352439f53771bbd7579b2287488c87134e3d448f6787356a4929c2cafa4e2ec695e2a308c23f0375fff958a4507579606367c4f92131a9dc2500b223dbc1d71cc142e5cfcaa2224de2b4f48ca97a6b6b510e97aed3c85c5e95afe28ff0ee0991f1b3d7e36bf78dbcba6b8d179bb7b08d53b3742b99b08b19b0296c749e3ae1fc00c8008176d23a05a32ac66c255a4e9b08e4d79b0ff74df0de68d8fb0a0ecd0d1b53270cbdddf795c9347a79041f5d04edd424b592c8869db8bad70932b2fb2841b5fde926d1e96252b1b4cc25d1d0795414e389e15cfea2393fc5b9a28f36ea867e49ed5333eac57469cce56c5f42f82bedbe5be191d6f303881aa15bbea032930c625accb119a9f27645065bf6212f1e195cd1223e039e32dcb1e7a03617aa5767ad93200ae41a4f2327a32704fad6838df3c286e1dde04aa8b3cd6e2719930ae41eaa95e9afa2bd44fcb9fe27792beee65ff59be1f3d1b6d5aef7d11b78333e4cfd8549d10952bd9b505b3f18e36859c7bb8f1fb3c423aef90c5338802f7024262dfef1661315edb8e26123aac6a4666f73e97290287168da9c0cf9e9a2e0b3373fd551acabb163fe6cb23afcec8c2742ba4aa85f35b5b7b5c6aa7a42b9fee637eb7aa4cf46a2a4ded9c8b32e32539ead33b2831529665434cf7ae6eb6945d079d08da7725faeb7f1a2d83c3e416296e48437fa71cc44242a2e0d50b03128a8cba23aeb2f08452de04c6d2cf44ad61923a00eed0634c06370fbf5c7f856b55c9ae99bddb107b97591ba38a2e51c6282d4584108346232fb69050d59e01c57237e3ddd0f35da210e2f27fea4fef92f6cab9656110a423b3f26310d770a2729d1acb376b765f20d6438953f9260bc7583a2b1f0bb7243056d4ba49d10ddfcd33f75d6d2e7e79aa5393cfc1eaf48f75a27e2c65f7025052d60e0d0cdde650c6b982e4d260e8d77a835ca2fc9e294eda5cdb28759e2e7ed4f3d877f0bfe189f0ea3bf150a450f9cb7febe150aebaa8ced78d194902bfc67b6341d36ea00f70af39005100e7e00058333c9e39047675cd98461de7b01ddd73cd1fa6f5c5d8cc148e28402aaf00a8860c0a046e2690225a244d503f732834e9d77b3ef9ec81a068cac5c16f391c408e1027ad26a5e7d7935ab220e007f4503f7d0357fdf1cce70118a78c6c1497a69c4eed93923e5457b98e6731f6601210a9e140039aeabc11fa45b8c772bd20a3fe30e43ad7e534fee2602b81dcdcfd380a169c5fdd280b74e36c680146f9b76f90e100602003be1ae8fa599b3f6477d6cf3b7936c9c2f9e9f8161defcabae0ddc3110a37c1ee9976c7d3d013a0c3afb6acfd0bccad359f2e0d0cef74797a5e4b0553ee9078c5a6e1322ff017e86cddfe03e93c72c2bd147594d910c7743b3b38202504b241b20d12759c70c344218e844c465cf6407634e44544a7630d8e5dfb47c6cfe77ef8d613a0e38a495a88e5827844fb2553aac8cec0913358147227c468f677c443f134a10eb73c052663068cdd43b58f9507ba22c287bc70b6dcf12b5a1ce0f2427522a7d1250116881100fb1be9e5afe75484578ccd93e1ba003574df7ce333a0d9b9d86a11ab74cba5d6cc410e7474c0b13fa25ed6d3625241982b9f7825cccadd3456d2d7f804ad0c1c626e6e5c35ea9728a9f8f9ced25898656cace61f442c038ee7f680ab388d98e8afd89fa0c10426a62c8016c621f16d6e379d928ca79a327260039ef95c2c83e3647579ed838b9a114c577ddc108eaba4d5481332062112ae20b9950b033ef22fd55a148113186e180bb306529a42714636d4996b4cc7cbb0538b1d2e1221918bfc9d421688bcfa1b7f9736c768dd2fa64c92998533c197d57c0afc6f20bf85bd463bbac6e5deecf2e3f64bb12893c77c72530ed1b3602a83448417162cbb581f00439972d0639abb4d3e3398d96daf922d79930c5aa187d6034b6a31609fa56943ef69c48a644cf6838fbe48e65b1a40ebdb686bc9321456443e3406ebc0ab1b203d2ed7d79f9776d7ff5dbbbc3505c3eb030631cd3623f7cc2a17eadea790875b149780be3748bd551086a92efe37620b420ed7de429ab7fadd8190c5d4790e5221fae2d581609a4220d87d0ff3e5bedf6a7054cf83c2d69b4d7a9bd60660a53f7e89ef407693f17a5e3602d1ae6d0eb6f597b933766fa302090da94a6ed172a8cd9af02ddea4aa06f32d4b56585817d47001b2b0d59c99fbd24f4abba826f40e45c2e2ed937ed3fff9154c47b3a4d1b4af2548bf085fcf4d0700b19a40a956be8dbaf20d7a1137a5d9fdeeb345b40b8f5716a2dd12f52b93aa9e769911acdaae2d231998d2e1f336f808a1d8f8d477be7a0b83660fdeb1952a2c090cbb272972ece62c32e29155fc075e0e9015714a5503b492162412859a1c536f06e439c83b9b5b6e5b8e4c007bcaf3b5841b3560e530e2675228030f610ad58d679c5a56c70bada1e51c1c7224e4563b1a9d79c7fd417caaa99b36bc186328354cb24fd3be2d27ba229bbd6f127b1707361aad6cb78b063e60e42b9bb57df81d8306ebab4fcf9d3443e0828c5a7b9ea2a238cb48071eb8b9612fc2468507b7ad1ee9246b36065bc1ab2d0c17250c6feacbe12aa9d4140c5d21191dc36d8528d08d3cdc81da4b9c94843151f87c255369ed83d1d718495cfe04fe58fa0b723aee745d12e9bc3b169c751016afd7e871cb9af84da792d4b23bcc6dcdd0f1135f26a75da9930d9824727bac7d2409650693513be2640c9f69349794a423afae5cb7ec871eadc3cb69ada466530288cfdd8e2b9a62370e69e7576ed442f392535421328bc09b1f59d0742b87c706d9de64b881dceb40ca38cb6cf76425c0b4b3e5993f4fdb83f19aa44674457466c6c52ab0a51d3b34df1041fe1b554cc1d8c782a9c5ad68bc87c668a5c9ae2adc144adf59148497bc33b0a846cf902ec56f2c87b65bc5529ca89976d53231a87e2b2d4b3ef6307cc739ba1011bd0b5335b098dac36bba702553190768569d2c8d0752fd0e5f1236ee1d32ca51f678dd88419d39a9ef66077057146242424300f1888315112532e8fe3ac390fba05a1166498a4ecd01bff7a9889d9bcd55c0b072b7c202d7fab9b89921a01ba0a3237f6f13491c4650da3e240e39d3f6ec7cbe19a2fbb6e202ed938be58f26a3e77e338a938e602fa22b770c0c66dd4b03248a296a35935bf676520e06ca7726179b8907ee52271b9deb7dca6e63e2e1bb1d2d09d14ddaeeffe7398298b410fba98c3361b75feca41cbe914fca47059f7e425218157ad267c682f369b728bdaab51a73346aef661b43c46fc93779ee0c3b5e83e69bfd3e89afdc8744113cdd9428809cfb58489027f7b91e9d0bbc7ee46a8c99ba60ce68e7c1605fda8acee5a4b127f3799af687a7a571d7575592014cfad4609f560e1167eee8d240b451fe6619147b03b8eff3f336772dece6070697fb526d8a09e241d2489da0eefe1e9150f19557d40d2fc7281b0814e63510bf14259e47dc706587256a0b80093445b7ef8c89079489a9b27a6a388e673cd89edbc0b67ebe6e35e62b26622ad0a0ba6ea79c496bcac638e11f5afaf8ff04589923df684d96f3a8497993d19a731ea9dc3a0a827348248e85143e06ba121a2e3303756a7a9396b281e565e39cc911a90a50e4a5cf60665da75516ad1fd074c0ed566f3feb066db23e798576d38f144220b578377b56ab35cacc3b3ff2126a8a1619c70a1f225f4c59520b650f2b59bbfa52ef2bcb91745ef23f8804ad0da91ddde5f77f6c0855c71c19daa163f529f421ac429e1db8bc8df3d8ccc009ed1350be51391483392dc88082705d7b04ad369fc21f365ed4099685acc9f86bf56abbeaa6713f70857b510877a669bb7ceb69de56efff1b35dd9f39d72d57c09e6496ff8b031c1bad74422e5d739b9e53764742d3b2575136a65f42f3692483d88045eaa64059d2af3b558cf72e979357027d74c968c396d2b30f07b7fe9c7cf6c7162908735cff44db41efb295af0f4c743503c259f965d05934cde4a0a53db1da3b8fdbed3326d695f51ebfafd0b1cd62058cd3de6041c2d07cfeb05c491c352d6599d6f6064074128adfa820255b5f475394803a985ddc7f76b8b963eeb14666eec3b2f662200bc686ee54c7e2b0d433d82e36f31fb8668379cf686469aa5c570f31a8366ed3d3ad3d52c354247fd8388b7b05c1139f9f4dd3075191688c74945f3ff0f5d8eb1ed1f8483a4349e30f7805426d878e3840e90c79ecd4c4e58ddafec2e69f22dbabf80a2c257c33eec6e8d2e42fa076652b40ecde0f94ceb8e5720d9d8ff518b82628c7427baef8fba7a6099112e26134a1717c387678658257e0865408f4f4f6d4334a45b854be2a4dd0ca1ad1a46966cfe27db42b46eddc4f3135037a54df8b2c2a044205eaf160ebf9a7a9ed7d5ed84685872d82456905ab97f8a19eeb9d429388053511a6b300003237207b2bf625854741430ed294c2170b812579620a26cf9f2a51c120489de3e20dfc3662dfb5fab501fe3be19ff856bf69167d2608ea582e8c4cfc1c41c7012a5f446f7701f3c2ccc20fee73747f45e206c33dba8ebc48e2e02959cc7d9a6d858d915035b741d73030160d944b2d5851b81c83e11e5a74a6a61f13a9da443f16446eb2a3b1c843fd5f66c894c9fc7e049dac37c0097c158dc63587b44ddbd3792eca7e7fe1e32955b2815fdf3b59c02a4a5cb4ff20e0f92d3b1642c078b0d680e17ecd4eba268e906d62fb422aae6d48710f8f943f9236eb87558b6d70fbc4c958e8bffe95a93395a06097ff35bb999e059c58821967fd462199328912e4f0d6d1c7f8d1ae967453ebe44cd9b9c950e9b7f759651d84029737b52c04e2974c10a258c33239e63098192773b6c4a3559908a146b7f71e5919eb02fa3095c99e6299a9a3b453f80a4343e17ede241d77ad43269614f607dfcf1170a99bae1284a7cd19c5600ff4adefb70685798da2fc446ed7930b58c218a20da1c079387a11e7a1fe235aa79ec195a171865aa65a969a12bc6e2633a6331f65f98a5352badfd23549968f0ea36c77b4b574fdef02675180be214412ff8824acd202ee9037aeeaf40867064e00c386022ccb0bf67eb0467f72d7e2f9170da4e8e82059fe714cdf91e2be072b0a628eb04e7044b493a9a521c6eb34043e2958deac8827f8d1eb37821bc3d88941073d56f1003be0a5330cdfe39dd0038566e391630bab330c4fcc9fad47c740cb5b1045cceb518bdd1ec007af210c0cc809c15de6004d097e51d48a0f91961890f4ce5e8fa924fd35f761dd8ddd266d60877908c5fefe6e1d8033aa10073b3a10206094e141d49df02af38a3dbfe1c2c3ad9546ddae94ea45e6f67a230c56c0ccae1af186f1616cc6e404657568a4b00390c5a86372a363f0f845368a8731318e4d37a9ef163821a7e3894d91ff7b06e5e09c4b96e3537fbb5ecedc73f88a3d5a41f5ef1896995c12c2d65ebc67befd985ec8be448181f0df1d8d496749d2fdf658a28b9b2de2995ebc9f9ac58268fbbbfb2630e90b6127e8ea38ad8e23adde043cd79d751872e3635eb942aeb151df40aeadd5f3597c3d074ffbd748f7b80b54d01c6caf7759eb5bbc2ea68b8fbeb9ff760da46bad5f1671c7896e3e8791b9230cc6419d78c9b49a33a1302c2d6c4e1e6530eceab6d4fdb17709a8d4da0cd2ca7c57ce0634199a4c55603162cb800c85980182190111c10b06d74bea15b2dd048407e40ea087047935e7a71421749bf6a2098c8558019f215a7d03a8a4ae7db86c8732b07b19b460912fe1b77693fa6900ac2c1e13c1048d8b176d945456cedaa20e9f7e41a10dade1d868b617667b9769060d49135bf1cbf3eb8aac12425b354d1f00a67bb9caaa27b9d9636075a6961bb4b5e2b7e68d7df513826e0e10edb67c1eebb157548139ccf05eaaa456aedf05fe6388fda010d9d1d44aae16d5084eb1c2685475529abb1a4990a6ab8a548c00fe893696291a07862f32d6f35b8140e56290bb6426a5c79ba30ba4b589ef50034db60260f459e74308c0c456868d020656e063650b7fa2d8d6f8568aca4e19673ece686c5ce722ed32515836bed2460099709bb8d8e57b012bb00f685d27c31a8787e4f8836042c03235f26549a57cb2029adfb7a05e5e8ceb91091d615a63ae1979ace35ab12bf03cb81186bad1ae03d50c509e80a3c2f502111503529c46f00b25ddb8cfa15856bf2700ef2d21cccb4d0d92f73563e8c7c739e27d922e0bd234c1a425837158a7f2a9d6152539ea2c48c6ae59fdfea7a68d5ad2b8bd24516322af01819125250bc39275b8282109b455219ab9391781dac692d864507a920918674757c13cc4a00a2e619db1cc3a6ef51e85e623132405f54535ae55650dacf19a358068cf3a0e452a110d7786ae7f1171b825c36c07701812a8e71f4c5dd379f222d892c1d95df132285161fec7e0db8d8007a544925821bfb85c110a24ddd287cf307c9a4847f1561852e162ff032a46413c1712fff2609fb65015cca17b31e3626a372c670c3dd20d8b778095938067e14c7f70ffbafbf0afa9beb33cb7d4a97cef836e65055988ff2a4921f796c94bf5cae5bd4148b08216b24dc31d42c98a0167ea4265af7d9a7594cbcea12c9f95ee3e0e459b31bd2b1e799bbaad1704b9c0edca280078317fc1ade3a6013bbe3c74a118868eb93b4d5777f2b733a1acb029d8cf09744e655d0c9f0a7a9bc217c2e179bfcfeb677211cf29b0d9336e7f813cd606bad18a3b8390fbe1d4cdeea082996c28c2554eeb5474a4ba0cb7ba439c664951047d0fe4e180929bed4e74ff99c65cbdd51b48f7d3a42e4602f737c163d0bdbd680fa4fc861ed671bc71b260b47730bf12d8fae835d41cb040b85ef664ed1e6b5d83dcd9834691039d55e8f37e8381aedb46a051de70fa847ff316a71bc7037c44b15f68dd925ac63a15c42a1d93503b1bdcd3074f51bdb8021cbcd951044a6786756fa283ce870c2d8a8f0c6b843e33b2c50d4524a55b92877b8df90632a07c952db00e7ce1a0616f35b7c52f7d6332a9d2025f91b78be936186dfdbb5f61da92f305c86b6d99065b4094a2c97c3e7b4995d04090edb43cb113a8a5bba892ce4d3c10c04930bc40306d0bcc30d7e29b4a7d3f81b9b0c80a130f1e88e370bad722dce0bfdaa6e8b3ab83b74ce7a09f8325d6419880b79fc9edb83491e0fccc3eb2dcb0dba461ce972274bcdf40afbe9b7fbdea4277c28a3e0e08f6634f64828823f7dde72bf5ca72d8cce476ea738d106dfb9f03fb50e3033d115629059f91f4d4edf35571793892a66c340f83d365339ae1b3e83097e85e924f8364d44cdba7c03f3e275825146a952c4d2ae4a7e573ab3286bcdc413aee8daf16045af3f8217718ecd4608cbc6594519592a0795d382d9d5f95bced9b5b57b324322da979060d3d25dc558e2cb3967d1a41b19a36b1fc0aa53e8d3bd84a3a4752394177d8cffee147eb6a09baee2967735b25f3f0d23f4a693435163b4beaa74d55eba30e4dc71729c8270a3c797d3c6be7078d68a38e3a71964b376923a84bc8648c87b4c43e9239ca3599342eaa7b94aa533a6b80513df3d4168970d6828e553c872690f52114a4dcf721fd7e8001eeff64eba8ed8114384bb6617d54e78068c6321af4ac29496ed1ded60b681fcd6d85ff3bc008c1afc6235379ee2ad3fde298a78379a421546587130834436fd99922ba3b82a60f284a79cf81eacbd689df4f4a915c92776294db8e8c4f5a8e0af90ab6692b4c2f901ab975f8408666a936d16a817950312fb007f836fc0f81788ec4d73da5c2a0c61eb490c045b70bb50a1f3fcc924f55ac638ddb32686e4be1ee4be77b5d107155644e94ea2c048fe192e38c1fab69e5ff92283c4ccdbcba4246e15fc0458e5c976d7668f6b786eafdc8209b7bbc1794b44594f4d3245a460550f92ebc4fcd1a2897c53e45214c06f44c27c65b181e0044b51bfc9ff674fd0ec23561044aeff7ef0e8909fe1a6e7bf76a193e74580e6d05aab57f9d8f319713dcdaa687ff59dc7263123133c27e91dff75595cdfd089375230e3d45922b13f1ee987c18ecef3ee2627fca6d8faf98ba151f47cd8a6e9ee625edeb7731053b6ef7202d27bb3078393f756c84ad7aa95c6c5e2184a58aeec349bd004dc75e043d74f5b15c4ade54e4af7cdf12c59ea67804e7fecf054841df54f4665dbf0bc83734e35fccfd57ed08e23a55795b6a085c2abd869bdb253cb8c49466ec8c5de6ab037bd0bf0fb534cdaeafbe29b29a86dd1f61ee01da31b0f94ecef0981ceaefdd237842700a053c0f85cb0a98205b8d937ee07229e6ddc742b955ecbc4e06e57884e7698a85a945722ec7a75c1f4fb079af74a167bec12af62364ab10b005cf5e6e382fa1063c21135dd4751e90e0d12c85af86b2f59bde11eab501dd41213bee687b47f0e78353118f5c47ebeaea75287815e189e9dfdaae690ba62736eb6eac00a62dadf2b9138ff71dff330816ea926c17d13cbcfb8e29a508ad42dd99d40c950f0ec3766e852c1f651f426a8a97c6f4fbdfa22e7ce5a4661018793be6313fd6c6049a79f050327592a044fd7c9beefded6dd72e95c7dd207ceb0ab8314d3a78b47c2d6b564cb5585bde8f74b528f04a85c635d67b134f10f5ff338acece60843fd32fb302183c17a2dbe36089ebe846c3cebc034f6c1ed610a4f229adaf0c887387d13f0723790c58f1f11cd4cf5a781481771ac970907b6ed71ab3883f9b9a7c4019bd47740d094406cd97e5842e5ca42f1459de165a7fa3e56939a83b89a1eaef8957378cfe3f0a0bf1513b5ab72ea777039979a1b85034bc8aef53c64dab936ba264420e44a74058626306d832fc500c2d0d7ecbfa1d8350b08d3a497e764d455a0e00e2cdb3e0e5388850cd55d04904fd3c3dc2aa1b932c0c1652898c3748bd291d912df35b97d38676a5b9048b76f509321285685a2b800041f66f17bcfebe01e27a1af3e2f578b7b9ee6a9ca106f214da291b7461616580482eabd0257679e898132bada294634be4ded9c6debe7a779f5074f4deee653b893a13f57e81a5b6073f86561849bcb88ae79c59eb0d0c45d9f99e606085dafb44f62f2c3f068191a8d28b1c423c39d13d1dcdadfbd0f98a4ae1c2ce3aae6e9f5874ed8ac58b57069f97a74d1e4ee2480da68f67f09b53622e74b5c5b63e1ee3c2c8f6a197191acbac3279dc2d1bd6d1da1390fa9c83e4633102263307b7ec27a40c0e3b528f67cbd443318d8b21217ee48e48509f49d43449e13ad12b3f4ba6453b4884c7fcec32b648f14b5edeb7649b4001955e403ec30216021d56957de6588aa1c8d921fdbf6eb0ff81ddbb7af6b24dc79ae5bfc899d29e7dda3e55471aa4cbfc42cb5b71f9b3d76eb096398d0136fb604fd8999a93a05d0aa835fecb167f534651988a47687a09ebee5d7765033edd4b718429faf84a491362d4b02b78b602d6f67093f2ac471803e2c4c09150cb204d5db062098e9b7dca07a10090e0a6b240191a772f27c1c3a74f6b7dc13274d3901c8f697f41adda74641753844f83370552018d8edbd84feeb40a0d90a9e0b8cff577cf37e230378c6e3338ea4be4169189a117f45e7f70368790d9b7c92587fe257fbc705b8c90d689d87262bd617d070a306330239e3de75dd237a42f8797a7cf36b99ac180befb0067e9efda9b5f5655499e427f1e680ebeddd40fa08ce38b387cca18ccaea12441b5b7fe6be3e5f1fbdab311b0669225566132dd6c9e22ceb85fb22230bb11b96c82250cdb54348db86798a559d8965cde9b8f0915e383a99dcd656dfce981c3ed0fbf8a9714f07bd78c27fb5c0b4a9298a60501872ab42a8ca712791e10b846ed8bb69bdc39fb2e9460dc8e692749b53d34851bc04459e8908f15348605a1907d3d677f7299e6deb184aea1d8bd8a20edfa1c2e43fcc89cbb89e95ada0b5777db60c976f84508aef72443e31b6432b752bb97ec6f7f1ba0cc39e8411023daeb6dbf9b232e9d9334ec88409f8b575f48536aa21b3476c1389ebcf81d354bffdd3128168280f92eeba488dd084eddd14a49bd97a82d4bad82d7b727a5d7144821799efbe895a94b3beb730e8654ccea5f8722c177c33841258e64da8e020bf7c69efece80c5c3968f13ca0f35fee5fc674e50a169001e42468b347ccc5db285ec2864d783895d7b88c19172d5a118c0353ccf020293e4400936c52324f3724757c31d36b4d6a84087f7b731ae5318d5d4f88f31592473760d9a4c99ea4932e698fe920f2b1ac90503bb8fb93a2cabcff940bfa2de25bbcfaf6cc44e63a4a62911d74395c406e067a64eea9f54d8186db4634357523691ebf50d0d074610a64fa616566dad9104aa9fef6f0d344692e890781b775f6ebb7af955fe2b6bfa9b1df64cb3a521d8b2f9f435775e5ac19f1758633624cf5a263d4b561e6e8b4766805c0de3f2d158a58270be184e8d756dbd25fd43e796df86375d649bf8c36d7e6a137092d5a542276082dc49211925fb3a41651b1288cf259c9b0ff0b426e7fd30b619a24f0c5c9c3ad0012d8b1f8bf3b152eae40f3bec33a4a2390c22b0a8d7a71f1cd4d2ca27b79850174924f717a0d810010cfbd97e8fd5347ec048487c16fc4e7cac138c79a021be29716cbcbf02b30cd87bc0c6e1db688b3e51d11910fbe158b9b625b361879c6edba0c2f0843bd07d46ca42933b0cd7ee15f815bf3aad9b384f6c2e7ee3aad8a14bebd05f12d91118de057f874ed8b7c432cb2d58db01a828620ed19c9c361152cc14d5109984dd390ccc32f49b134c5d0176384f465ca95b079e91b4865ecf3f014974282ae92f8b2a7ba1dbc54d6d98a77c56fba239b2a211c485dbf4a758690801391e508dba07d1ea890a9d67c431f3547a6a3af793d7ed115e30235f4e516ff81bd4432ffd2c51b44fa037e21a7e8f65b6c30dad283164da9d1ab949643e84c98962b39e76b552e7014af183f3109aabb804861bb7a43b9676310e2c790c391d5aed33489647521fc1090fedbcaa394610d2f73b800f92ab57925810f1febe7b97b6eba0970855f8a70ae6b6b5786d7b62b66df2c040e91663c23617e1eacc291b436736c724a213c39ccec03a08abfc08206a32e9666071ca8969f2dcf1d387e4e923711ddcc11125d57f00faba42a7223481695ec95427d9f5f78d54a2d21eab2fe23c991c70d37e044d3fb64a2767819175e60586629853c3b6819380d1f963be7ca0364e41b283c1f01d671cf692b922b4b3915704540c3424aeccf8194f8af0d1c7fa283c983dd2500103789c92bcf8528f16a0cf6bb724065ea3b7395e17eb6008c94db00fc964e556104f31295dbe41ce06695e052efd090742a14f23263385123d2e4dee26cad984f91013c505666eec7576949c23579549c81deee916aac2d5ebbc9f4378a723082a49968b0577afff664152a5caab88d7bd9f0e748956e83873094681a76068585c7dfa781ce2aa56c7da82c3f449007229be1e33b3436e44af903f6e3cfe9673b1be092515299471c82ed5c7757b274e78b66739350e293236daca1c7159ce33a864333737f5376264988daf81ae69df3a2967d8a80265715bcc896df6dcab6dc96db6b0bd1041c3d361821a1d09db2e86a0bfd378aa2eae8653e0a762c13ea240ddbb0b602e1344c356d2a8ad3eae5608a0164c413e44ca9f00a7df6556127aafe4923bbad8f84caae9e28b44dd3ef1a6d6da81ac1399d228f32a0449a56ff165255c09c5b2cbcc1ba2c193c3d9ac9f39637b40440da6810da9811ca197c7f8e3d67d9f56b9748a415741771aa17c9d9ad0c3dea8bb9c0360656e18b420f9f2fc2a59fe74f994a7125663f51e340336dd6f0f8bd7c34636e133dd66ca4216e334bf1b68fc9a3551b51baf8b3d3f52d4e3012a6a8189fb652987b3d4d619dd3614e926bccea4739657b0686d5490a0a8006e29edf5e5d869e94d88d9ed826a3fdd3499f89dd5829b6e03c8c1d59a10eee614959020614bfc23fbbf8a4800177e80911afbf7460d53698b37ed434007c5637fd8f6cf7a2b0599e728e502be13659dd513fbe72211a727c9c93febd831d7c68f0656661cda6952ddaa207652a88b575a6e2ec74cda71bb26c472fe11f04c208a880b67d665c873f3bd3805ad46cba52f64f985732320a59860ac82ca55ca0dcbe6a1d15003d45150d8487cc8d7ebb5bca182a4bc18d284dfc73fa4330031d7576a2be14ce1b235d5633cf6cfe77e6ec51f5f4f53f99922e3d62caf81ad044d0c4803ca4c4b59712d245414237ab58d65b679ff26db59292c6a9a1a575d542e50937f2113e2be0d638a7b6d99e70ab7fbfd5d1c321a807c3f6f8d3ad1361ed8f98d1ab5a5e052908155a9287474481c1a81fe689a15e85fc7a2c201f3b16c85a706cfdc598c89cb57b20a05f0f8f6885396fd56b2b45177677fd1ac96e16264f8d71b50f203953f9289147850181748013cafbb8fac5a05e4bd35eccd8355875fe5f55079f02f696cb2de5371b708669ffdd894c068262fbe315f70a84372c3b96eceece79f8c79a43de2070e87e72d7046aff36420162f47d9b9d572fc01953de4e6953bd862dccb5fef8c0abb27ae239f91235d7c68cc0d5c5bd14046ecf3adaa823319cbba6e0b4771b106eca6657d33c5b401fb4fc5edbbe37f0ce3bfb236a85c131d1a13ffb2165b7ae269fb2a27f4f925c37513060e61248981ed2990410868c512c1f271484529202362d76921fcb8bdb5348cc5dbdd71b294ec72560d93f9108ce964a81e191dfd807500aa50564057485799e640fec7e1c53757ddc5b1fc2c4f0efc03d224d3421be878b5c9af6213d973e6c2c15a4b2fca4e7259cbcb5f23688d06112d3be337bd51174c7e70b1a2f3a2eb8352cc236fda893f9005cdc956f7730f38ca069ed239df913194aa133fc671563850c1a4738efae6a6e438d6a0144cdbc6914a9db4890ff34e5520bb1b287fbe8878f71289593bb096ed71bf2169758d84e46cb20ef65556286bd0228844ec3e7b4b8269e141a5dc982287d98069f011bec208925b34f260b8c10c4f245f2e06cdafd0928898b3d4ed80c11b63288c504edb6b430a4dca5777f436b0ab73bc4eb1a409b39d139b2ff93b632528111cd390ee50a90ed7c91a7367e2d0095ae0cb46d8548f2eb0e57225d0d82a2a76d5e52a3968bf83c76b9aab4a5835f101aaea373f6d4b20fd371bcf19384b766bccd5e4861fd7c7d622a9bd871fe9b32e98b6b9ddb2ef03d3eb4ad1d865cc3000fb61841a887e77eda28dd27a78cb1b0e4f9d7aea3ac9664cf248f5c16dbb05faf488e0ad5b0362de9261979000ee40ad8b6320fac65baeb23ea967b799d92003dd95a3f77fe6c6dddeccd8979ea5353ca548a42e69a3a803d58e6eab4d6d48d47aae940fa6734d5e94036e704846969392f0b60c1745fa76f6970c15a5a49d0ae6255b2fbbd44ffc94518229753b36d9fe7869f081eb2715e7dc678b043ce17d24675e40807d5d156ca60d262f112d9c12d6105282c7b3fc5e1bc6904464aa90586fe42480c064214b5c267e0315d8057b09fe284faee0ee7d76d6db75f47777e5be32e515ce2072c1f17cbe24e50e055a2158977cc7c6f82f26ef12fb2f3d955a217a70e402b314be0102081e28a2f78ef8645388ef8cdf40d341940bc328b5ce251f3708ad2d6cc3125a1d602f94f8694a3fe3808e771bcc169e95141b9ccabcb061b1dd5a550f80422235bdf13c0b6cfd431fd3ca49c2e9b36a7cb847db8f935bfbece9356312ed8576ce08ab3c356dbd72680dbe5852b72738943c885e83ac57763974a5ff4537ea7f1ec9ea62fa78a46dbecd19c0a282a30d8f66c122d1c890d2997a57cf6084439df2942bd2db8060ce2b8ca298342063e8818700ae1f37235df827ebf4f9bd1f1dcf237d399d2c74d9580165ad9692e2fc5c31721dbe6d27163c196738a8d5b85d945001f42e6b0f483f56d2fb8d149af36bb3796330770eff71a1b94cbc6692696efd1d0482f713800cb1f74ba7fe1f404d6b962a20fa89cc1405a89daae883e30ed752eddcfa66f3af2d6f51263461ac302a0b9c9ad3751e416ef6447514a4e09004873323ca7c96b3a5691e276b8325605a104dedc66a2a6480b234cba29d76d811c0117230f3b978f675b3ca11092b96cba9b98b0e310b55c98e66cc79d14f31969a9a2306c8283dd55773e50698fc68b1991559b136155490d79690411b30faf44b951a44f756f31df906ef735244e89458f6bc25b6705119800e1048cda1027c84dcf0f0595b8a50f8c70e1472dcf021fc931f49f2afdd42e7f8edfcb2a862b6e94fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
