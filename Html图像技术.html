<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91a52b1f13f3e87160a182787fc36150997099986414bd4af8d80eb21b96c3cc6014bb73514c8e98b55f86f9968bf8d92952d1b812ab0a1197bcaf1a9bbfbd23042964c44aa8055cf52e01262a901e793854889cdaa0c7080c97011efd6000e59b64dfd91c22fd6c50a5bb66ae5c0e59d81adf4cd874ae2d9264515cee5867d48472de2b424eb89b2afb3694abab00f677afb4e60bebe60b0fc296e3fee7b701eb9eb8ecf454a01e0766c316e12c96c877bbb3345df881b6edd1dd96a0a8412f60bab99e0052cf4049aa547471c363dbc6376ada0567d09d6d3705b61f05dd85f3c9449c3070e4e264c6a66e5011f3fcba287b7312236d435f215afac87b3e39833c7134f581735674e74fdb3c680efcc33fd36ee9e45e69839da2da989a322c571aa0e7378354a44cfbc64a05ccd1a9168914141e65a62da500a6eb5d5773b4d85ae92569525e0e90d0457c8bd028ad6f26c7bdd36041a4e1df8264379363152c10c187340ff14dc34ef870439436f317acff9e62aeaf76de4329cc3b26e1f30487f01d73081d68dc758e95137ed14d09b0b79c1badee185f5d4878cdbcef9c4bf8597652b0d8e008a83b12c86cb5caf1346d7fb1fe98aa0b589d188bd368c631a7cdb5f396edc739a49091eaa8edd0c10742c69995dab485a72a97788636ea59fc6b5efb51514193388fca00101678455c6d3d52bf2a8a6c866128c17b3a2ea5dc33e3c803faecbf93e6d91d8f540fe11c29925d680d7215172ef059e48c3338134d674f4bf68f868d98d0d9e5ab1cdacc73005a4a524dcf821f47c27f3d91ba66deca1df38c444f339d7c4cad781d190e9dafa244f3266e122c6118b32fa4305b3ada52c5de9c930791137551f4f1d6c38e41553f704c6d6b7fc7cf1a5e79b2c33c289b4d08e06468943fa52a0b32bed04afc52026c8a6c0e61c9989d7ca5943cb5c7828d1adfcd3fc4d084a32890807344b6fee87ea171edb443eb5a14f11a212b742d197f9d27abd692b7e207a9a77f41f5e559750be760a4dd45eb37d2390e13e2f28e5565f34f952b01879826faae92a44c7a29089393be71ccebe2705119d917024191ee3d43724ce8a63245ebc9466cfd36be792c053655b8e90335c5cdd4b5f17d4f3488b0332fcf86a026067416ad933d46b7285dc9fdfd51494646ebbe3af5029c6b63fb531bd92a06443501eff69521f046af6bfe9444f1d42ac5718e9e7ae6010282e297016becdddd2cab05e804ac881f09d85523607de8aff3632f7f300a608f4fcddb7f784b09285fb67f5218863c24d732d362a137287067516d8e6b615d0c488d5168663f87aa619cfb09f637666aa24f989a3d3d9bf0effd552278177ebea096e693fba26f0623b5b72ee6a9618adff5ed6fe2dae06422337b3967cb30dcaea296ef7cae9ec982ba0f4f7e08299f3b44afca45a1bade7b3028e002fb9b0e7e815ba6848c70cc0be7fe1e877d9410a0635a76a56bba2ccc60b86daba9b212f050fffa4b1cfacd654a90654e09b073216416b2c8ba134052340fd8d9c848f0f8d28b4de6ce3f7b5e02ec6ed33564313a5f86490032a3bd2bfa12b13a113224d862ede7a3c77fc4153da00ead8197182bc1ae2c42c1675199183126e20f8cd96629ea41d342ddd352dddb2c8fa79b83a922c032333059e5a83be7dbacd5290cfaed8249e37cf7853b9117e81e57572f884d855d11e4d007e8dd03ff5cdc4586380ba709d5602443f00ccc898c189521d095898c29d8951ee3d83c8a08a671931675c94fe4188f1c7da9b79d9de106fe2bd240c4836e3d920de498c5050c4c0d33710fe5d29bf7387c0ab05283260617e76f3143d563353a619478ab0fdd89d8a33036dd1e6cb732bbc22185d2dfad7c9a9e2c7f781e0f1aa2fc52f3ec74aafd0ea1987b98cf08530c92749b9edc65487ff95c2ad2796ab0f06f517912c75ce015d3bc14a6ef2c6e22fd32c154504f8f3e48eb1a08cf7c8be2ec1b15f3983a03f51fce036d2866543b7ad3c281f71589efbc841950fb37a1ad7830ce836f51c5c0326d6f26d05b8d8a2a95fc0bf3925e51a3f66251d358363add227d3c6adb42d9bb116ac075ab0114b58ae1a00bb527c220232112f670ec60874d8a8cc0291776bc28ba9bd55bac1f4789f35a935ea62b1e34ec36cc2fc0ae8209f270f508910ae13c8ee8b01fd3f8718f88a81063a8baeba26ebf77ae608f7b5e6d2261e0258df2c205a099d821c0e754dbd6addc35f79c954c79ab7eccdf6dd0ee38f1fd17189ebd866844eebc46cab0cefee53d2051ea7bf7a934feb74181d2776fb95b7815f01ccad8c1e27595a5243c50aabb6e1f276f9c89cbd6a913282746c52d34d5ba38d9a571cf13acf9c30700b1fc38d60ac83cb91b01be1597c97d4d74592279b4a3ffe02672887c74c41ce7a8fe785c1b2c011ab6aa444f2c68c8d4b52df9422a9d267aa31ca17641a8c47004e3ab3cf2cf51bace9f18ce14d87c07c8b2a6e14fd3a370ee52a805cd56e516cc6050cf97c1b3d92727087cc887f06414795f6f82d0a222e52d2388177edc22d255ea942562189092c40d30625caac5b390f857e9e7830bd0fdaada7d90fc331ac6d96a8a6e62d8b63efdfa11835372e0fc0da444c19d1a2c14ccf4a15828ab0da0d36f08887ebf2d9a8ba2ca1e9afb21749ece091365eb39a20a39620601212337f73d78cc122a2d9d42e99d0c95a437fb288a6acbae11eaf9d97a720425f1353d3c89d57b11ac1ceea6f4c7a3934ddbfe95e92066cd9ff0fc66014d4ff0183a65584411012efee32b2b35d15cd34302865ad0818e03407d6f1b8889a0b6646b794cf293cfb6759ea4cb3d3fb74029aa152745514e87672f71fed88e80473a7c9d7c5860c2ea6d49900c58f1a3099d1e73f83bf96fe6d11ed57f57252d7881e782d65f8f5229600855bbd7d4447db8a46f784b5f292c1ce4b4dd9ca3df7c0047154140246c9bb597a177614c53cd215d6dd3de2eacfd6f0b664e23eaa39e1b86d0755ff8de759baf5c647e9071004d438602a7eb6778e395a38641a35f46635899286705228b58e75317ac5372f413735ac79da63302ca36ee53954a9c924bce49744b482f08375e7017412096f7560174470a43b068b413b42843decfd41892a69009a7077c34db58c6e9c9bff5cf495a49e08656968fe3ba13bda02f1035f8535654e980fa42ccf50f4a4c7962e0fc531b0124021d023e9e38f6be2bcca848cf5e2fb1211a80dea1dd194666931801d03145de72f7dd34b7a4da13efde201ee6826233d6595aecfcd4320ebc4c054f7f42c81f133177b30082b49bde19a246c155efe2339989933efb97203530532e22226ee55e4a0d964cf7d163478245183c65779dcd11f33e982e987f26d2599f6e95f6abae4ee22fc534756561b9116c1d3c68dd353e585a5f9b7691788a0675d290c8e0c954666ae474ea8cb4b40ea57a858a2c8d488fb2f72a6859f58f2f527bf5278dae1b8e801c9ec158ad07b57a243f813c98a85ae9370820607cebc6d13348a8c529b504e96eeedd3236c32d06471fd4079a303c605ad11511e2ba7e7b5c7daae441d90e707005026b70d31deced76d5e0bc76a5ba4b2d18da5aa2cf26d0f288ac69fb6c882595c29fe0f7dd3d9748aac25692fe17f7e399908e711f3f9077054aad8f1788c9837d66b29e98485108ffeb7e756383b4158c126f58149eeaa9bbe1019d87bf6d67b109a6aad90022a5ab7d7833e23c872fd3ff51326121628b9743b8c58098e14dad56584cd7186ac298b2f251688b69ef55c2920579c2e778c2704992cbafa3659b5f82a2bdff29a0e67c61f469c38841e734ca0210006c0607b540aa72393e2817ea3d5097cf1dc5c1c588a3c5952598d997cc07be90388ab41bff498fc3efba634254db9c7e36e405e38f35a277769e5a64b0f8022954a643540b8de23a69c414ea0a59e5d6a1465c626bf0c39ca70615163a50170c545cd0d3cbbe2717b009b81a43335aa40a9d7ad93a8b51eeec64b549e74d142c26cb709dfd82959fef93172338cb8e28b06d27494bae3f4fe367a73b1354f6fab6bc6e0579cc09a7fc57a35ea2136b49ba473c7b2fd1a6c1c187d0ebe99b507486cbe4b6c6765ccbd30e12b7028c82c924616980d7fc3b2fed562aefaa499758127fa43f5d79e704ef7643c35a845c9ecd6dfa1ed67e70fc0a9fe7287b038b8d9196a935209c55c95844afba238dbcde75321ce8b913d50e8e7f3e9c1cce231ec8b7a2a820aea77a1db35794ca79567847b33e33889214a561ebbe454a376a12b204cd531f502d070bfa8fa4bdbd695e0b1ec9c41ba565d0bf1e75758d2c90b06f867a42fcdb99ecbad8d5e2d1663fce49fdea5ba98183dc209149360d93e882b29201592b0f8afe74768da7643ce425951606341926d57ba90550cb98258f4053bf973802b8191cd95a7870b050fff06c77546ca771f74816a6c6f023f63cd31875df1492b52a52fbcf2c8f2a6ff4a70c084397f44fce32045a601d98b11efbf3e869bedf07835f3e60d4efe4710ea0abd993b0b005e9124216cdc62f608223fb2f15be3fc9d4dde3c6f5b23d49d7173dc7d45025f2e8d6872d6035ea073a3cb3510abb87d28d3e04ee4581ec99296acceaabccece05415e6036bdba9a82719c22e4b1b910190b3c542c3bf18c501918988d36873b1b5932b2dfcb1d2a508b2b22c57b1d33945a6d8acd8e340b02a539caa5dc97b2269e0fd043ea38dd8349f6a9ab650c58d78d3a43ca2d061543e908a9c78c76d63b90fe350eadf315d47ab0a8660e238f8fd046a5f29f3f828cd0d6996b6daf02c39d4029ce5f5ea61121c3560926004018d2351beaf9f93c1339fddce48cbe0b0a84de288c76b72559039e179f261706ca4bf3387e423132b4a2a359a39a8641acb3913a42b23c224bb0201203ed6715ee64c7a094b237e811d859395e8968b658709a1faea26dfcc67953319d3fb233a600478aa916527b1bb6d7ae229ca083fdfaccf93d0e71cf7339ca4ad6f37bfabc289bdb37dd63634e64896c33ace2ee4002472128be75324676898fc2543f10d8bea895f01d0eac6f25c75d36ce4d1cffd70749a951976b01da24979df92d45b522204fe3b1829cf0ae03bd3c0d3111c4fc2095e0120bcf3858abb45ed2d0b5e4c3ae782ae270d7429b22458853195654d8a9e0083402d7c79e4a33924aeb0149ea5785cc84dabc6f137ba531a9bdbe5eaa73e81593b2a33e94e3d11cc8adca3c919973e40e89daa1dc7b416b30de61e1fe7ae1c58a3e6eb545b75445da3c73aaf20818ee6af2981747678ae21662fc607ad745eece41e2222df85a51cd9e7d2266e6abba0be678bad98ce2b9d1e240b8ca2a0b5e2162c14d2cc80348ed0395d89bce57bb3af1d4edc2e9a866ec5c12eeb90b2be88edbc1ca8c82cc7648b2af9cff2cd9325813390aa7dc9410f66c95bd6363b9160337dbbba9cee04eeccb489cc6c7287a3c99a8287bf853840d144e8c9ad56bf35d4f99a256f3680576ee7b20acaea37e97ecf91dfb753e721ddc36d67db016e193da645a84ef93dd4a44173111ceecbba03afafbd0c59da4e3584e7f101241e27f8256a2dfdcad1cc469f15d6950abe511b6eef3f6fdec1cc791a7534d62bc37d30a63a9fe1bdfcba8c24c8641e06e989837b43a6403224cca6f7fcd86322bcc9a9e8b2236efe62e722984c02954a51da6dd6f6e94e2f76052d7029d4472e712a382c571ab9ef6c557fa9de83274a1b67f098414fbfd355d0c2ad95dd63c96f47886aabbb480499cc87671e412b6d41f23ba07593fdc6d9a44ba611f09d28413d5c0b96b4a67bb5d6f5e9cfd3298855603f9b4276a50b424965d7dd24ae2d0a40af9a0a7acd711a8adb4c4d9c592962947f596aa126c0990ff0c0aba4f6ddeb212259b76f0e001823ac20a2df74e7ea716eeb795c216a763b276d6c85c0bf251845df8d352e4e386b9f2e47da627ede21affda420eae39d2e03816401f1b2f291e4842e20bfee4a4fb4e4d0ff07ba66621c421248706db5203c688d6e9628fb3a324f3911b90762141650689b2c0eccb22f54c04a1a43d71f33146736f58defa7a371e74475a2d0b88027f83ab06c022ec6bb8b40a41b4108ff041e53b52290dde712a85b834bb53a47c785290597c090f85e99a1071c683e0817daa37be1db148e43ebe4e6b3a1414c5fca179149437c59e4f04a7ff486822c9008c2f524b7c13b8004d0a3e20714536043878605fae9ce1b7a3efc552c92b3e7ea7284ee9cd5c2326f4acb3f39ad907d26292112d4f5a4b2e327b5917dd9b0941a96e77119f3742fb63dd63aa61b2f978eb1713a5370be0263c0eb5658e6259b8d88b61b902da8e160900c4d6b7ec1aa28243410dd98ee81d7d6bf21d9e56fe1979924dc131a3a2ef8c281e9653f7e90f5cbd583045ebd8e87fce3b8fffe919e141f36c14221ff00e9c5a4e2d715cf768f87dcfce2690122897f2479c4a9780333dc673b6689251c4504dc7fdeea8d2222573bad817b28af6cd96a9fc552d924882620be37d7e4648f9c059b6c536f3162bef101e0c96b00c099b737247ac4d3dc20429920251ac84f04b528124dad2525782e48e5c98e12a4871716766e9809fb4a7a09e88b34181a4e294a1df5886c2577d4c2c05c22e1bf8ad9347861230bffd13e2e57b64071b5e22a4dfa7833c1722e937ffabac64be8a4f504b810f9203e52d4dbff0712bb9838182650c23f17e829420ce63309c90cca9d0989b34b27ee9897dee726603f47c3ef26554f5ada1c7f97161460a560a084aaa5958af3023bb1f8a75351e6639612c05d7eb45fb7890ddad74e4562f74792b591c51557dbcce9b131df7a84c43fda545edd0dd0bd0ef26fe056297f19f4db2050fd7e4af8ccbac9e6bf9c414c65049d8aeb684c71dcbd78e5f6fdb6e22cdad2fc0838a491002346b671ce6ec5999873016166596cb378d35b7b56fc33bb6daf4f648635b5fa509c36317175acf51db403d8df9b7a05133c19bacf8e45ea3cec638ad8b80d3714dbb8f9e12487c21b3c9a45c75593b91e6da1d88e2119fe38b939d4de8847094f88636459c5d93103e57a20765bcf1efb99f56cca7ce335c983d6b235028dec539638441404e3bc6282d8941c3120d0c89ce99fa957de9f9e9a265c1319d74cddf1415c73716d34b8d1318e0b627ff50a5a24150394e9861b7b3547113ed6b19fbd191d645ac7cad9f2c49cb933b3d9c5e242229e047fa9443dce68a54b27b8aa74103b9cd6da081e64111a29d41e9795796a030dce39c4616c128285c94a469f243f214db9be521b7dc4b1d30c0c18799587ce7d1d4c757e3d8006476bb3a20ffe9adfad4a9acdc0908d84e1c7607f8a6c3ca276d9acaeea59441f17c483c16761f67d6777d9a1e0fe05b3fc205f4325de992aea3377d79adcfa6fb576f90434796f23c4f27049014f1cbd9ac0841a35687ffd2aa91dd7f13c6e6b3d55f1401fe8003a0534fe82fbf1704a398be09e30e5ebeecab1945e3b005d842eafd5a2ea600b49651c6fae0df0ef1db4bc3aa2a029bfb9a82fdf7fe9e9e7171af450c408cd607070230df30846c9c8490c018ada4b55461e854b91da4ad1d6ee677f2697ce4ab2841ee81516ff2e09bd5bfab8f06945ea1b1fde2b9b6a10d8d43d51bf904d4c90e0f35654b5aa18320f436b44ade2b365d4203afb6062c188af5903fa57ee3df5828c404c5b2e4d5317c668df76727bf4ee24d4bbc462baf8bc2884f6ba8b288f04eea9e8df0a43923198a1138eafa6f92b91e09d3b9fcfd9cc72eb0c6ad444f57a3be0d16eab9b29c70dc431df7dea8d94016ffc8e27445480a82db632dc4321c4a0ecfa889990e6524956fd07994113cd5c5f618ff0f6d4385b42f1190b35d5c734ea48f68e742697e64141ce26c85937098650f2014ed574ecb886d7a856da5976953460ac183c604535c4517d9bf82237ec5b5770efd8e50928d6a1276362ca8b7ad1be9d5f21ea49334e10f1b599abbd9ec6757f63fe9bee778512b3b2143cc89bb3f929dd71cf1d9af42dd16e7aa924c1765c2a01557772ddb436e62f2130a5d17d82c54466346b7b18d3c8b8668b9bac7f3a4bd91abd9d84c9ffe9438ca4e2de1a36c637769bee4249db47d563923b22ee8920cb21437b2c10f01b8ef0151a24ad4feaa57bf1d779daaeffe94b22610ce61a7e0bd46b262a3559d47349c45f15e1b825d494948a7f602d364ae58e6db86d9c0fae895d7a70732ec702c778ad763db34fe681c6b7454715269a2fc6e37cac26717cbe36ec6e733ced5f033b9a1fd4d8ca99cf9704676cab032266da5c12e2eaae6343ea9bdd119faae553ad6c704aeb26cb58afbf31d42a72bf900da859956173ed576bb2d1ff49c7662733c6f25ab24ccc1f1fd9276c146338b37b754c606b38f3f2cd87526a73a8ec99af31dfd10e6d6c082fa6c130b1d4b23f6d79e9493a4390542b34fe63caf02fc365faaaa91b932e3ff6133a201ebacc90f1a29fe958743b8e89d9ad4c4002d89f64df3194c2f86dcfec13e4cb659477c9b9c78e5a105dfe95a6b046970877da3c7d266784ba15c3346b8fbc4b1098e4c2a041b1d1abd2405a6308fdec82bee4970eb59a2a23083bc603421da2e0010bac70778a36e5ace7a7922c5e9189fc71f8c200a9df96bdf03ddce9b7ecc6c199d28b55d986f981f328ed884a1af1cff03526d5c512cdce2bcf0c7dfcf86f04ff75ff32e15441d5099cb45eaf11d17e017f8a9a3ffeeca2fd18cec06900da2ade16fb9ee51652df02e2f856d2f8c70546f0e9d111c6e3d1489aafbc6f340d18a4f4d1cda3e6c7ed26da834c7832805aaacd65780b195d75f2c18747e086e38086ee0e8f217e0fe428c49ff6773458e7b3c11803bea6923e1b799cfe4de227dab7ab2802584cded25fda098cd28635acdf49906f7a2100b8d42820c023b57f50b683642afcb2e357dc1a56343163b6e841eae2043f86d71ed70316339ade95600930af9cd21a743a50ed61973c4eb794295d565848af23901551501f086a50be8a02b0f763d70329675648e225a883daf11f14aa08517047fc4c1b98182f2eb02def18d1ccbbf2ef461bb4b256a1a045d9a11cb060f3376f459a3f38e842d9129bd59174ec2fd53484edd7302001b72d65c4ce75af0d9d3718e191701e04087206508c41cd19a09ded2da652e94eeaa5bda2bde8e38e7aa4f24356bbdc27d99769a05c3a70fda489fa9a33589a7f6489257ebedf8075e73924ae16b3ff8465c5db300c69074d0ce4719c9d12b0b44f47af5f5a9b05aec9f26dc28fd0733b1a683c30a3579efa653c1cd4a8ab2a9794c1af241ecfee0045689eabd738eab9883b25996ac4ff6d9032845287b6eda5035c2a2cb596dfd5dc0bd9db633d1f3156d9e87e7c815c1bc29e6cb283ecd99a2db1047f57893a16a35b4c9882cbca23b4b87866f54eeb0860670030efc314a745a853fb055142172ee90dd3cd14783686386aa4c255ded7ced5f1d18633ced9b0b9d3b5c4079e909a00395343030ae7c9b79550d7dacd7033cf7a431954799960b79178c13602bb0325375522801a95b8f1dfdc06fa2fef9cb39b9d170ef82902268a7bc940bf4caef88a297f2ba89622cf2f9f193b50493694b3a900fda07717817e1a7ff4c03a5e081381eef6e66b9ae8b41ce514d52bfb0791269291a1e77eadca118fa2a23090d8a9790defd48c901925535370777aba44021f002f7d2cb8b3146ee455ae675fbfcb43fd1dbf110f3c52abb1553792598a9afcf39132ff6bedbae0e7bccc5d1ccdcb8d40d6c42c8f92afa5ec8a0d55983762fb1fda607c921112e78d0cb5fe7af2c846eb130146fc179ae8d88c9574abefa81ed5b472633241d3d736a8630890fba9599b15ebf67111e6a2a16aa3f342b2b8e1e2dd0fc510f1e847b035a3b566a9cfee8f148df927a4d1553d878bb26d644985e972f38c3d592a1f363b8a1e596a01e663d2f34a3a375a20f9fc233fdc49ff3ada7da0c6b00fb245d2a983632f6dd6644455e07dbd9f9e7cdcf449f1c59b19195963999cda9d632892f407a9cc54ff0c66ef7e6392efe7d0a25e17d90f71040e10ad5d836b483b072790946997120d754ad7a1adbdae4270c08e113908dbb29bfc44887cfc2fa96bf9323b65cf7844a2ac3b78cf0a6254491784ff5c3979db253c6689ee2ea1ab7101ceb4ad5dff7738f4419f025e08411eb653894c4b7db2b77d5466d6b3cc7a45ccb7595b2d57fe00ca57aeccc14efeb7f19f6ea302134569fb250c22cd28374366ae7c7afc5ec91d9dd37b89cd82802171a17b43c0063fc919687ce181346fdb8fc9f3b2f315f2b63eb90c475aec7acf0f6a3169a30c6cda9595f43998629f6e66c8dd401f6f7dd4366401bf7464c20327675700f2aad1d2a5eb98f2e1f2352466fa473e9377407ff458a929c81059199fd8b99a5e166a6453694d5a1d321439d4012e69eecc89a5c8799b1819679648dbf4d3139a9c10b8863075b54b1e29ea229de030304e421e9ee6c35da9328e7b3def4dd7c557f2fc23508f703d9c588ce361ea08ca76ab412662a1a0096f9aad7a9a5142606f3299e3a74679148ca605328605f276c4961689448741908b5413d5578291f62f38dcf2a8bfadd312298fef97ab0b09ca912b38b603c46d03452824b50b988278651cb93f775d8d90fed5a3dbe984c39a8753548e15f5a44e1725a37a6f6739976b9834fa4fa2891c6f29c2a7f424258bb19714d98b012aac9e88a9db73b805b9c74731c1a7c3c064a2ce8fa48a5e1f32c3e3b5ed6ee38a9dd4aa6405533aeb1b70ebd1d77836d98ce191dbea07cbb60676719df088b79c8313ed2cddb5810e42fc6a49cea4811970ce29bc5b3e69d492e01d9f2bcec118763cfacc3c52ebfac6df521fe998173a532428baf57fe655958c4c185396968095f978c8d898213389b8becfdb8600f3837d2963e1f24e3317dd269cd4cf9324cea8098055e5c53f022d5acc34dc24965998003db887d5afa36be9cd7c37e6eb241a6519d21f3d9383eec995267cd1a23351b3d509f76abd2d87dee8178b07189f1af2deae43f70f8b70301292f58b7b3878b179fcc17e204770d5b11d448e8dd3b39aedc34aa0e32771b21fe563a1bef4d961322fe25b09e7b5fdc5468c924434b004c442954781685a23c69fdd0e3aeda8387863fc9c4374e50e6ae9ce97e45ce674511a4d7f6de2734602bbf91bbbf12e96daac7cc47868aa00f778963c717c3230f08d446aed26944ca547bc12f3b42cc18adb95db959f68a09611e0adc473ec511ef5bd8ea2e471833c118b9c6ce3fa4c086e25894dcccccd93d64eeb5facc438a59b9b5d3b540557e4c2fe2fbfd6a64c6386f9cb76d423fc9dfa6f0fa4a5c46ab657321df04425621e857b4544b808c6d987a36f822f95ea81b1c4d83caf0a6e79e7ea93e69885f5c5ce0c7394dcff417c11704144d5584f2716d792fb6809ef500d87a587e6bc6642ae59d10d5d89edd1bdb39de1838bff44de46bad09f5907cebe92c515f43b39adbddaf62bba09a9671794f14fd4ee70640f7d0493e37b8d750833eaeb6d867683fbb03369415e2ae796ae1dad7d0718d194750a629c5179932f9bb6e09ab55a68b2f671a1e7fd9cafb24d520e0cb1b34af93d19ca669ae3794ed8fd486c621f8ac7631fa9a2106f133cf5298709d1e0ceab7d94910d8e86ef7dc26906524562b198c185b0b81dd8b9a70787c86b8fce3e5eb29f7d0611e75d61da103e745d1ee6c2f32af18e96ddfc3f4239414be7bc8add322605cd1542bbc45824536bcd4c771d008181a3f0236eb97c8575e5181f376d9dc74bf80535951245fe52da20875c658308f2ee096f764796d868cc87ce3e31f2aaa4de7b6f14456c4bee3d4d590ecc7c9070f6bdd3d33286cd151b1f0916d2d3d03afb7db5d901a29482b1fc2b8f5878ba9a6e06c59c34b87e7864de9a014bd15ccf0942c0cce33f985655bc328b997f939294b945ddc008355767a6747536cbcb6fef4cbb9051bd714ca02dc3b94fda0f58585a95a0546a5741f822a954b36af48ab1a7c65d1ba52103a1dc28c91fc0646e39ada9d361d54d61867f2836190d7019856a7da2c3bfd37148ed1c4fa16abc2e7959255579ea49349786a7998f46fac60db128ebe4a7b69baacfa67ff0a385b73ff6424f187671a2d3efb8eec1ab9c0e5f9b95012f6c10f8f693b1a0b7649af89617e32f15847ca43040a2ea7be521e7b2515b31508bc172022a5d322a5856fa5f052a2ec5c61f56fa506ee7d7a943938310b4d0acf321fe69094a7395f06c0afb017200b0685bcb671b4806f549bc366152055dac01dde47c681806025891a94eaa552439a1df1c2e4fefe40081f25341ffea0c49265711efb7db0e5c58c41592afd0009fa08894bf71c709943963561ef8bc42e39a72bedc648e8c1d688320dc257ba105b3bd517494ff9ea1bef1cb577aa17e0a6a1d124c188a40c811251a6a21cf5ce72e9190043279c3a22870e18d098114a09a56df9b220fd81c43cbf80ddf15f8192e30ebfcf8684076ec447d4baac036fe4ac3027c50485ad8fc8f552899ed42619e0a5ffa0a1e25b3512d1d3783757d62ba05af302f64c4d332c65a2460716d6cb77e9e9c7bc43dab78cfd747e4d019f7b177536d163cd12556dfd04af319eef0d44be9639db2c684f1fac030b529f58902580fc68fcdc771109aff3c9c459a881a479af6e8266430eb5569f242c506898c6020608ceb93894fae506702bb22befdd0349eed20fc46b70aa8117cf5b87766d0b0e8851bcd4f0788fcb5c256a6737247a1214d7b61e985af44cdbfe03e16f7b05cfa0cf6de094801a594e1cc94c0b1896c893fd62c0201668c2df0d9d88839d7016e9a3702177d6562f86f5a2879935f2da0b3ba5cea66aeb52ee09b209c670a6543ff3030bb2528870f9ebdf6fc05592a84981d21cd2cd4d5dff45b4e782487efcc0b389fe2705a245f5e26fb8c2c08f0a0307809b56913cee6fd60fbea3e264a2e171784cda48b954c5bb6c04e8314cd7d44e5bced3e06fb702745d32447b4e49fd0d2c6970142de66f8bb02e76b49628b67bd20b8985d38ab7259fb357b1ee0980e422969937719bf9f31b4c02939bcf23611a65f607655032dc5c36da7aa3ea1ca7857cb8dbc1eebc2405def32f556a96585bb97178944c3037139a0e83fd3f63603ffb88faa925ab9d1100d2791b42206f0c3b69ba566c0dfb1f95178eff9e755db8aa3b2c70500ed58cf377d5e14a9f77e4ec0d19edb1102b715877f8f5b341fd5eb6f3ea29a0dc9d3a6ec344f19d7b0df85114bd35cc6a7f749ea1dc50ae16c756f37eb119695fb670aad76b2e40d77098a7ad8f8a6b941f825d20cf7d714bbe0249bf5e94ba7a29753c599e6cc0a3f857eb0fcc711e865a2f409ada3c476851495c0f382799bcb959e57677b27bcc5a19dd1cf68ca826ebdd658dbfae8da86f4632f0f9320e98e0c9a11262d59cfa46a4c41dcb50993de914420b4b55ff8a0bbb9379f751e1c71628812353c326826a5cc737ba40958c83490e5dd87479a2b7ba72dcf7907f050d3ecedd933be752a803703fa5b0c6c1f3f074dd6550c3f42d86e0c935faabb256f4db2c2f3680e75a33af482170dca3fb757040c8e33d79bd939293fb1633c0be0673d6da6d85c8a9795c1194f7e45f02c1fad5b7c8468e28cccae0e38677794addf97c5aece5fdefbdbdaf274eb63a0701e55272d7170bbe361f972949f2547c39db87c5c078a0e9a51948018f600402c6ade1ebdd6edf3710a6785156f22938c77053fb6f681828ea806178f0f7a43f05bd48ef2d413377141dc3f59f9964271546b502889a967f5c322b2db3271c7078a186b4264f8cdf9c04721a01d38a288d6128a7f12d31dfa396e758d412b0b195cd4635710b7eabd3cf1c16197bb375cdefc111f76015d34238da1121e30c797e5f2bd00581e4f18c6be7c7875863d512caa7f24810d0574ff2907446bdd2bea3bb4c1fe484457f1f19e63bc3fcc97313234f1aa0503f58289aff8b00377178f411b53882b2fb5736b4b9edd21e39c6c4d629650968afa675905a884532068ce6fe4644950636be1130dae762803f15f278bfc56234f593f97ee6af9dbe6a597250201bfeb1ece0855b5b9b1f1bf862a7ca8d982ab3ef75af17da7fb4f501c1e1bf6aac0700c9fda91cb2c809c96cd2f0d8104dec38be487c244a2d75afb1fa4b67def3a5081ba36d343a49c228df4f149cb423f5b5cbf9d08a03499c650d34d28853f300f156d38936931a8128feaf59d28f34473846398026b7dd1a879e1ab6a4870e734a94b4303947353277647cc174f0ca8def7ad3e3705aca616eb543e054f25870b194b9c916cc4c28830b64e6ec1af56eda1bb1f341a9180b960da5233c45395e29ffd4ecae5458565f3d0b73fb2dfd52870e934a0595fc36e1a029c0213cc09c4b8303187ad548ea529597d0807fc2458fb54930478028a312fdeb75bcfcb985cf2bc41b9fa3ef43740154dbfb9bb4065ad089484aacc705f33462bb461559d88e6a3af6520ebbff80e3a2235516345a9b62c5770dd4bed8188ca22e896c793a7dd94613e660bceb59fd7cfeef30a662101860f625f4b1d06d6b8e430e9765e958b70c96f7759f4099cc3b55541fdf8a88326e104d6f6f6e59de97e37da42e1e6d2feb42f003bc2f270d4945db01fc179cf5c0b570f17ae8bffed59a0134ad3819a8aeec22089c1ee620b26a137c901fa68b432957093a42068590ae02c8fa2b0153e1b6fca7abf2fef5519495237aa95fd65c41884c2fe6cfd82b19b8e756421cbe74ff7c68398cfe05f0ea0f869b5a0e8f3888beed570b8d96068a2735bd2f4386e766e5def8a5d7d5116f81ff5827b32773be17ca244e749eb95c9794f3f22bd5ce9fc76c2aafb71b4c91c5799a3382df0dc4a4ab0c0fac03e35089cea175b2dc0f61578f3646be54330fdc5d88576d25c516f01a0c3a7f1c05cbec55ebd35e7160936e4f36c87feab22ed4d63d5a393c090827817998e9bd001062e4cfefa4a6d604a8f60a35b06a4ea89eaf563d32a41ae3911319cb70b222802a1ead8901488adf86043db86e25f466667b358c86c305d0eb0ed5aa744f1583694b459ef9c9c6368df93930b735c946b7321df863786f0fbc8fecdbc758878fd0c463dff14ce675a93fefd8f8992747f91e993d441b96aa86518d8f802b72b76833d550841f5a17939dfee0ac7cb4928697f378a097892191dbd6430e5e885ba5375e66cff5fa9c1ced6c19b331901f59d69a2844bcf0991fb0102cc2b2577cb06bfd87ae4c736275a8e99e763eefbb1bcedfd45fd1e7afcd71a64641b1c361bec0004d85106848bd5ad33989047a197ae6d05b49dd2332b167042fbbbd3d7404fe57da57e3c6e0b480aa6c132bc1625ee0759f5c75515cd95fafae3852b25b7de906bef0f02df8af3588c738726fc4f6f2daa426e982f21af30d342df36d598515eda877c9d321c40b6a36de81907d02c8e3b4d05b4440aba42f823bf9ec3254e1ebdfb2c6d02ba9c6812fd0aee896aa2b7174b4a5e1a2906b9371156ee010a5e03788463ee399aac2fa0ca83ec6f202cf369d69b3e67a5979f68b366d2425fc6081e65bef8f537fdb216185cefdde92cbdc64d54be60769b2320033b487387b2a9c2f1b91b29ab605ccc7715ad9cb6561e0f7dd921ad9a68e44edb58c54d97faf4ff95bf50567b76c03e0622232f8cfa03fbc045160d9d354a6ce8b8e272348dda36c295788e740cba6451a6b36775d8d5df3972e4c5ce7560c8dcfafe74301c39bb24ab13440a9a775b128e7746a95f1feda966ed940d04698cad28a38403a717ee74e9b5f3dc255d6d69b4ef05caed1a0395845161ca40a9297e402e1bafb5f3abd37b9ea96e01e0ecfa6d72937b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
