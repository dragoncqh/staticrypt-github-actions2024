<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b0da5850efb4fd893e8f7d43b470e007d741c93a11153f848d202c419bd69b7c2cccf8278f7b4693ab01579cb7d8a7a241e6a0c7639c629fa1f487a573be0ae988d0935684adcecee8bc8a0d70d1bc0419dca18c746f011a3559fab4b73157045d4d18c1e3486bc8b4ccaa5b2a2e837894eacb1c1bdb8b6fa43ef9f1cce582b98ef1ee2fabc76d5a55f8a9ce5ade3b467cbfd79f9e328fa858944e867c1b6acaf30df66a932c69bde63f23f746287b3113d304a89e43082b3d10cfdd8e3fc274f8d76f7f28805e071d5f3a52a729d8e7df6e853c1e5f386964e412cfeb7ebf6b902107094daa6efaccf1d1f4d0c72e85c33a4bfa29ce3cbef94f7c8abfcbde65b763509dbff56d5365b5d47e4c59685bb2d6dd1f68a8fa78c056625d4c7e2aa0810729690a414838bd64c6b17a424a973926e3f0eea29db2f33f5e80d1848906313e4577310a9bc72fc0b045d2a2d27bbf250ee85bf5a136f0e34c9a2b9ac6282f93f32996ee16d9996681038ec7095f9216f3637aae3b02c35599950148d9c25b381cd333b8857e67141197b0a92ea6d77b35a401bfbefddfe18601b84921aea3468ac36e600b3e05c6dbd796f77e7d7168f81bc472623c28b1487e876d2fe5a02bfad7ea9756b3250c46437c446289f98ae1c38ec6d785b4d227a4d8e63cc81c22ab5def41feda18d4f04f081b558a5dbe0d58cb00196ceebb72a1921eac102ee83fd024e6cdf93ad4aab0868aa675a026173d235854709bfe0ed08dc19010fdd118b686b14b089836b490a5d23df5969822fe9d3128dd4de42e0e202cd9103444a0c6a32e70c8b85c177aaa8a74962ae5e0e87a9c25a3b8efb7ec70be1ad28c578909889f8c0ec8ca612874329c17aaf6d9181ab0114ed493dce94942b8acf3ed16c779fd49de2c62529a24f4fde3699883838531aa01a22f6f9cc57fdbbf7ff511030c4b79ec8af42eee117f4e640c2c346a1496015d3d33e3df279db3b6cf9e0eb7f1f7c9021e9a3858d4d2096db80f97cb8f10e3a565f33706280722c2a7c5459be2b1ac753e7369ba2b4fb88bcabb7c064a642bec674d85a11ce1c576823ddfd617fa97811c961aaf88bd33c6216a59e9c49249f79841b32e65cec7d97bd13eec79ee79cbe9013e6f6f354d3b4d93670dc74d61e842fde665b53bd109bbcb0aa58324327e0ac23177cfa6878a2b41c8b6732ad0fc6e5ee8c948985effbc8ccb99ca3da41bd737bba1ac4ef999fd8ef444284137c3b905aea7528cfb3a4a26185074d8265ca6b272a8de794aff818c7e5ed777aa68e9c61c20aae40674ba092f32bf1ad7b2f8028f8586774273a52a6caf202f90c9c865d2ff527cdfdb7437d476c90fba562bfff309f381e6ccea0d17c505bb5f7767ac613b82f2962d0390e1c787582592e45129943c36ff055862092b92b7cb3b834f4b3d126e8582b55769758423b0319e2053ed124f998d1e9b02c94ad50d71ce8667ac8d37766cadf03860b89ea66ff113a77336715a63ba0c4a0f989e9eb00e64bc8a9a16b5af5a00433aa1ec3c8b4848eab1c0cb7a8a256d0bf9e80b4c7bc9cf02f3d6d9205dcfa0d1a8aaf13d6cd555b4881ecea1fe5e4462dce08d0fa043e9c5da34df9375fc9a21ce5653de99fb21e5544967b11bef52faf1b26d22dffd77bb839ca8632e50fd488e9e910538239223f24dc9a507497931d744b1e941248256cf1ca060c6903ccd8b8eed1a42dd77f3f07cd022addd5821e87bd8baddd55aecea8d9a62a9027c5259f23dbcb2dd7d8d8d8677253766c91dcff603b7409312c7157664a7bbe0086aff625a690b0c30df3911710b984cda6d9f105764a85e56d6fd70a9737492493bde302966e8ffb4e093f2a043bcf4fa9180c09702455f8da8af2123f206a1830d2e74545850e334f572e393049a7fd8b2915db4ac08c6811d16b262acfcd7791854097696d99032ae71a434652e92e439601094b7f8fd9546c32c59622ea8820784eb3ed94aad1782247ba10cb3d08f246ae0d062ddcf81e4f2e7b2ef38d5dbe77145bbaca3acd94f05f5be95a66436ef3d7e3521fcd4760384a33c2cebe86b00eafba6506e3f6100ce70e92e9b1e9cee3baefb91b7db50a0b32905b667658018c7da603ffbda6bbdc3d1586bda3ad3440df7fef2738056af3dacf9b44a464a18ab34f9602a45d2375e1b58b45dd793a9bbb5e95a6320d01a4736de41b402a975970dbea707c9532d6804a41fa0015b1865d9998165f7b3402d4adeb7891e91ba4d7844fb00289a29a5ec4927493e26a111fe139b11bbf580c6c444b508adc045b0f5672b173eed4e4f0906f9e035e0c69d876ac8b3884730eb2274519f9bc02b151d70d993031bb137ed001853690248d800820492850765a406beece72bc043977350d42b47ccdee638b4bdf7939fbd4a939c090e9c058e35f5f3cc0ff5f5e0c6a9731d0d3ca207e7690375e7aa6c6416485660df3590c28f5de4060df6a923f703fed83be7955b1e7af94e7ac71a67c383b0c2d07223a9eaf7b6fcb14289d175e4bd551c3939856daa29e52be86a23f059c1a3950b1a9f294aa5f43c9ff1f0105f329362f1c0282183fc0972345228655f4ba93356335dd9268ecabb8dd74798980292a0788105eedb8f0d713e28728170c24a5112d565c90df39bdb0c0e9511e3802362d0346e93eb66570872eb28bd695a72d46a91552e4e964ee47d9f5c1c34439b2fc9be0e2eaabbe6becdc8940f814882fba11cc048aa1f145238e8c56ea924103f6e71bc7b293e02a77b18a2494c094f4b0c638348e5d2718a75f3c7da32ae3e13aa19cfe61d5e0b91160eda5442a4b91ced49733674bf0c4231c53bb3455e192f3cb337a2dd4871739db7c9bb3018d1848e8e296c086d26321a79bcc4d7ee9c3fe2a40863f896179d87cd340a7e908bf474d63c6bd721319e09d58ab1379b2bb46cbae8d2a67d2cb93490e3f627ed8be247bf12bdd3bce55e817e7dd352ed88a210724ebc381f8f8f560b7d77620aa5a4fa4527df7698736d3851c4dccdd91ff2dd31d381c8adc9da29f13f7617a5ee678e66a8b4eec375fb71d908b94054984ff5e6fecb3fa600b241937b0defadb506d40f51b965e4c7f9d95758a0ca24ad32f8213abddcd52aa26b5b7ea4d83c6c8ab7425657b2a4510bc2e38d6faa35b1d1deb3bb32ccf57d834948257f3de0038a40b0a546ead84a6e345c1e79ac5c9d96fd30f224e38d1474e9ef6dfd53e9482f8ba1281c1656c6f270a77658cbb5e9258505e61202021b27014b763fdf402578b8537194c66d5bc7708dad751ae54f125899573802280abcb324195ea509cd92c0889922c2102401e98e30770dc9fcc3bf7fc01d3617d4170f568f062e1cab1fc5682e7d4746145ab091026c95a3ced085795c1890b868f818f6c5673c1eb304f74a09c3490b61a47ad0d0db93feda1e461b73393fe4ad880eab9ec810ac8119169cf5480ee5c05358d7e225d5606a4c214013bc53b895dc1a2f73f791f695a68b01a96583f63c1bd111a875cc7febe7355ae8536036dcd5adea4e395fa45e15a571c4ac66ee6cd84bf11df97a2f9777ff55bfeda51af11a83672734686d1084def1228c9799a3c32b0ec601793d80b9595c2a30fe72e551406e9eba93ed0979a6db60640966c427f6281832d34a09186dba9a34b032f77ee97d2ac571b0089c9f46fb9ef80c3adaf4b0bae595ab992596c41aa8b56b55bf06596ed4bd0006b40446a6ca0ab3da4f4cb488741b142015bf7b12ccc41992b8ebedb2c332c8eb2cd9bfcc511716074932c399f8197938cba96969871832cb9190b4b88714de4af750c896cc996f03bf52cba44c57828fb339cbdf624a3e7a64c75d02c019f8147da2ccf5d531458866a8b48ee11f67e592fb4ac4be43fc399c5bc79f39204e678917801a0d69fec1e211ba41ba2ae4a50b0d280f9ab7409cf1e07aaa3162e49963f5e08be658c058707e05fdba79a1daccfc36f955cc51fa63bd8443ccd76cbb0d6d9e1502ffaadcc1289e6d48f3f8fc6017608606b3072fb73dd3ef0cb9f0e90b098413a0f5aae0843b25a0c3080d317047b734f28499e692438b709d63b4b02e0edd924019ce4b3b9e69a7b8c1b1cbe6d35ffea833ce2fce29d9521f6c941791543dfb481b1fac1cc3a10235e3ef733e326dc08d638c669e9836636b4a5e96580d6ccf5edb50b9b516f32fb726084cfaffcea5be534527a39a09ecb27cade743be13c2aaf1890c62f6197ad128cb7fb4c963f9fbe0aaae53d40e2d4edda6758c9e6c731eb259cf3570658dbed5856e01a878c5908c53afc2bcb3299d50335f5d02a9b3e019e15dbd6bb020dd5f7a8b68079501b0c9cb411a92cc47a2243df9fc56d3fc5f8667ee4b945cb802efca1a31c619fd1352064443936990832158a2571c40d095af0cc490b361516139f57a0ce8db2175214cdd2bdc5f27838d03ef138404ef5df0fc8c5605ba2a234bee9c94618c484b01d49eb1ce80d9019062ee244a5b718b9457253de7480cf477c7ecdbb51679b8a1cee882e7599c98145b4aad6e9ddd71923338d9add24689fdd64b821c824d8e5161cbe12374b79abbe8b5ac22b35437106fee98b30d82f9fda6499fbae243b2dcd7f20af0789d4395255265b6830bde4790a4403441244a872bf9214b48d45771e3f21b10cb9a1acf87500992dad571bde4f88cf1f927206c7a7c8e1459ae1acbea357d36c841ea0d1477c33a3f8da1b13229b9995db243cd1f1a79c3fe10786582a66d092650e67454e7bcdd2c12d90556c67e0e30fbd45d29478f9c0e316ddca75ceda8196642b20b5e9bdcb5401e4e35886ce6c06403858a38cfb4035b8c8195f954edee586eb80905f9966756904330aac4e2cd6a88e3b94670631b5c2ba7db469610d26caf6b580425664ac331994d035c39914ab7f6d8e7bef255ba73cdf7940370d02d2f54dc71ba8c2fc9200f1a1a45256bfdb4e3a460e420a0bee7bb1c8280ce743482f57013ac2115cab6a50e35f09b43b58f89c555bd46b1106574f5418d7eec13f51ba86d6653a0304435425bb13132196d3ffbfa68f8d3bbe3b73335133af0e55f51747f27ef645195505ba1fb4870740cdad9c7cf73d452685cc41d9c85b6968981bf6684ce865ab4b3b392584452d405080fc2499f7d16af6a1263962e5e3f96b587e2e22fcb6aae9f9d71002266b3f5d8df6c6a84946d99350c1f90e61fd69a4c01b1a7748359ee9254cf13d9bccc9adfbcbe35dccec12219f80db1a82ea6be83216d78ed98693a64efd89f73e6e4c4a601b0b8939b0e41886f998e50ca9a7664c2dce3d863f2592fae9f1dbf1f2ab1b15bcc00bca75ca089a415c959150c01dfe2155ea4ef179269f44ce99a3e6119ff2ed82515d266e397f95999f265d54afbb0ab05135bf8193f3364320c2a3f7d9e0b0015fa0f96b80f83df2e96ba20dd87516cf953d3acdaa883f56c6d8837dbf847e992167b9be3c9d33bd083eb737be477bfd11ba1859e4b317dc220f60849606769865778562ad0f0f65e9d5432b14dac41d63cc46f4f9f89311f5c17eb606d0ce74db179ef3740a2f77020a43fdfe6e269353a6a51221142485bfe049a8c2c00b3d6146729b05bf8c1b179ce2906585eea1f1a93b7406461d5a1de6450903376b728f897380a060d079162d8b85400ef68430ba539d3605fc889bce7112413f5fbc3157ed4288febe26f80157cce0228f6735bca3a12c53d499d9a867758844235bbe1deeb4cc5d8b2040194321907d072e86c8d55e4b3afabe8ecc55e51c3540490619c1be64eec70158883f8c9d3680218a0d5ec8d0a5b67b8e495e3ecc8e8f230414153977f1fdeb075d5153d14de8fc439cddeba14c3d982f12dd770542e63fd347070a98c6de05143f322040e9f8c743a541aaec8a43ea36e4031f3d1cde72c75c04a5ff8c52a203d8242ef2728278d9abf8a385e460ba24451eae0fd687ce77ec4f26e3f3cb9a4f3a190b239d4df0c7d9a6009fddc1a7ae5b6351db6aa85bebceb4407666c42eb532e9cd0b60857b5f9e4bc1506616dbbab11f54036161ab61f414bca5c7b950296e934f415d9c67aff1a86473e180fc72e0787779e2f4ffd61d50a2efa5492e3948dd5515ce626deacd2a6fb715fd08982f719200568ef874e141de3033c03fbb36dae5f7f56d8f0f52535fea90a61d073a3ae0f472eb674ccb8ad0c7cdbfbc0de7cdd9f7895f503fbaeb3105f7de84812d7b83630a06668402e148c483f80f870221dfb4041c409efdb265f374020f8c1fb0a8a5f0be75ed9148eec6d88255e054c3864c6002276b2a04fe6b3889de5afd6c859cb55c18f077b73047cdd0456cb5dda28515d1fdc30c731e7a88ca9641cf991d66338fd354608de247ac1b2c9de98ba2f15629387e4ec3741295ad7ce1edc0261330f494ca76cc86386f256ff444ba1abe59db6ed53aad713b620949a8018a1afff98a254f1d94db555a55f9400b0a06ada8435ea9d796b4356aab02206c5ba139ad946e394b903a863414315d551e6f33583db500a18d972ca0d0b99531a0645fea5afa4f1ec205b9f335086e8e02998c19ce80f759a15995f315d6e8b04cb8c9248c679297c20c7c7d7407b2ddd706c3c39f60696015e05bc0e591d35afbfca03c9ce6c44e59f13c67094eea18738b4f3a4af55b2273e2dbed49d2dedc86aedb4b23662ba59a3d5a4483e00b34828d4fc2acb33fcbb59640c113028c8f7b383fd634bb5d8848a5267f6ca5bae036212024d96d73b47a5193f0aaf4b441226ba75f6918f537f8b7694f27e80d9408f87e20d624e5c0612a112511e6c115f90e6b01e5261c7103f864b2070b94ba9ef7f727aa29070e559eaed24e54bc4c446e33b8b50009d8f4349112ef86cc94dcade28b8f0531cc4f5d93077caa714794521e23c184a3b40e401e6e6289d2c2b67ea238cccbdfeea5d6ca52d87f67ee61af18cc96243954e49fe776ab6f17e562190c09c490555ca4cbe94b923c5287b1423e33d4b02c4054c21d223ab6b4698180e4cb0188a310a6effd5985dfa8e0417173243df7ab6a642eee0377507e01169ff0c3b8deeac1501fa7bd305951ca7855312f1ce058ae84d29641fde63183c0ed5d88dcb83edd787f7802d9a3747a61535f3d06dba1dc7ecaa8f9d752b7e13693afc638cce05373c51ac7cd426347160c88894484a4b1788d476a27dac17fe85e91bbe3e88aaca08d144614dc017ec810623883ec706a106c43ebba82dd82d42d778c6f134176f5477a95fafc92d897031a922b20fb3490fae5e68af0811024e686936e29f2ce92993f20a33dec0b6977587b82150cef801e880aecd02c28f655e0040133ed38e9ab60aef8bcee11fff934d6a1c92ab046753cd176a2acbf5454dd7fabd945c91311cff3666de8482a46cbfefdfb1a08cc8529fb3284bc7f155c8903c51d550762afb570e22beca5b730ba9bf7c615fdc3c73798fa71420a78029f61d3dfb169bbeae04f9d867bbb2f9fac4ec1b9f2dcbeccc63c7f6b12c0684b310a5344e250f9ac32637941cd5aac81357a8658762323b6168d2f3ffd9de1f7d4dabff3583ed311d41596661d5abfc0b6c5e36456fb0c6127178078b54720135108456c84347f014d36c3bfa8beb217e25fb8d2ad2c2e25f1604689f91afbc6d0d2a9bb99dd688742bc921e155a564d07119d9da07cc9a29e7c709e66510e8de9707c7ef8927af1a08212e48d98ff6aa4d1c6d8203db4c5c2c173304c87a0f3a5e916cbc204de6caed6c1a5641a5ff03a529736e64ceb6e5b7f08f299971fdddd3131a10305390e50dee29506e2e1dfc838f18f23aaaad8aed38531fdea0f9b6b8ed01c6ecf53cd3f8604f058b2fd0663e83dc91c0e3ae61f43d8591e1aa0e245001ac5046f40ed0ae503c7a61b621762902bfaa5b85784457d33a3f0ac664013f82324b714e8fb5f5608e63f151c284f21173a2d36f675202d34d3a7300eabe338d2912cc9d68f05c1e3a82b60b95354af1ca85a1d082f831ab5baf3e87c4e16196938b3269f702858e8f2aefabff797a5685a3fdefc489bcb0d47d3efeedc1b428d2b255e26c193e3e8a3da55b703352782aad0d37b1e1d905ba8fc91aa6d20b3171409bccac9f9cf08f0a0fc05c5791a5890f147d005a598343c076d91759dbf0197c9b6d8e073b83d7e49a9209d7fb9af0937280870ef60904fcf171de50acf27a841652251ff701f628b04eb8937f647a8055e8a605c5f44833334574c51571547e50e3cb908b6a5a7ce5235a8ea48dbcc60e159c192820033e070977e05b685656dad9f08de90be25b63663a8eedb1a1ff16496e774e0930aa6ddeb12e32c3a4580e43f46db405cac024285df6c7c7c11e3375f54d515980983395078e8709f7c5adad92e0fdb0300c5163fc663e37b47dd5e6c1d7802fe52880d83624d2bdd070d61fe0cabc90b8419d781634cc47207ed7f807acfa42588e95e56828380a6fdf000f144ed9ccf48a6142b83ec602e6d38584c917eb3d640cffaf280fa087eafb1c99800e9572b7e280d06c612c65d117dab9e889e43a4c14db3d02bd606369006c0b577b2917b69121ae355a249fa32917bb1f6cd14b72064ce105543ee502f556ae52dfe0b1c53ccf4a03083eb943dac36d94357aa0e13d3650dc3b2c9ecedb268f21f9af33c55c2549c65d910825daeabd97a16c4e7fb5ce2195c94b40c707dbf6383ef5b1a80d564b7fe8e52bfe9c3754ce31bdd196b2fb4370b1ebc91fd1b71cfd0863a78eb72a9985e96b5cc05cfe3217d59748e1267a50b7f52a17710d810f40baef204c17f6052c1a4de8d0b5e662b6cabc4ed3651eff40c0d9a6cc37f3866da60b0b59619ebca7c15d6b12d96efad626cdd567657be381ac8dbaa6c039730eaff46a49cbbd2b17711f1e44ec820b9843693a4684ba02c394e4ace16c0ca43a4972ee0e27470cf0a761334b40defdfb40183dc3a9e704d3fb628a376c8bc2fd820d9d01cad30bea0345bfbfcdacea77ba30d4ff5d23a2cb933fa074b191b3947aa03286c00ede246582af142c18e4be30be30f1e824c32c1b9b8751263d74d6528af967a1ca56520ef15b2afb1924b5cb0b913cc18e09d9420b9fb066c39f25a62eff1434c65ac857edb00bd68aadbf48ad6db798b8187bb936e85076dc30f517d9c48c922c3a540c4cc01c54e4ec67c4839418a5734a01a35307c7f04033f1cb795582d10432e7178ad4ee94088aaef6ff65d1c69172be3b14ac9ffbed3bf179ba8e0910ee9ef7513895bbd3a6d9023ce2160592cc8975e8467c51b459e16f15a0a283c96bceee313eea4177f0959b8e52886a324b5b8c094d2506297f7ea753230bf7f0814f957d445f3a0786ad82d87b5d84574a555576da96095e26a369b35c2496f7da432f3098fe50cb3863f288ed1980e0ee0403fca45be4568c28e874d0caff98fa969316b49c0576c58838700353e44e61ac52950768a89a6666b055afbc5137ccfae33b1943d8582982f77b50b208618bd28aad5b3c7972311a00f5ef467c346d81ec339fdd8566889211925b56001de1fa5d7b98ecd9876ab0fd282bdc17a3b86df58c19dc9fa47c911bba50b45b508d290db1bee8f5eb6a46b9f981276b24259dda7f363a7a9dcb874af8ab12b3345b096c1ad244709a3ec124e19b469361361908d0c2120760f4ce0ef9a4932a2530958d53ce68806fe77f186dd6d6114a9daf5cb8c2d66c75927316bcf00cdb07d00664b5db21625352a66be1fc6b400641910b7471d0100366c1969e5849874c84228615ca671e570b233ab1404f74eaa077551d65beebaa23d207729d55ad1b7041297ada86a09f4e83069c98b2ac4edca969685a77128acaee72bca68f3096c353be2b9ed464421225dbf02f6b5a03c4adab02e4f1531f48630c4513177da9bf922bf08c906a02745ed8b65034d31fbb41ff5582d2c7eda62fc4593c12d057017fbc4b59bf6b79f78539f2e4d5f582b8d87221cecc14427378f18acd52bc3613b36caf59895845635ea8b2eca86a296d8f4567ee6b58456e862ceec7f0430a5dbd0362baddb99103a5f91976c1b9e8c5ddfb61efc9fd0e36fcc93ebb9147b27c5cd89ff7c8a0d33b7ae7e0dc27dfa205253c3117ec9d6f368122227b3a425a68817dcff0a7eb5545bae0ab407d4efbd656343f5981defa1f2c4b30b1a4e689be593c3f6ad8d17d3423561bdf6b7f4733ca4c8c7b3453eda4e5d8cea18eda921017899997cc11ee6bb870fce8d8b44e3088f349dde467f309d769ce5dac1d5f0d7bb5ccf27bc98370c7580d8065ae97ca197320eb470fdaa525484e1f6112967b99e847b9e7f1937039f9cd87aab0eed432df3bc8555bf8a839a62485508aecb4ff751aa9947caa30aa794aee876f98ee41e1dcbd1797ec86510f66b22ca5aca69cdd21dea6677373f1a09beae560a4adc89d757e192118fbea19ad843070b985b930aa230340ad2a3b5ad91982405b640d082906c2924fbda892b69eb25e8b707d72eaacdf6d82397b08201280d4122c9967fd7b63eede64264c1a1ccba5708bf6f73f44d96c49289c1ee84cfb632a74a0ea8a2fb984a98b72b3f1f8fa219c710d6bccf39e46669c6ce0554fc846d2d9f854501f7dd91079d01e2211e932dd7a13f96687c349fa8bf17b1d4ea3bce04858c55b15c1379919bb9724e41151d0c21144efcd8edfe787a5b688bf7f88fee8241c4f7dd08075c2e3cf83a4b3793424cb65ffa2fc4279be18e369a0b4f6755fc0071c76f0fca9b8c7462f9ffd89108247165e0c521067f03a4718f2b6182ee5da4e49c52dc1e31faae0ff7a05b5cd88341c5f358e50f74caf0622c8c82313b82164140d864cd8c76973a9c75a15fae688f98acebdbe45f8e8ef445d23aff161d55ad20f66e114c5c3d53c2c7b9b8345cfa8b9528ad51ac0ba4101661c1acd97afa551f6772a79e76570480ded0f5cd96f9740951565c96162710cde9b3867cb0e0bb98f2ad6b49aa933d7317a7f27a76293bde575623ab9cf27669e3475c1e836393869b85f5c11741731f769321e56d57836870f148c4915f1045b11d2e3002615ecfe46b02d25869dc6020632a1775a402709b46284dd11a99286d9f729dced9c21ed56afbc8f81e979df094211d05f9f9285b6e97ffbcd7ad91961714d93ef850b42ab989b037270a1d8545f6dc30b019535e2fa40b6bcc3971fdba0e9dad3cef55e2b62c210216d134c2b52e962a3b60e980337d05b003aeb7445fc68fd04e8ec5b386aabfc666c5289501bb6ab2595bfa3c6ded7918bfd5693fa3bd48077018fe12d1a1b223f838c705935b702ff9337d0a20b36b36bf9cbe0c04b56ce026456610c1424acc5f3291331f2125aadef15aeefa15dd3a4935c5b81023fa2d2d4a95c084c06d050f0545de359c2b7643704be80c117b4bbe1a415495b92f93161f3054c68fa3fcfa241eed96deff050123e21c06cde3faf9f79fcbc1e01415b6f6825b584d1a06b5312be63af104b2334f709943858cbc352904b70bcbb048e073e1f1fb79d092301cdb6c9b7fff5dec6d32ad64645f7c016aa47eb2ee35b64c7a307dc426879b4b00e1b1aa92e88d2acd3268341ef5a7db0407926a2a4b6b7f103fefc28e630909deefdce7b2186582ff31a10e39a20d40baac9db1fd0bf1a36f8df626f25827ec1cc03b40663da084f74072aef4374e3a12b0714349bbeab99c09a48929bccac4bd769696806596ec8a11e1ffadb9d0de26706733a951c501bc129358152ad5e1f13179a01c3ac21bce29dcbf8dd106ad5f30354d2ec1cf1140f9848843df9ece3776bf7a90a6e60080726e311c306ef6c401ea24012b9902731979e7fc1dab65d59dfbad08aa2a6dffeb348a999be48b4d003a4641f70039c57f970852237e040eb0dab2f39d819e1ea7332df5b5092f246b159d06e65a323afae78fbfee3f4fb58599b146194985f0ac25e09b248422162be0c1d2ee5bccfa57988fc132bce8e9c03ecfb5f126e99266030489fb2c463bce2457d59be8f3c3d9763063ba767fa81fd116706b3ecd735b2836bc7db80b87eea763d1bb322c932ec491c4bdca8efe294088bb9f5ee9ac900e12d19a1b8a463426bbc04d375f86afa5622bdeb31f65aa5aea08023ee054b529e22860e901d489ed77506104b6582889fbe3d7b441df82ab5153edb5ef37d003b2adb6a551777c4f1c5f5b2ca30eae195b736537070d9f5d67a4c8ac2eaf2fb7f2aca5604dd7716be28579143f664c5e76d7d7b6f55b26d4ef9e58fc943e4ec32bc004ad58054a7e8a17be8b61410cd43fb5b9613bfe3bd8f2935ad5eb0be34eaaed3a3217104cd29f52a2a78283f87b29e07e29a904167637960d44f711d31908720a6676aee8234e51f53b3fb09df4ba3acd8fc790d63caa0b80437ea1488956cfa43f9d228a3c406bc83c64034b0363ede4d5db5a495a7d6bc2f0f4fee04b7797d053eceaaec6f36162c82bf33385878129ec6483a1909d804b12f57a54d18c4bca50374f372e4935bc92ea829abe98d024cfd92be1052c759167860544436edeaaba5bd0f448bec06df473f230ae107e75a3c09916915a7af497f64941f76ec3a20e9c81a580d7a3cb3a997695130ba2232861623128573464884229b3261daddfad2e7832692164c0e1ee27b1b2d45b196ee5455dcd69316c0ad35be459f7538fa283a7441672343d0592aac146010308f1503241848f78ef4a43a1e7abf7e894498e62143b9c714a1ba61b4be751e123f1aa90cd41e06ac91f1b298156cd99b0ff3d6639f4af479cf3d4515c4216bb22e5a78949ced37ada76a43941d37da22d0a6f0ef126de733f25826d4fb210e88ea34f5d15a2cbfe8991b15f6fef1f11d1fc4738d615939f65aabe0688c84a094daff76ac158eb89b6997440a80fd66ecd7c5a7b3acb164268d5149b9429a4de9d22cc85dd52b5bbe0ad40bf1b0fad1f85c34f06eeb02d85f5ac5de98088c4d2c8c65c10db81346f0b69b98cce38342fb3d5d0c8f8a12b25ee16e7863bb8fba8e06aeb21ac8f3fc58eaf5841749c8733b42e4ac59291733bcdd48894c8dc90ff3394d7e8eea2bc66ec461aa26c00a854a1e5da6ee744f31381e41fba02f9acc726bc7ac805720c1ae4c6b1ff89224baaf3087963b42172ee955fe63d51cd3a8185a6bb55d591d8c807314180d9ab364529064eb8d7e6368d2e148667f69db7f2a89cbc95c8283d866be5c008ca5a4df4a6f875dcf1483da5417a32319d763d582cbe5d9d01e6a9062a618909e4ae4b14bfacd9047f82551ae012425f317f766dcda4083dc99daa3902511b8a1f7eedbdc835e52037c5a97ab11dd3e1cee158a19e17a62a59e4451e4b8aa71bff5e3ffb10f365f3c21448e69fe6e691e9734c97c03d641a4bb545c8a0dc2127349432b41391130d34238ebf1d249df420939ea370aac6aa27ea64874ca480992e4b147257e69cd22d5085c4a21df17bb0b58e91fc00131ef51f5c26df0c89111542dcbaac636cc140f74c16c514e0d3eb9d9f2e11b73881605622c360e6916685d6a73d2ee5132572e9ba793f2ab17b1709634615f0901cb0fd0e724b71347327fd0edbfbbf80da1302ace020bc7711ffc249d72d277bee8c6c08097eefa6c02546e80652b88dc93f56d61197b9a988058f935034e703344105259c5cebbcc4b140918dbf1d1a09c28af21013499a63b8213d76c939d979c8d6bb1730f6a7594bb9b3ceccc191921de41560733d9b524c540157e636b5fd80c3b60e1d4be25c04a97d2812fd093a6aecede89e75d4e341081db669add53662fc4d8fce3febeee5ebe63b881b7da2b1feb0b23ea090f47716abffcbf4d8c2fe3fc32ca4a3f9c921f63b2989574dcd4b82e5b1ea856c01f19eaece6cd6954a88bb50aaeb9b2cd878b9b85bcf1cdecdb3185b2f5e5bcfedaed79af28eaa07ba7e2c1bb92184ec854ddad360df00c90764b71e73b6b668f6e19b0df38e8c468a0f393aa6dc0af219d8c3480e8b71fb3f143c981dbb31c9a86d999b47a25bb77ab41e91047e31a6e52d8d587d3ec2bc9f730f23cd20e53b4f5786eb383026f3ea8cb3e9642ce83d87cc964c19ea700cda083be2c6c9e265355f6351c98f482af4c9c4ff8bf732173661734b723c670e998fd478f18a1aa8bbcd235cb0165a612fbf32090db82b685b80dbf6c4b09edf367de379a2b57440490a004029972195402d7bdd063ac1a0ab15cbc31d38a7d74c76ac4da6ab391de73293e59da21ca4b63ba37847d2fa2c858a544bb42cc68443fc92240b000d9600a193698a92eb515b779e9cd283613748cad29a17a451c8c44278112c98b5e48cf62c2fa30f35279edb81a4eebc670f83a6906c0a1ce757f511f157933c62077e877f628c0e3da52bfe28735eeb91d21bde324124d1123534314be0166ff3d87187ca56d2064cb221d2f673392dfa8178df8f21b725c1e20de4625858fbcee00ce4e7594a1cd3af9e34ef1edddbc1ef538429585abbe55b3e644ea8368a2e8c84fd1d624d5a6b603f2aecdc5d143012f0e640fd5f1cff3d4b13e587abb13b8e1d27a0338887d1066b2bb97a5af8bf4c2cfc9211a95e7b54ee9da61a083f814cb0524bfe19f3abcd5fc2042f5a1b1c756c0e6804a081fd8bf7305a3deb58b188eb1150ef6f388531485a3908cc246bb9bbe79e29f9a3eda11d0d15d08381d643e062a59a4f6fb17e565b09b8f6339261340916808b30ee32a4e20ab593153f6e5d7a821e183ef9d014ff354faa91cfe0259f346512bda4df03800dd18fdc2cbde7994d933be82ec58da7e44200607840cad912755975fc542412919765bc967c916cd3a76bca4cfd3d47d86678c9fa72415110fe73884d063e91772f1a366d8a1c633e19f55509ae54b808a33e1299ffb11deb5de07f7c583ca63f346aa4f9d70ad71805dd97b854d99bea211698624dbbaef3cf78ad5b0bb714332d1b7f6e1426c4fc0c8cb411ee7eca424308198c7254c57d483fe8baa1cd98ce20c2adf12667f67d9ce59ebcea55cb01c67a72f66fe50f49ece6a6188a9774b54f45be59a40ddd64da30e521f03fd13b62c266faca1e8475fe44471ef26b910a881a280bd892437e7c92b520479e32be2e3aceec2fb69815121c4dbc82b546234b941f3f5593d44b9e63be042feb929944df0b66e37217c4c3b489275104f7d2955a368ffdb0af908810724efefe8b9a03fa497b6b169b5a60f9f4426769f179cab30e41701176de8fc4594a560c3bd0ab1e1ca75a7152e95bc763bd5861307ace21ba656da6d234cec3e5bcb4b12ecb893b0cb09922c426496a085a0829c047e28eb4085e27ae74527c356ba6113821e97dabea7f9c0189d428de9a8cbf665ddffdbde3e86af96cd09fe95c7e8983f04c28b9875b1f41820a0db3d73c309cfe84f0c5d4ff775f15d4daa1cdf37197b33a888838d924626d132f18a108397700cb7e706526dd5f92e798adba88705b38279f9a0cab2c956c520c54356ff839fc7d4ee67b0f1fbe8f469ea4eff9200f27777bae3ae310b6288a72ead53401c526c1fd1a27947645844c099a3dad324bb134385f6795c6fc075ecc538ad1d06d63ba763f9471c466714c6fdffb8e3e2020dbd2da614bde8d0b698d51cea825c6f7859c66a5e6ec9a07141b39fea785f762b1d592642f07961ecde5c9ab33bcbbb3de89cde148a85b9dc47dcaf6f7cb4d6efc0629c1caf58606521d37807267af59d13d2dbce36a10b9606be3fac2d2cc18cc6cd67cb7f1e901443c94569a82853459b58dba54ad00d502fd1fe6f0807feb5c16605221fd01f620b2e9dccb986a2873df6cfbf2acb5a4f92ec6494282ef44e9ff1d4948dfd533d03b7572cd6be45aa484e825bcaeeb5aae7c5bdf2ab478e41c6d6dd596ff82090b05165fcd137deb48d416b6cde7ba489524d576a4f11c92f5fcc4bf7fe516c9d766957e9b2721e1f8a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
