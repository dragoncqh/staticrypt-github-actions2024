<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03378b527f634ff04c372bc6b61fde73ba32a13e83d2cd231c70e0fd32adebae70d6758954ed328292fcd4c9a26572975b1eadd9768f63a0aff4f8dd212b0cc685b57958a687366de78269d187bd5dbd8221f8997908cbd9ec9aeb74c9801ea01da2c06950a283489920e9d8a40e8c312e3342813d5e5d5e836cb5ed8f98a7b8c503cb126c389c0196ee93d63acd65b529eb19ee51f2ad35947d995558c84f3e7b81bd08d3b38c4683b8bbeea5c59eff0c14a8caa2bd5149105e7e3629b754c8359b5ca731c99ab4ab9a6ef77f79632f0417dca701516b87b376dc5bbac4588d9317a1030eb71c83ff7d901052d0aa71917d17f5a9031e5079883ac79b3b135d4eff0b9d6eb9681acb5b1691f0f2a769e938bbb57b42935cb66440c695f966a67be1b1d9a28c0faa8881272e48df37047bc078c8f387686a2b7063123a11e10da0774e422c9606bb625c1e60ad36c15d098711ebeade2f95197f248addf4346ea1d7e4beb4075cbf51d64cac677c022cd3319a79ee6cba22ede15406ae698764bc70c304cf039ba904992df4a78bc0e5d16878c24b0bb8a95824335c148e96804759f591755c3ad4e2d5d369c11cd0ff8b8c3b954e79b251e4b4a8b9e8a960047abf8b7ea04ed52a858cc160d0711cc707e3c55b0ea6fe93c155c1d2f9d66485b5b8fce5f6cfc2a0aad91a35168670c47c536ef6865f582c9ef8384b6a6401d47e2512a421ec7354bc9af6fcecde8bdf120cc11745f1b0741880a89a812002c839fac06d0fb93eab1917667eefad69845d7eb3199605fb4de034cc01156c5f3a8dd63b5dff142bad1732f28ba1bfeccc6c471defa47fbc33d3c782497cd978ba00c18d5140bf2926c580ecc3900f6009449e1fa1668158981c9d0785d075dac8e1aec9f758c43c4627067fe1fcb3f91fed23f3b9284de2e634294969aad1fb5c8494b360b337cf637364030256bf1c8653a98a9d86db54d2604e99e1b781779daf7ffa01993d0dc7edada4d7440e28d299ed6c9fb4c532cf45c5b792f52a8aa48c4d4d68e023aa7e668d5e78e039c1595a6067aca64a8b8e45c4a3c1129221de924af1ffc7213e14422663b0fbaa29e3cb553f268e95cbbe411d042f8c2c082676dfe7ebc3db3e30494a7a1c0d22cbcf656cc39e54b2928788b3c031a0e4965c4446bfd440f2ff4aba4b9ca302d39776f26d76b74b68cec9ffdaaaf2d1e9a41931c40c678bbdb3f257e438455e43adb2369c40d48e7ebbeb8496a18e69e79e9156d5b3f29150cf5dd455bf228640537d5aaf2dbb61e5ee383a632b0da284a35be6c30e2f46115817276b3dbbba623d6005f32f50d1e47ccc00e10737fe4e26ff4fdbb0bb5e0f9cf1be7c28edeabf5cd417141665895949775f2b933dd7bdf3e1eb47ef1e73ca64a4fc7c493ad12dbb36d8024d5b2a7a66596596f8d3316c04d854a224f44c84b90d0a722120641dd566d9925485c4a5d06dd870c47457f871e09ccfd3adc09aab709884f74b9511f71efb0d641f8788281608eae0e176084a2e95fa9ea74588b1bf6e46901a3b6b0ce203ef9f43c54f6a80e807fa6a4abe84ef15a75e48dc8f4a86e588dfa8bfc6dcc079d02afc0a7b214650e9864f9062fc05547c45b60b1edda0e624bb7524d9f2b495172867d380fa7084f3e3aace58ea54674c11ce59ce247c5851159b8659019e7489c2189cc660259beb5d6e33def3c5303ade1597203f62957b975d6349775f75da70eec83e4055aed19c4dd3073bba41f3fa96bcd3afc352b3b1b6e09a4b5e5817141891c3b4a72444f3c58a0c46b7973beb1f9412946d435b59885d848f549ab13cdc824286de1647ee74c643a988e2c4ee293b7cffc4561d13053157e028197a2de1bce89274235be7187cf737122aab546b138e05cb9b03009b600060cc098bb24192a4a145cd7a07ef202fdd0d01ebb2a99d0e10960d58aeb359978381d5386828d60ee045850a58a5a5900bc561862a8fc63637a4bd419a73d8676d8e29f01dd97cbc6bca75bf2345a8d9a91c12c2f6f0eb2b9c5ea4e421a4c8ab3ba890ad54ee69375a0a88df6e5ed9f80abda255f43a3b1d0acba9c02d316c67bc1b8d78498244947272dee9f0a8a2760382ae0281cf7dd8fc32ca3de6ce2a018de32bb79b161d4481c9af3ca86561b319e741507b31a270f9da622ea8cb3c11a796daef2f0c097251e25bbcd54fda9819e30f1c2efdb6945f1040e7fe1f9d57284f68d2ae5334319a347626880d2d7a3a9014774031129eb3a484da5406dd04289772c58801d287411e900542ae92fc08e21a89795c44ceda50a5d0e1f6d7d3f5644069c28b137d4a3e2c279c11e02d3bab1b0763fc7b4a8a956a7e5bddc21f61bb25a50e32d1432ae08a9c0c966dde3bc27f13f69f7ae42d58dc45e7a9d6a95d12998fa3e6534d7bad130a6b3c979f7d3c899b7143ad39c75538e80c90d1299f258269d37bcce9d4c8cbb3b799e4f29919d1e95c2e95c7dac3b59a44267a65f2a22886f771917e2ad2cb20d07485ee8ab4431a11bcbd0a2b3ee45c51fff12f09e575a5f94b418a82743fcbfc5a8cc38fe56693b6152454bfa311df4b08c15b2458e6834b24f11707ba05f5dbcb61e95792dfc8d9a737043ae15eebea0d04bc72d6dfba85e6155b1026f13f23c82debde7366e7f5feea3bc46001444b2761a19c615b17363acfb6bb17fe43762330b2a1321c5653b4d76d6af0b7513bc0b8493ea476d97eb4c0fd008a10ba8cde6896e12ac398c2df24b1f04bf6198af0eb079f29aab23994fc6ba0ab6ae4bb1e75ed808b10facf2949ff1bf9974d92fd4a382bc7350ccbb67927e6aa450d15b1530e908d4b63563861f1ed3c60253bc7880f5d220cdf539636033a45a795d4f2528e33d0f1becbc7dd1c3a94ec0c90d949b346dcfff7830eca689143e1f8b54d1c99582172b0c00ba793f5e8775435e3929dfb4248074ceaeccd5533eee8cefe4742a5711e1e47be22a6aa5333d0a75f5a160152941d44022454808223f9ef87a8304a153bd00be293ee6c2e5706332c6de8b19992c21286eee1a37d4765c0ccba493614daba7b4a445de7e6187b62231c0a459398af2f878083902dd9b451423c9c48db45a2601d580380a9f48c2180f2ff18ede4a018da2043e5de223c78976f976246d6c1dcf01398260f6a28b461b9bd73401083939212204d2dd0df67c25431adae4bcec6b28710d82270dfa60d6230951156d02413d2cc7a5b464ed714118b58bb494fb5400e2b941a8ae609ce4994a8f82e80f5550910ebe0bd98560e21305582d6910f6a3b48402b5c3664c37fdf7690bae48edea3ab8e3cadcd4846a9173cc0e8cabd4120ff231be011fddcdbc8798540428ba41730d91ea44d29299500afa14e1e52b4b551cce8bf64cc6e41325e904d966c8ab2a3c89d8d7aa0ff5ae1508900a99747651ca692e4e63b8c06a9522b7db5e867a63d051b5cf2da1fd13c161b9d527866a1ec4747c5d929cb4ee46dffe2b021bd571316170bdf95c334591545219d5dff071fd08cc5503576ab8b83c7fd4b2d152ccfb8ab71f3463603112898d8c6f1cb680d73a358900f29533fc84ccb2b70237a1a399f9741b1ce4c616c74efc3ae44a96638e7182c8a8dbef3986c517e19ac805af275ceb30404ed2d268b92d2103088e871e085919ae4e43a64fd88352e79a33c4c07461db74e064246fab8911974d493e23474c15b62db75ea0119bf33a6792e667026aa3f206f95d8e87e8ca8c1f5e0f16854d625a9b2ce7028a337c5714f9271904b2a674b2d3739a836c048d89d54aea3f2546d64ddd604c9bd3ac144af3f279a241e78c46f4967b2f036ce5557262cfe10c1e4162cb5f4e4cba60946674182925d5ff5cdd109d83c0fa26a9ca5f61854f8f29ab3de63fe2de531e19da62421e9b88215a6363db72f818204424aab5c021f656127c7d2299e6b1c9284877098fcfb0208bedbd407b2cbfa4668b9868f6f8d4aae91eda972818b84fd5a21ea4c7c1cd2b9104e81fc388123b05ed49d4a9360696e28b0b930296d3c0bfdbe36adaf06dcbc7bedf70a45af906a4f66cdc7e28dcee63504650beba61b1c15b3d4957efdb925a8b54082756ee695891658e5f01274864e9eb88d8251a0847206b96e29b57cca57702e59bfa34f2ecb9a41a0741bda4543f03a683a37147437731b7064ac4b6febcd54b7b683836fd047baea83165d1f6775782bc49aa76595110c75a33346208ec9be2e58800039ac9c680eae60980ff01f104f7076a1f0e7646f8bdf85464ca6fa9f6b40d42571459c196739f86e67a4e5e31847137dba28ed61213f40743d79cd434abb320bb3312aba90d3775885cc55ac3ce530dac85ce212052ccc23222e1f5c673dee62c8e8508a39ea3241c361999307453d2a797dfa1950b8bb3c0c9f42ec73b314848d34400f0d0074dad58a0fcef6ac3566d958267a954f876b96d50abe277fb1ea5c6f56ba985f2b950c00a486a4f12d8aa6532b694d1344d9b2e39caa2f6d338eec525ff7b8def691175dbdbac9dc86e42d983036ea66d49f602ce37e57a14331bbbc7552658d64114ae64a4467f7d403e781aeab8a0cad069e69d40b8f78fa057cf8b94b09c89797783b2518af91124c7d1aa33020464e1b5d2e80b3a067bf1b4315956ff842c5abb448e1f74a00905853c08a42bfc95d08a8fa84beed19121a1022019fb01ac94b30ece6f7c8dbce9e342a63499808303f227cf240513b2ab5b1b901442b1bd70d0e2268a88ef162c321ffeec7a86dc6f43a1d9aba5182aca6e389c9cbb88c4c369639bbfedd02235138fc56bc89f8e007c229b407874fa19dc4f5ba6d38c44aafd6ba183fcb4718020b20312d0005c3156181f4079acf39e5d14576598c34dd27e1b0d2c2e5f9f77179ede257cded3959a09b1a3ad4ce071a3a115605034d145d1f853af9fc1d400b51c334201e5b9725bbad10f3d658e3019e27a68c2a92d670ce13dd7dfb8dc94fdfa0eb8d7e468f35b44fb99c244ea49342459bfaf24e33f4a066c95f591c5119f61187653d123fc63be9e2c8ad68f2b75522d1c4958d01bfc6c658fb24ac9cbd6877a0e0b6d4ef920198db571bfd812ac2d46cb025ee90a9ae3fd854e86a0e1b5d27a2105d5ce34d115edd2346a732e05ba8436ee5908d6eed625c4fc74cf7e73743173ebbb6c5a408a2aec9a119ad5d534cebc1642e1c83c9cc4a77080069fec90132960bb21d9adf28c069a12b5d8bae7b43cbae5d5540953dd75ec62f5ceedd480e8f3017b5fb1c2e9e6dfbc8b18116130c34f2dcf249b0b5da57314b34e1fc79cbbc5a3323e204b360f18c944ce86d1965dc7060fcda7ed4eb6617bb366f957db1ab5eb09b2d69dfaebff9927649259a7b8b7801bd033f48f1b738170508323844c648c6f7099b7c05d19f040152277085e85540e0bbf2dcd8916a59ef8598ffe030edd548b810dad86f1da5f93d6e1021b664bc734eb4aad2caac645c769898ae9b5604073b70ff22cd6ab93ec1d62c0993766756eb91d23774c4becf616836dca348e29e977d5b658bfdbc5fca92322bfcc66e37f28a0bf595d4122dbafb378a0391865e17649631cba81d14f773e5d0fd6c5a514572a8baa5b0f3bdf162c422965b687fc7e7cd3a84206092555cec54a327235828c6ba30ef6aa1f8a0137a33ed059b36c8a254bf723e98dda3dfdf7de96982bc5777897e6e80510c774f0b976eb4184642bc79248d8b3d3ddbf8c709d8833892cf3bbf934ec476c170009013e4e2fa7f9fafbc402cde9858a529eab9d64d5948d5221ad5ac0813bbb568b6f0c4b3069038d5af1e5160c659d576604a0b99641b8192858324cfd3a0c1502d9e31e05e03c6b6cf75a6c51eaaaec394dc12cc09c83caea8c335917b9360a5f365f2083766da5367c8b48fa68ffd7b4fe988d57e99529b29c05cb7273c17a3ebaf20acf41e90faeebda33a0b2c76c1680c878b60c9be6a6441808eeb58b1c2251132bec8cc2d29a1aa53ee36ccd48b7991c201764488a7dc086c3f8f4753a32e7f2098dd3e84732f49336d5103930c1c718195f2496c29e9228d262b2a6fe144a4203df95ed2da5d4662dcb21c7761d850e5581e3c19db8de9c41accb056e3e6c3c6dd6e34ada343f89b6ac862e84f1f16d599927eb7b94bf2f9d57a566fbef4f0bdd200e1dc74fea3fd4971b2275271ee169755554996d5c5839bf4f43ca337fdb5048ff8e78feffe588f5efcbf9ef23049bc89a6a9f5385bc5c68b535bf0f0a84bc94223f1d8dacb8138918bd0de362bc17eb514531b323b1e05fa845684c4c0cf6d2d248b4f057f1eed2862145555ca48a5c00ff588786d262ef654ed179d31a2c3c9a6cd25ee21fdc060d26ba32a085753efe4e1c8464135b8b3bdc5457fa26646654357813c79715f4ccbee65e8939fd4b42a8ff34288c3d656143f5cf0d179a738180efeaf72b7974870d7c234acab89fcfb56b5f63f929b4e148dbf11878805f0f13547e55e9079d92c6e162582854186aacc54b18115e1512cab0449a840c326bae5737e6163f79c8632b716a3103dd2258838c18b2586fa0c5ae6c073fed5fdb65dde1f2eec80c7df2a1e4e255b11adec9b73d14eabe7bef091789743ca2c0170ba2375bba4f652239da4eee1db7beb7c1fc6a4ffa6067cd87fa5613bb914554e3d0bf10e2033b9f0a55782a8f6e7d7881412ca11905269e5c7cbfe601eebb6d7c14906c84adcd593217b9e41be6e64133aca8c928903019e6813eaf13d77d448fafb7c62c0b2fd8bb4f5d0c8d476a3e2f39f0b6ecb7043b8fa8e72bee5d0d2cf90f89d875a02b7d7a80d80752f93824b26d6aca9e4b9862a4387c9e9394f49c00ae526d7b750a6e15ad33ef2753231d1906141d9f24ac736668560b49c64bd98e172f161a864b72a258cf033187f43b5e3979e4e85aa20fcf3aef6a2f6bf07ff35b096ae2a80bff9968bcc613b33d71dc3cc67a5139569ffe3f0fc7dcd4e09cea09d5efd9ec4105bfaf268beeab001c67bd4916f91be8e968ecf348054c28731eb093bf436fe29179807ea93d0edb21d24cabdfc949bccbb070ca04b32cb967c697066986f54a7b0b5a36a65e4631fa2507860b699764f66be12539cf09e12b0b50a6336cee61d56eebab51b8dd0d0d573260cc3cf02c4006fa838508f1c3d51744493a2aa5c804a96dff87ca2fe0d6ae6e2df37440bdefadb331384a1dfa58cda33ff4e7582cdbfafd53584b2260728e2eb592f5bdac1ae5bc3320dddc931a0e3c532dfdeafa7ae9660d4344d80cce7d26afc6d7ba4aaf0b7b0b328485b370476950706e41e1a832a6950797eb01437c65eee633423863819993d390b8af77a0e36ef7d9dd6bd20536c7d68cf2b3e338add69577920c56ecc7ecb99450ea62addeec001f893f8f304dddd54bc0d1b4bf3d58045aad2b7836a5fc684bf9b00e1f5014244ef12e88fda4a874862c0184f34589b10a07411c8f722e23942efd382ca4852bd0bf13c48e776760744b27d761c86eecca977f61067fffa8451655273b5d07ce51b9f61f0011cdd9c576e64fed2021e31f855cd65d002c417b362e77da00afe3ec8526d5bb202d48ae5b53da0110be5acd173529a8645d4fd22b964d125b60eecca14231f35459d9c2a1a9bd466ceba6bc0f8b8bd41bbb95bbdae71eb58719ffdd2fd961507399e2c15cd83c2e89e28caa2d8dd0edadbf1eb4ffac2954dc2ee5352fd054042c4f6e1cd8e4c8ad88cffaf3a2d83ea8c32ea27b68a452bbec817c2da6476804c15e568e624cf55cb19ddbeb9d09f015da02c8f2f72e1d2be3b2e83662a22996de0559d7e433a0012c32f8b35a3f93bafb75cfd78d1c91cabe89c43f9a40e05383527c1f5eb4c86e813e9fa29c3348788eb64adb728c1f7cd1ef016a1bd7d418892c378bac6481d381f65ce97851588cbcebcf8207d75e8499d086ecca04f4ba05fb3a6ebd8c92536df5135ec26aa2ab0ca830378287643e7a17f7f0d17f91be0f94e67faa83c46b2cbe0891dffb729243ec5ccd1d45bedacbf5a8ca8381bd2ef283f470bb4b9c232b86092f366db259e90dec77de51a764b9784e68c51e88ff798e3aa3a7fc15c8e9404c47ab4a2f558fa4afd0d5261065ce0b0b9b5962f7c634d7317a9167b6d91ea957a33cf9e1f85c891ed405265ae3f32be93f1914fe69a6c486238c7ff6efe0cd17d2bc5a16cb26a744eecd0a4c35cf00588978a286205b00e656b09d9b58229c85b3b1310655673d6ff43897d1590057021c2ef83f5f2da472aac62def356a2f93b16457d59a9aa5c225cfc8347f9fcf74399cd6966d883bc209c5d1cb9a8abebfe13d65aa8b2b88b90d1b7a4e202682d34f6b78305a6f5496093437fd36a7651608c3dda0aef34799ad60c7204655fbe12c3319b729359a8950ead1c660eadc10fbf11f6c2a779922345e734efb774102c3b756b984ea55583e5d7923ae6ac997ae80c86113d65259a42f98407d2f5fbfaedbbd1387b3050e7db402300ffeb13a73a6d2d309298ad958e877cffd79a38d537ad078807a74163a48573cf1f7115b3d198ad323ff9ffdab8e67e4b8ce9c353c4ef30304b0ac06c5632a1a01f6068c88bb8a012645fdad6cb0852651ac22385d3009cff155ba4496ac3a1b31bcdf00ad49bc841f132aad4ed64bc88731782285f79479a924ef4032918942fe1a60d4d29f18bec815045ec380753915a740c20067c8c40986504410377fa3ed0c67dfd8266ed0119047590a599c687d6ebd4c12882a19498a31ec5c7fa02cc548076d6543b73d4598ed5568766ce94fb21dbfb670f05298356cbdc2998cf246b1e4349bd1574955d2fd7ee986fa3c29633171f07e3b6aaf0ed79bec8c8860255b811d1d40792cb95aaf77ef5bb53f8a01b62655573e3ca8b3b1019afa2f82bdb64d4cd10f60429dfbd287077ff4f6c172cd4e33f7bf94e63570f4a41b4d68ecfb444ea6457ec71f90fe1f7ebd21502bef37da3a255463b2a7b01adaf9a6665244cf7eb2265659204bb394ebdc21ad293a910f1e9a17cf28c1fd51172321e72f7fdccd3f50b0d88ae80a033e391b470046e10e27dfcc552ec4e080b907d90d39fbe8b22e48e953e2e4989651404cd8a7eea4de8a680ff151b84bca4db52ba3dcc7a5bf2808a548a71914bfaf1327adfdffa5e756b9280218672d9ae1da7f5268920876bf1fa461f75e892530c47e9fcbb9b2ef21b94c935ac01bf9befa93ed32d4f48b501b801b00c7561db83b7d7860ce36eb06fdc508e0a952ebc448f58b4b63cccee057331ccba1fa692f1aa7fe35d7229d2d5bb3dbdf851e75354a0e1447b636f1d22545ec18cb3f4e88eabc19b13e09a34b52a3c59251e6b12e3412ecc540235a47d834a579ca3563d588a0ebfada22e737718ba3e61677a56da4b209c12b5868be1717ac26689b4c75f9ef665aca0b6c563c8fb8d25932ad7faba18fb790c7cfb3f62e5ab6a18931683ab119738d84338082214264beb493ea7058dad83c6f4bdaaca8b4e021e994e8345bbdefb207be2007fdcdfbf2cb72c5ece7d241dacbd6ec49ebe982ea78e2b76439ff72c1851b1cb7f15ce98bd5dcc1a39f2c17a03ef50385dd0961d1cc39d457bfd0e17c2a976ed144b7dd9983787efc2b7a86eac0a03b5fcbadb2b29d874b5aba84d20a39bf6456766ae1b316a569f6ec8647d9db775b6beac6b8fd6ed1ac36e7177bfd778b938a2d5c66777166698abcd3c1ede895aa3e8738f5c0f481f0eac88aabcc613c2d2358804691dcd3e03fe0df2ac76a188012ff4b1f5614bf528c3e485ac74adf496ba7a7cde3d723410d2e9937f632bf697c92bc41829e52b5a186cffac053183118d8f0ffe39f15c23eb43104edbd2465110503b9f99c7f1b8240f4849a7e8ff9553d9b073308d42a60d5d1736ef7955227f1257e700a54cedbecf6fd16fc42736fa92ea2f00d5b7cc81f42521b089366863b7895bd7ab410628e6ff484c745c0ddd763755fa02041d63bf26331f5e18554a1e6de03d180d883fce64cc4662c233a5dcc59233e31c38dc474e2181961be5df0e44f6b4eca1f0fd1caec35c3b01613ccc4fd209328ec3bb9aaedd3a9fd085928a14f99fa659f1c5a282c078bb40f6c7105e288fa94fbafd0121dc530fab5c0a5a5d17dbad16f5da595f3804848558c41ff809ab8d95ae5702312237e2c3f19a8396047e754c490eb22fd9db254ccd85551091310707ec2a12322372f1b57532d06573d1c830b8780151d0f3f54bc5ad770d8d73a7ccd7a37c19e59ca9ec43f4d76ccf70fbb0ba172e759b06bcd5495a1f47942a5f63d092b63d4924035ce23d36c2a746bc81242f146eb46b550ce30269efe4cea464146282b64d120db6a742c04df76d0a69aa972134c545b8a295281f735b96531363c9611c7202968324cda790da0c039d4570dd62c57f42681203302535654a3abab51d720982a4c371261b6b557f35ebd080fbcdea0e16955695994283d476b0d310252d4fc047188fb6065fa000eb3397e3829d06e7ee7f0e107686541f14978c02a46dc3cda7e28c34adc81879436ce761f620ebcb3b97916e8e6d50e859dde82c41fba96425de1348b0aba9c83c1a033d6377ae2b8d31c690e56e32efab59c7d5026b901d3d943d7405f464a437f0356f7a8da74ae7a08741991ff4ae1155384d605b47e30b69dd546f3c91d65df62465b0ef54a6789e62db82292e7a84191def43d7a9dc8d4be656a062af05e0a3696079e9105ea4f99ef653d43067c11505c1ce28c049440d4de3606b9eec4d556e2bfad8df38d1e170d84dffc1f42e3b3f31e72ef86754cbdaaecb5d29bc99745e27022786bc4650d9c1cf4ffc39a1a13cc84dcd11f3bed72b2d72701db00a36ad994cca27458a57aac15c4791dc55057fb4af8193163e24070909f23bb62ff5bf48b4bbde223f8f4a20b22bd80f34cb717ee3dcdd5da2057715633015674947b248d1fc88ec5f4d47fa16ab2084c7834a5d2f93a1853593fef53a1b51f79a4e5a6557d922f5edc2d330153c7c8957cf5a8a0854aecbe12e36cca4e7a50ed396598cd183b0fab86073e8479e57279bdd8ef538609e16b36c733367c75bda0673b73c5e6c5f8cf0253e9e3117ef451871e0f5f18285e80637657938070fc9e628cede6c864c8aca2d5106afb1e0b834b4b5a88ef99787fa081bcc84ac98bedf6f389046619a42ce831393d8d55b8960eb486c404ae6edf3def826644634c4f3de4ff82007bd693b669f15ab686d621723702b28a385d4557030c2f58e1113af83506b640edb2fed37bb6a4615c6f80f5309881d07499f0c9e30f5c4e511c212dc141f1c0ba2a0bc50fd6649f2858db34b97312fc0feb849a809b5e91b77c302d3c1c9ab2b868518140b81f44013e1a781ebc10456261f97829578834674d5fa155b00c7c89b6012e18e513e6b285676a37225fe9da564ec5982d009252695209748d88ecbce46e49df0de7a747b138e3f30ad2fe4c740bee4b207e322da93cd30ce50dd42e05db29223bb98baeb33973e10492787d94b3f87af822c9c64195da6fe5b80a6d828ce1e73b517ee545ce35947462647da536841b47414938138f63dbdf13c8c514139d1385d0d3f2f11132770ff123e53f7b116e3336132f23c199d4136b06a395b6f2dcfd83ed45a8dfaf074465559a80823408c671560af654fcebf6080bfe859281aac544a045db6b09bfac8930b9081c543ace9ad464f58faad8a60c44876c3d1761c0674f684c5c3d1f7eac23be61224c77dd81b2e17c2bdd3aa8e8872abceb6969754be351c296c03e17d39b7250863794c2b9350209f0fa8d2d5dd12450382331c246ee95a34c05cb6804ef0051101c255947d13944f55863b0408e3ff3b288ae62e762be1227430dc4634e0f71788b277e4fca39478dd48e04441e50cf7383e9fdd6069b2764be21286fc6366ca1078ad1c1074fa04647eaf2a449748a70e968e8a4929ecd3b6d177dd5195ad14920dbd48a7a147228e6f5e2639a9b031db21818c21c37e4e2bfb06b44de507d73c1b575c6ab6c26521ed4e2b331801a9b52dc0b1c074d282ad314873fe3fb25b6b59f3ae345ecaf5911673879c095b89eab653747551c2864bcb4e1c93fd9f714e45f4905eeae7d89b862b919ae7b245fba7da04348adda3c3dd7a2799ba72e8aa8e773fc219af6d576b04ec6bd4e47e78c8711776a9544696a631f17638e5def1193aa12d49e0a93cc50bbb80629264c77786b02c3191fc63362fc1f6ff3b7cfb2a9d86ab1eb08ee98903f508d496dab00df44ec28e8c86fd12813bdd292e58f6d26e500fa3356520299888eff83a59b88f71cc793df49dda9ecd9b5216a37d0c737ce5825e7a19d644fd538727167034ddfa8b4a4c36dd0d12fe2c1b1951d147e62b78bb779ad72cca9f034dbdcba844f3d1d1d5554e66603e57c9bc0a6c3b55d7be24c62c8ee3f065d15e43da63e12cd97142ca2e888c4ce7726073882f3e9c6670b81cb92c5f04c2082845bb60c3eb0ff7d3fb6c42671d5fb6abbfbdd4bba1f90de29dcfa2144cdabf6fc9bb738d6d7d1e9eb59309d100b753798ad241249d396175d5cef0ec72af26182bc20b2ae7fdf4776c2be685e4f687f0ef31747982ae46249f2fefb0c3dc89bc2265da2e6ac2021f808d77a562a517b9bf5eb6e5918fba9285f1697d4e3f12d9dfe72bc5f053663c43a224a0debb84fe9c8095c55c1737fc2442b5304f8a2ff921b843fb6117f9d452c13e1b3dcc556f93001e66146a188797473094e0ac815c6b76ad100fd71ade5a0c592c6dd773e1b0261512f1e7038d853fc95a20c5b3625e04787fa99ec40a8f8ab482bf529bdca2dcc1ea4c1422e2e2fc33a4ac0c995f5772f38d8f3e1de2ded1fcd410383a0dd1940043f2669447b0bb935ae2f13773e85d68ad18b64009f308cb0fd24b0dd1e5f210f6f198db2a00012c7635745c35360f40c49fccc7061519d4aedd2de907eb780f92794dd6c31e098e45f48ca7da4e4ef703307e74743afd320125b1b3e0c97da4acae1a43b8ac221de7bd4185a4fea33fd66b88febba9204ed34179a4d5285de8c723f14e567362cf667314aa0ae3d583e375855634cb0f0796242c2aabbf81c12b9b284d6e60355b571bc168b49838c32e40c078553cae947ed2bb55709faf850d3fd6fb4161b04fe9445b4c798c5e17f3d38f41f5150b2c5cab7933d178a5ac1c844b05abcec0e8f7827601f1e0275becae46813aaa1ee405977ae536bf29e34c73f23b9b50ab170727cce9245e8a4255db8dfd76c9b94732151a751df11c7103d1fb0046126e63fd5f21e0df783f2596ee64da0eb190e670d0b4ebbe6daeff6746ebbbbd360f748cfdfc0cbaed7a7c6300fd913addd4e8b5fac2ad0047cd7a7fc7a38df6ee264be6cff5c9f1bc2a08515643de2580bbfe0a7d03f1173b5314e3c584fe48d1fff3a55fdddbce927712752f3e90106fa2e3e353477187f851539f1db8eae6f6958d0a92c5bef375071c8d87dd5acf8bf785cd3e0a68c90aed8aa4bba9804fe0bdff361d75435651f28b314d30ca036259456ced0707d4d666daa135608babe54e7c99d12bae5f33034d6999ad74f4f7e729559acd972b3023f14dd6daf6a7b2421222c7052b62986b7cada4ab6afab1c6f9eed527d33c0373c76fb8a1b8de14152f222abe08cc39dca5e3079244a9ec2856593d4b25903015529abe0d8a648782ecedd52823077a00dc04e155e8fee385f60b2b6831f84d2accfdcc881159310d2dcf3f09229093e7f9e259630c199bf8e7dc651a90d38c8247cbe87ac387f083ee88fb0eb68746f6cb8339bf9c2cdb38632a08aa490f6ac936713c9cad04f8630c6dd45094a0d9b1c26562aac5b1607f1247a223595141f46ed2cf763a7f1367ff741c0ce0ab8f92c6032a934eb49e344ad4499833d7bce05492633e62a7efd331b561fb7cbbd150ceb7c6ff2895205854f7d0e8c103f6bdddeab4b720b60717cb510880a76816e1328881a5bf4f2de322109ea53b18c985896a08413e8d5b450550b24128c75ca75ac92e32d46aac2d7131a4b6c4c4b789f34d70197c292e3ebfdacf98afedcc181aec8e12df30ea1c79a251554220155bbc06b55a98c9a9fa0ad468707b14ab90171a27e9d4adf96013073d67adbff68e7c1d361ba648108dda198a5474585cc6ce3ae48062d30244221b6eab21e7056d2e70b988d574b9e81ee89eebb04b516cf16b45332ec472b43358ec5d4de9220e4a1ad0311a66c6d7e86ddcfe2bf170d80a906589723598e75afd29f3f4cece85a859bdf1ca7ef5a87ecc8c846dc13af02492ef083e77b1b94037159b2a2536feb7f21ca511235047d571eaaaf9dfbdd35e8576e70f76201ac096e4d815ef99f6615f3ba787dc10ff7b92f1c49a52e074eb681554d49ce27af8816395b6803a75bea95331ac37fa2e749d2b8fffabd0bb056c12c066c4cff2dc070ab79df547cfea5cb4f8650e596b8644fe1949c433254a5f7e1897bcf0684612b721408ade5f50ca545514343fc9a4d1f8d8c3a7115c1d6e3d0a1073efa825a89172504f7b7663ca49dfdd12b28277fc783246e0aac6d28712c41e27c652a4bd3dedb7737df85063599784cccd1dee9760c91e40cb04dc0330bc5357292014ac38adcf45efd79308b343a6dbdb091b3fa1e868437dcff35963a479ef2ad6281466c99a85b28d54c9fcd3910bd14e2170fa7971229f1e6c42092a7cca7442c773eac76538ac3dfaef4d8d64e2562268980a6fb69cbddb91ee7f943d2b6c305137dd29ebdd13b3fc88af1b5e02e8acc745b1de24678bc5be638ac1902eaa7e872277f9c4c5f9e258c766f53b90e9c76a9e30b08ac76e819479374289d97ca879a28060d227c5b45f861bfd6af6a6b2a1c29ddac8c0a7e7b009146f56921912f2f83cc3e3dc57b1136d54274a89fee373595fe9948834fc6f94ff0ebe5d5291b6274bd49762b7fb212f6a561615762697bc5c61e897166ce764b320d071a9cae11929999e0fda3ab483eec29e414b8909f17b15e0a3ae21f56432ece4351ce4fb7a031abd308e50a68e0531806ea607a0445c6c9145e6fe746b6bb8359ffc9d16601e99b546ad22669ef38679abe7ca422eac6f1e20998adaf35159e2c2bdafefc3f7ff981c55fbd7000d2fdcb523b1cb36f86bcbb7048ebacbc7fa26156878e0b9af0158dc903c48a9c3b6d8a76c0d3af2067c3c61285bd902dc1ace9b543fcbc3c9bca41656acc7c6d9fd3bc3aaac960a2fe0768ca30ecc0546ccb10267905664dc17965b71c5b8e6d2207b73d851a2fce880b5765ca8f18552fb4cb1bddbd3c96b1aa359ab7c660ddaef4f0703391e84016edb9d332f6069b283439f08721639326ea5424f18850b9a81872130494510e828e775bef9e9cd9bf2d05f7c3d6d210138f57cbff515b2d6e8848ead6c5bfa38954213a6f8d7bc1643997429b0b364ac9b3b866b912f400874635eb6b893b50e7707d3bc52b588f881eab923b92235686061acf7fd50daae05ae235f77b26e34051a746c182436b854880b46a18be3e6f69d3ee1acde82cbe317c3acaec2ac8c371d37f7458bc040b6e058cd75b09b92c16cb29524c0e057389791fa0569928b7e907a97d1c76e556a1b5c12f5c7a1e44a3df935779d8a11f638ee3a1c436b0f9d756316db87571e4aa96d2d5eb51d856ee7ec3eff1ac64e68836bef5968af41600a6b4ac3730ce7c7cf305443f5e22924ad8bd4e4670705469341c91ce3f1f41f0f3e0acb2de730a17abc8cf1cfc1e523ab3cb9b4709ddf27881c7bbc12fdab858de5f04bf8130d7c481e5bfcdef0811fdeb15820b28c92e8b6f7222790afdc71c0f089feeea5699540adda5106faac4099bedc533b9a4838a30b27e43bfcb4782d0e2a3cafa7ece5234a1f38e4d611a78d55b0c4bb239e9dda13dcb7e9cc4661d20b059eff28b78cfe4fa5fe1bc5bd58c3a4f35789370a83746e1053d9ee7bac2a81f52326b924a88ec9bcb4c32ed409f2c2e22312b092fbd646d20a5884776b84a4998db8bb0399c8ad6677b9ab1808175d1bb2d7a06c5d1f267f774a6cc06d31eac9882102663c5c04a3e1f094197a677049c49a989eda4d9f12da22666036c772aa022ebe4789c48edcd1a1c3a7f8d48a22bbea831e9b08592d349062a4b57271a74920f3ccbfcfbe2a05ecf1d7ef5b35a8e1ab48ed49dc9a70752ffacbb2255cb80bd568d33929745510f2232c7dfe5d112513aa16aeb1e742fa917fc3a686d4aa0d364f42d24ab81ed951aaa51cee3e50f0cd4335be165c389fa5ce6ad95cd070c782a07cb0e63644742bc44af5e90f5283411accf9e8c67f7ff66a03be257d8fb440f61f011e1acad230e6280dd15da102d62f3809f5ef9087f293ea457f3c8d3fe5907f2cf18cc67ee987bf11e9ee52f40c5fe1f2863e320d1b98ab06d6a1ef9b870a37ac5597bbee4318f58f4a6ea5d8651c06eac872be6363f06c00335d9d626fda530be640a1b39ba41059aa32922436a2051720d989527b35d7fe64f6699e29f4de475a875cff1788f5d62c6b5a84c242981f16d1cceeccd25cc1e1d8adddaf1d5d509fa93df6a214db65478d506f3b21f9c2ca31194fbba9d42c702d4b8636c5c71da152c37511891996d81d3275cc5225badb9765c0177d62e55c6a3bece9b5d96d476f6729fb67bf19dd5ced05746d9824d91840a9a54a35a56e103e7c01fa894defc9ae6b98a3bf0b2f7c1a181880c1c10d59b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
