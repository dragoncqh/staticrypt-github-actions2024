<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78418cce0e556e2e22afb597bd1d7c19b71a8d882e2a12ccd785df46e603f2879ccbb593d1f21525d547fd807c7b4645535f7dafef4b7d3d46a8b532227f34879b370450178ae9a6325e3579e19b4db9fa82cdbe90c6568ad7494f75ca925c8ea7c6f00a3a38ef6cea50a354ebd619f81a3318efb6420f47e39ac99156bfc1c2acccfcc372e868ad5087bee40f4e208b338f8972d80f573b4a19821abfeb33f69e9b884e78b718ebbe30a6f80bab271f44e16dcb478c8ac8566eab178db52af2fc2ade1be6ca003e458ab1237e99469d19aaa67dd3b4853d63afc75e3a2fdacb9a98b9ed6629edf4703a88cef5a493d1c6f7ec33103cde7b9aaea72536ac443d49df1c9fe8b6adfaea5483bc51aa0503e4f46d80fdd7367730b3b6c0e193b68dc2fffaf9cc1ee75399a71b0b0ceb4e0d28321669e951b63aa25bf7094cb98a4d2eb0b9ca5af9b45d196db6e2ee03697df887993bb1e3d3ccddc72fbb05c69b1e1073eceb2e351a66dd0ae660e270d56deeabef4c0fa7ed46fbf13034f0917793d4c8345cdf8202abf4c967f251ad594858aa4087c00ef3cc304f045cca71aef55aa986091ec79ef18b60e8be162a012595d4a1daaf8ed4f500c0cb4142ad969b60cf7bb51be36eb9af86b8d4617aa1d7ca0d62de92d3a1c4a3b02db1a22a8b478aafd8735b77504dafa5b9bd94a474fcb2d2ad3513de88a2a1ac400c79b61466b41712cfed64a271ea034258e6d4196729a9cbb455adaee6c73645366fe2cc48230b078c152227acfafa66bcdbcdb90832b68bfb7e13a59413f63ca7d2ac790e2ea973cbee692153f40f3a2178cd7884b488dfdd48985edb5b728c0baaac2feb4d453bc1b469ea0b84a4b391438cd22e2b985c7c943f7ccb62e6fe794ca5ac4e26f2d01bbdebedc76e3020c903583efdab501570aed27fd0c25dc2c996106944948f505920033b8e571620361872a294c926f890745836564daee647021771b3d42cefa19ddbce066248b9cf677fa6991e2ba396e1700f17b8fe1031153707ccf96e2ab9d1dc41f5779ee0179f4d7ea0e5384e403766631e6ea2bae935fd64fc604e5d2e8465c23749f342f7ae19a7aeb640d9f341b81323f3303e65707e44c0d7ecbf7c04bb61c1810d79a40df8ae5cac7aeb9964a6873e3582ebb6463b7ce07ee3d88d1388b95126726768be5e6671f844c222ca26d4ab397b627176193895ede2c4fe74167c918761c527fbc205295c964066ab489710dd17940fe1b1c40bd75213f42e7a2b4f84a8299e0e606d5c9411e27e2a3d1f5411efd1cb0e3a3d08ee27690f22ca6a6cef1627e73246bad56cd39a0ef304e05d43ad41d460f5e765850be20e292d7696d277c24b7df30897e5f9e87fb5e23a9d15fd2e125b6f4f27fbadaa35f26db6eeb6eb2783269ca60c0d76c783ecb600159a79f625616f87d6676507a725077677fd7eeaa05ac37a82375f5469e6e76e41215c19c54040fada0af201037944b464541d7ba250cc5041f5a8b62f090cc679c506cfcfeb4374bac71dc555ea4fa7e43e5c4f94602b99e936fdcb075ec1377993d0f4c964a9c771a85eb29dd33228345c58031f5bf28a586654372037c33d080e8d1152637e787ca7e30ed4dfa51be0f7fbc87f9001f8645901093b78fe3f282b27c2432c7305f763adc807f7bf3c24875729a943f7eaf995707c75d38cf27062afdedb4c350f225abce4b2b78ea413076e443484746a423f475527e167041980e6a3133a8f536e586ad1e0e805149d62f5c270be74ac2536567d6bbd3d5f9bce0e40c06ef1a15e597dd4cae9e14b951995d335c8ca1cf0ff89891e997a6253e1c5fb310f186a21c503cf60eff07132614a2733c8f55e07a1c9e081b1bb719a60659e2efa4b400296e97b988df5c0ba5e511b30be86488b7b9fabf5ea8780fe1b9b25aca208d79f7650546160f86de73b25353096a7472a17fd0b1d52f571dff70216fa8ef9f5a3feb7528f7c4a759262d533ff571ff103ac49b3bd77e0a46fb10a3d4e04a1180990c6e24f5064fddb971633e28bb2967a2824ce3fbefde1b15a63eeb64f2dd4a72b768199a058eb9f70fc9be52c2db8e437d0b5cb877cc52dc0871988eb1827ea9b8a8c0a0d948eac9dbcc1cdb083d68a4fb4b9b83922869c2d59896428a18c42efd8d59521ddd6454a0afdc6b35a64f3a1302658dab59c71e594d9e5912ce67c9d3e4922e91d69ff97a264aecd090fa2b1426d27c16af727d6f43772e1567d62b3f759c60b5ab23c2e469b62c59ccb0cf72fbb42e8ec10c6ddaf59b37b771179a3f5665a2a9c452f840b21541f5d6bcb4c1866c18a2a69fc0f84f80177374ce7c1d0406f9ec7f2ef6457a8036419f3ee04f88df152f42409537fdb705bf580043b07377f41822c78baa800698da954fd90932793d31e5ff08de34a0803dceb7765ca1b5795ea0139296741c8ad39ea1a808ece4d182857e8e5f4712d8dc16d63eb21aababa21ad7167468be5418c2cf902dd28588448f1783dc5e30a36b02ef40273b3b56bfe2908459fc6e15d2efcb94228f965948588aa60783173593af245516e44105a49ba01e316fb28971d5652ceb5509d0361527b50b1729d9c6147a0f90ef5f7d3f5a11c91956df05fde352c265c0879a0c81e32f1688a46ce79b5c0a6f7a110b8593e3317ca1005f150ad7e700c4cce7e70d7575c9c9695ebd8dfa73882fc059faa913e498d78cdc486f5bdc4faaf9c50026f93a6cf88fcfe7fd5c675d59adc3b5ad19c813139efdacf7bc7bea480086d363a64428b7d10c82d33e2cfa688f49c48ac72e2609116c7e216c45cd14d8998dd6b5477fd8a09375fa141100e859256276641ef28d3af9f8adb440e599f209bfe85c25bacd785a8d5d16de18de6be82428c68eaa268112aa06134d8d0955647c3866b6b56194a1e4c06bb63ca9a263d994b36f376405e3d9a0127a38811df5b1a61af5c738f490a7cc30cd5a253adf1b1845fa8b51be5c29d9a225939ade69272fdf37b3e81f608f0443f914d5cda73fb201bcd44fa75fa113406feb25e1178bbefd5d5f19410cf7ba59aa0f93465cb3dbc67123bde7bc89c7b649a55a1f3e7beb1c5349d436e5833a2dc016ca88fda036b9929de5b3ba802576f7abe1c91213f81914031dbd91d0f64509ee72d84c522af5fd4d84c3e4bb931b20d4f3c138dc53067ead611fa595f3cf0cace5482b2f792ce68989059c14f1b0aeee74e969bac7cd8f069b2fb51c68f37143226472df96facd556c4ce067588aefa840b8dbba8ba93febbc5cc8adae125f7a2bb2a7805f30eefe86cb8dd2f5498cc179d64fec9d52bb72d704d3fec292aa4f1c83503ad77c576325b3068fb7309479b81d63cef954c27c2db7f086071bb93e855b0efdb4026ba67348cf48bdf851c15d6bacbddcfe51415870aa0f9c045c6b206949c4e76a80cb434fd104f5f285ad7115eddb3980f61d0cbc960df1049c2ef669470aefd9209db4bbfed5e872430ca10d3c20481e6d4edd634e919d64dc470a74058afe227bad1657b374d83d4ff55b3429cf73aede0afbc69009e5b8a10209fb495d6ae00176ca1edc457a877db860f34cf03108ef2c2f3eda884e4a464569e74507440fb65460802f39e751d9ab770f07f29d0bf03e4757b47d89f326025bd9059fc9cf1b895052c865085b66e2472d4d33206c8377a1e78078fa3c10baf803144bd6b6ff1a251e6115c21b7749986bc6cda48f0d1892bde9070967c579d0c33fc3b690c7e3c853198e51ac798747622814b2646c537d6dff2697ef03ead208a7f3b6197d9d94b810d4766c940f85875bba174b8891ceead4c694db7b80a7b8702dbb154dd0d5bf1c385e25aa7f0a4b05c72de26366322c4104ed756d6e363b3c56264ce65ebc6a27ceabcd1b0e2f692925967eecc6bfcc28ee7dda11c298dcf33980f6264fb367264c2ff55e4f40f862dfcad36ba31c62530c46d7736b31f708c508e07aa9362774e1660252c36cfdfd5b0e255290b1c37e7690091d1e05523c9e7e6a1e240f0649125d08cbc129cfe22bc4185c5ed83adde051dbbeb82ba898952f1785e6c624d1d350442bbb67941342071af771b1cb2775d5d7ddf319578f6dfd8905785ba71c233cb8a7eb1dd4837426982389e14ecbfbb9b498ef56cc2a60ddcfd38c12fd9bd5c0f931eba9170a5cab6d9bbbba328286bed4c0ac9a4b025d4e8aabe8eef29262c46d331307d23b458aa93726cfb5273801cb828f18cf0c01805bd85b5e2517e8eb60c5e146f9ab775f73fecfec285da0ba0c67180d38cb1ae8f4d3a580b4397d3dbcf42a6807c8e24b901877c3cf2b8dd3c704ccac3f81e976a936c9f0b047f175f6e8f5b842b33acb229f1f0edb1e7e6602d4bae907e7c0659bcee399915ad4d76d7910fd96143214ef967dcef021b645cd5398248249149f5bb5f38ef5519706ae597f27059d87454a17927e92a231fcd24ab30c97de13f6e098417901223e6fb3b18a759f826bf94fa680bfcef829b8c521ec87b160962d7de44321765882f92f804af900317640b11f86970fd03445d41680700b870926fe7b243d785dbd3ce13b04296a69dafc7b5eea21f676d9d051b19171eda5d1cdb765e6ac8e084a31e5db42a3892827cccbdaee249e4f0ed32b744480426608354c5d8f5b373c2e474ae95233811a8f1df429d0bca0d5b5a9e4f769be7a7527f5fe4ad6df3ac79670a901609664cfed3ec3c95300c118a852fa415432515ad610774cd4d1b94fe1f8be02fb37f7b0760d60f0511da2e0164224d84ad557e22152a48001bc2d989f96ec54864b3a5929046cf08169dc537db22a75a51de5f3e329b20a42bcbc9e7146d243ef6640dc499c54059307ac3789733b3554dfd645c8b6ea7ed68edf03451793786b116fac7855824a51efc58cc662f56a589f6315a9c7aa5b53e75a92adde026d07f0749f9e0d73ab618db1297eefb8faeb524b4114894999f2628bd1c12ddddae2d98518c175819ab1ae3c4e561fdb5af74d9db83a1a531ecef8a48c6c39cf735f4e5cc19c36a2f3d99abfae5e6e660fca2cfd75fa50820a4522d4e323b911d29c93109ec5761499e51f2638dcb799c9ac209de1ab6fcbd7947e0b0b3b9aa685de6daeeaf595b53c6fef0ed170da91e3242100d1b7642bc5adfe46d61818c95089f0029f235609d6785ce314addbad0819c3a9383c5687f348c7a71c9940b1cdbad567ba63be050b638993f7322c5c7dd65af364d38baebd8e95eea6dfdd0703fa7fbbb684af8745a7a8c5691a311215d674a1301c7987a931031c7ad1f5d58d1db1f3ca78bc2b2bd77b95b18633b29a6ac5d88f026bdd549f747471d4bbbb3dd1b1261bae68b11883775e9b07f885cd1982087d0061b2cded8ab978998b4a4b196833067af38c055cc04b4cb7a5b893d069eedaeff71978af40fdaceab409a1d356ed37204cf154d6114ca082740a13fb5088d0a1a7fa46fccde98e5ecf9277c5f916cb3fe8f193c7fd1a8a5d8974851e9fc63cc39b0216cb34b340e2243f438f07358a68032d839dd1a32cf898fe117be8bce2fac3addc78ca1170176eef476f0783a939451c9ca871939ae18572363d83924564c373b731d14bd92380785bdd20e7aafa58c214f32a92d03c8402a57ba623e3bdedd12916ecb415b1612b4cd3792a3abde252abc6e84d8e23ca669f830ba0e25ae469bc047ff22100cba7cddd30f5d371658c50664843d7470dc313948c9b52dc15b170cc2cb43b0ce826163cd9308cf004014edc4c04ef32248fc4061829974f055a359f3c201e5270a698c922b15d39b0837837503e9be9f045af1ebc8fcbec868b070e59d5f3ba3155d4f40f02b0f92672f6c9a3dddcc3489da9d71abe701cd91ad92f3b6589c59703ae6a937409ccdfdf5142cd64b9775d97e753cf7e8d204e1f59191d84887dc37a37c6ac09ea26a478b2b41c337590b12902bd1f08a5df439dac8f0edbb92c62226ab93756a02da906cdf128ff47a85175b5716236994b0e5cd2a9c0de1202c5c83d1844968a3f1294149521610920115ddb64f6ccd9053261a1ba3cc888ea57fee970f255b59d753e34ac6ad36de57a6450fca066f04c1a5448baf01c8458e519b52d6da3eed265500f6e7177e5c49c51f3a64be6c05d8119c1f58a84e9a4e1fb27f50b655a3df8b777545ea12f550b011bf7724761509825f198affdf635f093c25606d0fff2121b888c78793955d519f4caadc821b27dfee3d3da760afb597ef8bc7f5a56945db9da8f465e26ffe603ea3c68c25002b2934417fc34cf928df180d75373d8cd63807f76a1fcc6f63d67b24f817c51063b9cbe46a14547db58a0f754424fdfd662e041dff22ccef8a45760f034e3185cd56ab82f7fe9e75b9c94c676e1f550e76a5af6567783ef65a0c2b4d9a1c79f1cae25f8e60535846a701dfea4c454cfcb8c82a1346a1a3a2ed1abb4828844037b7b64c3214d3aa6251e8b87b6f2c77cf505fd1312433fc248cef75528ad3cb649b7ed43eb60c30759bed504cb418abe2acea3458b3c1f2740cca4f456f4c7b1c0fa8df7135d7ebd795793bf383c172e61d05e345d98a214c499b623c3b5cd981d49bb19577f535e79ae833a09b5c1a724b608da0b0b9e6ec1d6fb5057d98f8601cb8507c68ff22bb7f6be50a61874a02b7a5529ae427a9e53c7a586fd939859457b4b5a6f9b089b838c87b63ad6daf12599f707d7b3be85332d40fa9f6106cce88f979857d48ffcc1346472b3a8e0b1d2f75dd403bccc1735df2ed3f50332ef0d2436d361e5f0f13db7778f4e7b400214ff940c8628ad4a46b206feff99fe552389360d91b9c07fef77c03a274c40005c96936d30bdd9af5c26142809a7154ed85d3422be9dfe2ce1112183838608554cf4d1868e5c74cc50c760b1a32c72446f1482666e25227ad9d5852025c319a71a032804e54c466c65717e6c046904853248c2581432452beb3decd0215d4f039c9d03c2412e20548267f2a227cfffdeafd957d961303806f2b0fcaec8bd45cafc220d3dc91eccb3d53a27f473450b3942d516bb22d87e62e47ccf796caf6f3ce15bd49e3fb131634e0142abaa7f3e432d113f7b1740d5190005aecad42cbb8ea9a3ba31655f1174422da8f33176d23ae99559a86edd4b13680283c7629909f2ed1eab188f1ca543cb305b6749a23151f53d287152541d7e48e36bce29eaf0ec93c757f7ce309cef1f75846816600e5fb89859348f4a6faa60c64d8428af0e3eb292c2e124a640c1ececb5dd42c0ae63edc4fd5104a45a8ae72053cfecf51e694c090e38ccdb08eba022402cfa3f09de66b5afee0b57cc20801f50c9a83878fc802bb769b2469177e6c3e08a29a746e59e4fef06e5dc3ac59515d09f21538776441580c5dc8a2adaacd53184fd7945eaa7b16dd075ee4f8eb2e0e019cdd33bfdaacecccb524f19a18973d68315950f4c77a1ec3d90932ae4285d9de922878b96a5144e715ea918910c5c30acf7965ee49e21216a503a3c6789969eab66ec5c43fe0c3cf9406d8e8270e065e373888173deb546f05910bafbe376eebfe35f7cf3e315ae355c5c5dcfa6be0d10c08ed801f2a24a238411250022ee1837ba77898903b721ac39e502fe47aaf1d35ed57df9545d0502ccd6d3e35d8937d192f8863056fc2a98fe72e9e4b1e01cfd3b52251394b4bf53b2e7715666b4b244e625e2f10a6f6dfe1e519170cf8383f84e8f71f897510cd02eb791e4e4d2916d419fc058ecba2897fce9811c5d6caef58f175bbc49f201ee04d4250c6c2dfefbb8677564dc811702716c7e25da0ebb3b633f4d7eb7654ae930f01bbea38fee0229b10a7b3eff8028bfcc578ed13c177fee63479fa624e5ee584ad640bc3762c0e90d50e0480783ff512d03ca7bd1897f8b207ae96805542f5a7490685a07b8111354a4be898f6c74a63df0747f6261292c32ff1d7cca8b15fbe3352a96501462885e04bf0c16488c15d472c36614a25c08a3aa9133a94972e68df533d9965dcc384456cdf3bc5041ab9d566fd2bb9bd20b6a0f042c701e357fcc3f7593026f9dfe9d6e52bbd824ccc43387adf2bcd5b4569cb89e3e81f9af3bdeb913bd3e8dfce11d6cfdcb9fd891d377f331473e49dea8b11124205c195faa178014fecaaff2c8621a98c7077c768026f7d042407f593baf109b213fa85ea4061b396e0dc46d8251e71a276c2134f390d6e4275064533e205322ba723e46ba1d06208cf4d388c5c57a81da5799efd20a2e549d2c88c99c7d723b53f230777a8ec7277f5fc48e8c1d6bc0c31bfa0b18e9d5d6c32bcc29be2157316c5d8151abce53007e046791414f147a457d41ae0e0655998fbb05a05a6e59a71e41d332f734914104c6f7c5bbbf51f96b51cd2946176669d49ea1a6ddbb56a14d37fd298d3bb4f9aae12a1d3499f1dfc68e156739774e678f6302c8931fab511557fee9e50faebab01a8bde2aaa496789d4b5eeab0af3e976db2d924eb939191760a56e7c1eaed4bf9c25a08d66083d32f151e5d38d0a73d07fdf43793d6c1cb0238d6ea3d257594d2eb863165474a66cfd65bc400858a4777742c7750052ef788140224a61499a26a1e9919b0117116abb972d2a2d5a333cfaffe260d4089079efd1e8183b2464f79ae08db8890f07b0f5b2d2c0b5254d6460617bc366bbb5d1b8157d2badd5fcac3c1f7b2e2375a361940016374db47d51530c61fe17925ef462d0b731d794ac9343d75918ef631ebd0aba578e5c0ca33efc3e2883509bf06518fb7346432fc35325a0c340492bdbd33bbb7f7a04286a683fc0ae8eca67f4e4ef4741bdfc282c39eb3e4f39c8696ad2594b9c2535985fcb9d7a117f14b320f17ca9f2deed77a5f06671c133bb4ea41c68ff9f21895031c1b945834f79c5564dd5d6d1cbd6d4506decab9d0a7ad96a60ef33608fef66b7e2a336b2ee1eaf46a661998d37538f293ce6b69c58fbb05a60e7341d1bdecf69f9aa641f9fa753a86861600c44e3a1382e7b77e61d9436932b56623cd667998d7cd76eb5417c985928a6be12fc3c85b80e5f44547dac97aba5623fe788d43f4298b4e66be16d4c54add4cb1755061eb2991bc902e60836a9fbe1b9137746a5edfb7ec7a453dee93aa3ea713c16f41b327ced7292105775737596b3dd1f9cf2c1784b328ccb39500b45919e9bd327a85349aea0fdd06c43b110fd62d993e893f7f8ca8c8428d5e918ae4af054a45473d09a0068bccf2415a653d377e5094b5105e292080b6dc6d9a961a99fd3c4256a3a8130d7367f1612c0254d230fb19a90dfea42c05df4d63ebbe50dabb04c19a639a18e4729bcba298900398d1c41fd5ffe80a70bcd4066b41a495ad36bc9a2f15e7aaf861d80232651b0d60c23cba6309b4933732fdd85fe3af2d72311d650cabec4db36eb3bfc68f0ab434116dfe8c80212ee00983d827a3cb7f8131c69d2ae71b3c9f6cb06eed3b7194789c5ce397d8d25be7bb6bec3e29c1798d3ff9a5fcbc508b2d957058d25e2ac3157a746486b775026c51c90ebd8f6cbbe6164f9e79905b1073d4029e1f1765a73a9d4b787f4d08b311a7814ee3da1e9360e1e656c903ef8f2b01267d2193fe230f58264c3f8484f777db71e2aded4961c0b1931cbf50939765ca3ad6c69726b14d4a910ed85db4837da87a1ac30deecde1b18c3b8ba8b11ca26893cb56265351617f2f80d8443630256a8546a2cf73d5a1e6f5a98a1d035a28e8b0cecfad2ba5423dfcea85140f89036f9a31a6dd5938ac41fcd145ec119810a85e72e5c3e969b4835f492098540fb6788739bd36e219aea171b0a2946653b5253bb0665dc6a4a673f9f6dacfb963b84aac4865f990e02af15d48bc318f5415b19cf16d8f4667128595818e6e4777bf2560fe992a40ab31f3cd454cd5bea0b4476764beae86e5bc05f2dacfbf7f294b5cf3044bb88aea3b0a3d64373717c70066ba9685bbf3763f6056d361f0ba5beff30dddd68f027ee0f47543632bb756b4743302a67870b53a8e1dc52950173569ae40089243963c9e4a573cda3fc6202470d225871c752e00021e9606082590a327b39e754bb08c84a16bb00409149d4fc08416f653b1b00cde48a39b565ce332ea0349b48065f9e3c169bc3dfcc310d925dd5c6fcfbea0a9bca51eaa45d4e150094d18bf0872c63f56757252838cd709512373793c8f58fed0f534bf32c1b1066baa1153f3bf337d2162f6304df5bf22ac407bf33d0cd2f91871f5a5d94d69991e0e7b05c686e72a417ad3b8813a7992acd606d2c6b8f807a96f7c33730ae6bc7eb943634020a04446f0fdee79c93bf602ba6ec9023b026c697835ba7e8aed406a63b61223c4105af17b6008a105e7eaf74eacba89a237c7a91168a34711e74f9b58b95e15bde59859e30018725a4a93979e9302cdc605cefa319850718426a6947e774c9a7c7799d6804d0d6813559627ac7277f140beb70eaef83c81c26e1b4f7104a762e5d431c3caf10c08d95362152a8f66d6b29209d69ea120e26a0669e8dd21654716de2ebc9fda0b53c4926bef618d8dcfeb95ea2e2f51ad697a74993301d819c265ef37243511d92856bf59b659a5e29ad4abf76b2a17ad345f8e479e1cb0ffa212943df9713e11dbb94304ecb8ec3de794cb263975a622520e265ae820342f3363ae3e9512124ff9deff94e2e25bcaa95a18a37d6a99fa7c993bb373d7a1e0c8b7a2af1abd4fc7ab02908d5db215562f6ae51b801fa1566c28f68d45ac5e428ff2f9d3066368efff7532df3686fe167daacc790c90f8fb42785b58143a05298f62c2795075310be06e268bfac5bb3eafaa44b01c438be75daf59cbc8b61bd754c3aed4b9136e50e860003423742797588542efe1a965eb7b36c31a1883cc85cba9e76524ea317d7f433617ec59393eb80f94fe73da28259bbd03effd92272bd801b95cb485f15ee9c4160659cb2c0e02924424661836d83bf7cd179c6d526056976a42ad7b2b04c2e2c36fb55635bcb3a9b901fcb256f9443614a671c3d7312a226001f9597d0d0e2e41b0e49638789e230ee4ef505c1260cd0e4a7be684b2b205c85fabfc0068be80e7a3e94d7c1ffc956f13ee6f4cf47a27503eefa2f6bfc4336ed70851e3af513f96f2afa220460d079d676039f6ce4b5536f575867bd328edf2d748a3f58bccbbfa439a7f02ddb97db01bf2c42f185a6acf6372bd973115f48d9bead8a958ed80f646313da1c181565a6b83960694dc758ee0b75e4e4d777b4dcd74635215bdb0cd49eb41983c87ca3320efbd8eb4742584f002b7b4991da8c31e88f24b478a6fbee51ab684ae5e2cb385d9f29bf32c42ed7adccbf284f446e535e26da24eef2dbdf0c76b1c90ddef0fbdd565e92c077f81120e707d2e8aa440203068f67cf4622f004fc768109563834b859bb1999a518226706e71062cb8b946c4159ca3b3982eda1e1f53161f2097b87fbb165b2923b2316fc66a41f6d34d7ac22e911693a515886894b9df12c5cc0c7481c605aebbfacc1196b4329b7d796d5e4b4fc41a01a5339a3f42bb9e7e1ae4c7563366e45b34ecb0d86efb86e55eda97649c24d836b441bf269196595fa219e9cc989308cd53bcc7a1a31b635be9793c3c544c443ae04c5733b8734ef94cabaab027a9d776dfab4492852e888427550478900aace0ef8e4cd3ece3c0365d49afefd93de57eac5e388ad5f8d54ea22d3aac9b9fea869cbf30c3c9ce71a266405f00d0b956b187a8d9b2cfe7caf22cfb08d85b78d2a81c9c0477b18b49d1e39753b3d8ad1fd2ad9ecaa1566efabc6e708554a6e413be3dc420405f436cb2af549edf560ae3dc1d02eeb96668fe18f3c195790f7f1c1c8dd1dcdee337e6f06543ee072cf86615a0370101d796a8f73223ad29d4f228ec9f4377bba82213e584d8f49fa24335e255a7efc1bc83a3308235d5a271be27d2697ea7547715edb23ebfd4dc9e7813c6f5020737d8c551ac1196aabdc1c7e40e25f4b752735eca6190cd45389e0068c11d50b91e16f1eb2951bfe57cf968bb5ffd1d621846b2b22d76b7dc2ae2438cc77a1dea994d9771638f5e42b1ffe84fbc11e9937d6b883a14a15b1b3a5f7ac89a52f935a8c6dbe8bfd623f9eeda143f68a81cec9488e0aff2f331de8a0f89eba2671f4e4253c42e8239886d49a9ef55a50f8e689b99a2a9d9ba919d8dfbafa60cc91ca8576652dceb7e9be3a08553a0cc23a9466806a41409e1962f47c0be93e055af2146c0591d86dbd946d605e662dad9f2c3481957f043e8df7d6d47e62e12c6c82f60f7cf4302cae89e2058cea38a8c5db1253b7be75c659db428fd8b9f7e0c4a3ad0caf5f1956cb0504e1f2c92e9b302d44c921e34c726d8d816d924fc3d7f8d04db438261d7161bad584641f92a6ce46f1001b5fd1da9767cb945fd1bff2116e6ae5b96230a961f94f92c6dc92cd9f63bb198a682d28528a126afd4c69837dea5fb66f978ec43194be51df5621d0aaa14eb6fc0377c88b57e53810c8d57113e090d7e2b1c00a15cc30b39ebaabf3ef4418a5ab494dde82168641bdc735d8fd6dc95bd07267887d8626a36592f878575338d20810faa1fa8a26d9642dae13a2df84e63a81adbf42c6d8dcf5523a4ec0ddc1562e35a3508875f594d954f1dc7f651441049e500a6791b2af077451bd417c954857a290a0be803a2eca307032a1b028c8bf11eedd8df9e47584d9da8317417a059d8a56eeaef8487d81fbd3d4d78d303ef6382f70709d9ab8165baadda3d19f6566a7b309182a31ced06d689964e3f7f4dff7a7a82f79b2df2e5281459eec89d4f5fb334fd8f4cb58e52a088d993bdbf1d97638a6d68de138cbe4c1e399d2dc91d4da6eb9820385220337822487170438fa2ddf3a1b650bcef6c2b08fd8928e88168e74d870ad30b30a41d0b8898e462faf19c48a9abb22b7ff111777cdec5ceb5a901e31fff8d0a077d0ddde766e7edf08ea7ee6c2a19a3d2eb54846559b77d8e2abad0ca0ae6f9e3b4f8451ea17f28791cf9c2ed772e9d1413551ff9cf416549f8ae8394a8988ba2a1ad379013c68065e51e5ac31b0e791094b7b34508d5f8aa201f63cfc676f76aa435d43580e36d7f39770b4e38e86978aa2214efe22a471bec0a58663590213cb9497e65e85759a589ab1f3e6bde9abcd7a6924f12ed24366ba4e440401b8c77544f459dcae17716f6878666f562e2962e4d5b68300a8f8fd6ba9d32e55052436ae49cb192b0db1e4b6fe2ce604a2cf9fbd1988c71ed3adf1677e94b71df05d832912ab8afd43ff1cdc87328959f72a1c4d522868849a4549d2892bc2fc6479c09fc4e8c3c3d07ece22a6fcb957455c82c4427122d0fbb711fcf23def39159bc236b2b9b35d6e8d907df3f7398282e5a11badbac4eebb326d5578ccf60e84b2fe4633f5b657fbdc0f93436319cedf202038be039411415cadc2f38a59be6e10d1172427c578912567c695b6acc4e4222402ce8296a4a0fe24565aa72182e9af46e7479cff6906dc6ea6a38990e6f1cfe48e96950ccfa53cd3480ef1959ac8181930d21b2aecbebdaa1735446210369611d6280fa681037df63b35bcb34882d3c8a3f6f5649ae5563141a0d676fe3bc39021893bd03b4d77f49882b3ad350cc14df7a5718e26d17079631c708167468018800689b6fbe6bd879ac55bf1a767bd2c099c92d87ce2a372d0fccc86fc915fdc9fcfc7d0104589fb9f56f6cd9a4e7bf4d9b1e5ad8bccc456c91b9c7caa7998f8a5129cd16f4d1b4bb77ceba543df08e286fb3ac3e8cb8cc093384e4dcda6bd314cc489e1eaecc17b0ee43cf21cb8f5b01a4497586bb1347a21eb712a98557c88543eb2f1aa225cc1a8fcf11edc7b267bef5c9404599aafdeffa5fd17ada005f0622077d3517cd19fcab7d6c5b027f84410cb0782b12f4adfdb29434767229df05ce75299d4e573b8af300aaf47a1ccb9e3de296e73e192f6276d26f4d16936979010bfbd2f53b9e4995fd10d5e58ab24004d0309660c72ae8937d60c9f1b092b58688222af72e83a597c32b785239945357d8625f762727a56700572328ef0629a707f226adbdc9c516b2c6a0ea7fd16410d6217ec567164025cb763277f47651b4f72ac431dddb53f1505bdd1276f71091c435e612aabcbf529e4ae842f5d299ba2e6cb78ac13a0bab5ecda28a39cec7e6a1078bebc3f92d9bbd09229a2e3d9bcfb75eaa6b43f97b314943b9a8309edcf78ff9d79cd74b341cbe057536008cbc998e40c657e1bb94974350e9b39941ec8280dea649d5c5c6a4705cba21e08c234164df6288944859462fdd8023ba66d2a0917ecfab22e9e579c3ba23d342024ca16366e67643f00f6778bc78a6c8d621e03dee20d1203ac426ac91bb7138582bd63375c8a77a9227fbe4590303538c3790b00969307052723e35d693bd2e12bf705e7eb996f403299d259cb1002d50cdaf15bace18c76e983f1efde01db3b74c1e195d658917ee0f79b4a63efd2967711661c577e07b788f7824a701497996161c3b534b0d85bd9d3717cd0371734f7a2a61d4018846f808026517ac73b05c8303f5b97cf1c70d5479f36ff32fccd46a2486ca8d39cd9a8627d6f4047d959dd374db028cfc301dcfaec4fde2672df30612a1d7d52c9dd605ba35df0addfb14f95a91ba1fb162368ee352f70c534081c5b734fbf4ab7bdb9f98b5169c363ccb43cb6baaebd3151ffa08c1f5792758a9b86badeade5ae16e0bda49fd9cb20e231405f6b15c59b9cc7117a0f327da0c11e40ee0bc1ef3169995d8a595e6153c0b4af25697100c147cc2475152a6dff5126800c86d9e83fba208092d0ad07490159a0578d0232347109cf8a1c689b129d170169f21c3f0a63368d57821ee3465e55ff10076671bd465f029e4c7e2646292763eb6cd4d8905953e876be7573dfeb4d070e84016683e34baa28fc3bd9493236d470822d35771da7d2862fe477b35f064fd467b86cdce3854b3455dbc0797302c19888346da7731801a361ed217b8cef2b4c51120870e712710565c9947b3867e00d1e4cdd55204254573c1466799812f808266a224ea76ba98528c562694fab9d2e301cc5ca4ed4625a70c4105d313d7e4c9eac73629f9ec8abfb16108a6fa42b1e74d830d841f33d6672264a5db8a7447477a371a3e13cde77d938bbe537dde1027ece0903c59f61bf581425ba5f1406c9716e5327bb771ea4de12038c4a0ecb5d4b1d0f671afc62170bab3942fd56f89431544d46167ef79b3a2bf6d9fa1313841ab18f99e187b9655c47e74a25e54d8dacfb276d86d332d309a2b9168368ca166edfe242914690ce7dab9fbb7b005e4862a86fb66b381002e6ebf3dfa774ff7d750a54314bd766c1ba92099bde48d1feb43a9128b8d5bf63b7c30a9ebc360be9b356c9fb4552866f8ba3527c1ae05722139015533c9d55ed61728d1d5ca5f89092ed75f2f42b8819b5ae1f25ae9209d457851f650d6b2589cb19238d93e995dc84ebd1b84657d003019ff940d2c998ac7a9515bd7dc19ce2450eb3d5a3cb0d3b98ce1ba97b433c47907fcdf5e9ce8c51b5f7caf843f853cdbdcdb721dd04394596396a87f4f7eb369b5affdd9467245d75c832a2dc31ff6ee64bd05225f8e4b396e057cea2b38d398eaf3bd649be496924041af14a2b7b5a7a19ba169c2a02e96e8ea7a041c10bd10653c5395778cf29cf0d25412a8160d341ccc1bc34deee0a56e7f6aecf36654a650a8c95405139f88b67f72236ee903b349fe19ddcf166eee5af95627a0e7d30c70475fffd00c51c0357ccb93c257194dbc79716945d8865e168ff3950a71a7966b689e894cc1420f53aaa7ee3b4a03fd05629cbd739ac94b615821c65fc3a3df6003e4d396b0c2398a32e4c8ef3b1a5940cb48a7ef8437a39274782e9dfa846b8c39bcc9de870025bf9d96a8f18e63fecdd319c069397393b1d8a52819a98115a2e8572ec36172df0d2d606028ad4b6e791a3210744e2cd303285194cd1ed05e5c0acb958c37231ab6a8911c2fb582c931d06d39ad238e19cc5bad22dcf99da3a4d65038040805f66ef26d85dd323988d2877d61d51391e6ad9e6bea96651ff64ab67e7bb252ef64f5484285d35594b35e3cb257b188310daa6da51dbaa855c20827004d4b3e1f365617df09f48ee6b39d771e85b6152292b8a49a8f7e9d7bc0497ddd94975f001d20a0656cde2a77c078109a614d8612587add579d3a3d3a09432f1aafe64902d770457e365aeecc551d0787e37bc93b9b6935205db4d08ede0bad81d1416e299d42502ca50d5b87f81ee057934cf1397bc8feed67cd232549c9191104ecca04991eab715b0040072baf9f4ed114cbe355e97400a81889b142ef3477e7b0847c0d418f7cf3b384a067baa8e9e21e098abeee68ec5855fb1a1bd84fd856d144593d59c9a12097d0c80a80aa1be731feab028aeae815d05a0ffcf151aa0d8184fd23ad92db2b88ac56d35439c21d19136255ee0e47e83bc34aca67c516c9686cbad2a51a956036ece8c10a2104f791308752609cacd6f09d40e3024a389f9ce997ae93ca331b82311a66553f3ae8066d9109c3b4b945b4cf3691849a2af25119e1b4d88122d5ffaecfcf827240c9c21ffb0bb4984516ba8a9d30e6933be553659ee6ec569f2fd9ede0aaa4c65ad577a58da56de1d6b4357ec523833be528cd9dc884ae4dc4a9a3d5f50e347d669b700f8c923eb4a2c1044aee9f6cfb110faff01d944d008d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
