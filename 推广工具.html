<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7bc69533af79861d90271178bf318fd612cd6c3eac4f40dce1890eb0bdd3566ef3846d9e558977bcf7ae7d0d907c01b2bbd4870d9f5f890e2963e1fc84b315ef4631f269053f2f0217f0b539b23a79063bcc0871cfbba7988479f1ccd9afa7a01eba35042f41ff814690600f0476f2ff6ccabba7cd8c7eed3803e8804012e8977701d5e7280f394e138de953150e914a4268b8ef9e7dacc83a11d0e10b26086bbbb4ff355a0c4a492ef3378e615a0968779affa177c5c7d034a6598dc31cf925103ae17eb5e7f20e4ef2ea4b289021ac4ac236df759d6a749d60b1ad8350069dfd5c217135b70e8392c23923e93ce49034a0897d2c54d118ce33507c16b023773133ae81988b7212dcda8f0548196df70a7a65479109dc5be239a5cbe181c02c5ab4e1fd99cbc2886b8530d6bf7d4462a496af5d423d4f5ed175290126aaeb78b8e582e86c024b7cf7077a2a47fa628aef68bb82a3d084c8437ed7d1463525acc0f938859071627cef169346dda277347d0bddfc981d36cff523e9e31dfd79940cf46e413d000dc4c63e6410d5bafaa62adafaf13785786f01ccf88c27427d90aa384d628d93746c0aad1389fe9aa444e26425836f7d54d56268088f9164857230a22e2a1db3bc65ddeef7b8fe49c384742d2fcf3224847ad80e3bb04e3466300a587bd5b9e77a386b10cb387ea1331486def57ca3cb99b7b957c369d4a7543e8f5e77d856daabfef58d5bd3409dae57972942f41f9b12971eb304187ba7878fa9579ad372b8840627d340c4c34696da0d8d538f3f42dc1725b07ac09d3f71d79158f9343d48556bf2561b6fbf1ce592a99eb1b421508f6c92a3b4a227fbebf992d585c37a11205f6fc63eaafc90d0ab0a0b6e266943764005b890203f28883a46260125fb7cbcd61e6fa5f13931e11f5817e34376cd612eda58ebfe5ec214e23b71c3e2ade4f1b768f33afd4147394b2d1ab2a7922d159bae7ac261258125341b67e7ae25dcdb5047e66d9c49b9913f2ce4b618d8b256ec48b6f5328ab830efc377cde4a95380d19b4f4b3953dcc8ff83e3c5bc86dba0815ee3b152154b4d758432110a5a592f5d0e878ffe8bb6f2340ddb66713aa2cebd311ffb0895570281c9ad9be74c26651fd7842386c94174e2409412a5de08d90bc25bae7d2334d50b0cede2923bcbf0568b06fae4503c1c8b5836619e8d7eb7239b1cb939cf3e64230f120c5f60a239edf0421c6fba565dee831a4a17d6b6b8d1321eadb99ed7e66b03872cc0f94ae94ec81498ae7a14fb88e5464baf3b0afbbd0e8b1b6b7176ac5999b3647b6c95711b828d69f790640eef7f1e8fae0d40b5e2f021f722ef5f644cd5f6726a44ce6315a1451a731110a0f0bdc43045343938bcf51a5b0e244abd874d4c6498297a3c69f6bdae71695f1a704824a92f6ac3f179b81f61c771e06faf9ad8f0ccc7e98a166069f9acbfc46fb695797caa80971824c74ae0fa6a62bc0fcc84b43af4be198d25a68d1285fa8d6e9006976ddfb197c63052c4e26df4b43fbf96dbf19f1f649fbe39fa42b049a2dd58515da1edd3d637bbc38d12344ff7041de2266b0ead736dca54c9df1c7f81998df0a5e48fe416431571a308107d4650ca78887975e44b4d61c34f8cf0cc04e7817c29f0db5e7c008ef7c58d12e0314ce007140912ddf0c6c59edf6377e44b539f75e3385c83a5ef186b95240b167c9157d365413a700d73d6577c98f9ad96d8dba5675f65dc9cd005cb4847c3eb8200920c6531e8810667ed9b9d7421f83748a5010aad1015055794762cff4ad967536cf897ae677244d875618cd4ec28d1ab6a1fe0e6a15483d1fd421ac47e0da69f9969b079ab7ff56a1cda6c7437e3c93373547543ebf2d41af6c82b0548df5c1b886f05ab0d7d84dbdef2eb4fae90df3c170e16a9c45b4b928872836843b5134f881aad834061c966197e383b8c7c75fb4779632ef400355a7cf84dfd3713658e6adbabe493baf50d3c7d1476f18b79eb2715e515d066317e6ea5d2d37d75a759638fefec8f41e3027cd75ebfc223269ac6bf8fe00c4c34496004885c171c111f0412ffbb576cb34cef38a21cc6c0deb431993805735981d2e5a0863049bdf9b6f5f855d6fc30d884fecbd63ecb83edbbd548b0934313115d0052b668197c7dc15932d606ff1fb8e9eca69418e8bbd00b2c8c00506a133f2b6f0b712432b51982870a6328d0ef6e840b3434e813720d5297b05c66f852cf73a4a135c40491334c31e2ab584dd3d2928d9f5b2167b48659af2220da4ce1c935f7daa2f90792ca09b9ead97df6618b18360bfa2e341912383f9767d51e48a99453485dcc99e95b5d077690f34e907f8d2153084d077e3ec18bac7f53574e6d256e0478a1b1dbb95de84a8ed621c6b4ebe8a28fa4d659a3ba2df290146ee0554988f9b86d39b9ed07518ccd7a6ee6a4fbd69d1a84e741dda26a00ce045025ca09fb7ca45f3baff04033d53ca30ddab1fc6de6bfef24592722c1878185f9214d23f1683a03dde3f89791401fd9cac6bb4c879788d647feeb55f43f0f1eaff60da5d06de7379c19e7365b46a9b384eac6cf5c1219faa2d16c27f43b493aae328bb63a78c14f1dfe71da959f57436976dea1aa0475711fed3add3eb23cb7ba628efa6f1e4ad45462e57096f3ef43bdf86b4db4549a91ec9d0eb993af71bf9039c0a2d1dd0a8624a4f5a65e7c2e6b0fdd9694ccaed724c10cb9ba6fc537f3766f0119d1f971ba51703252fe163000f9eec5c868f93a09b9b1437f07e03c760a6bd8356c27cb9151b48dd022ae6d53ea477d695f81420b1cec098bfd92cac75fc61dd4bbae8d5f7359e124772d549109c83aea465a0f64f087ed09867037a89d3ec4d6e0e16518e8a9bdaf91bd353893df3c6fd2abbeaf5e577a28960ef3edc28e1232ac6c0273f964b0d754c530b8a22070b92a66c49541a2b63131d1acd46c2ccbb27263747e530ac2ecce430f7499cb07702d3723f0bb0272228eb5d9e1fd2670a3c74d633db8d7bb0a180dd22fcddb9c5584b6d93d4c928e0967348985360ef844aab4324ace6f121dd28856e159645969ebc941b1def1e32aa2c5c95cd09a73206eedee381e7b3d5181bcc72fb573269fd22817cfcf811b3f58dda8fbe99f82cd9208935e1539f344af35806a57a51e332cc23e619fc7d9f314b47112d605ff54a07aff566b765c96e6a89b1c535602b3664cadd5b3491acc52ae85c83191272543a42460de8200db100880fb2c11704d767f3563c0510e82289612abaeb902fef0d6dc78a5f72fe92dcde420bf7618c6f975365cf472f10c32a89a7e89b6c1e979b2533d07e74ba98bdcd08d520b828a74f01e50a4236a7233286445cc752f1b54b8328cb5d6ad4efb412c7af84a30425488f001fe506789f87819228ddd82c6ebe4e8f076430414faca9c480f0d0f24b785930281b3dd8f2911de7f3aadf23084a2ae6bfc5e3c0363c135782b9853c2b3bc6c0119741284036b6ea811f9fab10e29d5b2c98d7a27f9540f999ab2bb16e450cb3b5fb6671cbe55814c076881149f87f617e7637624d3f57345a617ac24b517bf7307d35ef104732403397dbd31b75f41a00d6d730702ed5348cef574c0fbeee626a21f1f6182f660e966fd5d910f34560788fd7538033b4a098d44dd32dece22b775b2945729323a4de8b0ca58084b368cfe69a99d84458be5712aff70a69af4185a85cce9e16372cd0b10b8f47aaddf0ed090f19cfbbb02d0112c3c3592a27604a27730de38494a6288d928dd9b2a716615b15b857f1bf3d81f23697e41f63e852f27d7cf8e3b05ef4b9d313cea7ac735a7607d52412cd5466c97b088f5ff00dda060c6396db0a0ff27022d1bddda7a583bf7e5b820360e609e8a2bfaad8d25b6f85ce5b273749a2d8038055595f2868666ee93814c0e56e35b42048dc9188e39e2a995647c0d811a22a6ae6b61dc5d3459e9c1ba90fc58c0a8ef718503f4e33dc13a46192eb2209f80c9a57b3c0c08338009ad4ff61c86b8793bfc6d4013f4bb53032062c0fa389c25c212ec653d0174157a60222ac905508699fa6c3b9960b2b2bfb33c3c97938ec876dd2a989cf33e595e59739311d84e9be76bb96ee50af1b7dd20c3f31780757b3fef6289943152a29b75231195d438e438c93f926f73e023b7ccdb5445eed8137fb76847e31c1bca46e5f7b02609cf8b4f59b0a576d368422a77a0314247b45c56f5a94cb8254723f2bf94519bc9287be97814a43a8710d8110a1e61254d160b8a062e5d8b6c8bc19d721daab07b85296a5420e999837d41fa62ef8bf7730669250384256e3dfd871ed02bd7e557fe953c009dc98df858a19735fb935060afa12d67fe5d6880dad185ebdc13c4916e081ebd1326ece517acfb34a92e945a04f2e5ee092f03a7ece274627ecadc021947555160db59322bf9bff4a7bc0dbe2433433d52072d0235e499a765f4d570121a2c974150966fbc9d52f2dfc67eb44cdb8865d4632144036a7bd38e9530795fd3643e0a30ee0f71cce64070f4300b7fd09e685acbf2147bab77f7e34c7dd386e5f5df0166a0882720f54891eb28e3499e262b5a88daa9f11daeca92253c1e63f35d06dbe2114288b54d526df6a703eed8df837f5d77a0c637194b6968ceb45384de896db1413b585a51602067ee3bad7b545a9430b6f511c9dfb95fa047c44bc6a109be91a663058c50a90eada19a2a86ad0206a85b0041d1928dc57fb13142205a3d56d4e50136d8254019ebb0928aa5d0af91568097418713ae9e7c1c5fb5f023df2ab05166f61f548a9c68aa6e43ca74deb16a787befbc122c2e09e74568313381cd112d6d1b728e2f2e1c3baa81ec7622993e811ef39fc493824053cd1ae0d1f5c9474f080e839d916e113c66e965b397b24ce879bef834cf476cfd492d84da44ab717658ac1ad117abbe94df2b888ab66b2f2fbd81e6e7a10082645e6b5d62c07fdbf52ad1121b3c8d55b1664950dbda7f73e0aa375aa4be5a0e5160dc159f9a70b5cb0253ad0a8746204be4e99f2f0e261b23ad3161f5ec110d4711f66d7cf4be1fbce264fe628db3cca22f1e03845d24faaa5554b2a65f4ddf6ae5445ed2559d0486f84ecc9eba3d75ba764671c6c24e020974a3971f2088f8a457860172d3b849c3fe47997a0a4c412e7597f3920f0dce2034f7867670eab1e1a2268892758a086521e29f7af5c1ccf1f25eae6fa2b7dac5381504c498fb22325baad48345e3c2a4bf5a4ebe1fb343c1e469275f28b6b617b7434ab5e1b6065fd967fc29b3f92de30b843bbeb5692edab4ed89e692bcfefc03d4fd977589c769dd06e2d61dc21e55d9ada1ece2b5e3447847bb7eba80d55560b4e594afdd54449ae4f34a8cd3942a15001feaf2ac08c08116366e2e1032568ce630cc1fd113b076c7fb1379dddc3cc1d7356d864eb1cb6799dc0cfd2c3191e54752ed85fc976cdc79ec4df18013db769c18cb6afad1e10ed5d8b9f87633db3484ad8e676d808b55389c389b4baf8a0c754c43a8e0c4def580a01f48d91dc69c31f8c1002858cb1807416820163d39f29dc607cc88bdaa8496e28d7fb0acaed840dc5a33eeb626d25fb46e5343cf3cfbb941f2eb1dd9eaeb002f56668601db64f7632eb8d58ceffe33a4f1733eedaf1856b996b045cd7c527f60e06d9dec8241499a95c5f72f29e617ca64199770c8e68c4c4f3552443132bdd72cf442a76b1f01eb20b4555b391831f9ccceac250ec5c0dcf5f0ae428ae5467a9aae3e959b2981128cfea533ab640ef14474d89abd33528e52e6068630cef74a1e4bb808f3684dab1cc7cfbd7d3ebc2c708fdf0743235a277c6c65598051a49a30a755133dc101d794617924dfb2e701aa4fb9bdb91628036cfb057836700a86b52d7d280a526edc44ff824951027f28e013b874c82bc8dfcf0f2858c154d5055a03f9c583834c38e2def73d692a3473e4ea54b253305f9b71429e5953f2bc8f2e02c7ce170a8a36deaaa43796b98408a0bafd52f65cb280d2e5371627f7bc3353adb4f311188f61da20ce3a99ac90ea2d6a9a23264ae0fb5b9d2b550f03d63c9ad145baf7f0cfe116be98f07a2b29e71527b123cc2bb90818fcfe809c00a2d25c73fa0e542cebc3c6339a5926be3ccdea2e42cfec99d216b3fe38bf48b9d8e6acb39b054da5bfee2b5b0ac60f1e08086c4d82601b8a3fefecf41d6eb2bc1886dc116f30f9a93ecbf6da2eef1c09d497edcde2612299319053eb910891b03bdfc32341a85396c507f65151aa044a04d77a1a6c8867aa4be8eecf8d3ec2490b080bfe8d5be0cd352b145b1240e3ddfe400df7bd18084eec5ee881a4e023c1e5c42275bbea984eea602d5823aefb1ea3b293b29e6f1e1d4d3e9345bed88089ca808b49fdf2c0f6386fad2e7be7618875160aa1d5414de5ae8d3130af6d5c462b867954bea42c2f085df432aba1c1c5dbd3699b8a2ee10fdf262afe8a4bea4eacb64eea310444af5a26b191eb64675f21b6cb638b17e018d54ee1162538ab3c8bb37911299d446d53dce67e4743f153c244f38f281149b0709c52f5a493200ff568ad5d0ff7317bbeca84a21df475138bcff11c2c92b77775ffd37430f493d5ff04eaeeed33f7d7069f0f77145b09bf087e36f18ab644dafaa755045418fcb823f30d0f6aceb4546feaa11e0d008d69c5f3e7eaef129945cbc3f97e0cb2642d24c0d35d5b20b7c8fd20e0c05a491f1e020954ed6a0e805cac0e798ad9d360bae712e6ffc73531fd316fcc697b4003ed68dac3ae6a2dd07bd48eb47cf5bfbce0e0229a64f5995152078d8044aa0863f318fccd8475fd71dc69598b1a1c54fa4f05899553d1f2003e0598d24840b810659abace528245088e011056f8747a7f979403a3f0013b1254c17e707bae5fca3024757ef64a41f8f9c33dc84b32c5eebc388ee3937c982f135070f868bb0155c08d4aeb6cd3ed3b246d03e11b927476c0263e3046d6b23a37dcc66e1cd1043deda532f57cdaef73ed292112c2c7ecb8f93bbc9233bb3738e04c4a1f57dcd216539fe78aa1c4a11e031512b87909ed32b06b3f6899b356539c57ed88858b7fc18ec498adf8bedc696401173a55bd509946fe884ccebc23eed7e0ce4c2aaffb7839784bf249f73ed51c2734b5bed5e384da35368b3056b40c014b0fed662aab28da9597c8c66a4597437d2144d23d935c9dc724343b69785d56fe2cdebd9c090db6fef894f50c34c60847a1c3745bee51c3e1e04ad9116c58b901f7d96ce03512e7ff2e74553ed73152d28396393a2976cad23b4252aa136f5a86595b5365d1007c2951eec49a794a2fa9bb635dc9619a8ccae9d9c84e4044ca40867d032e86a946fe52d97ef0b356aeb7db78357d45a50e26a72a75dd519a1740006fa2d8d9dce031d49fb052b6975209cf95da3840309db6ba0c65f4a449443e21692e9ee3b81dd6a2708a3df27f25e6cc7389e2254300c6460ed7955532c155b0f54b2c7d2fc797d1fd430b0cf5338d03db01ea438b10aa70575e6a70c1f33e8d79572ff31938a070a58877c9fe0b27eac08807f592af6343df819a6bc21f58a9d78dc7bd60eff464bec51e8e8728f0d88a7e33cc94ea049b4df8b0dd0ecdf51d4b3719179fb2319e367b635a1e1f4fcd9ea363618387d623781902e8b778a2f74377743e9b9e4fab3cec780970560c068d7dea286fb6a21fd1c3241460aaef9f648a6ca0d5ae673f195ebc2fd782d1c5fa6e52d1f3e24ab8061f8f996f5beaf8e6c243d19b9f55be1c68caae1ad6f7c45709381ebd78aebd8af5aa64af2df8fbe48a89c31b0c459cb744d8db35f5ff2a9f8c74360a2deaaa32710283cc9be87bfa3292a67d680f8dbfcec9b6e464e8c263a0fc158fc91b3164952be36a175dce57b7423d53da0a4bc8fb095670ef608ccf6320e4b6eccd9f1ae77c8f441b8ef42e13edf16dd510b23fd087be6eb25b42ff2e0501945cbd75109165d43b4d65decf3c57e2f0bf69452e5f17350c49e6adff677b9141bd45d457adb001197ec7cef5a1c9e9bc53e4cdb689e2e742b03f3e0834cf5941ab2632776d5884c2ed3e77dce56350b802bc987af6add4d410ff8c06d194c844eac3fd73b4a1ca02389d505246c08de404a2a49f9514ae718d526dff3889e2a06467737a6de0ebce16bdafb1c004122d9550f01c4bd129158c9ad4f711d99b122ca48ee00dd69dec9fb298a1ac3ef8d257ddb435fd93d3c9c8d66e9164559c6c8d667e4be174902c6ce0cec87ccc3173ab81e0d1e13210df2d1b117deb6037fb97573953bcb4b2f28c9977d9ff0a8fa0bf49334ac4045812beaf97f9faeb8cd822a74b9523382f6938f44120dbe84c1589560098f7767591074e5fa731a8fed6bb56b952d575a5fdee553f0212422d51b1bc1d926b967974e18b4794a8a91c76765ea71a5c6f8078244c95d1c838f5769f06cbb5f46bb4ba219988febcd80e42433ca070d435a707159739c8b54d4c1e968c795ca00f3afeaf22599672c7b380df9b07ee00dbd88d210eba39612ec1e5347e01e5f1bf153b19e7f6e36a2d1827879119ea675b13e0969feecd577ee250e06a62cf51dfe25f16e0fa9a5aa5865cf67fed794d14c7aa999ad7e7884845bb04b6ac3c585c1d049f69e27a26b5a0ad3ee518db8541a47a99afa8cfe6760ea2cc67eb691b61b02ebd056b9bce972bf648c794bf05ec3999017ca5a749d0ad68e81d93a3692a29f7d65a91d3a58178aec4b9c2b4b4b3ef0b6c24dc3dc126118e9ffb3b048a5e3d804bd0afeb341efabd486bb2f4464cdc51052fdc3b96049f7613d90b5d624ec19e3574bb513db8b53c64091a413bf6ee5bbbf234832b9ed05cfc9a06229c18056aaeb6455a150a91fd2cddf2017c4857141fe5e61cfd7863155bbb93636d5ed867279e42b3ce0c8a13fbf41e286f0ff2c0614863e7154cf4f6ad02c39064166e14764eb376bbbd597e4906a5a69240f7db2ccf981267c6f0fb2c6df5f940828b5c0158c7288b1f4f2c438418cb1f9ea35c10548a39fc86966bd1e3347033be4a43869520960713af2d8a9dd4c97dafee89a716b5af6e3ed569ea372f3bed80e62c4aff20fc332e98a5e4a01007beafd71c781eb4da4967bfba8fc337e22fd7224552aca3fc60ca79b5f67ea1528dcc6fb195bb1ca759e5c017ad560545d0f1fd52311fd759578130112a0c1c7e8728ef60969dc6bbd2fc56db1d9fa4ca9d0ba6976dacd86d758ff9a53f4414444968a2f7167ef1eab5dac52bed41caa950ae496a617bff4aa1d9888d137fcff36459f294ab468821faee191b4350ee3a0a211d3f7b571a3ce9042744c0c457c0419221df628e70ec67d42084e2b343ca18b6b934c987928eb4b8a6fa5f7d0f73f39df135a14f1ad6cd11ee3f66fafb828eb3c699915dd47259e00b33844f08021c2932a4f4baef9ccc586f27b8b446a83643da6c9f05e2ad17ff550a9c487d2931256bc44f7153b7bcffc28db9699e2959007b05484ea4d99ee15df67b7997cec1f9994bfedd6569dfc563f45eb45ab27562d30bf71191d1136eb8a3fd2afd7bf09b94cb5fc8925dc2ef8f9a1fe7301d0c2366d2a208e04f07c47bf48a974db5b4244121a921cdc385290875d76abb99e3e50dc5d99841fab383ac9b7c6f26333e3d5d8b99be91a3db0e2a601becfa3655ecb9a2daf08406e6eeaa79427877202a292a71ab4478aba23bd02d6f3d72bb11d9e2291870333f15b7dd1804570fec8b49aa2853ac6ec9695ece85fc63989977ef8cb66e6ce93cdabd6b83c2fd03edd27f2819fa5cfb10244b74b8b68a7fd923dcd0b3e6721f2962782dbfd70b0a2db8bec961b5af9b5791bd8494187bc1d8f05002089dd614ee921a15c6bcb5527c9e73362a2a056f3160656756433365c63eb41d1ac9fbd800fb417becb1b104d60258b04398ff5f1af99620186e9c16d1cee723640d6c50fcfc0a9834fba2af72e4db77969d465d9bacdcdfe469fa71252b93dc7d84be8bc5b12b69d9f49ae5be81b3722f021926ada3f9ca525fa0f6f244803b1f4e706be2f4d6495e81d3bad0829c99285bb3611c3e0782e0f8003bf35b2b74ef279b163dfdfa4bf52c3968251a135f1eba20e07fa6e07657edb4be0fc5cc19c7dea559068bb07bd15e49ecaee206ecb318565e6605545e84d6dc1cb424a200b3bb5084fd5eb9ce28b3daacc726eef30715d1fbf6be8e7d94c475d6f63414f26b4fe9b0cffe9cfc07e74eaa24862b23aebc51667af6f0347192dafb4bf4c30cb511396c0199ee86e68afa30eb5acad0036e055fe0c70ede3afa6e133e718ab3a6f8fa9b529d3a69cf4fad28244f563e84c65b46049c1418881e4531dc62ce346b441012f56005095eada16ac112f1995656ae774bb77a59e0bfac25c1725ea676a2c0d18c3e2169666978b56719083ef9a70119e251376d01850010bcf5fbe8de6e22b558f14b585169c163b1020a8708bc9d93bcb38cb7790323bde050e42b4e062d062ad7ee611e52ac488aeae246b1f5f84a52c6d7bb630e1d159b4fa2af9a4c13803ef3ee31e435384a7a6f7fdf8deae9f9967255520441e56e4d8d6c6290ea5508ad5e29142518d2ce6b40dbee6621134e5058f7f364f2132498a1f73a5d7e1aeec80489d50782cce491c4ba36e70a0a4807e5a722440ae598a5aea31e6071e63daa05f1086561c4e0246e0dbfb238ec7e8868e0c896ee67909622c9e42735a82c5be09b63eae9d14cedc141f61c74a8079cdf720cbd64b5ce6f496bb3f75845c4063d5c08f6af5ef504c9f1930f041b1f9cede28ca3681a46a47988d2c59b2413a62ba2483d6d8544eb2c24957aa83cd7d88206f78188c6c96b4eeb0944905b1a96acefdb858423ced4f5e690801f858dce4d2ff04ff0516513748cd4418839e7eb122588ee1b09972878841cfb6847cf89c3de2f3de8fd88cd60cf3a7ad61428a0c60fe17a852f2a551b1523ef090e85d9023e8022ec1cdab6a931b6e8b348ed321a443181addcdd4f95f6eeba1d9df4e06695661181e6becba54f97b3b6f9c7f5dde617105a1878dbeca6efa48e225ff3f42a86867c35e9e44f54f7751aa13388843f18887f2631fa2262946b4552cba3e292d2e3fbb13617dacefc947e65dfb797bd5228092fed8a152857760d782c54ef24e5675d7009bdd076f2b4c6c5ef4be1d931c5188eec2022c35929835e13c6a1e45b70f6f0bb290ff326b20ff2d0f8f2fb780a71046338ca95f7af2433239a4365739f839ff387ef50e808251a357ca1c76adafc62d89076695efd961dab4d6df171c293e011d74ac9c7f8d42148dcbb0ee6feac55b064c5ed04d976f3ae882b40ceb2a1c1d32e1b2ebae344fa23c644496390aeade57309e0f1a5a34ed693e068529cfe49f872cd3c51c699be3e288902dbb7c048eb23547b50daf220a8eed5bc732b13a0e8dbcd07c7dc62ea3a80d6298d2d92054e02cfec3eb96deff676dd487c002b3172fe2948a0d750fa5f6b259e113681011cd094601648d57dfb248b488317e655bdd8b360c000b8f2d6b5726de8e789863609144130118cd8b5bc787901b923e2b28493606ec82ab9fafa9e58a3910eb002563f7bfe9ffe497cc713c13125aa83921767b65e59929780d992e2166ea59790e30ab9fae205a75528e684e0fe38ae4b216f3defa4115b8bf342eadb614bf574fd30388da701ee75ee3188fa21950bb0b0350709c7aaa1a548d339dcf0f9e386d05ec1d7a0b75c58e2c625aa32978c9710acaa142dfd050fb16433e37e54d232363593eec9a7c8e04b66eb56cade28e7a4c0497640fd11316ec2ef0d8f880b9a2f0738fdca9e2abb3dae40ce0c06e5f81fb3bae2e1510b53b750db84b927c451088a6e9153032e0553de71aadc19f038c0f36f499798f589cde6cd17199312546b81510bd6b4f75b1614fa820718a5ef2ca77bfeb033ff9d93d52721c24d8fee6437b9b73a26c78a76a5aeef1b1d70b36de5708c63c1b01bb05cd2a9278034c8e70d630679ab44daf6775d2b5bc4dd355983851b1578120011fae723d02a8e889d7e50c61cd85c53696f3da86bbb3c80242eb691901253a16679b04614d7e7f005f0c5e2a17e0b5ebd4a618a91c210ad1c46f8fe9175856c3dbbe68757e2be2d0a7e6c6f40eb91ad62f6e7392321991927791f71be1dcf15a8ba021d5876030d2fb1070b395586b72c703ec9401dda92777ce329b7ff53c03a0e10fc7969562a3b91cd37609b1402680cd3b09865d753afb1bf6c9d42b1b33c2325d2ac8026aedaa1fb574d90d0ea1787796c955c6b1da4cc4d92900238d17fe0980ef2f177456930b0f2063939bf7997a9aa71094020302746885d27ebf7220051dc6f387db4b734d15b6301505a13954ac3c90ff9b6de1ccc244cda55d0ebb077f96d41413d2c2aaead779d4bd82c25b33533095a347a8c35b3d0efc84a8c1b6ffda1849d4d1545ddf64f8108471f5c5ba9d4dd51f8ed462864da72c101cf2e733a0674596871015af24d0c76e5d7729d2a3131720da66bf2f060f52d33dd20a163731a975a0aa2e554ac11aa16bf9524de4b7fc9f3b0547f25c75b133e628b19f6798c25dffe4aa2ed9c65ea5239f999d9ac4778faa1d5e555e761ff86ece10d6988726d3743b8f885a73a6bf085bf77ebf8b19d93bf55bbf2fe4f3a2d2d19f219f6b50f8c0898ea2b538c2e15242089e0b699ce70819cad822b343b7a53b42dbeb05069a18a80d988ce9173f792694d409da9115d07dfd8d6ebf30775d7fc874c3c379fa4687d6e3336d0cf09cb4de2473ad83d90856690295e1af80933b8dd2b4e98dff0bde83ee66197de138800c91f38ae004a260f35fad782b94b6eeb9ba17b8b2198c0804ac9dd6206416cb651844355f92148e4809051d62eacd8a637936fd4e446f29218ce5d2c59360ea1c41ca13f874d8b54ef98573cfa3c019896199670898609cd4eb5780439277c4dcd49a3d4e8c5607f6ff4ec2b7b8415bd0b5dc952c3aee2435eea83b5eaf09ae2c1bce394384ab17e200722377eaa3eecf2c2a3def937bde99128caa3b282a030c13b40293bd9fe613cc9ea7dd2881d901c1be6e4eb036a7ef3f3d7a9fc09b0f5480b234ee9224043f9e9d9d55d8467b92afac645cd7ca79e780af9da116bd85c2802dcf32f69354446774d9cab8a369dc157ecee63fe84841e7fa6ea941d3a0f47783b88309df001e53b604d618eceb172eb86311ceaaa31a5d5497d844a9ac7f3f69cc3234858d7f8f75e02abf74cf4109de9e9a091e8a1cdde5148578e8b580a2751755dc0a5aed8a5e4a6bd210ac5ed322a478ac051125097d877c1b4297d23d134c15030695bfa30f341f148ce1e5ee16f05ed29849e5ee3afbcdac231f3cd48d3098059c941ffd8f8f49586d93ed4efe630256474b5e8f063fafbde1073d8b6c5b984d802653a16c13a571b99902b7e58e9a058d1d80209741c5a4e63d7c5d01e1ff7459ef3dc62451c2da559a5c834d56027c59c37224c980d5adf777e66b9e3ed31b3b5cce4c73b4ccb22d3b1f3e0ac4b7a6bd63dfb9474ca4c8eb7b59fc1267b694ecb7a7f2b4a927de988926a0a3643a5e202ad96ac7b5589dd95e7133c554172dc379fe943292d1a6cf5b47012f531013e2e06cbfd71d1db8c41dc8926f3ee3aab2825fb25e175fb075864fab3c25b6021f8a158e33ef52229cede8c959db8bc04d2bccaaf29a86c57fff963c29dc77af2402570599f3058e13d6fd38b33a699b9e0c1a4763c9e6c1bfec30a77769c58a8eecde15757506a55a583b606f60edb264d13a69c2f7d48cbd937c0d32c96bd8a97d76e4b47c0c49fa100117ec83c0b1c55170691f853d41eeebf05d39895b78b4664e01139874cdc95be8211b05a121d0eeb0f3382af1f6e1ebb8807da889c857b45b8aa6400d0b8ce5bc13b83c8456cc134542b7e60029b18ca90bc8338ed2e28871dd0ce8cec2fe80b12e578aeaab8b55604817d5c56cdc95cf9fd88e4b04760682df50bab94b5b1cadfa988702bbf988d9334395e488c6890ffa472a8214e188b24f81e6c371e9cc7492be7761a0c63b2452725b0f89c29f3ff84813d1fdf4a8233914787360e8f8e5a126e2d37bbe6b1ac956b4377d51248505fc106c57e835ddaeb6566c53d344a2c2748d5be514c1133af25ae9bcdab137c09233a7601d01e65ee2089c18d115faae80377a19f6ac4d36963315ed54722ffa2ae1e5403fb476d891d6ffa6a6a7ccfa1f09fbd4a2fb9f6a4b58f750fb22cc0a7a624a1f561ec667e3b0e6b827b69250f79755e64b7ef907cb4c720ee7f2c1836c6348cd69703b8aea994614d9db184c421396a2bd38d43649a6793894a9584e2749c1e821445ee731e3fadf8c21dfeaa0139922eeb2676957263f993ea814563acb0ea766433c4d15bd75133c222bfc52cbffa923960925e657b4e6fbe0bae49e3546d351d46260b8c9605710fa8af2745d4034287c50ab8381ac439cdae37cfbd1fe70134af3abfc723d7f8382ee9b46555ea7bd4596276eb474816d854e72ae159412dc21fb18404ffb63ac11f6315b3a0cd498c359ee116bb1977ed5df1ff2083121141041504fa4c791e798434e82ceff5085a9363600a1b8d09fa76c491d70afb6659476e5f07dbc7ff6cce289dc264d32e9f0f417dc9a9b0217c8fb7cbf5332a145dd0ca5e30ddd74ad1b72f3de4031d7a7641657fee17744a295c21b06b7052b77d1e3c8a8af2a70c0225f46e57d0c41d6c5bf956bcb211e8745e6ef1c8a83f2c55299e5c57e197fc2ec3f615b7b96a53a3d0441ebcc93ad19d9e85d9d12f72c837123efc2ddb8d719211253c63769d38108d2b700f016df85ae40d90d831b513cbb078275a7e6ce0ba4368a71c0289191112b43224137934575e77fa3ee64a6f662ff22a0fc734ff07dd81e2df46cfa497c5e3a774bca0d5040cb44bef914ac5cd101fd05c5dc8b4469328ae5c13dab8cb6c0241d012863bc18112feaaa37dcc10343e75ceeb2a6716aebff6d9fec90323416cb2e1bd8f006259c27072f6f54dfbd461ca6b778b83155eca90fafbfdefe809ed37a0055e6f86f23e373963f6f5904784f24b615de536dcc9218dfbfe9a30fc28b3870d09330d1f8133981cdc8d5bc54b21906a11e43cf25c552d40256d2d1bcaf4ddb41643c5fe55d7ef638b404608826c844fa2587cb2712b856c4fd6138fda5b6051b4e868a5b3635aa516147d3113b260f768a5fd7314a8b940477d740fb6cdbae0ef1521216ca7f43de8f7b433dd82d92de1efce9cdf14fabbd14f2d2e35ea77f21dd6bd98134e6872312757a1a2a787b0541ad388e22e2748a5ffd6a37af19b0d65361f702932afe3b31111a117f84eb3b774f7c3db8b445f184e5d99da7f07201da2f5fa73132bd954f1242561a53b56d590baba934b4c5ca1822e3e14a2f8736027ff37487bba486a7dc3cf2750fd3c57233a54826f8b7efcf505b912bfcc19eaa60065737e2535bcf608603d84c22ce3e83f21d573d5da601b7e83f30c44fdf3fb7ed92a0217dfc04108982d297c8d44476195c0f7d7ef15123ae733a8b4f91690e948cbed8a803a6b2d7ed3cbaf2baa23f4231d3a4b4a930454031ab44134352fd824c022dca52a9bda3a6c558e760e03927d33b9c55a1c962d6b7116511744ca43d5ffb42ebd72df102950128ec7f3c4768831e6711412dfc2c0ace7a9c8506f078c70f307c288c5039808a27d60332dfb0767255fe297d0c3f0019b3da0a08238365d9912f16d72176e286534df1b4de00776fc7306e6a4dd3a8cc571bf7b451a218507886b7f8713e41f94bcfefd3953d5ed2c7d2daa10b090036a1de903893da8b5a6bd451cfdfb81e87b959412c5f7b2288db68ec75c3b6e31d0167654309942aaad7e7be2ff732ee3c5c927f9904ebdf0541ecaff724c1a0ce3942451d3783615e12fee6600b4021c6f10a1f2ca1e67d76fdd440fbca5eacb454ad574a349f6f45c49979ed55aaac9f515dccedc06b88a73be86dcbc4e5296318f810414178eadefbcb8bec56caf2be0e1e54114d11608dfbde0aeb72d56057397513cb15db635f91789ab5c41fb2bfcd42bb06bae01502f741f7de3fc238ff18d029cec71d069f5ad6bbbdd00fd27a90e73e6ad5032d8afd213404eb0c9fb01629c676b1b5c231f194761233a8032dfc94fde5d9f641533be47304c1b67830ed1f9a836c99b4e98f9799d0f8a4f5def1d5709bfbab861f0a597c98154c28700275faebb5521bd9cdac91f9127cf5ae4beefe8d67e305e4dc3a4bc096b8623fc46a4d9040ebf5c1d7c9f0e615ee9cb5f064b4ee71590802bab86d156dc4d0691fc15d2dd9a24548d36b23b6bc76b925dcb957da32ffa705b246dc19f261aaf9c15dcb75bc3386a924f065d59b6be2c829a1be2c231c017ac0c1f9968e930e06efbe31dd879cd7a62d56486794bd5c5c67a7b6065d2ef7b65429d80f5a381b65c1212c63e7ec87ced301734507218cc67ffb297c7e265aea8a3aa7360673813a1aaf805750cac35e557192b1367a18195653de26ec664ba507736059309de2dbe0892cc9057ecba5b79018ba970e4a4c3c24ec26644b5621b4926ae73411964cf4ba07be78501e9bfcc0053fbbb56b99725fad16a8bc7d343e815338306a57cdffc3846fee1367555eb83a48e84809ebed6bdef4d009f7794c1ed8ec8ce87cb44a2e037f70514842d8f33593d2622b6a766294baafe356e1a355a21cd04eb776cacdc8498f68371107f188d2fec63cc4d04fc0104e2d65c556969ff3ec15a5140dbd7eaa46ff8a8bedeeaf9e0d0aa883f93a500bbd689870777b944c6d6de335b5a167e961ff50ede313c9b72f114dc6e513e97e70281ee56c1a7077b9e5267d94ef15360b909d12ffc39eb80cd74423c558ec0ec2ec76276caaf31f977c97b905ce148f3e01d9e41f514980aef8accc8282e829e6ae26b88c9d5d776a3e487f699b398cd027f4839c2acd7de73bd40c8bf4859e09cfe5465efabecf3cae55e405c284ff94b82458756423a8909b25e692c5c2b07d0b4721f29fb816313c0472a9e7f784bb2daab3b4f259ed1330f279e63f62cd72b80963e5acb371f533edb5d54871da41f16b79c58629be0b08bef060e4cbb8cef2955ea7f3b367de4ca685d9413aa9711fe232fd40d26e6a1e7de01a0e6195d9473b7e2c7278fbbf092ee075400936b4e7903158ecead8436d6add7ee023074e78467f88c9c5e104781d3f1689db1d2d88263586737b374b7146f0d13aae39ee484ca169873d2078f3f5bde5a0ed2453bebda3057b1f8fec0492f8481361fad6617d311ad89f816f1115262e7a83560731e6ad8141ba8502ae90eddf0deed4d8d11d315e6d650307156ef14808506cebbcc3b6193977a090ce7d7f325aa8ecc43f3c603a95954fca7862d0e6efeaf93818a0a9acba6137f0ace417ba99790c6683a409ef8ff01126bcc2e94084deaf08d7b7c9c0c0dc20e1ae6c263ca7a8cdb2d6a8b14ab42fe47b9b2213a6a9117142c69a2d89ac1c186fdd863f47410f17a906c39bff1bef31b7e1f5157b0708768be2803a4dc62c25f69f385a5ea3f45b4e6d5cba703c7a6bc4c34a34210e180b75c71d13270b184619364eb0c732f8acc832a09087b7c0f12e65ceb62123e9ef95531eaa307aa33255dfb7c066421efaf6ff21001c0b355e358751f25613e9e8bb988becda9bdaaf64b0e1b2ca4931c70c1e62f7ceb94383436ffb20c46e60e9e6e4c6475cbfe119bf61c0f3447b4a4683bde8672d8a5bca93ff5797fb55e5db60a47d8da2d4df18f7ccc7de68d5fe90d358053f50765e12ab5feaa98256bcfe437ce0df5049e50e63bc57d5c4cd873dca8a719ef0cd78e6e4014d14bebf5015962dc204a818cee1a8bc1ea7060620d005b3c1e210c67b624fa5c8f98f8255c41c924c1f0b4504182cc006ef79bed8849be3999afb2b3cdcd12feacc6c0e468be85c772a4e13a1c6944563ace9ecc1a2eb9bc6a74795f48a245dde50cf16d3654dd253d6ae64fb172548006c2fd20ba9fa91534f95e7772bdf759b70fb298b4f0f3dce63f56b6fdccebe977f7eef428eead1620","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
