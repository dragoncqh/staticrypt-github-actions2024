<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c21e75b943a22995b84fdbcb45200f5be92c70cf77c95bc68ff017a0b5e0334e87341859212361487e959144edacd7c4ea37690eebd0c0e1b230022b227044581d7d2dc4c4dd7ff2707ca938dcb0509f6d283a08fe9c6f90e6b4607c1ffea013619d7a5f751e360c253fd5141f6e1d04e81baa7fd3a95908560ffa678de4a87f89475f4892068077078dc55ffe0f0f94965a2c5c451f485c66761a969d8eadb832d075002190a8adb5102e324c96487998c404a5c8cc9d766679308aac0d80923c325f17aca36c6cc785474688a6c9b25fc125217f2e56958d34193eda431f5549ad0b4dd4c80aabb202c4d7afd3088e62a77a80401b64da682b1eb5b3bd1280ef28583cf87c1acaa21546e1c953c93f1f370405925e6f145b0e4bac91b5803b0e6b198e9b44b3161e5a9f981ed5522c86bd75dda61871a20d8bcc51a228bfa14d87defa54697dcccf448708ff141647b93031a1366f744eab0c854f9ebcf8fb5e36f3516fe0798a1a8b4a98ea2f9ad444022a97fd8d3a80eaddcfc7d398e3c77b7972f8596e9fef386c3afd0fdb14f1b5fb28540b285d4f6ef082349174a1d0e41895e7d63acd9773d8b5876cb9e57e7a53148327161f4ea1c96372a493f8cb6830b9ceb3cedc61861076dc3354d25bb815473bf79dfa90dab580286276f84ae3494f613fd3a5cf863a1688f1a78e5db8440965386157c7841091f0f99a2987378a7a12ec0dc24fed0927994b454da9a746d8f70404b7f0e0d14c243c68642c92ede7122f7eeff7c6f80939b9efe78345922c43deab515bf922635a1cbb8e2b6659cb7d409a7c11f7f62e9b8c7be2dfd3df062728fc6599463b0a85802300293032e29a8dfa95a96c4e2cb53752a71d5148978f55d4b01df84c87054265f0fa47577d862380ed77b566f19d073092fc708db51d77ce0a5219ec277d5238d0eaacc9888a1bfcd8ca597b013d0a5072bd47ad26ab2c164cc966ecc88640e5ffbcad30209e1d0920fca5af1faa0c44ce8ca4a844f52a23f3619a056178b5d47bd6f3c9cd831997f0cb2e6669f9ee1a440f27a91be8861b4ba7d13459002bb764250153799f44322bcc8c42add610219d2b1eb0574380a273e51c38982b03e5491e1a1a5a9a5a643e8326d2e0872766e25301f3655e2b91878ceddc928c98e6013daa46dc91fa8dc3dee12d88c75106882743d8b97a525c90752ad4b3c56b7e787483ee298d127195d8112ac9ba08d092bacf06eaf3afe41b580abef0ae6b14fe3ffdf42ed09066c3c4194b228587a21d8cd4d0d89ae734ba2501f6d11d470e648c65d4a1dd7090dbf53b45d4923c46c4b9b4cd2e52ddf683767f4106d2b6192e09cffb075f67903deb9dc143b6449069941fc772288c2d296db937f8e62518c3d4d1c9ec3ebd45d11079d8b89d135c50def386843dac252d169c869077bc65495ad9754bd44b578e62c5bcd169825e76aaa6debb5654ce0595f80f7d0ff5b05b559fcfa158ceb143b599d9abec4f0540c34a89b1f74eb354b070bd94400a36937dc35e05ef664b48d64f2af22b5819a3dc14c0d61bd7b04375200dece4cd788abf7c672c1598f1d50face2cac01e3c8c3ec2adfb268b51072db13ab45adc28bf6a7ffe8a7937648cc17acc47f35e360b53a370d4ff7c6a2ae40e1dd6505559b0ac2e763e73fa5a3a59bd6d7265ab6211227cdf0b0a6cf5a953e60f15d2bf9c83f7c8dbe046adb5995a4e6e4ec3d122071d69e0a2ea85d6c2facdc9641270b6648d98a45879b85501f73b282e0854d68d4d853ed648139f4699925bc2b24f41177611989bc03c1f90eb8f6fe84adaa8c738063bc5f211dbbed0f536f3b052bf1aa58abd8de8dfad9fa2ec23fd25f8c0dc3895d83fa3e41ce46c29192bd01fd991fc1e8d04f3ba0d783b94f1e5c045b146f6937647ecdf46b6b5d078e8015bf049255894e4deec4ba8fadee8cb52c0ef224b65b86382f725ce16a9826db31645ed2c20c9aeeb9648487c739957f2b77dee46bdff12152a5ad6baefcb24922a59caf8e3091acc79114b3fa6f3f5272e31e5f8b62ebea628e8cdead859055e8962a80283905a3969a45f0dda4abbc948dd28f9ad78afe35aaf5c99e5131ba727588e5fdcfb4f297d8732f03fab1d2ccdf02e380019443a453c41f07b368f4eadf6d2e4cc323bfbd243ba8a8b93d7cd7968b38c3633168886364801a826003bdc094f7ded5ec2cb06f48e18156be4162bfcf0022e5aee0d71cfc4c74ca855cbdc0743f27ea0a793e998bb95cd43eba5bc3355dd74dc8d911d60d55756d3321717312370d672398148bb32b9f6b6f4db4bd7d7031d85e3f0b594b3a0c627703a3e21f8c165b82a84c5053653fc1f77855bb4df13f71a094d4e453c6048ffc6f5816c94e7cb56e4e2a0543c0d32ae155f84391c8e48cbbb6052d7b994c5f17219800f7fe5735638b949632410e6eab8a31ff0c620bbdc1e8587fe2023ab4b706886cf66aa185dfaae0e97f1a0df262ef1f0ce5c7f6df4179216e7535da3e6bbda0521f047847491cc3cfc49d7e1a13e6a1b7ebc472d5b34e944041bdc5d66005ae81af4033d847aab53fdd69afd14cf6e8247797f78e48018675e749d92b70fe8423f929a3a6987b860ffcfa7b103e3fdc225ad60739df9be9af3b25dff2bc6dce5a50d19786e3f84d42099201c1da8832360db270ce5c67da471a0b22e242428c1e1f076c4f3d352767cb160799465f98c715faa88284e6130aeb19cc4c9586683fa2b8c43b4c8d5a73c51d719813f8c7ebcd7595100fe8c51f6b7d39c12c1fbcd956c8952dc26091ce2bd9a093de500f30368ea0e86ea2a00fa3b56323d55d7caf7e3181c7b55d07e21a5173a7b0df2f82c5abbd1f41c57acea83f8b03e8b60ed4ba327db80a8e27992e0056ae361accb253b234e4f82e1a336d7ada15fa6273957b20e8b6baddc61677af92e38251494152478168548029cb1abd074c0daee73dd75b4f3fcb157eade6ea4d9063a1fd572367a141fdcd8deffd4952fb66753f82f7154a793165fbebb0d556874798cad05f539a841a64aa066e99801a23cf7a4b35c7870e34f735a153285187080441d9f8b33a9b15390528953a4272425840919092f132752c7de760c85e8bb369138fdaf47236aafa81c5579c478d1f1dfb0c9af8aff39c8baa9c9266c8b7f9b6d78d275dbaf66c47ba5fa0467f3fe39c203cedaefae4041a85aeaf183aabd0dad0f4132f448d20c65a844e06e63d0a109dbf30283af56b0efbe09e3dca3e6cd7b579c136e642d2b5c270faceaf686af5a23135273fe22526972966ee863e8f760eabf621fc3e997611f285f32274c2c0adb0d7a0236501b44e125c6bab93b9583b93e2effeca1ac498b71c413f39719660189ebd64607359d5d56503c80220d816af79da9dcf0fbc61c9f9f843b3217600f3129afad9e0506db2dc0659b09d5d7991cfce3ba7f6a7a33a94f5087d1f748e6bc89c1ff6f5928e48b9661f24f2936fdbe6ff1c13efa7884fe39fcb041f78b1446d4bfe8a0bf21ac35c3e24b872ebbd207c9a5f712cf0f8f947ba1196636cf25cf5958e907a8e199ab256f92266c4f63a1ab1e7053466bfc69f802846d3eb9c36e767be359c92e4417809b036704a1c170a76acd473dd7f2af2678568450b5b109ed57450e420473196aa1e708abd41dbbc63300ec1a2ac15feb90e47eaa94a90627446c7b270e13dab2bb5c612f0f8905d894851ab7c37d367271a89d610e69eb361ff4020d00cddc4551e47e08663289dad1761d0b4760980b34951c06eb832dd99abd07d9dceb237e9160b070718cd4c89578a00f57fc9bec9311b084df9be69aab5517e00ad67fe052e272e6588cc6e2fd6f9314750d8cf8b1be21240992589c654cb076af5b7a38d91e1e8a21827583b8502da31a9f1c0ad3f07e8b87f02a1e074ab4ce06e478d5599fac203806063d60a7dfeba96d8b1d6dc209f771530b017a97f743ec6cbbd0acec4f1c3fdae38a27f7a062b4f8c96bea8a5154398ef2d86e9290bf6e37f5c1aa285e02190276ab6f5735746d175906e75a7fe4fe92017cc05b7d3d01995e60ce7f6ba777ba90ded9661c1232a644f87d4b4000e08f2c07b85e633a03ffd3e07764e53e88dc13f96a204861796ff8645b53173f2daa9b1ca185b6017d6976839db9a95fa9d728074b98f1fb3426272e992e82ba7ec7720454bc5c4984fe44d98b5e372c5addde810abc36727795e421413eca0f8f0f634b1c35914bd60032a2bf4020dc34bf60692aec93e6ed3fb7e437f94440c25b5d28e2475e4af73b5fca497113a442a5186b55701efd1838c7aef5a0ea5f41ffe1b6a4cdeedea5dd3b6c9565d2117b4e65b935d61e7e3e29b0fba9676a01c2fdcf88232197d084015c6ae4bced7f8cbcff12d3f86b9acb8e7d087de6e2b71f134e8ee9ab60a01029922244844a239254bad192868c7e120deac3e8bb1ee6447990570f3ecc6397d03db6354610dd001761b2836689d7963d5f88dbcbf7150abed2d11111a2d2e00d6dac61b517e9ea5da8b353e103d22f68c6fde8b3329baeb61f1a3aa267297be83a920dde3abe5fe484c24ce75f3d7bee3d66a431d9619b348320bf1327bf14c9b8a58acd11ac88d3fbf3c092c9c015c247c7e3bd605c72836b20bf9645df6da8d888594b5a4d6ed8a820105cad5211e9268c166690056283abb04325a99021622742ee69fc463d703e1b7d0ca423ad5a2b8e18a732b3000a97954fdb7e2f783606743ddb8a121a92c45241cb34b479079ad0ea52bff79ee5a95b6099b354ca5a081e77400f1010412f1ec10fe41f7541edf60c2fe5cde5a763f2a1b211ef3d21018a6904c2a5251144801b431158442095de0e979d70af2033463d2c161c971fc796731867f5caa74bb95a3309678c2dc085d07b9e148b3992110a0aa3d05c12490001df85fb315da90ef53072c887fbb58b741ce69c04611970490a69c203d0db7b878a90996dcb3c9109093d1ad93a75c965498718b7bf36b88778ec725415ede693ac561310d994518c3b1e4a7dbb78f6dade183807bc4e555ed96295a2b0ae8ddef7d5db04c00f0edee975f58eb5f5f432b8119158e633040187d74ce60d3453360fce09217d67fd4a3c52577b5b2dd1915c7105436f11f5bf89b1a2dd59fcc08b770fee7b05d099d78f1805eac9dde675a142137b4f38fe1f3cfe2ae59268cfaf702ffec4be7a24b33020c1a256c62a26712312d6e6f57907417bdbbcde5ff011259cb9117eaf42bea0d62210d2f8e9f6e67bab62c925e8864463f28b394491a635d786149408ddd9c566d909f438be35345948b961a1921ad2b56b3aaebe3056bd0e7e3f9e1c042f17d414f06e46a191fc82f7def039bcb793b969128a8194bcc8d093072e2ef64bbea3736c8d18bb51ea017add0c1d1da6f3cc54908cc290968d4f410bf9ae9b8f7e3bb8b8f67bc38cecf4c99fc0ee33ad760eec6246e08d5b15eba18f66748d2c549a4e226fea6bde4751c40f8cc75c0f2757857f9635c5798e570c546165781746f1e9d0fe45d276adf46ed2dac8b8a373ea6d1c06945b0efcca27415d13bbff967cb70f13f5a8ad339353dbad4e167324aa13f3040f242d399ea0a3db20e7661b295f71d39a52dc22ebe6944397f30c9e14b75115233f3bd9e90365c0a45f5d873262c2e1b018722a0b5b99e343f30f9198de8152a282981917f1c2245a0d90b9cc7659b8abdac2d9676d60c0912c4c2986ef5cb7f235173a52c465e6d722f0e4cc8d0d55f41551441ce44071522a32073ca672da783b9e07898d0cc8aa7fa996a1c1f3e30ce41cbf5f25672037d9649908c876db70f67eff2201904bc2edf0bc5b4ac34ed7ada059f3d15ed30e289414aeaccd23488d264e5502937b587b0fd4a648b5f0f0b2bdaa63aab76b47e6ed7c01c3a2d276d6112ab8fe9c79cd91866d007b2e02914b9f9238f97a03a40e026331e3f14597e9ce8d0503c8db37587eccd8fbb331c66cbdc6231be21b87335dc2585dc68eb9dc91c4b4a5644cfed395efa474f58dd5fec64b6c83b3eeb521f05f4886767fd60b2b2d46841e45730ac687aa199ae7215069d24c17e5ed59576529bfd0f6542a419cfa6f453a73e32b040c3104222011d597c7a0dbfb23d392638e629d186b3dbb0de305672adf694a029caa1c9b3a4d91418090821609abbde4fbce769ea682f7b63d66cef588935257c21974d0fb4669244ef44d1f05fd5b600846bc09f50842ebf0a6b531d2d7986e74aecb8cdc3b917b24e741dd9099228abe8fb3ab0bb03ade15152d3d7ccc1ba9f972694aef8a2ea22fc5549e66078879bb05d6385ff0e241e66a6a4c6fd2cb0ebcd3e0498291b807dcc402f541f360d6d97536c4f58fcf42e63e56a21cc2fbfedb034d66d28a240f5e104b3dff1a9be73523504f4e66b01c191911346f6d7d6f71d8e729a5a6148666cc70e10284386cd47da6db7a7ea9435d42506d25163671f2f6977950954cccddea202adc9126862e2bc89fef26ffe3880d4caa4c5efbdf687483686f5c5a704bdf9c69c334e8a743bf0111a23378885d188dfeea6e0683b4e961092d076284948417ea56296cc8c8cdbc9bf2e680f4be4778238d28a5ea3aa6bf82d74ddf064ffefa9e52b67d59436767d126c50acdd2fd86d66bddd0191fe07677d08032c574ea34140f2eb33fabd0f9bfadb2939adc52ccd8d843c7aec31913ee01dc39f339085f310af2c61d5d3a8084fd4d87a7f720fa40084ee74d4a4ba9be3d1af02f61eb41f85f082ff6d14277bb5f4bea1e50ecd43caa2f9e179bdbe93e05c2fc38e6cfe2163625670375bc520af88549f88b8ed6cb18a8ac091ef6089b55752f8a0408701e7d1b990c1a43a53a537de2b25cbc13befc97ddbd4385ee614a413551e5336cf801774dda8f76f8dc7355dca5537aad781f7863bfaa86736b6c28fb2de2ece06c14e4eb1184da948a5a7efb51a53f4a7bf032de171534e716d9ca88a36a67df178520db8c0e9b59ebf48b44777d36f2edb0810ded48383dcaa3579a7673b779eb7e602c5357f37d8862d71eaa93a01b68f1e783d7c02a62c5a25cc494ef3b58fd53d25f9c5c560bbde94c828409af5ee61656ca083db71bfc57070c454e9d154d282ccef35c4b676312a8da33a991d1bc5582a2ca1781c41aca01e415e32a6a39cc1c1f685f19b182fe4e96804557c5624acb9d54daaf2bdc9051138b7fa8875cb0ef4dcd5fc144bf3063bc2b198a754399f3ce6ef5ee87b41dff15eafb35a374a914afd7ba7643c7518337d233731e02d65c3caa7787f8480cb7ab648a1c3970525a14a6a1f8b67c6e4265a0e8f14514af34e75857ebebdc1cb2c2cd7df5c822858fef11ee2aeab144d72845fc4aebbf0f3ef57c77b36b0876dab0f502f07328f72f2849e384e6a7c65b7b0d7b1da6f286c60a8de50540e8aa2df10bc99cc7a9c10897301a859ce52c764dbca89a20b7a08becb21f4c7d2a1c7d6f5528144ac82411368d4dc5f954243d20e70de114b0dddd7faac7ac88c22c80957dd90e3975797be88f10f3072bfd38273ac138a390db939a19da0a4bc29990906105ca45210f2c90e452c371b7249607fac92d1e981e27df774d217d326743b16f609885d5cff403e35b11b99a90cdb2e3c479a0e398643f4adba4c335a80476e1b6e8988805dcda685ffb3fdb0b1bb6978fd97cac1e681dfac24f428671b78163209158b090bbd7593ed36298eead9c737318afec88cc6cc5d088243668fa65f35e367c0f6de92701f0b91a359f546485a6be9e658013b5706ac3af8cd425b72f2b5d85a6aba341a74afb1bf7e0064d3f90d077e84b6f56acd864e9e3cd3045c4b68cdfb88aace57bda7db14ea4f8ac4781e74a05dc352ca7accbe8dbf7626928af6a76bc4d148115ab0ea667a1443331ced16b2b278a77b25f59a78b1c3fef7c6441406f722dc88b159d4d6f47973c988ab89e751a6a899a86de0ca1deb5e5df2364814bbfa34d40f1877fcd4e34cfdc0339fa3af0601b46383249d7f5d4ca71a791bec8a70d4d74296c6525a4288180512bdb8f2aed2a1bbe791f0985b838963a3caf3af2841bcc155ce1cc27ba64d9e4631c2942f5297d591929b5226f49dbc41a024aa0bd132fdebd9705204d98ced265d5749899e72128c8a2fe309e6105f321b7d43fa88405e1e217d30ce0e558f0c7407370d4c383aa3a60ba5a2b80f3f576f5f1b65202748384710db4ff5983d8f79dcb38f1195c0552499e5ab9c07acc324add536e40f2aae4e63294ca75813f6bee7ea9601e0c2c40e3199a78e35e073a387e5737a39ce3818f3396decfbb77a8457fcc9ff8f67587fe59c4ed7e650c3d7fcaa059873086a4388032e580bc2d4a4ca0ae409238ea749af4aa62cf9f2e758b1e0bea7b4ae143c90d16d23e91a2f2e5755062ddaf8904bd0c54f71b1117da0630701c2bd828a55df3492f0a9d5d63d7579008b69b4a6875d377acccbf9857aa8bb6a69fb991e73878678d8c6b4e2a98d37953d0524f67503faa98e80f45a2cf5639b28036aa36ac2f85fece5c3c8b5f502863538439eacbc5d3b4a8a1ab3665ee7c6af8b71569bb6c32e41c46cc6b2bc23f0c82e0829349cc620f15fb101a19b24911320bf30c3038e470e50713f2a54d21bc9c30c26300256b503cba16c34e1a37d0978e7a5752313c6d421552fd2fd511210d033c80ada0433ea206aac023d53c7750271c627eb99e9e564c3370d163f8dabef5e89e80c62813b9788cf0dbcf23527a0455d0c6b52678d399a6b321e3c4b4a49b37b7c858cef8fd14655876c87d86f964a81f54772244880d31d52a157a510ba1404e51c1e8410c394522ce927169a06177ba9b96f6a806edb1051d3b631f44650f126f95965769301c4ae96f3cc0bc3043f34fa61fb3438a455998c901fcbce741c766b74a48b08eb1c38115e9c2a78b99fa3b636e8f08df1b5118d87753eb5a9387ec5237424375eb4b850e624a2f829c99320f8daca5b81621522ca6b5764bf92237c1b23b283224b4bfc655d07deb0ff5619a812f5c677f0e785cb803f9bf84199f3669b429274cb1055ecc53c36e6c5338198e4c492f0ac92224668c9a47468523ab2e40a22e0ccc919cb26b9980fbed49b3836300aed7793d35d7e33cd0021b5a5a5c348de645cab9b2d280ec36d7937205ddacdf84a8f8c2b13bd8bb48651c38a2e456a99c68795cc60b070f77a1175a8d9dcb284005155c18301845679a50a587ac28012c86610554d6acc3f7a7353ff7f15ec7c62e26fd8b5885807b21f5462bf8fee7be295fc8c44e94adf4989e2523f0478aa5fb81aba8cc3dcae0c9a8e1d7a410ac474e464e37d7fed4e154d0b628897ea6982107cd4c0f5cfba67f7c4f82ed21f3547b5301adb70dd8bf38d2d77d0e0ea38f883e08dadd90a89217d226b1e55351f8c9c3947511de4629f0d5a26e4a511581a0472c6a48b8978a11f013d83636658854048297960b86ffcfd12b5b40946d597e8d52affbe637185677e1987e0d5c858f4be48f19dba0f60b0a22c796a94f07d9c240988b2a2521eadf6f2ad513c3a09c2ff627a1d277677d9a2393a76b59fd841f5a28c533e6f9bd2c083d9f4e6c9048fb2178a87e97274b08e1b729b598381fa06679fd10f2564014d115f4dabff631f7b0b18b2ef7da3a10a7343d37c60d0a501f79b082eed08b1222ee330e97f5da84260c80c7c318a16f4458c5db56f64659bd78bf743e13a6ce913833799d0c3caf4e622ca602e8d7fe226ac895833824f1841c8f957ec5a196ba96459bb17f8b5a2098e7ef6b9f8125dbf496929b6f6925f29b83b288f1e595586554033033b7071e32962ecbd6fc4db81097eda74a573a2da2dfeff156047ca803d11e31ab13b2cedb2fc6e040b51e294a0e7c6dbb4a6a2b36adf438b309317bc7185d491a7930db43e2a8a19b550af062e0087c6088dfbed0b4ad8d0194fcb63cdd9cb880985231ad29c9fe0c961351349b02a7f3aff3280e5561d1b59c702d7594c935a568c6b81cebd7961b603661c433490c4fba3417f7f7f0b49a6a452c27039cc5293d57f2043f5b8e7c084eacba512d8092a2c99373c3dda251120d0fe5aeb59d6cfe797e65eaf30985c87d1d5979646fdcd43aaf801482b15977ca272023819c6ffd6f25d1d10c0b72aee559e233c9ef68031cb819bda557eeff641761a68ad536c44563407fd65857ebebb1d59086eff634d5d94379346550a5097d07fd124b36150fc6a92b84be8b37d07944f842f92e849f2ac5d6cfc7409ce3bfc40733882a7835cb2e92668e324cef734916435ab5d708a836a044974dae35e78df2f06720fa14d98f8114f4b6132fd755caa942eac15e8ea91f18c5bd263e01e2a6233a7792c698e1a9127150c375a5f0f91d84fda78f1bb193d99a1577ce2fc29c168b1cdd5e79b5822ff8a7855b13712eb720a6a79b6cde5316357d1834145f95d8e51edcf115ca1a4721b18e980947fb3cac7d1062196ac00d2a9a97e3149b28877d210e42e8df363cad8a3af30c210ebc16e0b522340d0af584343940162ea2088110975d7bf8c39f0566aa88226a65fc1e675b7d300cc6df1d697ece6d4ad5ef5dc4ca44691ed9a182710aa47b59e0bb570de64f1b12397af0c6f5905912683e852e91d5b60161d57335fd36c8612011a0182692ce5c56f3faa58e8cfda47fded9831140ce0193b75d0c60cf1ac5f19ab5ff1265d536df7569de9cd8289ffe4d52b6dcad6493e18ab7695ef67161043f56ac3626f21b78995e8a7b1665d612705a010c5dc8737af3f13cb6d5d32666521a184b0b18485d7818940463a77a5c6577716b75b85b430eca79fff7c4935f08fe87f8ebdc962ea5c5dd341ff9a763d8f437ba96d11fb8945f541caa376f9ac1a5c0bcfe5b2969e3d6b834eaa23bd1f15c174706a17e81b44d816f39820cabbcca8170ace45151a42403f2adb0aaba43288d083610a87cd5d1654277c74a493dabe18c7b353a976986d0c83ffec1d4f63bfd97f265e2bd064a3553bed4b474693131bdfd94f5c1a4ef921ed77702512383644d4f2bc223f0c0aa0c5cd8533679cd976a6af09c5ed1f9528b0e5aad795425a2347406e81aa69586cb7bc0d4c833fd3c3c10f06972b49c6525b07d46e7403c5f02d80aa9810b03a0871526245e7ce65f1773a9dfb002783d5534579c3890ec7506c84fcb3b03145760e4e60b77bc6ffe0554f3de88cffc592463b9c381d77a4987345dd1411da9be8fbfb26bcc348e08b0a3918b55d76ca93bdd29582583e82a1b781d830b7e012d9abf4ac481e80525160ce0028b99e2c36b028e059d8a7ddb0589482f6441cf0fd10a9389b2d1edfc5f32e12142d51c0c5986bea171fb5ad301899361776404cb25f0cf478a4e7ea952d4ea3c7c162fe02fa74e7f0cac5d2808f0a611402abb8ab0f885def048e8c200afe42ffec4f67d6c0d0860cc7beec3aaff4c3edb2fa0845c809247e24c99432b85ce90637a845facd49c71bb3b8e98017d61c8e921eb3496249e2dc2e347acb7f4faa358d2760519a9718c8cf47afe317755cae545afbf67321fa337a42db7ef231d706e6cb82f248f2ffea237c3ecd25f41a5716faad982da263be344855f425aad26b8be95768352553cd0211f8dadd06835c42bb326005310763b2fa7cf4d82c9f3e479afca5b56e569cc2f4cd524e4b50082cf5f6ff427e97c51faea785264f107a6a37246960a05b264eadc75842d2e98f91ae9d2fa9d8e0990adf07b2f03040e6c1a3ac8218a003f5d213069da3560e7284182220359d3cd3656f25c293f77cb94e2742a5d81db4144c16bab27d484cc92250dd62c573d9a554b641e9b5961ca4d6aa9304633a051fc21cd8ebc4b598c6846d8b1c9eb74a86b3b460151154ae0da95eef588da3e48cb847fccfd6d171d0472f06b520da356fb8d92bfe49c17399bc2c4296da1db4559e0a5fd710d643e0e32f5e0e7ec937a83822cb92826bc84f5008e89aa6f376a13a62f96a29216397726d42c07dd49c80312c25b7004c4180b0fd9f433246ee572f9849820322d21f840926466f8ca5f627bbe9aa548084a7c0e48756106e5b1a5fde2b2fbdc1cf845530f2587d91c342cd05efab74a92b60279e9bfed644beb5984edc10622639ea278029f06c6be633fdf5e23cd0a62eff40623b7f2d6c9eee8c8f947f664b13bd6a1d094e6798c3b17e655c19e2e4f791a34789caa40f9c29221896ebcf8d0b14f45c5a6db6ce8ea0334fc776b14dfb7caa9ec0b99e904332ef212defbd9ce2f2dca790fb990c277d4b5a6b973ea46afcc4772c1c2561e6ea4767757681da880ca9cf8e63204c31e8d9f987ba55719b0869cebf8c60f94522a9d9c2fbec7cd463a3c1c908b80e3b15877d96839ef2262c7800ce13ebea7f8dee7d004b777f999493334759d53e88a548e4c55a508adac87aeb271f3335ce673fe3ad875e500da1f32c2342f56f8be565d606609595ec29de5c5830fcc0940f6d57b07cad3d6183edba5074268aaf017d87252a60a83cd0ddd0403bdf7b5838b783ba6d2039ceb1d3df7851a5284f3b6786fe0a2104ad46e1e0a6cf7b4ecc1069c3bcfa1082016da7d2e7970eacf76bb83232c3624b2f6e9763cfe91802158bfb3b0b894f9b33beba1dd6fc45c99dc70985c405fbd842f5ece58354e590454a8d1538377e499ab1d46bc3cffdfe52378c4283c3edc52613b42747013322012797d710a3b3b46eb843a8747e4f486d049bb6851c3d5f99b5d68eed712b7a0584d8a69e7cc58867bd6a391bec72f5453c379668ea32135aca8365b0bd2b6e2e01f53e935d4d8b6422fbbb233a4031d860f8499b2e59de180bf5497010d33c29673ae1cfbcc434e7242feceb7d3c18a7d2c15531456b1b201b234cbcd14cedf50f1125bb4d2f6a3b72b97ccfccd21b14a57b6a0e48e89940cbc70ec73508103a779015e52caf74595a1a738f077f7811c40750bb1e71c1842ff2f460dedd9db2246d1b9c801339010116aeed42f8ddccf575f958e18dfe2ebb91ea86bb58c6cf139a11957e26981bf39fd1b8680fd726fd89cb9b3a8dff6b0093ee1f2e91cba4c4c58d31cb7e58be8ecc3deccefed684e991e3fa19a3f30de4200dda30f8f6122da5af1d9fb5666613b546ff02ae295888da4e5ce198bdc6134cb760fed76846ee06c600af8d5df06d06a2826326dd3029e2f6c531693df1ec72af6ee18fe6bd44573ce6bb50251a7d86d024ebd889e4225ca418b1603fa1d5ffe024e3c59872cbca9e83595f5d14906083140d8dacba65c80111f14f906f517ecd3b9d665cd8eb6b0d77188f65af21deda35c7f98285155351c25d2cd0f35a2bb45e7fe55560103af15b5fa61288dc14b4bfed30df7889a360d02b548025082c180291ce6b5ffc0b9a025ac1250c47d504112cc3ac65f95ff41c8a3bb05db2006d9f05c2568abace9184d0a6a06dd57a7dbb6ab99847483a87ff4f067cf4faa55a010694e3881ad308daf3c6a2900ed90fb03ac3f12f766adffdc569ae6a65f8f776e80855f7d47fddbc7c51352c1ab33f4cc327cd4c4a6784776f1e610942844d4725d016f365569cc2a776e840763dd84c5fcebb2ef73dc7610f0c071f94c65bf82c5b560e98c61f92b6d0681327bdf5c31407881e91b85b6dfcd420df05566e7f59e186adb68d88c36ac995ba27d9971ea5256e9bedd74f444ecba507f2c9365ed37a98b491fd1debc08bfbc88c60e740b71dfcc6caebfac6cf17b685d251417ea3c5320a310a6a677a5f7337d673b41123ac0b94429a2cf3208844e5a716f1bb445596948f1379c85bccd460de90736078b7306b06368b397a2bd1f0919234900fb6e44f742e0cfbdb04dfc881b90c026adb7283ea6b33f2584d236a7c5ea178afce35de806bc255764cca302022273d277c2d09c672f3b0e96e79d48beb11863362375f94de79ce1d64ff02dc535ff576e3d84d10fbcd1bd8e65ca1eb37a064c1a370fc06a1e009f6acd47940f326fb346eef8ce11718601e20f15fbafa104dcf411a5163322251105f96fcbcbff3c6f7e5bfde457f9948d43ac652073b9215a484316c1015e899fb1243591299d16c1541efd0bc1bbee5aed2badd1ace95778a9da58a284604a95c030657eb69ab7d353cbd7a79051e777903c82a815103898970118606d4f05f0ea676bb4750a2b9d30c206a5888004f4e0ec5676f1b53acb0dc56f1edae6ed845ca10c5e72794a06329666260f6b2801ec40c54961867656a71c9c19a7db9a6c4804e435c21c64644b3e97260899c05ed701e0acef32b31bf5cb6fd05c64c81aca96e12ef88ac9c489fcfa5f144073b071b0b6c18b300adcdb2c6b3999bdafce104182ebef03ab899c7c7b9a8e928f78977e67293b82ae58ea1c6f4585380e949032ef613d3c93f7d3ed90d51bcbde9be9d999d9fe5f72d89c182d6e609eb32b4bb369f8c75db97e765be21cae6e3495d447789222efe26d7c7f01be273e1abcc2cd7711533b86b3bdfbc35a12439c3729b04e34f971d21c13b5984c3e662be4df0abc62be02d85e3a9fff7d5313579f1c2d4ba481d972e1da83ef6d871e87e6c588ba2802715d597cb22a42c79584333410deade608ead1f8616c4a11cc73b4f1f9d23f7a6143aa8c101ce1718b8ad4d5d476deeb9e2c5ac51dc23de4c6e6b5d40a8571e7455d1e5c00e0acee09bda47aa0c0e338c2ca032f01235160fdfa1d8e51f3b968c63dd8f6a6cc7d3f2f5dfbba9329c2221b103cd49aea9189a7d1f3d55bbc965e5c86eb4a269151c2fb8ae17bb946ae8493269821f2c9ff4e16ee9eb0e8e370e1d190bcd0699517435ab4d0dccfbbf22b14f97d202954e4848e358aaa70aff5ab9c9d35f3fec790afe0ad5421cd94ca04fe1739317e83703fda1bdebacd4af0e78e9fb79887def0303db0385041170c518a844d8cdbf2a75b03cffd5cead470e3bbc2e09f5819904e0da55fe1fa5b6022a88dfedfc7f078ddb5f8330f6e9bd530eec4dfb1870d3d6f5c3c19edec15919d50b2ff48a84c66f8ce64f2aeeb9ba4c9a000a28642bcfa05b49b616e0fad6657fd114c6e41b4b62736f40cc303ba010a9f2e484c9f3f99b09e0edce45214b485716512b0403f9b4cb65655252bbde77a32b115ca146300d3ffd3ce33695cf54abb8a996e33cc5a21bcbdf30366569c3a0a1e88d6d072b6b63f9af8fd63306c74cbc45f3eee141d8f4907d174afece8962a7158536653593d7f4ccdb99cb3ec3bb430be7419644b6384577a51fdc512ebfbf8566a2f59f365662e819fbe951ab1398dc272cc68c99bcca4928fd5b25813e8b98f79aac183e8faf3c8fa46e9298c11202d290ad272eaace985f7aba516bbf6987ec7ded142179b37635841d1a099d8d0d539fdc59d11e0febd685b1b0d0290f4658b036a79270467e020886101155fd10e7ac27f85c6cd43184db9f02b0067b88bbf830d31d4062ba6937545746b6239db05775518fbc09853f057fd22228363de0f0d8e3915e93127d2d87fea35cfc99f06b115aa0b38cc631d06e35d401ec0ac5f4986e1a3dcc0d6e5d5b4b1a0ed608b9d000859e03dc25a7b8c68fb3ccac0e8a57b9c9311a086d5fbdc3bd37acf5e88211eed9936ebaaca9e35763e0f7006c6109917adc630c6963df4c710c576bb64f1ea6794a8e5f9031f8ee90984f18bd29dc2b563bb1f12cf143b3cfefadab634842e338f6b981593bc1bef695569b22f204339c37d9187d24302a6f9c48e48c9f2f5179f80c0824e0efe85648f1a169e441c51700dd6ed3bbd7e5e8975fe5fc4d5a35cc88c4abd9068cdfc045c940e9fce7782303bb4c560be7480f3b1dbf0e4adca8e3a08d9a2142a7256ab5bcd59667dfc28bcee771dd21eb5783bca461d20b03db0201304f9dbd65ec2b2572d7c575782be0d47e1f5c5f4a3cfec7343b7e00eec989b70f470fe1133c2d4b232a198c0a5122935bd70840867185bcce035462e6748d73185b5f180b04762c9e459bc67750441cc4c05e286044db72dde7e27b5a6f91fdaabbb50a672c5382d127dff2bb65c0af3cb7707fb37e890a5cac2937c974100acda6a938e543e31772675548e5e0058a18227eb2b416123f7a2272ec1368d6d3914551a330d22ef82cba64a451263f1ef2be9eb2f6c911d309067fcb962a350ec6fe7747670f1b30554c9e1f7e52a8d795c19f34b7aa1c8b6af2d60c09fd363650afcf285ceb9c15fe391dc7d7772fe2ddf4da070d5ea7ae23802c3f6359f9813651bd5e8411d5570485454f0fdd72f993dbbd97b4d6ae1d2d4c81fc9d9cc76591f8b0c9b962f016949b6878317e89782cf24ca0d91c0a57a64e0130da897ecb7dc1ed7e5bd27bcb070a25d534134b5395892c7c84aaeb03c101228c7809309cef2a3c75298e1778c348b7006add07e2e503883b41f02c4432735adcdecc0ae7df895fe815f868fcaf91042e74d4b33c70b1c7577e6dc8f70ada5e138353c6556e84189295cd72837ff56e5b49d5dd52510a9ccff25575bc81f1b7e483f74c5a1d1ae2e5b432753b29c0e0b4fb5a9851c463b249453eb03e125a774b85223d297d9af321d335ab36fd59a8563907154b0fcc8980413f941e5e5ada3505c7e702245bc8a8d39c016facb91004f37265911777f07e4ebac94266646aa97bea477258bc178a471755e55c495eb020fc1be1bbb62802bf32ffc735782fb9ec32d587c305ad5a76bbe585006f6b6b59850ee0a0847d282fc6569e83bd2774bbfcd2b84c883c92bd13090e27a512fc0c864b710eb7d1afea6eec92db63e146d4ef5cb0b8d91cd6ed554b9967d6bd7f4ba8bd91043e7e9ca9dfe8221f952c05488aa7969c24de93ec8f7c2cc8d3f8f3ac79427ed7cbc1a3b6b6d97dc3a67794884251337a41895eaed507e594ec8bf3d211569cf56f9fd97a9fcba376ef07feb9d645a6c8cf0502d7d8398548fb623289c428f91899601cf0787402b9b0a74188dc283a640bd17a3096c332eff570cf59516ba92bde479051daa36e5c275df962e0580e8eef0b9b5e9f0e5dcfabbaf77e024a82c01297d235bd052d7a72bbf31374285782c96ba349916c62ad41d7bbb89950a096ed9901d141fe93a5d923512f7e786e1073b824efcff463a97a3b99e23997a8654d5c6c9e8e2bf4afcb21851e3b6b3e6f31c87c84d7efc6b4d22b2cf681575ed9d6a63e6c4723805f1d1c1d5e717d17a304f00967858032442784c5a18311f6c827c43a18fc69974122936165920d658fe46c94711d530004ac811a806223641107e25338bdde3af833ee8ec0e88961d3ab9c781a1a89d64aa4746fff1ce04348554241ae2ce67c585adc5cdb36f6c603e2c3e122371697b11713af15381808816b8ebcb507a8b17750463ec89a51292c57ce5cd0ed96fecf1bf3a1555a254e5dc8f3252ac5f8f6dd4a2596611667dc5d9c01f58e4912bdc14c8113f661f60b830c7d99edf02b1d0c2732bd29bab47dbe70d7c3939ee50dbf9d4b63c3b917c1430d47757833f4c73977ba09948048e9509068f67d898051419df7c0545cf183c2fb354e89543cde5e943c271b4c153430a1f7c147bbd8c5728a2f1138964260ae6f9e6652f63fe72e269eb5a0bcd2c9ea31aa1e9d81c04d813740c7a501e646da27318d7082c0d0b721aee2dd7749c701919ed470c810a5e5925fd765a4ab2eb8b9a9640e127823d5013fdba40ec7866fc3461418959c3fb5a05cd2aa18ad9e58a641db9818744a61c799858e57bfba38201ffbb2ee8edde973b605fbde434a5f806fed394310b356fec2db215fdc264149f6ec3be67b11a0ad385a5a2a457510f0bf8e166dbed248aaca0d782a18a1d388da55374b1c000cdf26f67a20e70189b7de4c1fddc9f4ed4ea231d96f5b2d2dfe92f40cd7472528d06cbf36e3e1769a108fd105d97414425d7caad75c33b475370aca1359ac820be7e0d43bdd4e79406c0b58f37a4cb12936f11597cb4ea954f27c53df7ef6e32a4b26aaa9f4307b4a18fdd93133f72a2419d8de9ea6c57622c101c62d095ac1fdab75ef5da6de07b2b5b61fb8274eef7450514343c6df4060ab9d98f943ea1b0a4b815","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
