<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f6d19c74393e605c4d5072bfbe6c5e135c42ca10bebf13316bac1b9dabc09b0d7cc0c7254050b7b3df5d116f830e042ddded0e90d58adc2ea602d97c397b471552b98db1686682738547051554ecd7b86883b131bc898d2cfbc7fea6c27130d3cd33e9ab5c6962d85e7a8e1d82b217fa1e941db74c567fb5a9969349efc1de7a9ff31c12ffb45aa1cdb24ad70eeb1b326837be72ca2fd8f34dd0c4d8e210e8a08da67d7ebcc404347167c358122a61728cba7a22869710db8a1aebbc5c7a9bfa6725b37e54176ef4b7bccfbab5a6b932aa74f6ce042c87bbcd408d3b62c63576f4a01130198bfe9e6a1d7f07fe83d6ee56fb341c82943308e154af49e4602436031d007758ef1b08777e8342d7cabe5ab30308c1a43bd4386888997229ef543cac4050e7de26fc2aa858b73578d22b3a56d4f3940d9f11a9e77bbaaf78fd3f7b0c986e053ce811b8a5c64384785a4e82274823e1ad994383e165e650a3e54f83c37f77f2bac190741d8b071bb7305a05abb5fa7a6553587f3b5e931d94ac9ecbb199f4bc1ecfc278de42e8fd809788661c6664fb4c7a74a83a417b2823924ed2e75354f44ea0e91aa74a4431f16344289d4d1b963d34dbceb1a8107d98dda688cac0fadb65d5deb5c0d162025a22033e7c875c70b3e7e8a71c9ec0a60b05d848ba2b3a15f4c7d5a5a252a4bf3078487462afcda352fa2aa2fb2f1d7c9ff3a3e9aa694f7a4c7b9065f832f4adff03ba5f0328dafdf10b251f9a87c4efe178243d281724437f9f4b88e12cc3f3971ecf244e1b546e50ebf72f0b72fd9cbd951e939addbed7c36e8e8d719f905c162fa324f11b669e098c89132165739dc1a0448223d5b21f6569cb1d9c2c56eeec97a72d375d85b25e7f083a1480b76b6eebe582a0e0281952e337c9fe5554e1364d35b70639612fc3cec217ebf027f6b99482d7566057300b58178508361814e351a384e57d0537ed714e638b90f164a69ff76cde5abec8c974f768ae6bec1a4961ce8322a40cf6daf93e7cf8ba8f515a3c2f5cf0b77b3d73a11afc31fda4446cabee66090d58b19c5b2ab3ec99cd72a09ed524dffd361d79d96bc5cd6ed193563a86b2f48bd1e154ef6f297cf6a8a2b45be6fa09d035b6cd0cd51c202b2c2da0f77d946de71d24e35aa11f7bab4c16c0ee069a42f5ae3aec63637dcb1bb2015b7808eeb15af74cca6e548bb9341ac03ecf54d2feb50b869c5efb5eadf39c3d234368fb296794cdd06648e10844889d21db243562f1522a801b2d754b92ce286c5f239bb9092466fab4d1dc4ee11febcc11fae5823947f8316fcaf37ff14b8d96aceb4b7e07660245c85552bd500af32ba5448e4bf6d8a4289d43e51d9f6453dede781d94a81716d7a12f12ea038a08e8435f0ab0145c0bff3f9890d8a4b9f48d8dc219b47ac454c35247de22e4d907c5125afd3e24f77edc51bfb5ed9f2932dc314a695364c6ed17ce3a3f7ae73c459deede93e214071f791b046ce1d60057b938a5e348072b96c5219ac9c0118af8916fde088ea559ef4073250d6beae52fb99283720f1dfa74d89659362cb059244bc5f5b4591afa4ff787ef766dd02783d0308935accbe930a101a901e3141dafed4810a7e03cf2d422c99cb85d711d669e7a6d956d7dcb51730a83c5cc1dc1a9a236ec216be2627d18fa67b2b0f437fc48a0e839589b3993c041b607ba610f7fc6be377b93878a5ef2786232210443a20b669a2f0f072b7a11fe38eb75fa7ffe2b7c8953e61f7b5f59d2a8dfe3e525e8510248a3b830a6020d1f4681350d5a47c6e98545139071508310b8f40bf3ef266649f6a858fa3a822784961dffc18f74544424c9138d222a8211a72c5b2080a63cfce2343638a8793b1b0e6cf938d7250df544631ffd97a99ba22667a35c403692030969df9bd4b084b2eaddf2974246ed02088994b61482bd2c22698c52bc48531f32ddb1944aeac54f95aa20d67b8306ef7bcc1510173ea836d81528c766eee0672cffda1f1c566113cc8b8aa8e4150a5f34e1b058377dec6a61583fe4c80de308d6a79a2c16a06f14d760bf1d3bc10c0af1685429a0ccb99d70af1ed73bade13ff069e8f92b63394a390f024eba20d5f276385268622669a94604d6fa141700d1748b5269d958fafa231ab338178f43a1d8b87f65b21e2efcb2d7d815ad549070a893375d718b50e14b899c89e2f0525b04da6af0b230438907a4f0c82fe0b83efc4938ca0c62f5d73ff5837aa699512b33876160a9e64f1a8a467c6b1f4958718ca2d5ca858bce38775bff4c10a92498d6cdbe6abde53ab669c4f1a1e4b16e4c68b55004cc8ea3997d208cc9c65bed178d154664eea864e06494f1e1a5817bb6be0f75465a26cbbf67a82a63cc0ce297d92bb9d2b41155f70e768c33ef15abd066f130549ad0695f6862beaec0d4742754546c4f77ed9c8e750edcceee1a14c764ffbedc9f65b0dccd2b88e1519a0c9b3fe09584656922a2b54e315e67f70d84c4e183054f1d7e9560da8cad591b247ec64a2b4300fb058b953e1fb30ee764f421d8adabff383c0933d159b6ea0229965361753a5b2edb5d9c1bbb4939418b503a28277a91f758cd808296f174c3981a74a3c2abf2f46af9ca994b395a47a482a51ae4ab2887f08730c632f212110ba77b2303b6506db0d31ae20ab1c7779ceaed2c28a08a39e876ddb43f51ad099c144bd473c021e6d6c66f70282ef6ccd981e1f45a45e09925544fdb4b2792950d85dc7d56b170d648d56fd9a9272974c033b59375e63d7d8a62613cb36ac40b2eb4c90196e3241531a78ced5bcf2b7e198c41711068e27ed1fe8ddaf11f729db16b504f1d3f395d0287963618c51897aed8452da14f22c09cefad5b6db29fd9a27fcaad626e6a0a4d85e57ae65986c0fef6b4ccf7bf63dfe24f590a378aa4cc99fad9a22dad414087513ba2203101a5a4d5aa8d0ffdbaf1da9aa0a8950129c0fb2935ab2f715434f625c91fc5c1da4f859bc8150b51cc1409fea45589c77434920127d85681b99aa06801e81bc98887b95e02c92ee5c1a2f066b96e6c0f76c3fb29a020e92f8ff80d9de302e018981b1feb1aa7d6d91de043d8535bbe1a6bcb1ba30c035500a6e1db613999aa4783b0e8dd1699b3b3afb96e5c09f02780f33f2cb101c9b0875d862fc17a989d2f82ab9fa426e637f8adaf0c484f05be1a5bbaac92d24e6c21e9db29358a08caab324caaa757fa008519327bfa799047064ae8d8623cb94f969546000828c45e52b0adad024c4ac5c9feec8937c94ebd05cb89ae003eae98ac4c58d94975751c1cbd2debcddd862540d1e0211a0ade82ff6c0ae6c325a371319ae1d1dd820be8cd0d9bbf8e30e3a1698a0cfd0101a488c0d82a55053960d8ab1dda2922e64e7f220465818513bd4b5b565d3e7c1033a1837a43972f36a75470fd56131f5def83c88c7a8cdf6e69d6f6ee071869a9284357dc657db860defbdecfbc56220299ed253cbe27faa3afeb8c1d28f5b9c65ef9c29dfd039ce8bcac81d462a138b5d4f0ff98ec1cca7f133767a7f3fadc679d8829a8341807bcf02e6928c247a869964fd2cc6ee12c3bef1f2cec1e5156c2ad9ab2c0b5beae5f508d90783576bcd71cc3637384589faf8b7e70de669aa0f549eb65b874c2917d07338fdda458e8cecdbaef34e83d0dc56bbb14bfc90cef4cbe82964ab5ea4ef936b589d43b30290287f1c51d185fb663e06001ef4343edb5ace82f13dd267b3898c548bf6e1cee115c3ef7c9b5276491434fb81dce7c02607494e5cb1bf9d6bc99adae1533553b90b07f32230683063a49af18f6236d15fa0ac18b90c1e3253a338cbf0a4a1146f4acfd077ddb6e9ea7fd6baa45f26146f00246992da88736ff0d2fda4dba980a8868f6ec93e765adbc1f0ac4b55c521e4fc25cdbedc56f2d02e479716a244986e69340c5637a786eb0b6e623053163cfd8c1aed2ab1d5368f666591dd7afada75a225f6178c91a654ee93e4b7583659800a63675142515343b101a304062322a35858b09f5160a3cc03e2c2313abd5c645b83c0c8f9e5e33d4b0a9ee8fbf9ac6e8a88c8a70483e594c03211022bca76bc30642b8e16f99d6138aae119ad0ab6e3f1a2adcc834e7e23882db1622c26a0b0e9a4b9d684e986ba916fbf004137a9bbde87ef6c3380ec552ec580a1c1b4ce8ccbfaef40925449f8668dea360200ab1096fe3cb3442076fb8056f894d1a39d9d2df2e707d119cb200f1cf6519668ab819a8596e7c42c0125bd5c7ba17aa324231a5cdaad2ddecfa056c3338c2d68f421d398c950b4239af9e9078ca6b03ced625b9acef703bd3bfd2325f58df8cf9b5fb0eae8ed688779a7d0e454322bb961804f350cc623a34cd68642f0c6cf3600600b54da5535e5a24ba0d5556544a626663081baac59a22cfe5f0c3586952f931e166cfaf81c3a01b5589294b193d3edb271b6a8803077782ab2e19708efe87f0b12dde9fdbb0b670b7339a3f2ca1f00e4d9c46432c96136856b16f04613ae532af83491ad8ada67a5983f5e3355d07cb8bb0657399da2408038e45527051aa86ce6ba980b24e5eec2a685895444c36c549aeffd3861819c449fe20352f8d0e8bef0ccf79ee24539e93fd86603fea651b7734da9d6c3e945eda91c4fb621b64a0efb993597e049ca943dfbdba75b380790f78e17854eea6956184d638bbd22c9c15addd796042869d7397196b22137c07152760b183f51522bc7b0882cd6f8d1ab21366e0864e997fb238fc1e531260bdcd255614824eb948ee142924ba50cc8fcc856fd882ef1ff13291d558d288c72a213096edbd92c0069d1fe771132e86b8252f2f9e6fbaa1ba2a4f3b0727e064b9b8400d20261675be6e5f0ab994305f650dc802669242fc3c7d8a73a61134bebbe7d50d07744cdbde441fdd9614300463687e47c35841db13a4f22bb133f74e96aaa92b8114c07f20d56a88f4a5f4537285be288f7463ba71ead12af7ee23049d2caac1e887d7e12e98be30468100f02beb11e059d4d44a34c66eec0742c61d881dc17701658108e209a34747fa8efc85484756f80a8e88926ef71e6096345b0f13f2c8570140cf69be9517aeb2d42dc22b84145cdc8e7d9c643c2f0c40a11954773abf3ac4fdba6ac8efb684dfec470c5d044c3ac6ebe5f773cce306aff260c34a3fdfbed9cda1eb699db378ac0bd6a4fefe836d638fdc620f58af4f909adacb0c32b5e860f025822762999a11647e7248e5c78d087357939d7fd2a06b9e1d45dcfb0d6a73698475e8d3c02ece3dc04984a00ad53d4ade113741f427a9b78f4663b44fa357f815e3e00bdf30d7e570d3a6ca5091b24efd2e9b99321591f3642e5187ad0e8901408b9d2ee1d9f9232cf8a846192c36f384c86e89b9ceb36693b467332b99d71f95c88eff04318e6aac8c8eb06294380c2b53f0824fefe32840ec90ec8f20afd7f346905137189b74eee8114ec947d7be3b2510c6ac3b993cb2ec5ac139ddfec7c1252e94e6c0d9c820601a51d6b25c9e743abe67a5926aeb61df27e9fd7684a195a5a1f21ff4315d00f8b24bbc3c051fab334500e4bd9926d39e6860c63a33497a49e1b6f2846dd1d8557d94e9628d8d7ee056d910dd2fdc45ea8e36953e09343688542dc9104474fb8584d2c639e79d4030984b6f0f20c0e8f1d906d9a4ed9ca44bb4d0a254af47aef9d114bb6bdbcf1e051b752c8f90c5e0d4741ece463dd402e9a256d6aaae4178e711b894f34a09c74488b19755ee8890de0edd285fdbdbf7929ef9e14ffedc72484b1a56485a5a4bf5e686d2aae71e853d9d990dc1fe6417f33ca17feeffcd8b463d9109d6a8c89671f6d39d7c71c65d4437b1de073cc7c6aab37254abe879bd9dbc25496e4353c0cdec3c6ea18b63fd0db5c847e78890c5469460da7313539fd1206d4a551c6f66302dc58550d2c25d50150b5a8bf85ae990210fee61e72c21a49ab347ff3672f0e9c23e5818e09e4e62e7d8426d75245662e4756a2f70d42516d73fd3eb228c05cbc537143128faf68e6ba8a3a0cb36dc9d7e3fdd4b958bac6e07cc50616e93a2b232ce0ec4a26143ac19d92a5496821ad8096c746bbde0518b265d13acc10a7da31a75c5add612a4f2263cba6af3398d17a6a5c882deccefcefffda5d3f74592d02c000f7f4e54ef2b6fd2efbc24592eea2d05eddd76e6d60f8f29f77faae7b2acd0c07be2a27b1913de53ded94f9daba0786262b86fe7bbab1487e32453e2c5a8e12f2c39a61a3ae92057d361017445ae50f9b6fdb894fea5783b06ecb96dcd8c445364f1f6378c2ae46b81c483556d2696c0c5e456df54b7304d18f0fcbfd2123520dabcefa87877997367692c0e802ff1f58304c0e3da1069e6002724c9278c52b17de6551f1eacf629886103ce6901c64f274458e5d02cd2e5d5a13cba615b44a04aa59e703db589d8cbc6671fe6a48417ce040097d5592dab972efe25552f07d465483dd61120f89caa9f632b5ce10c1a9e14426ae8086e7b60c5e8331a0f26e4666aef1b7d62144896aa25a239a48782eff836d2e6ab9726ada4924dfefedc4f7eeab1093022d13f75354e088bf9de2c90b71095c700b4ad83dcaf32521bcedfaad0068a1aa7809e6d77c28d37c26a4357a45544af264f6e801c9f30e87ba237c244892f1ba5d5dd806465ca64e1a10dfe56acba01a341d136d541af1a5d9e4102b567a532202fdff9a8c605bd8d9f3a38bae340c1d43bb5128f02bc3e5dbf5de202ccdb9f0cde48eeafd1de45346add1d735664a29cca925338afeecdd790fb898f035c2f5ea22730db773248063ce9f46a78e0517245b7c01d31c127e41e5f64c2257526ee52ac7bc3d95f38d35a1c74a99e657d466199cb917c5dd75741c160cfda77e04dfaf48f38f0703c687f744b3df11b290c0db24c30bd183ea26f4a78b931bfc764647e0b0d9ccf7a38eb346c0f76ebd455d3192bfea92c6e6a1121b7cfe471162ac777c62c8b4b5d9ca2e21ad83e343275b2615eaae5bb5061a53afe2f258e358ba0331a0e666c6711a0e5f59d0103f14ced553fdc236f2d32705a575867d102638ae8d01b2207023e78cd20ec00a09fbbb02454f70d1dc0004f77575a88ec80ca3eaa42eae2ad81d60c011733d49fa5ccdc7058396f34c8f7837725f7abcd7a73ae7046bf4834a6a039e47bcfc7050f4dbfee59df4982c31715649acf9def9cecf7643dcc85a8895f8dd991ca6a86ee99d9a3346fe67f0454ea15d6f879a1ebda811643abdf8ed8b3bc3684eb6af71944eeac5214447a350857164b3459d3d138c97df593748c79c84d17ad5b24be470e4e6dbc1a9202a6cd6e3af87979aa22e3c3fac1774854c0b4eac6f1bb4beeeb5c617b103aa411266cf3f3e373cf03aa3469453447a1f5ebb528843a1893f6639922fc189c8b3c9ad3b474532228c5e292dd56ae36f2f0f9ad40fbde71647f8278d1cf7db00b4551369ca932d8cf6e5ec4b3321900e6ff63589b88400732233d0280f1e7b4cabd6e767054f100283cef99cd5412c70f88e6b187d405bcd1e2edc946111124bab27553ad57a6fa54db6c5081ac129f43c6395df22d700ad8909a3dc57e6f16321d1a155a8308940d0d58db2dc974f113949d2ac4f5fb03f38e41afb30425dca308b1bdc74f8ffaf5324ed4dbadd0e139f2fa028c504356e0e6805023003a25b661690ea5db1fa685bb108d99dde1e30fa0889b75953d9d856880e747f3cd049f6baaf09235b8f5d70ba146484f15fa2b21898574c4b73b4117d66bf8fe708ca0c83840c829b6826a76192279dbbf1c61d418e9a8bea679098f125b1c3ebd70bc329160f16d1eac9cf43de676e36ca34deed14714804490240410109184d65d0acfed2b6b9e100da291b436d3ebbbbc834e5510bf7b3795885471a2be930bd8fd1563043f8cd46d0bdc87e37fe94d9b043af6c8959cf2fc4cc7e15f9565aea25bf7355db6f0a37be7fbba7a969b22ea243a4bde9588676f935b6fbbd1fdaf8724a26ee117b5bd42b787842e621a9b1f7978a05bb851f88b4e1d82bb9407715d302a16e04d47eddb42a3727eef3e579aabdc4473333a470778fdd94a78323deb301fcd70abbd9a602a7ed80b5f8fa7f95f530e0466977cd5f591fc917f50d31f516266cff24daf1a497e0469d82e0dafca5c47856f6bc90f9e975314443e31e84d54655fa17a3026291ea9be872c3cdeea58906cfe72f87895a9d7275049bffc922213d4e54c5a59d07fe7e56b3f5e5ecbeedf23f0ebec3f6da600d1de3b316e3281c7084328fc0f18c44f7a9e99d6998b3c578d0abb9bca68fdcef5d27c3482848360e3b7f2ff27375d6a4aafca35d7319d6a40ae27791961dbe2b01298ad030579d01deb9688651836986eee6ac80fa3def251c3a8622b0cc5add99a8060bec40116df2aa1324eef2c7ba8d35c035f4ce2dd89befa3a0a64cb08b7320201a64dd80048c29fd220d33fbe948bd9226d132dd086eda8236cf85a79aa4e18107a34ac82f9e69d4e9378205eeb40fd6ca2cc570c9a80c22e52fbb0813d956b4a79f90fa7bd948a52242d8bba55c98b25256856b3dcf480f15b4fdb65c0a9be24b1e15d068c09df6be407735bb159e7885ad718edd667b5816d11464485ac0adaf71fdb822c21d140020058145af4b959ece07c430ac830cdeb91da3560684da0f6538cf2cc9b1f1a55319525fd9d89c65440a840d6ba39568830b43ab5ffdf2b1356405696911214b3564e9fea9b92ccb5487d87a9fd9b9f34528831cc7ca6d28c06bc4dedd26fc7addb19b91327ce2b394a73c76bc59e6f0e1593a092d528511b274f080e25944b8314bbfb3ba9aac7c588989991689a48ce900fd1eebfef32537c348094fc64078517016f6a1dfaa51ec7a05eae51c91a93b5bd4003195738a2c0357ed9129c9b11b579401a5dbf28b26b19724dfc4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
