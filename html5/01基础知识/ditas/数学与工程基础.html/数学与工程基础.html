<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc1af244df41aa273103c048a79df4b27117676f9a62bae986f58010ad2651174039eef8f571c13b35e1522007500f6f98496080abf690031bb650978de5d4d39b255797cf033a035df58db5016e131ed8a701100d5e329e0eaa98b25d9055c18a0ac10ebdf3809e06db5ad26999e7a7c5a5ac0bd7308ba21818926a590c272c74a4b845edd6b7f7bab16332175712f32daea3192d3cea69798b88926d4278c530c86d0e303f4a8785dc1326149f29cd7860ca2ac4835e0bdf0fd8ad0acc2907e2eb60b973aad68b6d14656b61f7aff303a1589f541ebe4bd3c9a1c0d36d2483025b40eb004d9d0c0751debdcc6ab6489a59ce9a95082268f1312e44e8be6f1c5066d24a7f2ad4f72c88ba1bfc3e663954ce0cb670fceada0637c1b939ffe8386a2c4d79f886cbd48f578b8a55fb1aa4e1aca9470381cabe3f0860da5b6b290927b73e36a0c09dfb47e4de5b04b0c68f79a13f6c808346392afa2c6d9145e479326794f0369665fa8f510b7a86b661b1767d4157f9edd57be12ee486fa993443ee3845ce148764b1f40c89f7fa4e6d8c20e62260aee3f44c7e86c90f35dcbda2a123818fe208f77da2e328be9c483a202227175c9d68adf95e7d92822384b0fea66a4c8b98488075893b7d5cd545799be302d9a5327db7a4b9bf80430e2bb9ab589ef0c777186c90862cf9b3641e939b088473a86f0ce4763fd330f66eedac1625b37526d3edde9800d7cdcf73850db3166a18a1158966e921f47ad26ecea23d7f44a0f90ed5a0909d083cfa3d03408a733d9a4b8e48e865412247eb5b1e1c89fa1f2eed17b5a4beefb204c168126a573e1ef650b33b1d72c941daf4128e1e99e0a869b5e8a9f4c63baef042f72a1bf0719c8d8f938dfc1255666158e84342755b22710ca90010e3a97018b940796d0007642e13153a3f4f5c7e2780a0143741f140c23cdc8dd71cf39cd718ba6ee0b257135c65936ba036cfb1bc8a69de3b276978926409c7be64d114a2edb997afc28e3ca959b011ea7dd5f56c20645157bd6b1800502b217a0db324af44e3c9408bca719ca8b8739b3f9d41b47a512ca747c3109f48f5b67e801a7434ec0f57bb243ed37e24f71dc221dc885628d7591368dd2f50ca1cb08712fd24cb31b276a6a5b407902cade81e44d0b3d4141687cce8dd3cbbad374cfba1dd5767c4c0a588d6b2a99a9d55c59d73ec9b095c42df7ab28ac1d6d1acefe16f60491359abfc63425f7dda79262423061c0d3594d8ee9ae2f53a831cbc3c79783a206ab13b2810f6fad394a56a0318471fa199761e4ec11539c36b6d801db25aaa9fbf52dc1b3c200ac0446cdfdfb70379f8d608b4ce1db5c3be0b91d832e497287ecc874f880a5525a3460684fbf86a5aa7f4160c26f50840a419e94341556ed11f93e606bd85740c3de6bcfd491c1bbbefd64d3b84e66fffa2163b2a197a96cbd35a51195b3e53367ae4a99e75ea5839acf4758ecea28268c55c79a1b010d1e37b7e197e32e954718e0e897feb5297edd37b24c57a621f6c3a6ba0195fda55148377de4e6b7a91f596a1f4adf84639fccc597dafe6e5d2f8691e155d1c521aaa646f61b86e0d59584bc5e47cbfefe0f082ed3e877696608265d4729c9d82f84cb2abad646f51d53ae4e527cab94f7b2802d89646445c4099e5e1662ce7d74bfca969f46170a109808ae1363f5ac7d330f81fee245119a7038c748926051ce10fbe49a477391798f92461680b52c41c0edaa0424a94e864c468f0086afe36381f89e0dfb4dbb7f41c057ab562aad60dd2df9df8f3462d9b94f3ba88fa7c50bdf7e3e1350f397d2e5645a8d78b0f3a2aed055f7b0c3151a68d7fc520ae0780d125e632978017bed2d3a86a3eb682169a8bbe99a28cb5c9383f01c436b5141879766f4331ebfd63e49339734cf6ab9ab4843fe81b8295578c1242d3d60a19db4b9e8a3750132669a19e9a78de86186cf2a4284cbf9251116c64e0c56614c701fa9b896a683d1716c78b76fe32e12dd7b2ed1981b8f0d1982d7ed5ad4e016ab756f686d2e4082f9c44aaf1c092031448eb1a326c67085197d07446949371a04ef1bf879af374136143f4b404760a847333efd5a0ff2675b7ef44d3b6f1294a1473e29f16b7219f00858d47cde7b9c6f43137c079d437940764190fb3fd3389ba0c795cf9cfd66cc9bfbd9d99f47b4460122471ac29a17f6b8f70e44fb9c9b5c48760f6c4c1541c847aec48d9aa588a750573413fa088c04d49b4a2804b6124e5858211ed705e1d78cefc4bdaab695335e825a418dad95a917d158df4298440be5efe4abaa6a91c3f8bd2e3721958ee45ff36c8d0da7fa2e83bc665f80d35d05b44b871a18fb48db83e28b85d529e10982b10e37268b56d8e62cb1292d8fda4672134d10db26ee23d2d8e9f5c7a8f095261db4f9e2c29aeac24ffb85daee0f61dab0aeab639f2070b66f6273697937273279267e4af7543b332f5cb1f6add00325493c65b7424b36f47bf74b9668f0e5fe4faeecd192af68ff1ce23202a58088a0c8d0ec98956e45dd7b5d7cd209d9052c5fcf4dad2ccd063a3527f43a13b1a38e86961445f417661b9232f817eb30b2882f3a8f08556783d82603a0a42b9789d25adaad8e871abeb6d7f6c744ebe1d51046aa787fe7cd50c80d30e3c6586ebd22ce19d6a4137810475fe98dfc743efc0bd0e177f0beecdb9842c856be2e7cf6213de7a448e35cca07e5ba2989aa648b1abb92184ca7c9dbbe0cadafd41e9dd45d00d269abfffcfb667d0ad5b4fca1ae4f2b53df26cda4e0633c1d65a8f7217f8946e6fb7b5b25036195c60d0433b54da1aa0ac72fd63e27d231de7eab608bfe6a437927051b68d1cbfd8eb6fc2d3237dfa8688d42dffe997c1934dc753b00e8ce3d6fea876b8a3c43ab071ef929a1f97054faf64daffa31581ebf19ff58b1f9d487ef6e46c7e29342e0401349d85b1d939ff2dd116d69ed82f4469d16637961bfc2c60c8179d12357169e73424b4b25973c68d6cc671a1d49be7b39141ecea559c63e97a8fa6ec482963916778719bda056748354b18ac1b3b8442e993a417aa26d49f5354bc1b7703cfa125633db29d27807626a83becc508c6a910751f0b263759c5807001cd02bffe1f1a08aca925f21966e6f87093a19f007e65c73984e989cbc79f4273e71b62ce2574e03c4309d93924f7edc92e638c0011f63014b5688f683f0cef82ff7c04b73ddf0b988d9408e41f9e82c2d78eea3d4215147dc681f172edef10776513fce147541e26d562f67fb06b6fd766e54f46963f384899d101ac3bc980627a09049402d5dc63ea22f657a01f7a703bf8cccb0e551a6ebe860f732a3324e8d1d2fd4252f4fb61e0a28004b603cba43afea01ae143aa9dd760d058737942603c1a7e575aa953312490f921b47688b8532a18ec4ecb4a1d965d2231fe372967d4cddafb325718bbbd43ab7d1a0e62626d5aa2bfacca93645970bf849d6e9e9ae64bb99466972fdd37dd26a79f22c6065e715c4edb3dfc867f41d3e31894ac7192b5a85046b60e46e08f4f139bfce5c816902697c1557935987c42aa7f87836feb701fbc769be7b601550c9dfc586a6cafcfb70e7117ed0f00c72d16fae12d518062f1372e0eb3132ac4b6e70b373d8ddb84fb4e80972efed544ec991f1d9409ff189929584abd164ec46cd50759062f830b0b05a1302eb111109b532a32e33419f0d8288bb449dbc06004608d163fbfc9000a62f2c6bd2f34c02db17e8c5c5ecbeccdd37458cc27ed927b75ecd896e0148a19a5e87fea5c064c4482e45a5f974704db61dff89ffd908e79d0e565f818adbefeae1915061200ff4dd76b1df25681c1d40b82916a377e500b082de394248ab3d5792639cfe7cc8e1fcf84c48a12431da8d83655b73a9ca189fcb65b1410a9b295164226d2af85a28cf1f1d8aaaca3aac9291e08835721fd786729a7b6c6c0208bbb96ad5f9c4991a309528f1f23a993abe9fb59474d5f9357e22bd944bfc20e2ebf9620d34681382e90064a72f2b8ab0f85b99bc2d10d7ec356df00db96cf4638e401245452dc2462fe8ab08c158b394d10d424ca2d530a48b9bf58a705b83be19e2f048fe1f655650e99daac7901bc244958f6607784f78ecf0d69fa5cc64e80f2b382bc122764ecab521fd99bf804571393b8073f313070889c105f2d59e181facef3920a2763416c480bbda4e5dbf2e54c5f549bfd7457b8bf5f5b77546bb4530e7bc95c517b74c6d03d3db926878bd7fff92f15aa04e14945933d2e8dca57967628290fb51fc2f76ec531d54f28aa009a084d856e7e4ad704ab0ee3a82ed1080d47f088a31ca067de83e8f86e92016d0e9ec18aec8248a8000f609885c71046be5b57085062e7a8a4e2c1aefbc2ceb2b7a196204d0d31e6f960037ab4e3cf6cbc5e0bef141701277d6d8f38583a45346b8e938c678bd77c7e4e5d3110dd1e867fa258f630901d02b6f5297d42c6d8411a26cd2509276deb2e7267a3f98bf1c9d69aa94d45730ab180729078d953815b48caf61f965827f2ad46c7f4deedf55d00665728c1e7b27e4773cea0a65c318f5ad68e7208a7cc4c7a0e30530e4e07a74895ac951a7904327842421e7e7c6c78024f2329b0972fd25a18160de6a7bdbf4f031aa07ce090a2bb98b484464172c8e10a63560c9d2154c44d0348062ac421f7a3c3f5d9fa43bf4b856b83d8f2f60b08df2741ea20811a667c4ed7a9bc445ef18e4e35318b5a0b2e084c06a42d5d266490a7209f58b9252f3523b487df10a6feb21f4fa955432d518011a6e9dbe557d3bf1e4ae2807a1e0ecb3edb19730160cb6ead1c8902bc46cd75780a06205cecf1981417f02a069c1f110a33434b87cfc8b6c1bc6a0f6b4362efb94719d9f1b944bed71394efea4bd4d2059b7a9e5deb4f7dc07b93dd11b8f316f90df3cddae5af0afdabeca9f99adaffd17776c33f4d761124389ddf9a378e2b08b17098825961c413ec6a1c9cc38e342fa8bea0404f7aca2be5f1fd68a2bbbfb11bb4c827597dc788f71555c219218732fc20acfbe12e27458782de746a6008cfc06b5dfa57339698b0291081d3d922db588a0a9459aaf818419696350dc45810bd032a1b7fd4b1e9a02cb1aa37e947e64d35190e69af86b1204527a0edf0efe2df352d54c9e5396527604c28da017811bc8487a3d7c20905ce0baeab762934c3b7398b9d158623af2cbdc351169e416fcdddb2df47edbfe2a9c297f811cb80c84a7f173e1b5558ebc54cb10df5abeecced5f11e058a82ff5c4f6d743c0116d647125617c4a0ac9434ef3a30cbf3bfb78489f50063fb060ca02433953ef60899e7e91fb0dc44122614f707d76f4c2a146cd8b7393f63630e5d757ea2e44f30a149e5ff2dd757a132fee62d4ba5af63e3f9b9f5811846d0d5821cf5d4ee8a5e01bf9442479dab84347b162381147601570fa55387fdf7c02fa692887ca00fd4b8cfc046d438383c0d659c7e87af0968edce61036da8331961e1aefd96fe2b66441d86e80546c1e5110c7c8fb318f7cf91cb328a5091d8d87b6ef6fd6459c0c733895b8ebfed6b75cfd011d6ea80e731f2101a1d8ea9aa2abdb3ef619833df034cf0c5f40462f20cd4f4edf8a230590587cf34a334c67b7a37b308bacb40c0797e3d245403745ac6c4d57b41917fdd7303972ed56473c4beb57f221fa4df9bb285762b4cda6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
