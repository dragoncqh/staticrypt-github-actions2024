<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98e27e39d268d16c2e2b8c7ede2fcfdee1ac5543c1071ba4d12c1f84423f92f51bb8d67ee00690343e101fe579adae93ae7e0db8784dc388aefc70709723a9a58f06e73cd70e15633c4b7ec2b0e70b52e3fd13599dd6328433fb4462ddb32046fa51f520c9fb4cdb7478e25de54fa3eb0785507fa34230cc617dde40466ed47bdb6220bb5e42811d84507e0af8adb6798c551669ef4a527aa9ac458521010f61c939209cae9b716b00881d1dc764a9a125097828044a8583a32542c245116f8e70cb8638f8c70391be3252692a185c1d575c17dcb94bdd5ca78cbe3aaf5a511d4929b9fa117adad3b61fd96442114feed6c8196599569508f16c43d66e13ff30d297c74340d5890ffd11bca3c12c172751b6e9ead81cdf91665f7b24048c16e1fcdf7f7f5a5f1d96c75041b79eee8e00a1ced02c48bc91ccfdbb913946039ac622dd810627129eb87abee5f13a3ffa719565a73245ddc8a799e4bb655abe3c2ec97a7751a0616b71b41300adf452c6158a5c5b5ef6b088c93ba34c7e31d522f535015776f6267ff4839855c2968110e1183ce1974002784e96c0bd7ebc0c10c7d63be2d151ba238414a4a90161004b728adecd45cddaf041c0e8061a554dab722858d5324e943ca99da50089d2de81a9be78dce70582268fda4c47493a1758bdc20a988c71a465dd4e6c4edc6e79564c137c4bd50c140617d7c253b4001758bd1523dd07124981b6cbdfd92518849ea356bbd30725f4f4bc1c321263c51a340c9097f0fb0e986dbe037908b0cf19c40796887619d22880d4a728dbf9b22568ca97e960bce133ace3c2b7a911ec61b085dc7d657eb2784663f3355b0fe8fc8ee2856208aab49632f2fe66d998878b3e90551c6f2acfe7bb3d2db81db912fc02f7eba9c5e33040bac3ee7150713a327202b82bb2c30562dcd24f8fd023fca67ec1c64bca903fe99150bf4cac3cff4a7809902931c25db0fbb3a0c3770d7745d7d3224b053a3d238dba041a0c749348e44e3ffdf00e76bf3c42f9cb6ba944b333cedbecb36e92118f8103e20f9871370122d0a05434264c31bed7a5b38dbb021fd5fc795bd69361619dfd5a1493bb853c1f02f13f7bbe4b625f38e8cab321b1b1c52dfecdebe6cd14d0d00ad0cc7b243efe8882cd5939b0be8e4e39536b227b5ea0096760bc452ba2ec1b70d1f601a59cff5baebf824d2e5c8c8119abf8f5a61203c35eacfd450c8913767ca1d77771f88685d065aaed8f090a827481f906c02be7b728dd5f2bbb8dfcac9944f5c7936fc82594ac73a0d5efa567e428733258b94af88062385c096573d351aa4c85824499f4d3226dda11f4b440d9133e7f9f078d8403761571314aa5213131ab8296cf223eecd30e1791ea974f2b7e4e2896413ae349462992d14a9e326a801805d009fe1a8efc2144febdd37cab3b7e3cde7b2c91f405686ca55eda427d3c43322905a436a836f2a0368377c5e8ee1f9c87f7319aaf94d9765dd4a08465e78ec621e1e813e1abb80a4228f4cf9e302f7e8c9921358650089af6dbac953576b3c80cafa79083600fe73dec28b76f259af16a70efbe446d8d9a3ffc6f6d2d465b437d1fe5f030dd820569f695b27c44661f608ab14cc49406019028d6ef8d3ee79880799b0da56d963f8a5fe414537075a94584bb4acf3e17d08f8323d52fe1004a12be2805e216bac4c480a91af3a21b479fc7c4b98d7fd18ba568ed320213b65a0e5087aff229d9852de3553df5d2e50dc3ac4168e47aa682e1b4d30efbe8446220c07eb4301534e5dd19953dd1f5512e5640367834cddd526d13dbd7fa45b5adaf8b984d87471ae86b50871e5988cc1e9338d169996846f48d3ca09c127b61cb68d65c745c0cf152988f0b1f966cd37c5df53fe4612a0e7ef0448146d6d3031a7379e8f75aed124c68b311ceb5bd2ca2eb826b2085a5fee9939988e608a7bde8449a18fd6918fad29137c87b80505489761aa0ccc50cc1a425faa922fa92a9c021eba9b215cf773cdd8d324d911d754d8a9b829598c27cbd86ad5cbc33189d403ff80e25875e15c7c4197ffed9be35397617a1a1d3211d1465c9a7aae29dd6b5c5caf2a79c8a38a52c2f0b992bec5f7f9e21f83c9395842fe7c9c80da6be62a7706e3714385cab363bfca362b66de6e6ce738cd896728c6ea79b4cbe02019debe4f05715157c30e92a6dd62698b4e54ea6ca34e4afd5737a021bb837111591bfafab6536fce32f898b6e38b1073df8d99b8e8e40f3321f527fa7fbd4a3998e6bc3c66a3758978b21f5b51240341a98182d0345851a24e0631ecd1822dc090dfe064b552fc847c29de93c26a044b1b56c1e3d31932b64f173df8b75998df9ab0052705c14eb2c592e8fbc2863a65541fd53dd2634df8a9091c55d4ef2b73de1372cc07c636b31c032f228bccb8f8d7fb5ed671edd0ed1f3a16fc05061e5d5f02e3b7e47be7b3a0dc0633ee88354cfca2f014910c3f1689c587d469b18d70cd883b0761dbbb01f4e820ddc0e174f550ef250bc69532b89ada07ab22438fe7dce547ed1b462de43413ecfa6f8d918b76eec919e7cdde4ac30a273230f75a6e3da3a4c8ba88a870de0188f9c1175f92014bc6b493a35f1ca93f02c09a85b2cbabe56fe1ceaecdfa9c4cb12a61deabbaf13d3e81382c6bc714abb39c1a41d135d271878220b002a599efa3b1ebc07a10259d9eede08ebb8132ce169c9fe36087737f3a3e3ea03920d2e77b8d61b626a8b18c421758a8cf1164ed75bf30c318189fa541c7620586291b344b02df45e54d38950001b83220e0bf462391bf284751ad5ca2a894b63f3d3f19b5a68f244a50943f2cd9210277ec29a8e3c5540eeff70403c7e751df5ebe7a5047df821a9475ae80ac9c2809c47ebddaee676b110dcac6b5f9ffb05eb6fb6292133ca4f47ea4fde99308226c69f139ad3e10e5d0241591df3c5795224991638fd6d4190de6c859f9c61845867509f412f87a511df4d5d409d514134fdee45bdea249c851e444323048a5ba91644d56b09f521a9f4257dd87a12db060fa7eee5df73b008c494f7c814acb0fc327a90409172a0768e3c4e4a57dde3924c20c5864d757d860175bd97c7a4edc004c0437106c684fbda0a31ace7f0f8b781fda7fc4133523f70f70a8e16c4f13cb8bb1b34a7c2436b38b206d0679bce89d4e56e8c6a6005594f9c03275dae9c134fa6d6a1ce143bb468a0651617981a3be5fdcef49e102b5cffb73d73502b1e3aec3ff352077dab2baee56a19940b5dc5b7b0a65b598d2325f2840c8e5e65c002a6c621dbed6fa07abd9f83c973f61a1d7a3a7ac6327c03b9126b4de700f83ca72dbb700165b8793e8de3a750195ae38c2bd6ed8090b69d9d86738762a92b7d6f921206cd796226d9ffd49325ad739a58c61f24071406e855264326662d1ab4abbf6f5f3bdbfacf1eb942cefd5f911dbdb41e9debdd3cd2cb4de4c1bf0d04a508660943b98310eef8bcf6169a810fc08279f3746acdad3480c922d74cc05cc6cf6b3a69bfe5b0c7c59e8f52202a11ff43491e3e2eeb182c86b5d10dd6f5639f401da08cf9146e6e39a6176edb9511d76ccb6fedf9d3b4ad1a287c62df97a11100efa9a67ddff494735ce298c3bc9d2e582542c1ea0dc42a4069a83334383651e84594f9738f5767b67de0afe40144218193656792efb588b4ad67336af28082efb6cc9ec0f28be54d4d74b9d34f047bedb16985ccf9c4c74008e666382649722964b17bfbf6dc5599c57258d33267f349ff91a61bc0f82fe24593e344171c86536b4e0958980a2b5b07d051b4eab99ce4caf7979b93955325ea758fe8e3a443985f9781b99e0e63d2a128d6f5be879b836f37c772eaddbbf313c8da3acf027d21612220ae2fb4ec0b0cc1fa191c2e31de0946aed2cdf2d16f2a92a87d3dca4100bf888ad254248451eabd87a2fe000008095f8ed7fad6ca04c2f0a9e0f54e7b6d49cd31fae9b46c62446a8052227b433f1634b110431727a9cac344c3d5d42b744c6103bae4619140185e06552783f8cd9d195f0a78284123a5b12442f8c1186702f8124db46f97a3dafa015b481cf3b7e61b4a18ac1108a66be0b47ad9c7b6f3f8223cf4c1cc8095c178432919201089c9d04a544213d8a0781ec026a8993072f0b2e2666581336aea5b2b4fbb308f4ff1f1e9f27997bcb96d5524053795be5220b57b7c68f1bf309ebb2316794ca9ec5792a037b694aa919862da86326af0dc01330b341aab8e02e478bfce61ee9b91ea521475509ab777a5fe398c62ffa3e581e79ba9a6552bc67ece5a4dcbcf35dee65f634acf5a111996271f9bf61839dd600e9af9a3a2e6fed708585b6bb1ac365ddcc5c7d050a0814eeb43f50f0333738c379927de0fe1f6ab62255ef7e7d73b7d71db384b781735205c292a8bd62e0b051c7700c31e0276e5732151125fff054bfa148971c133cbe9d9bbf1478fdd0065e4f2758bc4a18835f818d75a615768bb3293efb85d96410605248b98528a277721fb1ac968418bd5600e094cb84fb17b3703565cda39a9ec6415717f8bd7d3bba2729f829003a55c5ca0fd491d0f1466dd83a4494fb27b52a283fcdf6c233397767b4af49104668ce94edf8f0cf3fa67ddbbdba12eab5d9b5a8155bc539dbce3616174224d7fb5f74603695d170a7c0fe0564a921b7253ed77b469b96e50b602138621aca42f9b1421ea3206ac71751f62e77993698195c2ac34d2cced982f251e021b84919a856125461a32825cec60849192054926e2d3fd3e67679a432a1b80b0dd9e5385b5a39b76d41af32c37aefc70a56a85394da62e108e74990b7308b470cb17300d513d6b7a99924e728ab20a80ed036596211dabdd3045e42bb410719b88783ee2869e03d13359103d25cbe9564708084b0a261a95a5b0cf033dd37addea2a1d6e3f2cd23e8fffa50f6c960427ab01bfc15049051ece63458c84e4564e25faf634376115b3367e56c26f980470bc42b0ad6587d8b93f3deaaa3564c0607874e0763b4b32737fd4415e907b53b42d7543ce035aa1c02ef152dbf55144ccc3869efa3f1f35a3d174275c0e64839ca7361a9b4ea4a9dfa049a0526401890acc5c3cbf1819bb9ba72e3e08eb942d43f84fd153ba21fe8c4b19fe2f17b99c570fbd04261b07316245fe70a5190feb3af835dc07b67cc0fc96f9a99b16d34ff69d803afea91ed90d338347dc77e911363ee46a1ea9674d956e1d5f45628f251ec9d96c9a938af80dceef4d24006be20996ac4b976072a8f45cab9cebc8a101c1f140fc402e5308188fe8c47e19769d517059c956b465d36cb3139c2fef2ea06bd3af955885985c391fb2aee8137129fa87b66499c087ed8e4878c3acd0e8e2e1d26bdf6d843f6ee1143b937ec21683fb662964b079e4271c1a52c5674de4358eae6311212ae15ff57dea671b7ed7dcf0149a25d559966b21de15945cd96de89a151debe5df8045f4b919438ae49b0185c6724281790dbc5b20c3f1727498d0e30badce59e16b681d893bcba66c8a76d8c871a4f0c463c1fd4662da9ab9601eb3c8ebf87c9c50dba39afe387fb51285e257ab194369b580c4f74dc8c911edb219f706eab5791daf6bd6af4f515d9efc90c4b01e690a368eb59b411eca776e35248cdd1f0bc328ece9daa85d062750d8de180af9166e852a8c5ad37297e650396540d7d9961cd59b82ed6467d72acaff4ebad28042d1508c91601f3f209548f1dd0111a7053edeea59fb498f7ee9f2db37cef4668c154dbf4bf78565dfa9598dbdc27e057019754c6542a8f748cbc78da4b0c9ef1ca7ac78fc3fd97427f045fd0286d751aa23a4dc65e03bc21e6f4f55314d1023bab80be1dfc7272ea0bd41fc359877507a440d9de752449d9b5274a0028b4bed62635c04a297707773aa027527adc4943026a37b8ff05dc940eac54c8015f7fb167f1c9f04a3502ea60928017759779db54334a99ffaa9bc934a8a8711e249f153346645ee5e1f91e0be596e0b10896d8beaf5d76641c534ec0f1c880df7780d8e21f5d39a4c9fa64ce23eac296533a8f33f105e4283b022fe1b531d015afb433d1026f6949fb98c8f80b689afebac107bdf7b2e9c043a77b5c2703c58dfe1a19199f08574d1d8174b5103e5abda4993003075be6b29bac212bac08e6bfb472ba9e22328d93ef0e6ce46db6de74e5d8816332810e1660c74cff396c467b451d56a2c0ff5156f5d37850d5b075d4c2e431100e18737a16fe936f30b891ae30557f4f9655db2ffe4e723399fde0ac08f2d22b7efa782782039e9cd39d7ad1a2003535d1872f39ac01ae37ebb64b75648463d2b1baa0850d9e39f155ac6853abccd2887df4c0743ec2a3701403bf7f00bbdf63dd578614ece07236f979488d9ff19a3d742a0947bf57809789ca84e714d98dd50c3b4ee2378537cd00cf5834ca4c753e3a08ded9901fafb5fb96a57b7f98e0dd17be02e3b41d138d43231a7eec07b423427394b34481228d57a77bd0ccd4cd11ae6dcc6c1d4725e8a112a5549aaa1936eab92498257bdc09208189bdc24d8f4bbe69d79e1d9a144ed92c8205c083c9d5c76ba7f1bb8bb8ce0cc65ada14245846bc6380719e8809a43e114854c37380526c0501e0a826d26121e3a1ee17ba0e4f5cf6f2d3ff7ae67be2064088ade175c61dfab0fb4461d9efea11a9ebb0ef10f7e8c6760195ce5a71254bb389010832aae7633d4dbc8ca5730b7f1fedf005c8bf60d3f122257df094f893daacaa22d10696df6611d078813f2aa4d7dfd6e225171f471c8d2420a00466a20356a9aa8b1471d14e345e726921fd2f5b229e70e62a502328c04086b1dfda648231cd96e4228d1f9c832700b4897dbe74156c9dd63c144544d32d1f45ead4af75220f3112f9b4ac865652bf003f0af3d11f983b8f751db0a2de49ae7b685c09f85b299a338f0889a619d3d16dcb92ce6ef9e13451379bdab65263b8769a9d5167f8d362b380c58fbb9f54549d796a3f21661f4ff1ab94a620328d072c731e945c4af5adfbed3b9e025ca8449de43e9b88f8ab73c1fb69e8208d0746f38731cc003e6c1f04b10d9218861e36ecbf89fed60f55cdb21b1568b3758555f89d6b44dd65fcca5e0fd765d9ad0484cfae5d93668cd5082b18c92d60d73851597008040d9b004734377e877ca7140cd684745f359f89dcba2759f986ab1c9c1e69efb21f5d0b6142799a8e6374464f67cb56cd749237639066d6dd423d47d3bc92695001e46541a4a817de51e348c61f88a04004096e3f51881b2ef5a863e5df654d39f0574475b5af5bed55f90bb287939566de3a12e63a4588aee91b799e3c35482d6f7f329fe1b94b7b0001f34fd71ba6cdbe2d8ee8a67e9970a07b1812ada46ce33f66b848f691cc8eb1118710c209ec4fb170ed2bd57548e52f62872eb57058db749d19f1f6a4356778bb89b5cc14729a5b5904f845cc27fddbb8e02fc66ccab44426d9fdb3dc3dddefaf0f4f5ce88ef02923961c1cd9900abcce7fc32cc3dc1cb7136554afd1eb2b1b62bc227828bbced4908c67d3b9ea75f167d2cf41efbb7cf7e5d3601657c8ee5013094b8a5daf697779bc2706bf6e77ffea2bc3d9d3069d8389e0d513361738b527cf5193a90748f21adcc89289373f10e1207c842617e43fba35816ecde132e68e175e358c4b8bb19abb488a5353b73449f5bd0bb93ab2b5cac5b7cddd1a2549b364acdab50704750a3e143a3c45c994407bdcb2268cf684eaf4e00f32bd32b93379aedf11d534ed1bac121c7a913b0a7d4ae98e27b75d45073447e8e4d6bec4aea4750393f8efd39f8d9240412ea28d585b817956a5de335b497f20dddccebe614646ac3a20f9955838ef6200e20bbb574efea7948322d628cae367d374a50af482c2599fe10886624e9bfd735077a2a209c6b59854625d5cbcdcb127d5c9332d425130c952513e4ec4b93eda136aab37a2d6dd6838e2fd141c21cf7dd3123d8fdb1c27ada925faa347b5c2df335f3f25db3748e64371545d5db9d4259580491f830d0a896bd0e70d3f06742125e92946468ee23db9d65dc8c612728a6d2220339c389bdbf7cef42fce56c02c34c998a8b6fb7f74db7b7a1589e82899420bfb218ce2febc46615bb8daf36b0c200b3d913914a29815af8750d06090b862ed865038fcd0726a8565afc16159c2d2659d18650ec11f55e59659cb3de5e05d1091888635841a1d9c84cd8008fc43deffc46daa28c58a896a308f273ebd1fb51c9d144ad1281f14f2bcdf771338b2965abc6666fc613df0ef8a032cb8d0da5734686f968446fe5bd0119a54179647718cbab44f03ccce4006e8676293ba25ac67b0b74e9294f9f521fb4ebc9f25a8b8ffb4677b724653b1aeb48a3c96e9be75d7cbba3f8ebe773026e3f351ee2703a52403ca606ef56b1490f5e93e5afe1df6d426ff975d7e85916354749a906ba8d0e72b5c886e9a769bed6251685cc7f0515398f894713d4fe09bf3cde641a5fa7b05266fafe1b540cec3a380ce866c31e45302a4e132b46890a58fc5a511e8aa130931f176383dc1696574ff56cc24dea3c18ae500a7be125afbb05f2a5eb8cbed5a8d8deeac41927eb63ad79a9380a66e3b61da046e4b4a5750891132ff7af6712d4b21b2164a4a0fab8589adea9017336fecec5b0a50f9c614bd600ded5bf1e951d61b0a1a203ce3772850aaebf8c90b494de447a7fa2fc25367d67603080e640be586c4f739446da7309d0fba1fbf29d4556e6312b455704d1df9b74869b801c30c2edb56cc8b314cb65340e6a377e0cbeafe3baaa24b7f57ca659e24e311ab799293c7ac8dee56e40882391095cef60b4186e5f3dd5a1fadff07a21279ea683b6e71d66c2a57d48ff077e7a55b8862ca4c17abd5ad99c2ea6c2e4fd5ccd2466653b9915c33c841f92ea126cf12416605cfef681230fb62725c394a66cec3d787a370dff4efa39b90f0fff94eacb34c21c62ec4651bb884e455ef602606b788d5d53251f509fdd7080558a26322fc9b9f072bc24959d4d0d71bfd0ae66d8200070aeffca264e587f36d6966cf4289cdfc92b567f774509ea6debad8d3fa99fba01f30dac433967380e40c1a26ef33de728af30b3f43a35c66986b33c4ca602491607422d015b2f87e2a519866e64d5248e09fe22dfb75f4823b099fc695dba5532b1f343842f5ce57ecef981a93b676a52152c9f396b43b82ab27a5815f6bf4c63527a4836e9cf648137b8e3c85a88f85c4cd27a209e0b2c9bb631fa4fe341165901f26c5a0cec43758e285be7a16ff4a86b733cc4ce9347ac77a895f955bd8132f0598bd4f8681ddbee2e21b0b78c8f6894313dd00e4837b4da6ccad5c8ebe0357530ae577a3d60341c3812f25e2c659241cfb5e3d0802d04c7f64d447b6dcfc504728e06c5bc1381c8c2813183b89e3b0269ea0e174294bdd5e7bf8c2ea0a4be4a9b61ddb4f535e220c4d37716bf95f7c93da6661220eb658141484fde614d2cc7e231f6f223689fa3320dff169f6cd5f4f09efe35372e46f3c9da46ec9618a53825effbe5b9481c1612da799079504bd7fc4bd7fb350527281926e3ada4690eed941c6f4bbe2e76b006fb9e492bf47d86271c1cd5356f23044b33440b2f2c767a764baf6696e3aa4fec070d67604e34492d6f0dd04e14d4ae8651eb0f9fead581cb21d97e9e19b9de57e3ebb792a1f04ed839df81459f736189971db3e96797329e20fc1a7f45bcefcc74b36e2e007f38f7a00b6bd42eaa5a2033b9a773242897864a3f32e99bc9892cdb0de31655c0f7bcafd9bf020bc49114a0501776cc4c162336190c412d9430605d0afdca357ae8ad948eb17177145b6223622135aff9a8d89fe251d0196c0b8cbda603aa5f7d2f8a12931f6290518d510188e44d4385bab6b562cc3dd21c6646c518abf246d89a01c5032078b91a76d9cbd326017a894e7d7c84b1c9a2ffc39de7b8b313e90456f915b2d016105d5f6d14982f2f6e0ab169552290093ea9fb7590dfca9d33512c9ba40c29a337ccbb3b0e769595ba3b59c8bb5cb89b2d06049e02df8cd1bad8c1c6c0ffd168405c42519e6b8c95da3cf23fd9cdba8097b30345fe2cb3fd9e50406f23cae8bcd1d428e71684d2c90b9886bef14fc4bfa3ca7c491eb4e534e1f897e52459e7f59970263e8ec598dbf87cb11a923b74db336fb01c7fe826c2774a58bab1f543857576ec3df4e6b7f974225bcf14b758e5614e1e9b0599023aabe9031ce3a73b9d8b8b7279e216af8b50a822b30999798bf50f3a64998d25d2a250df4e8c9224a120df2ab4f5a85befc2e426f4ee9f4df780b7b5239f145006aa4815d2e60362055856b30c5490df2d4994de87ac78b697feb0fc252d7cb5ff71fb56323504884a85c73ba4c8c8c59c91d077617ac13e6217ce81184aea840b898723f8a01dd94794348c359cf923b395b79caebd163ccb3156facba71c426c905e155e39cf9a76b2bb0e14a3a62e0637bcebcef75ba71db337453dd389ec0e9c00bee5ec6f37bc559a8fe944a0371fd82197e96d01816edfed8cc268d2c462851a333a35e5d684e6a23419b6c4334386ae4b374da63aaa9db610e4e048952dc01aa05fa50837fb7e8bbb2f5e52248af8d90a642096da7d353bf795b7c60cb3c8466a3b57d6be756d734a2096fd952e2a8b05f531d3e26ca2b6c0f0ee77aa8bd668d6f8cb57ceee75a13bc87a04c8b28d0bb8d09f4a74f4032143988071a785cb8a554e124f9435789555359fb46d8c2ec4f7343f811010f0538384222b861d816d4c2302a177762eee2a271f4b8e2feda6f7a49a300b3d65491218835da6f5e0b77cfefba965e6850b72b7103460023433096dbd54aa2461869add2ec5887ec6af31330324f22ed68ac60eb4248461aa9ba8057177b0a04925c71db69a257055f1d324857d2ec3aff4b55c1698c72d3cea7f20c30320f71522d9af6c3a2ac7577960a717d2517851e78e27d39b28b0035dc1f0bef27d556b619a428ed1ad4790ceb9b34da616a67cb52e5380c6e5fd117796a515e8fc515e17328f63c590887bb415f07dac04bea8de09a2ce785a56301475b40e978cf44c4f4ea5dc000965ddafa9689567309001b97b0f0f16b207f1acf10eb3ff1850e3a6d4af7de2586d14504fd34159890005234fd772d546ee1e8956a28b71905ed64a2a022276bbfb54230364f820b7b9f8c222a104332e2f573e51d8324e39801eeca5ad001e7432282029fd9061d3ca6d8352468b2e4b825a1739b8838c61381d9c452ed312ca87bed47c552cede7d5a7350cbf5642b35404f92f1a2c06b29c74d0a515175d896d39650bc51ee890078592cba9e1dd44d535f856488075d059298d6aa71e725d15a47bae3407f4ef5f6745fa84581611cb76eb15c4cc39cc88cee59ee32f1cb25a71a59538f739731c11470dac4a3244c1a860b70da1e13f886ec72074fe662b1ececf8c48da312db4bc65b6b2a807fa7068b625e903c6d3072db789641662b55f23fbfa7a71d1090fe5c0f707c33f604e6c21dd31572ef2243621b094cba4059b49eca13e2171d4d499b65c911c255d9938d6dd2b2ccc5b2a6960a8d6a15e2b64e291ca998ce9444a1bf845b985a191848aadfaad08f1bb9721e9f5b582bf9bd2e9cd4212e2e68b473d6ca67c9e4f3564f3a7b35598871c07b5d9a5a33b92d3e112ea26c8a49338fe21a346c74fc094e119882c30b890e8c037bb91df3aa4c6888b2a0f6cf849e5394e08462f387f8fc9404b5bff9b0970732232e1f5f883635f956db1c85214fa78a80e11c2c27c12898a728e975a57c286cd7db6c572a3a4905f929b08c157e703b9722162e6c0c8679fb8e43fa3e3a3a215878676d8894f1e68b973c748a32e35ce8bb34d63f8f265bcc06621c4b4800d2957841309bfc0626ccb7e4808b161494de840e28008b4e61a7ab775deb46a34832906ad866e0c647aa07eae8136bbc6f3e776e77960b4412dd29d10f12921f94139307582d987b7c9e4d28ac67ae2bbe550497e5b43e11dab8af71b75f78950568600157a1faafaac5f1a71f436f20bc95d15a7ffe86006666f04f72450de263b43138f2dc775efab54aa02d2970917cd5b8f2e8158722a15ba3982ce91056ad61e0d84a0ada4e6b0d3585ceb207d5fdcf58caa1c551f65aee4df1de24ff8e1d5b37eeeb1064b06df5b65f175309593e130ee69276daea705c3db8d985bc98c0cc84123e0a1e75452354dc30cc8e9bba62eea64fec32cd5e37c82fde2f3d253d541604b50d1eb3d2ac3f03715d15fece17b9b37eef1905f19c13c2486e8b5625e740a249b9e63d454dc9c5867115e40202ff294b8105a98abeef5907e1659b71d9bbc112d944181abb056c0b5c1fafba7c49f9dcac5af10bc59069bc206c98da3fdcb973f0748ca84f3062c8f5c360b8522c581f3e5083dd5b4a1c0b95c7ef3c45b5e807dc5e5bbe1939fa779e23ca0c5b1ce2149b3037263a261b22aa1c3b38139ea6bec6cd77dd97e9bcb7165ee4c67257750015239e739549c13d667fb2ad7a64684dab7f030980643dab1add969f16330f172944660b710d443bf79d704fd7448ea4afdd91c52d854cdca2b535a728249d61af4dcc93711b95159e98cd11ebd0ddaaff6b3a7d4aa08d6d3599b7204f4273b922a6b56f51c30d78080f394d02b409b1989403d1b84fba2d94f597b4ccc50ac967f732a5f8d35bdfe26992cc3c9e3a0908d712724199c3b788c4dec4df54097cd2cabc6f47ea01f1d7779b19f4de0ef6ca5402e7e9dfb0fb7613e5868431d24c2b9e5e1f9457c321de604c06335753faf689fd4d5759edf30a6f9ac8a0d45666165ac80f31ff2bf376b0ee527f317e85217ac00fca5a2a49bc98d8cfe9edbcfb3013c79f2c335118a9bf126c3053f24b078204d7e3476327f92dcc563e87d90f010223f3c52f6b74a918608748532a8df32920010327da17eb5d4180a88ea6f5e6a45bd27adc921457b03ef320d23c9b7630ff47d57f1bfcf9a3e44c48f2a98c23be981ad04aad235473e169300f6faaec6e1f93894be33f50b1485374a3c1719d1a35a38bffa679432a2aadc0c336abfe6b4a8edc18f29480d6c15b16315c8ae5495bb78142d8b1577d6b615b0e205a71fb2051c111d8bc04438e75c2571409a62f0b5d75898f09d6d1562fe86dd6c0fa8a0f23bd3149f5597c46304c4a44ee42d58b405ef6524913b523f14869bdaec75f956a5a73d2eb9c5949b72c149d6467af0079889517918453841dea124d40a16f2ce474598b02f5643a593e8e576e4d5d1e11386581809b0bcdffc7bc713dd9333b0ddbf86e7e22143b6b7d13711ea37196d8392706153b0d9a732e9c6a41d790d599c7e2e20ccb54e9178f7cae17e92638d22553dff502265232d405bfdabd2e99190678b45c6450d6e5ae7bdcbdb1d9b168d6c2a2483a2db1569c2dbb618fd3f31245adc34d4bda3f60371e9b171e2436059a4a5c29f01f7f99102a18e597fac5d312759a1e015c26b8bb0c828ad3c20348d619e05288725b69fef921256b71fffa4fc079356365f0df19026744f8395f9f40765604e2d56ec4b66975e0d163c7d797046100de5ce0a4915dbc0ff15046b71834b0b2721ff73c88c46d756e0302cceb3d443059f9b457ebde5f5a4361e0f0576fa88e3ab548cc213389bfd50885520f86c2aff6fcb15724e526a9d2089afbcdb0e52fe472ea036ec722ca156a65aaacb6c1231d8c4d6bef91bd3d5bb4838da842e21a75cb9bbc2da8022b7af0663ed9ac9bffa971eea9f46ba8010b04b3410378a9a8698f07b93cd6409ed8145d096727579190fd6a1bea56043930ea17e7452842d64182ae6e87536e567301d1f17d66285d93b968c5673c373366ce92c4ca86e39579a3a7a706d13dd2b7d27f729363d9976161cc14e9c8cba499fbb303ddaac866fc2c06041018b435a7a2bae8147b27b5a2a746544d0d7fbcef4965e57fd35d9f259cd871de61ac581df9a4e834ca103be23593e5879492559417ca82d2e60b0d4b9052a6cc9c82a9a5592d0107e5bc5ab74acaf1f603e01466970b72d5f0a1cb2fdc829a6f4d801d173d21ac6accd2d5ac7d07094aa5faba2f23b1bca683292c6a65241bbaa3736b825105f2384a103890e92b5651d1a52cd93c236d4bf48ca840af384c25c9b7ab425e5340ec02327b6cc63848d9726b890a60268e25c8c929d6c0bbe4bdd6087135042559697250d6487a8635a2d80718043a002f273e009fd59829194d2be633c2aa53610a19c0bbc384158c5762b0dcbb5495faddbbc4a2523f54a653fb2a33644fb2800d33dc23ddf0e668f1b64d2d0e968f51359239ee69b156edc90e5e4db25f67ce61c55b26246e0c6e1cfdffde590ce8b1e16521b4d1d13c2675950a18ab8dc4c43e8a9fe2bdc6a8980a911e3e1913416eba57fe3e6031b66524c479fc8547b9f85bfe2031e4015aa83f4c7edef207a2f46c3c095481762b8382f5a01b177f4ae303720dbb6e6732f816c7b30c4ccb528f618e115fec6971742f6acb87ba180c07b7b0c80f3cc85643841828d4043f263463baa6713718a0c857cb40ff458ec4cf70f84543d14727ad65bf52a561c6e8e54a5a0bab3c98307d04b2d4a74c4a3947b0dddd00879fd775d045f3b7d6acb7f28d5514e5de1bfc4538d154d737e3df92a66b9c1fc756607231b848c965f0b95c8463130ae48eb41a6d1cfb9ee364f54aeb32d35638818771f743d993c43b39dacc0e6c4591087bb63760b1f4019087859cde391c0a65c151805c8bba1a4130beb776710fbcfcebb70f4856f9bf95ca643f5c251f2cb2bade6b1994822b4a1c7f8a20feb2188a0beb068b65c8af2f7dfe2f172e5f29d1559c01de9198322903ceb83d52cab2400391223bae53471b42e00f25e002161c3ab21fe693cd18c02b760eb02d7ece77288f6844494374c0533dbf41243b2da22fda3e76b1bc926fc988f49b10e6e4480dac3506dc2de2262a0cbacf7660da952f164558f4db8e225ad4323b73495ce4ece7ebb2d2d5d1e969c324d825ca57bbfd9a1dab0ba0d70dacbce7087fbdc851879fe86e5baca506f9aaa427f1b67e17b93c118ffbaffb17596321b62f56ad19f380efd66c73142c8788bd7b29320ac50c54727b8914c72c44b244c52254171593150deb0089bcfddbd646520968924f66fd4e14c2412be3e1c8afbd18813b07de842254bcaac7cd6f76e476cdda200990baf232e037e89c59274221e8e1281875b28fbe79b3ec9899effb5ce3fb091b3e3473a5110d26f0b050460d6424dc1e98e071ec7c0b62ba9a3a36cca5abcfcbc654cf6c1c028f65c217906908decdc7bc073230848afc581f4637f3e376896c19dd82981c59d06bb07a3b2a0ee11de944fa313e7d4cc952f03d8f5b07ca7ea4cd90718e26c821688fbb470bdf09643ac92f4bbb156583d40e5eb00771dcc652cb8bf6f6ce05a93b94f77fcf53e4c3fe198292cd0813e66ec8ad5c3fc0758334d16c7de708c2449d2a9d19d4d3636a458bafa24959e56de831836cd5cf81418ab8c686d85e9d110418be1d1792d8bea9710e39745e9a6ae15e7113057a6a6d8201a5966e9fce80e3201895f51dbbba05100d8a458eaf5cdc9f1e37dd019ec485e81b83dab12614262db0d7249e0efb9e196a80ba3e83ff1159545be9034690dbf74dc6f478c92651d9b937452b0c28b5eabdd485df56f36b629129b7f13f55686c46a95b6ce18cc3d59fe3198c79d2db27f1d3d6d60dcad4c1af3048c2a02c73bf013b8893ea390ac540ec579f26c00e7c1d6431a0ded3bc7fec4904085037856cac4cd261d30ebaf8d6a66bcd57128fff74c5e8fa35994df4c9226844c20c34ed778da73540d0eb8a695055d24ae541dbd10bda96e0880b656cef15fe7c4fb572cfdafc0060149babe5386d7e9ed13801bbba97b55020d3033b090face0e5ceef88ab330013ba8b5ae34677f2fe2902ccd40e89c734c17ef4aef2cf65280f664e2c917798a032f980596d842f9bc0d16bb23036b28b38f7174ac41757cecb3332811cfef32b8bec88e9b2ffbe02b1e26d6e5239871b3df05d94404c4f5e34fd7431d1ce5cd1061b915140ae991032d9a2984ba9bf103fe6d009c9337fae87b59bdce2e0cc1da2f3dca63e05a303e361bdda43e18e25e4c60aa55b78f0b8fa138ccee2beda6ffab48c387196d7a53c2a8c078e2d5e1cf1fcc45e6a0c9e091515bf64de9594f2a5bd8d345799e4f1be0b8785a2c8e08e684563eaaa6f4976d9001dcbe0d3fda55235010e08b8db984e472fdf14ed369bae38c52742d31bf1f6bcbc3071f564cb693785c5963596f53e1afb433da1c9f8a91f809e1613249b65f0057e95287ac6a5854800b3dfa0e76c68040f3d6067f70a7452de65e79ed52c0d0bf7192a87caa60b7688e2ca40a8d6803f2420d731a5e9a35c22c73c44af0e725013ae2698923f8d7a8b97577b75719e0151951f47605e89099b2fcf5f5327f9a78d230a29257f87361ab8828c99de13132c95ca9c5416b1e385f6067838652f6667b814ed865f4401f2ab8b50054e9cb5bc1639bcb5c31456ee368c061b5dd060bbcb41ecd66ad265ae40973a0aa2f4b7667d2039b439f2085a0986939f5d158578bb3a68520bd6a06349415b950e7c91831dd789f516f21098f1dd5cc3dfe6c409981c1b5f23dcf6bc2a5c2dfb969180e62a0507ef89cbbb40f756537924c800969d93cd536c74b178f401fde403dcd5037123d19ea47364463ae70425aeb5347bad457fb021682edad52b728be94db2a07d37156cfc71eafadfa51b0ac293ea30e7757ac716f3c2b217695ff38c1626f11b575cfe3e4502c0e42f55ec8f3cfddcc211993fe836e424a909e9fcab278938bcf825b7e58b1763ee030e052541118ea8aebab028e002e210f1edd55c6edafdff3110fe22b9bfcfc1947fed8442130919e842bb27316d2ea5afd3c685a19e19d6d8258b8aeef6281ae6917e65d7c8f3f71aa3136c18ab6ea9530f20ec4862409b04120203f7a076be88a6f9c16c01adc7c0f6bc1b9899dff177eb9d91c4966747ba3892987beebad6c9e646954a3d7580092052dc21b01c1c05374883fe6e937be7034fc6e2f7f35332682ad2a337ec7bf773f2212cc98c37f3e1345dad718cb54490ff23c27314045a198242c654263de45a0ffc22fb01a0d86a194313f54af845c5d3ac090149d995981aeecdf8635dafb936c01982e73f1928dbfbca22463e58522c7cfb4a094b4b8667aa4f30a230be7e627a82d7e5fb3e2fb57b10f0d087ce6c7f409b57342f35132f254341a5500c297e6fb973e845918a2bd31944a01c7c28a6d5b690548b9840fb9b0dd8ae6f548c8ae05fa8602a38064aeef25084d313d42cd50e7a5552aaecf72659b79472b68a426b2e45eefd37d987bdf0ba5ca7bcd9ac46a32421a0982c20926faf6f7c4e6e4068a65e4a49c27aaac698b2ea559687a7384a09f89a69f69c02b24bc3cc1ba3ee66f2fdd3b1705742ffc60a882ad94d69c08e0402a93cbe0ef6c8ff5bac747be73178c1a039fc13b97075386f0607d03805f5f039e60610bbf1ed3ebfadde3bcbdb3eedb00eab68ca37f8fa75052b057dd694d3d76ddec8c344b16b22e5c990e8b2ee3edf7091eff3653f55827d4a301bb14f5efed6028ffdf5946fe4cdfbe11d8434d6a137c72f28b4f46298360327d9c1ac1244cbc541631ed59fad4b54b834b04dd467db6d70b085d6987d9c1a85bbe84cfdbe809d5a14366970a84b4aa38740931a9cddaa098eb883fd7599636aa661d780dc29ed0acd61f998deeafbe659e73aeca95bb84fcca7dda32513590a2aa0daeea5ffdf15981f2bb659c7617ef6504cc037f1519ad2f9f8feb463477fc32730eda1af5b0bf21bcaf6039461e8315c2624bbd7f7578994ef4a10179b3a0b9797cc32a1e97ad4b7d43a743c6290839d065b20c76d299a63fe129bf1e9f8b0c64896da1882cdfd71acad9c0f57f850eab40a5b80509cc94398371ca9a73d87beddfd84e0d9db14444a21e945c0f3ca966a176028c10572169f60011b227a6bc55ecb76653ac3cc96931127648fab776ac7988d602f371a4768cbda551ff3656fb1d0dd0e51bb114fbb209dd57ad810dd54685d57df1340f2c01e1a8d0f7ead76a41b757801d136bee671386d52ca2d3b4d3c6e0a2d44bbf13a85fbbd8bf3e31306bf7342e40c2ceaca07f4e6a7f44a652fa81aba3c68dac3d07d9594947f4afca05a68a00a4c90837bb0b91c4be7409fbb8faa31437e78aedcd990b212328768e193fccac48bef199616ce6518875ae29070083f78903ab9ee1711c0269e35be672d914f9690593ee8a2c1784d04551b5b12b79fd1924dab080ed33cc63642322f36a979e200fc3d07fefd10a3082446386342d7a26781cfd27375e98f8c648f5dcf05fb8f8654b5f82063efedd3c5f8b857718595b1326941b9a6937669ca15d34c1f2ac0b13bf5860fc465ed6c14e41aea27288e1547bba46962b0d7e0a2aa3dda2e9a4cd4dc666fd9667b8856bd5f602a68aa0cb64a1ad9f6449e6dcc23269cd1e80f61c0e2ca2b66bd635cd43aae1bb4e2c8f1cbcc7cb86688c9daaef56ab4ae526b2da0e51c1067971b2c4441cd280bd56ab943a4dfbda8529253580b705038f47d14450f815653a769fce47298c95b707a16dd845f927d175d07861228104a3f0cd9fb01a97697fc6fa2974c0ba638d19fad7ed3afcd1f488fb867bb4736f881c61c00e3be0b87553bd5c3a1d562db0c039d2af83c0f1d3d681c2e89df8ecc4e870ba3f66e5c100bf4b588f0218f5083c5bceb541dd8291bbda7eac50dd080fc35dd6d873890b67a7516c8af0da7eed70c2ff6e9691999978f2324377c4508f38fd7f8a9d97b114ba85216bf961e4bb235fab544ac25f4c27d832c98f497f81bfc1b63d4b45c4bc833e1076603a24a06ea220458677f517b8e0bfc168fe04e65fc1d9a26d801ab938895c54fb3cf9bdcef192513fc0bf267435fadaf1f5732943beea1ac2be332d04018f512c947180fe8ed1d0bc8ce2c1530692eb5f23644c42a5e187fe8631db9c535d291898e5fba53ce62f074d36df1b75ac649b29844a7283fc05215f3cf643bc3aea446c9e20cad187b7e0e6151aa1d671653bdaf738b3ad7ae3a36e615c2aa07397125a8bb0e546657105b774f862a72f03f2cd60cc2e1e92ec3890ac1563a44a3316a7ea437932b05347744a9ef95d46f3ef26c58654233bc6bcd8666dc5d181e448b13071fe2643c90b866dd09fb425c4f5db87bb012c3512793ac298d434a6a5c2b225b64ef45c3f286e353426ad30e96c5bb8fc3cfe89ebf3494a57fe3079470161ca9fa9fb3028074425bec5188e232946b320e7657a40b0358129c8583d8c264ede4fc55df60c38acb6ccd4584a39752822c5173c9160c7fb366eff43578716de2c576bc558b98da1f3dcb84e992db24ce0fb35a286fe561abcd1a765b7bcb4c3f62832ea8458dfb1ee2c2fc95e899e710baf12e8fd756c7b5287c0cdbb4721ae72936cfe2dc431f5e26c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
