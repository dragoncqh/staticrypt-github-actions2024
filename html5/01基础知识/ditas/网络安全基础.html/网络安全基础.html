<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b892fffc719ae361c3d50f9be60d7d59e6cf4fb94114654d16e403f294ec4c414e8beeb17588dc952483343ff63611243a33b0084191feaa5c05dd86c673483e7880f72e7e97ab7e043f610bfa061792982a41626274007567bd708ecb7aebbf5b569129ba70858f0e34cf063bb1eed0f9ebdf0699730468e983386138ff700f3b6fac74116ebc314bb3ad320422903382f42c28de7a71636d903e9db9efb720271351358aac31db83d66853f07306b504c732896b77e9b1ec074d9859eaa051430edf538a6efd795c39c4f1e380beff57c249428a7dab1b9800f13162c99d5f9dc2d37849f693684889c9dcc08fa5d51f062c03c2bdfa9b8fcd6eb9e1717c302d3c218163de6b1da0dcdd40638b48a29200a4a93c84e7c6aa37ecaca5e3223724bb56a560cf282e2a9c350c020a9f7f8c40aa749d21e027ea9fbe6db216f54bebec31efe420a727be9c8837f8cd180308714ad7935310a256370c6542889c156b7b0834a9c4a342d7eafb0a0eaee583305724094826c8aed2f22c9d63e63e56baa483bbb11071b61475451451f872801840efe56f606561437c4e75c796df4958a6421fca35504f5e7594228e5b0cab2a7c195bc52d0f3f77dec3bc3b2697c838644201d1726af57d499d543257c40f4288ae2b3dc364a965dab4f8af81f27f915588159d2753ca56413101d94df861a0edd2d30f9f990f2dbde661f862622996baf51397f92135155a031092b5f075e4ca0215497d5935df3458d2a16b2d585dae59cf30f479413d944398d6efa7f352d6063d7ab8205dc69419c290c73ba72aa3c39d770c97256b40018db11c046a397a752cdf8d2e98438aad5d2e36e9bcb9ebe5aa757676ca9749c70ac3a9eb6c3eac0a67999dfc1ac7195648fd4e271706fb2d0170d9b90bd630e45be683a91795ebbd24a7da273968707ff9324e236e5c3c205c2f2267609e5c831d55bd9128a4b80d861131a83e6c6335aceeb67714b63fa828400b94adaac6f86f9e5bfb33187238242e2ad99a3573d65f9002234fc40f6664739016f6f792b03a5a26dc70e8cd772b558f4f2484e0e58e4a0bb9589385b73f88c5414e97c213a030d9709997a673a0163fc99f2f33ee59d0eb1b3b0a97f0bd04c46e8188ce7e03285c8d6c01810f1750248a29803c9c8e0f73401d23e60f3b11a915e818a5bb3f403787074e29e227ab663cb656ef3b7bf9bb7b62766ef0257d91690d5951f5d60824c1c712bbbb8cbc1e5d249c907df55f019a491b61ea094eb94546d5676dae11eeec2969450e65420aceca97e808390a465e820a93617a4c79bfad45432252ccee5fbed97065dfe1ae3e914759bafdb08fbeaf5696d2f1293203ab6db098bf49d411d62eceaa22e92193578bc1ae763e35524d7d8d6ace563c22b194b4131d1b06c97a630c11f43b63ec71b3b99542c815650cfc80b7cd43b4d39a90b1c1f2733b90d31fb5ab51d1f8f9a9af6de8883b9f4f597aa6b5aa59b95b1325541486e433bb469af13c541429da412bc1c6575be9b8a86e352d5debdb36357a9781f56677bff74a946e9c82d6e6856ea12f9de8c8af60b22a96cf832d8bd15e38ef2dfc5b3c31dd14bbc722ef6b08d44964caeb7276c4c3202bedba6c9b740c63bef23b4ade2a51e98f508d1ccc0db5c137d2cdc006a439e9f7ae9ad6a40496dd90e6578071c8dd361926235536f776ba791c4704497258d35a349754f921dfed0b1b791de07bcf528f28c1ce4f06401ff8e4bf2e2dcf3a593166f77e1c53b4d681e69e53a4c71bfcad98d1759e78f90383a5739db05bc8bcadfbfc5bdbb0f9e95157bc077817b412fe9a79e1e5c19fed51efd3ad0168b75d4ef26ccc2e83819e2b98b39b4886eec2ecab17eec35a44849032aa6cf73ed4f9e0c66f040326fe880e9d6af87688a46725bb0c066e63a7f80d6d0a747a867670b49dd22df7129e485c165697ca9e625c044f51f4a21001717976539708515e03aa43b0b0911274f7e851729ba2b4269ef43d6d576270c05c2b4b27bdc41943586af055047d9000688cef43ffd356313a5cf673cf654c53817420ab29e54dc9047995ecec14befcf8ba65c402b50a94dc128114d96db66900c334209ec611f56323c3d1eb6a5924d4560a54699b1419e4ff9be06fff8f5ac9a3ab9c6b6a5d28c093440d4e4981b98347aff6a850b8c5f5a55201c5745df66457f3dc28b36eb52590e7d26f863e73efe202da734bb0f87d6d7b41f6e52c0bb43cafb61d1d464c7bdf3e7a44db96dfd4d4fc3b1c89040b84057fea55b6d95c7cb65757c1046d1a83110a563398bb26a481cc22ede2769f526ed15de5482b28e406b8f9ad75dad7683d76d7dc4f5eb24a3483a25f0cac18437d9561c1e32ba459308ef0f424a69f14736f7fb6213a8b2c6e44e8303d7a169bd82266ad0569c08ec8847ca98f378702c2d34ff96d3cc84eab741bcdf52fcbcb6a2e131b2b4a688524b42cfecaea44c192b772f8b2108bfe0f7069166fbe06301aaf5047033568fad9030fbfccab823082d356dbc3fa635101051874c34a42fb83cb755d44b6cfdb4ffe7a4ddcbee820dbb066bbfb609204f1e81f3d921e06e717cf52ffa35c491e424fec6573349c067fec12704dc3f05140e413b329a11129ddac7eab5bfc4df0c873572635c6e9c3934dbeb674d2c795837d87fe6c887de36c94bc812008323abd9ca12c8c806a1b3179e50f7254a9f0210dedb25dd37962b55eb6f8d9677b183e01c2d42a8ffb57d3d15080544a81aa19b880d1fec4692591104bd3d1a2bf3ef963b2ca533fb4994ce83aa4a91c3921ada79e1410fec1fab37cbd2d76e288dedae9dc135eae034b5f770cf7bef1e13b3785be4f3c86ec817dec044f2cd1516ea9e190ed070a51127a7f37cdb7b79087cda9cf068b3ee0c4380999d15b354d4e481335a1e7624e30047f6c7005acb40f271d5b42481d78d7dc079686e59d831cf2a57e8976ce6f74f93327474059c7a3df2a6de67e3ba8a1ca95f52b119f82955af85ab17f9270cd7e9eb5adf5d056bc76dedf31f4ef3d8bee5c10ca4a4f576e93623dff5002f72931371d1d684f4bbc2cc02cb450db2e3b464a7cc00d5cb0b8dbedf9e8f13fab7a223e3b420c00302fc4f9d55cf35e01320fff13f17a0a5570f4d37de2449e0acf22e5d44f2a230f5c63b82db42f9471d148c962955a323f7eaffe2b767c779132c9466bd9d95770a6fb07d372bbafbf8d014661e265a3074999684f7443d85c7831ba7a6faf758052205916cfd46c30366fc9e03cf2b3fd9cf4ea73c0a18346d0d24b9299369fac52338f070e6c335957eda1c75711377224a3856205d9aa210b1df8f37e8e383d22049953675f411d6c03a04b4d3cabe46c125b4876d72d386d7db28de8760a50dc4fe5124149cac2e3059278f8330ed10a91c2be357cbbbb12191d8077a69838f9d50342f144740451cc584b36b18167392866eccd287f64abbf7acbd2c6bbec4eead75480f1e398eda03b3e51d891133200846a0ac9a14e0d3ffbd7d668b7cbc6e66f8faa8f986912aa2309625eed0b686c218c738387c6a043b781e3b9391755d20c018ba94bbcb050bafcffc3784a883509f201d1927f03b85679513a86a477b3028e2fffdec52b6fa795dae80e99a9522873559e1d37b8ebb9fc7ab878dc5e30dca183155b289807f8a0db47a3aa17bc88340f1f0f6e828c763cb8507acd2f0d0e31c672bd777edc17d2eb3450c9059720908eb71d558a015dde117f5e23cf792046826b8113c05ce99302f73c5ca64cf2c1f9187631647b175b5f5655b98a66b2c1acf3687d7fab9dbc4768ba33980caf5c3abb9d8ef0b0c33dee6a2188e1b400af17d2b5c814c42f93ee83e1c8f46b7a415b38be1fc062f450be6d266130df9c735f04373e7518ec0a69d9a0dbfd0e7676330f4f0a65b05fce2aa27afcda80d02ac48714cfc4ec7cd50f11e95e652bd0005e0666b1d870c01a8d6e820bcd0113828ae472df599286936a47e125fe6845edf33b773db77073c963d4da6cffd1973cd5e4b54452047813dd77629371f6590bf4188edf230db5601b7543243d01f4f2d2d37811ce1d2028d1f669326a57d595dfff6cef4686b9cddd12adc3285da51add7e7398f8e793efbb5cb2986c0b8a3a8c6da4cdb6dd6984587fb78e0c7da9398332ed0de49250f133dc622247d2fcfda7e3f04ad9e75951aa55b91a9e160e426d390f4d5c2667ce3e5cb2daa59ed0f729bb50d18cddef11e3bffcd6f47e4dd0268ba9a231d7a6a4e9fafd9785215d8ba69f62d01c34f47d1b93ee7cfa80ef5bb141c59853f14cddf0e539225f529e957c08c64b387ea9edabc1ed7500e406163798f865145ef84eff903117fe9f6bf671fe6790720448daa0a4d8433387772e3eac1e65605434233eb5475a4c4dadd31a8417e66b10b9277bc52fc65065f9ae992b756224c64b70802cae73590b7dbfde45bcac1e46d0606cfb3c43814978b357d9a60b6bb154fb251acae043b1ee2e7ae7e9f5de41852b9c433cad223abee2aac88390679f1d8319449ec93c7ae280e996e6ef53ec41b74cfe8770354ec8b3aa377dc49f41c37a553611099b31f6f708e3342298361fc294bfb7f35a0c3f64fb4ae6d3705ea4b7b702a5d25fc9fa539ddcda41275f9ae924b336338359b76e06581c5914f7cc063c88a2590b21e6895227b7cffb2fff832160ff9a68a5f654851924f19fa188ad1969d86fae893a3696eb10c0c2fcc1582b214d95ee0e77be94dd8a64737da1fb5c836cd875a27fb5137439d8d6a06c061f777cdecc079d515723b5612f64196bf22abcb89d6f7b6be42b4c5379dd66941525899a66e4518fbe10bab26735b99fae08d569fb9dda02ab29140d9301a7920fedcdea778c5657f8b0e328e5aabc7dc32c4ec39019e41a23dac40ff8a13e8373db4f349d7db00016178248ee35e9ad5d3038cfe19a1c51cf7295e6924050659c8aad1025461fb326b03a4511a66ad998be6695d215dd0d76dfa20e59ae3d066b87db6280bf0c0b5f1f2da85f3ed8718667e9da3735a14004f05de6886ce9e7f2d7250bd12d5a15d856fab276367d377202fea5d5ae6a743764ab881cd139ec923742b1169e4425e5b0dfc1f0e8cb409f5c9e5be34b59bba7e288066b94e5d63b52adb28018e42a3614da39b4be69c75c5844985dc7b0cff1995b3bed32167cb634aeadde285d1f9b6111d3c5960dc7db3b48280c7ae4561fd7d53cd48af4821221e6486781f052487f306985729e1e4b9c3e0699f3b78e980b63038efbef330023874c8ca32b6a103749df25daedda9f14006cfca8f7935a383afc6b5e4958a7189e07bde8f08a0a25596f3f9eb3378f673f2d4269a6429a43cbe9f1180845b799462f904534694ef2e55873ce22144883b98db434c44bdf9f7423d6b04cc65088a1ac6c09d610fc1ea3d4ef53b37070bd7e9eebb79ffda0e613a47c26c919d418069937a25c6a32efd549c317fd6b3501d455f21e0a0bb60c6fd0c7ebda4d30db1accb7d59b2afdb62b75991f233d6698cc7936f44c99bad111aaaffd49255edf5fbd2f1738bf826856c003aba8891ef6bf099f3ac488824a1c21722b1ab08ecb215f7e7d92c9cc834e6ef1a141b029450a078887be8e3457047c98aece102533d40740f19f4e6327e0b6ecdc668acca63638efc22a68210df9bf87b7132f2ccf8caee34b380f0ee9b867cf9e4ba001ff4af9bf2a2a915c803dcfef88cf3a17a20df7c0e5eac911bf8e698a62e2eb1199ea512cc0fc19dc193495170ddea59598fda1273ec9e8e40309c5184f41d6e24a76ea2e38eaec41da3afddc14d3b799d312b0bd192b5ab516050a49f9b7ed5f0589a5627a087cd039c4cba8495aa79222e271eceda44bb8f8bc339b08371b51b9b487919fd388e386fe8c20fd036716ce7d2b3045aa37deb1845a666e3551648edf5432d8a39e1650123883c28d597f533f194f04f7bda0c8c0dab97088a76363757e9238d93346e4ba0c9be65026803207eabbe408444a57495f738be7d56e6be73cc8a9ecf8c8e08d101a35b64a3c723ac1dadbf3241a295af532978364705b2da8399a90700aad82f8d811a50aff1868ffff7e53f2a2f19f8d30ab0c7d4bb71c5a5a80ba71511cf0f1561c8b3cc8830eb8752f9a85436f1a73081e42ee0cb50cfb5970f1e476ee9db3868f40f2079df472716d85cf59d8f06e448b79b325a19a4b3583d488024afa06bece88b43dc5dc3ebb4bb3020baca2b5b7d74bd88e85f61ead5a75a3d5a4cc06576942dd12cdc2473fa49571b7f39d39f264057ebb75f26643e5b403d44976bc6c64d9dbe52b9977afa7beb8b5b476e44f0e16cfbd3fc5eabd9b01af8e518de78eedefc16e2f07cfe503fee19e2717814144e98f4f3c0c3df84777e31f8f22a3d0aac4f78f593a6246abeefb000a8eb8ce0a0fdc8beca72bccd4bb128c53518140bb6360d70ac5eaaaf1d12e7ea3ffca51af18827fca7d119df74fc260fdce86776df23dd321e2bc1bd91a5685ed1c4cd1d5448991bd506a2570e069c35d344f81e5c55f56e733c4cf4d9caa11582fce853f275c391c8224d2319eb45ce38f5bc3162b8200f532207149e1b11fd9e82a30b403e9e6b38e30d4d1e8b131b61fd18c5549bd608a04eb469b8bf6be3ef252b75d987c04bd8df0c905b8a11c3fd5d0d10fea9d378a866a0f28894c0804bbde785f6719962ad55a380ba92532ed22ddf7a14ddfc4977f2423769eea2ed7af1ff038ccde68778846f79fe174ec89517439d570fa80fb988100b089f964b4d0a1f58fc8e655868eec92167a5be202f1aa94bffe0b077b45113cdcaeb65607b033408f35be14d9db043771cd991a9dc88bc9ea4e46fd6c6829b64653d97215e6b7693c8717863c4982fa9728a359559dd5b7a6629dad12062b10b0b1759b9d0f3cd361afef1277b8f503a3c8e6fd6fa226486fa21ca12fa1b0ae907fcb23a070d832d6b24afe4a31c76d928b541eaf43f27c507fb913a8c588a68b3e98f20b92c3853f181a4277b75a789fa11e33a9eb7b07b67a0d2c17b05e12451bf2a6d9bb882b995816ef2bf98f320559e64b93331243e8fa0733459153049d878f8770be605092d6a39023992c9d89bdcc2f341b0f7dc05fd9ff7ebfeb05fb11aa8b34bab0e0f1ff1f7725fc9347df738ca29bdd51dc9561ad64c596d2206f92f92615e2a9cf23143fa9704fc89c93108fa2e32a9712a705a7907f30a06dc83c738123f4ab54e774ab5f3e87b436dffecccbd9c00abbbbec49eb7ccbacd9cb057ed35a4df294d3903351989b4ab0ce207fc765a6f5249fc68c37e3199ab1b90d6368a30e531fdf8dd5e82eb43b5dcf44fd1d38adba86fb1a8e78b06675553cda1e35b1c282dda7da0379026845012b4c841b9aecd279b5448ed8f26aa52fa9ed71e892be5409a445f007697cf3106e21cc36a0bd8722d371eacd5c796fbd7507f484a3ee355400813de927baa99726a49fb2d2bf33c8d74ca56ca04eb2b290af26d08886929ef4383bd3015bac2286d9a902925e4efb5c43f2855a61984a86aba110d2f4825335aae56e86e10e86deeb696b18cd77102e84a0ce68533312be41256d13e5d3e14879681e2ef5963e9009a2d1745f31d240c568671b60d5da9378cac71b801cdd04517958b45e32e5f47b4b0d713d47a14ce557178c82fbd9ffafcfc54ff657cb3314834d1b8c254adcb8e441484efc1e3ba244246b60b0c31c58e186cc93c70ac31d5eb69c5dd6d087ce11f650e45739cc123767f4eab6122e3125feec050831032c132bd2a66666d8446c09d27f7b3bf9479694108f6af2639822130b2a2b1a8a69c3dcd4a7cf5be8f1ae277620f6e46f4d8ac1494c8699053a1765310edcc0e8c5034d8999cb764f8c977ac0eae3a22102378ff65a07b1439668671986cbe0a666a9fb92a86ac5f4068382ccf095800ffaefafb4936a23d2582b431b6ee1a617088d4e1e87d7cca0ef4a26ca3c399aca8e2be4a3098db09f6850f45a7a41ef2e53dcebb1311b2f8551ee9b6cfdd47e7277f31566ee48cd537eec5b9444eecd45f30f45fe415d7cb5a20dad179b15ecba8aeaeb2b14ec4d0c5dcc790ea58bd7c5598f157bb7957eae372ec7f51d6ee239e007d7c265a6a5ce128cfce7fcc92f82b1158ca46fc2b7f024316e48e757dd357b0d9e87378cfafca81d4d60a2ecc92a5133ee9e90dd2cb9b409d02f9bacd982cb8cb68158352e24d4dbfe5d52af342a756287d54bf5601b7e725e4778aa95c2cb3bd9814ed144a8e788206fec74546d25785b29b6ed852ac027875218190006239bf0d10bee8cb8951378b49c69c967c2dee06c326eea943f41c9734f788e52be4812c2949058f2c4cbd620c7a416062a93bf2247c4718ab5021f1cd3ba4e1ed237ff1f7ac5c82457af2fac8b116040db0e4f6896aa2144ad87ce75f3c2024eeef05d1fa4e9920e383ab625c3c30666231495cce8cf70e6eb33774acd7e3a32c76b6b8d1e64b10fe06c92bfa37baac7706a076ed855c35d0a2aa68565cc3bb8680f39d33b0d22a3cff553e089ce975b84dfeb747579ef8c6c2a513646d98d5b558eb856389f0143cd0127a58f796d7d4d605af0451571f7d85ac23e522354b9509562ff1d5168e55294fc8c1e94f4357525c14ce72a530406a169ab6a0c2315305bff502183b3e3964b5ff22e9d629b9feb7f14f618c18b2a2c0004a0a72f7bc28c7f65cacfba3b5c1120989a01ed1aeb61abfd0d84eadb4580bf7608b33d297ddf58d3ef844d5cc58e132d828ffa8b7dcc0d16543e54631c717bc179d374c0cd451d044b0c7ddbe6698a5162b9734600bb04bb1678684d873013e5c2ff543735c40ec3f10cc8c5027a3670aff53936f3505a5a0c60d9d6f89042693819ef8cbe3497c49ecb5ae76d88ff5579f5a888683b01fb4c9679889d994d30eb1577d397e25b0c9ac2347cd31709c209b39bbfe131f7b480da3de218545c0ad7c5bd7dcab0e8d776c887378a9df84e41ad22bc3ba3cd36aaf1810c6268aa0226bbf9b439df604a1141eda66d7233969dd907fc9f9fd035da48a4898009ec6bc04ade23c72ec0d2effdae459a57d4a5375103d63e0465ebebe9f845a973ce106d13b84c594a5d25c7e782ab033c47c603ee56ef11188662068c123bb7914506bd5a3b71eac8130a028c9bbe8bac5b73239f5fd0af4cc3e400cc59e1e914f34a12dd75c70bf68d08a33bf9e8fdaab6a7d5cf623ffc861c2273a36dfdddd60e3028611af8f1005de96387cdc15df03fc8f3d1bc9f92bd831b0348eefae37f167d54016673c9ed63c7daa0dfc86eb44065dd8dba764f172d6a285ea000ff78e7dc72203535a6c526a57c6b6e885d79466c80f41b79ea19b332f03c1bf628e40f5e41083655dad68eb70cfe57f17a09a2e7af1056a171ea4036526ef3b095207f40479c2df7efb69581821ca96df88ce2dbff9169129626fd3f4ed5db29df6353dcca53d1dc7798e5e15e2c25e0bd42112bdd4d29f42c1f7a7cf559aa039f6462b528730e5a3dac61727f9fedd61f6593fea193ce9a9bfef90e37adc68eb2ed36831a85a219809eb3d721439d8c46a686cae8c938a509598188d0a2a695827411a78b51d437fc115f432f4f57a27e4d73dca357c9d30a20ac52eb0c62e09db244064df8d39d4300551857889ff591477cdd97de817b4170bedf95ae8e1499ceb5581fec8fc4974606e6ebc33303f69ee564a94e99d02ae2a2cb9dfaee86bb894f854d4bff374a95544d49a016eface380209b185c84132a4758cc7241a72329c9767615e83176f812e9eebaf4b474486576de59d08b80316c322ba350a9e91ee24a15eaa65b9e3fa9914307e54765fb10568879519762b67519ffe3303a6f5ec0d1d6fd02990fddef55233558d0c1c46acf03025c84e703f91e57b0ed3edabef377c2ac2c480fe6be73d42f5261d22984f3b4e11fb5b673c8106debb60083260bf7fc3a6fc2863541e2d7a952eb90b70c65bfabd4a60d5a1782c6381f8f989781a253c246878b7072fd7112c23b84b8819f066cc5b8c40d2ba9fbe0b4e49041a7221ce8918ea827b5a55010e16163b28a80d7643c7657b144b9fd4d7ab3ee59823c68d0c0e716f7c8ca494159106d0f46d03990642dcb6208edee884b496fae868405399cda79907cc5a246a6be7c0a6472d82a0965cdb5d8d4196d8cd5032a6dfb31dfd7212415b49379ace478b9f822cec1be046fa7c7782b90501c8e19fb2e8df13ba8e74fb42db874a0bdbba6696ecdf3539c0aa6bc8465eec37e99ed024fe641b3a9ac51e40d65e62b2b1de6188df06db4346023d294bda78d3fd0d74d1361bfddbf9937b9e538d5eab9bc74c31eb894024471bd0ce10b7951468ae6c8bae2b820182cbe138d35cc61babdd3c13b17e952791fbb5d6583f0d2ce7470bf1aad91c3a036f70a516ac92c1d2dcf278a17175627492bdad2c0a2e76eb3586284103947b12f86a9aa3c61f1c47a7bba577f02d82c075abacb89248045df32c582981b981d2617619da94f76b11f4dab285e233440e95efa0650df1055cdfa77c04e48bbfb7759c40472291048ae8929f57c83c9efaaca38a0de20a7aa88df1fe6f4e247f86ababcd624ddf6f8c84f044e343f0bcef31e418da245c477c2b3ce8ea606f08592727384cb69e2ae07d8cf1c6eb74f55fa0b150e57c648ec4c1624aae891123fc3f3bab0751053c3874ab1e25986f076e540f29051008dfa2d092c5fe2c8569e0669fb7fac08776ba389d031ac2b381d4a263c3bd54013e27514e9ba48ae4c46b9681d9007a838bb0fa3e0ba3b15e034c7ad416b9052b1e69eddd301833fbd7674b344e9376487f42ff283efb3179e1d16f08e1efe61acecba5c3b314df38e1bf0236e23e1c67f1fc4a466cd8668a915167a7aabe3e6a9edbcd7d5a048ccfb44a953da753fef1413187527e63379c77cb80dccb0ee8680cf19a1998e46f6ce16541f04ba506afc7a5b0a8dab7c03ab0a9be30ad66093a182506234bcb2bf68be4eb8889e5f988159d10fe0e6d778be6c33c94084dad83f22f65ec9ae55aa20e3876155cdc59ea450c773adb52591883ca2d543398e7b18eafbbf79580804b8cd0e38e90f039c2f93a76489b3a69cbba2c49648e552954777a4876987e73ebb5baef421f6e9a93d656588d81f4dd426af654d5c4c2d2e154568cc2100d03e73c3c1986a5faf8f9e7913731735abed04c98c4dfae5401a52fb012a3dabd5add8d822ad1184f6e12456716eb4b501fb1bdb1547f6e847d40ef5ca4e2137d864a03b7a590a1c0960829f2b3ff6c7015c71d362b5e257b0240066e931e1086865fc6767df1f1157b99a053a28dd6ffa2c47b6d93d40e812a1405630efbf14c33f0fe9d7fb79fcb12abfdbfea6e0d1e8e3a880aa9333e53c25dc72dfee4c212624959cee1b2325f7d008aa9c247f8d148296ccef8d0ad3030112c73c5a5c087f54f831f8a0b2ce31462be33b6479c6fa5b976b21bf53d1b7038f0134dee7ad5689a904849d93c7772aeed130497a2f68818ef983297b09dd43ce548415dd7bd698186bf74991f2d6de84956484143c46dfd5e8d1f41e37cb0ac16c8a7b58ccb6b3b86be0c853d2b2531d2e787a43e2d8d026334fc0d302ccacb0a39459f81eb128a208e20496ddb129488f7c6a73bf558375c77e31f883c66dc6f544e44ec097a82b4af94b8aac5328d5c6c55c83b90811411b5b714a06741b5b4015732788200a7f298122866c074917161ffe619563a2db44b3d77039beff2e19c941187f58813894626321c5175ed0647c50866df9d72c614751083432163985628b09a32401bece22ead4a6578318c4ff4e68a3bb0010058322287aaeb1ed222dc9eaea8dbc9ca0a4dc12a52b4e253c3cd9d1f941c2ae68e62b3b8a292015fe33a009b7ef3ec87ade5124f38368017e897747eef3b8688c8f6478825248d814ce353e63dd30ff9b6a7c680a79a3589eee31929d48ddf31751276ef445ae74924e422d3bdc42ff6259da5a12f82fd4a25dd6ef08769698cce0b716b782e9c9e14831fc9dd28d67065f44885460ea8039d270ecd6c8e56e06e9413bc211450a2b3eec2f948ce8d426f1cd1364b73d9df903a8c3c0d6cdc51b0dc859667d0d9cb0e49f514042115d008bad82289ad4d20155f8d8098b3062b6adb0e52ba1b9a7f09772e0d83d2b8891b897048cf804d18a8d79cda4a8ee1378634d7bf4710a3df41065c47795a35f6fe10c10c8fc57d6661a285fb876a461d4b2947f0a88a0656b1d85e3d3a15f9e6e1d2a28248bd1db8e77c39f27e53987a090afb63d4cb9f4c1a1d1725c97cb4ed08c98c39e936cf8dd2494c8ae8034db8b6df54aa2043b347477dfbf05c9caa5533d98c0efb188a42163b85b7703f0bb4e42e2a5d5cb4b807ab27a415994bad9537bf2248a09e515d75b2b598b83e239ff24c522a9ba66d77f7a1aa67386f72eafbf932e51fdf8bae511c3511c3d55974f0148a892bbc4a2e96e80ab25a81a2d454aaa1295eccc3973a8411abd2ca505b45f5299f8ac48e3066dbaa099765a39c5a49a6ba02602360dee87274d4ea60a6bdd6bd5f31f7acffd79aba60f0f1ef9642ad38cab64308450d83299e550a1092cb44f59bd46cee06f0df24ee86b86afeaf8343c900aaa8b6e8ec64ad0290ec0f0e743bfc3e027e061a2c93d50f32322c9d60d21e301cd12cb6b014dac0e18c401ca14ce60ff54a9e6a586de49ae80a0aa7005fbb216c7df24b5a915006155376bf1be144870b3a07d0490a4b76753802784875e97ed11737814f7baa65772b32b4e34a314da92f47c103888ad0c77b848e178bad4da643c4a04577a6306156bc3cb3df93ca7598a0e15bc6ceb43c8a5bd26103f0c2d7804e7cc6d8c4fa752f43dcdda46aa4a1b9a4aac62627529a29bb21d94b687d4e75664b1cc611c6bab7a97dc5ac70a0ee3eba4668db817baaa890ddd3545d28cb51608cd53c1b68473de19ec2e4fab93c445b57b325d48befe76274b1bc8c8d30658ca63a9a9b12e9182f7dd0634f8e875abef7013678ce83840d8cdfa2a78f8c884ad41d40dd095698bd9ed8f64b133af1bde9d6760b3b601b92d9690d890cab2a4f0d8340c07600482309eb365ee9212f0f9121a4c661c7aab9ceb4a23613b0709e2315c9756cc96377cf8e61dce7898cf404122931ec6b06d506d84ff9b3562eadde33f50ac7485646b1f7aa0f77359d1b16230764c889c72c0a3e5555dbe599ef97504af52ce47e8ae019d20a0379fceb8f47f5cb8379f9d9d683057129ccbf23d88d1ee4bca66defcd363a83e4c643c6e3f367ce57c8604ff5877318ebb1bb967bb4354de7cd9c4cd923129880314ca18c2bba46cf57510e8153065c9397d8cae3baa8b67741d45ef7a4e3541d1f651029f4bc76a74b15dd6878c9e0a4b54193f9ef717cee16ced60a2d37cd8c8d0b1a0d3ac5516bc62ca6eaf88b6fd9eccc7a334f8e87a1d4cd6b9540a670d662aef21b2d356a5430c952ea622fc8bebe8d5d14c4553d5d3b9c2618b8c098f39edee9e6690982941ba9d23c804476314c96ce1238e9889d492e6f2143aec62964a9edbb56dc9fe3b1aa5d03ff466ef899bdb1c507b092c9faabe89ef4c1bffbbaf05fdae60b7c4323628b0cd0ced293bac651f2c4ad76a9f880e74414335cf341c4a747d59cf3700049e29556ee51f3f2620558f70ea68516842258fa49ac9f7ec21f663fc92c6fc12e39a7e340d2a51ff664154ab4ef441c6c042b10b7446d2d1f9f5577d87386c8419a1d16a69420c71b2efa762abba466a21d5ce8dda7e0919110e267f70a32c70e3d178e12aaaa2b3a85403860008e78c4d98ce9f1ea687f5c6e2a748c099f92454786de3d90674fe28dd64f64d531285c1a71ff0fcca66972ae0392d637a7fb5e615a3abf668a4ae0dec1153087f2743d935de5fb70c8f24ec1edac1977d579779f7e587d7efc0d4ea6e0aada8f68dd39ae150096d5e3702ab21ad4cc0d95ab3e5951008da2aa0656ad51ac5c0e541ff294dd68d5ecd8729bbbe1be95e9ff06a69d4d186174ebdece75a1d1451636e8471b977cfc2d65a4895c487f0feb54ea96a1a206d92b7875623f76f01828ecee6a8b379c41ba44b41a638ed5196a55dcd601017c649ec93283ebc80c05662467c80d3c36da75fc48c054f8267cae5ee4c9a59bf75f59934de67aa00c30d6fc7c0d83d49b2722f18a75071d8eeb55c77dd15a52ab6af36db1e8023d146912e31b60cc1855e783fe3d5186b9636dce0b21af6c06c827b65997b11bd3521ce9b2c4972c6d6fc6fd7d2e95418c35ca41d82048039a6bb6d75f1a759627ea47ae1d13f65e514050594b8f7ee7f70d615012f59187339e2271b0ed19ad7654dcab878ddd4d7a0c49e37a25c33f8ebbaa5e4e164ca5c9840c31caf0f1c11bc3c54e7e442ded30d694b9b811bb1dfa1bfb513b022e903f74a390d936434276606a6c3011bb84070084c2df4d991f5777085392d4a49e95f62f196f14a3fc298639c8683846c5c88a859f5c9ab87b8d20c58c10741f441fef2f860f84d75b1f06adeffefa1d3875861b663484f21298be9ef3f423d9a2a5fa3f01a6e795d60f76a5750656212811b5a0ebdaf2968558ce62ce0660dfdbc2a7997eaacae84f2aa499dcdb239235ac60b18b98c69ccfcee0f196d2ce64654ab73cdedc3041b5fd7aecd4fc55ae4536c6c1c3b12e440e765bd5906bc44e248940f9fe93236da49b6213f28fdadda9afd347ba65113197ae5ef3b7be109d07170757aedc9578d3ff940a983ad5245aa4ebb184ec8a9dc980b6e70ad39500f0740850312377dc09c916e82c0f40684400ffab84ce190eb21093f7c3cac61e38dbc36d5201c446c1fe67e8ea79667368b1a20bd44631f39a98f15831e5e028f70f47fbcdb75706faf806b12b6858ee4dbf82cf784a5864595cad6b006d03f3c870a7386784e8a0b9b3215608361adde7be500a4e990353f53c36d025da57308fe1ed38d22c3370cce066f747ae6bf44709203203b29357eea9e1c5ec09d47985fe4f462ad2aedd38eff791b651162019f579286fe6e932e1287c40102155f595a8a7d66effdac7d50c3bce73584bc4f69ff9270603003552b184cf220f77db045ccec24c0b661c5979e4403ad178792a2052440c25f565604c91093ace6742f331c82fa413f518953f5ee92fd49c81922602dd92b0ed3ef059be51465bcd571baadcf21472441ca4ab12f1f879a1b903b18210bf4f7acda7a17fe5a9dd42278240c4ba2e18b23b507d21f9bf5ab04a5045486b6a63f798d0574c915669ad41e209b0b90955d935f510e66a68f8caf8241d1ef594be8c1a672123875bc0d09138b6cc67ac668889e9381b6e35065a5879d80c865b1bc5f9c33b60633f2b6e67a192e16eaf49d6258c1366654735ef10c4b4911a8f7467a121d5b59991032025c32b3cb85e31f1b9e7a6eb9eafbe1b3aaef1921d31412fa7bf70c4908b36c7e0da18021a28da0c0f7b741d9f9515a6264065830f86dab95d3bd9c44d24b4ff1324a2fb8c2dcc2ac5a6d7b501d08091b749557e6d69b1bf9f717e19158d6355708b520010f7226b3345da05804eca3553e81ad84f6b25593fb8da1f05fbe4c94f624308b80ca719566a1848999224491b8468a03edf85762dbd5701f897f775375a7f8885fc6bb9ee3176f41659a59547586137e6285e35f74c937c2a077cf5e892aea24d46c042f7b37a18124737b48f1b57fa900d70a4827323a629e9d20d883e475c52d15f20142cbfac0669a3ae37a756d158814e2525d01244a3834eae9a1fedb25f700bb62a2d86b04c46006bb1ac133f29e0035a0b34af5a4decf1bb3e71f2b04d6147fad7049784d56bf74f46f50cc0e0172631a7f7b53d08566f8e3586e1991b0e1343e7ad41420b21db01f528c0a1110da402684a9c66e8a248cafb4235f352cae24beb7b1938265759e34a584918e68cb381672898817004a1087e06f1a988ffb64f115b154f793807957ddb6656b75db845ad834855ea79616a948720cfd1bf70b448089faf68cc314afc44c9ebd6f711a9bdf9bee443cc9acd93cb06e0774ef7a9f7a9dcb50b99e18297d81bb8f898ca85120826bb1be8e7d612c013d6b936f033d1886abfb7df8eb6943466795559aa93e1304bccb3398f48c5a8e03dad1b374d6dd2ad781c9dc456be63308f23f9a018374c0020436c3bcbf2750d5afe300a9eeeb48bb5ace2eb1d0c2047b57e8507204b99a60f83a6593febf1bd21b74eb102b20905dd5647a8d094786ed8342623329576803e1c126ac44169dd6255a892e4f0c93124f0e09ffcaffa6ff739efe6127262db89ae467359555d1d3c0993fe0e87d52f22b2032473629b4017016e64fd51ded5bf741b7e2347eec09f3d59894f580d10a66ff5cbb76b87ca350c591ae01adc578179e7c369b9106f1a483af391c00c275dbee046f66aaa6028a59b1ab107469ebafe91c5afbace1922998d8870d334879c3598efa09caaf044296f1a79b81e1479dba7ba6b73683bc034ff967ca2d8bb98b0999f27060ba7bade29d23988fa972a765af2ea25abae6cd16d2c1a9d43aba880af60a1bffedef0cd2199e4e08b226220987eccc132c56478dc98fcd82f4a1436ff988503a5b9fe42a76c21dbd2ee4bf54feb0ec254450a7c9a7bfa08b8e623c02b57b53fb1def9257191d6c5e6efe6e6db9d727abc83297057743c7b98f68071db8711254dc59179f41498bd6cd704eb801c5a5e3ec672be8851a701a79a95a424d7fd76df0e06fb1d916524a5bfcdc195c84cbe155fe645d2330903994b656e211edc9fc9f7fc21c20c66f641954a11c066a4cb6e9f9f3cb159434a5670262aa5f1c3e66dd6dfa2286d30999aa487b74e09bbe16b527ce0a7bd91d589547fe866afe632ba3e46d835fbad8d4a8b3bb1d02a5143bbe49abf0465d7a0cced1edda12e8619a9671229cfb6583387288e12784b3d7fab7ae7aa945423795888c4ce7e75ee81ddd1ee416d87763231c14031c0eb4d2cdc6a55c921159cad43bc2c31c24f9f759c83dd6f1bba027c7cf9fda78f1b137aae68e1709d6b4319c4b9a61d0c9ef3928fdf878e79f8241174a7a3c96aebfc4069e1104c22d3c8f0b0c5123e7928a9b8043689e493a9eaad9ca32c34e96c63c8a4320e1bfd4e0143c94caa06a91707a5ad1ed98af02a711a297f11875d595aff367674a5fd8f90cdc7fcd09bed8787dfd260e6e542031e3265ec20840fa983c5d410a0a048a0c56e28f8cbbdbbeae6474e7f0afa2a1722b6aff235d81ec92e3abf1b4504bff9e10031a574c61f2891a741e115b37da79b18be89c8cb0e7e08d13207e19e94a53f46393414903f92b2ca20d2fb9ae537f2c5b8998c5c0a5fe1ef4d353786d99d4d9d726eb22bebfeb52675be963c8e50eb99d8cac2bd9e965b11c36e634a421b828ec540e2d1e54ed500db0a8bb062d3a880e200585b900a2002146cbde7786d8b9dc6291213492ab57faa631c2f5be7220e9147f0b0eadb63ffeb0ae5b69c45fb8c583562b24e0b8a39ca2ddf90ed4c9895fd852cdbad7d40f5a36a307f86f357ece16ae02fd0c0e5fe0f03745daccaeb2af10c1452cbf1df6daffc7485aeb8ccfa44a163ac10a10a063e50d3f59d033edca76179435d960f7750e987b2538da36ad2bf3fff1a8efb2f9fca5e01a66b8b974e2a05cda3ac7d531d6ff6b5b3af19415d58e542b669c6237145b1ab028a3cf3548b4a13875714c744bb0d80a1d4cff0cbff94d4244d0210cd10150c7a2369f8570d0f0425619edfa01f6929ad4590d189ac34343a09a58ce2c1cbb687af0edc5559bfe9c11ff34682431a98af2803f7a56ad3681e27e75f75a73f6f827ac046c85ac3d1b6b8829c3f9159e50131803618fcda4e9f4c7eb1fe6472bb9b3b5dc4b8d1d898f6712df7f6ccd49a665898b48f79ffae15af6bb121fc396b788ace73e1f3bf16deea471fa35f58b219cbc1847eb5c53d052c486d12b63cf0d1b052a0a281a1f43c330110a73f1cb81b3c23b1427e4ceae1229c3b3254e8a4e2c115e4f0b92e07be84c856cd5ed116cb1e5ee995f3c79242e153a6539bc318256f9f9f2ee46606e9c93b3611ae1c93a60766f752a6d9cc9668e1e4b739af76a483ca9d2144be08a4556c7103b9ca627db35add5bc9d9b2f32f7d45b2d06e4578126a4ff5ae71fbebe0dfcbf11b981d37aeefd5d1d5cce03c780ac57fc592cadd7e185fcc8b7fea0f83fdd9968a22aea89876025e090f3410febe3406ccee18fd3df03bb97ff89502ba5940e06d16fdf20a7b021fc5c91456399c25e2d6d533b77e3c8ff8d96bf9308e0a4f40858ff512d8819b7fa2f8f33c9016e539262fce8327fcf16017b845c2e3e37f02c456fc42f0446f6a4be818283806e90ddee3e71a69d463d43b476cd59b273254e50e1d9f1e7ce18a3b8f08240aaeeb90045135223f5f16604b6a4e3f1e922b03ee4b218646f67e70d582183a01e6682572871a17939871b9205a4dd349fb235cc1ad4b93fa3f29eeb6dbddb76f0bebdc2c6d4947c8a65388a49c18787292e4d6c5cbe97c0c55e8d145de18b776d34946ea00d17e62f82567e7640fffb93fd0871a2cc82c5afd0b086551133bf64315e4eab883081c77fd436e65e1e159cfe4777ba63a8da0a3cc1b160d077047a4f8e1b590920d220128eecc9ed22083257e5dfb66f221336d3b387503a6834776e35b94238a9cb19a1c335e168bf1ebf12795043068948b66e862119d186f3343165588516ee9dd22ee9d6d952142690006da386de12f71d51611d00d326b73cb36ba796e1f710202d527c59d8b0c08db82c9d1002a04cc4670fb984b2ba6581ea12356fea52886821a578157f138f0e25cad5286fb748f2af3f0e8709488235ac265ee8eba527d725fcc794f856237dbb252d714685af685458b2ad6ed80ef9a70ac374a34148f27608aff77e72bd913393383288e2bb4cb80a621766a49b8ff752ddeb8c37d70956e8de57ea5108a59472c73925abf10bc45034b52f931e28a5547ba6afa85c1ad8c497082e579c065ecd954d5af7bb194d99dc0a004276e968947b141de221b1dc11998fe1e215a38009ad083ffbe099e88897beec314ee30f09410d386a8167fcb2697ad12cc24d4c566d92c9584c3845dd56df25126c8fd3280a5c7c3561e4804e5ad6d9505b60287475e35cb7aaf0afa1106914bf8fced3cc367c5839ecce73533b5778acffe1327f0c48c9993db61828bdab8155688037e11954dd994dbd1fb5a5a4a204c996cb2d6076401e96938928e526a2809f3efe77ed66c68740b88ff080c6968be4f07c097b6e6bb72ee83fb9332f56dd1f3262f5c656ee973bc1ce2f11acb6a3f844a07555d45846550779e9b6fc7714cc86d8314218c567c3336b04c37f88f53e99832ad670fc6b8b8d43ee01a576fac926c41420323e9602babad595e6c780c899a580aeb7bc44193b3ea0359169793b1b492a1f0d06d173f61307fe6ad2cbbdffce3c4e5099366716c0eee7b723c1e07ebd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
