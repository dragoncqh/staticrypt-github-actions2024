<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f38b6af46b62c110fb6cda10f8c38332a9dce130ddc37e06b5911b057b7bf8702f182a9c17cf90d18f958ae289985bc373474aee5296d5b4cff4c4b46dcf6f0d240fdfcb6c80880e6fe7bde88b829c779c2ee77b79e6227eb42e64a6308b5b8099d70afe62380c83b6fbea0efcaf12c5dff329c2c9c2b10a6fcd536be6d22ef9f625b4b1f8624e98306a9d13b8833d8b8cdf39461e60bb912ff85141dc2a30cd25568ae2ca64113e9975190969869d78bd126559e74a3df17580dae6e359b9d245bd9c92d00601a238ba9705fb4f299774edc4b5f145c652ee5dbc26c064eda92f7ef3ff994bcd4173e6e4b48f109efab6afcbcd637d56d9f971a41805dc09a185ff095862b8c5eaf22c5d8bf5039618e42202a2ba7f561060b37221677e3da6fd0cebe6b068289410f24c79e384b5736f6e5ad173eba879ffda8339ab558dde6fa25f3d3d4e4a5fad69b7ec632135ceb6dc2c17cd69f68a167ab099c888533a03261a0c59c6ac4ea7593473058a120f245f5637b2f3a0a5d0a6c6723514dc050b7afc50a8b793951ee82aee94d0cd147fb3bdf59996c685ab052534edc1f05a8300c71dba6b9664a85aabcf1e5280bdfe58e876a30edeef6c810c9fc5cbda682729c8c91bbe0f7b0a2af9e4be788288da92a8a0df1a45f0d31d0bb6b55ea18f3d4a30ffcfd4b25b55935ec2206d03c92c6b9512f269cfd0a725fc4ab22d15b9e2e72ee875f2e866b943f9207012e52521eb26fd412b3c885bbb6102c2ae8256f476c48ab55f33c75cbed1286fb4e45ed3f74e5d9881b48c1d44d19fda071d21b3a07157be2fc3a2490c090c770172281ed0e18cee1e6c88d0c3243020b21fe9ee439512fb3b68c29929a462ce6cdacd996a76c97ce9f48190d9758a63492af579e55b773d56817d9fc3387de857f797158ce0a7b8641f1efc33b02c2042608ca8b3d41e95d35a5dad2899cc40141a41532f5e3a7be2b24e8f5240cc4505f57374037fface8dbd812e1aa332ddac63db3d6d580e6eea6b1248c0486122a03aeeac38db502caf0ed26a395a799004d50fc8d0aa6e60a0be7f728a2c12aee60f23a1b4e426799135dd0ee7e1755b9d6ab36cf6311092a6d22c26e6c576473a4ff0a60839df8d9f12adc3ea2145f82777b48eb206222feba7c8b2505c86318063f4baf374ad46bfeb10a29701603cb720f37c7da4a94bf662211c915e09359a1141bad9363f3f9644f6bf20b6011e369adcefe3f22131098a9c7650221d2c83cfcef8a037c9f1e9cbf2f9bddf8cfbc77bff8eeeb43b4d037f2699b516d19bddbe003438e9a8073b204949910f5a040958a290d370a54df77d73c4eb08da8af7a4f504385c1d7c425813f0973568218fadb60f8b5785ad029aaaabe68551496ef354195684152d8adf83df55798b2f299cc94d94d072ed7d2f706fcdae3917a375fedd312db7d46a8ecffd0ac2ea83f11e218b2904d6297f42a9cf1ba5ce5751e919e357824937cfcb1fa48d975f1a311eb4ea593598ce5bcfd4fedce5e01e3cca969a269749143f1ee1928966f41f76e349bc972fca671f568181bccadbd0cff679072cb00287fd8a266167fed5f755b4c4e7ea0b0e6184db220acf9b539b48db04fe1e4ba514928ba7f0ddbf555227e05e08cff2b66a4d41a0016d7d915b6122903759a10696bd348c1721bae5a353f1d169395dadb95410f2c01c2035d17051dd8beac2eae5812013711e3d4124b3eb6010e0063a7aa8a45dfeb56b8428baa4d21d8e7617da635565669f04469949ad26635769ba15f342130d54b2bf3d209c211cbd26c011d3d27533e34605311ba82a879822e1bc424a4546e0817838bdd6b31bc17ff0bedd6fd4cde2115f0fb2c4e4b1a3a390d66db0da307fe2c33437d8c9f6882b6912e1de289a249c69bdf0e9b19655d9ff0743b7c0085825358c68d7b912f13c5eeafd9d2f4c80b059cc9be7b8311ec2b7623b9b5005a74a8aa9b274e782c728927e1738c418816705a7a3951bf30b939add8bf0a0b300e46ff5a301f8537824d5af031a396e8043c2a696293adfef65aa1cb02e6aeba1deda0af9afb47f7fd72972615e8dea8308bf36413607761eb595df3f06d062140205c7b2a530e6702f768c236bcfba728ef9bfd8ca691c9f9cbf609db39804e0c2753ac77e3b704a5515bb6206adbb9831c4f90b1a437c4e0bdaa91560bcf880b86ee7177df38109ec9d4c7ef14eca171d60d1f71404da472db6ad83a3085c743ee9ed08b8bb679d6df1fd6842a65443ef3265fdc9ce48905c0db29b36e40be9677000f87caa3116181c04e11dbf8e7086e2de9084016b9965f668075fda66b3f5a207abfa788ad44000bc11ac43df9a5f01546e022b3120e8c21ea5a0f974559c98f07ae3575c04f78e75818fa047e43533a217cc9534c0efbf82385170a5bca002e09f88b2595ce9e3297d06688ced7dc24f127ae5be9023c36ab3e4367473ed12acccb4db84226347bbe10291088a183a96bf87943249224a88252e8a34606de0946769acccd1425fed72e32fd5385b43c7cc397dc87e312e82877d9f93d38cf0abc0b4cf2c6fd58628cb8f4b005ceb6057ce3c22dfb1fd437efb24356088b9e9662444d4d61d1ca072a2a7a60258a80b5d4c97538305cfc78cb70ddbf1be71de07aeabaecaf728c4bbc7797b3b6497cac3d58e19ea6c8cee5b2c9538f5de971b19273c1014dab7607111402ae12eced76692197727027af630daf9d0f6d132f930f18dc58d6b212048db97d141939b3c73d5e56499aed7f5c7190e69cade3ae3a04c7ab94ca38f3e64b75e642ceea98021b489d15100fd54e524d271da314b4772bdb0d43d1ef9cbed36b8a58748752da092e54289ed806f577e2fe66c68826378469ae2c66f28f3ed69a9bf509a1f0a9201d7e0eca2cfc925e750d427a69baae116e5b0568ce3edc297b88a5b6826129c8864d60574441dfcade5f39f01beee2345faa253a568cffb3bee13b2b045d6b38fdd259a67bc05b15eec9a2ee2088a20bdf4253f9ac10687450b4ccc6e2d36a524ea89368569b5dacfd7946a1aaeb3b49fd0a619f56f27b9dedcf1869b1b2179196593a4f5852e9aac2c1fa10b2181d526d2e28110b6e92e812ffbea2592fafe1dc0877d2078a5c0e80aaae13966e47609add8467e7274e9433bbaad5c2e321ccd4094175546d895db6068f31541504b2e914ebf95e6751c305641f6d97c508a9e63f3c642e8c06f59e1884d17a7b0f9659e46e33d90ca3a69f4dd3abf92b2f0bb3f7489c5927aa3eec2b37eab735035104b42dc96e500cdc98150dc0a3ae44e8f62ed68642955d7ca89302634fc88a333b5a00fdf7f1d1add74254544ff32596705a627fb3a28e54c0cf353bccd1d4b6be475a4650721924ff918140b45507fe8e8c4de7a9ac0da747917060c4afdf26888891f0189a73efef7e4826692dc39213f7648322ffecbfb21aa3606c1f7b329ad62d9906bf1e39dc19d742a8a773e334375b6933255af050fcf574e4fe203080de18424602a3af5c912abc2aeaf5714f732d6dfc3d3dc27c0cc250a7dfcb747d9d5c126b0b9a9e8840824836a7af747be7cd6935002909925ae7b0c94dc1c53a7799719b7a4191476fedbc1c177aab49913e37fa61516afde89df2ff4d9c9ecb8432755f7b8fb2e93afcfd96b9b941c3dccaa954c473bd6c4937ec3a864fb38fe115471dc7e08f4c38ae3c8ebf17bf9c318bba59496dab95a280e5f82f8d278fe7f84d300fbea225663fc2b3b068bf881353ffa382572723e2fc3adcdd15082471f83f1cfe045819324a80116c6d32364770e2851896220b4c30a09316a20c31f98e8bf4faa9fb37cbf3b5447a02827384a53128bb03d9eadae7852fe645397a00ead03deda0d4d091b1e8002ebcef2b09812eca34351b31c7ea730875fa7c3d923386608e763bc75301c52c25d0fbdd55d21341aa42bc9d688ff5c7a57cb73961e1f414bf2312eb792a78b5bf899f71bfc4095aaa990cfe8e0c43c082a53b11b6dea323e392ab07d461c6c95f32eae1cf2bbb8c0d155cec4564b2448cf3ae898e7acd9a90598377b10d46f97c8beebb8803902c82c1eb3633c22064d5cd258afcc1e8a512ecd3c98ad0fcb8d21e002875764d47b1c3bf800eb55fef4ed365c3e45e711eb368a46430116844be06e4661086da0bd359781bdf91bd0f60cb8ed4cb4018faa040bc57ba8614a76221745c87187dcc3978ec11993e0ffe3761357456881ab4a8cd59343036bfed83dbb75c1a641066ec5ba81a70cb788869e1f7065b22c05ad46e2056100842a8065712b132b0ce92d8b8f9caead2e5ad06d3b3f8033bab791587a64c04c8715ffded301e215f9768eb0e9b65262282a0ddae42d21b92b540d8e69af354a9a9ab485666ebf324780de53abd47137298ecc274a44d68981bf59c66985f66c1053a7fc20ff44b86c70c087731c1f0ab8ade17418e2100fda5b575c7d74feced787004c877dc389040701b7b51f816a230e086dfe175f6298b4847b1ea2a7c2cea63a2750d7a7f7a2136d295bafffc11fbf2f4c55397e1529cb0acd4b8c2b3361712ed81ef8ea1018fb76ecf96848e9e7407d589560c54d17fca18f17c8ece63c56b72b3d5ff8c122dfe1e3acef36c98c95723fbb34ba60ee3a03dfbadabc172c43a7dc17620ceaa05094c78ee3d242e3461e7dea5187b05327f018566fba6d7531394c2ae7d2374af2c3438d46ba5e0dd71ea3beb07883511fd6f758ecce00a5f4dda9da79a05166e197e57d4701705c46d5d3711518e001f139b2bd50eaaf270f7fa043e5e323789d4e068846ef0e3cdcd69fc4e74f58a8f680e5a8dec95a13fbd31daef216002cf8591b816748f4581675151fd762fc3636214bbaaacc56cdf69c9cde4d836faa645d009f72c28a428890732b2614dacddf9a4c62802e7372b8409f4d700ad4bbab2b1813c550d4040f94fb7c132edae46beb23f3c23b8e7c064f1bfc190848e810340cdc5e8e2a1537e3fe653310be98e0d9534982adcd4ef5a563c33dfdc4d40d3f991c2259029e508de37a0bb5057b1e728c4844c0f30fe06a8108e34aad9c478da55a29db97547b2f4fd2903d8013928a85b753934460e23af145941fc55dc449c585928b71ac25d4b74202af7bcca181abd2e371118b72a58f94da2ffcbcef8b35bd6a32f578a95958e870307da2d8460b04cdb00f092aa13abb7db50857df1908e89d62df5efa0ab7589fd2122eca9b3c6259327ef716822090177375f7e9fa166b462f536ca66932e26c6c2d3f534145f6481b50aad4a5696c8d0bcc6d9eb012b9ead543a483823b853ce0095d24ba31f613c75b85100111cdae0420cd2add20f6fdbd8cc2febe6405fbfdff20740444ab5ce356afc1397fcf4a06294db5ee3156087778f285ccf4c3035edbcb3575db02ca8da107a9fdfdc7ee9eadeb51f62909bab088ef7c9eeb874a15de0a25670da1f9fa1e24f232eca8858bd20355413d15d042a6a61f406cd608ffb8458b396c0539a6948f79e5d75a08c1cf663456e5c56d997f053de8dda1e1390d943ccc85fb11e4721e15c9cf49e608ac815c9a296440571e3d1675b79f84f894f12d0edac64168f6ac3f27da3813373b18e743604004b68a0ba669a56f2deffc601370aa0e10e2209447586f5a7c83f6f714e44d39c630c6e658d4d3693642f18cd607031d1a0de5a24a0ad6ebbf7a57a4d4a0d810829050f45f226e97e22a4d4e1565843f533f6d39776d609ecc8b26f29431df0030bf56ca9fc4e997f97423ebdb65b194e55e619f0bdb0fdb142ee744bc118d9d3db53ebbf1189306f6d5c313a3eb5693137153f7f5b27545d3c1b468ee11d9737e1f1bf597cbc0cc6cdd5dd2ed13ba4dd0f3991f0e442b07b297d2d3f7ba4e5e170e79fc4d6dce20b34b0af1d06dd82d94d2493aa195c83377be9ef4fb20589b305b476b12d796890212d221e2e3c1362ead8a1512439ae0fa7e64562233a4119f43689387c93c46d4d76b529e46fb924a140044ab7bb68438cb773c94e46d253290f85f6a9b3269fe34104c557bf044d2a5daf3f6d7bf78b6a98d4d091da30e285c269a7200de1b5b367cd2fae2068ef1076be8bceb6e55910b6d4dd81bb0b1c666132d85e93d74cc9d6952ade24185c6c57848d10c18a53951c2fab231deb1974ed6b2d8184367c88a10241cfe1f9d8310fc7c3ac6afd544239ff0f33ea65d87330fc15ca640f19682667f4856a0e5b88f4a31dd487a77fc1191d18273d579f1f80515ce952ab620e84b540b50e5a91d2c4633c6666ae73bd5f33e2a0955985408dd5e4f724e421ca35a1d80a159697245aefa82aa3de266f5e98860744f4e8ba12c37162134cb93c23092d7445877409db6038d1701e0207bb33b897ed8953634b407fd8d6129fa4d279c7f115aaac753d0d8ccda08072354cbaf7e973c3ac8934d7d5bf347b1e511f47221d246396f28eec80d788308176b66bd1469f7a6c46e3f59e767018a5769a110926b7d15e4f16ef5631b4959070fa9e2037481ca09a23f1625cea01783058d6b0a07b9cc0e9c85ba46cdc88716d0348ee916e9936775668ea5236063ce02e54f926182b924839b4377e96468ee6dbcd1dffdaa8fd17ab35c594d6d155e7f53169991ed51bad7a56eb8bbbcd603df3772493e61bd9979f76709569a6b8c43c2e7e810f722cfe8550e0b84b2fa80f23ce7cf7ad706022e7feb2238ff7419eae804a6cc319e23508a476a5f72b549013a04a3d6226a397867bf72964ecc6b4581113f7f893fd2b8cc169bc1c08ba2739187c6681d6d73223f5bec55c43ea7699b7289aee5cce4f20a8fb9c46523110e6c975eceeb606655d18330d6e04967032329b16009db708341de9eb3e0163d9c0daba6fcf19ba87db979341df991090036c4685fb07623693283a232b256b50e62075329e58fd2ebc8429e26f0d8124271257316798e1a1308470deccf2defb21bd045ff60fe3c9c21487a7fe974d543ea8e9d8d66d63fda891b87536fb479551885caacdbcfa82fadd3f07adb25e1bf108a67bddcf28fabb1ed8aec39be382aab81cfbb6463ff5a3d1482c3451bf4f1a1171bb2902a8fe77780ca3c82ee63b2de0b62a8bc4ddb1c92642483dde40152b428e77d5cfc1721095ebd7ac3d13f234382df5bc178c802a9cce087878fe0c12f693dbbcc33a26c9923163e536b4900312d99629c92649141cb5c34e55d7ac7346bd2b1be90905bb1baff0b39296c4062d1231254b112426f8ce603353659b817209d2991babea561fa5d6007d48adfd76a573ae0c9a59f3502521d96034b59a1e513783afaa7558d18b785ae430d842ca9ea9ae1d8d9244423c6252202aae38be0aa261d8491f1f94ba55e35df772d7326316198dcf7d2b45fa4ad69389f1d5fd3e8716359d0589bcdad500f269ceec7f59f8795bc1717f3a37a8b8c9db66b624cf1b9ba985e9fe43b4822c48a9a4bd3ee8d43346e50c8e92a71f3a375f1ac82daaa1539d96363a85df42b733343ee9511d7be11680adb9151464426288a026049995705bd740212ac5e4cfac275951fdbf0f79deb32dfb72aac24049438554305d03a92242f0f7b5bb3ed225cb59a3cd342bdf6f25870272db9ae48c861b61993bebb9517f3d3a69f34231d58a769467f2d9e2cb23c3afffc83340e26175763c283abb29024239b778f4f5585bb4548b68d61914febc4f7ad26de6cedeb26b87b5ba7248235de7e6d6757a3aa7dfa9fbaf201def82f971f6f72f67d5f9fa144703fab666b1782b318e8ce3d0a71ec2b540a1d96b2bd5f4b379a3c523c67d86580663ea9b9844cc46a670fa01636d53b2bf495b23071c1f9b292ec3ea40d96de81c4a351b26d56a0bc8e380e8924a9977db75f47822c715b8a6f671f8adeb6831db836bb49aa92d0d2a963ad3b1294ea58c0bd153164904a7817c44a372128566658d62d552b3635331532443c2d2f381b20ce0a2c4b11ea64f625d08a98dc92cae745d60034e1704c4002bab846a71429158638bab4537772d8090e54413a00202eb45879ee0dec78e61d4035e5a27718d2264efb5f2086ba1b9eff8a767f92f8aa4102d220ee5b230c1d0879b46e8e773e8d7751b5ca3d734497cccc6e920f99a528cf0a5173ac475e658d0b80b7e201ff060db2b376cfe482b83d039450dc87607c747487b6db50f1ac26785e28c0430029bd6a3868f35e01e280505720484f0c0ffc41961050693e3fd213c1e8263928f2d4c9d1129fed1a738df16c015bfd471367a68f68bba29091bd9982f9b67ed36be83e7c67f4e30fc2228debdc062db2c4e9d24d19eb8925e269da10c2001b70f8d062ab9b668f16f7a49cc5e0516aff9eab75d981d1a261814960afe6e5896fb47e507a5fb9877fc36e516c65cba828b9ef64b66945d62e73ef38f499b9748a9ba5ff7838c09bf631f60f4e68eaa15139053b3d97f594e7263238da518732b04a81ca6c9aadacfae7bce8e4045b54090056d33c3d6ce9cf09ef1f27cca24b89d619314e0c106a31e75a9c67c32a02c412141328416712b9d8d3dbf08b5524d73c2698bb572dc70e087f855087c84ba1460457dc032ee59e3a536e99fb16a96678d4d3a414f4b7f34061815610b900fa19b16aa40fe4a4b65247089deb9e39c0435e1dec2f1978bc321654df3c190205568388b60179ae0e246c519e4d7b59e9e5fd57a854b9dfea6d9d587feaef7b983db26508f7c3216bc532220b7e0c5e0db73a1a6082a71f650a77d36eb292a80869349eef8266be1bc6b816305de339c35b76fb2ef623c8517c6498510c07d356a2f7e216c8bc293ca77e343f340bd688848f0532feb52182b782345c455bd878ea1494abbc65e68127a0e51334e3083bf7f41d7144e4150dcbdfcfa554419ea7c26a02d560bb56c5a65e98ba0fbd7d32208be2443f2c1f698c62139feb17283d23fce65d2a8e94df3429e0da81f010abd398fa6657cfd844762291428b2355c48c3f1287d48717f3154656df4a9f2cc14384ec31880a55a7558c320860cc82e276d85b6c34b4fad93026280982ccf442f2ab6e3941dc0cdf0b7c0b351e5e2822fe41841f086f0d576c5eaa845733cae05e5b5f3aabbccbec443ddd2724a95a2cf656d4ecad119586f8f2260428c0655ddeba3a41536d99557d5e63c6e22bd8f26ef0f3d2d8dd3022030fbc3c2e6ac5ade3ba0369870f0ff8e6dbe4ace6d10a902f070f235da3c1c9321e33b3676987c610cc4a47e6f68db9482d986cd04bccfb8692eb4fe3af832f116c10872546fc9aa3b28f3d6009d2bd24a44903bed493199363ab9131793c4f11a9a6644fda8c4239fa810dc8b36709972bdfe50923ae8de5504c790314d489cfd782bf8f8f971e2533de483b2558a1c04e09fafacc3de86e3f7fe8daac9278b210fc625e39b228b9cc32a9d26298a5ed0e564208caf2364038f3950836f3d06496adca343e151ff2cee8edc94467205222a1b97cfa6abbaac93fd8c9ff5abc30985a18fe533acfda37ad3bc3949e9a1d1e68568c6bda7f4fa99035c3303e088f38079bdd28cb2e78831a62ba3fda8eae8cd358af0e12f1ae5b7d7297feefb4da135d45e24fcbfe9346bd7249931edaaac9fd43ed4d365a7b69b11766b889aa048ff8d92ab45b69d239ebfccbfd1cb383e1d837f5778517a2c0b7a32295c750d8a81938ee76b3a18690ff9c0f49a47dbc2cd0ff6672b2ea0547b50f01305094e2fbff64b96246a64bae713ee7add3f522dcf113a139a2affab0c331009c165404afdc0a718e771286983964c7bbc24275345e25b0ddf6efba7ba87df3a14670f6dd481491dc3623dd30cd061f35aff5468c2666002cca59ae72eb5392180180b1bf728f0a807374ccd81bd7d389ed60fbcb2b1896cf8242581516d8b0c9ce4a726d07ce1cf79e07a2b6b5299419d09e11223c8a6ec134f81a82c820427ccecd8a8e1b39c2792469b62f7a78100c749c0fc3c46c72ea7200beb87db02a684a003f41613325ee91a60380780d1e5140d3357dfccc1e667c2f763e30410b24e0f5ac270dc3c2fd69c10d23802445e7d5e59dfe611ba6a168c4b1d029c6f34c4b9c1b54908a52082d4e98afc32a0ff21fbae28d815c531b86dc42393930ce6596521f54a002ea7df134c86d27bd39e878971273331ad4aac130353c58e2fe7c17cb194c59ca1288fa269582218765482d4a8cd83194c919cf30a4a659f54b17a92050d340b31350fefebcd727219b2632eccf5769de409e9d54554c93c242d4da57dc56d7e89e05a446d967405d545cb4f3bad1b23efb91254500510f528f18c01ca43e39618bb53d7b0bb704f05818c89c8d6cea0693d9a8bffba20e82b9e8908a53a0d32eb3e6cd0293d705c886c0741831ef525e91084d72bce85b7d0c684aa05dc6437235b6118b4e6d150c119dd0e87e5f2cd1c715e697dccf9becfb38881ed1da40b4bcf3a5eab9ef5d6e85bf3117a9d6953b1c539042371e4087bce05888e2259c6e1c48c673e57aad4f55b94494f909472856bb4a5fda77123a8fbfde45058e6febb794d8ce219624db48838d838fff75e50098affa10434f2bd5ba5003e4f99941c1dabfb1e4a080159194589a65852370df08c5accd0dfb767719707138df407bb82390989c56fd3bb7b7e3c92d4065095ec019515a8777cfdffe14278f0602f1d2e4dd041ef317c8fb1fd2d3b816c366234bc9b684e6dfabd40345bc7c97f71dda47616bedeb5c09aa615206d6672f3970b1d605a9995593af506e84c421792b985b86de20923d7f09930154103dce7a31777ab5faaa579588df468b0d86bea2ce38f58819399d477d3f75d38ae717d6a60780c1d8793852fc36f91e38e4759448d0824ce1504f5a014b7b585ef3e058efafd225fc30f3b0a75be6c6f5b02ecf3f4f1ef508e620eb696b0f7bb231c8d2e73acf6f0174c8735b95c331f35429af3de259499e0e59da6b153f02e9c6eecd1af10eef71d35e0ca33e82968c3d417886c92cc3a6c866013fad41bb6371b8b7eea1b7ae04623911853479ee3af3fc6523db673a48f853b811076565ed20dcbb009197a0be18e075f300a3724e3dacd6fb97cc25452e9b49dd3d6f0bd2b1cb3e7e7983e58cabfe981ebfdadbc1f5b288e5766b34ab5ccbdc0258b6f416bcee0a6e53bbce6000ac51228f7ae1999fd751bf5d0fd234e1a2fe22964d1b20637cd41365ceac79f03c895746f7e812051f3f5640e6b0995a8c7cb8e9e7c29d6951793151d962456db89eb09e4b4ff7f8320d7f35827a4c59cc3603b72420360806042efcdc27c1655efa03d7f6b508b1c1dd5f8698357b15f45e61138ca9235e8ed3f6943175d1783146223305505d95c8521d6c6337e0518213188ccf3b2d5ec4cc77fc9fb1f70c2b928f9c62d326b7b4abd0a60505d8f7849a1f2cd0a8985e41c06fbe45eb36e6b855562e7ad63f8d8900901cd756fa769988f26a3d814931964a33c234dc1c5a39c9fd81016abaf15dec7c47c09aad3b94c794a209387e40bc74f0f822e7beea6ea1e1108741064c28920ff084356decc46f9042eb0ac5620d53d1899a7687aeb712eb21559700563181cf726c80cfa09bb46799e3dbe02d491a4a76270cdfc9df8a21ed7c3645a29c32b365076b74a0d852c26e40fc784af24145ea6dab5e3de5acbefa84bdec6bda1ab31807f3f98998f7735fd10c12f1b42d0a4f5c314ab5e4b11a3bf46e4c2d214f3d12b50b3917edcdb683dad1204edb16c34e76c9c6a0698c4818e363c9c508b48703d34d1802abf627ca43e968198c56eccf7757bfb0158dbb107a5a2d4a325e54df5dd6e1e7a6bf4fd9b96b6dee5f047cfa51ecdb9c509b5a20efc807a2bbdcfbed4f8372a15684859a6236b6ca5788b7e3e9a922be956f456cdc407716a2d3726bb2dc8af812fa37de413de3c5081c8c0d387c5083ac02dba70e85c33a62ad3c35219aa52ded37c4da7877c570d521041665de568c102ceb380eceae640cce407459501f86cb93f83f849d11066f527197ed2215cd19e246de853e9d1f5d6386626377b550f598bbc80f79f675b7312c8458e0a85e0eaaf1e6dce2d4c62265b5b0e705c48901468607fb015b4ef77f52ea98f631d9fe154888801edeb7ac7751346572a2489d2593995c702814a19fccc1839d16b8f7c6809c1046e269ff9786416b45a2365634e8137746570ec803bba0dd3c250deb4d73d7deaf10dea28c6f1f3d69da4b77cb13f607807db009e4657a209af5f6fc44ee0dc111c832753f4204853d047d38867bb404984e65449523fbca793a9be2119cf3435c3fb31df1b3904647e3101512b6f9a320b72d31a717dfaebe52c8889a48fb67f5642fa9ce8db107a3676bd6b7b4cddffe6977432022e091b4b97db39b99adb1b867d9105a956f55ca192033a6779b443ab8104de50e0180e0bbefe6350b21f643823c48307856574ae7fc264e7e9682421c351be1845a4392c6a61d80afbf0c27e31582f4579c0cee90389b6f77664a42627311634198dd38e714ef0c24bf764f267125f72e0cf11d020d5f84737f8edb9b38ecee9c309ba10afe4ff4ba2e84c0e7a33de2d6d6e5ac2163cb138a0f4f63745164e031a802ebcd2ec54a4d7ddcf6c1de38ef67f8d528e2d7cd0df41430299d3e994f0cb2e30d72af49815f90d153e211460da671932adb0a466f94e8a4e96e83178cdf4b9cd0a3dea5ddbd57a50c0b3063a53337557e1b9c8076b9ff983f1f48a53bb73eb194c535724d4c3384f502dd952733879be1f192d38ff32ccb67549e7880f0835820585642a4fc63491bc0015093f1d1dab8e204524b0e157d7d0be65f7f7b369f412eb2a9ee560052534af6f19f20a4f8d0d94232abcc40c3500daa2c8e8a8b8fe82dac34a420f25df9a0241493f917509f987954e679e5dc8b8eb50882077da56e2d52bed54fbc29c98713573bd989208633eb58d3dc8d015731f86deb8db83ca44aec489abd822cf91f171dae316a1cc30967c2c01073cb1cd1feafc6ce21c29772771772aeccccb9af71e73bae27b1c8056e8f2efa8fa705111c6d746e79d6f68248ce6e79e985adbcc0b55c948dde6a26afbac2aad02cb80d924dc8291a4991f8ab1f564fd10fdafc5f07d1c51a10491fac45a162264993678380118d74d24b441ad9f9a775b1a7bafdfe1eabdd008403072ee7c6157dd97bb28a23e1991c26c2f9bb7905b2f4227892778731193ca00b08b7fe68374c79fc6c4735f286d1cd354373556c8155dd587e84f36e9a203aba49aac5381141086255af86e432091994f2456392f4df284d969345811d20e84fe886922f703ddc87ac5cf01110d99b47229fbc640406425663dd1d0054b9dee6050288d6fe96bf3c75340f6b3feed9654da65ec54d10f5e5a2852e434d05008b26e7954d6c7561f0b8f9d05edea78f184f26f2379f76f7b533822463b1149bd2aabe7c720159b4bb524c86c39a432e2e8f1abfbac6fd98f5b125d43fae34a365367563c37da2b378c05b2e7ee351ce91c25e727d3ab54cd3e3c9c3c34b000d2941e7087d1c700e0a4f08e53eb8f6e23584b40c296163b58e070c0a961187e53ba695cec05a2c52a1a7742f635bb33fe26269d67270bc61ddad7a2ac8edd68a9b6875575d6252eadc87c4d04369616e4f3528f119e6ffa7c83c03fa8dfa77e8f8f1f6ca23310b74a1af85aeef2c170a6114deb1484a4e167631e958d739df0d2f83498b52841bbb064f924639122aea75ecde4efe54704220c76a217f34ff7fb860a2d7d201b915aac7c972078b3f9039af3195d8207818b52d8f4fde032e34a3c75f7828ff8c91098f904a99421ff76b873b0298a92f7070b79767203a3c9e6de7ab356ac530a39c9e6a9a8f838bb397cd3375a041b1da41d361df242ae7094bf9a08417b39d063c3001d604a4260ec22b881213674a77b0a64449bc339ed682b697b29e7ed87181f260ccb13570b0402f7f46d64ad8263b7df82f076271303eb35f7c70c0f12d2077986ecadb19d1cdc52b3869d74181c206cc903d3d09950d613728d419101583358d326fd870b19ac903989bad236273c1a3ffd3e1aa29c1edf4b917f04e0ed5c374c7c7103d9147aedb98bbb981b6f1f8eebd3d7b3d40f0d15052008cd0e672981fb458fbcc57d1c26d3eebfe5626d745b763850d99e0ddc3bd6ebd61451376d666aa9aa8362d8aeec42251d9d75dd5a2d5b344529b34917d9ce4e9f26df0f0252ed270c385b3e790a15ce430d4867bbb7cfda24f997aa98174fd58e7978806b0ad694bb62e95ed06f972004017f1d0b4f3a9b7e0752732674a21ce9ccb4104368ffab45f86ef0734b654a40999d0e2fb3d08c506ddf9da1e1c736df496645c52e1fd952f2d6753b855634ab1ddeeda77702e4fd13d3a6aecdbe0a05fb2fb32a7d8512c7f8152f17ff798ed0c7e9b594bbb337747d98ba47cb2bcd7ad3ec3d37ea8b1197744fad6d46cd258ed4dd1f72525e4406cb607a687b16f3427d44b8d5aecfcf27a83d831155867bba5f854bf305d2bbe0c60ad4e0e717b1d430b849c8a45fa9e470e226ab1ed6d17ae8373eee508aa7d977d1168cd0a34c005112caf7252a05bc0eb72600ca17e93a2ee7ebb0041d31395ff2453b9a960e3880b880581b6017de9ad56128fdcff1935c8f93af79358c50cd45f2677c959b37594597940c06387d51f9d76f00a4746be1400be2888d8ba5113042d15804fe64147545e4692ebe5a0da6f5176f52e6cd1082e7c249cfcf2ca4e1caa14760564cfa9b4d34b060930f91ab207318d05b316910fdd09782c3403fb55b9aa4faa67739208b4d433b0574b62786182bdcd6df32d389482d4ddb3e8e68423f74157cebab27fa5298b1fc03fffcdd45650ae33c632ad61be2d2b83a57c31461521ca3cb6358009876b7c36337444892f4dbd077a57be2deb6e80137673164c1be0f881e2a4448a7cfbeea191cfb5db956bc8b996d76731c015146a8d8652201dac40903109e31f5fbbb111d3a842141d0ecb40421e494171c3e5ea89cbbb956357f6ee419459485d73b9328b6b016ba44f814aacc100984df239a60e2fa7cf58b012870bc461c75ff6c3a7b671adef7462aaa976b35e0b2d06a11228511d7b0267d156c8a106ce5a93d170470b0b81f67319355119330af8140a9647279efb14b9bc736b6f745e11d7de84f576b8384fed2779af6716f57595bf3499eca695501019e7cf7f3b2b0550fb0c38e94c9b4dbbc41c781449b4b676db2b34e207c2909ef229a3aff310aef35bdce485b21dc2fa13c726f39c0b83d16332a810b092f5c92ac2573978831aa1bba5f615c0e9861ebd9b6f6c2b573adac262aa44ea8201f12f762682cba20ba9c9e7ebb4a7e0ae26264985bec73607efe0f5fbfe2f5d21f9e7b68d54395c86d95bb436f0537552c84449a4bca93aa3832e19b71a65397057ad14c6a35f98995010d02b249434ad70b1db39192714dda4e198f57ff23d5df2da5b7f7a1eb006c74680ae451f93aa36f803821b79bec0ab39ce78ab3ecdc7181bcad740d00098385e1c4bcf775941262c7e712e658c1f56db7d825d6706312e078d1e30c1532affc1b0c3aa6a89e3d7204fce629b9eb7488d8cd709a2f0d28d8e330fa3ec625b787b6c9e98f7e07a8a3b4065e27e61f5890eff52c90850475541a06b3fd618cebd54e2b6d26571031cdbb939ef185aa361a6ca4cdf5a13d684a7990f3366c6cfd9b2eef401b847b89689432633ff0ad1db0f86d0cb4320c04b714c94ded8fdaecc50be94f1c3f98ba15c9d3ff742759b0d35f8ebc9cfe6e09b4959def7b4fc4cecd382e936b6f6725fdfaad435188dfbca7ede76dd2e6e546e8609168349ebe562ee89eb8e379c27e9d380ca6a13227069ecc57d40f91e7498e741277e869c81407e9574012734eae9f7793dbc5f943920c50fc15b5f11300385924cd123f6f55d326f77eba0425f809a62946f0bb037049ebd6ae3fcae7c195c260d3be354135c38e729914d546d3e7c49418a7277e29f93d9f0ed9c26049fe2b1be9eebe2e592c544f96de23c43d9344ecab0ddc825dd2010073eb763f889fa631639fc3c2b266371b93df384f88b41692ba46ab4f2581058daa65897fa349c2b62d136bceb69a80b15bf800cb58285240aad56a06c240e96c3ae73f0caa6a9020e37906a7deaacdc79b0166b4f17e95a4cc4ba83b06befd5d9c8ca46daebefc128479240e82a1bbdea91055bdc7e4c236be7eb1284c2edba74b96187eb18742ede1d3a00d8cd680bac9e35b1de685f38a6c0e698804ae4c829acf919e3add2b4fa6cea89b64b9174484d3b026685700252398eaef19ff73bf2d3e3fa8ae5681e151b3f8f298cd086daf079fb0d367563f182b2807f204b691f79f574d2c43f03b23391d2105e0c01165dc8247928a2830a4dc604cba520c7c9a37f2f0ff4489311a592417bc016cf44506680236c66797cfab3acf3faf69f72f4a7d2658df85dd6a5b85f5a515afc76ee1bac1c007da8b623440b5cfdf29d1035b2ef1f5e251e3b3fee61229070584be69ff6db2d9fa8aeb8bbc6b0c3002981ee87db55f87f0d326a0e6a99d316b9a3f4196a20bf0644e77e5572a2313abbd5ff127297f0882fd733db8d9d7871114e421f72c992bbda756b3cf5792a9ab896686e0b0dd1b9fc6ce8b8965da6106ad93e2a8cda6239a121be5409140309b8ba5126c31ebabe2118fc828f791b29d0a5b52311352717e2ee9efb47f6349a2fc7043fe634311c7ba2c5d163a3ab4838544c63ff3e816c499f166dd987c5f3e7ee100f89f843053468620e9967bb7f5646a97d43baa8cef550fb38f2f16d5f6c3a3dbf850520e60ce7c6025acbfb62e0a4d773c0ee58dd2e04e483827f69c9fa6e9626ffa8c46b7349b48d83ebed62b5ee5d247284565139cb1f61a1654a713152044ed4aa556a5d8089d7c0658548ee281cc57e6e12df786b95b5f0859704ebd51d91c90834699fb0095963f51a4794a9b470f919d9c3bb9d3c8bd2911eff685118766ebdbbb2dbef6e0699d8165ab6ef6ea5b9711f8e53219232e33c9e7e20bcaa8573267eb6061925e08a84abaf645c379b6193908eae6131f654868b8170203c283570ef9eadfcd2b9dfff0c904a4a0b866aadefa6b6d36a9449260db9ea599478bdc27971dba2cb49cb64baf9f01e30b1fcfb9fd20bd5ec6d7a02567549437855780112a0a6e0297766bc02e1cffb6b08b748e79540a07adc1ea8e3ae36ec296d75af76c57636e0e4d0a94a893c6d586377d506d734c4798b6922370c9390d999de2ac14f45f6f5e9cfdda501a890ba4c9438777877c78f71383cfdca620794ba21a9f68dac14cf01ebbff1054d73422b500ed74a97bba4783b6c92951d07a6ad65893d32c62c5c3fc21b4cc839c11a50d1b3d4b249cdcaa12344520f883ae9cf9695798ea99d86706e8a0b13c3ba761696cc638be579bf20b56d926786dfa280b7e40f5ae142ef07dae00ac08ce59e43ee68204c0fe5cda42517b3c90d1667ce2a43b1c48c34fb776ac425e895387f3019276fa23039b660295d69b9239e463332d306b2f710231ff664fab7b58a806da00cecf63fadf58655b0cfde62e7a58187a756d0482c463efe93ca8bc981bbbc0c36b85cb00de58d16db23b7d7845aee188521f2d33c18c1b269fb7874fbe55d87332ba2ed54fcd674fbaad2089cdde883f0cb3eff3628a9237da09c615e6895c14b336a8965993ed5278d14766338a097f5e7df497542453f81ac58c98732cd326f6d14e2b0c890a5692b35c1efe9a8072076c5fa40189e4612ac441555ad4b36fcaa671b0c9eeb51d8ccdb640258a1e77922243bdd8558589abe236f37fa0688f119422c0fddb074646034c99b2d7c7a6faac6f4fbf84036679febb6892689dcf351f08863d47b9dcaa05d173c5f83d2fbec8e9db28b639f514678844ff69da026044c642bb87a63b8aecdb6a66d47392acc0d8e9187512a0c4ba5ebbc1404152edc3d78dc959e445a51dc703f3ca199b4a54e503bb03a73944328517eabd33cb0e0e23f9d89e8100dacb0d01c6f9b77bd51c82dc49e346b852fb5388bcd0eb64a9639c8c25bc75582896ced4c6701f9a46e65b5a79f73a388ba059e7cc95e7af54e1f4eb9372da2a30e7fb8dbdfabdc74162fcfcaa4598035f0b32a0007f5be3c9c117cd04e8d70fe943a104812409fbe5874f0798ee6e4c04509d7bb9dc4423ba38ab5c016b9f57a98f1a52952f1e84adcd99606da7302020a78012936548f934578a298e7085e987c34f211b2c59e1605ce95677846ecea5b0d0c626556d539dd493498ad5fea22f2370cc5918343988388ba291e1d164b87d52de268add1b69d26cff27e9ed4958452f676e4b5eb8931fd58be973ca8979718b2a99fb2ff142b87111a17c9bccd65ee95d43ee981fbe374d68407ad86609a618d84a20bc13606051e9d51078472c3fe06584d017fc84140d01e5556250d2689458117e966da39d00973ab2445d8be6ebd9a3dd60c8105e51c787a681b78d71f5a923ff7c0fc0a5f5510f2b071391577ec3fff82ebeda14fc2fa8313b9044aad6fb3ee4482cce515f4533c3a4d7e5f40bbe97486bbe77ae71f09b3052d3672fb6e5b29bcb24eb861bc44071b9ed75c4ad33ec1a4e753c6f091e6d3f0d8fea2a1ccba02c0f654e16fa50ef4163901369d4993e116f58c8f3648ac041f0d6b1a64f2760a2425fa1688a240e974725a2768f539254e43af2f3990bdf7dd356528a1298daa613633195ba52a9f959d3f4670d63a4448b3ac7575bea0954ad90c233444413d3c384477c0bc1dbc519486d18ec9de90fc5957ca1f7488a0bae731f102eadf14902b4930948d68fb91b0b85f874b7b568d8119f6452eeebc183d15c9f8b4387ae1c7a1ec6db0605fc6560d7782ad60816d1798d942f90fc093185e6a18514e67af633b6f3a23c145ce4a9beaeb6c910a79cb8c5c2a6c33f1699d86f4c7778109e4194374922c584e5d1a7c40b6f153fc606221c9c0a818c8e47e24cb1d6687ce99f33473a98b47085dc5e00414d029655be3d17d9ac9018dd7caec57470e70f012257dc6e00230ead981f1176dde0347a93e42a26b60e4504dfd11e1b1053d44fbfa69585af8b540b5bfc9383dc1099c1db1edefe2e9536b86999977cf4231762ed186dd2949fc2f33c1426e3fc2f44062ca95ba437cef4019a3d73f7aee4a32eb3b725cb716ba7d680db5cd1d5ff89f5eace0dff437716d294ad10a762a8be1f5efcd8f0ca5162d39de841fccc8d6e086d705ee29dfb672f8b2e8e8425ec8482bdefb762220fb8e225916f10bc13ebfc9d7684ae6e1559cb9f79ed1eefe869fc0ae5871f4891d619d5ba1a28675f0c2d50c10b2a6962e9ef1e74b8d7b5a73854d4d0a642ed18bb77dfd255dcab05de7619cebdc10ae47d5b800f3b49063c1357db599ddac53b91672a5f328e8cfc5c1aaede380e8a5205932d49d118a9e4a4c10fc53ebf0d388a9d81ef8cd679ca46d8911ceccbb0afa964b838e35efe18a2c26c7170133d9dacc5f3d1937fb195","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
