<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a40f628086e7c465c7f9ac1be1643e77590f5d1c1b919c4627273551cd187de23d305ad14d375f124a35924815ad5b9398aa0167b5483386608cb875fb6e3c4e1cea699d1827809e968bdf80ae0252e285a93e60fe71e6f7d474a95ff6a6adeeb38b68ccc345bd1d3139b66c76555405c25a82891e3bccc2d8f40a4481879a120b66bb0ca0c21ef5ade247d8166bb1866c368640f107119fc3aeb1cd187c604e57ced72fbfd87be71a72d085bdd3731374c869601a8891aac749ca7125faa5c7750507da87e81d9ee84319b3261c01fb3696af81997462ceddddf59e0b0481c7877acbdddc371b78b5ce60d8181616157afd18809c8fbc28543411b3113dfbb14ab6b9ccf2591fbc097bd580dfdc34b03ae1ef10ba4951486d885d3dbd02071428ee1eb446349eada481041f4c24953a4d7b923e1c6e96a577962069876a31a68487ebecdd89079194b5d700fb5f0c1cd8ccf81e06ccd427eb72e3af5a4f49d9d6746466c4f47e8c1a148669cb03ead9ee513a1d7aae69a30d1942840ffc586994648a55d2653502bd8f651f9ded1338f783295ea77928b4e788ba41472b3725024c9d16c3f7c9fadeaf02e6453c59de2037c259da94ca26d14f88a5892f19761110241e2eb53499cebebd73dd9958fa3f66bda985c968c6730decd1caf93d9144646790505060104e78ff11407315914c3418ce6763c17734087bbbd5dd2f32bcba8a072ea2259c509451791a125d5f4445826d73eeca691129a0e339da3c24041acad346c3d773b3079af5e019ab1d95c1c47c8dcac7557f8da6c7de2f20a0ac2076102bc43a1736725179656ba9b9bcb5fa0056410c4b341cba9cf4a338437dd06b644b45fd525fa81045e364bcac81c9dbf8195d929c987027f131a5297359937db9cbdaef199f3c2c7fbe6d31ab583f041782d15e8b8cd33259bf2324a824b19910fb5afd5a2f8a669c6cacd58be184d60f14044d2ca853a52c0397febf1e77d8724304574e58ebd0e58abee76e3b91d170a8ad3e7d2df4a53fdc81aeb213a9aba0608eb29518463d641128ed921e5cd2549125086ccbac61654869eed3729d06f53342df74b389f0479c5466fba18994a1ff44d6fb8995359806cea4ef63dbab48423d54acdbd682fe7dcc6dc73af39dd1475b6dde34764c10bd4cf0a7bca9f2a7cfde015b05337fd4a3b0389d3e847903a87ae35716da484940194da94b8b7cc8fb9faabdaac71afdb65c5dcb22104f94df3464829f19e3ade27ba5cc1e3b2a902f420c0438b9f05364f1d320da247d351944ff12a1113caac0a7e49b5157605372d2d004d1ef49f2022f93019298dc17abe53a8f87e2f05364d2c2c83a7878056620047de7352f01569ceb9353fae05d94d0b83447dd236b87476873d7930e049f5420e0b50bf843d371f4b19fed1a03ea332413025d8fcc4a2b05efb78910f657b73015ca2305b8aef5ab5e9d158600d53d26db49d5fbf6fbe45cbcac3584c931179fedeaac164747ef57e4237ce73649101bc70b7ca3b6246bd76d4f6cfc2b92bce1ef82653fa35a6b9742e21d0b074ac1849b1e6fe87e39273bc9895758592c681b663c4a77a50f6fb64927da7f2213126b5d8e84ce3b556d211051182445c8975810b706fefc64a7dee3fd02fd1b80f450d4e001f3d4797b6eaf9e211e736932c1c442e6df9a2225f3a0f5311417893f7dac0aa95d3cd96a1ea60bfcc0754ae80f20a807479d2fd1364285cb1d88f81c7b078e61736457e36a0abe46cbe3bfdac53bd09f0e7b1a63e0382b2058273b0fe6cc5425f98b16be34c09a87ad521f203328cf518a4ee7e204ed3c9d7deda5eb4820dd8836fded0a9742d7038c6cf7ba5b1f613b8820076f2263667bcf63839785b7e59c1865c889be338dbc9ec7674ee3eb017d9efed0c36ecda2a7070080deba883372ecbbbfe8a0862f86036787041377b2133f48ac65c43905e7f1879d4b4517e16b581383de1152d9c579f956740a9daf3441af1810933e5199a5743b273ace6e96cbdefe7ce53dc251f3be796f7b4993f192f09e0aa96843d26c1abc4b265f2de15ceb713d738d84b855f4bae91a13a8b9a3442819722050dabcb1ff590ac1231a9948d2fb375b82c6c0eb87b43c7c8cb0292cad615bd74735940bdd5765ca2650abcc669de7e34b325b2bf67e6a6f6b5193971e5f2dbb33fec98b4a7adeb7e7216b1e9404e8d0cb4ef81e78a9bfb4a5a7d9374cd219a28ba4a31c23a52b96614f4c988ed7d4dbf7d43eb3aaf8dffa04eeb8995b598d07b04c7d56407d78aab63f277178988a14ebcec358a9d385a1c25dac33153ff549472db9c1aebe92597fa81fc76e15a330a48abf66cec59944d573ca02bfe9e9e87ea46f730282c03cf796b3c708d54b84e176f9b10f5e7d47114b0f6f55c3d0b3cd14d4f52e25756515fb44e6cdec59e3076a839bd0dfb87007306bf325fe0b5dded7b96e9a8e6e1a9856b60fe7db962cf8426cf66a26acad7e88a555db94b379a346a92ac621f9029bd095eedd95fcc6c8319193b57f56d6ac2e67c06aa682e6454018d38a97a49558374394a3a41482e90fb2e627c335ce167688855e113ef0e31d54203b5affd5966c7104512e46f94e8186bc19cbcbe1c99e7b8517bfad6051cf731cb33e42d632ac7c6fd113203965f9dfb8bd9350986d0fc30ec0e9579dbdb5a394128986cb55bc51ad6b08f8dec3ab6cfe35bbd0d29b0294982640ce9b8ddee428a17db7ab176366ec451f6c56d83a9348ebce40921cca8e344f6ab672f68bba334eb1fd1668fa24c0b1335a93e16a797c2227a53bec06a6d1bd6f8bcfad6941ba6bf8640fa75c8df6e14d100064edc2d5b3dd0c55cfc7569d262847a82ce783c1ad6e12dbc9a20c380f32d4d12e8f5a88719ce96192a595f2f091436b5729832d0c7811d70e9db14abd1a793a2c3d3e8aa79c4213f9c6d8232edbb6c55829e0dfefb616dec439045737e84ddd9b2e7ac1c7a9a0838fd555d35200fb0b4756db778f28259d0a1cc6b0507149342304929b1f47da039936a8dd86b461565a1f909f2deba62d2e6e53d185ee0a538441bba1f6e1358aa847c45ea5203b51f834f3618766790de6d3679be8ff7b0070d5156d0c99b5c9f52f16fc5e6397d45b1a51d2209c21f4bcf75cf987da0d31923d5ba1f1b7e3395bd6db4b036886d5b9b5bbecf2ab565837c1f3f78ad6fe9ade59e77360c001f1ef180022eb992bb05b81875339848867712f31bf6dce5b3caa3bcbe471b770b1e8ed8f5f6dd8cc181814d3c03a3ebe0fd835e75562bdc1fd4a0101a7d1d5c858b29e40667f4fb1fe13ca530743d9f595b6c830d5e2f97accf471ca4b544ef7af9d0baa0d2ece0e84cecd5c1b45820c322ea34c3e2d8a64b694bee7047b36bc7c9402004010b6d89cfb831dd0e03c73b1ca7ff41df2492387bea176976566bff7e33a56eb459f464bb1655535cdac35eacbebd13fa9a5e991f5b94ac9ca75415293f6b6a7dfa7a533b408ad76a5b1d576b0021cfaa5859001c8bc052948aaea8903bccf15fb707e9df1556838300a66ca126b114140075b090743176e629c28bd70db1a348ca3e2369f899ca3705540db17860c4158dcb7c44dd3a7ab041fbe68f80cd28ebe123f4fe303e34882b93b57dc6c3cc83b0ad72f1e048bf096962eed7683d0acc7f9583a2a1ee668196df85f72de720531ac9d76f56890f3bb0c1c2b7f1c634f561205e427e03b7f3db0ce69229061b89df190269cd6c077227f518af46835407b9e419c754fb7ce4805bc2f08b11691b5b115d941b278f371f41548f7813549cc028f86eec036b3fdda2521605cee5880fdd1eb2c1569f1b75838732766c1832746b41f35c381c76322cf0d703e3e4849db7f7bf5ebd9911e96737ed35968f18c76c194505ec22e518fd12fc5ac9f12e177a6a6de694f75f2ee7d809006d2658f000c92cb143eba3a1c599c9dfb814f5ccbe36e767afb3c44b56d3925ab61ae12c28558fafd13e12ef54f7b89feab85f9ac7443241774bdea7bc65c0b48cfa54d88afd4fa9e8ad1550ef0dc6b50caa8b5b45be344d6c854c1776529ad442de970739802787a7aa49c3f0dd46b640cc6dbf3d187e30dc43867572575528c50abd6ff7ba30b632503477c28bd198814b69c454cae1e390036d26a827468b9e4876758b2ee41e7f5dc1beee1b8bf7d2fa13ae689e4fc50cc287a9b29066e70ddf305d5a5a6463228bc434b29327f295fbb165cccf8aa98794c2e1df50e0875451a6e22ae0a7cb3dc9754c44a0cb6f7999bbf949e56129ed0d46726140e081c8527c21d3952cbd696579adc385b5a8d29d2b2fa43dce7478f85e282240ba70ed3d8ab55b5bbe5e9252f36fd830580ad2a1de52736f339fcfa499e455a1cbcca8fcfa03b2661f9b97549635f25c341c1cf77594299abe3a967bc2d88c29be917b7a8990350d6861d12b0e82234eb8b93e16ded1a3774ca4e0ccb1c47609b057de4399d88dde2390e0adef67231b18a11030ce31f9646c43a18c159ed97279809492c461f8a14ccf5765b2e361e1a0942b0edb29419e072c559c872893fb79a6ae96244d0b4ec37c6e4a364830f75458918c19c788ce3839c912825965e425171dec6553418421e6e67f14e61d2be4e5eda9718f7330ae3696c6ed7703b93fe73660cc2091ffbca8a3d13a7a1433b1e9effa3ab0b0d53c1cc9dfa6332230014ba6f29604d16fb4f69bfbf6608fc8263c4addc60403020a488b7c75aa344ab833df0c2a65aa0a3789380f41c8ee151aa338118867a68d21dcb5180d9b6ef7ab0aa0eab4cbff674bb061b695e150b56829e08e8341d9131bfba6a4bf41b4f921aa1d7965a1708b0bc445896d6b2168c8c4af03e93a58c2abcea228b1027b89f2df0b4be4f7bf3aa0ec6539195f760ec90276ce49583517b7d179fd9dcd2aa8622eae42a5cca36de2c9aeec46ed31a3e0e6fe8343dd14ba9b30e6d6410adce60160581cc24233eb9299c1e5d5e7056381106d57bf42f2ae39a481d69c0075c55c397b62b9d8f50c8cf3cc93f01ff569af1976a273fedeb859a928a303bb10381e88dfb6a9be813786fe3264eb69a5d43016f66659f7ddeacbf9b87b68166b259dd9b7b8e40e5a319138bf2ad2f3858064766505fc8e13ccb78f247a09b2c4a7ab70a34727712338d2db55ead585501d22502e317c7efdbf809cc012d9912789340c38aab3a674213bf8cde3638e17251d95a9b385ac30eedf8e5868ff3eeafec0e1c16ef52150d10032b4842011b9aea177f87b821b2622ac478458517f51de00e6bba0db956013e5902a744401e6e4b66c575d99df013879b5bed533a54f7866110ee77260a9d2f4f29b3f0795f5f51995fe02a858ab9f800ecc290b34a9605664837c789336460b5b6cc62aadd41867d80cce008060ba0173d0e3bc37d7dc12fa50c6c59a43b5a2520d96e7170ce09ab9fb4cc3c85bd386ddbf93f2ef34ddb7010b8734eaf88f2cf3991be879e9b99fa7a1bffed1f9e89f34d041355fc84834641b04696f08c3e11e9daad7f5914cb8f6bbfc98e2ec5e75b8ec9dfe93cd201081ba2722ffe8f8b3a5062d82dcf8fca7c84751348f041492c1b98341c83198eaa4f6f9ec5f7752150667181f9edde7e7e7e9a6ef0a5456c49426b6c5112ca2e241139f09b867d6fd2c0a9a3e59e3c678d8b467227d5b1b43633677dd98db70255f0e3cb9ddf136da422febcd41c41489580afbf2833e10365fee0221c55be2d9fa6a9423c854b0fa326a26de76844f30f892f62b46e4fc9e1073b8b0a0c8d085206b42cae7488ad2043dc4a186c1c3beba79e2a49578838ce773e920894a42addcad3dbc7cea74751d06c983c2682f36b7b3d0e387cd5ca3b016f16f3fb7fdaa59da811278fb19b6494f9cc2defcaa8cc3cea607ea422d4f2f59138d6d0c2f3ae410619e788af08298719c8f03e8260a647d1504aa8f8d952a8b1fddf37d8e2b4f0cb8aff5d4f884f043b28042fc0594a5bfa4c6410604df8ec52c49298a407a108c11a9bf90ad6c1148bf8bfd815f0ee5ef6d1c0656c3267cca58ae7e5116e3cda3c500b6e28bd66c9ffcc5dc0e6df64715318d0e87d88b336f2718f24ded0337e1242c915065bbbc8431b19073672fa79d25835ef8671c9c0acd4df6a2382a8846a995bfe27829afe1d4712e92f2224d93d36f48ffdfb55a2f9199f3967716c7ab1333a47174c41303cef23184b99318054378754479c5726fc9c33f0ac153aee56f07467f231adcc3aa0aa174d341f98cd89ddeac903de5ea8c9152f422ff913f669047d4dc25932d11d13b6db6caf6789dfcce31983199be8fd38b5724adf73633b60923694c1265bafe562b633f85bf3d49f8ebf9a06cf8bf8b63f6e5cd91f1dabec0bebfcf6e7dd8c978ecba3d0e773ed0ebc885cde310ce5067c2086c69881de26f1255c78bc1b181321a1015d9d2efa11d9d44db4ba6328b8b478d49b719fd7baf62e7b3b5157f6c5380fbb6714752145b3a4f8f0ac0bc10d01b6da7852b00e5de9208a5c2575e636202b92562491591330f9125fc3cfb5584bc7cf07d41bce0d6a07712f3a7b36410e5ee1cf7cd6c5603ac43aec3c595f022a117298a2916b093bc5f54cff479b0ef0f289b684b5a3e11033be7cfe6939c9baebe7a2782e844dde5622c63af02fd6d17dcb4b02815dcca442f990877f1d14f77c8bac0656aafac1046ade1e94a2851b45d5e776bf9648ed84a89c61fd5ed67b02e756bea48cac7f55c8c83dd65853cf0ce60f996a3fb520ff04fab2b08c6e71067eca4b4374d84acaa4219907c3c9d32de41a6f4046286a3d55070451e1e0fa2e23f16e5b2bd6016edba7d66a3b885ee7336b4208141cf1bfaf2a2087b077e6b96a80af77dad628c32325c539c60ef6838d9e685cdea4cedc3dd78c420b8ff21120221c199117961f0ab8212b5e8db20acef554c23f2d4cfa1352113787af044b0ae2f984e9e1a91e3d70e294e12cfd48e7d18fbad87571b9d392449e4f3a9d49414a4381335632fa125b446d0cafd90864d6611cb1c9c261cff2d315a437827a1a5bdcb9120a10d1ef5cf0fcbcd0f9945b61ecbbc81fd34578632fcbcc71bf0c33f70736d702c01961eabdebcd1f31218577415c177a3bbb2054b91c886af2a95a2d4e64f733e843d437c667ea317f2f4a305678d1e2668532b9d07d412562d7d32ea872935ad5c16f94b0d154fe7c045a676e78ad463524d6c6949e90a9f2f94dff7694308fd228399071f81bdcafed4774cab0f024f76a47306ff79b8605243e7a5180ce9ebe58cb3437450ceb1cff291f90484f38065919c5f8c09289c6f121456bb22084e5d9d70dc39130e5d0e777303431aaa81217b839153db7cdbe0cc346935274546f9a0b7dd0633d7fc54cbcace986108470f33e6521c51a2e905b0299eb38d3ac80407d7b7e26f052ef07c6e0647344e42b7d464f4801fc959d42de0169dbb4677789dd81a634fed18a5fa764858302921e976fe547e624d8f7830f95bc8d45be5d623dec18441e07ad41f960530e0c309f226257bdf336c3e0cdcdfb6bfd5a560d225ada0076257ba7dfcf97e08bb70ae90dad33c4dad9c6f26e63ce14b75fe3a3d0c9576bfbe8b29c3261501fab292f6cd0f89826cc0ee457cbbaa6d0f0573001444bfe03b7455f6f0c8f83bf3748d8f86364573c018efc58f08f85ba274cf0826567b2e67d33a02187e2dfd9ed5bbaba509a6e975b8ad411a354cf05caea72115272ae18480742932c45e8e7a8e01fcf129edcf24d83632c531a3c4d6f3a6d071061f944ea26fdb40104c5ca366030216962bdd525da9500717291977cbb513f5ad00835d044620e272e44db071cf425ca99ec2054fe119fb31d8394db7edf02e46a372ffee5c313af8f4cdee94be2749a1967d8beeecefd4a38a6c56ffb1c19c90148f6b385be42c094a3d0f98d03cdb416797e15265e8379cafe5bd1f194cebf24d8732c82229183c302872882798e584d81af5aec9fb939219959fd719a5468a5159b0dd86a8ee0d8686d8de7f4dc869c556b154a5d932d9a4d3463b1f477c39309ab20ffbd8ae44cfaf30a94cc128763099e5a3ba6ec77c9c28a11f5738b07a5b8734d4def55ca5cb8174d17ad918e6f44b52e757701abf76dfcdc05f4621143d7a25a77173c5b2b2198c3c37115bd009f677a3e71e31efceeece99877ef9e551ff35dc5579af321e60aaeb76858a2c4df9fe659cce7064b771df96cb1bcf1e9d585f470dd9c3142260a8c2329076586d085d4775a894cc97203036fb032a17fc02b5d00ef9e4b3594c517f0807b0140774c3bf3a38c6389f4ace4e4ac041f6b06d674534d1a41af0b95ebeb263705f428b3ee828f99587d9bcd038c8441bcc0caa8338f7628449ea388bcaa59b9eb027d73becaf662d32d18579e96697edfb74eb30085bfa35aaf3626ced6ec9ae8de2ce567e8dba28b859bf5add347aa01d5550012b14f8bb920524a63e9083e30d43d03cdea1643226484323448b859128da88206626483a21850a0e9ab1e72e2760d6cc12739acaa74f79b3be3c8ff21370550b9f781e361954d7f8268cf48acab343665f7ce8e980a1d0d239704ae90eeb4cc9e2a0abe713d453eb2f5096d332c2e220fee7611bf7846fefcc9f02a810067c2575606d9349303c94542770f651e44802e468016de8c94a98b5c32e8483a1cd6f2c493675974a5a092df3bf3d9dfb3cdf70e5d522991c14d04b930d30754be7455ad9a8084007916cfc0dc64b94a9e1bc68505d057fdf1637d447ae548c2e3692077cfbf19b30a2ba28b6bf930c5020a21ec496eb024670d59a6ae04cfbff500597d0b0d92e231b6d6a25f22e91c54ed2f18d688ef02db47cb4e6401b4e7e16aa9992825f3d7d86086c55078626a652eb511bf752d7f0749c06c6b0968d5e47a905ae704e651e88215dafac0c84d1f25c19d40b62ed860c326f9f28dd46d546af799f6e10ca22596cf637a463086e0f90d715d4f0ead8b6a94610b14a9a5712fe846fdd4f7d7cd5c19b5a0fd7ad96639748e42f177b986688a358f73eb2d84781934077d5de0f6b6e6814b19e993c48c0cac59679c08a413272137324b199a413a24b6c21e1b84948ebef176c232f9ad85b84c15deff118ce43e4f0bcc7df27606cd34c16eb5d13a08367dac9ebf7fa420862be282f492ef28dedc637d908930288b2128004e73732f185156cfd232c518a697e2e2d1bcdf76c671e4f87acf040b5071268385d929f41d4054a83e8061f551849dd5eddfa3445829f921d09d8b5da0ba7927f9a63daf456b0b2064b8fc1ab87017185071f8061acf40dbf486dfd2e176f0b8658694e64298a26f9d7bb0265842e373f785eba160b287dafc9e8dfab66793dabcac4df39a8a41127a2d577a3e2f07c2f0d278a78396f1eb5c72b85e9cbe0bc667f78288672fba9f67648eb00687d6301ab88836a5f7b85dc922c21be90e5ba6d2f215a5244e1abe13704dd423f2d3f8f2ac187b3d651a27e97d931fdf70be72ce817a321026014bcea42eb3b0b7a04d0d53a93e516f03112d62c9dd0ce2539cedcce84781b34cbae5926b453ec2a01544fbe3ed17b204654d9a4b8c4d9c733caceda93ae7b8a868bb2cf6d98ca6139fe4fa733e337d8a08355f9e0221b99414b157d95c8ddcf471e8edd9dd82ed6f1ac4b6d8febc624c4bfc46e46f3f00c05cfc8abfb4e0b5c23e57b271b4f983ccacece5205b5856b58f3a37a3f8a587f627e8e72ad4273e36b7165f134224f8c59a8fb80c431c26abcbcc47a33aa56dbadec096acc7bd8a17cae6bc2a9467d491b649b3d53b67355f3db9ac0fdc66c5e63d97ee0f0fceb717748dbeb56f4715904067ead33f2d5179771b88d50121e4d4c56abe7a6e38c9bf2cf73ee89743047328713841d3e423f57bfa9aaed1515a6f5c976b63df6eb398dbf9503b6787ccdd7aa0525a2b5c3ce7314c61c539f85a126286d3d8a8eea2ff276c49ff2a75b9c600da33067536494e8aa735ca40c5a9c8315c90a087b67db2d1d74a45e245c90d9f4494e2776540681ad0df0cf76bfe58f7ec8a281f284e3b5cefbb15912803415dac31ec87aab4631db5d5771f6798521bcbf3e7fca4bfbdda8ef2962cb1586d256e65ccbabc117553140fff970bd72204792bd5758292dbd235754a205412559c0c749c69913dae423dee19717bfdab486caa0052b651f08ac969d7ff2e3d04d80133c79dabda0a7e4a28811e59172be2a242d4db5a386e8545835ceb9bf1e53a1ef7719af3347e0e22df22df7b5f715617b76bf18aa4368d997c36cf92b04bf2b7e6f531cb97b5e512cff7d46bacf18bfd807807308039a6edfcaa7ba0eef88b823f4e5617c4c43c7c9ab3d93c6f2861223fe36ebd0dc92e080d06ec0de41b3fcf6f6d6b0d2be13f7b2d918351977f60955b27b379c015cf75b5fc7c3835e870730b239a278ecaa81e2fcee8a2a8131eedb3b7f0a56df0f141a4e317e46828c6f0598f7463e55d85cb534ba7f62c0b109efa47db1163c6eaa814d075fc6f63b0b531dd9272ca63d37f3fa19990bb23f6c4131fce7cf1481e7cb612486e376a1bab7123e8c98b074098f487262d94780f467e5ce92755a792bf8ab38ed75bdd789cd89f0b0bf225aa8cf7ce7670a5afe509a0595cc905ce4af824e502236afcab268a1e88011b0084b68685b6b7574f97424cab300e3460983c6e6fec64740484c4918901c9261fa18e7d77a2631f5481646d8562d9271587bc84f289cd6c9b912bf33917bbafe9861d475bf012e6a87fbef8d10e480d9e4036018558780fb56b459e95a2089c613f21eeb06a7415a3708fd0fd931e3ecf9f41047620acb7283d69a7f566262fafc1ce41771909812de844d4690bc541786f252d3144aaba8aadb035e73e63969dbc26af7dc6856085e9ba7291fa1028f973f9b1ea0113e6072c8574dbea50c730d4e3fb2f68b141c6d84323db284224066678f5ded3b2a58bec2d7cccabe1beed8b8ec8a74937ebdb3d68ddb7b56340bc54dcf3373734fbc04fea62bcded0bb0a365bf8dbbffe2602b3c2badbd7e145683a86664b898d38c05f5cd55fe2b014ed95de70a7d62748c2ac6e6ba20c884d96606a47e3ed6b556f3808b9582dd16556578c8df10ecc8dd1f787fd19225a78b24227f9d4d3924d4e5bc7b11a4c48dfdf60a9215bec11de570a99693f35dfe1ba1d6c6654d4eb2a9cc4984c5d3a07fc89e024c0bb1d8b0d814ba47411dffb4cfcfd9cad8fa989ca5553e630b18702a034899def24c7227c1ebceb865ce00feb6b2b2ffc9e64a61b7d7f893437657a009c33e666c19ce4f201dd0811259f0023394177efa13c4b1f6a75a4b615f7b45f0f0d71137a840085e46ad3f07e43db1d597da493a14c9ddd2675613a8b29e164639e34f43d072fd815df702da622938a3b9beca4c210247490fe63b3bbf77cf78c2b1d43b55c29292801e3cc79209cac7aaf782435a3f3bc09b3cbc4dda26f186ce52726e12e41dbb43c4120c5467bbedb8ef89b45dd030429d3b47a17796bdd2b8b23ea0a8de4e8d873657ca40bb126fafc3bd1cf64f5b8054b564d9b668dbf3cba99f9d1511b8ae57ad6eae238995020c0a9fa85d7d8475336d3041c36aa1d2d056ff00a29b1ca7e22141e3d1d482881ee5dcef5417fcc61507c2b002a1e29c18988a8cbbf4ad2adc90f4f0e6dc8b7a91e7ef7ea359e7049011eca06fe0844e3126b9fe26e827f2c15d46f76f9701093793d528b7d7ba6fc7d832019752d75a965e5c7fc35ea23e001802eb8af6fd095cc4d9351005f5c4bf588a3ef56c05896775d767156efb8e9f7eca03ce3c333db6cd44bae619f03fc1e596bec3e5b0fa46ef0a3b6af3f9ba30f9632d515079e7175d18d99ed98aee8344da82acfd908566da9371a1dbe1b1e2fd0ff57514245bd08f91e2a8f38e5536adf807380e51a209253fdbea1260f45876f624ce96d614631156cd73a92bf788bd6e23596ed8c5d13d47236b30447ef9a074b1334987358887415044b5b8ceec2a7b1db9f65c3ef087aee877310e75fe33abc51e087d3bd0d372d4c1098c06e0693aa2047f633d63cfc008d3abd17f6ace727f096214bc1ce7e25b7270695b6dbd67901d0998b633355a6756afd66f7dfde7378162cf50310a1e811be401675e266e8898e33545814e416cd8d58fab0db65f3daf4f945e3784fa78a0e7400f81438425b433c63929d32942c1345fa40c3f2178b32de0d8c31e348cd0fa7d0a9b5e81f481c15ed23eea6cd5accd82b4deca0a0f5691d7ac290ba3b23c6f83c3ddc2454e9ec0ab2698e452e7632bc4034526adf259ec839bb229284918289248482e4909ec3e832e66dde50075ebd40f915a81540c808461535056fc1698019ad53ddeaa012d16693527b1b8d4688c83773fd72f984ef3a46c2cc9589bd282b8f6d2b1f357fe57d6b6c1b960479cebeac1c88fbfe1d1edcc84f7b80721d21f9b17c8b6e0d80d8a7e118839fb73ca4b92b536e3130359a860c77cfc30f54e30a2715bb602704bd0194bb473d870b4a719ad255a1f674f4a0d9179d89d56dcf5c7c50ef26205a879b805a7539adfd4a21f31e2f73b1a245026c87a17821b3a2aec5bc4c64fbe3bc66f1f06004e49801c98c2238e6d47a587fc813d0fbeb57d882949361bf26a86de7dd091f55cb6e0744435180c9f4605532d18aeb9117cb198369f5ef4bf5c682ed57f4dfbbdd79508f8d52e832322e93b8f3bfa00a77dc52335dfb6ba33c70fe8cacd134d14be162afba78ba9677017d6307dee3357ef660ca5296967be052e84d3c6544877f87816507c9401735e69aa711f0ca4da453c38c1c08dcb02df0379dcd4b768958e6a6f3c36e2e915aa8414f51024030b3f8acd1d5ced73af1df7722a3afe983c78cdb5ca561a91c258c5b222f66329902cd0455dc29cefb36f9a4c0221d9078933ec386283b8f940bbd9f985c1278e54bfff3ee41879e722bb59ad8b40f504e4ccfe4663591815f6cb56776c0015534f6711ae362d10641464bbc777dadad8a55a98b67672c558c947cb0c0d01259816c81b2620d166cb166848e120bc5eea61ceb2a70c6a1e483ee0239bcd1327b6faa8bb68213995c1cd6133ac1392ae35b1dd7a28f56fe2af13e7f6188f0622790cddc5cbae0e2a76e6eed2eced9e17161d0924cbb3ff6d7973a4f5c22683bab4ca668cab1e5dbd0681bece757e5300bc256de34ec1d7423629d2bcbef04e05df6eb4a32835aaef2b6940bcd038154b900f95e0b1d57a482c71f572017ab5a291435521fa14fd49750890b9954c78509b11236b14dfeb3a705c5d5c97a1ff1b59cca007befee40045df3e3d89ad35504a57675e9a7f764db34816184571a9cf7caaa207701d70107653741ff0204a5996d7288541137a441892dcba4baef29db467ef8acf76c1406f7c0b1c264f5c69bc75864a13361f7ef6e30772b26b75e31d5b68faf7c62947b8b7c47e6625154d386bd1feb3ba45cd83330b8075f8d62fa463858974094fe83c697e84943420867d46eada1b637ba43a5d4f1fb14775ea61e0076049e00235974f8ffb8d937ebbef39931e56a784fb187b48339ff1df5de44d27a0b62d91168068e4333e7c7bbaad738fad26f5c509a14570df0fde46629ee5d2bbd21ee495acdf0d915bf6fb8d5c9ec1e2f47413596d41d713cd2f6ceeea095ece5f5bf893fb1adfe6f400d1a9efe24b36bba299bc7ee62b16aa177fd24e6103e21d2624b9abb1b684dc9561bd8376bc2919ad34deca76c2e240ad52bcd9da8a33e77822369e812e0211e94e72da4e9d6871f851731d876fb76de5a20f9d841d1be9adc0596a12ef2a353f6f8c6c98f1c327757347c6d1096b080774162a85e0117e3ffada040013fc98b5b12be61ace8ec9fca8e0094f257c4a3c9d45a7b819dac1b072f8e279f42e46f5ec4b547b821f1eb7bdd30b82120e082596bed521fdff577146c2937078a751edd890b5a9fcf011e8ccf5fd3880fa996105d1d3ed44452b83f8d909c55fc1730dba90b977f90125b87963e35ce4f7066737f59dacfd806c45b1552d122f0b31254678cb30db3f30e2b559b541f06e3ea232d7bccc0a12434fb412a54dbab0b83792859acbf130c3a3ca03b74bc2c78956a490b833786ed176f76e2f01e6ec932394820a7a4e291fd68dda94b38ad8740ad265f803ff0c43e0d52ba93f352ec50a538118a389ce568415227e978406f727a3c7fda0d7d9e00de33470a5e74c2f255e076750b9a4f6a2bafa156c4cc26de29f9248402f008b7367b3d1ca2460f8fff3cc4bc92e701b4281136acd3a46a5ece9d3839b19d5b30db26b65082668a18aa7a0de752be8dde4d9336b34e14cc53944d3c0cd0b405d71b9bddab41fbabbdc755e355eb3ddb68d1318027ed7f63a02aa5aa7faf666029d40432553705d9cc949918002ae9858fe2526aebf0665fd14eebac3b77bc0eec7511a7cbdabb05315df58a187b9731949daf2ecbb5a66a03e8d4c4c485acf6246330c5e302bf0e2b38434975a3a67bff0eded6890592fd57508f13c331e9008b6e21591c4570369e1dd6cadbf2eaa8e894b90718bb18d05c42c118285c9af492214ecee41c2c66e715ec3a9c0c5e56a309d244521b01a5d1f9899a98fcb17a6c7825da1517d47ceef65796cb8abf0177cacf77f6899fbf2bc7afe6a9aae056593e7f883c7de6e668918631450d766d8152ce915b48d6a163ca4f7f449bd146741bab761f2f2dddf174d17bdf39c182ef441954ce45ffbe68208bcd87fbd77326a1f86212c312e3b9b0b0fe03aca642e413db39a5ca645e03f16239f3228516c465b6098fc6138c358e8b52cb7db22ef0826efc5fd6e6c25d3166b9434a4f13546ab5f3c6ba90236abbfbb696d506767d674ee4d7ef3d60600f809177039e2b55960e4a2d039afa35cdb0be0a595cdb9261936ccab6143ac3a1478ebf730ef20b991becf4a181aa95e8268329ffe2a002c919ece618332d7797c84b49548bf6d5fe2846e1ac7ea93f832557fd6d07b500cdaf7bb23b0db83e7b72d391522d80930d111bdfdb55e3870978a14fb73735162e2a88e386c50bc979c78a1aa5615c45f018ebe5eec7ec61801533ab25271bdf923487f014069b601c35c6170dac6f25a6a06b26c90bf28c125432d75b6c7cdd308ec04abdfaf941faa7cb129459a7da880b75a5e0cd48f5ba66c9e3a8ce002de87ac06076248ab6d5ac0f852ca0d1294f403876275ab7f8404856a34dfccc3eb242a9c843d09b2e40478bbf81a318a53fd9e2b45d0574a8950ce6cbe1374f2e2bb3d3c29690c4bfdac497ec650921343a0e23980e4c0ea55f3bbfd2683cf0bc28f959e0b46872e7bcfbe51b9239e09cd46f848f4726df32f35276079a13c454337ed156b2ff4e32f73a0e7a76eda8d9b066e668a4972214433369f5b43dd573a5626e9129aee3db885f24c78f6005d203d87fa389f76085760b46a03ada6cb2b555f19b78a55e2245da96cfa38241e7a6b35de7fef6c0f21d0890670f2fd5c1ab52760b406bbae824b256ccd7a9ae8d3f90b8ee6050a2e343f21918dea3f9db11c7dda21bcd2f56fc6b1d840d6f41f8df944a5967cf56770b0b065954c2e2337c0db79aeedfecadc0208c55d59a746ec038aa4d8c4345b5760292b98b72fa9dc0e63e75b7c55b8886bc4a0ebadea3cf8e4c26941db954f0528308215bf80111b0a1dcdbf5b25d8bc66f3d7cb427776f0eed39d16ddfb0fa508566109314e6f35f28519e91a2dbde01901ae7f311adc14e2a924f1376b098a187b13001658f5d2940615a1db850022ce18168199c7759fc7a8c407be4ea565a82743d477524be0d5425c77ac35f84a312b15db6b593db89c9bcb35f3c3293857a9cc6e47f9b471f9cdaab2937e6c8056775dbc1709116b0857f40bf9662ac8ebbc5e3bc35b7327aba675b9d4cba58076441c07a489d5921eb8b0d4dd228a12826d909afa6cae8a7ea2733f43818a7c5095ccaa702de79e141bf8708a390488094ef4f67c86e31dda7eb92e8f00637298971b16e48f004731828f3b33f505898f6eee9907862e158984f68d0488bab03b00ca330d44f4784ab55eabe72ba8f238fe37f9b5053071e85e26b6c77908e6d49ff69e384d43c5d4d824f6a70facdb5fd7fd60b693c72268da6f2b7429a015066792429c1c19b6cb606ca74c1e0da16e243c0ced4f8ddd00e6897f8f923e0e1c75b0775df4ccbabad55eddf7752a9a46c799a8418cafe56a1181ec2920f38c198f48ece0f3bc670a68c693815e103e05af3529f27329378763ca5a84266a2dc647b3571bc9b5bc8fe8d75b059c807ee8c1ce866a3fcf7d73318e1229173200e8757c53fb7b2e4ac3124daedc16c2292fdb45d8ed5e41273feae80a23504b90bd182d136711f9e532774292795f5fb9a20acd42399e826dc084a360166031eb4cf61e29607251243fd0172b38b6f57b6c534666c36439bc1f09a2246b642740cf877a71f23d65b6da7339d1d86a5f0a9a8a8799028b0659d8ec5c38382fd1839943d91f579978880572d5bd494655c6d83307f0ba3c6d4208bddb8a987542b5ae61fa77a784603d43f6236a12830c08a86160624bba9a0672cd85a1ae78de57662e1ec38e16be8cf332508507bff6d79b7ac7b912dc4a64c5fc5930d4d15f47084fb8270f93fc7a07ac6163c7b60c8bdd961ae748b1fe443c4a4f7a398146752c63a2c5d7328ac24cd534b6a8bc75f0159233a635132b0be52d2c4f6934c630544aed47177c4b195da207fdfdedc079dfe3ed98c489a4d5276dde146371aa9d831480f9f1a4dbf51c8eb5153ff6bc72cf940b4b46a6bb3ace312ace7410b21adcdd0b3f8db693fbc86723a4af880902aa418ca022fa79ec98f1246e58e3c21f8740837582cb4065d27b4fe6bb4a70269979814f8eb81f251d281143df9c2a6a4da644c838ae2a8d83a9890cf26cd22e44c8acad3d1fdb1792b6cb36e0b97269eb804ac65a73eb58f75da95b0d58114cdff3a1c24e72944924c92314e73de6617884735e22bca1e6ed793a7578ebcea923a834a71f1ed5bf822ff1559ed9ffb790d6160c4e4d691307015defc7fbaffe544e3548faeaa2e4ce08c647d540b5fa57ffeaf492624f0b22d41e7dd467667345a7e85f44eccea9e69d813ae98e424e231e656e601fb672edf913cf22ecf8b4dd1d60ea83c6599025ad07bb4b9a4e91afd95b19ba79f1fa10630cc23d8a152f2d315fb284668d4d2dd478ff0be46a48afcc67346f5fdf5b6878e04614601ca1e8e52f294fe1d6a4fcd73bfd47391dd08adc46b0fe5e2f2a6885a2d0543b703a43457abf742640f18999bc6882797ecb3fcc1e9fa0395cf496ba70a2e4e0b7e8b4644e3801d8118996252be22e15dcdddc6e52665a25c3ec05770c7f3c7c8866d6a477b7a82a97ca71e1574f2ff349f70dfabd58d0df47059bf36d3dad2dc75fec1b8a9753d931ebfa62fccca314c614d64bc644f9990ee1e9796a1004773d0e34fb118f597988f6ba157b5db4b0be7a52b7b9d7a13d0685a9a75639d81a2228f1a957054688a25de2061be5c715e90693e53f41d2c3cbc1302b3e1ace6d84fbee25d6478a836fae3ffc9300409d898169c0cd6c3b94aa4bad2eab971ed03a469efbbe1513dd5b3de87e7f23be60a9e115011b995eb5d00c24d63c3e03835ab5889e1c9425232eee53c1f8ced8231d0809e0ff38c19cf39554788f88818e34eb0b7424cb8babdd9bf3d2902c88479ad06553e5ecb56e582f65d306ace3b0d87c1e1ebc63902990274bdb333d08e5a024704d23f6b23592040943a7abcb5222d54ba1bcd1f2befa4bb4d1c418cbe97b4aa456ba1af7a8b46a06952e553cb7e44047817aa30b2f05c20c831919c93008fdf4a633f469de98c4fdfdd81fa71aca244a8bdac8166936ddbf8cc17967dc1fcf2c7e33b59acc3a51172504342a103e53ea6db6dee70a2cad098c9ad60300d645387cc025b5e548bd62c95f38e0bc7f2befec9199986ccd0694567f139c5c5ccc32dba9b2c67e9a3380f506e725e4ee424db35f96330b311d4364013e2e6f9de3b4155b09567f203fc2b4dca43106ad114b99d2a868933fb70258744d959330229259abadeee7961682f6071f613bdaf23bc5065c50479ee7aeae045bfd9f5b8e34bbeb275823a165ded8273406391d58effbc5ccf60bf3c22e3fa212127c1e7270983ec0b78d5feff8b4e2cd861080ddc32d3edb11f7834ff05fe11c28ad4329a2dcbcee356a9c45c57bbba2e1fc99426e9b8c5545268b07d58c2093d0eade48c6476500cb2b0c577bf89fb9f92dc8ec8d4dbe72e0ef9da68a9ce6f5e6862f4e60e90294f8952c95d7cfb9d3bcaaa09133ad7029879e23c6f0cb2f32aab43824e5873763a7eafd60572b59dee4670b458d3ff490d60785af38af83e819bc074c3cf106d522d1995cd8eff9149ccd49491d0d442bb3b006060f5cc6a369f50d9ae77259161f11de98e6b7cbaba15e917755da96aa7c4377beed411139fa6e452570cc474706657cb3423db78d46b2b0c51c85b471074de5b7c93707353f7bcdd25be4b4a8ccdb14176e69e677bc464b2d8dcfb2563dd6e8b855a6def748fbfedbe73f684f189611ac616f1c3cfae76ddda43e92d193de6ca83dd0e87f8cf971df3c4cca91df74f15a212c88512f2b4aa4485fa66eb96c1e993c75884dbe34083ec5eaf0dd0330588a58b91341dbf44698e3eaa0b614aed32b48ebe06d7058d32013afea346d8247ef446375bdf9c40e5183650fec8739d86d9668d9f24cc53e5bf9b705cd7415e1b29ac2dc5bb4cdcce6937a3a221fc56c1c43b4007dd601834974de89dd60746d2215ecfc0cc2eee2cefc3bdc17a9de6afb6cd16cd7bf78cec58062b74e9d80842742811705980c334c6159c39cc3ef6c858f72ffb3f5916983a6779b8309c235b89b4cdfe6aae6a776ea904bca767aaa0fcd181de3195cff4cfb228d4cb01af5acee1cfce0105f5000aa0329a85dbcedb1c25733beb134d3c8b079c3b6af7cac40e00f8362abc982f1028416e0a99fc8d0f5b05e042eeed33acdf8297317b04608998f3f18f9c701a67dfd35588df8d1d07460c2a9cf591b5d39b3754d4ec19556977206c867c2abb56dabe4202a2714f9d119575382d9db47f3e8a9e66dd74e51e08ae59158116439442482686e200c1e660f06117ed2626b81dc922e5bb2c082c7e2c7d0cd6da6e10f8f917e0ba2e7f669357e7c8b8508978c2005ec791e44eac92814fb3b7c74dd5018c17c5395d126d65530bd2efa1e81f627b265a4a7760f5c103d6f890cea6817f6697ed50418547a4b336659dd420922d23fdb6112364a89bc8ace6fe715ce6958784f753ba154e1eac923a6174995a2577dcf64f2f69b6f4cb4f49a4ca1f84953fdb56975533db9e5a3947e6fcf73615b2b78f7a1509fd25868f3100082528e971f163d07617c6bc801eda4f35f6ee88187f44524881de6ff93b7633baffffe116a32941e01d3e260be11b7076fcc3bd2030a49302a429b4fda6987fc1ea058af5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
