<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a4bd81e1f0e20746e30be5779f8f104dabe3e049eb0299a1d4b5f0400d9fb0b4c0070eb02a4e3e7e7aaa9961aa47aee4d56d23b62d87176fc4c133b840e1c5e1ce0d3367782ae0bf97066e9c3cfcc553b737020b4f52bffe607a8fc5ca285af7438c41cdb4f184032294bfab156da5749a7a70328228317033c6e042d2008cefc2659144d3a8636715d97e00138c5172a78e48118474c3de3975c318f86ae783191e297f192c7a97e83a58cca83d9ab61b9ee9890a51721e30f21aff9df8a65fcff7dbd8b18c24fcb740dbe10549d809eb8507bd5638e39e618d59ea1d9d82c562159b4ad7843826a56cfd5cfd3f4e2ba4780c884a70a66964c85347d1e389648fa92d1d4a826ea87807de899ca2cefb301817dec154fc539ffdc5eee7ceec8c18873e6fb9eb7e2e54defe26d69ed11bb6b847789e23b3af0683883a528a0b81504b246e73716b000f6e511eec1b6a10d30805cc43bc65e637ab250aedcdd7761bf205baf9e2bf95df348ad62c8c507dc57c9d036d9f6dfa6641830d98e439d8458757489ed249c9bac8400405c45c43a8c2e234945c150841439e218efdf44fd33a2580f3cd533318d9000faca360c883a67915291cbe50ef96e7b9c3647b8c061369b1c7a07cbd290602c96dae06d673d644b98f9c7401841080c9b31ade231ed408c0841d3bc60c9d98dd389e2e082c84b2417ce74087c72393571fe4fdc378dc1b9ebb788419bc9fa436a5454f169c2de0ff3c9e18c54b817089d234932eaa35e14b2a8a4e650e050a29480ae7495fa8e3cecc9c1cfb7e7573a562d4a3dfd16d595ebb1a70e114c0bef6eee8c449b92613c60c1b9abcdc52001eabd523e4458c7c7a798c4503cdafc5fe5660e0094304120d3af8017fc3a323bdf7aa9549b2d53801efb3818b64f31d655cb6abb4624272e2b1d9d0122c74dc78ad5e47fd884fb47d284d408bb13e6121490a551d903766d8a9b28a89e169afe059284b8048e4659af2a4db0661a654c3e30b5cdd8b071ec85f8e5a5c92b70452368ea2ca6b1f724f962bebe1ace31d2f231165745ab5a0d6f8910e56bd9a935cb24a81d95394892ceb721ad318e8d0918ab4044609813861aceaf530e39fe5911c7b07d5426697a45ad7ddac394f7b68dd42ebe188bf0dae0a926a078002c78173d7e0ec9e7928cbeb91e45754f5b4fda4b198d335ea707522b0b4a790ca665feb7e1e7c1ee954c9b46a7970f1cf224974ac98b540b5191efed7e19cc9cf7aef42f6670533cc12e56e6ab41177bf8713d8ae3aeaf28c163e1755152ace15fbb5c81764e2556282c24aae567f685256895a665ae8d1c7a32789e5106c1649cbf02847ccb46f3b119a4a8b61b3dfc892617ee5110736864f374da72a4c8df00893e5990dd059f7ee8c06f397afff3a4b347ccccf5169e8823bdc82f3b86276caf8faec0483b91c099d76cb01d4e76b8657ad20313599400980222c94a7324ec640dc8628d6afa88fd8d61970c641771e2b62afbfa6be85ac42ce6d0e6dbbafdde70277d288e4b6b1c407f0b3ff320dec7171a388708f916d75d221cfee00c6caf3d817ef6d2874600cc0260b356167223313b3bbf92ef477cff8c1a07bb4ee27d89a6112f24a5d77f9d99eed0b639ca672c3eb35c9072afc75390a6a6a34c9c3f206e531f58984f086923089b6833cf8a5f36dc4ae811f9d08096f5b37ce146a26d80c0e245c959376af5e6838d805e9c9e15b7c55e3d0b3c1c9427d2481de5807f3b0b322b3f97d1cbda423be7a5893f5874c3ba3eb236630fa60d6ad9e6ceb289cdad3c1b62a195ab2e8a463ac0000127c486ccea3d6f4d4c42ed4faaa63dbd11cbe7a9df758d12fe001e09ea4b4884705f93a78f5919e9a7cee659944436c02b5109e2eae6a8b96bb76020e7a037241c83e568580d758b9053a642e9a2d49b18cba3807d1a7ac74bd03c7ae44531df747375d2177b7da3185cc6fd5c3e8b7e8bde112993f5e1d16d31fe1c159fcb7b21d2675302be367f29956e511b81e24926f7112029cdf113ed913f5ead4594d1a8172604c1622bc0f67dd5a45f3af1605e1cf2a37d217b199a29c79c19384a80f1866c0a6fb6130acd456c8453b3f3ca1e8d70db3efe7b2e64526bf4d8b913f3fe9349ab2f408926113df4de9881d20ce323021cc87911c3e128732c6642f922edf30183413cae4fd68e2bf1444c72676593e18270a45878d6789cbd0f017fc2c333d70c4ef84c1ecb5a116a5b43882665b2c3d8a63e5a910815ea7c08b75d01776c17b89d8970835469ef010f43dd83fe0c2c17c5bc833e64d0967475c44dd0d84aefdf8c9e84b7a4072dab03a7d56b77141b881e95f3b52f00bffdb5a9b19bbd4600d7776547d8bf3446ddb43d49ebde1e8f905cd515133714d66be6b4cc3f9e65776145911b756c2059a8ad9837e0b13f9c0950c54416ea5387857d3aeb44f4e7861442725e1b59dc9390d275e1c234872f9467bba1df280a800eb6f25a95d336fa4d98435a8ca0e3828b2c87094d9aaef0ae55058a040e7834478df94aad255b9639e69240cbfbe4ae8eac843ed9a5da19e19a71f7887e9ea58ef8e657fee7e9311ec37cb89b3ebff19f2951824c21e9ea1751a9318ccd89d637e77743e1989af1c5a32cfd20bdad2ab07ab3227e55afd68aa44cefdbc787d4abf60ccc595ea9b39be7a30bab2f4109a459716c83d5fdf898cb2851900eea4fa28337cb4187a5f7e38634cb5c8ebbab90fef470caeee89b58347bbaba85b46d146397ea5c54354190492856fedfb168710509e2329b8c0d55267be1c936c1fba2b52382c800395e6e7211dc8d0a20e450246a60db8d616edd0238c4814ffe4934c1a5c40e4909768c0599aae3c5c2a38e9633e630f84e5cc5290e0ab230d2735f7f0bcab49e0e45cdc56674c6f71d156f37cb770b844452c88d1fac0eb245d8753f287bf67ed9d5522731f61f5c8d3b30bf5c39de6dbeca826fe97148e19ec8a2e8566bf532c6bc5f279eb45300e1ec989cc93ce7e17a7a890bb7cc4aa0e749dfc99c1044890a966d10a354727c4aa55ac0b72a324dfda92dc39a699cc9c8e52c0a18003097bb0c0c3c6a7171583271328c5bdf6c831cc9cae2ac705f6a408d080e7e23c37230770dc4e3d3b76b32de9a045766e0d2356d7747e60e9b8bd19f7d6fad025dc14913205a9a80e92f99dbd1b15782a1e255bac41df23cf4fbfb69c7a39d6ed192d3e233e37b9b314885d2e505cfe92fd039feeccfba8231ee7af371c0693a3577c31961992cf7cb7266d925ad124a533cb2508a629c97d6f39a704b0e2024a6249a5ef7a0dff312728976477b4a1e56d79274b700f5b2ffd0fd9a35c7b0d0fcb654e37fc48ac8a3818a3ecf83c1eef660e92a64a0b431a24d4a6581916b6505b6577c9207f4c99ecce6af2d43f35cb7951949aab2ac309dfa8410759bba23438914439c5c4f122434dacd88fa7be4fc4d9a176da778738c5f970596add122f726d979e2570d9c373eb27b426d129a3d73afcaa71fa4a304ad2e90b0cd252e4fda9f71dbadef4da767bebabe2ca5784f2a8aa560e090894dbd027b5fe1748fca122c352fa1ff363f2bc796636b709b064c8034489b20bbbc1f17166bd7960ebf28f5d8918081be04750a126061c232c7a2a7f13c98adced9187feee0a94b7ba8f698edab63ee57d38dd9b18426d5e05b4dd34d12bfd7ce3adb7a48d96232bbe026f800a2868881a8bb8d427b3386b711882504209eaa6e31b97d6d7d65862884d9dc1fc3cf1261e0291bbdbb5e661beec213f0c2dcf05e239e9384824bb676ee0d16bdbbfade76821ab42d1248af9b3f93f2e4f1c3116d62a9dba8be632e616a17a5d7338f872bacb47376c1bee1bded9aba11eabebc42e720d4369c266611d9b0ed380a4a7e275f891fa24385d79a40262f2ea0b2bd0f8ae62e9844480b4c7f71dcc9ff8f836e275e39d88aa111d0044a75cd9407297b9c76de5cb257e7cbdde849fdcee25347c3482e0b4c2272636d047a872ff1c214d184545a9836abe092feb03572ab3866952e8b2c0388db743708fd10cda3b50c1893a040ece33cd0f1ae3fc27283f83ed520b9b392318bc8a3b686f73664fe703c93168267b58fb4dcbdab45f98112641c2fb41c8980ecd52185ea0985aac10edab4f89866eabd223df822c54ae29c452a4f3d74a32b3f409ec4fb7766dbd130c41917ef7c3933c3171f534b7584b265b6bb0e993bcdc018e30437c4848fce315cfba4bcff52ead8d482ca35b8e7fef482983e638179bf4ee8d73ad2e307424e65d50dadea6be51f3e064b739636e28ef19959402e412c72cb7c30733e12ca6b6151f13f2923b70b9c737659e1353a61a3be4ada0d913515354bfc2245aa1fde99695d513bd329c973591e52e488821032f18b3eb60769c4bc7a87febc6dbe44139c83937e5be75c7617bff0b3274ed903a2b8eaef236709c04d843c5b08a586a0dc11f668e83d88df7b2a94160972fadff0efb2690b2dc9ccac9f5333b71ee1c747c849d3c9046b8baa9bb1737cbfc1b7aad6983f5b94c0bb8068a86becb7332e725e22f7d48d1eea37c0cf81d908f7853758d385f9c80bebe71edecf83d1c0d3ada803c020ecaea8a93b5db49a757cf6986ef178bd8c6cf5d16838e478ba5d29a5709b71c10dab5652ab335c4a76085e3d88e95e9c976abf9225cffa512d0ba99db7e78b9f3d2fa08b7f61efa7f23dc7c4cc5006d838b4b385597f5e4666b87e88d759ebf7dfc7277f03b88f1887a1462ba56459aab560106ce9d1180371f59c1a8e42a89cc88f49b62a1c567402b902c7c02532f075877d0b81dc1fe4cfb9945f4379e527b4080f23529519179bb0cb81c204ba9281d78d64ff962ad703a55c197b18ba33d01c977d939a8dd0bcece3491acaef34d877cbc5b5d978cfbfa97e7e78792077b10ddbf39aad52abbb05ffb5d49e83f7bcda420b491e002fc1852a93bbda43a67c8c364f03f8b1c3e719366529a6ae8b01dd8a90f4530951f5c8f5f97f6e85bf12681aa1654a938f61a547771cb860727d0b688bfc8873930680b11db9dfef394c823bff11303ab915eb41af95cf189e3ef65d3356da9ab43a83e5f8ec7d5f4ec7c6f0736046ef5e66a535e9d902765a58789dcf3ea06925f20052afdc15afa9ae15382b6033d4874037040b2c7cafc13d68facff5f9bd63ce8416bf3b7923459730e78bfeaed1dfb747156484417dad8a8b2f8f4a31d8052b5b78934264903fce751a9b494d4742b62d96993a87b1bf2393a4468d968d9c1390866cd78ca8b5165c752f5dbba53fbf4a3810ef0b2d93ec5ee4131fa638c48c74e7a483cec8ee805d47106e869896d7f047997022db7fe182426367fc341c193de1b08136fa8ec55d46f55850ef26a604174e7f8a856ce81c8fb773861068495b78c26d77109d979eef2a03b104fbb9c7bb9af48a9a3c499aa20be966446cfc9c7ea140543a250ec20098a31e4081da48a9c9fc74fc91dc2fcd5dc88e44045dab88cf33c2a236107112db6ed227ccf4523f67572ebd347c5c4ccf98abe1abaead15ca58beb3c7365b678c4827c368b145842e81e53063701c9e83969372e667bfac97bb284dd06b4a6b67109211dbd31fc7f3113c3e187b10bc0924c2d9751ed7d455068e8d705ff353dd9ad246addddfcf375b8b6dd65a46b9ca12316c56f59f70e763e5f20642e31233d40f9483906d104f3b3b4ff96ea8a8fd15d20e1a4b82ebd0daa2debfc81c422c4f8c10a6f01f6956152fa04057386bc8a30c4de699a1858ddb3f54458c6ed8a54987eec1c81fbd2dcbc70fd39fbce85c187a228dc7fb9800f5c2fdbd63bf736183f5ec13f5aa8e56e83ea7f2337d3b90a1c457c821d095c25cec63cc8ad314e9f3ad5e83d024cf3097267f6f64d2d8cc75777b65b959beba4b5797361149bfb2027615dcfb60edf889c1c2e201237af697b26c220229c6321221614531ecdaca1e106f0b23ed999d3d767f64560f54bcc68e37b8d75956b3de92d3d16fa0501c1b843a45905b4d62143bc323ce72b3f0bc0353683c32861a34bfbfe823fc6bbe1909228f6ca5e84761bed6e2e2d3b149b8e53830425f9907cca4422042ba03f42badde47767766e1c564072a01b7fc66cc92d179944297d72dab566211856282fc29d4f2d4cc1840d1f67f24d2f56421d2433f1b1cf16589c4b7d514b65748c63ac0fa6b716ab42a58062e7d2b1129409bfe238a56429b3956d500ce9116685e10c71cad0e5f72540fc9f99e79fb4b2e7190d90ac07726c550ed81150f091695ec7e4855477d5f22b70b53bb766fbf4bf6d1acdb60f5b3c104e4d1d3430438b37f38f62f98815275a434e54eb10921d500b738a786e03af6c2d750e5473462fe7d1e2ac819579ea615550ebf1ec5b387d59a8348cb671cdba613a35043e2adaa9029438daaec9417a872540712b191fd245d0851956741de970c1ecce2c9741122e6133e2bf23c44f10f293b17f0c438bfd068771e1fc47a284e742e4828f556966abd0be3337024e2890598ac3f0aa27ae6d68c3a5be1919da814e774e6629221ac258262006395584459e48901d704397ff3a4e1c84227795edc659e68d6a791d854d0b5fd3cae04892650f865eae4945f5919659b80f55eee21a064d7a2f95b575617fc8e23f21559c6319ed01b762bd40205b1f0c34f28110030534b309ec47a994a2eb8d3b6853256bf20841a2fc5a54fb732320dd581265603a3fb18a70a0cc0ecdef9e83faead610f71c6a094821b7feaba1a6c6cf8828b7459d457ee0344f06aad8e9f306617881a8ba24211bcfeb583967b786a93cfe7d5a374646d8abe3abe35f99150df5ee3b3bb9b716f1cd424e60402728fe4f77624a686bbf9dbfb221bbca6559ddccaa475db9fa3391d3ab21b6df05a048f723e6b1edbbc9dede2ddedac39e2209dab30994155fcef60bc04a989fef74328d304291c5da6af40376c30d3caa59a5e5f68817e6c5658823552ee383c564d251c1065079571b6563dcd87cec02273a65f1bc48fa5c2248246cade40a662a6708ebdc94af84708d515b07d42a24dce4fdcf231adcf1899f4ee679a9e7dc6f084e73912cacc2f2e18ddf1fa3bc0160fae56a4502f7d773325ea2a2baacca201d79014225a85ec371b9129a55b777a3c4aa0b55957e975c18e40e7f8076a38ce772a7e7c1547d89ab8a1cb37de08fac8f7b574d46b0a1541189393feaf36773be3f58339c6abecb396a33e84f41925032c59ad1ca9b48de22551b8b9cd77bc170315aae0b7ed008b660945b5794640be1da96709b860824c0f4e5fb02f65f88c662182b6c40b4d9a1e4cf287d204541a13588ccd43b620e4ac5ecbe464bc7b8322ee21be610e056a20932a2fb360a1f619fc7a77ff4a160977cc406f9b4839b074b4af8a7007f8fdcdc68f3461abbda25659acf00c324b55af0c1feef7cff945f3090ceb0949f3cb668177ecba25214f632cc12daf28ddc6ee5e54040f6e9db50588151ed9eb72c57eaa27ccea22f751b6d0c55eeb3aa214a1034b0c1f2a8be11bbd1120f940fb9a52296c22c4aeffd705fe49c60833915dd67a67160c661542e00319a336814ed041033a76066b2318dc8f606e2f0f8a065178e3189959ae247f67cf559dfc8306712628aaa59e9941bcfc15aa6817daadaecec58bd454349b32e8eae1d149d4f98523e62aa608fe1adf4267b64143dc281c1277a61772ac32894d5d07e5bd5cdb1dfc565885910bce80ea66ae08f31c9f7d8063d0779bb34d4b9f94a5f8a3d488adaaa2e644e349cea3c556a8e79beb35e7b0d21cedd52f5c0273d05c30c95b28bdc9ea8af3c83baae5aa6fde22f5b43d3bcf5e6aad1dbc2f54247b47a58d8bfebae274882a83faa30c2e26b1ab333d7589efc0a9654eaccf46af2308f8c666d849676cf7dae8c930c7979e501790acfc95bcd4432e3075038cc2d2e03d48d6cd6b92dfbdee280602280fbb919d1c6ab99b6bccbcfe1638de000036a27d34309d232acae494f5e1f9939ed39d4d024869eaa22378e5aaab2e4cfa51f7f726e139c5b2030f1d648e1a4ad4a7f707826fa80de11c3cf52292eec11d7f412efb69695455191db5619ff2eaec11dd4b82555d1b0e66885c16cfe4a8b9577a4c89e32c29357f0dc8c546da0399de55b1aae88bafbc8f0b1209ecb5a3167fce0a23cd6cbf6ccbf58d6b58159349b268504b2468e21373eae2bb17183b8c83ea95d4c7207a2eeef12fe454daaeb2350850e16a62b8b0ba9c5a3a7487de22c5c0b3b381f6077a0683f5b4635e950130a990df157a3d040e972a1b1b61e25a4dbd31ab0e6a3fb9714263a2daa7a66638721f8731d0a1989c443f4a615ecfe9bd444db72fbc89a0c854118499d2e1fbbe5730de3035094afb5e4394aab30549e10c006ea9c528886b02a2f713c78f9140f81afc623e134a97745b3438e7476b824afefed2316450397ef798a456d567af690d4845adf1915283b65fc57221323de8f550ff82115c6990bf044ed92669e28785461ef074af7740021ac462a6e3e9d25f3dd9537c08e8cb066329287f66dda3267f9aef985d235d7b9bdcd79a98c9d3806fcd4e96f9d18d71e113f6ce6f7d180babbed780b06d2f67e6c02364031891ed272d79dac53b24651a9318c7349a88d640ae84ce22fb75ff6edbaa149a411c7d822ab0633436359f9d4180defb48564e60481cf256e592473e9c922902fbf0c2f9f7a5370231cc1fbcd20a3a0e66e52dcceb8c0613a71fdb4a48b42f05630899ce7f7b1de9dca39121dc748e4a45c527cad55ee9e86a0f52d33911f026630110effde8b5cc6668248e9fababb615da9222538002266422942426296054e98e8647a151207b2843f0fb14c2dc5f98e4e168b64dc9579c398896f0e029cb9053149ad51b9a8805cd4b08243752611155a676890d9af49a2db2ec0d08799b8a664a43ace1a81d911e539f59832e61cf94fc2feeee6601c2535caf25de15611b0efc5240c2b6531738d9e1231dc84dee61f98d4b52e52e06f6790ae45d73bf87160ffc8f6593160529b7e60e6f0d310df5cd482a8fbf8bda0ef41abb6736709d8b936f0ae09c4b36ec338955063689cf75946dd746a784aaf316b77ca9ea5cb409dbd7e7895d239fe551f6733a70e740e59b7ea3175e505ab18afe0e420a1980721b3aec5655ff95fc71c55c45df894b4de4536ff1900585db74df1bbb9dcd9f5923d5cbc14ac4d8e13aa86da9d3c77ffc080b83cc7663dc68471d452294b6bc9ac0934a928383179589d07cf039214fbe5fb4cde6db4d25bd48eb1e286506ee0fdcbb8c72f31468a246cd34fcc15114a211a979cf1f5334e2de6e6ceaa31c3afc0f37b3bf0be3064a11d6a41333c7165fce3aafa62170821477146ea88974448bf9f3126a1eeb883464554d78d05e9464cdd070bc18f2647092cc81f09c0a19d897a6774206b9ede5800841a64580ef63e26e6586d81845c0f825130d505a600f2b600e18211abc9376210193373a110d95e68afe704c1c9d18814170b72ff0cc63ba1e1b727ea884bf68178febe3c2f541cb3d95fae4640c0bd009ac0c4e8c039bac0fdbc4356c0542fe860d91178aaebf0c915aaf4d8216d052007ad55e560d8d28184c2943abf31cdfd56d3b43caf7173d5303e5917fc1c7d3ca34ab9476601b9c0d4dd36edd23fb172f9301841af93164115cce05185cdd81c334e2138d949774f2f45d1a8043097099154035fde9f3939e71fd70493f1a7568702607147e1bd0146cfbfb6c51968e50109c0db9d692cb73ebf6e8409dc5a62d84ff48246b754766284621b31e7ad0d957b0a77ec9a4eb0dd19dca2dba7217a4216a99af1f8122b607ca228a5836c9b86ea3d986b3d87c211bfaa9cd5264bd5de0be7bf9a3c1a3a2470c7c430877f7be750a1de9d6795b626b0870be148bb70aa5ec02c86e84bb7bef3b1374818491225ad4ea985de289f2e1df19db520abf8633e7d7c24ab72f7a70d751c8627f7123876cf2e087ab597dc00ba9e6a9173bfc6e6cd659701caf33e205d322868e875bd3e94a1e7253e37702c32333299093dafa639530d04fe09e4c8b537654b25be5e21fa4b00d6abaabb10524699689b01f969495664daeee1d28ee1a238a7db7ae7693f8a24eb936f54f3dda4e209d59e4fe7344dbd40765880bc2c8da0b1f71943e212ffde1e80f022fc401a792e7fcec69d9ae67689c39ac473b46809e07e4bdf090206a97945a4e3855a52c1a5bcc495a971a01d85a9461b597561f8e998cc3229451348d03ed166bddb22b687aaa085398614092eb504f02ca2a78abd73ea1f8473583ffc329ca034bfb9d17c459f2ed9bf683ca54c967eb5659973b0588f70f11085dabb35212724fb1c3c225ac62982faa8482a0fc45144f266b8606be22ce891ddeb64f4eb3a606ddce307620696d688c867b3e5c1c536aaf43a08c255db7022665b8293efc9eb76eda6cd4074cf1ce0315001ba7f068107376407ea40d17e523e7917020873cd8849bf803c9a1be260bd4ed9900385bb9f8ffd2af2f051cfb0bd4e5e05810e766bde13d958ff3d2a20349bd7e3f294fad57b5942c49997ebf8c2c80516f2d87c3f931219b8c2e9335fdca277a5ae721694f5f52c6d47015e5d46d813fb377765447022251af46b7fc70627c86bc81ecacf4d93d95efaac25c73806484602fcb1a3b47150f6bbd98f6cf530d426f07eabf8e44358705a5798bc13b6303e5452317c9e52b896f91f624b575f8b7ff9cf32659c339f15a1fd1f30744c249459e6fbfbf088aa9656eb41b855208eeb6756e5f241ea6fbea627a0f46a7fc0aa7396e188c81b72c32b1224a111b200fabdeadcce526a9db99b6c5442ca925f7d08d56fc6c9eb2a580eed5ffd65a82ad7a5204fa894c6a2231aaced3f99be6b2425328fc64ae3a01dcb79ce2bf8ae1616030eb8d6fdd8c7490759de1baf542b4dd2e078b2ca6508b62f69fd09ec3e526e59817a903b9cd2f196fb3ad8d760f2a870d868b7d47e3851e7040c6bbf577a82ec4a58d622d3b7da3383b5ff15e6d79220c048c5e81e369b6e945b964360026f0e6535994ca02e474e1b7e110ffe71368c3eac871a3ae628ca26bd98d3a3bb0ae2828d19a22f646baabf04c48565bcb893d1243eecadb0a69371a1d2a2339eb0d6c4e735dac151ba249261d30005243e6a4335d4651c5b6bca0c4e5bbf743d8fbc9a37ad66e355aec670afa8682987ce8f019a3390da772ce23dfdf2241b3b790ea9be00d1d1cdead09fd153b04fc339cfbb47abfe520be942cfe91cb4d7cd78ba7aec5c2ea4558bc9460b9fe9ad72a907172837a6b22f459378f6d761ec14073ca073f5b0052ff5542da4165ff84ce3cbddbf4639a1b14359559b2c2dbe4c61fd757b1bc01719f90b689db82f7961b946069a18faa828a52d124a24d10c68f57accac3439a4f21923f757560f30bbd4bea46ab35c250baa48f1bbcd2cfddc457fe0e796705c2879bb3dc0912355f3a50fef5c39cbafacf4886e40913620ed333edde845dee8837fe2dfd749789d822470af57fdb76902dc7aba6f769c211a295c4d90aa235ae593251535713055b823f79476a207943793439a5e58df2c8e075344eaedd09aacbbe7738c8456e014652965dce56d4cc1ab8edb2abb807e57a9bacaa0bd0cf87023df4f87ea17c4aad0c78ee587962b90c18630c20d5d7e6fec3906c22cf5bfb8f66d7530f84163241ee1bc1d42372039a61e30a6e6037426ff01bc2f46afe1d2f99cbb24030f8e20f729df4cd1087b2a70c5cdfb15e2953267b54fc00a61bde6ff3d98366cf1b5afcf6e890134773a9b3b634abf3865ac6da91e52ecbab3c46ca5b096ca1acfbb1020772c05c5272f67c1a0df675a205015b7cdbf0a04b3fd044ce9e362496a5245c8f09d829ad0201b4fbb6935c37adb3a42f626243cb51ded6dc2968fefb624f48a31c6d6c8028f0e39108690c9e5bb6c03814a8c223f60eee7134bbba49cb69def355bdee927ccd296175230ee384ac4205fca2639c8844b210fda1d638f8443b147018d704ad2e1f65ffb80402c8f4057fee983da36202d440714f17f93e520136bb287a2c35eaa5b05adb2f109f3b966ba5c7cae9d8a64782e059ede64fea8f5962d5d45f8a05e25712b5cb1386447d1785a25e2579077abe82d102b84dd8ff42f2b4cfa5669bd5b897dc8d9dbbc54f6dc99f58a2adfbc8664298054f35d95113d2b414b68bdba52ddfb0baea656f3ba03d41aa95b33c382af4222c0a6e6eececf4d92ab43ffcbd4da1f113166afe68fdeaded105f1042d55b76a9f19e92a17da979c9166be1f980d2433e684109015eccf331b423dbac4d7c0b91703bad246c959914b03674641b7cde016964ab7abea87a77f8ead72b348a85dd78fa66feb3b65f2481f7b126c2bfddb0a06cb1b813fb2c4d54775d64c1b5e0d94ac5c678d3ace70acf33a784b8f36ac668e8c78fb32418efe04f7aae9aec8c0557bcaa8834e2538398cd734d963c61c70e818b70b957ae2cbd6a241b3e57c15d0d7baa3da8606b662444c41f89e83aad973bef8da2f84d35f3568e64e74f5d38a5e91ff9155851bd2e006f3f5377dcea9db84eda552c13473c60ae068c24bb75c78944e35066eb183e181be1f1de97664db86dbadfb71e7f6c52629962970cf3fc699ea0b1723dee46f16ce8531a0d2b848ac30b7f93657745f7f0cd8a71ac2da84b530251554a58d2704516028e828f4c10faa61c21febfe08e2075c9ecc538cfe5fff32bdffeb88301275014b8921257fb62eb9a6ad42d598a4f977af4691116e101bcb18cf046e1b9fe7ade449911e1dc0c2544973a2e3cef0e8603805904ec7248299bcf79924b15a83f035aef94c134897062ec90c28e0a880ba9eb6fba9f74ca435935122ad52db8a494e1c31d16aa9450cc363b20ddbeaa13be545a8e24f88abfda3ddd02d82b7fb37ea107534249d19e5aead528d8b16fb891ce1f4aefd45beb75b0ea37df86f2bc7cffc9edfc5e59dee79e2180c14e396ed79172e501410985a1aa38e5988d2645168167256a5c907b32902d369ea2776945ac784c891011172ef1dcd6b6d3e6a5fbce7f705fe177e8021a01eb447c976fb24e7168a6b440651451e0ec6f1527e6c8a95d6bfd56b1970ada3d7fc37fafe282b86592be874947a536b723ff212cbb412d1f1e0308abfa5f88daebe1e837f696a7f843aa66b9b937e99bdf5246f2968406a038f37cef29b1052e0b9945bef034bd927c5f50edc947a90572c92bf5ca6559581db284b560ef84efb2e3f20bd5e87805c2126c86adbabfc7fbb4599be580bf1f97249a5e8e29df3b8d546eb3c3b5b665a8a3f3a699e86b9e2765f0b2c48f7693164e3639d449a822d0e37aacaa2cb46990fb767fae0c780b87f762596e083a47abae0f5927908f3888625b56e525d0f90ff847d9338a2e8be7f5736d0238636ffecb1c24a3fcee5aaab67342e301e38bc2531fe70972115ed2569542a33e6eaf72573e2677f425a82dc95319569533bafde3ba2625b2384eee42d0ee019444a64b1667789198609e8bdcc4ddfd4f3533db906ae20c02774918a09f287a5014558b679bb92bb4e26d2b5fb1177384f5ffc293853df99b532ee4b6c8ad294790953433e6042677089b6b0412e3ea35aa7dff04202b3f63a7d7266845627357794f0b242ce912d3f888fe894197db7a19eb25e1a1ece690c2e062a7f55593fd3801e15bbea5e13f8dba800713d5812b48843b684d2652eb25c06ac147efdb1b5102eea5ef56f249b4e1ce78ce794bab43b4cb863bb927b4359e233d0c99826bab36a1d7dfe185eb99d56876ae397b9be56ca30c5751f9565c8f981ccfbd42a2e68afcddf1888b250e83922b7c19b45a491d85b67558ea6dbf4a5156789b0892b8ac116ac1a90a0f58dc7af673b6e9f6fa9069ca3b39069e848e65b3a97f86c8a61f85060aea50ccdbf18a00d1cee560abd9e1fc332be3c3cf8dc7ec2ca9893759be5c5e193d2f0dc9abc7242477e0374dd4d6e984369c004efb3be24f39fb9e8a9eec2f166384e6e39beaf380c2537fd70e2b8ba28e4417ee032e15c85c2825c2673aa2aa2a4d805e2b558cff003f5128793538088beb3a302bf6e80f840575ab45527440673389aebd641d5f8b9160ffec4c234c734ee278dfc9d0de4f496032f5fbb55ee1e6e9ab7db7998625c08ffc1e1818ed4b385cbc9971624daaa039ee71484c9cdc62897aae5806163e917aad46307caf6c434e64da7eb44a03dd1955b5a006bf4c7d322ee14e6ccefd91ada2995f7c5aef17ab20649ae2c6a0d2969e3ce0b444e383591948844700eded8be41b771d449f63a36b8e3dcd111429d13fc46ea7b72f2dfac37e62cebfa86f28b929ae5972c598cef3218b35c67bdfd7f36fd3334eb3fdf2cc958b83e4515424c39e4ab681c3aaa6f23b36fd8d2208065cbcd53a438985e853b6aadbcb2cfed78e5ddea715217db4c07299a573275c256cb28b5001c17ecd7c95fea21069f1d3351578cbfbad68131ccbbad92ef04dbfd8c15f7d8afd4bfad1a7df33dfcd86e03cea9a148105028a97b3af22e674ff6fbdd1df99cc58c9297dd1541ed6861e27f17d80bf9ed55c2f17d74fe889cf09a8c933fb93fe9c024cafd9b8b216bdf6867389db066194225e8f2d7658a2880084c25c5309be0c8110ad93409788b9e14012b83cbbf6b2c8e90faf576ab489e17c5adcef13a29e524a0e62bc8f2cc86eee9d6ff11b5cf58d226d509c7a3f67768a651d88b73502ecd6bbccd1bd7a48ae90989bf5fcfc016ef6243f697fd0a4a11ca8d7a651ed9f2b24362340d1de4622db7d876390d6ecf43bd7418c970fe6dd93afbf89fb0333bc4c45fcd283e8690366efa0143070f36b18168c89a24a03d2f5cb53a53dd9b9a27a0b9ca509087f7f36f4c5182b33035c290d9373ea20c1cf87c8be25a8bb0e478b81e46fda1aa9155e01b91d51f3c20abe00076780db92f8e36aeaa851d70d34312ddf50a20957a15756088e0e79853698dc08a2bd68129215ed56f5732531738c9982213ba35b09e81715b2becf803d504a9156fe43dbf62cce4c7161384f96d634abd09f7baf298bff5be08ea43662affbe54d8c1c9f1a3798b47ddf1dd72bbf6f5404e44767e6fa91a3c9e551b97579ddc86def2bfc2b6e6f254bc027d5a3550e9f32d5573f27699b309d6d7229681c0feb26e9433185b7d617f813da890440605db4c60421144c3ed040bc88ea8d4040b9ec3f6921dc37aabf990376dc59c787bd653d7b5d57c5f044c3d3b6e6e50999ace29d13dd628517af3763c431e7082d392df347f24b9ac172568bfe3c949e18908fc2cb6325189e5d2e5a19f55177d67f394f7779d4991a8f5daefbca9cabb1744a61152bb6877efa92183b33ba7c6a787045eecb0f703b5835e477f46db1c37277a1bd252a50d65826febfd4e8e62a6802376944fda160f42b2a82cce57394cf5dd016741d23285ba1f19104eb578a3f8f2da0966be220f363da2749caac5c016e78f247d0ba19cef814bbe9d135be56d696bff5c521b1cd40886fdeb85e96dbb15427189361d81d9e4a88840c839b5f10aacd70a9471932604cdff49d20f8f38d76b14b19557a2244a8d5061d89141d41fb6bd552ebc5f0aa95f92e3ec7c01426585c5978520c0099678c3597db29b5185715a2b6b7766618e7f36f2b3b45a071f2033712bdc2b1c06e891147f3f87ce58bf2dbaa5eee9e34db0c6ac36891dc1f2442cb3726a19d285f46ac807954e0a4d25aacddee3d66ade103d60968e06ea2286aa8502c7c68b6bee0b419fe5a8e3df6819bd7438dd387e1e25e842538eab4fb88cc6975a7baa5cda21d9347ae693362ab2f3e3e0ef76b06a6f6eacb3b05a44843c3052683d2a7182efe01a97519f682a67d90dff3d95fedb0e8cfeaacefa24ed75144e382c1b463566e7469e800e4ded48eeb51e91822b397f4736b6ed8af44627d1fe50fcb7e1f6714391b33e0515deb012801485cee7fee54f2dd1030078aa453b65e19da3c86a42488bc619b4f233b7dca2c26f800988ff9a214ca0ed4fdf6a9c9002c5b554685395961d4cb62cc3ea332a0ed9e50f7b44c82753956ae8479e6a9dfadd1c5e09982355a50fd969765f9f7414e8598c51926bc62b3023f6f657c518b934e00027349b28cb3aada77543774529dc57c155bee4e8131beb6f4cc31e230ebd2cf6ba69ef6e25ab42010516fd97630fd84d750b4548f92643f7e265f0851ddb917fa12b2282bc27369a77471977f6f157adc48a537b7bce3413785f3edcac1b949f43319bf8a7e642dcc1bc788ef80e611a708fd0c7c4cb1bb3486ae5e5e8e94c9772bf860b1d27066e4a3e1f3ae5c955fda7ded10c017d32adeb4a67446dc42d597fd129138c98c78db444f4c013fa9cce3cb36102de9335822ffec289ce5cb13cb466d76377cfdd9bae123d8952b2ec3315b74ec38d288ac3652ee1859dbf8f9af68618aade12ab5179b794eb9acf198deb42960699d0dfbefa3e0ef0d05aa1a535d5b77be2ace33f821dac8ad10b1eb1987ecf6057f0b39e4f8af4286c9bba0e50e884dfc7812fe7c19022090dd198d6cd7b2fc3f786e22107b79445ae0ce7df91710da11c701cb7791db2682cfdb2cc8db3a1718b413bae8a75a3dfc8c535e86af66c24dc0836e3bfbb77efbed70277d4ca5fb213746699682ad89fdf116603765aab72848f6f05c9077ccc334ae082995de6fb3ab5e76e7f11c3a65b21429796d6b42f02dd23a5c5b7607cbc0b296f31d80e379451bb6139d7f0a1aa4384590d6d70392dab0b29c5a3f35edaa10d3e8a6933892c94b344099e9acd13b50b8226d9b50d0a10e927dd096af3d808d81f59538f1d7aa368180d4005df9582f702ad67b3a7eb6e377ce412aee843fa75ef10766480cdb765a74c16d45b433e709cd7b7d861ac713ed6df12eba5773b6b96e152fddeed7490de618571f10c6dc8dadce6fa79f7a734896ef9ed0465f15b8a946ebefec1c32553e450bf3017959c3a6ccd0f2c6f5eecace16487bfe773765bac57688966691407be89a848ce971b86e048002c04d9cd4286c1e2bf041697eaa844f7289a017dd299403bf0348b1c57ce78869ef52945b211317068be3ff7361ff21bca8609e2da34ead577f7bb79681693808c654d7e3de933d8d817f233ab05e7e8b40b6712c64c4217ab96cc0cef0e2d92e723a1433df3fdb64edc52bac86fd5e25c9616d8723cabfa0fc9c59b7b17e629208ee4d9f36bdd72d2484b0edc783768d6f2a10c30e13e89842680ec0ad4422a2586e6ebec35279c2c1b197bef983e54de232b76741e64f76d3a67405464f5ce3a07126f870e8d5dfa8224411fbb63014367edfc3a627ccec2b0b64c1c0ede4ffdbf0187300e01f07c09053893209faf69c77e3fb9b269b98a942cc778e45bdc97770be711c6dd0b6d072446192cf58c327feabeaeaba8cd9ee8418c24279fc3371cce1abe47e745b0c24b29b09b5258b4cab473e58dd3b9edf63af021a49f004d8aa826d7e7b10d7b36785ae7a39cc7da631e42e216f5f86385f73f801a840b99e3a82cf80fea271134b39cfce64715dbae519ffc19efb223fad0f2da1af2a2b92d3dbb1f140f4fdb3bd9c92dbd31ae44c883370d04a4bc5087783ce4c190ed2bee3259f2ffe0f8dc017e4f96d343a2aee9dacf3190a1c4bf9125bae549e1983c0b434188c3e22e81f5ae6070e9516f25f50c8942db3cf7d4212137d506ab37f68b7341372d71d4f05148c99f5b5459af580fe9fd842b1ca793c378ca5a84992d54b07de9235f5640abb9f779ade5337cbcfa3fb6c9de2dde66a841df4e7f88861f10ef88a3f0bd0d79f40251f657bdc68660227a4e69bccc870244e9a6396dd4d6a93db3894d8282449bb0d9f9c48afcde120b2eef77ac6bf82c5fcfb5222989fde7745ba354c1724c7c6be912e3a659ea4076f9c009a59d8ede90255c1daa88d2114944ecc2ddae008156259a45095ac03dd3f709594412f9a2a5268fc3c98ab6ba931689bb2f025d84b23a95685e3052e729a5ff380897f60078c28edcae3f49d25064eb915ce5c422926d4a0ce7ce657700f541dd635b752ba17bdfe75d4ea9f145b81aad07cfe73721f72610aafd3927fb5083bcbfa8c8493ffbbeeec396f051aa1930b4dd4439a203fa7efbc372fe1537b5d2234a7cadcc051c6e76ecb175bdbc46b374aa8094d40f1ec1f573606007066c5d376eea5443832ac539f965cfe4554b995c638ad7def410485f35d28bafb693db578dacb4e771766a6b2d9cde0b530b493b11988dccebb4f39d4dfd2ad74dbe5a4274ef3b859baf0abb1f208acae8b317229922d2a159b70dae7bc2b93399bcabade373c729fd3625fd7d6f9f2f52969c813b0ea05100396477b9027779ed3fd59292bd40323f0c56e2d8e7a299a8d8f841650df7eb8f33746cf749c6728db929cd19426f62bfde00ab526473d15019ce3134fd00db2dd23c4f639e8a9c6104e6480b58a32ba15b0710d7a2fb3a1d515d84bc19fd4fc5c247b65b8f41aa87ab806a615828fe203f58ceac5f626f645a62994d44cc6a33d1c6a6b40c4c16dcd062e769d19220230b20e2ccdfa2f0840699ee589dae49b2659a2f80460736167c77476ffc5aad1269996a5d704594394aaa64c9dfa4e70c7768a93a0a0f6b0834d6351fc7bfd0a8ea6e80ab2811b29e9cb2315079569456dfe7b8f7b69016b4369d30b506055c009b3d523e52b93b042be88d342b04fe42a1382a261a010185cf68e8e0a876fdfdcbfc83dba91e0e11a28952c6222ef476562d73acc21c9d6287e9e2c995f6e0e43e358c764695ca5182562547e516b585a3ae309f5d5924e5a1fca087ae20ae4f8a203b9b0872b6fd6ba4e51807ceea07bf668b1a3caf740fe223b46dde1594c1e27e79c9f66d98ded0c649ea726162f1af1b6f3e7a2d065b13d0c35e82091548df77df209090e6be814a1ed353a675695b78522f597f5a2fe868fc59907434f2398d6d750825e656338c7bda73bbb4afe6ededdad6d0cd08e18cf080e7cea47de86a3e8a563b2ba398408f1f722a72fc052ab1b0e3af45e1660a87914d9d134afd2b50e92e28d10f8954d9466def0a045ac325c90d8630a9e1813eb0a11ba075e6d42cf9c888390a18977f0b47573e713506068b011b179649811cb3b2d24e4ce7f3156ceff3a468c05c3f139cb7d8201d137bc5cdc9fc96a03844802f2473ea5848648f837a9ea84a05ae841a4bbef2d14191ce9987cbc5cc0377e2fb52cba2aed4c7641e5e5e4420d42a8752d9ea440f09b803b2a19f5142208a7a855996c3c52a4210ff2c52f5613205a1fdb68f45e87f7ea6e622f2f4a7ba297a5bd24e0127b7439a4703514def73eb1005fbd61de19546ba3582e1ded7007ec01fe258ec0d156d26727e49c04a2847975a17144359ea4fe8139780e53c73cc0677431066a3bb26beaf36b96dfecca4b9f8927ab5a42d57405421357f994237fbc8203da5b5d13e3383b61fb79ae44b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
