<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f8a75c91628ce38b395189db87dd67cbf7cbc3232b9fabf59409aef8929e3643427507f13c1af3fc2eacd26fe90073b3cda13bf4ba98d39abc6df40193c4fcb5ce4cf84c8f178ce020a5fb50adfd2b8a218170d08fca56b7334e8a9daf8fdcadd4f3cb051e10b2c779637db9d075addb728226f571b48e2842854af9800903b4e16ed8d45cba18de131fc475e545a553b28cfeba10663e88bd7b3e6384232b8fa2f341f97035b809e4a77d59aca70622551b53aa1d31162c87b81f02e70404bdf55da7bd1c32593bb9c39cfb914dcca9e9b35341afaea9621f16c1fc2167dd27b3358fecef9d41ebee28dcdc75f6c1f9139ee9cfc2c9fef2181bfe4c05c64e5bf35745a1c95f195d7ccac357d692ddb173b5c1407a362db0f15cf0f2e60182ff7ff881d92d906b56fd5bf3f195dd09269a1a849e97a39a8ff894cc9b15e56f99c7ee7f40305d4d5f83d8eb8c4dca788c14154d639e58ffe1c6e16aea3d311430d7786082c5d88bc77381e4b647ce75e29be316112a411c4e0b30343d08d7ac02fd2b948fdfb856a561f37cdc984a23d85b69f18f7299136558606afc77b297ff3da619073a7393005550cd27a55a1c820772d4cf4c19758466292e12559e7b6ac2dbe0e931ab292ef16358bedec6c0c9514ae82009dca57c99ea5c5149077d4872fa44e6675e77053bd7211ff7f096628764d0cfcf3ae9287c8a850c49e35f910ea1e25bf7f4836eed9bef8b1ad1e6b199b8e2f507c82c8c2c197d881c2424eee98fb8dac7496a30cb3ab93e868748a5f281ad75c9c64b6153c75cae89472fbdf90f0f5ec2345353bc4cca13c11e09a66842a6c32203969ec050c772262206444408edc5f8d07eca0b1b086acf2fbc90bc3daaa808f2eed08dd7840a7f24f1019045df174db6a15f192fab402113dcace27aee630e1b6f675636547fc2be9f81f8645ca25191dc86917b6d66754d12d9c3d31c723fd37db6dd05079b8a64cf51cd1bcde266b550b4a734788b9d9f6c3842600ced235b2747a85ae98c6a8f9a36d9eedd76b40e85e6c70a8bf5a4650aa6b18689d184a7f95fa876f0961d0ea45e6758c18916c5a0bbf332faaf8e94d920750b89bd3907803bc3defb6b33ea2851d9aa0b401e531f2ffb4711f3cee259452fbfc2b70508f69a8f0c5ecfb5f8d020774a2821c6b96b88d172952bfa575d568150ebdf06bfe477ef05028333634851e571146e03f534975d38511de2e8ce559e8e0e87d78f0e57eb7d55f164ff86957570abcce55fbb60ff0b47c6dd66dceabdeed03ad45f7aef4c723b0de259620b5bdc0e5c831ea607e5cb0b39a0ebf7ae6ad7b9e7507a5c679e97c38ce2473e2903d95bcd4fc9ba85c0dd0e285f26caf3af5f016ac12f310047a5198fb7888526d0109490d7cac8e7f19d7f3cff87229fe0331648861f6cce4b989e983a716a108a238dac4a6b13b5dec63540eff1eda29faa7b9ac2979e3009fc7f303aa430436e55de70102b0aec4e963c01e9cac64ebcddd41d90942433f190b4503cc8eaaff2641258e433a227d9aed53960c7478a068c7918c296832e538576da3773c535c000ad4cdedd6e37334f5581d3e34cd5b87d0b129af2833fb406bd7a44303468d6b7f0a177eb48cf53ad0674446e956a949ff7b16202b402977fe58540ebebe38cde8442b5b2aaf66038ff91dcc549c2d0970936eece29ae33b0b13eb8d9eb6992134e71189a2d9264fdc98a6b11a35b28cf74e8b9f9fb989d1ce712d0731efd124d1ee67e8c69747c0e5082cdd139f157d6f7292bc388cb2603415872b7dd3b6a9c921e7b88d0c0a3662ff3e9d2bc4db60b8396f634d6b1156a96c56004ee3c46e62cfdfb7ab4e6efc1431893b42d1f8c71ab3e7d3952a494ccdc8489c82b0483365aa6eeed634f2e9614081a8e9d2cfc81dc0bfcb7034d35be93aac0111c36e7f5153694d07481d49366a2dc9a15f73d6cf1343bdf4ac9788a2dd36f40f126a1709701bfa5aed94878960a91883b4fb4b60ef328aae17b75da50efabaa24bc83a33e5ec59e5858a0c01bb89e126fdbdc3eaffb3cbb4c139a01a997ff73b4967a97327a8eb4da4fa5cdc95d25dc4e002ac6960d8036423bbbf84c1ca4055caf14aa9ee6a66e7dbdf86527f61615831294ee48bc5f9cfb040b6e544d6304b02adaed9391c66499c3a8d87548ae59d5fbc064ec2e666343acf7b7c410d6e9d5b092f343ff33f839b99558eb0889d1b55c73c9fa4ea0fa93886a7847bf052c84277c67c8737b3401a558129deb8cf182ac08efbb8bef1f4eccb1915f8ed57b21853eec1fc68196b90f9c4b840747c9582567981d5830c2ccb6417ce0d8508eaa9db01c36d15129b7a8fb42eafd95382b93780e7cf23e2a6728d2f285e51bc685883e731a32054e3ff97c5de382f23a3555cba421bb0e7cfeea3a658ca6648e5f9d6f08775f77398dcf41226ca812844b2fd681d3d90f94db8ab32de025eca81d0b7fb1cea634242ddde8a1ac01add5b4797aa0239e28d2dcd5cec5fc37ef0373a61f383b7b633b950968c390cc40d6811fca485cbf6d52ea149d1864e62158898d8c8121ed811bca87d9284dac72a713ba5a808eef0b087ff8bdfcb149e2bb2012b4d770e942cb3579adbacd6dc3209a78aec172d46355357f226ce818a0bee5a330fccce6e0d5e9cce8cf0810c4a70d2516a684a78ceb67f7fa72987e4ef49f05310ba650c0a311f85606193d69311816719a394fe9bd201c0270853b20fe4f1e90e01273807e378ecf88589b5a568de83b8fc60524dfaa5c81e43e4cee04f8c41e784e9f411be263963a0478483f5f47b264d0c8ff5ba5254d583fc495e7fdf04e68305cf3202f5c7e20c0b6cc81e0fe9da846d2afcf1df931e03ef1f160c99bed98b86e0ab0ee1c36c1f78a3f2da294f3d2fabb372f178536dcbb97ce65c1ccc0dec6c8b342c0a6f83319073334b2780190a8d9be454e433381c530b03faa2185636f69f87a11a9d8d5be923a50dbd1d9a0afbe6461de4422a079dcc03782e5ca75354a519a5b624d6490271e98e8a687981295490fe85e9d5bdd2a399987d1939b1dbb16a3b928eb2208d86ed2e3db32bec40014f65e7418d993027137aacf3122e3f96685177963935999aeb7edd2ca3a6035642ea02c6b991d754650da64ade89c8ccff5ae9f3ae4c1c352f10ce4cd7987d788f05e5e3b1bb29fed14ff1a76cd5934d22f9a05c7e1880cb8d5bc987c54d914691e0ccdbfcef132c4158e16c1c15296cf53fa4a3c5b8a48413d4d1174388e529a1feb82359845e33e9538f92b519941b2db8ed87c795991e49391a0dde71b3258f0b3a066fde7019c4afe4ec96d03ebc0ee6df6efb770f15848a8eb569f038f7042d4a942f2e92e4c1e309c52b6a74521961abb6562b56732173f3541670c16cdafab468aefb624c87ed60e1d5452933de8a55be9992f62b8e1c6b9b39fa5c2914859d251cc5a1ccee03dd4dcfeebdea52c44f52e0858b8c831ae9421ac104c6fe10d068ee0e56aa871e7ad3520a69753babf9c23c42bd469e11818bb93f748ffcc74068e99835099443e1fed0f562c1e4d56d71c2ac3e3071c372cf61b380e89bc5251e745b3407510c4242b80b7d55c3fbf3fdb556f4ee48686944afe7778935f7d18130d45bcc80cd17c77aa33c1aca1166257f206c24086414af36df0dab532990de8b1bac56d536a3aa7d90ede7029f27f39983a60898d0d0e1d84e23ca59195b6a116948f5bfa294b4d8519fa6b226e189afb2f6962fd0b9086cfc88add2af606d69204624e3d484cddaf82e29cac629a35768c8bfd2e4ae9ce96938d9b75a26f7eb14c5472e2fab41b7ad792da606dbc4ebf69594657fa399a2afcfff389d54237ae4151d72b82fcbb99446d6e3a9aef7140ffdaa749f2b0aa8fd158abf5510bcd3112d4f56d6cccfce12af91863157fb423edf9f44a2e9e465960117f6126141af0d4dd2016029f5a6e48d8cf2d85ea553ac99fe8ba1b6347fbdc6784e42148e178fb28d34232fcb89211590388424b97e389872ff05d85ee7d4570333bee8b05bae7e2c93def4eadcdc68e42cba3772cadfffa0a1c51714a8b0652ae6b951dd9f96e53e08f442a4cb212c736eab14c37bc482d58f7cc864e787d78ac1765f98c101370a7ce65b4d64c15872732670dc98979ae4a1c4f3434d980179a203c6a638d63d2215d3427a6976b54f6b570aa80940d1195d0f498acdef1c831144df157d036492fce41ea9a1d62ef89d850fafd1e2b6fe27d5234e7f75b4d8e9449a4f80a75d7bb694a55effa9cb5e62a6ff2a021ce8c0c81eac202dc920f48e9264e8bf9c46744e06e926001266649418d936d8e7dd51ef3233d9b2c85b16188625ee7c38d1afeca9dfc93ba5172217b1920f0b911d9abdc828a065490a232a7c1a25f75dffd8d4199907a898ee7fd3a34d8ae184a105427fb4d67416787a213ae615286dcddd29e18d3ccb4ee2f3d0a336c9a472f5e2998de41cd5ca50c8540e2382203e900e496fb3ee4261ecb930bc6038a8f72126d4e48212171eb0792fa95b820b77f1c9d40fa0da438f3f8b4dad012fcfee9792d614d592abef8aacc8ba11a1647fcdff6fb2d75bde43e3e2d5c35138bea7e9e7ffd4f2d955055c16ef3455d87e0931f673b0d0613a777172764aeccc5072042ae7f206ee1847de3fa10d1f4bd0356ccc9f59ebb376a84bb38f4f05619c31b5ffdd66e4aca4b78259a0200d9c944416921d351c6a79a22e1b19052381d6b6f259f4868b3e5270111af7396d8f44bc7a82df86ddeaa27f72488c20a913ad5cf9b23158712bd81b4c21ae27a67b460dbf946d8aba22a67000c3003251f8cdf842f1c20a8735186a702ef71136f82dcdf2a1b1b56d149648f4173e0d9ee55b0a723854126d6678eeab449018534a5afae37f25f2462978a7488a25e1995ab676ffb668cda8e141b8ecd62f8c828b3b4c63e2f1eb73c4c4ab2d5c21adf878087c796b39b7c49e878bd3b8feff673624fd19a4e8ae59fcdf9b8c1204f6d0c92044a643a6eca74fcd0380f997ccbf78daa063890adb5a9d2ed3b06c50068a2a6cc7a09714a3c48300e746df70268af5557be9ae935cfea53bb0b0d12ef642cfe766b8bfdc8feca8250b78bb44747a0096d3bffc76a45f647a1b7d7c81fe392b7ed2ac92c357ea6b21f59829af42fd5c6d01f560d2d5366647b704c6348e3d5ed0bddb22a0cacc3d9ed2cde9cc4873ec27bacbbe14b679579807d561c309b95cdef068dfd145eafb8093c067e4e5c60f8f0482f6cf3aefff17f00a4efd3eb8e8b628093dfd68b206dea352c5ca5827e2b3adf6535aace13898129385005791d601a0d081191559444b8857902dc95deba5433484446809dfaefffd43dc2a5ff06cfc7ae8b7cffbde9f0705b62ddb80c5cddd10eaa48ff92595770519a5b99c608ba0e835f9a5255987d29c090d5defcccd97d4271e62349120edea07dbf9628e86b948c4c7fbf51599dd82c2cea488cc259a2c3f4d7520ca7f1b6e43cc73bd673bb21a013e6a584823a5c5a0aa65aa240c8c38780fa07974738b8a827aa7ded11b53538fc62ac5451433efcc963c2b78ec1646e5835d2e8c79f2d6276f01c7697d322a57665bb52fa978157c00c5b8f594bf35967b1f4a621aac83b3558492425681e5a954ffd635cce8c9cdd869319daf2a4b7c13c30e7f8a5fd7a09d52f7941a52a94dfee7cd1f232bb129a7d664359666d8db576631b2b882abf76efd5c52427cfad4c7469edb08f5bd7107ed5b1dcc9e9591c8c6787bedf4cacee27335a47ce87ebd52ad08862c592b5244312314b9b63b55e05c11079e204931ea96c54cb08931095a2cfef7d2ee7590a3808aeaa52d171c1e41f0a6de7703c3091145b483362b754d45733aaad970a9dfd1f50b27bb6bfba66088ca161928c76fe005bb0de0eaac6be01b4239cb05c978547e6d116c6ab922adbcff1acf9eb191d41dd36952ededc879fbee4fd2230c0742f232cb6b351fcff9ebc0129adc31cdd0f6b355930a9838ad8062f4a2ad011312e600361a292e049cf603890b96cecd2753f5c9591b98aa244758a3b0545e2b456f90a9bfd5a0b7dbaf55b420c7aea0f46b8d67d9f7acb1f3cf5ca0c6fe0922004ba1c44ac3fc593e4fa1abab7df7070ed34d6bca0e6c334847dc458090f36dd93635542ac8e553e8284738010fb0a2edaca072611dcc13d9f572632df87fa3d298f727af8dba6663f3556ffccae50a5958bcf024b6322f4c6035f11e298aedbcc9f6e0fd99fda30b5aae40a4486f54dd7b1c0684b6de9f3182d8d37f24fd01f6b99ba620201c1d910552ee33fd5b75e5b9a18d94a5434ebaed004a0cc4c42a31ac674be30b09cc614945a9ef4851e0fdca86174f4d96eeaee0ac87c4a61fe4210c2e858789b518285d7a1fa118c52b445d98802e8013839c4f4d9586b9b7741aa497f223df5e0b3d810837e2d50db6806796e462bc4e9467ab2e412901541e4c4ade29456334869361358fe33dc4558c0b8084f83eab498823cf30be03775828be5d6ada382fb518d6229cb9c658b19ee167201de73aa8821d9b635dafb05fb869c12ee22c0a2504a87b6c7ddb897738b96464120afaadf87345944eb21a462307da74d2866580eed9b032fc78e1d3e99eaacaf21000cf5c05b2c7a8d0bc4202db92c00d71cb74b939f72c8fa89334083d993278ac86ca7e1a1f4998ea6e87e8e5d6e921a346e1ce81a3c5fd7ff859a7b8cb9ce63aa45b37060f6e62c1478fe6f2d737a8137403edcd37fee2da18c8d78e2b86eca46430d91343fc424cf427ae2ad1c08562adf18c0e0dfae157fd5fcf3cc9802c6c37bf3ad3b0588ff7e46bcde439f170a8b679771da78bc83e335757d4430bd24a2f06f04cc09c8c504bfd8404a5d69ae658786b78e2641f18fdf25202451a15ac206185bf417b4330c3fc6b7f5e195162598d0cab6c74bfb975d2da3e3ea09f49be706915dc6e4c59add8b68d534db63bf3b442080900a7ec8723b41ba976483b71a2a1e463b59ec2e68b74fb8e980d8fc2b08bb6cbd204267b49a6a812997b8e2de349cf7a81b1f1bdd875fdec9724ada8568b555b704858cc793866711127f9f8e071ba500d50b55124de80e1dcf96b95bb6ca84e1b6cc083e7de4d2390d7fc80a8c8fec1efb32731baf5ee5b87c56234c22c0ffe871c822fb6f97eb07dde660f7dc0aecd2c29137dee12114749212b6f3d96793cb5580dc4ab8adbb998b0bf85b40ad8ae0cca776b96830a41ee27d38bb19813869794cf49b888a40961a0124d957709f4475835c059b23d2d8c6ce57ffab6f783429e6ad6d51a4ac2177bc1632a711652b3b385215052b67fb095e380a0793e7fd7c6af5e448b4dfa6a7b357a4ab84d2a51488e1901d8cc61705f422938b155e80b6726b9ee968267c7d3e1a72cd8d97870ee6c9470503c9e822656f08d778cb4fe0de67fede933ad553f198511ac1217e9ac5df8f93d3a5d5bc7ca2daa077538a2a769b6f006db7a459fb55870f285bd865919551dbde6d475edd0fb5d0d4ec9f9077a0f847890faaee1375cdd426b2871133c005c7d75780070787253b8907323fa6539cedbf6031f06fa350966cab970a792f5d3692a9535c64090477f1df3c2d35fb6d536b88f4f9aa37f9fbc262575b14ca8d1f48292fe7345110433ba9781ad053960c4de8713c2af6797b0de25e5e6ce575ad01bbb1d5712551a19383b8350a1351efe6d70c5f4f2a520a37bfa46a6e3289dbaf021d396c087b310bfc566e9929717d5a4820ad3fe9ee69924258facc0529532fe23098ea90a3463f9bd00091aedda3b1b080af8e097a90e960662068b228680420771662c3559a45997babb1357fea809bafa86110ab0be0304b5015b4255f9a21c6393104c24f1e8620c5a3b47e987197eff33b7fb2973026f8e7cf197eaf57c0a8def2cfe6f082a4e65cd4e179aa111c0a697f8cc039363164b6105cc5058ec8ca29ff31d79de99488ba6b131774faeb49993df98a36dca7a3ff9b6a8077a6178399b231db8c984b00c9d7bc8537c6b5f70f04229c0a25e6ec1e2996898fa1d8dd95d381976711862172e20873d99afda66958c571b6812f01841efb5266997370651748a27615f62dd1243d1020afb3e765753dcb0c38533cfd763a19b9c5fb924b8793b26c2b8f26b0868d9a347a321783afa4e801237c24fc0f200473731f18b2b26b56d9b61d1a46938ad850662f9492df7d7c636da62329bdb1e0bff1acd3467190d69e9ef04f5522efbe2a1e89f18ccaf520d00bf82afd155f04964a8c8b0e5ab36f65185130363353e0299c60c7c720cf148a9baf5d32dba2dbbf48f735a4f7b389326a0e0ca62e53383a0b9c941a83a7f9576973bae365ffb82aa4c7ce77ce60a17b3a4fd6aa198d9da9c2f50cc67e08f0900d4865fc9b6bb49293177daf49541f32723fcd28354d2bf967409b7781d83f4cff46e4e9561f72076d5afb043e764ce03dd000609a237497adf626f0b41c06b6a6dbb62eaf8a65d43d8438604ced30ef8528eb315573f12747d518a6316041eff2e327481064250104a1e5a6b6ad48b3d4e3aefdf4d79bddb43afed382814166a0cfa48b1316599af578949362a170cd2a0b728005e64087a9b5c2c772c2ef2216e35ac805d3206fdd6100adc4439f561efa16b55247cd6e94b3fb2355b51f7c67eeb489355cba74c13528b11dd7d70c246de18a9fa29b0f824f5178a6e344cc26932f4e9f5dace89c9237cbbea56357b61cc947fe93e47af45f69bd9355a36cb802ccc105fbcf150aaae876b3b2bc13cf8a9448d7cdd47aba108885e36601d8c774b08e2136ac34804446ba7cd73c814ce6e0d0accbc4670b2d6be3497c506c277c748426af5a5839e699e69ba504b9f769d6f22f4c647d4ffe812e78feb10c5a1fd6ef6eb06638a564d2dbd069ec7996e444f713bc04577888e48d47c39820f310d7f065c2f26d14c67df2ea23e819a2f1826cd0c9e24a6cc552c864fca009bef50f799d13290634ee004df63342332aaecae4887da53b89cb3e1b17f19433e4c99240ecb8b1a1e01d07a9b09376b939bec7cfbeb04622021b53383e70f0cae20ae75e7b585eaa551bed44657138dac8e8d5b48741381a868459b67345a38df11509a1287a4cab7b8c2003906a7b6f254695c549b28746ad6bbc002a77d5a8394f5749416253650967c6c05ccb70424e8986c5c8901127db2af40b52a8890f8edf3e4a92910c6982c766886f995604685afa98a012fa8266d55ccc0a9250bcca8b98c441fdb797db3db8c94507855df77ce9c3fe56cf3c6919cdf215bbede3e1d464b850779f607bedf32deb0b7ec1cf501395bfa2c0a22883bac34fdc363f0b89f36b7aac4b16a6fbc5a857cae7861c839d737524acafba3a48174b748bb42adf601f245a11a71197f31d477e5cd607270b4a079dfe26feaef8503f5dad99765504a3fea3d582d7845ab9b131b5cae32a0004c0b427fcda71d9072308a8dfeee54236af1576a15d4f9d1c0341014b447bc46df2786ea61d7bbb9d6671ef2ab9e6b00876c89caeb95e1fc4424634af02891c5a54e1751bfe17d7292574264e495dd4c51025372d3de0481537774e21b75f3a1863206a2b2e9843bf18eaa3aad14cb50e9856e4aade30ef8bde2b5f486a85bcea411b4bc31198114f5994d34113c95f65e392c71cd7fa7b8e572ce6c037399c012235a2524a32d275f3c70b36b15d479746b8e8d306ba2a7588c52b72d5102fdaebe593b553a84459c00f490d305f358c746b57eb5fad84761b77fc4aa88704d4ddd71234f152e79006f976bc0831f26f75e772513d207da01292e2702843c093610ce34bcc068ea2b1cf9bf54a08c7e582c308f221001439073957e3d99194e6adcb92fc2e70fe936f5aab7de3232bcfd38b5bb0447edf3f9aa334a6f54c0e9049dff269bf1207df6a898dbe693c3a285d56ecd76d7136e65256728a59bb7d57264da3142eb5e5bff426a8b05a1688b80ca9c52900b6023539f71db2efa06e8c23276f271601bc0bc44ddc6ff52e96e7d63e32bff3709821628e89a22d345bfe4b6666d567825ed72255e990de2d079a181290d7aa98d25c2b11ccb0e6cf35b1568ee457ff4c1b3ee3151a7e5a687831062983f423828809b5ccbbc5566f07a888a0a67808cbb34a3805b953580ffd724ff7ab7ca31859447176399f8a64c9bc1bfc01e99d4f5a4d2e1f8cc235ed6e88cee944f803162506a1151dd62a5dabc89fc8eda6dbc0a8580810c603901e0538209fec79d8497794d55669dbe640200c88779d66369b2f670dedf848c71af55f353cc5364b135f79373672c61c9ee50018a4f5ba2d1677c06f137f1d4ef6faa2185e59bb449810f113640fcf3e95f5d872f7e7cbcd2f37928121e9cc0d6b1d809a4d6d645a962c8a6dca5c18700e831177b6cfcea2a4f08ec1baf36b91c1a60fc1ff5eeb8c2be36e0962901c7665838deecbe8aaebc9d2cdfc3d436b82adc83b7fa5e1d34c3b8dbb78c3ce87b3cb81b515af8d428e3946ea70144a485daa99639ae3632bdc74a5bc469706f12e5d2d3ef4ee82e8046f908e588b343e756345d2e413d5bcf2b01f18f48b7c5058fefbe0edf8f8ca9ef732dfcf3c4a88d49d39724b88d2671208e658ef6de8b590155633e72b67e7d94c9a2cbd4d05889345b3ee950124daba8be4ea6dfab71c328465787137be2da09c67683cf63b69babe056daf74e73e2030e2ed8a09637b29329fd903c723bb75703b71542068c625b85947a3518f321cc7d9c874e6959ee74bd45f809a1321ac369505a9b1e96e62701534508b5524cf21897cc9f123f8a6210cf3881ed905f3fda3c702f8e5d4664e011f450508a3018c8494b263f358f83220574e75812ceea457c43cd2a4e7a5d0fea85ad4aacb868f66c9543a4208c26a931c07a870f6285cc5c440684ea580f1075129163b154c05600eb289dd614b69bbc5bf9cd766bb6b798891e01a19a07c2720c5b01c38afd3e8c409184769cab91baf0095a252e6dde8807aafe1e08e33c870b77bd238d0a63a6fe8b3966e89369af0fc7c059b70d05c64888ac618c904917685e7e90cd962a29bfe58e03788f65c871bc70e4bdb55ea3d6debc936d8fed6621fd181e162a56535d6e1090c014d0bbfdab3b0eb0de39414c6001df46a39b004a1d49bdfbdf7155fd6ceb333b264b8fb7435fbdf00c4d112fe6811ea176b0e2635c88fcb716c8972ca46f5eea81c51fc8f5e262a71c949016f8d0ea94f6f8bf7c129c8d3cc23e3474f69ae3c05a992c353274b728abb94695de506402c432aab0f6d1f579f31875a0f85f42f3fcd67471be4f50bac95215e6b6d6c2d903c488d8d1fc58fc75c269948e1fbb4fcff16ab09114512604d9cd0528985d78f7bbe6f68f7ff037826d8f1e0f6c9908d892aff1da26cf53b01c851f8b2642d2f808197891faf0adf3b5f2f456d35701b542f53dc68e52301f835f23d0c9c562f1d648cbf680a92d8d9395eae3c54b4424d2f7d86f3c21ee20bac2e303af95a15bb5b6dbd124ac0eb8761df052e3c1150a14118977ff18a8e7b1cc47222cbeb1c95fb9ce98ad89d80240a02778263e4ace9e02d5185b6a7a7be807e8d45b5447fa5302951f470716d348198546d46ad15b6ce97387c070dd4be68ef8a656064dcc874bf3eb585911c751a1f2ca1084939f44d86f9765ca256813bebc1d9eed7c00a14ceac9643261e01c8b75d56ea1338bc98f489d0e92d81bd9b6495bb2fc60a0ee2bcea3a20595c3d7d2f558a37f87a7731df987599ad08aec5b8ebc6efcb59fe8b3b1708e816159a93dfb4d371c7d93555417a8eef93045b3292914ab4379b73dd220e7e7f0de424d5341852c3a222b0842c0705657c2c911a7fa3b83a3b10a0cf1e7f8cd15eb9ba27f031a810994d0717665b8a18c70cf12664db5df3c21b7ffed84742df9aba807e85ad54b23cf98090213dcc14afaaa99ed696c9ef3fdcd4fb21096c5e8bb04f8a3742908bb143a85234b55452f9e49774de804ca15e3cd0c7447eb7b8ca3b1c75168006699f7b8d07328e7824abfe8819f62ef62fdef2297e93676aabf102890bd49f1c74cd9d0e4b55ddacce6a2104bacb95b630dc165fe9eac8813a195763b00aa5d66e75fbc6ac0f5b13826b839a39706f716a0d057c3291da33885d8f6d176120c4d24c412db63faca682b63bb9ed8376c55c1c5e9fbc340ec3a80bf7e56817f961f49474c0963c04a29ca5f8ba3e7f0a21bec817e66a1b838e766c229dbe609fe599535c14fc3ed1357513a344318f24f39d27292bd239429b10a1aaed3b889639bd857caeb817be055fdb57387e49eec68e0810c7ab305fd09c7525c15aaeecc8a8439c762092d9921a62ac8704132122304d6fcb83dd867ce675d3479bcdbeaf367da6c6b4df047917d887721e8c179cdf4de43253b7904daa2ae8f14c358ec498c494c335fcb9ab04ed03f28a5f6e4ba775ebe958e0ef22d6990a48fba3e9239e1e22210ce9568ae8fcb141fa86d171024aa2348438299cf11f65c86d654c8a9ccd1fc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
