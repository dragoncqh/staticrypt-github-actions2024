<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"656e14d92ff36848458cf7cffb1dff9643b2ec672a41886abdbb202e3436cc1dae18a99d74053060eb88e26db3b4b131da03de5c0bb70087c3f7bbbf7f56ee84aa99f78932719b15740927c2f02b376714f86f03d12b45c1d9242db4a1ea4a19deebbc650fb99bfc852375860cd44801bb4ca5f597849194834564459aa514a8ad8d758c4b57bd12c62873fa2154753e776f12b2d8b9aba50d4577c1928b8eecc39fd3c1200d785540d4f78c26bd79df7bfe9fd6bfa8a655dbf5763ee0051da44c5f5d9eb640ef9eb8cbadcce6bce3b423ac8a577016fb23106511abbb4b20541b8f26e68b92984966b834a5e5cfce98b269f785710e580e70f4d14c48f50751ab5087ae1b931802b9f98e13105eb7da683d77317da34e9d79d5334f5e030ca32f491315444f0e25bd4e708be2860b31257e5fe4c609bd049cab93523da57384d2d97789ee16e7cd549f884862012c82b6c4ce34d5bcd502e43ac486d01ea6f58f8bcec71db5fd406cdeb965216aeb25c4581d8926b05dd1913238392f2b59f4ac8431a99f6056c37edc4beed61f4ed7dca8c413638b0d4b0155fd68b076f24f8fea4767b9865d84ada560a62340f56a270dc34f24959cc2e30c59a1a0a141b89ace6759d739462c039e3164d93c18a98330a0268aead854526d0ef5c65c8930ebd92b2aa54ebe74ab8d5c102fc4675978961655bd0bcf25027e041e26f2bda99fbdef9712971066f39b686357c7279f02ec03e89e78d45a4fa26dcabc05ff2f00204cc448bd9a59137c28ddb8861f4e5523c7106ad62b84e1e194703136cde595d42277bd060fa9fc826f1f1b5cbdc76dc8b121cfe70a568ca2527136df398bb876710ba8596adfe10ebb847e930dbf23d681d6f5d21473d20da61cd5534140f0668b968fb93cdfb810ed5cd51e0cf880cc809b5c2b23ad60b9488183baa0f47c2a2ec764ccf12028e69285f07c958101818226dea282c866754df5df1720254e2b33681d1110f8886bc6461ffe7434590d60da7b9ec7a2e1e5f9887213ecfb4cada3c7097c3280110c5a77da510f0cfabc8b388b5c5dcd7804e525a2ea61074e07cd3344cb05c5d39b6938e3d5565e2f4475d7c99444399e5a6e923558036dbf658030ceeaedde572b665b4036d0d9b38bd5620fcdb60a1cfb371cafcf4e349fce6b87283629fb2da32707a514779fc7564f9de70f61ee8c9cd79875fc43380a93965689f849f04b7ad0d4de0b83a4324390a65024a4ce2e9d0544b60a434059847b7c56487eb17c89edd3d589f7e3aa00cd3841082f07a610ff7fa794c921a825a4fefd2e1102dc69bd0cc86e0e88141123df52cb412eff9c642da78c9ba9e11a8f30991e679099d89bfe837831edea326ec7315391db3c8d65d5c3045115f6432a9587c2cbc46cd7dda3a17b954066f91d24713a8ee30225a29f7ff4f239e59923411c092215f73b5f75d7fe00156a2738cf1e96abec3e686628f821a12ad29d458943b8eabd6fef527629376d507d435658a3629551b204224fb3bf15071686a6d6d39f5c1003185de752f3625a271f34f21dcfad61074c1d7fd2b6b91a3333ce86262dabe9c714d6da18c05497bc61c77953880e07f23a0a340478f35cb71affabe69cd44586d61d945f65b00a95eb6801e1fd0775c9a4ce24448aa4bbe398eeeda88e0d52dfc460e1b75e078ba66a851c907c3665ae339a0dfbcdeff1af092a881d28b6d1bd28bf18b2be0a2ded1234ac259024e1491348626a660079ebe1f688685d1c03df4db803f56685e9388396a264cc22666041cc2310750bf3a7167d4d40ce470c20fa5e0e931a3392835ca4699fc8d23f03e335bf325646ff2c9364350271023554bfa93aac35a04a7db6c20817228da7a9f0ae246a001c68a5a938163b25068e312f38b2d363ec8610a14d970fd549c3e6e86080083d983b56e8f1cea915fed156f55b413e54f20b1129e8128a67da22a0a9dbefd006504e8bf774e98d66252b2602ecfff5c0ef533713ddc8d6399b77e988cb54519be27a4da8c7033f15db436223a0c6c2553444563981ce5ca31c796243929d5f6b65070072e115b2587833319a4ccb92fa5d34d68be2231de17f29873bca51f6fba08f4cde2b508d98d9a4c18cd924f2fa26162a4aa65225b684c3666c38ff4822f1587154bdd12fa8bc05fc78974639d5aa61b42789877ab8fa7cfd3fbb6e015a77369b7a2be29c43c7433514801930003d430d7ff450a326a304c5183fa840eeedfe0c737ece241947021dab7a1c3aaca611f662b231895b0ed165092e2a64871c6f447351ae5489ef33551abc4e72a541e4ccabd6f7c9b85e2f6078d5b01a1bc85686c31642db61bf5b0933171c05ff4c5968d0af3e7058f617f065694f30ffa611afd4beb560ec5fabbafd1ddf77702e24be9afc6c1fd70443c3f94809caad73525d3158aab3ffa5381258915562f6f81e064c7450a66b18f73dba0a64ece13ca0f5283ba3dd0ccd895747470951810e3f227c98bb729a8f0666cfcd8d8723488b505f7d6d890462a7471c1f1a03c6f962895f95fbf89440f212478584f387890fa813033a7feb2f334594e0f780053f715f59526f1c413d3df2d2e51bd404e8e37150fdd8b6223fe4b2149d2589983bbe17052fa5148bf46154a0cf6b070a3049ebd20dcd44bb7594dea22fd32a252eb5cf6eef02dad2fe00677f66537fd6dfba4ad108af1943588a694298a3d2dc43310f0c563d6f968ef0d46e8f9b6c9dc796f799129e216e5cd82248432e036efb8a79e4d1d316b2916e2e06e84a3340116505fa64d1a350992ed37d1e034d0bfb5f28e09d98befff47f95971530981f429dd5d91c9921876607f0ea49b4b12fa61487213ecaacaae65e7a01b2a80008ee3803eec740089359ac7fe76973d3a0b004ee25775b11230420fc45b5216ce3363466fa67ca499edb578df93bf5242ea1897b2055711431f67fd4ff1a5f335880e9e0b64225b46f40bec1212161311c04b28f171619e3708bd13c563fb9375e9c84dcfe26fb166d0260e7ec6eccb03a4167700d3cf886e9c02e39ff4d8d5555d333edcb5079404620732921a41cd6daace9cc21d6a7ad7706e719c947db024dccd860120dd77b0f9235d478319846b18ce5b9bdc8d68af79a40b5e2fdebaaa262d65671b3179aeae53d4dc483e2d24d97e478909e9f2b5b9599d80f9314514469e4e978f89308c0025223d52fa15a2f39b65052d57d5b6fb82ac38d683cac499aeb3bb43789f829a5df3daad8733bffeae51c721a5c46c11dc30c0dedf1b8e6aeaf93b11a0c8b982376caaed8b61e04b3e0a252dcf2a8f1710c497b01d981c2f6b527aaf50f8535a7b54c8c0597cccdac0b5b3c43d49898e3cf8913c0e52c4e899f04367356ca0a3b891946a094a8d68361112cec1bf3ea58c978a3ad2268923e7dfa91f685eabc1404d6e39ac40fd2c637d6c37ab5b03fd13ed820d384c0ef9baf0c37580e9979b4903dcb13513cfaf46be34aaca46f9a94be809149ea4e093d11c1fbaab277f31cd20e90236b90827e940deb20c9f60fdeb6519665f449a583023454f9ccd73bf6076d5e0cbfca48dbddd1c2334416547687479c5b5119a2e39e4bf6138573c10656791c0e24716a1d4011580e089b3e08b9c78b0625475c0c92a97346339379349d8f7a1d214a5e7e128aad0fd00206d8017e4f8ca90769a4925512d8f351844a29a7a8dae652a17c96024bb95a0a4247ece5fa2d7cec49532a5718ef3e5149d2187c1d55b11c5f5ee3cdb8bd073d7e07f584230eda86be469c6a247960a21f055b8d7cc8703c70650f009e44642cd2c01815546729b03d578f15d71f80c4ada25acebeda6935f69be8e64e7095c3c113bbb582052668a4b1bb9a7a2083e6ef51a99b988e35fed5f7ed82dba1095c6a6d080afd411895f23a78471cce429e32ac51efe13e4f552491ba5bdc1123ba24c02c823cafb4293acdfa15dad8b22aad0bc309eff91e3a1b02308d59d09ce9e03e526c6ed707db7174ce9740726b643517727053bd829bcd1a82cb0a70da41135232b91ccba256a54abd9434dc82a65692b4d13e52d071558ec3216da8b8cac51a89a060063f06f0882aaf7d70b373e83c380aadae6c0659479930cfe4fcdb217719423e423a3585cae2e75459d7788ad42815235fd2cc5941d7cbd3d2b4e6950e5864123371776fec1992e3d8f4f0c3efbf2a38cf5531f5f549610106b963bbcdbb369b9d7fd660796958a86dcd6ca05c607fd282c87bf4382b7e5a0dace0cbd244489d0a3bb4ecff490100dd4b0aef768aa8fd87932e32a8ebb93d01a28e06eefb882591cd8a0b4898dd96d1f1f1942b772a90fcc6b4511d4c3c602f3a1d182f77a6621aed9e12085a8209db3e5edc6e171c7fa8fc8f1f2d6d2c5d93a0fe663b28adb1fab6ee74a18d43310ea6e27e8531e8b8fcd837fc328e8807dc55875e0e8cb9ac442cae9c81359cf0995b0cc1d340f61f770ce232e06c7e1fd3441290795e777668b86802211b3c132aa0a1bdf1ce714ce6c88769ee55ce13dad4ee65c6205e935cad55a01f380e962eb988dd0729899082aeae8e249aa929d266f97f5c43f4e12f9e64a58b6009be434172d6a0fbbc717ad1d3495fbaa1fd25631811e05facbcd9bb22b6f41f54ac8e2862c7101aa504750d7ae3e030c871057612204ee651d85268de72d65bc01170fd83223f76ba19585c81df8c22913c7359aca05abc542df0e9e655d37abd9b191685fb1367c05368e69330fc56e8db2ff09deecbfee8060e157d4399464e11b24a61828f3d7508ce1e5def4b6af2eabbc69392a7cbf70c36aaa06d2dd668e28dcecd94c88597d5da4fb1fd63fec10348b236a94345a90c0c70ffb533d2f1462a65bee7100c554d445d0e21ffab9db96abe2cd6445668d894843cd8a67e2fffaab8479786d6b5016c3ef7abc42cdcaf469913bb61e719e6030273b9d7b4da287d6d26553e3f3d9b5fbe51cc2439484c65165bee174d8d9ccc8ad7dec2a4c53f07414213fc29370cba6614052e24f10a8b9b7b2aecd965fc9a1ea5c8132e7f60a4398fe983a96035fdf0f9722f57a705cd860115c77537ce8534cb3ade2fbffaf9e6e1e089c2d00f115ce3391126abf111dfb9b121fe51c9500f6cc276fd5c7cc2b02c1560ba861429c5d549e6b37f44cbc02f29707588cb720cf8d16cef8d02e1f819eea1e34e6532c49f35d7bbe2cbdfac65501772f4bc8b39ddbb78d50b36cf590e9e3fce6278aa54ef185fc1e6a2a414e3add47af17abb863b240d64962a48b7f70c1d0c7c01ced46ecebef8e459a92a2b0f10783ff1d784c9ca2121992726732f67dad0dfdf23b71d8114ab28dd6165708714d3b2fda1a5a4b533e844a110c39b08954a0c7fee5aa549b0b92a49290844ce4385498d62910e6d6dc0b6079dcfd507c0a5de656cf335ad91589215c995443bdb0b5b640370cc8dd806616d2b43ed2b83e941302ead3ecd76eed537100301f71a692ff3aca309e5301e8bd6943a5cb0df4cb0b42fd25ffa3f8937c85dfcd4705118808125b2a1d64d47996f1de92bee8345a482820598b8fc1708b0990c0bbf0324932c33a3a63e90a07c8dbeef0629d9800215f5a73d40804c57385ce5a333066a6860620b23553d1145f36daef14491575d97b8d197b0218104deddc5105d505e24bceb9f22a1a339b2f70e2a6fff6af168b16f045278cfc2b174f75e145c59cc58923198ef38df3440fcf5f0154aae5d331025d656b7855012b3b2b04c13d5440dfbf58e0235e9b70d9d10c37e3c4a495f21cf7085b8afdf4a81fda294db2614886fbb3018195f3e6ffc74aec6d54f2814280fff82c83bcad21cc11c6e6ecc5062d97fb62b745ee8f3ce5de3093c7c7d7e3d05989416b72cb7e9a91be922cdbcb116180c9cb9902ad96eeda7e0a862095606fb5694601ebd6d5faa1377866de4c58de17f8a83793c375e8ce7cc59fd36ed05fe4789f4b39baa85cfb0b2f34de3c6ab0019b9b84c0d0046f3cef0bc44bca7d9a7134373454d4b03bd1a7bdb88773ffa7eecb19dd0e1d161fa3cefbcfe58bce9ade4444addc8588d966f3336b6647469282e3ee942626931be2278d75ce1f3cb62102f4ababb6a786bb6d9f6cddef9743852bddde406ab22163af3136268b6f57b2abb9a16099730505d9c08099b39c36e88ba664d69583b24658a0c4e9b7180d9dcf5bda6c4050d4da72bfb2711a99674933ae1d3328591331d50bc511a718dbc75c260e6c3e01e1cc42b2e2178d52f0d0cc13f8292e9c011daa47750255663767c0bb127c9deb69e66f64b5ea9c021d1a69d69d6e8d9dc42a31b966943ff78d0874debcbb53df1e21cee33bc6c6e957bd733f94661fc7878f638d6376be8e4ad389f236c0b999c51f0e23c251233474d66d21a37f0b9360d1fe79ffeeb5594b1aca722f1cc21f34ff5747df8ebffe2786b9edfe2a202c58580ac1d43ba4ce88f2bbfd24b9531c985811fdef99d36a933388723f6a5e70fe2ca219ad263e149b7fa9bfb7c1d30b487c05570658b12f5a11adba7236cd695f692eb90f5bcc08c6f70c63a49bf67e3ef163e91e72f3f884f184306f8d61ccfb29ca927cd554d59f80ed8f98f40f013b4abc9f20f128cc45025c2eca5a34b9281efcdcc01ddbab9b0675ef05418d7922453778562f652fdd67f5faf195093572fe549b4a600cc70e31fd38b5731dad5fc2a1d5dc831b63f22de7c8bcd7eab7c0fdbf3dcd672a14212acab95abbad4bda9d7711e5a556ee4b6fcebc49b98b3e3098af38b61515002cca6d918ba6ff5a40efca2d221966ef0671e0920ef6ba11872f0ce5edd71f9d0289b7696712e9cd49c1aed28be01c16cdc97df98bb88b9876e096487a1f1ebcb7e138afb9880b30b245d423226c7ce29b8adc6214adebf4f0fbea8547cfa0a47688e09a660832991306ede8ac34e578d79f5ee8fbd4d47536d43db5735b958dc67cc74696395d93f342c0c646a00b722fc07f047c87492aa92d70efa5180921be9ffb0359fa3371e53bd67e04ebf3013163cc4c1abf1fcf6f1f788dbbfe725b71e5ed64095c266aa2639fa92eaf493db7930f537aad6453fdc217ebe9f38519e2105ece5f56603d7ee1d2c8c59e81fcf1d8ed96419ad04e4858d01898bb91d86ea817abf0113d5769853cc2f1c124d37d2e8ab826219fbed96df94ca64fbbb964a30589c81eb4d2911f581be211961ed9ace1568072a660e4765dea78d0f178118386a3cc87431e89583fa0908b3f4593e1794b788d6d6fb555f282a106ef3b3352e28f79c647f0490ff4cf933b6ddab65940c9b42a6a5d5999c049b5828ba87aba8fd23346be26a05452e03475fbfc5f316c4692ef98bf3536732facb1e311b311e7bee12e057a1694876e5b2faf824a95c38f1d0f40a95e9e9fcf8928bc12fe60dd9e73126359704dd89da2c99d76f4b62041e9bd96f375ae77a8d71f5ae91aae3c034907b73420c10657efdc053f030530b3ae72488fd3ac586f28651abb97004c610d2b41d475764508d0b23a9ae4f71cd49b215db986fed382a76042334acf52998af4bc53fea5957926b403f2c0186f33861eae3332263f3e57d4c98f80a258ed7e5e6bd0666069404761200019260c15bfa65339f2f234408183aab810b487f674dd84d676529d7775be4907515b279f52e41cda42c54fd2f153aa570d1c8004f89b0e272a56b7191a4eac73cd89b07f9e78bd177f6ec2966bb40a8426baf09a6d4a44fbad1938ffcc492607155b19f94225e2712b029d988a1a6103f7624210fffc72b5eba643465877f7be698a3a0ef709aed2bddc9b73d61b6352afa5e3cc62a403f68a622d2cdc223d6fa6ba2e5f5fe4bf8b74aa9f75b0cbeb07602af3dd14b3fd78056ec70409833404c1c3b071b9f0aa5980d3c5666d55b279b45478b90f809a93ba32f4106dae5bb75969fcab9d7e9421a5098894252b6df40cb5b3d42cf8452260c9d4c85f343dfb2fa0a13fc9e3e0d19faba578c05f261a18d3d63cc8c75b378ba7ece004db6ea76ec9ec67a80449bef8d826e1a833b157c89ce20cad007436fe88cd72ba6cf843639b59064c90887bbdfc00a2aba746ddd7e67863d5920a6c822eb6e4dfdb3337c30c4520d4320346e915afc333e0d1624476bde26c4ceefd42c903329cead67ec74dacafe095cc20c2587e1e8b81bf47d8e4abfdc9928479c0dc8d97da7c6dbdc238d52161835c5b8c7a2b878b0f9423e40c1b205c80cdbbaf5e6727e39128accff3468a796317b2d601ab9266ac9ff6bea936ed2b216d78ac492d9c0bb38d6653476a3ce6716a8da6d711dfd21cc9a6bf9501d7b3cba0e63aff2e25d14a0bee5b8f8468050bf2c9328f1892d15a1e7ccb0fc1f25af997fd9343bc409f4464e6e15f8814efa16f0c1804e1e78ce8ddac99bb6d65877ae4c1fdd01d8183f3db1f57338ac215b65a73fe78a069c6d5f0dbdbe238d2916a51f924c3a6d26cab2969e9cad4f59dd00ffd00e062791c7862014778e5185247de866af44707e6244d49f0635e40828d65be117b724c394e3075cfcc306fe07d5e08bd3689f192222beab81bc9a4568703283a0b1bcb1845b4417153a35f369c2af8f9261abe70024ad27c44bed730b01100d916ba1249c2ddc7e12854cf6e822f2c3eec775c5647f34888cb22e1f61006d5333a7cbbc7fad8a8e82955cc37bd0369dca562e4488448b86dfde457f668419a1e91a76f0a8ba9c0dbf3bc79b2f33e03f7b325a2ff9919d4666308fa07572c16f5ef2334f677cdeea8a4bf89b5c03dd9a55ad68f68c917282cb01a79b73ede38dc1defbf0c505597941be403bbff5b16a8efeb78985a64b43b9d9ffad96b36a5142190e1b417d46281327e5fb763f214b90abfa78b56c55bc45aaca104a931beb43e68b07a38c21d62bd5f1ee01d0959325aa8feef5036412788a8d832fb8243c110b1940817d4aa4c2a0c99cedf750865260ddccd06d8bdade1486274932d48cf602895e1e429f0e2ac9b90ea978404e6bfe011f3fa41c480b8c0b318df3843eaa1c6c6bc39b79a7116ae95984b5f32e57fbaa60c8d91c540e9362816c17faddf348994445c1f52b3ac40a048dce338bb1bb22869dba2464938a640d12ade1b635261f9dcca811454268cfe5637a4d308a9cc4266befcab7ecb41c299cfa8fb1390cc36d4fe632670124a756407f2686bc945d4b6bf9af5933562b5f8f1c6199e44f9748250e85d12aad3294dd7bf51a9fda80d9a1fe568c47ff9b8f00136f0da5e6555e3acdd23c02cf53ae81af446e79bf0fce29cc4381bd5d36b41974236f69eeb0a3bf39e180df2b93e676907848d69cf4f45e6178316871a16aba3eae70ced4528f9746da66d7767d4ce480cba9029bff2b9326b869b643bd9dec746ac1205a696e7e61e3b6bb71de01051b411cdf50100a8d4eb1cbdf921192f881fdabcd48d5442a339bfb6b2f0b120d292c43d4d1e13067741e8ff9d2057e8afbfc69d94eaefaf101ebc08ccb2cfd8238d90fb2367cf502cd3de46a03fc135349ea410877158f9511d69a36839557cf01de5ccc67d80dd93c6726fe6c28cc0d02c87a2a6717e19db01c59a6b5b4c88cf87f0c673d2065ab42d70c0909de57bfef30c784b64b4f0198f9d8b99f4d252b57aac22e76dad6807cde06e445ca97d581c884738b43f70b41cffdf379aa67cc58bd83adce594038700225902271fc53721c8483be79bc4c858274d09a1020583d4328edfd08f00a1c5ed1a9aba34c997256ae5ee930718fe7dfb40803c4e23609a3cb0f6b06af1e321e184e1137312f6e4d2224b911729210be7edaa778d85fd300359828f15c800f53a0486ecd912abdce9f5831d3f743fc79393b614fdabffdf7d5c94afe274c652fb22dcdac4b6c40fc9ffe2abf15196360d0ec4c969da804e813041d57431a26c2aac38a4f4b4281e336e8254c0217c828abf137cdb59614e9921688ecf22b150d74a515358f35d910338113e49499b9b3eb4235aa1be2d69bd42f4ba2fa096a37244554180b819fad54e24f194aaf0d770b39a805350db91580293f88de3ed9f900d7ab93202ff28ec0bbbe01af4f1ea6873418e8af0051e371212dd3c2d7dfb0cc56c6ec61fd4fbb4b1bb98772971e4ab4b8a9e391a6af52c99d70b76009f91aaf16fbc5a508c178cac6bc4bf56b16258bfa7d6d81d6046090517bc26c79de5fd01911af25869202518cf7ba1d78952cd1565c8f1e70c2d0eaf9216bcb04abe217b1e56ae2093bf7eb6d9f13f08e6adcd77f639fce4d04bdd70cb1063880a5077f0b2eb47b6de0b36037b067a1aa18ffa9cdf55852589f914cb685c5f460d400a21768c0e254626824c9acb09fb8a2c72771d3cddc8526da88059c11d77b6956b8f0d9d5bf60d7f8fb461257cc775878560f6eeffc363fa7fae2ce9d1c025e45fda58b108dd72b5eab8a33db8dbe860002ecd1267589219d90b4658f0c1e9bca43223cf75e875536cd38703beb2fb851580708ee33e2156930871d834b107b1d60e212a7eaca18e5929678c7e6ad4fd2c1e65d7c5b54282b041a3be95101c78017e9dab371b3831300f6a4b22e75a30d3abe309d3982b49f45a7db01a996165c09bbfb44b4c5d12a7d6c271547b32bd454842253d2ed1511df098d237920c230578a2b1766ccc5a0994729ee9c8101086fad2c05f2e3d6a0461cbaaca2304fe9cd80c102f966082fb9d7346746c2110fc3fd57ff4f115be1032843978d3d4ac852d38e39ca03006eb425879d32e66e40c9a3cfb45cf73f05423af4509e2952b15b2db535fbc9b15f60b8715b029dfdf1787f4b5b92916c6b787017439257e2d28084b1f5aa4260175976ff90d987c748d061b83e652ee14bbbcbe45abeed9c19d0a466deaf82057bdce1029596e7b0a1c994f0c1372e620f5b1f3ed348535bba4230c1b88e960f9fddfb20525001a79983717b9a9d6a53346b0b2bd29b1c5a2bc2d50e09bdbcdc7d5a0f625fe8317980685281f3a6eed28bbb0234cc93edd200b087062e2e8a3818dad50a83192094e58f87c775c55a265790350fba8b8c890e86e013c4e528bd501b2aa69e5dc1a27264ec6b445ae938ffb1261155d48e1776a5c7f272135abe11265666aff8f3459e17fd9d2997aa593529740969f34c83342f9c268f0099f0bfe99e19f6956f02a398d291bf62caac604f23b28ab9b2dfd1a82cffe5ff4a41eb92bf67d9c148a0154d9722589a4751f00fef818b9cc0955e3bcf2326b519e884d72c02c07745fb3f7b485d05191cca739749e6d1e430afe4ce36c434e182f1b65f155773f77ed57e37f8dc42da0ea870635de7922ebdd0414517a628c343c98c4511e7f5371344bc6e1347d9f39f92dfa989f9730ea6251878de67c4e7b317e518cf2f88cfb48853bc7b6fe2a4f0246d1a9895695e100f1ef7cc3ff7e88e762de693a244c5af50546cdabf90380eb7578474c0917ecd19c59b10a91e285e0557a3afe0b6192d397e09718f492551830e26140952285c438307f565b0903e43e09e9ab336909f50de087b5e5dced2535fbe482151a971fccc794d8e3872742476cb758e9c447ed05e4956508fc2d3e569980f3033d281bed295f656833d9f8f62329bd64822a2c32dbc4d8e3bf6cb02d308fa31b7dfa243785d666c3e4dcb3f4984246c0ab17806dab755e21dc6ba661b5bb5138e1ffad0a3bd110caca89334fd0722e1570b350adbc2cc4674228f633bccbc202eabbe4c4360463c8d0387f17dbe4d013de305a3d01db4074dd85c742b4e895d27be7a52e1b8750c78e0bca24f9b4fc42a5075fd164820f9f93edc9f853a5aa34dba4436cbebfb262d5b6f753bf145f3865420f42e13d3d30dea2bf6cfd2f3edb620cdfcd82a8ee03fc277002d407cea0745dcaf03a9a241470eb1397bb59634668a7db345f97688190d783a118c8a4eb8fc77a9ca621d69522a05c4cdfd4bfbfc9684fd488cec5f17966ae521ba84afa6450a72d627d110ce76b4f3ee03e5f2c88f12400c57a5643f2a8aa2495a7a3b7d2ea997df0e675341c1d929103b6b4f04910a5b01186c0ca495c7f86a4c8f3d0d104a70ad14be6ecf0a8153562e8b42bfe3772fa47c81d28a13ba593e1dadf2b258c998bc0d297d67beec6f93f87a3926e83d2baf05b88d0f879229107342583e88f7253873fa953d94e47bb93f66d718e421807afc53a8023d6c7e7be808744e21adb11db05ac80a2b83aa83196cd57a246e002deae8d22fd42870bc5bf95af1133bfe97b031434283028eeb27f9a29cdb5d3b30db8bc6e6084aaa439e53e8afdf3ce50721f87db2cda2befd74d02ab43feedd8f5c64ba84768a3cb6fbd52f7379a5cd15eaf4e077d43a9c59e6199aea3384f03cb16d144783c1ce95770592b59aa01680779e3ca2e879168dca758b7a6d2889a71a6c1d04573e740c4dfdc244619ad067e438c3a95d58dfa0c550f2e60dc95f5400fa46358620632c3b2b6666c5248bbad900da91c28e1668a4e65fb7751faa610113150a3d9a9a7ffa2f381d9a18338c5ea7ac8d303cffc01a8c492c9450f52445bf55c7aad2aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
