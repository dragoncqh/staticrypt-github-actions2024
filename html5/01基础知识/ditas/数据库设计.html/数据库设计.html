<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd5841365ed68d5cb046733bd763f566308d8752f009646fb5f0e00e41354b8ad2bdbf0fcd9dfa8ff12784876c568dd2178d01b03e9b4c98c155b5e48fac9080137eba3764525391fb1d088201a49a226bd68d3e2b08da9c4ce1ddc6bf84a6593d6e80b8927f3436dc250e26b9f0064583f3acd78c0ec852d2cf534707b15d411a6df7ab39a3c8435b704dc020593fc4ccbc96bd9c5d1676e998f5051029aa07fd0a74ef0db96412f7a17059cfe92e9fbbf5944b7a5be26cc7f8a29d2885b5bf0a89413c94a82b4308c6104281446790fa283eee5435b5257b2a24e6ebb6bc39c506f2f098ac834583b15840141f282b260a398a7995b04dbc4a01aa04f3334a67dcba2fd4b74969227a3c3d78d8c08e99eb2a4ace4d8105761ff923896cef0711636270e61dddc668c6281685e71a59cb103c22e8040bd02bc36f969f086a3b774a5b350316d615da285c245beecf8dad19c9aa36e4bf41aca5a86bb5e3568c5d81da91579d80b806b05c1b24d03dfcd70857e63b7a0d8fb9e31d000d27faff32b5e0aca99d12869b9c520442b13ee9d4da925902916162f5f2c7d5901b57cd329146c330cbb58554039a06d36ebd04bc4fa8c157fe014057d34f3b804a3b25ddcaf36314288d538a5075fcd0fafea7602998bbecbf8c95bd27bf8b98981158f3b6780b4668f52ea5fa07f52c0d84a3fe721f90275c8c9abd9388e3041e70a0ace1e1754ef9c00c5f23f86fa7d626cb8b35049b4b8b5b562c4dbd269a4cdf4700cdee6ab526dc446b9a5ff6a88b941445ab4c6a5b4c4da2af3fee93021a9ebda29b723610c82bafa2ceb5be43c4db6661513d23d735aa0bcbec7a32ea8404eb6f9050e4eebc1162c5cee5926ff6724275a4dc3f11f7c0d78482fd6f041189186e437119420f570a64299666d6476addf7c09412270a5de980d91aff006334a01e23e2a10160a410f06b902288fde43e87d598f3d6d7c4d767c802bf7dbd710e75dd46cf0c001a0115682d0f2e83e2a4f65e1225dd6a7dd7027355f956cab706c0384e908b4d3531c8a9407f02c369b8883561d616feac5cb536a85e6cf8823efcfa3dcca305f48326fece1f52eddc0f15f777364d879102a5be58a52a1a1a845669e8940645d5f5a07230328b5a4e815513b689ec16f2652725dcdd6a674cb72bb8c454d4ddc79c1bb910b1ee4ced58232990b75ac115ce9cf044d0e06e189f64c3422f8614532e151c156321f2a221704db6a14164094f428190137d2014a6d207224bc849d5995b8bb4e9fba505d74881a59d68de675a5bfbca51c3c8e16cdc92d5fa01dc583274b832171b7561741dd78e1f37445004c4ffdb573d3e017509f40b2b12c05423774dd47458f5bc66381e6d963dc9aa2a4d80d63e9baf9985c454b365aa0d9d6994e67ecff40f0ff66d75b6170a59ac45a809477bebee34fdafe42c2cf9731325341b50d8bf27bb5d75a6aeb69c2854b18087fda5a18c3f8413b65fbfa3c4c778cc2a7ee13319749cd193874a3c6e7fec0a8966e98c97ab96a128d20e30ab527daf5bb3fa6806634cc1606a812dfef98f6217491a97a22ca0b6f23dd34abb016f8be73ea146af1dca1db9cbccaa9f26c34a754e705c95477bff5da195a121f761d2f5e04e68066871aefa82f906b7e1f086e379c92d3fdb6a9f15bd25e1281373130edeaa1f6fb000e355996dcfefe80828badba1adf5796e6b5129408d5870c921c07220fb9e930b001f56cb8ee659e3957463f6a5798f24394d829c5dfd3696908d43e155bf5a904bb1974d3f82e7c02b3a95750afb9eef5acd4f05fcfd8816489a38188e8e389d3515b82aa211623c53a9e1d8ff02667513c08ce72ee3a413c6f400f9abd42d9fcce2508b04dcd83f5554e0b41707bedb4697f2445d512cb6c01e315149c3a10020c6657783896dd64aae4f1cc051bb23a1378b626e9b8d2266d7598687eddc204984661abc7fca8f051091ecfcbcd21da38697f6af9c99e2bf1920755e25385f7dbef68ce452d6e1ef9a8942ef079d55ec834bb76e32199160714feb1634b715c6c3d60a361fb82a14453d567f8296d34350b34184345d61a22c4e5eed693d635a2a9c8696d17a35cfa770cb39537f70738693e85194f5e033d0b70074f0802765f1a5ad570f494e7b764acad20f3af4ddf451e225d3db17d4fdf0698504ce8208fdc575b943352ed3c24cdfd873741df622ebf8b52cbb98ae1043c536c2b2685c5a792e2cf0cbcda528c602915aab4c33812a0bf6238b04e0b1f2f4ba092b2d5665f7c944b2b52d5c7071f3546e44bf1d7baae9304637b4c970eea4c014e4660c43668eee671825b1e2b2bc81f0c06dc9f69a64cf3d26e11a9894eaf2d14b91d0c3a4e32b16e11423d67dd7fa493f5dea68dc837f30c4ae5c3599c193e503fc40be57460c97f14fd01d0fbe408ee0cb49472786d2494c9373550edea5eb11e90815e5cb07247bbcf328e981b53c0b8201b966aa1c17995d55a09a67e8305ba10e3cefa1b05da44d1219c81cc1f2fad0091f31950bceca5e1ee705e4f708bb63611b75141aa0b25f1af6bd8560671d4369eeb9ba2337eda57c4c987014c665a69fc6ed04537a9f3ea2eb15e5d971f279076ee6159aba2d286db74b46ae71e1063e0b74709fb54e21fb58369844b6fa1da9d21fa149a4773add76189aa0537c56bac739632026646e809e8dbeb3f46a87552ffea190ac5503bc1d82fed72c663a824bbdfcd6fc405cfb73be5987b3a34a4bf2580778d3d753176d44f4c36e6a408e0f6d3a4cdbf5279e3627a529535c7b4e9fb236264e58d37116ea438174788223c44d02c33cfd12c0cad5461cb28c2398e419bd5e287338217c9db5ea7c311255f98fe0d52ee8399764a99ba06c74f85bab1460cc14fac1a2dae04255f952ca3c2ac83e450592ec07aa587e5808fd431fc74f9b2af1cd046c0fbac7df3f4ede56e8249631c22fbad7375da0cedfca2c9058f5dd5a46dbc32f1dbb2031a0c108052958e061fbf47e5d0bea9ee45fd640127363bed0870b89c16a5cbb478b02676f06f90825f444b5d0a833b856ec5f15e9a079b96260c63986dcfd9f13b614b48a1aeb1aeaf05c88c8a406afb0bcad0f96db2464a33b2c16aa61c2b699da0d985bb4f9c5e51e135a31d08a9bc30bc67099e89fafceadc035a366b56a21ed6b476c5b42c84cb456384cce9e88cce2959bbbafd1e55eb56659592c722a10fe9d3ed1857d5e805d354e74a449ed40e6c336e1bc46a6ed2b0a92ff6364fb08a63566ed5213f6cea8946e5dc98fc66ed01cf45f588f2ac5e01e26791e7f3ec2abefa0eb5897c05f4e7a419e366241f42b767ed83aa0886b22b5b9a6876c8307528e21e3d81ead681ab0b25124ba0774b9a51d29b0aa5f308484105e66cb691ff3d8d201cfc967ad46f4b31b33fd49485c99f23c436b7250a2335dd026fda03de2d7379b61660a1ca6bdffd44d2796a2221af689f25622721c3eed7e72992e5e03a30913173a7012d90760b3f33d0d1ebc2bbf22d78d6401bf5027585347ac195b84ed494ea59eba3f990c2fe71cb8f518cc76a8c1d5465a2ceabd78cdbe8cc74e6c30e750a8b12a9ab7eacf5b6902d5cc72b0d81c154c2fe84752a7cae628b9728fe07c8f42b8b46c219e2715fd721cf7f455e4114bf4bf4182e0cbe0713520ff966065e5981030635bee2e8fb0e1ac6c55f2ebd489fbdfbd6deb272d1791340a58faaf2c383b425cfa5533ba4e660a1f1b4471f88c45e08f2d74185b878a0cf49c8b7142a3b4a8cc690b7c8d15ab2d1fa614b42591d947e11b8ebaf8f1cfe9cb6ff50fc6953bdf81333994f18e5457d376628c2ab937df299acd4bbfcaf707d4eaaf5fcdc0bbc3ae76015bcd9e661df7de12226fce9425cbf03284b0232995955f4fb7e0acb2e289b9a254da148f890a94e49af8d8e88f101b53747bbd2ef8f8b6757c7e4532adbec884aa284fbec73dcac7fabbe27ae0fd9349b291ce5d08a3b302b2fa58c126a85816705dd15b6a8414d547fcaa8875b67cbbe8998a86d91d36f1291921889e54b658895a9bd53a8686c4ebbd2123d925c8b8c6f6736797bd36d7534cbd444f20ae4c49d4a5bc05e49f8d2d3e1aef5d5fb603831497ce644c53f3c675d4cf9c87134683e31234f78b0f9b03c02f3d1afcd104da13db7ad4d34815064c13e7f52c6dd8c4ab98c12a720497f5f7bc0e1fd04181b67efd45cb16aa479d381e5305d7213296987824aa65e1d4a8d1e33ae07bafa923af55128cd04315f08e5e4bf76be290e99896628a39b7d7dd685e4f0f9fc2dd3a7814ddfc7f97aab131001680f7e316758e7766ea305e293fcde099bff5f1ce6bc12daa26e8d9f531ea1aa47259200a92e25fbc1cdea62fc46d53f558382ed5ce26ee380330cdbf89a74dcb605a6670693a353d0837b3cf26b0f200fcbc1e65d959ca800656c617d096c5ffa2d8c55f10ba0fd25ce360fede8e4a57b3eb009d0feceee83073eb637f3d5c514221647575df6c0cf787cc848afadb0c77f515fcd5d7faee96439beda37c901eda8f12b20bae7791a346dfe3a8a16efd440607864b7bf15ba77ca60618bb5525c3caa3137ace18e2e05b7ec89a049aea7a8d180be60f05bfeb09cbb98e32e196a95b067c85d5f837eafd61a92642c842f9a7cee2e469f6027ca367d12dd725b0035013133c88e1f6cad93b0f19605ea4b55c8dc226b499ebafd68cbdee1eae122c2a73df1e845b34e37de2fa453190f8d8062fd3e73a52d7eb6dccce96852b600b30e4980492bd164d91663f04aa835b59686f18b2b4554c10768ea3b6deb539e312af3ad1a8b2113c05472d6e825cf3e89877792e39d493722f0c17aad19b4148d6441599ba8a0120c859642c7d131d26a7d758c66cbffc34c1c062cd6891154dc4b44774154b6c25c28b289255bb803f27a3c7fa2fca7a3ab9bce2761e6bc6b288556ced4929e0f0fc5f15b657f0384ce6bf85407acc567e77cba2d42fe019f3cc8fa4696f979bd103601fe0a3ab707114bcb1160071455b141e8d0f0e12bab21379a36c83824ea476cd981f9986d786a04042e8260f912bc5dc4b9fcadf9be3f48b9a2514faa61eb8d58aeff350f2d3f8379775bac35c1a71930d87833c85e2d959017decf3685bbda0b1d447682790eda23095c74c4688389b2c5ad1c4187cadfe1beb5e36ecef31b2b7d3a4b23c6356c6b22c84cc9da1a0e3ea25e157b180871e4d7f17b3c64201dae148961a0a1be8d34bc17fa1694b75de8c5c56108b846bf0b980a1309f3a2d7b177131d39c5302f20d068a1198a297836f56df392aab49eb1dee3075a6b62d43d7ed52d3800e02fc9b20b48a023f407145232792ae4ee4cfa34dd3955cbab66a406f8bd00f7751d5cde28f8f0f951de9c791cbff047ca33a336fe19d39ed076f1e3d836b7b16de1f6da0f1be6ddd15a4b6a353715b6b2cdaaa821a631f722e9183a0e33779194b8dff9d6040a70245cd5935235916f3a1aa8343cadaefcfac58a43f9913ea7173ea29c851ae446ba29c4edb770ec39ea84b7ead01281157287838eefecefc058d4af7662bc6fffdacc949434ea5ea7364e673f13952ec74a6c6025a854c854a85ac781965c5472f175c6667d91baa3cab238c77a0ab4eb43417381d7c4e0dc40569c911911be406e94e8e43fde66681d21e39e3621e496bea47631eedb94065878e7d75443f4a42984dc2dcb8680283cb10c2f9e717842fd20180edf9399e0a894efa275e51c97e2a67e1df3943fc281633e8f5c84994db8b39580f97b99c08bb58685b242b2c4c645c5dcd843c3ed998668608d10b7989ee69be6f77ca6e3842eb5709030c7cae8521cc9cf57ec0f6179fa1f08e800be60750d00428e5fb1446108e8fb2cf9b48654d74a34751cc699a48939762d1e52fa96717679c0b1904526a3c025894656613ef2749978ae3a7847c666e5386b79270c71c76780c8ccd624468c605ea2749aacd2e910a8f6846823d69fb0885790ef22db1c3fbbbbc06c7910da2124c49f2470642d4d8703d9983b0cbfcb073306ed5ef58e434d1b6f79883f02aa1b812d451b023d2778f42ba2ec491e40fb4fd995c058467609e519f9c7704da73b4d6a836a03d6a2b6857163213e329fd2bbe977f76efd9500bc7c26e259ecab81127ee585e2043fcabcaee67b54731241f0c7b911b32b69011888def3e1032acdb91f51e47c636da3e0154ff145354c5d9cd03e81bdb07067e42c6baa34623a632cce59fb1058eb6c2ca75ce2af6fd5c9bb9e8e5e277910016f4b055b2a6a487b790ec35229ec2894ec1368ff3921556d9ca1cb1a94f98abf47af5d65bb273eef95551f9ff39b928c16cc10687ef98f1e0ca7b4aa539e5850671a008c41dd924483d90c33f7f80955d78a41e3812dabca8d66d22a586435afb34938f208dbeb4b451c2f79fcf814896ed34e798e95913f0f89e1382936a0a142da424ecd1a637bd3c96ef953aef5e0af2f8f3b9e08e2bd717649c06432570f8c23040d868df8049a65447518712513f20c19064165109c8ad87ef6aafdc47346032aeab504f09bba64237c51ca747ae6a86d17b76fe4253f5d6b9b71d9e792fb2389b8f886cbdbe8a95a893c0b49aab98994e279b1e00e7794f80d5fbd77a1e70f8010d73a0fadb7169fa8c0ce7df2fe602b60792297ae908537dea441d4e07b46f21e292aa923fbeed0f0634aa75b84072935d5f78aba0078b912cda8a44a00d5f12eeef92a99c48067a14f2eeac3e7329fc77f0c72f566355892c06f9360de28c1f5d9fd5642b71d9b5ee163dc1d75cc38b535a1ef922f3e58fee068ead88f97ff890e100c09512436affb45caedac4ebf73b98ac282985d8b0103e05b5c128cfb8fb78108d40a79a256261f2bcfd8d187f18b18e7adc1e8ed2104981e235e5ffd983006e09c1bedbb442704e6f1cda2a02c5c14d2999b35107de14a766d94ec451a2bfc188f2d40e17f33453febcc4cb783ddcc32d3fd246a97eb79e25b2aa20c27e7e134fd22eda34ac4c10b3b19e0710df7f5e11b131a3d6531744b0c5261cb945c51cf441e3bfddba024cc93e3439a8b27b6126a9bf16e663f1d116b2ce2da44200b58d5dfe2d8ea007b9c6ec5962085b498fe7a6277e74b6d62505664542b28477859c4483ec156c068d6b14646e15b5a877204c8a691c3b8464ebd470181939fb7360141395f8afebe270d31dd468b53d5ff43cf6fe86dae50e8fb45fa692ae225a257da3614fb46e6f0acbb23cf641522d6e4af3defe7c9980eeee2e0e4f88ad78e292a5a8dacc8f21720c12a480cf37b468b8c00b9f40d36d163255b64a765de3693add9ff5ebe0b9921e8a32dc88fb1e44b87d75901a12397992d8f9289410dfd818e3728baad104ed4559af0a98f3bbde33f57033ff901d39fa8c7ea0aba2b525a0d2b3a9dc5e5988b5942d4a0660f5bc4862adac375d8684b681ddef17d6cb05ee2236ab4daee6b341507cb2e1d4c96a8f9dcf0bed8f9aa680726088ae332b8eebe3697398dd99b7fd5fc3ea17e2698163ab3346805efd240d57de4fb0e13ece7593f7152e9599198e0c29bab231626ca1e5068b905b6d95f1f7b876ebe4507423e9dfd5ee6965a5b10e7ea1cf3069c93234311d3c0dc413d800a0a3743317a310915b65deb3457624ae6dc9f1336583b0aa7bc1d480e8dd1ce979ec21ce0b77e9b1d8231b30dfc06b58da3821b9106a8c4c42854ac0be61184226c7ac7049f854e0bb476727720f8ca936e1f413362e2fcb73224e69c7a66935e00e540d1f167f6eb3eb856e42464e7d768341dd673e64bd385f707b35c662f70ba26a839714c172b015da811738a419071e96c87d063d7c5fcd78e462b39f5e89fa8390d567e14e460f8233cc7d82796d099b4df4a84901ad7e043eabb6502f9874b87f3a4a47ff4fc581ce98a9b8f339cf3286dc9059256dbd5e1d61d8451cf7aaa7d591cb8e1d5b56ee973baafb25d40c6684419b27cdfbecc8a90db920dff5b85dd57c7ed5126002ec8959d5a0f26fc8de934af4b98200f30de223a8c0a4a3c199402d76883dc24e0f5929983ddd3e4192e1de91a44efb85d1ab0569d0c2baea4108dcd3d5d653f9efa1b06c071865fb3bb233c39c538cd9720938095fa24d301cd9e5b0bea8a886e6459195d79aa9aa0da621453ae03607d73cfed20add9900f9d28398af411d1f12bebc0a7e43c90bb9c9ed117e5add833ba5a1da514c9d97086bc93de620703e71cbaaa539574c274a6f5a18dd7ce8787781ecfd5f7797d1204f17009cd4053417feefa841ccb587f3abb18a5fd02248ef1b8b2c9cd74da231b062ac89011752fe6ef39bab25886b67dc5902301fcfcc94a242ce7eeae2b329f900ac59ae88fa6ddb9a0ccb38ff18e8c2011a4f282ef857684f69aed28ceae0d122b06fd6e6fdb550820aa7c7aa572f2cc579cda13cb0595153a7cd815249b1c1c7579602982bc5d847c51c672171f1a4d9b4bef256a6263739d80f0397fcd1fd3b088e33526bbcc9522f6036757c5366e2a9bfaf2ad2bf347d678e0701acd786e8c7fe625d852ed0aea952de04ea61f1da109063defd777c885fd87023d40809ad4655d13d17b44d6f0d9f463b0554b3bc610b3ee476206495f5304443ab6e77df703e4755e8ac14f5e3636a3b1b351f9fda520a59921506454d7d6dd939e9e50db6668cd592bfb972a9242cd3fe2140e10fa195db848ce4c84f49c6e69696c810e3dd06706fe93e0a34031657e201736ece1d7046b8450ad04618e7ceb3f4e16e5dbb0b0880b81976f9cf168ef3a688093b9f59761cb041dba35f2683e4c834769e998ee43b4a19c663e0ee88025c2e145ea7092e28d296a324053c2c8a97464b2f5e301e403fd2eb9a9afd74c3c272eb84c22f0388a68c77b10e3c8e48d9e8d22a2813ae50c32dbbd49d5d9c935fd6f3d2f113b4931b78087a937eaf856a5fc1e54773f9969d06e766c998a23bcfa2587b3de2cfef45bfa1b3acf0ec969eba489d450757b719e19633a20334a2218e2cbfaf87c83eb0e89ba0c8a68dc49100fa3ebb85a79df213de030fa81b30507265007da7c0f22a48305ffdfedcc1d05e41f39913e7288eb679c6d19c65568e7d7ef86df7f9d5d2b68ea3d26597cc00bfb02651a325456f11a8f6129ee2fc5218b2dc1c21ef087626207960e055f4762eb7b6d666da09cbd3654a64855ae552282b56b730d4583b7dfb31901d42de3a8b27a380639ca5abee86541456b49beb13e4bef7939c799e124cf0c098ce4ecf9150e71264188fc43377382ff5d3af9b5925961414a206800ab9e6963a2a8f027e4fb740e47b95dfe1bccf949e6e15c19b9b3d166f5f09ae9b94c371155a60e177a114eb6c2b25e5c96fa0a1f079bf294ad26cc90de07e1036e2f0123f10a9a42297a1ebbb37a5e567883039879f70ced6a46ec026cba3048db1966ba2f3759f1b9efd32a1fcdbc199a57b1d17e3ce5c65657e58b4ca60569c0776c520f7da8ba7af2c6965affa28eed0d78af0095166e059c023e550f65628cf40b8731d39cc8424e4b5199a1c6427b0fe4340ea5fcfb5ef77a2546e7dff17bd5c4d7ba58ea81f44700a8838863f0e0795b656c404e49ee0c315e3e3d683477189668b82575f172fafc20427d4852c624b9bcd53ab992a701483d1beb72e47222eec89b0b97cb1a2b55a862c2140ec6c75d3c28a61ebd7764c03297a44bed3fd3bee4f37ca85a9bc93122be65a34094b12677756cab6208cb6ee0cd991a2ca815a0f6d33b0b00515e920dde1dcc223f0800ebaeaee0b7058b418f112f3dc2ef6175615ea06d2a63373e5757f2954e3d88f8b1346b21e20c3a323789c2560ff44b739de10b2ca3e79179428366529c2af1ea16f03cf84f0fb2527340960c7408f59dc3a172c30377b38f0af80bffbe823c7edd35a6c0244497ca3a2a1a4358c235cea0417a53c6fc40a91f90cf1a84957db797ffb9c6844a37bef2adb705664c19e82aa61a2d4880a5a9ae1cc3b041183de566e2f57f4c7480a6bd146fa6b44c7f61e274747048f9c1da3b77c6574554a3aed0b335d2f6a771c81c9ebc15995928f031f20d12ae105fdc3b07df22cb7ebb783ef3035304c8eb901fdeca048af2b2e7eee53ae3d656023df3e72e069ab5b5efbd4314acadd530d461ce5b049e97d0ea651469a8d1942e2f5e0e24fd6653cb33bc71773b8dc47b6127ceb8014bfd4c2b5e2b076b062e8442bbf6af02a80b21a56e6dfb7f7f55ea366ada96baf949436bec956c81d59d4eec2849aa91e394ec2a59cc241b6090611422b72d0a0d02cb1a8d613e926a3fa95b09e7c94aed956913f8d0cb02bf5c4c4f46109273d9106490a155cfd0875d040cc998e29a4cdbebbb9b3feb24c2da83eb02af543c1736cdb5bccb59b5bed6d61515b53857464370fbdbfa4969b75348bfe595a7967c80b6a12051cf8c7cc1ee55997c12361674b11078f6bf7d801e7a4bf149d63ec1030eb9ecbb6eca33b1e77eda9ff5750efab047ba0541c90978ea80aa366a789acfceeac371f7394c234eb8e9b3381398532a1e0978aaac19f7801cea5031145e3543e32c6365617ddf07e16344485c10d746f29fa27490b002560c691026c65bc9a714d4bd16db9a8fef32c8b0c2afb084ebebefb3261268e672dcc30fc9136b002991727036f564c4be550e7169ff2d4922b0ccf202cf1d6ab4e274829766e3efbef58a7221531ef8801ed6fb28f8bfdaecf56526852c7cfdd828863860903684f4da053d7ac8dc6e6aa3925db4a1de1994f47f7862da373d31ed741f55a5336c3d1091a7108a9c23f73bc7fdc4df6f3f134a5536f690a84783a15b6baa5bbe5c78837011bf1dd1157333f5911ca10fda8cf1112c8fd54cd6164e3e39b2a33541b15793b3dbc74d5ce32dbbadee6d7f19036f2e4d73379621b396a4d8f5bc5b553de87dd68bd2f9c593114b09ee9ffa947abae50513711dd97fcbed85d65ee736b15671d78043f1845b79cae75d96678d9771839065361420cdb477d51655077d504ee11d352264dfd759b55c390a85d09ff194a1fa5ef89a91d309abfdbad5ef3a06ac9448f036a338c87c1ec75af3e1c16e454aecc76d9633251b2758fa28b185bdd2547ca5357a44fcc76a925256019754146f2fe7c6352a90901c2c78702b2dbead32d5eabb72c98044d22a88f400aec1ed724e401dbfa1879471dadbeaa9760dc43bda507226153e13e347fdbab537af515f45f3e24e4202f5ca62d24c61d30b43324e311f180a9457682e03af2d224a7a5d7c30e42b4aad06f70acf0c4e21cd77983d6083ce39046186676df09f187196e969d340e7b16e8d6a3784b1f69c8f8c9928ae92af91ca80d42893b538a67fb155f3095a25ecc7fbbd446986f087fa5acafd2218a09758218dac301c6b81fe66530d90c51e4cada43ae9fd5470631ef1447861ce4193c5f111c1fecf90661eba12d28c783a3b61216c665ce96b344a4dc7626afe24df0ae9ec01cc391613b992b9778af4f999a8d9c327bcead2f8005c1794bff6d9c83959fd90198f824e5530b597cf19bcb735cc1e23421efb4c3ab4b3c97117bfa27ed55b558d6264a044121dbfe02023921cb1d299b665fcd28f3d0218f926fae13588607581b10cb4caa9d6875091b70279a3496f507d1d95dad409ba4303aa2a2683dcc4fc7d1ca2128ba5a817c7913851149ba7fc74c65436e846f366a72446e7f4dc1a130b4b31c35935b1b93f6e89c21220352a28f15cf24a15df768ce7308e87ba1b0178cd08b2034ba3f145c19f5027cb856de1b135fb859f5e5bf3bf668ce6a2edc7d4fc86de05aed62e2be222255999eeb387b14c0258d6085efbf4e0547569d5c3584a3fa774dfaa7dc6f1f094fd9a5d6f8172760a3a3830ef9833ffd58832abe53925fdcdf73a1838fc4db4daa7290bae5bec52492a9fbdb49cfd9b25aa7240ddf7a234b917530aabb4d2fda672f8fda54f93b446808389679816a4eb31b869aed00591da15ef35d47186b7d3ff14638c4023453a6f12920be824883dd2f8ae99204468115bc9d7fc8a14789856ad76ce7c01c82c3048febb5de5a659475107ee42052cbdb3ea50faeca7cb346cbc2d9bc834ead634580820f8d2d9ea86591467a3dbd5d06d6c815c04835a7837b98dd0b84f27ded94a930348dab3ebd1f1d1b01d827b157b31c597814ac4ae4d420ddc642f6f6ad55460c2df39245f8a7fd25df6b1d0d45ce903b8f29801f7853bc5f51a3d40fa0e877b64c5c02c87094212c3b5c411d723fe37d9bdbba6ca51fe124b41dd4e846dacf6e8ab84fc28369c85ba4e511b570512e6d4ceab62661db9b94bf7eec4d943aa8a9eb9374279f3a65204d3a5099a33a94a5c07c17ecac646900fbb673feac7de5d98b9296d108ecf9d0acb67384e735b0c10ef5cbaf7b8b3d7d6dacb43ef4903372d4a831926f29672a316db4ad07652e4656ba3e1787ff6ae0c06a830a5023f77e87871f4c3bfc063f8d89489ab073940b1b552a37f2837f61d082cb27ad77e86b9a5a86fea487675b1ab97bec96559974720cb1d7406278358943","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
