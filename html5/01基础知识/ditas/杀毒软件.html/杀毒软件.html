<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba3ef8a6a7a1aec5f06c9c7358ffd957452ccff7c8ee4d7ec7102f923196a1f53012512635b63662036d7f97794b882e054f29834972d0c4310da790acc73366e54b67cbf02cc442502215237f6c9279382cd9ddcc2bc52852679663d3a140cd457cf36ec07b5843320b269186b963855c137b1c5db08c72fbaf421b8d741374c3a3f5fe98106622d4300cf523fc765cf0f9d471579bd1505a11f51e342ea8d7820f133c0182251f70434c2952b710ed16028591e4fb2a1907f26172b6e94c2569341121efaddcb8196c26e135adeba14b2402c8331f4abb3f04e05da9aef871b9f9350f4086c47d85fd7cd1fd27864444053fa0a948001faba81e5372d287aa81adc9c0d08f4f8becf70db82312aac3f9d0115f3b1d97b65a9292ad2040a557247e2df71265b4013267e6ae9a3a803e608abfe60749842712de4ef822338ce0a6acce1d8ac7dc3fe3b8ca5fbd452a7e92247e4f4c624a2ce3b4f51cfaba933d9c2aa662cd5c8e178ade63a6b8f5083c264e58c0a7ca864629c915d3fb023a58e9c26fe76909dc4b259a2033aab6aa8083e9efb71b2944905d86758a6dd1cbe2850a6ca7087406e414768dd0863daa06e63e098a1e04ceb36c7ef0cc984d18237034f170dbbb3c1e8cf822d183f2f157b5b59e72c3441819407990f8866fc1b09a13c713f72998f4a7d09968692c0a79ae232c3451305418237688ffab14c3a588556ff682a64b66385ac3597c832845d3abc81cc7cdab5c89bb8c2800a9ceb3d33436b4f58b0ede813eef2e196f7bb8f3e5789fe359704a5506825ee6ff26eb49437d8538d1a059fd650c5720fb2de48b5725bb7a4d79d4e7a246c1d9f22dadddecd1b59778217148dbe714cda12e6d631b74ebe64749081c7e9838b81fa790a0b6c0ea963c5f89960d127d45762370f62f553dd9f3d02a06d3d14b7e67b7198916ff70e2857112108519c9885be0c51b2a63ee7acaf9b5ef0f3cb6a4af587a96d9de459f5a44c5387a3291316301e159f620e53c87f33667259b2121c83a32c42f74c33efe1d45cceb0cede03390021b46bba7e502e0b9d3644781ad68c3b4c20e993874154da98f955bd260b445414b46133e5071f589a754d6e6debae2c151ff10846a135e671b88163968a9ac932f6ed958c6660c82e66a366b7326cfba6351521ed5f5c8a206f7308d80eaa107c661d23311803f7a321eaecaf5076cffb1e0918d1c41e9540dc37bcb25d68d4d0418aba4ce128ce835ae684440f77a01240ca300f5d6d9999d1272a661fe124b9a24a260b412db8d05f992addc69c48f03e574f6f1d8ae6a08f5b2f867ea2ec5c087700e1c53d9226598f05b8d3978d1f890e85abfda1269bd910c814ba4e7bfbd3416522319d2d087056a0a3e458a0debdba37e57910e9efc0bd71889c651be74332a7e9aa523b3bb75c94dc9e2e64a80d6ef98e4b98ab0ef3072b4d2ecd955f50bbd77429f53fb397e77269079e80c0ca9344cde87c0f55d707a890da8d590674204f381c04dae32472b57b559bd6741947bb437caf045fc3b5cb321d6544f6b67ba588bf4d14e9d3aeff0000c6f21a80c5739f5cbb60a07503afc8d05296a4e5a63597a13318e2296e25c3aaf2367329d4f4d0bbc4a9ad6edfd38278616ac51b1a1afdb8ddafb72817fc3041301fd17b52a6e707a0fcc0b12147e5ef7b801fff61491db2b5c82a7d2aef1d6843e365bcf52c2d62929c8f250307064aab77eb6ea07cfa78f46fa1f20ae4b647475bc6d9c0e54d46ccbb1a7f8c7a82939098a493ea5f1f171ea932a60c8f21ea4d9cd612c7f5bf02da5f0b8ba17b6ec71c9301ed1f15c922d8d767ecfadf6a0a112ea8b8c756f2259eebc8ec088d0abe9e0ee378e0f67b05bd2ecdd0a4724399b87845b1ddfaa7b6b4d133a2752dcc7d3652cd6a03af253eec1d5e24494a0c60d2844a7b86709c5319f412d03ab601ee983d3d4b7f3fea6d95fdb07da90122927ac8086ebd2c87e761476f06d336bc94abd1a8ce320cc4976e6e27c642628375be50792998a8729365fed7c52e88ef1017e9fe634a94f77a5de6103849fc703b0b00334b450dc96d39386ba32d07658b615ec0c3bcf6dc6dad05616d09909258ed85dde60e513b88a9401120b405d50c5ec0beb902e2b16760ae7424bae83c665b3bd4b93824b11c1d9d7684818a7d95063264892e2f538834fdef1dd8e572f96aab7c2b51228ef7a910980809a3c9967ff768c3e5c6012812cb1319f4c78d1e0b19c8bb8fca8c2e4ecc1fa6a89897dc248d2b5f391931da706159538ae58428ea3884f25314f2689a80527d0505c41e9f82643a6a35490cc980980f20490cc8158793de87b80f4051fd4ed1e3e2129cc3f30da14f211a34fd84070ddc1ee3f5ccf16e01ec8086bbb4f79759dba2a5b560ebea9ad541ebf529dbb541fb50182e86e30226bc49bcaac3195f575e0246dcb947614b39d01084ee20970a4ed2fa9186d34ab51daafb68961a913a2396f6ba196937f7296d30668297e063b3c0594cde399c53913ca27605ca1bce9a51d05f2699ec37a49b4e5e7556a1c9a87750e0f0c7ad9877c92a820d0619e0df201daaedcc98a584c690e956d78e5dafb85559dc016130070fe16c79dd08f37b7bd4f00baa71fdd8fb9dce15cbce90f74fa5ea119ab92cacd4212b98e0d6c32d2623fef81db93c40d7d8a1660d38d3220b4eefd40c47c1418aaf53ecc8b97327127fc735558338423b6e2e88299404d7f408f7dafae8b13d0518032adcc16c8742843427a804dc6a7ca017f494b0148c6ff58490592b6b7a1b72cf1cfba9e344e33b245aa4cbdf7e03111e3e21d9f59beb83083ae4039bee3de02c08bf9bd18b5e0cde6e05bbbbe4e7ee062f8489082598e93ac33854653b7ae60be5975bce4e77de820fcb4a6e101366d0f1bd3757ce2a380c19c359eaddb1274ad5d79fc7b895c1aa68ad8aa5c71e05234ca14beac5a36ed84d91b0a865c67c66cd296a80d0431aeeb3af4832d9a0f6cb6c907883f18522a9934015cb12ee5f950e151468e92ae9954ccf51d76fabf8aae8ef4ec0c6e366fc3e4b432b0c73c905aaf1735cfff8a274e3ca30d2a010f4dcaa31e690d174bc17e76c6314bc49cc81ca35061086dd9e917881e221d9a9586b138536a4313d68d380b480bd96e44e5327aec4c38bdd62fabea869d7cea3ee23de8b36162bf3d4276c2a9499c9cb61c6dcbaa4f97ef0261f390f2ae17b147e37530e3d4553e8ddae069c6091b3a3b2daf7713d4769735d7daa46784935059e8d16660b3aa438f9ca6d3759f4ecd5acff8d3b13f9c9b3c2639d7da6611e7335b50b53383e2508902e4b2b312a7f4fa1a1f168f502ab784ef68b027d9a2f9eab979945002f02c79d0fb22bb621528c8db44c0a59e3105e7623e64a230cbbc3a8d314772db965d2f3229c67366fe4265853d4b6f97ee001e3c1bf6a507f1e1262d3cb28188430ffc14ff283b63615cf4d53894f6b59991e537243fc66e8a76a252e9ed71a8b5ac2d47fc5a50e09f795abb05c2f25a0f5a3bbd16563a34240b32e04218f5b3c1828ab330e9111b886c5a36a8d690528e67b247a75a4c02beda3cdeada718053d4ff8864d1a71a9d9d194ffb3a7f6549568d76e95aa0ef389095e5487c413212e636e23f12c8c50a560c5b7373433750c2fc96b02aec51eaf08930f479b56149c1f44ba5203e0d68feb972827dcddea29be146ef9362cc8a6d4dfdc478af26e5e452ded0ea348a32c056e57d2e2c4abb168e269777439dcb8d0d136b7e99292b63cc9298949d7519568b5eab29305d03bae6717c2af787efd06b4399a4f5db5ae690db137f38f1228e321a4d5e887d8f56032307fef601d1b8204498c510ae2318c46435cfc411e6eece0e7d504f68a5bf3eecc002f09d884949fc4f336c0d76da1d60090d31ce4e815043d4bafdbe83255e1604ecee714d4ba4443cefcb0e6965d0b7e357faa8556b6a4593b64096429f5d007fd0bb3f4d8599ff5a57baeb5df33e608c5bca41f5e07e10c9d9aff8ca0208f49c1a1e6b163ea82c58f304622774bd31144c4a47aa0b2865bf9020659e4c78ff6b67f0edd0fe4f1ff87aaeba763e8488ec1fb41f683436cc8eb3c22bd500bf4dd967a89ca29ca9d4e5838804a14932758be2809f24d26ed5dd82a58b1371e9adef479e6a60ea85696e687a9ab28203c8286e311b16c811a9b47c5ee9b23b50638cbc63a6875fb77d374ddd03eacb4d12f4fe659d9c6cd7eb290e8ef1b05d35148796ba0de2f27b54cbd7c2bf604cd494dddb80fe74bd9d1f6eacaa730ff4813c834e09388189f23cccc40875685723f79a7669c7f0a3bb53b06a41d3e03bd44145a981d30d0feffd68af8c8e1faec6b1a54b13204aa7ccde96b7642154ddef9c1d7bc9930c41d52cb34e6cda8d8a02cadcb0c1fe0ca210bb2ef921524182b05c07ca5f5ecd63d89a3ff1dec3f6efd22fbf9f0abb2e2d44b59181c65b8b6951027d45bb4e106610986c8df1e6d8444e69fc16dbd21e92059ad349daa45ad3c22ff96196c0738242812228041d44df97df73852599b6fde3e5e781447083361ad78fb93fb632d83c39911c0554796408b0452b891efff7e937be2a945240ad2ee3e3d3a66b68d1d3af4b8136ecf00294cd4f97a0f4ca75969d679089ca4db676176e143a0cad0b2f61c07c2e11a405f20869a918910802e5b2b6fc5769cb3d0d6cc1a9a4d1136d80cc6b8cfaf2185c550c85f0540e4d689be30a8e9a932ba16dc92d66eb88355099a00ac689d5f4a664f92e8128446409464b4ad14f44c4b47076414373bac9c340146f5d8d23d3b29110a9946da7349455b832e20fd9715b64070af8370ad17aa487c377b07b71790f1f79bb5a80fd8439a320368873d10bac5b8dc11c965cdf13cd108851a69706dd6c1616bb28de1b159f31269c2bc8eeb31150ede0f5c67d6e608891700465e3da9342b3d1da693f850c0d09b92005c8eee91aa99c1dc32a4f2b0e2f481e3a10ec1a364935487dd25c2bf8157ac4f10f3f013a916a8d42f6c34392c389ee86a3702e9906b91b967b08117d7d38c9e62e9797675d6a7d6cd353f941e4a5c008685835294584c79147ed2158446383f124d32c6758a9b7b55b467de180295654c4de766ec7ec063a7a8e289523314c6fcf68c5cf63af4cb8a113bfd080b6bb3bc7149604b19a9e935ed37f6061a9211d0f6d0702cb045f0b5653479cb03bf181165416fd74a2f0c3cd7fe9d5023a2e0f4cf62cf6e7b9577ac4bbb2bbf996a092b1fa8b01d2359b15d7f3ce0a179c2d42cb696ff27354bbd63ecf12b561ac33ac33cb6c76cba9501d3db3280ac92e6760ade0c9880cd2f1f839b12251f7e6a226bf9f184cc17890a00efbe3fccbf3c5603bbbd9686332d8cd3fbfed6be107c549c81f5f56e36ae7c301b6b30f5b32095141ee5594ee737e213b279cad43797df7cdb4837ef78ea982dd737335bb0767c37f760976abc30317ca3500dd61ac67cb1bcff1847a20463c5d914507a827b867e530f888a03a34fe67e7d1fc3f5780d3da2d84ca9b77660752af0c21ffa85bda24978a3d348de6e7234a326d1f74bf1f77b8bed59df5918a75c27667d9a7e8de44bea782f4096b7f42c8e29e4053d82d62c3416fbae476b50afe693d2658829b2c7440824ef895a88d79ea44187b2a2c45d9031de12c2dcd41aa64f5bcae77ac2290c856139b7e7aeeb686b65187e36fa37828fbeeac632b30d3e7a0779267112d4a90fb2f831b5a49ea88457adc23d0a8cb1eb85402673073af7c991ae445ea3639573e9866717f06e05fb673e89214ddac08fb8bbfa1de36ab515ff3773484709a1ab8aa5d8e2adda6aef1183913cca5a991ab171ed71587c2779d7f83077be5e8b03116e76396015dd4b80030ed92ba4594816c0a7ca00e46ccba7182211100122797f6474141fb3423db67f70be8c3fa7564d3fca0ee0290fe734a0651ee7cb6110d463772e60ce499f67ff61c2bf28ec6ad6d170e1a357c42b7216e594a31d130b08a2ca0b44c0e0bb1a0a845dcd5abdd95393f075814bab8c5014459dacdadef4387a87a07e930200725a877f044833afc6ff4a781fd555238fd419bd2a8e1ed218fc531f5a0f55567f6c19437d535e28f52cad8ab317c1f1f426be3374acb3bd145518e83eeb5653a6c619fc7442fc68229114878ed5cc81d75b9929950bb03dd3d85c54c6b3d1f4482de280d8325ad971c74c9b273c4ddd4dc4fd15e8289fac85b9bd60f694439591bc9499708b2f58677549c901ecad1816ec35459fd6e0f82b7f2299a7e02510e5253bad9dfcbea031f66a72485a26587d7919efdc7fd2856af0a462f7701bb8a2d7151ae808c4a5b47d23f12d32386bf5a57c9b8acc57f2329ad3ab5a005f6e4a6eb310c6440b79d5cea490cf5fe8ca8ef0a277502f55898a2796ff8bbf28a059ad1444b8f3ee9f8da75d1d81527e0da5cece16f43a02cf1e969179ff7017d7870bb1a7584b24f3f69f033045f5a32245524e6a896592331d8e721363a05b40ed0c4119722b081fdc034f492808c1d03b20ba5c0619108535b9ffb41f82e56513c7db9324bc1c6da16fb3c58d13f01d1f2157fc511b091ff025d6dea7ea2d8d4f4dd1a1c4e6af961a59239bc408efe749a0a3c4d84416d7667d7ae5471bcc09b666c8e4ecd742ddcf8560247c5ef4fe61c9f62a7f3e98eda30ff8c7d2d90fa490fde6a4c34749c8e6516f15f47a0598a04b3bfe2a1b37234135256ddeec58b2cff269397ccd9765fc6ab432cc3ce50fe1b1420b61e4a94c3d5508c14bd1b160a82a2b272082bb37030d9c9b38edf1ee5b9920c4ffa00e315f93a3aff69ebe345373ad8ebfe3a438932e240d9106fac4308683e63c178c05f6ea7a7762018edd3e96ee069295012c647172686337f87d191814a522d942169f833d6d5241df32c68aa1b6d0d076ce52ac62283043361f3a2fb627f4d198af0b20d31fd2b7f769b1e58604b4e9403235a1dd8a19724b566ad6fbb0920156ab413adc861d165f838887f479f58464dcfb0e88592d1e9e3d6804b67f0c59e072d5a976b0b53ea4335212df7505f0b991cea8c773e1786f8433ea42a17e96790217a35723ea6fe055ecde3cd2d4771fa06b36fc4a5515721638f62ecec75ff838030d707d8d08bf9467dc706ac4f3e3059ddbbf4cff2bb7bdc0259dd1393171b3dc8d08e6a8f800d61a4f4b235e8d36c0e66d01ac09a468b2576e8ade75aa3967d28dfb2309b906e3091b15c21cd35e4c5f756ac8a44aae0af6ecfaa3a69e6ecf765bb85b5c93e8be33ca1f23fd67858f52dc87915fdedb649d04e6788e20f6a37282d5015e590652135ee6d4738f8f33b40c8461b85bb1b2e77b9522812eaaef3a9752e45721df146ef08e858dc3e2da4409e40db6f892e29c776be511292ca80f5b32fca5fb43e5759f54e46caee33c959488801ac0942a62788d7703e981940fda73a4bd0b06aa4cbbd3d1bd16801915e908b0f99d386dab771f8822fdb008973d11420a10ebb356485f1da361913a20c691d8fea3f1a0e9584e4c10d42523f6f13ded1b0d2720e5cf0adcf80a75788d32b2ba003a14f63302b63d57185b4dba278b977882f7776d177c03e031191d822f158d5e42a9dca8fef57e0881aa6c6c2a1e6d6b3ea25314968bc5e9148879f987b4e4dd913953375392a66357f43607364f24100b791628a7cd25c9fc4326be9914cc2aa47c9953f43fa580587a31277725660214a474bbe36828a684d23fc6dc4175635e1b782aaf18d2f6b48845543e2e462bd5c979c4a18dc2bd0d590736367c355cc49b6b2c5edf153084e514b2aad91cb5a85fb8821da092ebc2ca6c4cb156bb706e807d5cbc3a294dc5829bf95b1bdfd1e6a8a676f34d74652f1375d7a4a3c758be77e3f6e84fb032efb48ab138847edd5a4b8f56a74945cda1db4e348d3a251342370521580df2cbb308da9a07539dadfd45f0918c0814b0bec07b0786c1c8c3383473d2c14bed19a835f1b3cc68f16f55c0c94fb6a099f362c40e7a3d77ca7158e60da55ae6491f4c385f8333e0750a71a75a9f95c76551f0162de143e3beca2908315a32140639d71a2bbd7315549f72811f9dbc60d9fa0f2754e5b5b0605b57379c2fb4caabc042ad6934e9936bfe820cbe3e70401212bad42e6774eb3b4cf7634af21e5278c6bd9c5bd289d1371ed339ee55f29db638105153c80a75981ac0e91a12d21bb698205abea614f322f10ba35ff37d299e1519c54b849af8f2ac2307cb969b9daf53a084eb3ba5435dbab4cef523b447f59b5a6fa9ea6822d9ed3845f041b2dabf0b4330d2eb4915bc9ccf35285f080e138e113d458d866697576adb9daf21c7135fd3e0a9065a29ea6df97bc8865d33f74e226f96beec49b86c2b047d80faa6ecbb526a36f257e1c4b5cbde6d79da68e9dba39d83879ccc1bebc3c7e4968efea3264c50ae7d25b9e5c1c7959f724197ffa0b2c57e13fb6aa88e29af8fba150012433fded360eb85dfa156e3be0765541d1596c97d5f14db484a449c898646f29904b1fa044ccc49783c9ac75b6e2dcefdea4dac2e5803902e2664f2b9b1dcf3eefd5ddf12faffb45b091f497793cbaeb9b6c6211c820f390057fd273dcfde8b0c0904faef67a7e7d3ae3d78d21b74c48fc13f06d241c15dd356df5df1f1741e0115c9db7ac09915955d01b51a014a3d24a7a9f098db1eb5c969f37b8761b4a4df37ec17ccf0cdf377471d153c64e85c8c042308f389c00781a1f6cf3870e115506cddc00a2f11d6bb66c536bdf0f2cc3101320c0608848669756dc7fb09c31dab62b8914a8236b2e1b7431a53e4048b01a92b53e72ca608059e23286bd10ea8bdb91c626d555f5ed311272e95c7c8cca79ee4a8be9fabe696e83688f3c9f6ffccd3fd0130796f5ef3f96a187f61791f12d1dbddbc65f6593f649e886b6fd67fa34064916145d41c78073e9d522c57fa410743aa8a599a637325523c2f3e26e2414c09ba1b1db39d582b2330f673f6d13fb49d032ba2a538c37a3ab2f530c267f7b5f6f5c998c1de820ac208eae7b1ca6da48dd7f1597ff76f5b3ab9e87382a57cb7503fb5f81f4d5e7e335f7b8eb963900a009d0699fed4693ddd6d92297244e625a02887894cade5d25a5e7e9e6ff2a2adec68a08c3550def46c28724350529269839fabd72ae5d425ea9ad9f06b1c7f79478bea63d2ce341fd2316c800fe4c10b9057838f79cf250076aaa079952032d5892d68d2713a666272a98a17f1dfa3cd312313f1aac91b9647ef0560fd3758511afae871d7db2959ba9c479ffbc1f9cf635a87f5bc84773f496a25dc5f75c7577e706ee8543ecad67f2bcdb347290c9d6caa3602d13cfeba8a95456796a0a74bac0c28dbda3359e648fc1231e46ef78622e93dc27e5c52e630c2bd42a1472ff6d93a6868863154eed46172212c783b95333a8bc77c7168ef616f26048ab5668063a1aa5430e2f4d5e41502cb5c1224e7610158050340faa2ddfdff826cf9ac13baa4b6b7998a4e855da74fdac5028339dc26ce1ea413af6a83c61ea87b47434534753c5ed58bcabb615d034a9774ed17d4a13d160d6e68b7371eca2c45cbad20e6a42c150e9d248138cada7b0d45a99e4fba349723ec04670531a006bbe389b872e32188c696f4f60735f167fc4eea5beee739a45663856bf697c71ab3a922af62a57a1cdcf751de3f9d160a4b3084582a36a8c0b296f7a700b15f2f0d6d83861e94fdaeab11a45b8eb07573c009750c257b9be4e2ec128b92ba46e3c7f58e2020697c2c9d2026c880e2bdf07c09385b7c33a37f0e29f00f47d385a2162d55d919b963408b8a4dcfdeb8435cdcd4e4f4b90f0c178f99e6e0af190dd9ea01ec66f08c83c2105a9849e038ff5267e8dbe445a2c9a6a0c86c878a9b19b78108196fdc247fe5321812ebf0aa4e628a043c773b5ced2e7b56c0ab826cf9040180ae3ac1c07f59860e705a4d2713d89cf0b37627647542b409a56f07c70aec73261740f1bcc93aa41281dc3e8ff13adccf0044f74ced46bef72f3974445c61416a5ca350545c6d8d2fedd244856ec31cf274c274a9f9ef5d77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
