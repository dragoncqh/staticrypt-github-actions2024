<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d06cee7a57ff203a16fb2b2e81f5dc978ed4519554619baf7426dfd997300c0fc7e6904f4b19815e1da790199a17aadf8d91c542fde6a738693c130cc90df518ac6df6fdbd197f4b151bfc65c85e6349667b7bf178d00a8b8c36d21a0f6e78e30ce84feef7388739340a6f2d2faad7f62e2f28acc104c0fd9133aaa407a712fbde549d6477fd8817325bcfc80c323c675960e5edd44826571637110fcd118c4b0419575c3366357a18e6ea3cf91e3d4c38dc9b9f16708b1a55759b39490a2a680f17c1dac4bf90a12abcc28627be2cfcaa9016903b66b4c127a99ec799935685132901521a583f589d7bb3f2255eeeb27781c255f3066e877f8091220be076f36443c28e4703a7dede826887d806dcc9b7468db90fcd93cc68cbdefef4d583196c764b02314c9c925245a679cdfbfee8d2e12ca3adf208a7c56d33214054785429672541d5b8de75d4b28b26f48dfaa35c4717b3e1ad2d647e0c11124bc0e17e109fa668cdfa68f0122bbaa9804ef45814fc22b876ea183d3b5946a5adba99b648eea8978238d2dabe03878be729fe770369e8ecd4f4e7dbcea4ca86335c7792660f4f76ba26add6aa9e2f1cebcf6b5d34191b2ba7f852ad93723941eb671d0367b704556b859df21ea2661fd9b14820051d4dbe333b3104668f00da86ce19caf7279ad61919b7fc5fc50abea1c668cc04bbf77b4e063b438819aab0b0ff98afc1b70b0d5ef0b7896e53b956c377c42ed3e06b29f663e3c9c1130c4bb7b702b57089c90af194a0c65507b5e38660fa3c15c80f82dc226e39dfa95c98eee84db77fd7d8645f367b027c33d99bf3eb7d47e11c2510dff2419eb3cea5f852d118ae568a0a2901e799c762f20ff7ef663363e41f9a664ca4911b5fe2c3a934e91ce142a441a77f9c7155e20dd4fc9bcfe9b824c1ef81358a9c7619aaef6b5338c550183920492e594c489eb5a0d39ea2b38239d065201d9045e7a24d9e641e3e15d04cd2076d35eebd7e253e68a1bf65f249d800308fd5ed346225f08c87e7e7d76457b961a2a244e03cce474256e3467ab47629bc7f617c6169e4e91bf4900996f147259962fa46aa55e57dd0872fd8c6bc9d4dd4930688109dc31b98b305dfc37d19e92879ff38c285af52aa51bd1779896639b913c346e66abd737fe602662fe5fc517e7fb2be7fcf4634a0e517b6d0a9ad7fb680c4e30a71501e7b95c45068dfcdfdd8d7b5171554300469db3663380b83ddcf006a074c27e32aeffcfa804493780cb8b2ee5c9f3828fb0469d87747ff1168fd3f2336cb33613b26eb620ea27b9d98b46e90a1c45f3e3620a436eb672453d4b5c3bf225b430dbb6da88ffe85332e67ec2dbf97732045e9b75d594e845ffad08bcfeb023e51b5f41f28226796cfc3f392975d6a64b7a31c4b8f9d7fc425c6aeca30aa3480225de12ee20e0ce75d098e258fa06189aa2655677013ee76a74ac9eaa6b35569cb7970996b887cc34f4acf92ccc03833538d82694d6c087319f57a971ab48bd2add7ff6856960dfecb45d1e5829b1774015c20b0d4e182740d37a58a60ea6c062bb897546610173b30b02ba5fd4059e586345861030c6ab62c42f7f169878955c779579f7c39d32d60306b6c2d12d1df96c8f484d434ecbaa13037d4ff32c8594e615371be82916c4b80680174904268bc50765e58c7910d4c8597f276569d2898cc0aaa608cd28e19ea2bc2a6a83452bb56203321d95786f02fa8f46d64634ceb7dcddb5bf1734ef271088cd99d3e7400d0712c6627b753e5506952f96d2c52ec6d52bdf2110404f6d0e76fe4b3e94e86c5a3d605cdc33253d2600ec154ab2bb2121144089ad65a7ef4b7f2789a96933ea3b4a5fb64dd12ec011a7f1e7b6a7be82099fc62cd83b24a24580b66381ffb0b173860b2cb5e1e5d085179310077f8c72461eff757a5f36c013173295b2e654b741ff27482cceefc7be1329a1bc4ea0b2de6c053d779a95f3f4c3654fa97de9b7e5407236ffe26a4422ec54999cf2473899076a9ea364dbdcfbe040146f3b30990f6254ef69563791533647e622fc924397132ddd1ac658ffb88962965bfda67fefbb4d9e0d12b951896d6605aee0f79c5678a90dbd64445d945f3d9c819036b99a13a8f7b636097be6df346eda6195adc0a16201e3cbabd010b12ee51f1af9ab7f296bf608618c180a74abde44cae7e70bfb967940c5a4fd02b4e8c56395bf330736d5372ceaa5d05be0a67a1ff216e3935f0a8571358a06746c828cfdafdcb846a3c1d65e729eef67819cf25a8216bb18db04b7583fca7f60039fe7d15e8c39c59fec01ea01fbe1eeb3b06eaf31c291be4f1c4778f11a9f1f1c79cab03027e6162101d43488b2240182a9e67f30e0926e56b70e3b7b132067a49e90c4de2dec3f194f6cb1428c5918906478fc54aa91d8c01d6d681579928b3daa6bf4c545814e6bfc00b22eda9789acee7313a0a3d3c0fdd5d29c256ebd6c2ae1d1bb551d8c589d834008c2b76798d78c0900aac1104af66ca46b01e33069f4e406e2ff8915726a51a2a3072aaf2072f53a8e0fa06fd8bce31ab905432c6fde3b54932a1b6b79e30a2c7c09bea6ade0e47afcec42494952c39858c34c6970408cc2593449b8dc45a426aead9912553b91f063cf3a3002933d0b1c2eb5b0d95ca20226bf6b7e9913828985348059c1189614258429c8134411f5517f98c94b28a4eb76138573cad9845b16f3673716de08f7dea9ebef19937605f42cb8993e840d213218d718a69532e5da96d305e0a95e280c488c01f1e0453cb683d9c41a669a50a752aa31cb985bf0efc5b4854d4645633c14e29871603d0add04b1c73a8b50e2067e244eed512d30f10991a51476d8aa475fc25231234785ce7d6e2c586a66b5f760d78b57902e8153c03819d85754639c3c048580acfc4c1a399b762fb516e1d8c7b53f15afc6970af88e00460d9337148fbfe76c0b36ca6ffa63517ac5e0ef4284c9df1212f6fb2283a1f12507a687f678f75ed0f093c6a1c8e61cfa73535a77a381d69d7b44e06d3f33e65aeda7e422604ae1d454b15c89f07fa99254281355fb038f3e00d6e1c8c9a151aeefdc9284048d750d7c903a87d298e28de0ec0d6e9a9ec9e141635729a919b4a2e43021805b6c8ac4282ad9a4c237f9a3f8624f697bae36b66ee447e504c1e7faad3cf7b86e7d42a6cb14baa27e91825fee86c48fe88ad7816faa19497814410e9b2d7502e697960fa115ff3ab786feff5d0ffef53c1601f587f25173a059306860dfcc6359dd558f0a539463b36ca024976745be3c115636b72159c71b963e9ca386f6ddfbcf40fee647ad8bc195a14dd780e58cdd2410135c0425d42f7b0730745d3eb2b5118cf9d9a5f762cd03dcb6dc0a42ada8a22ee39697880942474403021f272e8ab97e7129492001120fa7faec65f45609125d614e4337b20c6ce2f09e6fac74d077db879a1ba66e95ff1d152640baa850d28a10e6ff5cda28f1882be4fbf3dbf4f0bfa2ce7a305efb4f3b0c96d406d886703dbb099a611a985d173984c19c79d42865479c40a964751c21af9e52776095ed70ef59f254251d0905a883c40b01d07b75d11218e1dc57ef3e79eea107c19c44250177c429b629ed7c1aed32d6df17eef90b8467eb9e5736c101a03adfb058c49f94cdb4206cb757f0f1e349c61c05944db952126f7929769f488dd042b54aa7b5d236ee90d7b0beb8db05f386d163d073bb4a204b47666deb64374caea816bf5ed7370500385d5cc415a92dce6ade75c9b26396709c14f5b5dcc8dc7b39aa9c3596d787f042c455d7945a8951d982cfe061627f1b91c0218a01dd441cbac3e8163717e1cfa0337de12088055f93965467e54b8a940bfde198614f3a79441b21a6a6cc3810b762061a6979ea8de15feeb2cb50a3be90ed657c8fe38b7d51e21e23ae49b38ac850e8ae97daa519c44357fc3aa2309fbecec9466a99d723459b20d2761d5bb629a136f985eafc96a361903da8d48f0fcc176ecc80344ef43365ccd5b3ea375d6b3a491feab27e25d0b89edb1638ad2a4bf9d340f3795601a033fd680f8ba1afeadf82858e6e8e92b544e7117725853e8a36aa6e193905b81d24c82e07c16cdeb4101e8014f665ac1eefa5bebdfe119a7fbdd006b04507a92421685c20277414d6ede072e885ce469abe51792cacc3485d3103b5615e5f27a4d4e9625e65b31241de9e3263bf392413d5aff779287734411070f8fe1b23fb8d4fea324867368551312c7610eb8500574deb42f6b378cc4822ba4860ddee4a56dc73a29932b9312ba62ae6f37c8549b2c4f890033014491df5d023acd22ae953a6771a3923456011e86a12015d2537767889e90787ff6fbfeee54005e8d4516b3f4c0b8071d2e73238aa46e50a23cf41745baaefcd40e797a50db5e35db04359b82c8518ef5592763ece125560c37026d314ad70c7c22c968e1d688356f05eae00e3a81f129b99a7d70b641a882504e389868b33c678d2dd3f0557a212cb65ada11069470983dbd9f480ed479ea10fdd8bf9504b5246362e99cb615bf9844446ba405eb4f578dab6e12486da6d2a95bcb8a26b6a5e78b34d9745625140128b6790d2483a4160a72882a1aef2581192aa13f524c7387745a7f85b09bc81b0846dc7d54af1c4f1ef3d9cb148a0c2e701c844225dc3745e2bafdcd40ceb6bec83ba5caa5d28e278a60069d24f42584c74deb0ed68addefd3c914ffab33f7bced22305b557ca5b3cfee4fe9574dc53c53525485a9bb3e6757c95ec40440e8fcba5d035c3037b7074eaa52aae90de6423e12558d80d8ab3b7bc6a7332a513500b472e3c40f6429cffaf7c804dca43e96efa42e5b9ddc31dd218ec8ada1c9ef8e95278b7bfee2d97007e37bd633943733ade28555600d74c053e0193f02abdb1f11844beae813e892453b75a5eeffad5d80de9063ebc8820708f0f43a0ea0e1751e4a7644a62f6111ee63f80962e3473010fe61133e127d5ce93eb89393cc36530b026d0b9acd4cc1c71c20893fde4e90441cd68cb0c937b08bbd4c04cae714dd8e3877dbb82a54f1d71d5bad47f3b8bb4974cc6fd7c19046a1331bd2fe75d5ff01b2095d31179f84787de5f078a599ff22db8414874525016926670219527dd592e521eb2f0d2939c3984a232427b32d3030255d2a12342a8630f7967074acf52a02b9fc7e6656c5511d5510faaa14ffece6f8e1bd3d62850f6f7a7f0969454e17c5ee2f5a8b128422c87f752d766c420d27c6e071e8b971f2fe82546ae604144e5956ce8f5c45802d0407ac084f50b15d00aeda6c5f01484ecf8b8fb92eadb2a6863ae6ec6c9daeceab002a3149c3b8fc5f84b174a96557cf3c911ce6a527c900b684b6d1afbf06b54c1fc57393f148205839f1b03efa6da051e5ff8b7e663e328b940d789274ed2883bea463cbfa6600f855d99bf6dfc39bef9759881c2f42a817a6af7c42b9200c4f3466c99f58d193a81cf60821ad69357f94eb6b03ea3db7f5d152df09a85b9311a07e65a9ad1b273cf8764eb96101459c1b1dd39f049282f8a49b561af6a26986759eb84b48164e4232d68957f1b3e6e68d3d2b1cc5ca8861a2fd5ea747bde2ca5992a4a3080ece3d2846d4d65ca436f687cf78696fe075e037f18d549b8fed60432710ed6b41b1ac4fe660dc71a56aa8fb2449fb1b0bf4b3c41e7edd1e987f9216f84ade2f021373cc0f29db779394a4cf6688949b0dc097db39fd72acf72a5a8c9705078efee960236544576cf7daeea748e5005a129166d26e8d8d43397b9d11ace26274104c0d0258e367de786f46f9ac4217746db4018f1f028a5d626d1b8fef3f7bc3022df3db641136dcf6e96afb6f455e77c1b5ab7417194d353e4921348c17d8f214299b46d01278b7631643967cd1e22a83b6ffd95b2030c8f679fa0025817e61e46581b7953430255f1e14e11f234c3cb70072f0fde105dac8cf7b62d5013df0710005dbc94ffcc5cd5bc893f08bcd0b7c21d097eeec6ea215db3b566ecc43cc11e39e57790a47f39556f637aa246c3f49ce0d4c06c335a7a85be994b4f853a41152d52b7d39eaddb02c61703091ca20843a4ad440bb6985838e0bbacca9b15f661fbef1dde731bed440dfa60ca53632342b83d0699d3f54ef9158c87033c0a6164aa9968b40e466e8f41f4ad96ec5467d60297127fb341e1a03517c01bd6c32b54b408c411f46062b2700152b5b504e2771939f81c690c87eb4112c53dc102be0b4c67b5048e9f3fbab176ee7fdcffc278e50c82ec103e8a91cd53a479a8fde9b26b42d12e0fabe125c5008a3974c3aeffdaff61a933da8cd75e1c59fd5297d348e5daa7f3c2247e1241476287188ff9927b7241954d3f3847d962863c850afbc1be307ffec1d9ac493ec0bbae3f92236f8d3749abd5fdd055bff1e48b40c9841c57b598b767e5a6932640aaccb0a76085584efe385c4da8aa3d6dc1034f1a3e89d012027e44d7a9a38f1946296f9ac0e5f2271c92b36933217b39c0b500deb0bddc610eb3afcb8722343cc51c30f68047c250c12991204f4c1ee47e4819f6c6b01f772e58cdad7c254ca0bf2d2fb0135373c5f0d94f1778cdfd6500398f15014aaf53050cc132bf8975af4592dde82b19ee733b5fedc607ef432d4715f0bcdba328501090d8caa55094a046321623f7d7fa5af3435eec60fc3c18b01793b928803a34111c8f90559e3f6e78658d899419b9b90ee9dbf5f5d08d4543b3b1df7e7098cbb809a6c014284365c7b871758b94fbc9c94cc9e05d3751d52d9b6a651707a7a765b4c491ff0c36dda48dccd3e143f680f2102de1b3ff4c4c3fee9cc1a3454407363d423c73d6b6b395e87b6aeef097df8f9973adf073329c7ae5ea6b011177472739fce5f3f547c6fbc3ef66b94bd2b0fe6649ea7d5de6a63be57e71b72922c285cbd15ccc5949bc536a1f384de5962de14c437a1d1c48ce08ac565171e9c3760c07930eee5e6355b2a2b15939c79f15e6139be77841f627370b5451814d08a7d36531602ca9ee1238f10762fa937012ee81fa05b8a9649a3836e2da1f73622fe740bc1aa663e3fbfb7505ffac97c8f34442a99d05e8c2b752e8dd2044e347846712a9436aad01aada979b90ea43a22dac6959f5ef7b25799a0f7e2d3a8759a3fae133250e3e0cb2f669fe9dcd186359186fb3d45f1d4ffe5d992bd7c1fbef934f5ff34bdf3c066ebe1370ec91fff1846f9954a49d94f9872f03617cd443b2810e62be7d9cb2a2517a2328382a883a5102cf2cf0ac669481d1d66bbf60107aed9cb5e91e4afb69652414ee91f435ba918564d3e1f065feb00d38b696234428a0e25fb3a86f21678f6c319e7b5f09280860b3c17ef50b756718c00404a03fdb5eaa218b9355c645217d285e80b4b9553ad14f6a1862e4a938292402b9cdd56f7463c9976d7100b9d9152ed59e8d68c6f3243cc9c0a2baa9759d226b7ce747d272b4e7813d6db0b6aff26e4cd3acfc146c11d84259c399bcafeb133d6937d11330f7e53dc355ce4e9514a745c45fe2afba87689ee6313771300c0734d450f406b50ea82442d456b83ec4e2dbbb8cf904e942fe0a4aa650655b5ae14a86740936519a016e4dad4fe549c99ab50b0623b321296ab545692a8db347e53adfc8fb91ac0732318fe56b20c2ba116d5604495fec2ada87f3d91fd679e90aafeb63364b3c1f22ef9ac5653d98fb4711bb4e93fb5f4092f7ebeba49ef0516dc7d6b59dae8cf19362c2fad852bad69cc08d47dfda1f4a1efcb7e78d307d40f00b381c174a120a93ef472553a9b2f6bfd768ea65bcdee2e155df2dbafda197cc1308cd702c8796584310c805eb49f988ac30a8d610d25f3f7ec62bc940a47caa83d3291df206182736ef737f46043d49224da51e5a9278cddb4f255577e37615a71bb1f38eda8c736b2f66dae36e7326139ed5982e5ff01de4dac42e71c69f85e6a9833d0411fd8d2a2bed84628c104c502a0ace4deec1069bbe260270476ffba411d1374718ca37bf53511e53f0bd0763f24964787db0a1c9d6dbd610d3da91c674ac2c545b73780ee12ef8736561b278c710c94611d3bb7158a503b4cd57c6bfa92bb5822900596ee7ac22f37079c74292c745e758c39509a02bee8737399608d8ed2174e8e62da53dca7a49f60d43a726766cce30794f97d95ce33d67a38ae312bc716b95c3c81f887b5ee03324b3296ceab15bb0679844b0a73df1260b04810acf34a6b4865d8088f22da1dbd2fceac601984d879a484c9e5a2e69fa67245c04f913253f0df1be50c8bed083d3c60065f1794f58cdfbb481fdb08368dbeace36114ab5af8cc35a4cba534742e30a70fbac5c2419ad3daf553a8cf4f3cffadb3c12f6d54c8e956f7ea9b9731fb859f8f71750cc4c9f1802fd7a4a94c8664bd9464a95331fcaf934d01ec7b538cbbe2ad12485b41e71b0d7f2565d19421cfed0f1a9333b2a6609843239c25872fdfb062e1e9f5ba607fa5869bff8219a67de69fba50daaad89b178c6d479d9602facc9373e5cf2f182f6fa5e931310b22a9c79a50ce59ea41cb106c853c3eb0e707ebcb712e2b2e23ee57de03718fbd3e48218443bc987028d01a2522197a3623a209324e0c8320e5bbb61a1a0ab8ff921d2b146aa795f47e97aafdbd55645a4836d0cade92fb2c475983c67f8ac654ec2e2bb50dd401c8d959f046e26f635d505791693b4b6f360d4e7d0242a9796f5631c11bd63ff20cf4bb30f25f3cb6fa44b5f465bfb8072e21b68101e1479c7352ce9d527565a8fab508ea42f7adb0fc2df2024db624287b475e49ec3710cba1ed90140012ab0cfa2f60c0f581ff729ecfed2335e1acb78b9310862312a880b5b48267cabb770ab29ef93a6fb96a7cce8e96d639e5d65292ffc86c9e468c93a42af9d192ee528278b45726c4f4baed3849c3615e978827c6926f63999611d80b0af9a81259df1bb6b5455301c64194aa2a7cafb6ce689ecac104de04d86afcbbaec8119853e21b6e2aef9bf1da523d384c28857fbbfb33ee94b325eb9fde384a16fd95292067a1ff4951ce5b50855aa59544876c655e7c4a19ddc5e625e151387073b2cead51454962f8b6b3b84d14de3266df1637e64cfba7d05bf87e125459e566c0f865a6adec1791bcecf7c91292c3af86086b6022200ac1e3641aadaf56eba1af4248ade01a6fdb332be115258d326ea2576dd91047e4dda49d8b7eee80f8d705a839eb55397725d73e8404b82c504862fcbee3f037258688da09ee76295f04f29ed068259379bcf863fce3e9b1491035ae2bed87dd9a0edcf91f1ac55895c73541576d5cde09a9f6e65496ed3c3fca6e18cf1dcd02d2764bbe056f097bfa02600a11aca524fb0e006026ad4e7ddce7c2cdc831bd6c0fbca25724d70a8123d0f00e77a16ce267a34655ea78f55ed9cf6c7aaf0854c2ca16ff7d5eadc8b13e6ac1ec2891ffb44019f7144b21188416f709b39daa6338f52043a3203f1cf7b6e05d3cf64c1137ff9abd8e06b08a24d1bb403317548296d72b4a7996f69f280f16d6ac0466e9f4314db47476ac5f8f16b75eaa5fa1c7a3327f2e2a029ef8d5837f75948eb465a2fc3392bc0f9b5352d2edd04e9c0d2292358b6a8c2a482d01c3bfb143693b1261477b9bbaa38f0d07e93bba837ffb95b04411eaeda60378685e8b8c34cdc062296b33f263f43270e7ea44f42dd0bdf23dad1e40b28867cdedcc65b84e599b6f38b4cfb842ef532bfef964c21920b053834d063d6dbbeb6eaa91d90a0a1adc0d9fa71186c878ced6917a63cb2163262bf6e7066d3ce00088f26be899cf6a38d2be81d64afeead8e9b9913b5de3669af55221c4644c32f0afa3d40258f83a14b9ba7946ff9bf8b7cc6a317e359d6348d9c674824777bccb6c870f3c4075604f6f6210c464d3a45399eb1feb47aa3e7434e61a72ac4c9208acd995aa889345f88ee1c8ca2829339efe1e8769cbe3b21ea09183baaa37f10bbd4d0bb3a62598c202377a597844dc1587550282b02092c5513502a5dcd158bb5f3e458d31a3e6423dbf5d5a4b3c06494489f5d946309481a2a063e6c1a47e07d4aa03f0f2a31a0cbd8a88d85f1adcce29a949460b16f79c200653f1044130b664d6068976233f5694f4017a6aa3b98387d4c26da859bce92e79c281899fb4b6fba6cce268405abda3df646551a2ee7a00105528aa2405e65f96418825e998ff2933147340592c3529d6a27ad639c125764009bf131f746ed8130b4d0b5b654e1f3da7b973253452082ed757fac888cc9c37ff555f39f2c40ea45cf6592768741362b0e57793832b559abb63d8f90ed0b7c97d9102af5dbb2e08e690646f70afbb297ec369baab8c968cd92d257fe415a2a1973ba64a27c7dee99a98ac1e5ff4dc4c3ac9da487f6ee21645febc669fd3719301cc8a68e8f19c82a0b9d563209389ba4c2cee466d576e2d47ca55a904763c741a48cff732bc295e084fd27e2c3fe761821fc50eeef03d6b98f0496df12971a7c9e738991d7b94f5057d8b29024173f10257c7668f76d4a18370882edd069b2aa962ebe9da6d5fb13d38cf151663c2befe2584c8d034d3348c05c9105df9d2f38b533812b87482157630ab2aa5c639c35c5d04a45ae4df0e30f0511aeccfb57facdb0030b71db6f9899f461056f63064de3d0d36eaa274c27e09caaf39398deef348841a3d78224e4e2eb614d061deaeccd50c24ddb4cba77c8b1289d2972fb616aa5a59e9edcb0ba5f6b783c8c5a6e165024da04806f1634828d7749114abcf24bd8236dd4cd9a83e07690f7da025beb0273a22fdd4b408e0ae227fbfad4eaacec4e2475517989159109a82fe4a8c0f4183b6ab4314d22433e20841f85b0e5f2536314bc3908fd366a3cd93b9b12f861367c8cb0c0b5d97f008276ae786c639eba6371aaad7808907a99e49992105a257676101491bae4c2aa48e1244029852651c2528bd1d91602a9cdd9d1fd074fe1574cbe3933d9efd665be57818dc1eda18a93255a654304b2d4dfa02efd3c8f233c3608d4f2ce75bd67622807e19ee601e82cb772bf67a95bd07e20625567cfcd70b6b648d6be7c2f85309a45521f71532a10e48ae5f16d17a4f05080a0d066e47d77e1e7f3c91a194967bb935028fbd36fc2e996bf93be53450c6464ecde56e325df47a97086ceab65e11b9b67180c558523de8aa27eed6f5811b751115bd433ba1b2dc1c8c840a06839e7489ad203f7509b6975ce9ad837f9fe0ff660b69aa46c0d935a74032a39591f740e45315925ab1e0806abc2b6603821f7e109206d4e9633c290c65f3af8a95a801ca845fded7e30392119f48f2c32b5c0782b7187020e87577215c01b659ad7dd08bdafa7fa762dcc4ecbca6c858f82c7c40189993fd0b50ce3f42a1a22683d5a4c25c4764ca30d53bafac1da80b523e9d24dc0c307278286d49d559d89e860ac03f75a86d67e5dff0f5797cf97c873f9c1f53b589345624fec870a031b9e4549ec8afffa08bf7ff668df1c0d8e698c39765f52e144df901d5b51d9125b549bd412203fbdbcb593ace076394505aab7d2e209a37a41ae19d9591965c06bce9a7685e6612b3c78192f840c91302e7894fc0faa372dfbaaccf02d6c9837b41abb9cefbeeda680d258848dfe3e527a4c666a52f73972e3db73a20560b71b6e10fe80a40f9202522580d4eae4319360737e03c288c4d5b9b24e46eeaee7d775ad4271429e0f5c246355dc8799f27027ae851be254fe40570c5b0593c57ed96aa2e0e45f2d244173236dcd791de76d044e38dedd1842e2f197b4081ce23f4c0a2867e74c4d691ad784ee5fdb47f9bb5d2d44ed31405ab74a413e57e5f92be0f0ff405d362f8c366d0f435838e8486f29e5dff79acc525d21863cb1a64cc0ba8bbbb6f695bd4aab1d321e5a87ae0345fa8ce88f34117b54ef54b34e673babe2c08724adee592f2fb6d0bf501f132bb1b2a3cd01deca842236b82b67914064830cd3134bb3af4b48b52d058ee0f8215622f2f17a6bfd20c087c4b538522ae4419f2ec35790774de16b7b247e8b71cce833e3ce2f54c0fab25e4bc5aa76f114117becccb888dc8e17f13431e2ae7d931dab42bcf9b628f3b22ee04124e9fe8730a8d855e8c19510e63c02f29460d2ac166d5b8a306979bed287a5fb95f2b177b8c2931ff71af22b0b4c705142effb7ef75bc754155314069cc96b40c652b34982675a4c7ce71308532966c2bd0ca77a32622e45d935cd2db7b6764958b4d9f51ff94dc2883ac6d06037cc8891afa36ade17bd25a927a7cad61dbeec37d8e788f61eee8994f6e5bee59b24476f95b97b1505da2fcef1a484f87e1b40e0fd4deb7531edd0a9a991bfbd255041e54fcfb80ea0870db2bb0a85d3850a08b797ad38a61e7e47b26f216c2f2e01fab86bba6b541941273068f3906cbb940a5e82c76167f9915020f6660cd0c2bc03052aac075706f1c944a5166f24d3c041545c53724a0e2a483b5fa2d07b946689153a1689d50be532b33cdbac436a3565f1a6fa542f5d6099d100eeb33731d3b28f74009a4bb9a8146b915bcb840efca6f2251912b78608c9f4e02e65a3ebc72a07e0321eb0322047db5c9e89021413e58348889ab8f4ac8e6f56a2aebf86127cbd72dc825ffb849f135c8a204de93bb636f29330f2db064e4095c5bb381296a26342d18dc6859e93ff5ecd8d73e6792a232685272c37856f165c279075c11ae085cae901572028c78337a1f2f05f0c759b55228be476808f9abb9003f098e8c5c9b8e620e2df7994df3b8d5f0dca46e9189d4407ae9b99891d70cceef60e3d25f4e82afdcf4bc41d62ec9390fc300d9088c622c03671bd02239cf3d6d9f3f26a9922f24f37b11a4ec9cbeb88c9b55bc7615197db22e6cce486ff0e2e303455a3f06c54fa5e8af839825e84fe096cfce8c88c66afddd3602449f06617abf41e1808a4a1999416d335cb87967e0dac486ce33bdda3f0b46b10e149506e5696dc0b4a0d9ff7ab3a81a9e1c42672f8433785020111524d96e5a978e8c0fd1cd96a2bf0b81e6acd8f6be939151593f14b401412a77915dd6ef13f1b1175cd3b0c6e10f8531355f341e3be76572dd361fa83d5d43cd3379b5cd53d2d2970c7d7f946f6f69059c8f54672e2cb863a040cfb53c04fab09cb2c89f82b2f7c738486e6d154f654472214fb1cd8709ca066389bc1c429cec4d443eec0890bec57fbed316538ec3db148f27df5c9f72a4da677e783f5a9bc622e83de9b3620b1d31e132f3ad6c91035e95a5fae20bdb065596e699093d83d2f5e42c208a55423c3b35a30103120cd7291f9debc5f12a8e63b44bac5cc5895cd8d79a5d7232a0ef78724aa93966d1cea3ac8010f659484e93b15177af67d0d025d0ceb3bdf143e9fa6bdef7546b5bf44ebc43b127efce10c97c09ab9ff79ca96627d98955e8850312a18785aa4136d8744a900101fb2b93a257f88d6847294f35768b874cf1543b289bc831aa8bfad413371dc39a7312cd6a5e233ec292aaffbcfb806de859cb92f4cdc1599d26dc5a3fcace6cdd720ed2b8f35d75f4116016f91342f5713dc8f0450021879484664e711921bde8e13b24edb1f9af7c019ec33bec7cb5d75708a2bd6960c3f7f657d9f64bec5834350e7281116764b0d00d11cc0eb62e2bcabc8f7e689e512aa04090b8571d15fc0e4d2463e80a1aa3b56c31e64a9ee2c59d2367083cfb407dbfabcbfbd61049a9f93423abe00dbe33f44eac26ff275d14b82bd9a88b6a5a675f13edf571161090dea7f82692a7786f5b1388207874013150e51dea88874b4fe3c4d1d133310c210e217e2cbbef69e9f09c9442c8233a5fa5643105638095a4f12e551632c3ee373bbb21a5f766a7b0ec6559e216539dc4850f5f106f18a5b0c4617135f820e047fec069ea84ead024049adebe9e53a1b641812186db5285822cba3f74906a93931e1000a703e420f6a56af3c4cb652787c86d85a9dc36291f8da7ffc04206d153550d62c8be86038012ffd70844b9ac16811bfc30b81502093aec72c1d45a6400508fc31ccd4cc377ed2649a47503653d0860f28faf4b45489a5faf273447559b4fe150b552f8b9ca4831de512884a0ed1d7ade0a7d9f5a3607c86193960a1738134cb7f62b56b396f8e3b55dd6a32a86dc1aa7778fa1ea262a3c5f3e0e1856c8ae2d5bc02ebd8f46fa9c948a4b9f5b61f82fb0c9cf8ecb8564faf6e7e93b0ec3d47992e2d05eb3cfe3cb8cef628570d84e553c39e2ae49db9309faeb886fa67c4c8365fe5d6ff9f3a06bffe0d1e6c1683b701c4caa0ca7f0857ed73229c5fa95f653e16b534f1cccf4b9709a26d17c4a3febc748c8bf966414966e2e56084e5a011e700fef63e48898450d0232ae8cdf06209027a2f60ee33b8c1e0d0555f20da5c17430f4268def165b80ad01ef870d2efef5e193777dbd35999241e963fec534eabbf931bbac71f5088d7adf2e1f9cd8bf1560f813a24fc8aa7130422072c87ece6f89040192b7b7b3d1348cc2ef1648d1f6a0756b108e3620f3d8f35e3bbd21622edce18623d8656db2b1bd11c126bcaa4c1619a407dfba3b2b837c25a161bd8b0bffa2e38717d82bc588b0835cc6e70efb8e0827b12a01e82d04795b036991a3e1862f2ab03161384ee0ee1024aa9a013c692d7298110ce56186f3ce8a25a5b87f6224f0c0e95b376f65abb3f0fdb72099d8d8d2a300150da9a8303ca3af41e60f91a866c70cec082aa7b94a6bf2c7e45f8fe1a46cd1b64f2a7ee2994670211dabd0d3a70301c7ca5e987277365ef919dd2758b6606592acae67e22b394e3303a4f739ae9b8b4fbabf93d6028373239f1a84e068c8b79f3d98422380e95c52bf38f986deedde921e67b0948b9c24308755ae7604e6e78d3dc4f98467583d17fe10627520944da8ffe1a0e7e53467eb88d5978b84fefd28525bddddbeb4d69b10280f4bb49ffc1fa33cbda646d93648f9939a8743fb110fe0314494d7d6fe30e91404a00d254da04cc89940c690ce5210d8bb223e15053ce60692e624962771861babd54676318f8fbc18f909872628a782a4d3f550b6f90bc1c0c890800fc845f924cbf48206a27664f6a475385c557b39f83adcc5028a3514316311ff4ca2ae6ad507fb0dc6d78b4685379fed6629feec7d89ea6f0b7f4af72b0b5ba0e1ae16ef48b0e0e91fefcd02f3d0f3da78f33f10b265d447c7e74ad9bef5ff3998dffb06ed146b1a820d61aafa12803ec0fce714d472e5f2e5945b5f24ba15e4a02e3ccf4e2ee0789c32b642ff91deeeb96a3e2e6a270413be8c6474a6a958ac0ff0359457d8aa56cec65d6776a2d022c006ca79522ea983fa3b49e9bca05f1ca90e16e898c5a43e6bb3d53caa7cfac3d6bf98657b69625ac317db4e4b6b78e40dba09ee9c079e9af1a078db235116ef3683ecacf1cdca71b98d41fcd39faac45fd76210739b2aabf2562a1521c30d52c278331bc782e74fbab01a9ff0b367a97941273ecc3a76f4ae3b0ec4e7b241f20f8c6d60e8cd17adef54f3c9349edc4441574a439e52b4384c8edfd72b9a1266ac680404c859506657fcc08ca430e5ecba6242a62be9c4e70b7805e8311629c81dccc3b27cae723229c67248f65a8b1ab15c02e995dd5fe130872a79e8391e71376d19904ee45f1325d237a406749e9baca6798577cc9811a72d7f28d2298408fcc879842488546d08bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
