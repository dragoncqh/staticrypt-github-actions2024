<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98c5a82b98df1f9b9c1fe663ef8325def47c6043f6f06eff388050419c888a93b55f24602ded4503fc1704fe53431b06646758016fa15069a4adefd4fcbab871ddf803e535458b8342ec71b6b2edf6e1e61266730907e8f0d1532122787085f8adbfdb2ce4b87d9a3d366ddd9993e210567050f2d2d3d6d31b04881aa068596ce3e6fb3fe190cc467abab92d518367996f7f4743f361c163b458b6f0af490baa9c4a768afcc46b5ea94304873dd503b17e55751c4567c2c2acdcbaf33e98aa99eca0ffbaec08a58254c8d26db7567ac11a363b0cedc243c7c029ab57dafc5c5e41b60ef445a1cb8d8b0f79f744e28edaec89d8155a57f53ae0d2359b50d950f249064ec85afc28bfa7f2a710eb563c29579dd7167dcfc30ebf1b5784a2528b7477ea047d9fbd6fa49c1e68f1c6ce9683eafdd42ff3c2b300b58fffdfdc703686fa594ddb4e65a32741ef16a525d653a6192702cd3571eacf0180a0e29f2e663c7393ef4c162b3010e32d8666816181d1c6f60258df320cdf4c2351f2162427425937cd45cadd13d699056e3c33ce77e1c1f530101df77a285d4beb72d52ff7cd4a2992e33a9bc5ba38e016ccb3d19915f003331573e4a8d38062c5dc39219a4fe2b63a182b760341f4dbaeba25c710abd0478bda654c94b3b07383d968740e3a58e271336f9921ad8e306579e43ac29a7b0ac0acdd61386695f304201d5f12c80733979aadab1740cee8f1fe45ec9f3f94b19c9768080d7744c1072f061dd46d8dd02a4f9dde7e5f13d41a5dc6f316177341e94438527bed7995185beacf0100f9778287e6d56d4be2637ea1b915d1136386b31d52feeeca8ea35e6f17985de2a7723675126a60eb81fbe635ad43c98780b81718f6360ab29aa4703e1f5c965174e629f71873586f51637864106bab3c1a87b724e9166809e706ea9ea7642832dcbfac9b8d6bd7526329a106703c189e37f63520f9c7b6425023daa40a7cb5e3f38b61b6699d63e44245accc8466b529eb3b28821f73875a5b31a3fcbfe6f34a5b82f5170b8871cfa88190e8a07ff5e4272540d0f47f7ebc6edd93482d17b3a021bb5eadc306f5faa09a26a536a85eb9a196a585e177da7ce325fb680f6c1fa8333bffd3eb123144fbf8b04f90132d376e57ca400ef52b409477fc4aa7a01d51886a156781d778a58042feecfb25524bfc73b3b5f64406f46d758ce4a34dfdd8d04c8884dd948868b5a9579d680e8a8d86aab4398847a5d118dbb8e04e07b49a709e9ab003d16a25dbca698bb76a9851de58253469ac824d7461429ea4e5e4aeab1fd35eef1220885e3b7f9cbce31a2d843ad97905deccb25ec2d327c5d6d46f0e409b8693c2c1e36179e48aca78e3e074e0ca7893a199906d26e1298642f23c50980c6e8c292429e9a06ce65b6e40811add7091597fba700d9e249bbceb6baa8b333d5588150d27fe8966e261be44ea1b62ddb12eadd149f544fc1dd074303a2849a20c5214f232acb5764d125f11e89b1c59a424fbfdd41b6386a4b667d30560a3d2366aaa92b88c96fa21077df93e499faf8b7fa32d91a40b9ec34808f6f648c452381cabe42a9ec352e5a67a6b8324390f2441ef1f2256ebc93651400ff9aa364e58be3195522d05cfad1891e5ca1da5eebb8396422438dd472f6ea3111b2187bdea4b162d58379ca329834129081163b5828e620c0e0660f6ab5d473813f3a4b850848ebf975126fb64e47f9f235d2c041fff44d5c6ad1aaee1fee82135974edbd66fe6d10585a5b8a2cdefa3e45697e41bc1894141e127d647fd97850e446b3da757913c9c754e8af8bc668e6f58e6e2ffede2dcdd7f9189f5e15aae9c62efe77cfa35dda60df56c75403e6118c1d61f1fae6aed774ffb357cadecf95ef445d78c3cd1bfb0645a97444c20245e147365019c608bae5fda029b820e809d8297196c64cf87ff57c3af0ba3ee41e0a76f3d9ddeaa56289d976e90917ddf07f45ff161f6fbc377e394ee6fff639fa8d0d200c9688c523ea74623863c3caec3469e7f7ee957e172804ceb80ebdc630499cdd8911e8ede8a1aca42f91e88c19f4e2d94a083db9ca22c1cfacf502c46c29ffbbf22d33259f8ff64471ebeb890d5cfde4d56c3068fea66578654219791a4a6858f5fbd73f900d3dc7c4d2acfe4c6d35f4dc5839344a060df7a05d97446b7e7f4968155df466508bf24a621fce0590421c3559d006dd36128a3aab65aa69e8bca7dd5364962af429ddb09b0caee3c0fe3c24b85093e69f40497d2a98204df58df79f8ec634ecec890e54bae920371c3001c9e582342faea559277fd3776a2f0920f35c7a058c0680075abcae68337113b3fa65f35bfbf8ac8fc15906363942305e2f6f0c78b5b4e1952ca147d004e3819a7b203c79441b58f93bf879e2887e37d6266ccfd29a1e1e34a21a69c9665d4b3d04158790b93a2b089d4f039509b574861c22551d974cf83ee47a9676d82b10e9fee2a249f31eea66afca238c9948b6fffab87cd53c2b9e1a943ab480d9e29577cc96b886e498b7fee114bd6f7d0858d1c2ead6f6b089d9eb70cd65ffc4980e4d9d853310cef2a87d6602ba83f72aab2aece2707f80f6346e24a15e9f16da90e25131cae69a6a67432708cb3e057460bb86d8c766757b468998d642885931405413d9d247358b9baa483e03acf2e3fc28ce88dc6c097dbd8b18f7b3a2c70a613366db31441b2ee67ea98761dcb4d5530bc4f8c3a6e685c6c071fe3cc902dd99cd5e4d326f3cc521be8dbe2b68a6639f2cfceed36d63ebf134be99ca7d8adeaf147762a3be6c2d23d1a62b54fca72b2cc85f4a2ee0563a817f8d202447466ec3ccd2b4b69e877e4736a40b7d4f3cf656cd76005a53f8e56ae9645c8c0b03b674804ed2dcd7777d6fc9c55ce0be6afa3be46c05d89fcf6e857713d61b9f1b128abdd8cd212b977f5b4d78f417e00fa3c1ac95ce698c56920619d11bb8536112b6d78002eded43fd9921248def54b1a819cbbb0ffcd10b2c5f314942885ea80eb150d4208dd89f40dbea1725a7835fa97e75f6629a207c2d7e665f7c12b79d2d0c5532ae795c89a59e617864c5e769fdbb467e77b5aaba06cf9e053e034f5b2de9dd108e1dca328e700daeab433b07432c099e3d701404378a391ae4824c01c29818c0067c97246262f5cd3619161ab77aea862b3404adaeec7ca25e33cdb0587915257617bbe971e9a179e109b3de554db729bb9397d14ecb79e57934cea356dc3d3809aa6344f1a6c681f42a06ec5b143f46d4c3c9d6a153a9c8a5c9fb900305822704dfc89464e8a8f66a395c4e9ca942e8b18b052c7e45b8669da8f56587aacefac715a25c265f8d72bbaa09a565cff9c79641772844dde3f681d6cb7979b33d2a3a7570a457cdcaef454319892142538803fb5c52fa498eb5228297028742cce81c88953b5291e275931b4306c92f6a183c24612b3846eb23936ee44c509a3fc740c4bd145ae6cd45c8b7db4f88e1c3ff5bfd51a2560a3a619ec1e6350408883f295535592f398b5875b48ab4ebf5392d93fd4c1384792547f1e56f6320b9618dcb51dcb59846d8d96a84af9512820cfec73df5e48f6f2636d30543fecaf6957bb804a6e207b90f8e7ee06f525b2ff92b8e1e91f5a056249a5245c96a0cfceca54feec15c4a1b42dfb3dcf52cad09c3328c9bf6c4c41b9e935bac8992aa7709e17894910388592aceebb18559d1ffbbb682a6851c1f47f9ddc0e21f5592c16075fe7355289c362ed162532688baccf33f2106015febc35b135e7b82000c6d87e8cbba96c0fb80bf0960cfb113fe6d57007151c26573ea03b79ee93c7835d77df2c0f83685be9d19c62afebb3ee324b9e9dd08f91b3b81cee77f94f65bc26fd489b8b9d7b0d0b03bc4e250f268f754324b67181424aef4048dc7b3e530b141c2c832a915461ba47e6d21b518501e55ae1e3e6dbeaf9ee079e0af25199b053ea44fb7c7561718c7c0e7f0cbfddb6c3216a8fcc4fa9f2ccaf7a941855c6abda7b79c83f6ab9229da96428a6f4d1a3a557317574b180bf2f50a50fdbba9f0fce22e4ebd0b8ab6ce37b247b2f66cb2e245fb68d827e700aa679ef7f33bffad3f6f925026e146d4851a5803afb646e781f6ee75f345a0e8080cb731b65de68dc128be15aa04e7f8ef44e2a034eafee9e569a0e6d4cdc76a738766350d9861b44baa48723e282c3c9ec9dba4eea8bda59438f71f2a9d9303cb4d33c4113101a46e0774018c84e72b89f6d7a97c6282aafa58e8fdbf6039db0341042929a1f8d7f286f1fbae42741c96ec35dae66f19e30d1425d667481ff8f4ce0077fa62ed4fa7f99c173b0c38264df229fe5653eb645b4b3d6da53834e6f1ca277624023f39056a2f37c76a24be1f93f50dbb1434de24a2737154a2fb94013f1e0e57a336f7a6949cb7c93fc8974280cd6c30236f71fc496ddc65f4a70d85d6add9d46d1ed8ddc3ac139094ae843892d6f31a3325ddd63980a711cddc94e3d7165279aa5c83974a944895f0d2b695eae0015af431141a0b46e39ca7a1bc08b1c174346d0bf88c32c363aea7bfef9c3943c48b36a182ecc7a1349fc8a50c82659ba00f0ceb43157176a2c2e105f32d857e73631e4a579b41e4a9ba170e595a4e1e4679371aa4d635461c729c83804369a06820e12bf2e8fa24a2fc64bfcb06d0b79954b386d5f51ccbccdfab4b077a7b80506530cec8329e96238b207175a0798d0db1cf1b512d3372d3cc919b56d31e0270495fb940f43216e452e2766a6f47e000f2a8bff221b28482b436a6513d8a8421a2422e3391935ef1e9092e7f637775d8e290dd53d305f6e4c036a4d9684dd3e91176c579604a413e894c770d9dbe9658c7b865a2ead429a0bbd8eecdf468675d663717d619ddfed882e8c2baffe8e9ce3d08f7272801f235feb7c6ca0dec32a634fab802d527be93d0f26a1943a25a4331c4122cd348b9f958bcf4c3834934c8e60c53555cac794ebb0635d5beefe837d79df72e249973c1a07d95598170c5b23c40ad225ee181296c508a210892a3c8dc210b4bdbb47f85cbf725259fb96795de2b411eeb443834e92ce80a3fbcd00a99b807d63cf01c279e801a941f478e57e8c025da9cee75eb77f3d96b928d77454cf169d3e95d3ee5868cb0aee0ab8161fd1a0a581c82a80fbbf5eacda1f3e96a1d1eb990114847764bc4608cf7526e8678820aefe75796daf0d172580621bd8467ffbcf34a24104ae628ec84d8b0fb6d3cd60d7eaab66f5dd1f751ac91b0b9769166b65bf1e6171a5c2283c751e1c5ed4045439fd2f527fb130e3f8b1f6cf0aeedf6d394dc15c6b5eff2a0d1a88aaca81a1b6e9c4ba024c949ae9a9a7e431705eb258b37fb6d816b8a7ff90683279c8242abf7e368ae0cef411fe268a95d3c95eaa258d83397ad750dc24614414c543c5fbfc4040ea5a755adc500f974bae6909ab0846063d6ef1915cc0ad4ad70c62daf9e5aadd04a1d4032cc1d2345866fe8a925c47887c9bf87cd4f345d211cd1810cbc5f90083818d1ab85babe2a6d8549bf8d959929faa4f143865c016b78ebbb466a02317820642b7d1de77efb9a10aa547c3a426f914340465b920b1e0265cbe5695094e212a3bd66da54225b832213b33f0e18533fb59c8ba16011e2256980e039e5bfbb6859926934c0fcd29253df0b18f3199b4e9fe59a3df47b1ee48b09de86e349103c3c92536d6da877c7686f4227e279ee61b185541848d9bcce2c69a0f763e736bdf04bb3311f2b0d923ce0f8653cf7de837d3fcb33ec620e4a231abee1401046b4372caa833e401079569fb2e43db2fefb0cf6a2f8587502c88f43b3665bc65533c064278d0383379af6aa009e0590b1f75966f404bc450534108aa3c7d9414a4b2f41c24281146834460a259d6795acc512c5ad495dc235a0fee00d22a203f97cd83f69f2e6e358017099b1394a683388ff83b4921ea3377f59e1e7197cf5c37bb1dc1b3800960cbca40802f5e7c55529d9e91c0255bbe3693c23b1b8287a1dfc5fa63d999c33a794620705dbdecc0e0f884960f1fe22644692883f3dbd2809cc1e3b49448b680f752b67bd18bac66c86273705cec19f5fd1a9f99e15d161969778c381f2319fb7ea3951400111482d139dde97d8d8ef7d423d5683a3c6ddb0beb7a8ae4de101eab6a256c0f07d5b082cfa002d563c159b0a22774572c6e9031193f4a158095e3b388682d7b1ac819e057efbfe7842de680f7933e758f1969e8798e8ccf8da1006326d0d9d571c88faf5da528547cfc3ae0cdb8b90df8d6b3800141ecd4aaea42a06ffd50556787aa11181946536e82b09e5b160c090dcc3d4a9a8cf77bd89f52ea5831d9a94d4e01468622a8c415015bdcba18f68f8819ea29c3d5f1a889dd0c881f60a7988a8f146b190abbcef45ead3dad50099d790cf0d4a764519a5a58e20bdf2b902e91a96a28492c6b566f6099158f6669a96f4947930c3b013ce58abec4e75f0afc7d24718e98292ac9d5860e88eb58a1a83d7578473201a60e41fe19f0e249d267c7f5102c98ebbae0f5d1b8d978bb8dbb99be88634714a14f98962021fca83f415f7f7b08833709ac83491bf6d7147a87de01563a5d95345f0663cdb7e237e126f00f18d62eef050548bdf0674702a5034244594d9dcd21f365b654989f7eb08a97a0f65207103100aca86b4caf3fa2b7b4aeb8e8d18ca96a2aab2b055a888dfeed4d15e2d1b150afd62a454437f60585768e017937cc6cd6feecf1dae218342814e88fdaada8c4635db1343ad73ef4287e34d41d0fff6b71f1d675e994fe2b36dc578fe761bd631171edecc5e0ecfdd64f5f762d4491ba3c36d4181e49d22551978d1cad3b16beea011c5831626e0fa06bf24e9bd7bb524a095e1884f39cd3251b474e96a4cf57ec22218d2e99b69bfca81f4b423c39964eee2477a44a30fb408600046ae93e7845d9f2931beedd55daf8596a27de5def133796b3d1fe17de4b19da2c90f8467cf95810da621f89f04194477e3652164a015498f27afbc184814e03b81007d993636cffba1cbb944e6a822dd153804b6e820895bf11f7a0fd9973d883faa75eb6b7c4ffbc6024d9afabb4ac19bcd33352f2c1894b796d87928491a3f4b728b3687e33fbdc68cc225348d8949adb83a0158cbed6cd0272925d55287fa18f9a125d0c2d26012668387bb357075b69931bf02fded7bc406e2cfe90428f7ed2cba478cbee513d582a954a91167fc15224605a3ac1fa73dc126d09b5d3187a2727065e60a8befef150c19cba9e503b7fce23cf44bb2ce703fbcf36e18a7f6313a0132e8c961f61fa08a89ff254db2b1ad5213baff82dde926cd117dc06d05b3cb17fee4d641c8efc692eb7c0b13cbaf4aabd02fce7b63acfa12bc2af0c929eae12162e04753f8cbc7eb850fdc02b9c98607519a6cfd6787f370070c8b8c9464a0ada3a27cc5c67d501b3f20806e1441f2d8edc90d84255eda1c4db359418a81ef1c49476e675b4aeb20d589f8892c2faf5cdeb51f91539ada97dae07fbfd837cf21a1102c012fef1e827bff5d003d027182087dc13dfa7310b246f50e4b6a505afa16fb0f0e0adc8feaaa5d1357d4339e2ec70130b589780a133269c30a81b8bae71e81074d76cbe70e87c5a596093643af5d38e65ddcfeba1e48d2739f3776af32741af501b40457277c6b4fe82b2124527cb85fe1e4bb87b61cd9e497654932d1465dea0190e71b785198c8ab45b3f4825aef5d4902783fdf7cb0ad1cc78e245b3fe05e50885d488b8b2e64220e875b284188ac9f827c03deb0d248510c980ea73beaeb4b11f14e4a7b8ffafd02343e74a8c6b97a0d3b38625ebce1a88b3474721f89df2511de058374d657981b98b876f6c2a47c7633d680db37ccd4f6e6510efa85759af4ed4856135b80e9fb2594e68c3b5f50355ea3889b24443e7a31a05c472aa0fb090c64b945b371646c10c8be002210a30de6b2d9461b210d7c28926a783e60699bf5bc26bc3f491cc8d4c2f6be35da4acc351efd853e24784fce6b37a38be9ddb5dc24e3033fea639971afd911ebf0310e657c22e9d34f28e158e81e363dff549de79823e28013fda4fae46f0daabed2e78c42ad6a6db52528142c1ea8a56977d9d7b79beadcf5a0e93bf7143b0e5ad170fe46340025ea3c0223e2a114b3dbbd9a5e44353d09232ba6ee535b1cb28fe402e62bab37885c24b890ba93ec5543700a716a302a2e9ab0b598b268575415cdfa802a9e5caf06e9b0c7f813534125d297b894558c455929a3eaf384182b135399bfcf9efc81535785edad359eda747ca632e385d198571baae443ae77a494e4b358cd38e1b831071fc573e9632bffcef2f2c89207cf5c9a8a7bde5e4a1affdb861e1f03fe308c9f3136adb229f2ceb83865ca245ac123888df1ddcfdf1ce8f19243a94a1411a81742ef35cbbd353965491b83a56582e5a82c6d612c56dcf55e2c7608bcf0b71bf80c4fe367b44ee44d491d3216592f84ae3437a7e8073bfbb24b1f6726b6fd9d064ea64245a48fae888064b885f7886801492d49146a04b3b2de76accd6dbd2f36b79a1b82bce0ff6fa58f1bdfec97970b532382699d46cb0ba9c8958d04e4a851b7455b35471deb337cb2c3a8388ce7fef55310dbb3cd21e0e5b136fc372b4cc9a6e91eee7022ca7e6b1dc12b35419623f3a003be53fcf08a885a943e8c45061fd7f56a37d1ecf107523f1be30b7811b1a1de1441581f446e830404cb83fcb7538ee47d8d5cb99acabfdaf39bf8961a35647e02610be524cd2029bcf9e3ac7ee66be9ac43d62c207e69fe6a0473abcf25bff05e94717ab45226b751a2cc3c79a4827e061bd9a54974c45324fffa21e222961236107f4e7a9c97f2ff8495d1d5d17c8c9490cb9721105f1adf429738489a4aaef96e853b58315aeb470ff12ffed213e7a64c618045233cc5a861c3ad368b776b6d1065c0402276c6817bdd224c4d8d8a2b153add8b4810f5aa0b04299ca162b8c2c3a852689a97b04881d95fa60a599afaa98a90df9ce5771a4b1acb4eeda18ab7cafab05ecbe8de05c5fbf5074476b5267a62c870579e3881caa98c779b267b3fb219f9aad60d6e4439bb632d8d346a2f3ef45ef5d11e952f1e7b6cb9654abd428e6541e0426b510f65ea7eff98acfdbca9cdd9b720a07eff3d36a3dfc87b2ae78c218c42c08afb269e03efb4d6aca56618ee285d023181cdb2017271666488bb61dbf4c45e97bdcf5e4f43f3253a11c4373ad9d09b359c2cbbdad0dc9743b2a73dbb8cae76508e8b017af0f19dc321a0cd63455241dc90837531acadf7f302d3067c4afdcbddd02b88a981a968336bf78431e2860a750942a924db7953b459adf437c2e34723c0b9e87ba82a5edf40f91b47b3bcc02e657fab01ff97d93aaf952618c433664d10502b18ed58b329a764c5ea64fe2aeeceb05c86028c800094c63692045d3a089f2ed609b5afde0f0e3d807db016f8e14c6aed73510291ab0aee1ea6be0881f7e0631d0c0dfcdf53096e8d44f7ee1a2afd22ada22f6af6fb7689cb66c8acdad18a71c75e79ea37710f3e42b8a677b64994600d9947a8994cf967223c93b84b260ffcc774b8e44ebfd8f95aa6215d6fe60c205ec2ea1074ab381d4814facbeb506fac042778f04049e9fb6af74765e301a011f955f3471b929dd9d133b662bffe01443189acca46e16476a7eaaff855b8fc104bda7e0208ad902b9fd387a148cb85a821332294371a17c5c4057e4d536a9da0dcccebf3b09881f6b52fdc17f3e66bb24726b9da08d658adf0c063c49702a52ce08d2810014cca76c454bb70604c6aff31ab3912b8c6299dbfaa3b63e2047ebe41e52e67b40c6dc669cefbc3c43dd67f980725e76b028cd83d9aceb0090b0534b451cf6f92e8513852d92804dcc3e00bee20da42ef9b19e221ae4edc08b49d58831226ba82a2b8fc5de33b2a050f4563960309a6268754eb581e06381265df0c9fcf9ca4d6f2f163bf484dc03d54c347bb07afc498bd4142a6692763a240cb5062359f20f37fb709a847dce57a42a72f289fd2966f75925465c54cb99b0e9432388c800128df3f15a7d3306202cbee075c29ddff948a707de67b48991f8c39fd9c53a97a3ea33ad74bf148fcbee457e7eea9f530006ed136f63ffebbe9de1c7af9f449805ba4b7eaae65261f2e0f9236605ae317c1d9046ed4db31e09fdc801c1e86f8bfa8e7c51396189090fe9dfe97647de71aa9c8fa25e9a435a89d6680e7fb40e946cabc190c973bac06266be3c751f3b1bb21672063ccd4c08d7846bcd78b44654af2cc498cfa7df8472b1e83465096a9da3e5bff620a045d513c3cef97fceb3df2c1a9e95650621acaac4e29bbcc4ba1dfa5cb64f65c3f6e6b9c4d9cbc35b0f9b4e7b104aba9f39de70586b7788206e2c2d61ff737fdcfbfb3dcc1d57fe7a64ec11083b39dbaa4b750a9008bc32cbaabdb884f80f480d06a198a75e01cc24698e1b42a897a3d6a566704eaeec58f86e12daa5bbe78520516e567ed20b03f543a22c0f97767a3a16444f3f46a09058779f16c786eb564830218e6f5ea4fe6476f8579989e7cc4585ab427056b0e4c8e536b8f60d91e341482e0371ec9d6ff30e6eb689ab18e18a1e07553fd18a11985aac0ef6678d14e9e85f0861b29c2ee91ff295a05ee48ce6cb0f6ad2d0d275fb8e6c5a93610d5a7c5f4deb9f91fb56d09fd1eb009e6666a477e50370f90e5134e89c7d93e80132231b2e41e111496607e5d5baaa102829c5f8235e304618dc35d0d4f61def7e5c03ef29b774def5ae37815b93c7bcc99a4ff15d805148de162eeb436e88161df0e5714a23bf3df92be02f73cf4c753b06c7ac73807ac0255ed04216271d3e1579c87231fd5fc85588aff571c8205d7ed83b1aad76b1dae665952184d71344d69e350311c25812d450bf9c0c2a626a08114309ef6b9a0e495f5294d9a0be3d283fd95f0af49209884c313b730cf4387a420e7027b142105c43ffdb16702e202e4c5dbdd60138ffec8f94f8500ce9c5bc3eb7facb69394604401de431f99844a2b237c9637dbe5f38f15329b52119a989e656f27b580d185c3259f4b64e9c37059ae7ff72713c9da2f51ffea5b646c5258254e04ef8ba51253f0ba050c532f424da09f1b539016243ebe0303405e371c1b9ce561dd18c2f704fdfb510d8cb4b1a5b28565de1d23f580ef359ffdcfae5fbeb9ff79cbb046ed2f2dcd26b2eaaa3d5841cf2dbc58d8861db0966a07600ffdb022e3b766cc3c19e730389392872bd3c36736b9468b5d217cd8e227be5198fa2c9c10400656e63be456b159d189ae9cf8f2780fb211ecd1866899c9e858637d1648225c45bcb4c38834226a221a89350ca7692030ca03db557492330dfbf888550956c82fe14385f303bd7ca87993be34b3a6b95961e4181f5df216a5d261a13c8c0a042d64b8d65368115fa50426bba56a7ce3b0acd810646806466839273b8d653fd30204196362644c396c95b304d3435d0fef93bfea5e855a2092dfb2f121149e8f5fd5b9e2ad6a558dab2bfc4f1e2a3dd383e664e580497b21cd29689791f200e5b3c895065baba659e9bc2c80d8082a0345bd51c6a241fa89b79813a9da9f308a69590d822d286413a31ec3d71cf5ad9fba8438cf993850dcf6959f8399ffbaf9fe707c54330ad92712281cfe372817dcfd0b04b6ce6f20f580d35f4985b787dd2f1c215ad6de1ba300cb7f9cd79adddfd2a0f32670e5588d9f6941a6b9e008d9b4306f50ca6c05afd6b78e83f384dd43027d8ad2d14a3b5a68009ed98a66324ab5673a10457060cb0814208285611a254326577d4c679e5d3e7359aa1b36f93ffa20690f2704ca7df13afceec948fe075dd2121b800725278513827f1a82e52e8f4f2f6272d6fa3f121a8ad14ed71c17822c12895f64e481bc541ee8cdaefb63014c2ee456eb5e60807191a98f24964d412792e4fdca63a2c13f7267e58549d4095e51169ce84950cdd846478b9bf98bdd417985dadbc5f3a5edbf92cb1cfbbd96004dc042c94f71e5af44bab1c7568302ad54f3a44b65601f069dac6b81de1bbcd0be9970b4aa2dd6ccfb71009d387dec8d66ab4678ded79c7091e1933e41f2d7f4265f93c928473c9399abb528d698de819db8dc12a18d631df941734d76cf683b26dfa5589c562a3b0457304ad3e1bdfeba036db14ffa0ca27d338decd867aa34c0040fdfb26cdf629c4ae030de7b5596c334b8682af0fae03055fb85068a80c6079acc77d1abad60b34ce13a3e85d3333f470d69177885db950cd066e9ac336ccbee204df180a3f19c7ed996b68cec86699632a16c548b00f2149a86d542bdb3928ef3a5c89fae63cf2387778cfcfb78c1bf23e8235f0b3c657171c1d5ccc3d40b958e416b75a0b75548e683f4867066145c5c66555057657dd9641b4539738dbdc19cf0deaa492889dc42e2752d011493afba7dbfae07c72c7e6cbb2beb5c8e42ecd4601cc285de01e1a5ecd2ebcc16741b9da7c6fa2af115cb4c2fd0387e71313137d35fc37cd1023e8b3dfd4cba49a1507ac866dec22cf21872e9bf91152031b62f61b2b7a4b2208517273ad03386b75257abf2349b5bf1362a2866541b8b662da7e1644911786e9d050aad724096d53c553706a3467839c6168b8078eb83e534e00fe07b2c66d4117edeb07cd4818f5f5b45864ded674673cfab264545213f4e32a5663493cf29d9bae558073f92b28156ae1546af873eb7a0fbe5547b0632b21a31e033ed0db0e8aed3cd6c9685907e375f1abf99cb3667a9ae024fa13f6d6cc75da0ffb65a1f82d946e3bf35525515e71b4dcd209fcbda1056c4a9a3140273a53b6b1587d82c331ee8a48a27f967f97a54afdf8ca85e127c8c850a3764eb064e617550d928a7e303d32794793672b006e0cd9db8c1de7d71471d29e22d1eee5fa85178d5a6728de2adb2d7c3abae8d5e804f0922d4887137803fab663057f3595398403afa2a2fb6d63540e353cabc55be7070b93eec9f2abea0c36ab85293f7153ce1fda38b97d01a1bb7b351732cb55e806996468f5354ab609a6f47f031ccb27f9fa4c88f8b317f0a99d33548c20dce9179439715bd1756ae6c0b3302042f34c650d719764b038665c28ac8356d532ba38404d79cdd7ebfc5ec4dbb881773944cc7e39aaa75296fa931af07f5dd6e983bc2400e43feecf398d4a350b5068839ebaf878d879ff7b90d0a13c8638d2ef46c80fa5c8029c30a61b1528b942c5b8ed1df1697ecf3a747fe2269cfe1939dfbbb2ea9d024b5dda613c9d41b8f9a714c4c358f124ac01f0ce5b705f4390e24de6d48ed2ecf9c81dbd221b64848ba641f8c8520054ccc61c8dd61233a4972696bfbdbc0a1c4aabd52b0fd6562df054d5bd3aafc27da600bb59bcb8958b1919dfa88876a2b84d398c1ab8c0b921485b4613ec3dfdfd56ff5f335a1dc004daacd5f52fd4553ab36991a97713811ae828394a9d74b971d182ce3123006e711a9277ad1036f7b1e21db4eb7defe4c0a7addd19501a8aedebeb8b393bb4efc186fac8aff1ea67e803e12b7e07385884acd688ef09f789dab001aca0afc1315cddfc9967ee0cdbdaa8614d5f6bd2b505448261f6bd405664db6e648a7f7bdea0818503837d4e59dd07940278940adbbfd87bb39df2fb82c54edcc108b7a82ded0654a0843a30dacdb3650f366733ebbde4d731c4b4c5d7e7387c021239e7e91da16d271c36da7716ceda7ae28ebddd277eb295652609a7c4a1ed454c5afc0968febc464e69e432ee2aeed92b8c6e22d362a5ba7a8b5cf135e769472de243421e06511f35f97da737c2d862df838a8d9d46455edd8b7065886ffa414dac63d88fc5f7c4e21dc263b918a8ed6b6df311d0e0e1c150f4e9d1deb0c17ccf9d1255a9d07bbd97cdd1dda274004455bbb2f755073c4cd428bcc63e40b69a297d26119333ff77abb259a866acbe5d4b307a356c5078fa1dc639d5ecaa407e558f08fc77474cab7da3b933e5b9e9ffbf003e30c5f1bb40d446bbb3b42ae757005bf708105073876930c945a19ea957b2d79fa371e6ba55be63cc91c3d54b4ff04a68270a2a181d8ad56eacf31dc4187ee246104840b07b884e51970b714abd8b22a9ad9aebf44287dc99bdcc0b674c82684aa14ad106c0848272f30706bcd93be904837c783e6deef7e52444b71fef8aba1dbbc086adb7b056b33eff7b2e3afb1ce5398b1a842164203ab78037103cf9eac9c5f83a33b823221a383d9043dd39378354f3b7459e735a467c096d9eb781f4e9bd9be6e2441b01803b4c7b77c1fab5b492d60e4872020dd8611dd7666886c0edf3e510b793932af9fbe5b294e74bffddaad60801fc95dc127808b2834105aead9cbe1ab5b952755fe081d60c9086c72ab06cc2d65582ee17f488ed20c78544d453de71074315327072a9a21eea585fd64d98c33ffa694f0b4bbaecfe431c182b6b23b2d93c1ae55f8bb06d64d2ddffb62829d6862486ec8f9becd5a4fac80444f093e3549e5a7f4d41e66111cea173cc39a82bc3049e2c2d8198b993bb620d706d049538a01c354ef85ed370e3329701aa3c7669ab26fed0129b78ef5da665254e70530cce15bf70c58d6e247e532be1db51064cbcaec7ab0dac2887dfdfc464843dc315a34e78123b663d4c2fe16769807b53ce2e49e4717b097af50c5bb732ce739e07c3c9f9f3d79280cd61a4c19f9c66b013f8571217a2fa4f60185263d2bf0ef0ced035183bf9fd453c13489c6aef13b9d0bb9c774d8ef3ad461f16bfa84c146db6b79919e02dc7a2e59647ce9946b57ebb26966df3ea4a0e5d4bf61b056c64c32b58691bec822c4846d31508fd36cc5ef293d09f3b78d0ed0c88fbeced29f6d7fd417f2b74d8c406f59f7c7edc7bb1d1adaa61437aaa48dfce901c2962f45ea3fd88d21762dc701976fabe43431e03dd23c3d06debc63845cf55c918c665867fa6d1d8a93ca1a3c2f6e5b0577572c950bbc5351736d361afac95ef023be5ca186f3bff51364da941690f2df97f6b044a94ffc844847d512493536cbccd7e01079f7fb1e33ccbc5d7dd3833bfa38699a58c3d38bbdc77effc3fdfb5f3203d0cf4d4ff90647bd1733b5c12befba6cfe92d035f73165cf3f44be7cd530a80930906bcc7506554fcfd7c64c74d7615785b9e8b8d4eb1a15594260460e2131f42b6a3a0bb8b1f7166911409b358627e7efdbce0adb5a9a3e1b1a0b86914bd148b247b7c32f72d23f8f2f348005f57d8e6e6643e257331dd1ac627b26e7b80ee960c21ffced88f08ed823c7c08c5975f3cd3f345dbfe167419a4bd645386dd49bffde1b79a4a1ff0719e53901d1b884b04ed9cb425d02fa5bc59172ed0d64f4bb2b6d0337f5b3b89d4122520ac27f8f5b706dd23506134e2a3a9260551ed2a06053d876c2c60b9d7ee9fba0d4d3c516373af65b6c546a16ad63c43deea65a1f01e36ebe75753ffa86308f401404bc5f9f5eff40b64476a1b805679ecf9cb401c56e8137d0f08b553c723509c0763987cb79028e49a15df3ad312de2ce85525bf594de57bed588a25498a5f53557f2ed717da6b4aa6db915d506b3acf74d663b840dae42ecdb45ddef5a188683094aba38aeb23d8b7e490c987c246ea90095cbbf55ab0b8396c35a807fe70abf9faeaec7998e7f38f471e5a94287de4d92543b781db9b6f983ebda5a20e83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
