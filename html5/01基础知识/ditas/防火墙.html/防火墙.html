<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a5bc890a9a2e7f9a21ef17bbbc2f31772bf09cfa18af860b588bb8d36c9601f88e3fa92d76534598a98d711e2f0a8ca0843737780ded46e402c2140561b61fd7812ca35b7037257e501ef8c17edda3e4301c837000d8afab81c2167bf84e8acfc4c7a22071b235adb235ffed93560ddebbb936792cd3bd7f7781e5093c1a90c7016e16df9f46bddcc76298fa2fb8af3c73072b5e80442f95861d2f30c53dadfe95a2817c9532715d8b2de06bcf6c111450ddb6082ce08adafb90cca8c0184819e764a4c3bcbe7dbc54244ba3b45497167a22c94d9a1ddefd335134fcad2eaf90b3647a6bad37831c57e64d301a514bfc600c620269b5dc2240e14cee7abae226bd592729f43d15be0132b21341860e1de75bac4a922cafb0aaf1d79aabbc14ac8b569e95648e890645aa3578ce049de9c1b91769ff63c39367163d970830a0e6f264e1a8519db24423555212a88c296ebb5222f39df3af3d328e15ae67559a4bda81501663a89a3951a3d65ec8dddc0c7e2be9b16106dc7398e63b6ae3a3daf053c3c033ba6876d5e5211369b835790dfc5045f2503ff4f7bae21231def9b9f0ec419eeb3f504ee10c60a441f265a053e0f55c0dd634057a53d93b8a7264be4cfdf533a316475deb9eea01e592618ea44114add6f3475812b3fbecbf05942a45d516b067d4135a3fda4a26c1467f767cf090131e114cc2278bb5cb212f7da84b5cf05398dfafccb66980e2a1a5041338d28ca820629605cd8bc796ea4872a3055db2d3ee8bbb9a21724c9fca5607c75f2e90f900118c82440963a5b90b62bd88153f191fc9d71c11556f53e5ea5d9e751cfdecaeec2654e77db60336f5452fef738b4b42337c0ec2ece4599e2e57d87073ed4ab4835586a0c32201ce1c598743b602ce210aae6a508f71c55fa8eee910f5c45829c45b77e5012f07a12c6292c42ce44dcaddc6945238427507345e92e2dc8e01d08f7dc175e5d4351cef2cdaf246d471b6472e204673b18e98076f00858ecb4d2b7ba22c419065d2646a3c33bc30b921c2d0d9cdc32639f18e2479c455a1b89708e9c6869a11593677a472ae7a3fc60242a447bb98fd1d72b24caa4c2e2074bad15ac0845be4b5094ebda27b050230d13f6a2d2842379967d824f747a3633ea36e582e09c91522419abfb80d6eb4e6ec6511831e9c8236803a6fe41018831ca87c00fd315d6d4f1dc4a6c049d24019b434466c73ddd4c7470a8ffb42e4dfa444baa69e361b552df6bacacdb19d5dd16448c5170fa119f7e9dc1fcad121590baa1d924e7fb168e6a261b52a42624f750d22e4890f0fe23523e54ba8e795e46495e1f743492f09a93a568a314e30974749b2dd2cdaa9c5be78e232ea69787a67a77690c7863126d4dd5b7d319f6fe86e5d152f52010dd74f28df58f07ffb175c1d68137e21d140ce8e23b1de5ed755f95cd02d0f764be3af72f1909aa5ebbeca9540dd6154a3045dbc81f596ad433ff19c7b135c322dbd1a5148fadb7f9791cd137822ab8f708491db82d399dfba519500cce63a03863466965ece952139b9ec3943db25f0a6035e30b3047dcfc8543660aab60771586c5dde14b09f746fd0386becb4eab31b2f68df1faff21f8536672940a214d35245b851a2354c6ab68d1be033232077c424cf6d3a1ffb0816af6e282b41959cf40883d280c3eb86067f0a7fad877cebbcdf8217cb19869524761019acaae2074a5d10a0bffcf7285e8974906aacefc98b63f67e26c7dd01a39965b33bec1a2bb5fcbdd5caac0c3ded04e77fb71a47c318971415daacfff4b821608027accb2c379579ba0da0b82867f65b3794c7fa5d55e1339b973878e93314ea8d79aaefa6839ecb2130fef7e96415ce4d376d802fcccd586fdfbcf53c99f1346f36257a90e05014f62b512c7b10716cd02b0aae7a1d300def9a0605b85e213eb631aa0861275a6ce4e5132511510b0987c5370322b1b394badbb6d9c45554dfc9c40c5cf89a9586ff68cdff4d33e07de5f73f7fe9c29b12abc86c164c4dd3e4a501f57af09463707fd8eef25849dad78dffb84a482250e3f5096be1c80be8f1fd07afd8d218f975c5f2b12d98b9ccf0d87801963c88a371b3b60ecf1a16e3e5eeaca7e3a1a4112bd4ba2a6db7334c27a6902d6494ed3f5f1411887d454356f7dc833086e4c932e0da537e8312a75414ab07ef7eec2307611988a4c5fb7ad456c01cf3ef7f9a4bda364ffd52345bbda1a38737429ea573417a2ce5fb172bbab4ce8f661959cf91427eaa4945627aebb1e01983143db6ad6b2af2475b23d67c2b3fa2b911f03624d9b839df3f06726363b4cc3a64e4a426a528ad72c0cc9ee21223522e704e30caee285f31db580c33fa2cbec26029d8037c4ff868480c16b679b9199658cf23fe41f299c3d335b121b9e54745b5cf09aa18cc037b57ea142ae97b078328473372ed1cfb375021a68a9e8cf954ceec018ed8f262b308b7c62507e64ebdeb02ebe87bbaa4a0a502df00fd5e04571760bfb7ce07fd730a129159768bb519ae0ed4a2f1e8dbbc36981e1eb0ba9019597a35c9ead0778fd55bd3304b9dd175ae567bd0e9b74aa114dbf098eda813e40e501b366cc1697fe081e0019bae77285ec30b571fa99818762faa60069aeb9326c986b5a937d4840e59e2490220b004419b9d210e1af9abfd623e8c35f5bfb0831eab28bc7378a69a5f575dcc49c88bf51a1ab49c6dc5340e27c77bb64d139c50eaae1c4c617ba88533d5546caea52ca186baf06218690e8a9bfd8c0797d8d535a1c3aa8ccb19677a187fc45cdfaad7e68843b71bd0f9d7a06c83c49235509eb8af3c3230e2dc56df76ef363f9e912d9dc4f0d2813cbb814cdcc8f6ecb451c89ef9fb6f9adaf84eebe49fb6a3bc4a161a77172e79f0fe6474456bf74837188cf15ad5c207335e267681992e97064793cf9ed059fa9951856cbd186788b1e138da0cd019c5c830a016eaed248dd68888268dfceb77acd26f6379fa6369be8239a57d761767fa504a528b966fd8373bfc8a7a199bc583f36540606eefb745b53510fe0ee04c9f9cfd02529a6061550672ba287c62ef6278ed026cc395f229fd293fd271187ec2ce74ad67cd0c7d75f98def68b7ac819529685ca96673132e6453ab7b5bec1b5eb96886647659712a183bf7f6df8406333e26b1f46dc7d19de4e2a38c8517a52a1376d684c5eddd25cefe110545cc406a5b98d5e12e6f7311f8d68380632121b23fd7480e9294cf36f9c25e82a2d103028115bd91c42efca06df3072556f8d6ac9961a1ee7dd1594817d03edbe0f5bd4b6bed02154bc435479ce46e0efda0803267578c8d4c47b814a8b575bf4551c0f89d8f3014d64016570ce8848bf09eff49e10499fe211d24a80188f23c86143290e789cadb99650c9716dc8e1cff6f5ea03f2ffc1fd320ba0477b49a5426bce47f27dd2410f63f523c6f86e04466c112c605a4fc5d4fbc93e41696eff041a84a2a09022effe005b8aa2f3beaed67bc845c0b2c391fb5b54638a63910f09e901cfddda4bb1707d6d5d473e622b653ca90475678eb8bd364352b9f7e2020e242f84b3138ffdc48a7bd62c59d2fa40c4ba3baacf2566bb06f042980586ebae1959856b422545ba54ccb7a764d44e428288dd8b30899ad60ecb0b82866934915b80b8c7005f99db093a27916c4384ea6c6434958d7f54dc186c862a50737cec7abba0beddc931b9f3126affbb6f8745d0aa79f6542bed3b4b628711a262f047a7da748060a69ef09e56e2b93a5300b15f5286de5abfbdc543c917adb9f6d67f7b169ccdc9ff3fe539434e252d9ad21d5800cf814d5bbd22153004cef55eaf9fe3ff812c1475f4fa3a267c84c5947df3deb100ce4acc8a18b8665c819d6c9f988cc0ba3c3e33c960e420ae562546ee085d2934e4cf4f44ff668afbe6c3fb4725c72e3d7619f510bc2a0adc1b59b01425a43cead0257476b9d43198c405f5551079396fc14c213a53a47b64fd0305b318e3891c4b5db661336db6d5f9429e903c72a683995ad81519ca481077b677f8d341889c5b27e46d5da0e21128ebed168a3a4cf449d442a447e38395ad71265d29c8f70f02e1953bb06093112f1a0d2bfb679016806e50530425f189cb9ce64b7fb28a0d831d38256043f708dc3f101f44c0531921d32847baef85e410e80e123183794cc7d1040f33cf60a030d1f4881efe6741fda32c13a4b126c3228178c9bddbb75788dee642e5d62a9ec215f944ecc6a3b8af5b0294f6d88a3729243a606fc151455ebaec4821a835652d11045406e6cb2b8d2e0838a7ffa7b2625cb618d303d15f7eaa1b90a607d3cf5d3a9ab5c96bff77d9dd235a9992da3ddb5bb074c1d01722d57d2ecb4df279cae0f0c95ed311c55b47690c378a3d82bac0090f473fef05fd352dc4f4715cbbb5ec7247b832686b28f8c308b449d22407d87e8fc23b6d5b1c5006e013f63df5197ab8edb59b7466202d3e8381a42b7089ee5b0cdfb45751acb84a2607edf57c6c7c74efe26c0158082890558d4908f51b706d0436d212f4c9c55a58ab327d91acc7593636629737ffbb3ed10a972391ba9464d5d81b69e9874cae40b5b06459b90bb01262c95f5e4b9995d2f32513fe105517c65e374c46b6b0e737c55759303ed13af48d2c2b264a50b69c44e4cf29f1c7746b7ce7d962cc43254f7297bc84114af38e458da7224e46a35b2fd87deaad006a5e0ce7ee5370f180f81811f14fca4c4a638673a172bf4d7b41712c7faa915c6fd871ee9872cd0a5d9ae2bfb4aef0d03ce6f5a8665dc7c945e7a0688e3f11fa0975c1abc0990f030d52d342f3bec0407b90252223d53521af15a96d95374473dc902f2fc5fe7a5adbb1bd496fe47e927a45a7c0e4fa227cb576db2bea7b5bf1869a43892af9bc46620922047f38225e9bd268ab136e4668910c599454f258caeba73be2b155f1eeacd402d02965f6096ac51b13c449ea857369f171666538470afc483bed6296864a8e951a1e8ced4f6eac92e158a4908020d862c4ed3e6bb903060dd8bc78309d98a05efe2963d2be9056c4c9d6a8c4c2e5cc303385c65345d89c0b0e7cc46e2351007ae9094b793f84e0cd41cd3eb17e78e66c26b2f7d2173d38f6eef50497a4e735e9d8dad81b11b12f5fe897fcf7c555758ed447293ccc24c48ac6cda1d138c2a9f45a7bf70e87c148af1aa1cfef85426c69ee3eeed4a6b1684d75189f67df0d30133070009da19a96e6b8243f04f576415f1cb6456dbb6c06e14f4ad46d2a3185085d804024ae6ec070af0232b925be321656874045da73be20d3d59487b2fbb53256425626e5f666c3f4fab6cd136ae5c3fbc706773fe337df0239eb8195ee48dec8ea1ee941ed8c439a4a90b311eda682db4a1ba3e340c24568381a3e8d4e31b8390dfb5889f88e2d35418e385dac542fc88dbcc8b5a92e2581c9f4611d994846d6a636b68af0f058e88086140b11b913fdf1dd9eb2f58f0280ad7f02dd20d1dd2bdccffb2f3f6e3f1d32128da3d4d4c715cc8a60366e7cea2fd0de8920b84712a24471c1f4c3de2405a92af586eaa02411579af85d8c49e5545ad1f5cac96d7e64c036021b95b182fa4adb1caded97ffc9937b9da143a5cf2e5f9554c0d9c76fbd9fa7436404de6df7ab1caf6ec8577af5f9a87adb1dc2fb5bf0267bce2cd57dc8aeeed1d0b3ad883f1b565361898fef5464d120063a3ecbb2a4a938ffc36353990c07d9b77d9753b2ab2167f32385a77d83cb3726308731036b87af7b5262065aee8c71cfff5bafdaad747601c6e50ba2268e2c9b5fe425653cc5a1b0b9163f334d75c566b47ec000dd3bb80d3ecdfd0f87c5147b897698e18e45eaa5167d3e76ca8d7aee0b7e079f49a16b0a5a28ca2bed621e173bf9165f3b7e628edeac8f5fffb773cec628ac7b65e3ab046ca5aefa688a9fd2dab34a677a1fe6bc779ada661a68d4d33cfab88005a52cf166121089b742beb9c62dca423b1200b3288f2939ca2c9ab070ba38c976ec98351bddb1288a3eccfcb94f7a81b1bc49187113bc1a074b96acc0cbfe406bfa722eccd28b0b61e34ae39fdde04cd8a541681f9a8eab6e6cf13f8f1599e4783fde01c688fe741c72c36be89636dfe25eda4e5b7c3c4de6921bd3ad64b2afce8720f79a513bf55727e2950627b9ebf0bf39d347f60a04cdf79c962c26b691a8ad7d16011398a3443829029258457510518e612c9e142af251854518038528a9d3197ab6aa5b5df08c06895b600fa28fe625ff860f12316b06ff1e928fe4fd73cfc97986ec86df9f558857651106999124f4a973687cb3bd04c0dac88325b6f3d8ae23667effe3db1c38b7aea8cb3fb12dba74ab1a47d28ce7f95b1d58499cc3fe5fab39b83650d3e03407950c69277646bfa1b3c72ccbc78f099edfded771cdb097d8b3ff153a15e3b90ffa12f6326f2513560371445c922388ae52f33c6ae0f7a6ce6b54dab959b91494f65f08d69788bd48e440b3752dd09e9b728d3df965a189af110d19e9555a17b4956f8bc703a7f97d7e3ccc9f28f2f6292ed7fd79ac0b3e7314a9916118dd42e045ef4c34342fe2d165df9b274af1f7419439c7ec6cce489845f0ef95c851095ae593e507b6c7a8027ac55a89ee76c4f0091cf312e9da4765be930cc7767764d05097b7ac07a9bb5ea9b737156af5e5842d572213ba4be3aa6d7334b38484fdc852d9d0feaebba4c6a97f71084ee436a739fd2f8ad040adcd0c60d508e7acab0bb8b486b31a0b54731565d7ee40592bf566f331e5c0970f3647ef72a62616a7985c0880eb38084cb616520d3ed7901c9abcb4ab4056ca56c81a7156dce2d82c37ffb6ae561bb179fafa4f12ef3d55d8bc6e63aa253ff03e41ae447bfabf0783d343de1b7dc6e79de04d29554738934f127e03e52256e68372d2a7598032a7841c36b871814d168d739df5ab1a29db05ecd41da56e5c74ad9c79181c10054c36868c3e1a399d4e9198b3790a8dd09da4dbfe0e3848a45db6e65b7b35144514e6314fd6a0a090b68585deb36332e8e1e822ed0d93c3cb4ce94013a0244443ad8e338f46c9a57fa29aa0fa35dfefd6e793a4b7a0fe7e4bc3135a45fae4a51ed184ae11438d2f676fef71b6d5146abfe2f49edbed3e8755d675242d453848257d362a313f8ab2d50295913dbdc05fcf6549b29252f57380cd2d9e01c77a04a3345ff6f001b34c2948daeca8ea10ea605e158671776225bbfff2ec2b95823815c3eec898365b8e78b1b36392b6d42e88c525a804bd0ed9a2bda76445d6219f75ed9e24f61b399db6523031075b6cd88db59713d991b2e0ddd61bd16c816597e8d0eda268fa076857df32b268509be7c29d22637f152fb37a374a4ebf7849a8aac7ba130c48e71aa6c3fa703bc59dbc220bbfda4fac6908bb75c3cef6e4a500c6a8e719961296ce918f89a4dff2f3768bc3c1e127c49c6dd5a79b1ef79c3a9871e209330ac9c4a21bda5074cc45a876c3b7f96f6bdbf872bb3a7b510082029a0360a16e3eedfff0c92b2e600c5fc75d5608e167bacd6f65b4fa6eee8b625c1e7e451437cdb181f7ab0079f7e41c19c3c1c3191053dec6dfe30db36eaca6961df4508cbf792fe04978c30b197917c3fec9f54e2e61883fec9d006e4a058b81711184a30ba37409dd8a0fe7fa98899da474382306bdf5d1b61ce393db8ec77533b087ce07cd5c7497a2890e2aa541b86138337748227e31b0afb989d45ebea25aa8f569da6fff75d4084443bc8e9df0e37ea493431bc2cfe357249c554185cbafd5df759daa6a2ae3a79e6742a30a7b83c0243e63d5de29f0d0beb8f9072e35656702dfb075db73e14aafa8a570e805065de8742470f83c8cdd447920a5fe0d88b95061588dbde6e7547b10f8aae15552900dabb99b5acaf56fa6f840267dc4236f8208089db898a445227e905ba299c6351ed17644b367ef728237ca2fee70b95bea76e8bcd9f8cdc82a955f7d5f28a128911458b0d0677a93b660f324d2e372b6b91bbb4e11a080ccb0d6bc0496d68776d594740417271a6784552e860115ee1fe77ef108799d1d19505fa9bc36213eebe1dd92d9f4ecb9505c3c0f81f15dd65e5cfe005e9c936feda2abd9dd91d58d83d936c39d3b7336360d04720b820f02e29e77a619c919ab075948f503cc33a8061f488d04a4627a08e60f96a7bcb95261cd046362231c1cf131edab3808c12390744bd260f5212d31c423b734ec2a68541d135e2b29eab76aab9a3107e3cb18eb0abd2fc9e45222ac923e8626333b4f40e7336ffd4ea7023ef18cf14b323b0b7500f6888dfa8e4da1b6c2f8a737ef4c6e1eb12698fca68d5a37124b6e6749029ff6b5de00828a15d6e7b2c5d4858afb091efd91e589358bcee61afc71bdef03bb49943818e54b23820632094eaf1dd5668470ba72e3fff42a04c32ced852b750183a7612e3f8545c1cb684ced3c76626514629594955840941e7404f17290657f30af54cab06b4a435f7cf154053a8c017636be2136c891031d6f06d0277d85a54e6559c51d92e1acd1ae5b175e2ad1ef2aee69b30472870b1d969cb7c18320adb0de1edd695bf7a68250e43b07524f3ec3388efd40506b1a91125089720acbfdeed69288a1a9003028b9f0182e01be1f4a73da3d183e281552fd1bc02b42219adcaea7e598ff042e2e9885cfbbf0f1cb03492bc3fc4ed395e3ceea03cd390d9352ded2175e0962076f94c19b533f129c82b7b0821afae4ea53c5138852bafe41f5b3fa7d57e13b1c3f613df10a72aea5881037ad8e95c2f225260b1397406d9f7c0118bfee03d2e2d09eb95d5778d7c5f0a310e965c902c8e08ce1dece8113837194aed669f6da6669b63ab7ed753b642a9d187018bfb8116a3625d3fcbe2be3e3e77336bb38727ec2aff2f365eb9efeb7ff2b301081c5e73e6519ea6667cbf58f2cafa08b12c5f03f1234f9a009b8a11d61ed145d6a101e93c19c352da1800374cc93959f6041bc802546f90168d66179f4c06bf4668e1b57b4e36df4526cbad5800a95f340e352c70810458469e8a61ab5d4e19db6413e5c6d24af8d2e19e0bef8fce0a01be76511dea6a821f1ea18c6c2efb20a1ad72de97975cbb932db56893932cb98c9a8b58e6d1cbc3e060b0266f344e75c061a6b403f50ee73ba05fb1ddd69e43e6ed99ed369ebb8a0f2fee7444ea416d583aaf8a75c1858e43f67d7bd7978be203a6fb0163300c0623ef248c94d83fc8d10cb8d8942d0893e9a4749d079ac1733fdf8c443743f89850710e9e9059af6dd8735bf5b5e2449a6192ffbbbb6caa24d29fa8e80e9ea1f9be7c03720a334b83a9c575ccd3b351d5d1ff18620894c318f55e64937d58215b98f7356c0722591cfaca85c2816d735ab8de9f00ec896a8729bffccaf005d864248b9ffefe2e09acf00527d76748f3d52ff8392946095578eeeda76c3a3630cd88e87132ac9d9d2cbed9fd5f2cd1883dcc944399ef190d16224d7e47e62ca207cb1955e476422240be68b495b979a07b60eb97157017991ffbc491f9b683572664a215a044223a04e526fceffae92b67d9b92b86f8e7c792ca0f3fe43d7a4d6fca615fedb84a7ccfe19db7ec89e52c278389b36edce1833f529fb6eaab876b290953df569be58bf0ac350dc3e496b9140f759b09dc1550f1999ee164f25759600640a4a5b26334f84e6f093822bfc933bd7d0d787eda36afa6bbf5a4bf9fee7cc181d68dcf308f7157afbaf0877ae620f673b70a996a4157f598e99015a82688456a5cfb2937d29d81502dda7270bbe104c6d903f3407e37748c9ff3a520ba4f10ae94f5d8ea6dfc949adc4ea87b4ad8334d11f9c3f5a04f566e27d4d009dbb981c3d9d3f5d7004f9c474a2ae1e100f7a6ef5b791b3f917002b8f8922ff854d8bc1fa013e4c8bc8a00b8600abc24fdbe6ebaf5e989e0020a8f8861e5af3483895faab49c7995d4d13509cc6266044ba132a75826ec67a90b9c8404f52676f92a2a29844c419445fe945ef7404ebee7bb648965ba0641bad9b1b02b1e92ba6b26635d3a2a2fc15c25f225369f70cdbe972397ce873dcd49998530b87d2bdc149efc2b64fcf9893847156b0c340f9d66798531e8f124b2363d9971029fdd84870716051f9cb29c703b1ea712af387d93fedd427434a520e98ff389e15b3e27c765e39a5a25cac7af439e0afb520dec3ca97d0da18d0afdeed0abeec1601681d6e534f3ef73dd542a96dabb3863caf383312ad82777b26c4a8145cb1c69f639d5caad109fff82f91242615821c79d3b613aea57278aa59aa4cab61a1305f16ca162898c36b28ac39e75c45c73483218103d523f8c74c76125b50c3db041840fd8c89525f0add68dbae0d0cb684384b468c6c522bf88121f25eef1dfa741ed406c048edb210e0cc8229aa4a260de5b9d9d3fb0095fd06ea000f00586ff16c1931cc937fd44946de06b91a7a7edf2a0725b67ae2679511a588faba2e221ec3c9741429fc7bfd864cf1d89c10197404a1a39d4f3a261e6f17616cf4fd723492ec6e9be5291b706b359cb86d3bd93ff88405a2bd44765ad49039e714919bdb9e89d88b2f8e5ea89368c28645506355e88bb30ad8cb268ab33ccfc4b28af14fd1eabf9071d43cc92ff335ee9a757157221edb805efbab91066005e723b10adb1f5af8088ec0c1b1e3f3dab16653968830bffea7f121c3f853f52ec065b9bb85588099eb2a05d7f5c79ce1a4ee5f6557f2f9034ff483e93763d12d91d7aedf21d1f2650cb795f896fedfae649a926e72fa5ac7f01e49a6694db1a36b35f6e3a675f02efeff4923edd27489416b2e9f0431dadb2f2e08e181e2a45db3cfcf0a06f4ecdd415a7eaa5ea4dbc953800b94965b7c45851d74433ba388f0547c42d961f6dcfbb1fc96d04bee265047cbdd37617b4a934a18db8f815212e9890c34037d2dcf422fe06aef9a4656268245db2bb6fa1cdf6eaddb57dc4e0ff1566ea4756c3d415533c03d5c94017f3a6f8b5f1a53a254698d4bd74daba92ae5125b8420d3fa8409e66df472a798ffe499cbbfc325d19de144644a03e49f5cc39b2deb2dea96a88c3a184d611118bd88eba84f20ec2b381746a53106b55ffae3062cd12c3dfb3e7e4a48fd72995dedb49ac8a375e2cf325505bd7a36019503a2a969cbf01216b3575c7ca102f3391b165d3e47b010419fa5178b55479440326cc25dc4ef1a360d75a446c878daee7774062282f7e1b1c9119f31742e322a9c3d5d7e8bae84b5c7bd60bc3e7c59748cda17f952ee087811a436163d0a30d3dfdb6d9cf953f43e3c7cbf8c20ed7f7df4e086f8ea84013910a752accc890bd9a72262a490337e5a2649b6226e638ddd62a24ac3ea996faf5f0326e0caa0cd7fbee803f0214e8fcfa5b3b3cfe504d636c7da711f26a00ed170cd6d0db17661a8ee8008fa3519d7de9cf818c536d8d5150d8a9a5d1c719d3927cd437ed5fdc987b98bd3c9c52268ee29b73cd912727b40ae842cc39fda82f34435cb0069682491de3591b1c646e1257eecb569e0c10dc606bd638614a641f6aadd48d7ee5ef2fbe16e7b140d1488a7908cf60b720fd826dbd478dfeeed8d8796c1bc99c8e0f685d2225c11b44a65ad213f5284ee801aaad3833e1e7cf71f9e3930abf0335277bd9fa0bdab8ca41ba13c2d97c660779c29d5847d21d516fb125809d2b7652ac9752a8e005ccf5eea0ffab66177566f0b114c10b28fe8d04b2af57d023cf50dd159cc0b283fdea0df2196608c79e1c5a1a69bfd1dfe76c50903c3d1c9efe53072058ad54b193e57f9bebc79203bce30ba0ae4d04ec74fa5567e77a235db528a49456ee1b397f688e81bffc2c1834d916f7d53bd3f1d5e25be4e0251e2948800930c61189493244237fd62aeffc99d4b02dbeeedea16e81d0be2fe9074b6ff8f302b479f24c5d02288f2a8661b392acf2600f54ad25695eeb6b2995021c287cd65898af548ec08be4a36307ab14d39a65927e89d89384ff332c24d778b167fb8692818aebf9b059fb9c21390f16f4666e0fccec9aafac06cc553e19fd4e923145ee41d450c93e843a454e81beac0953a2f6a497b78259d4184997b2fb1b68030fedf8a0e3429549c7a6c2e785965810aabd0edb81bf53cd2ae871818cc9ff273d12440248489748d1f2816db2d695784f4e60cf3ef1132052642d0f1efb18af95379829c051dce7640ce473df177297ed014ca312a7fb91b918ddcbe4e4a42e8b3c974d5761ded6c4f4214ec8b74b6933efc30c1415dff5987b95544fb4103792c67085b317a2a62848009e573daaf1b94be0fede8f7cf27bfe0c6966d02230d0d1ba33127c7c48987bb238022d4a37c3178d5b98d3e76314977d3e10acd017c57182857601dafba2e63d3de67c0d4a6b9c781c9c55b68c2c40260c3df1bdf90a1caf7443624716b5f8d80773385e7ba526b9d65f22c82248b40dd8ce5e073993fed875398a656487b601183fc1403ba96495ce18377ae8cea75b619693e36e05e1b34bc51669bb6710aef285c499a20d728379a9dcefa25fff950bf04ff00b6b0532b365b1997e626a848c27702d90e0609398db6c9a69dcc4b7742e0b5cb4f57436af3639e2b8b385809f36c1b1095eee4a88b1e7365935860afb4461d3941246ddb31330c796e265f506a88c050bb5894d931f617350b1d0aa1670f60640ef774de43f695a9434e7cc24e4850e0b599f9fea486c83257d7b638f443b34084f92c21697ae62d7c49b2a0fbdbec059e0c17e0ee85f55ffb481d0399097d16991d86fa91cc5d93f4b159acc43a7cb517e6825c81826d881637092881cc58e98749bf3db58c3a10721b99bcc1698ede5834a335d69a74c0f45ced8cb4bcccd4a92e54ea528e3066206eb195bbf4696fe17732ebbe923be19e84830557349db40f7399c6444b4319eac6df80d4e8a17d99c87b9026978d927cad9870cc1e13bf8710d3b8efa8a0869125eeeb9ac1205408bdd0f6d8e156efd0887a76dbcd41cf697003177ae9be32886c15352df55abb3dff7e22ea19cfcf8d0694215f3a777f23125efc44e535c6e7192b400f88e8b10af94079cc5c46b0c5628506cc2dcb2086a5f577c9cdfdcee4c5c7e889d15e305a24edac243b3e53d26ae2ad1fe678497199656825d3dc505b2ed696a68bd6b57a82f8d016e639fc289b56400e623bb993098196d4e3d3308bf604fa4823dbf179a390e3b1b4b1098a4db285832d49c4c5ee641f563293718884d1be53e12781f28f4539ac5d0912fef370db909ae455ea186b81304beac334dd6f6e81da26125f172636130b85bd592907d3bc0afeeca3d61b446e12ad1faf9b0d89b1ff7b69c02cec25f8977c82c60c13079f41193f50979c76a1fcef2100409cb47e3e0147f6882e48984aa112595ad03fd22d75c1885358821be0acf0aa76f74fab357139e00957d5d40370ed31bd92166cdc7dc565437e201e5887baa4fd44472dea08575bf1ad9f9f25ebfa674d9acb3ee203179cadcd9c0a4a3bbf05a9cea77a9a1dcfb4a9baac2198112c277e73a95516c6cc37ac0c71b066c8dec38f29c247b66d3d3996bf471183db971ae1cda8e8cebf588b7d0880bdd7d704f1b435e5a13e46df2e540b4d79ec232ea43481510a812813abfbc5b3c47af4b9a244691fe95657d5f7206044705bf55b545d1d65f32323d9e95514f2d085b755a46a7222b8ed7c4d79fd3a36d403fea460fde4397263c72ccc51568587a049791ee8149c51e56554b3dd79e9f608d52dbe61427973f28e148678137fedf13bf2b41b25ed06750306543e9241250485bfa98070e59a8b646eff59cc978fc8af8cedd3e247202be3cd0d40104b6d013a3664117ff8f858709766dfa96629b55b0e28daa4272f63baac166caebf60e02382643f253a7c817fbae0cfdc92a0936a6ac2186e13e1d94c3f6f0f82bc730d6865ee51f7222cbcfb6763d0b85488f6d357f2e93e90223e85525eb0ac18659462d8e3ad4c773cdda20632afef6d82579504203aa3341e6d8704a65239d4ac804d1378d17d48b4bcc20c74c38daf854cc6d1f4ff59a061fc660b490610f877d0ebc42c6a8b8a0b0c36c1038ce4da3dc6539999c80b9456fa3217a2a8843f3801d2b9b127e8051f6c7efa48f96280f1afda5cd6bec8aa290a07cddec7b965dc87d1f471b3d0194122fc481870f8206dfff0bd06058e7839c0213b4e853ede311194771a9d863ff8347262f1f78ddf5879dc7795784757002166c10614fabfd4193c07a8e5c38d69597960a94859e12dcceeddb0fee06c2570faaf1bd54a13a0b510d24f1b302d9b2f133551b5401be302da5dcc0a611f4b7f3df111895695a75ad4748a1827a80b6b5a7cbf513c82a81c193147c3ec9f5fc8a7063530babd7c22cfda12c90663664e3081c60ed6e0d5a51d6b868a7aeb00c9677f5616f075d30ab1255ab6c1c682a38c02b7fdfb843ee67558fff5c37f8bbd4fd5a8dadb4aed29553b055e32cca60aa8937e6d349b9f610c036ced3728ef7e033cd5a08f2e0c39a477553de6397fc07d21cc793c46810a3c0f34cb3b294e9e8c0fdd33f24c1e430d5035fed78791e267100b734735a9f77153418e6c2a4fc4794fa38ce04889e8e2a845b8fd9c6a2cbc8ae35e1b6865db0f314a7dde5eacec9061e170cfe1d3f8feb1a3b8fff161c9093ca7ec83e8c14a2e5a6f2a4ef501ac04a12e4ec083980dd59306a63549bb45d0828ff7276c78cc572b8f4d2641ad9db5b40e825f1cb241c9bcbbb9ce553ac48f7e64a911f9a465759e6336016b1ff929626fde69a53c54a165e92db6d01e660137bafebb4707cb32817ab58860b298fee86c58691168d32ae4e48c9ffaf9f5857515247b149e7363b2f1e0047bc52a7207f9a578f838d663765f757c8f0bbc4e7a6d72a075813f88f677b298e6caaed88229c5c64bdb51930ea5b613192861a6db4309aff4013f14f77450d71a0ae1c132b31261688ed56a33930b9f538a2e2827fbe3fa8521c2fc5bb88900c9de68ea54028ed31cdca15f2d31daecd2304d90cf932bd678e6752d066222f0422bca2e16a32b2097d039a54fb9797ddb7ccd8a25c4e95cfd28e6037b35464429a4e024317bd160c55a82a767b02c3bdf1ce52dd244b145e73088d6bbe6cf64dfb807593e999885aa3a19f1a0d9257a487278b339633f8a2f5d0689143e22c4c27af742fa0f0076a9976795747b3260f1ead57745ff8b329ed003e9e0e649f3c45e8039ac2ae130a93b44940897c02a98c602fdbf313810161145825efa6bfecd79b968043fb8dcd67cb3f4a73a65e57a353bb2bdae5021812e08edd7ce8f3f63666533143ad7fc0317c71b87cfe98d4358e60ef6854fac31c5cfc08acda245036f843a284fd396657f7c0a9a7a93b7a543873881da40582871d779f05de115b06469b88b72a283af039c58be937964eba72d2a2b1371a798a9a3fcf615e587c0867351d71462a84890408198e8831a5bf95dd634e091c92f03cd1142bc5fdf9d43191588694c28d0cdf826bfea432e5b052d1abfff4470e11f1f73fe0672005826992b5a468d0424defd379dd8811093ad17d9a6fd7c93ab003163ef8b34763e11c15756be53bd4dff201da20cae6ec17ff0ce0aa3174bc0fffafa3f400d07906c82cf341956203cad08170b978a4f777a3b593e933199b05697a7ecbaaea49cb5291077b36d0cb9261076a5e9f0a5229c3cec9514","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
