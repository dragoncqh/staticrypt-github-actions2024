<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d6e3d8701b356f96453c15ff80e07536f1763c821fc6eb2bc130c23a396d65498bc6e2a611f5284acfac394e038f1f3d471377c9de54e3dd039d37fcb71004ab928efed96bddb7bd64eb1ec2ca8eb4124d0916f95b842bc3545187c7fe59e8b198ba62da6a453a3d030013cff0884103f2f77fa5cd5ef743f55ad13e8ddbc33cc73acd8a75f388bdc220c2fd09e356f1f9c4cb3712e11146af151ef6a42f145d19fd637930d7589fec3e25258555f8c21a8d1c0f699440b8e09277e97c3b1203cc46d2f408d989960b62957cb386e70b5486f5f2fdf575610898a8f49e1e78756f9f9840630028101cec78af138833adf5040a3b3a198f4863f803276e6dc279efee439f64db741acb1879ae95b5dee59f6c0a5f256ae71c45810252e6355ed3c9b101a1573fb4b1a5b17be4cfab0097f989a258880141ae5f6507c1418524472fd809540b690c39c2d61e963fe118eae3adab3fc64441faabf41cc3865823856f30ed23409fd6a4e4eaf697928ea7d02f91caf11ae51e3389b9a5184f71438060ebac1f020cc16002bad863d5d4702b3d31ef5f0b68927d88ca3d25bf3986b30c78ffda36b17962a375ead3f2ce7ca6e13d8cee421d8dc9b8799fca86800e7efbaf21422f6b14cedc3ac5b6023580d27264083dba67ef7a524b5a56b4fb1002768d1b9b030228c9757db04918d230fefd7f4f4aed6ec196678afdd311fb9f07ebfa7b47342b89d7a5ffaeff0b17e22ed7024aad222b349b530e1bd507450f4ab024ec988ef49afbba226e9233a196af3729c7f03cca344b4a8f9396f21867d7b05009e843da43123e4300261c22022d890ee524aa1045f4e4fd5101534cd066aa2230a249db1902ae5a5fb44b9b31a802dae3e74f70cd5da5747a0bd3e738c59affddb0d32a42b7c978a1cdd2a5a6103b1cd8d0282aee8b98ce276cf67485b73d9d4d4fdd51cb0cbaf2b8b5896a88fb7597347faf7af3a80a53a4c1143f466bc3eab5f5c4f9c3dcb823df7d9e6b25aa11d76f71f798d19b02e1e3fda73c9fb97e5e1d43c1a218c280f1e6db8384cb105c7b9b75c99b7535c79f623e5c07ee50a83da84ee80f2c8806ef99ecad7e519b1a7979836193d5d01506c2773cbd451e37ab0b46fd7d6e3add0a5649f9773a09fc28d516118162e5f14c9760a8598a76bd1c02964ad9d36ed354f4874a782ddf1feedaaf86d714693f56d1eb3c9ce44a4f24853f4ebd6138277af8320f1104dd9272b727dcd45e821870bb16ada6d0381d4011b8b5b39989b40cc9947ac3b656723d8e1de187448dd17def07d5e0c409c8dcda0335bf8ddf03047a196805e2bfe04fb70893008a31cc0e9dafae9cac0adedba5aff59131e3bdb84c42fea3c639e9418beab5f62d9f9da2340190632ac57de22caf8160db5f2caaf7f1931b02206afaae6f2789384b013ec54d14a3e25b31629ed577e4524b739b46fcc539e38424ad47ae284eb8ab5d629054daf958e0a6993c7c1725c29c1ffa0948d09028172ca28fa936720b89d0f3ba0d8a3a6c6817815f3d13cd8602084ade733fbe059c42e6787d91f14b15589415b3609b78c8d0c3dfc7234ab3846645f28339eba8de71c8c422b71385ca6148a3b44652b2f6fd1096078c9dea3b894eb1de0cd5915924966370d7628e433a5cbbc216adb9ac38b2cd30a3c248770f955f8aee8cbbdfff7c72535e9239fe50d602b176e908fa45d103c8617d8e40085706f3020a00f1d3796ebc29b194c0be42a5574bac054e007f54f396b85c22a6624a204f1facd1c42d1826eabd44be777a1932f082d7129e7181fe136c1712dec5e7862bbb790c6711dd3d140757a18619f64ab4f960d74ef0702db48f925154bbc8eb35f9fbda013f6bfb167dd326c210c6c6ac692001406280bb6f66a63124537d70ec50a9874e21dadd197722485317b6c29aeb1f2303711fd3778394da929a6721c0dd5e14e36d85798ac006ed7760ba35d7d7a5ab10c23c5a2973c0318b971304c47378dc6814f1738ea0d5663ec6fdd48e7d712e976d67dddd7f79a9555be5fce34b25c651e7af957a9986ccb114d41f79ad77d18a92352aa799dbc52695e7e5f8ddbf044c157ccfa15ee285a806f3ec678e2bbe9fa91145afa026258a60afaff575a61aec72ce649e78f9ec5b19ef05d11e35740d1edc9bf1fc97171c9301ce31c228ce7cad1a81f6101efe2425da010d23c6248767810480cfbf47e39b9d2a7fdbde3f997e81c5cc339f41c1505f237b493b2205fc0780a51ea0ec2407e8e9d3be53d291397c88c852e18fe6a06c21e4ab1d3cb283eafc0ce782bced737f64c576c5684659cab751cc23fc37f0d7534fd6f994834aaa35527a6ee1378079f0c8daf5f04d9de5768a8a2227705863c5551167536777f48538f5170b404a020339cc617e62a986f3688eaa82026e575e26235bbfb1879aa6ddf7ef59fa57b516f261dce5cbd0861dc3915815bc35e1ba8fdd924c8dfff10d70b5b458534e3108a3c3c1449295c1a9fbcd0c3485c4df417e4a6b4e9925d880ee99c1756b3d270f0812c7c182d371af0cde76a2e8836707796840bc4ae7cabe06edb96b3931a542b8cad459798c344f2862f921f7c8a497eb58816e7f5eaa63804335aa7ba816078d44f4c924f58a331185f1a6fba658ae69591fd71d2a1f12647db959adb4148da4edb82943a7f521ca1465c042261d839db15f8ed39fd39a366c94b713858bc7fcca3f060a4cf2f5614b0daff99aa6d8597941fed0b7fa80af616d7b2a39b40bb953eb61bb6caea3e896992a4f3d2eb8824eb48f80311af178895475db7b5a21c1358be36cca6b2f0dbe37de29a514f7816acd6d84cff2bfee0dc483aa06b985b0a4c5fd94ec5b9727c8aa4dab6ea9983d812586322f884adb20d6a5ec2f647810a08248e62d7adae6357e626ad95db1c71b2c5afb0e8313f862eaef53df0cc4d9012a1869e03b9db56fce73491852ae71fbb11c7f864602b6b2268786368e2961c08872ebc7d3969d0d8c2f326f85b25ed81ce059ded22dc378f1f5ea81e2d244cd063f7524f0c90465987f89087927e5b3507cf14cf3f25eaa9f789bf9fc6251c9c4db1a150d727f0ed391fc02061721cffda38725b85d1cab7003acf5ae0f4047307b41422047f580508a5af454eaaeba0ed296231ff053c6a3fbf79b95fa357682311f8103f8dcf5c6b9dc60822f0b59571043261722b31be59d949b9089473d589767eb9dca12a08b88180b1af95a536c6567557f96053b8161cfc2783cf8cbd42ccc134b8fd822a04d5f4c38af22dbc576ba9faa6924222916ab4d21511d554c4874e3d1ab5a5cf0676078068976361579cedd2383b9e4f8991d81990c9658a8a44b6883faa2e9d035eefa39293852a3c5f10d439221628a17cc35c378da9542f2f7cdac4aa5339241b1580d6307ebe9ba514d7ac10215a907b5ea8ffb3ed51e153c47e267a04841c542bfd2307c2bf63770b5a3e677b7b3776e5cd458d695aacfec31183305fedea8e358877712ae16b6feacd7e83d896526239253928a6a86d1bd233e7872e70e68e2a6e0a89b94952d5f83ca047f50289d8ef24b141662542a595e4a0077b2158e1144b6c191dc16d5ece5a44e93f62b5262c809516eedad00622a5298cf0e62301d116686c34a18ff9d29cd56bdecc0b131e8915728d8a5d07aeb9784832f833e4508ac15373d4151ffab260d0ae205395cde954632476ccc76700cd2c2d040a94703a310186e7c40da1aaf83f31d91d9b780c45149c29a054b96cb609c5bdaa739d62ce7e3043c68291e2a3d791580a9ced17da1e6caeadb3ac3cdf5b25fa8cf5533a50f2a47f1d6788038cc6085f9aa293ac5068d25a7cf601d02197d62960d0fc62a2b2ed4b686c014202580c090d4576bb7fa8e33f3227023d34e5f1e44a8a31b482c0c5ada722bfe457cc17daeeecfd4e9d38083d96f4626cbfd1e37b164d5e985787c9950296619d2254b4aa323d30dff5def93e9d4dff04f3c55713450150a7e901c72dda1386287f6408520259b32d49180266775a45980ee91cc9a23ab2a769dba434c7702a773c562b05dadb321e95569cf834864a23da54c1b4d190702c74b68d92c135af18d08e00c1afa6b1a41f109dea8161be87647a40271ea4ad0a8de8316eda1761654a68198ef5a64e8f82d0b9b46ce443c55c6bb855bade4c72dd6641365a1db635a29ff61bbc6f6a4cbae350225fa83f922e1a0782c0597cd8f2931f4b02dfb9350621791fbead9d2d26d78a1bdc138ee958dfb52883d92055c50472969fe592e5ab6929d493297ce02228d56ab578f91cd9da78adb1daf96abbe92792df0dad1497822d55b74c6f45cb2c8fe63fb7c76ec9e8067b7775adc2071e20aaccd2f5661eebde7f6a27c421f68a5e7bbe5bf4727599cd1124baed79d59b5752b45ad1d30791cbdea40606439748d6a5364d3ab989f26a5aa1cc114c0a04eb21aa499c0c04d7ea48fedb84c1ae38633c6cc365a4b422cb04b2966c0c07f5a94c9df50381df327094533615e3e6cc5bc849beaba2b04c7f4c934b84e9ee10f163b0fa2af44732f6bc333e556d447cf0dfeaa87b898b03e8b55f7c327ad59d4668e6c8cfe295469f51ec3319365b8d8b6ac0fefa4d3aadcabe1eacdc5b02b26ae3fde3484a65b2f3bac299fd5c0bd9658bdbf32b6e43a798e56a156787e9eea9b3369bb375a10bda78cd5e753482ce0abc91dd569b4897bfc0d10385d2545af3bd315aac026626214c73acfb4ccc185a574f4ea41be450396ee5e0107d237d1bf002887d1bc67fd345ca58b34a67b61c90210a97f756b54fc1a3bd868f5a68cb2798198de1ce9d19866ce4a9e65fa9ceacc99fb9ee36ebc953742a86f09021ad391175c9f5f0b8a7f75d0c75fd3a79bb1b86d1f22a4a0d247c8a3df466703287aabee3f09e348e843c488ecf5f400651463568cab3843122e3cfc8cc6826f8532e59029b44129ad36946967e0397ebaf9aaa1a517d7cb89a85f343f588e3cfcd37dd251dc8b6a13dcebc87a1d67d91b87989df557adc7c82a3a3f012172759fe0c024f67407c3b1ade144293e8927720e018673e86c8186f2eb4a108c1dc896618c384665d3bfffc762a23ad7664e543194a90e7d69633dd1bd3c51dd2ea13731218657b08b93f1071357412bf68d310358cf7e5f731aee6d0dc98cc0aecd81f7a9a4f0057e2a2e0ccdbf700082b24f5455a185b8896755dc8f7372b90ed87481c0bfd8ec4ae22e8033cbc384317d3a01a23eeefcbc01101e4275ceaf144ea67851b23f22d2f00b42085d020f656382fb56626398feda5c67def32cbd77948170ec3ea9b56aba88c9012daacb7f1faa4cee4c0a59fedb0449af1dbdb7f3c26af46b988890eaf73f04acc86f6162879c0bca6b386d8ddee50f42a82914150330ae36bb6f687b45081342eda22e073a8a785378a178d07b7d105c3361eac64acff9e9182f684014cdbd4704b2090867a415b2fb829eb01950e69580070b34c62f5a812027f9eb2ee19f38d82d7a0e34c52555083e0e05675499ecc8fb2f398df6e9e7a55ca2ac2dc825dcaf1d8093ae1877aa4c04196a9e044ed8544bfe9d944a4302d84aa4aea70832fcafe59faf1800e36bf46ec2fa09262a403b1e2afc0ceecbb6c1361b763a5663a332b99083cdcbfc4ff3b6bc1e14034130415c9f9109a04722df0bcc4f45f01f6eb6b639666df3973a8eaf79d20afbdc52b9644253eb2785df98aab3e88b08aae2fc4f720e559108306d5c1ea4a19698d4c728ba22ba3c92f2d2f6b8a56814d68f76b5362f568dfd162cabbb19d90cdee849d7b1946919583ae87328494d997e456f8df88172cedf20a3d48910db2927c6780ba7a4954a2351df44c74eae36c134e17fb55d3bbc71afd08ccb8b4293f560def550dec801a0393d2daffcb3778476838017db75f4f23444be6a1ec0a9a7c7c7990f2bd9a8bc13476e9281312b8fb90e8040736c087ca61c82b5bad2daae122080af4ccedabf6ce07cf14e8f08a06f2cb57889946d901b786d6f915cd66f35300b4f63f1b77e2dd8111220663bdd8b939ca88723a632a68ff6059fa43036087eb0d3f8d800850662b422db752233c3b166abd5b0349b5963a5da36a4c241e9f5e376ae2f38d768b5a055fca6478d03df7b5bf8c3e557172fd6cc7f424a67b6e9b481ed0f612d93b0aa7ab4b8bb10853554801c00b430167435b6c54569de50c1333300ebeda3cf2cc67dba19e6e83255d58a408dc9aceb0620f0579256123095539d3389ca791ba878121fa54fd906771662d63532a4a0dbe1a085c9913dc038e5a5b91ab263e6cde0918f9f552e7fa117c49cb915f8a54dec6671d18ca31383b6707b719c1061eda9a835bd5dad99159230a0472481c04c360ef22790629f1f44d33b30fa78f3c5d171e80204a51a12509f7643e6e93c497e7a8beb60e14e7bb54823d17b97ccff6cf2af439008d16f7852345737f82f01f226ad7531e74f476687a5a77a4408989cda8fc9f25bc29752cc0384e9f11ff77ce9a5f05c51414e0a40909077444d365a25a438a00e715ba16a6c2eb7152856eec16abbff3544d355e711471cfe98985e5d0a8f49680001c7304833ac2da183aa9ac2e5771bfa6b848d5de09be69658b3f38c1b51aa2e8a18ff9049682ce3a0430d903eb3ad41f689510e4d1fd6aa0ea3032c78f8c7cef9ad279572d69a051bba11b15be22285d3c494de812e75c0bff199347c9688c2231e95b0a215d99e43ecaaa1dffda3ec70c82aaccc8520fb1b34860959afff684962715e1ae8b36cb13de756058d35eeae9c0cb49242375e3e49c4c4f3b41564e077fe449fe05867216d703041fba31d57dccfabe3ef8b07678a04df5084b3ea0b10eb96162a81de01610132d6243a0de6023399c0eba3cc5e1d84f1551c793f02163ef038dcd25695dadedbda6cf2d5e16e1a9ea3e09318b4be3206efd9e938417b86f4cbfb8272d56705449be01cb10eca772b6cb93a073ae8e6101e133685f8ca1e954a1d358115408548e8e80eb20b02e31751fbe1c8a1af9a3d6cf4f9a8d445e6db5e49a989e08a37312e8df8cb8ae749594d2891ef7d389706b0d492347f5763719e50dc991ec45d3f656edabe5d6041c65f9991e1c4228ab74d66113c0cb6858a7270b326c245c063e584c827864bf083848e60263c14bf39d5c7f191bcf5f27238154b9aaa36b8924b3323fdb5fede56ddb0675310bad9261998bc867284942edd79382d3cfaec314ddbd1d20b8a28b86e586e3fa8a28e0e91fddbfc960653161968f853672e2cb01e0384a0685321175bac824f8c0ee304d092da315c48645bfa4db4fe739bb54cd7aa007f96b7e83f81cd54639efadc631c654a0b281e242aa62c7eaf8854f4d4b2f586134c9b0640883713a6cce54857ab31ce32c4a3506af66a7c72b0a6f2a62654f68b5634dfbf0ab7b483745e0f56acbcab6d10e35fa95b3f77f331f172db90010da129af2886a8b8d4bc41c7a15e8992eb516fb9d00f4285b33bedab5c24e38b74f46d8b2772019dd544e8d596a57c37c134c32140fe432e1aefb27d851fa535e9a5300d21f813659db4f6fb0705166a7f04287cc6be93a92e74431a3fa310348e0a1c9e87ebf562b4bdab204fe5eacdced63024e0cb2bb6fb5c9b290aa0433635328659f9d90cd5f66336a58c576f7da55c8901621b6db90818a392cb6168ea13de1a06506bebfb895c083b266ac35cd1b9c3fc8a19d034e0b7c40c35bc6b78dca29ad7a7f610feffce2e34305c5f4236cd3758d79baf08ad1de43008ebddef32d0d57dcb77425a2d9a0d7ac8f5e644acaf54f27492af4d6449104be89eef3e03f0baa130d639476e1168eab9cbf1739e1d8715692241b6cd92f261836fad63c41f4a26cdf6d5b3c9aa7e179c2d8deda27666b2d32bc02e1f7242091517b696683d33a6248c23355f157320059f121a3d3e1d90ee3f6fb7de278c52badf4ec8f01b2dfa2ebbff4c86ee4e0f10430cd5d3e5a05d17f6847d9ecf82b246563eab6414782b604b9390babc8d808785859ac0281beef2381d70fc43ef3e4a9790a78e05efd0216077bf64f983ef9858dbd82495bc2516045078c008e29eb664342663bed763891ca4c522d7233335cf20300e826910a3c055ae89f52d80adf01f6221a95df497d6cd1adcaeff4dd628804edc93a7f6cb27b4e858e81a3a4955cfffc131bcda069a77146d88fca161c08ec01f15eaa7c8521f758461f58a296e82e750bbba0496a358fcf5871b09e674d39e1351089157c1516f6e6e462729acb2f3a68e06fbac58704739fa683c95fd0486589f780d10d0fa08ce92eb6408591d297632f3f79ac53d2d76979645acfcc0f696c3cd0092da901f27c735f24422de3d0aee171297985d752e59e0239c938da4c5445ce0adf8e31689cdc87a0acf584cc3ea35386cd887aca76b5b45a263b97c4e15851fc9e08fa1b1eceafc781759818d96cd16232ea3b3d972021bf94396259b11d24269bf60780df7771f167b57c0c2b595a534d13643134cd3c3e15eb39213a6b2c4ef880e77cfb284afd6116c8a666641f811a76be70b9fb1e95c5a5b104d2df26e032342534d99766912a9a2034372fd0b9c6eb74286d2093aa6d8749509e4b0f1ef55607ad2b2833fd5aa66a744937c3846a77fcd18d6e2366b4c1f6c39a075a0e8e7fe006913cd50cc3b8e5379d114ebcdabb79c312ff0e5da70d16f7ed19101847516a2657a2ceb7488a106f5d0e75c15a6d1b51332fcf584e5cbb3086d78222434319abc5155d3fe5dc626a6305a247db211486e132fe7fcbf8a566c7a51ca6079a0a946681db018c7c211ae9ea354fff743356e047f32b1c51f74693d90e27d561f8099cdaafbe5e48151efaf5004973793ddd2b6491c620e6daec6f46364e3126cd288faaa9ee020280e01c7eabf1b538fe89c38eaf519f92f1ad2bd7e64b720477f46f6f19d6116d5cb791440d9cab6ad52413762988f1efc69fa7dd0023a36deb7678efda814c8cebc962d836d34ef4f12fc67e0d1e0833c81e29b32842c6ede0e9243749600fa854b583cbca47fab0ad2c1f780e331a9ed3dfaeb1b880d27799c00628c574c45b1c1d9f3b0e20e36d06305151e47743c839d72e8ecd7611ab89827b0427fc92a4b6f312c7be99bbdb928a3ac5a307540b38c81967719002b9f9090e2cd92bf531edb85529621aec43f04710465b2cf1d4d692c394fc6617c0a86b8d68e399722252316fb185f1957817e69ea96d685cb3362db5a0c04bfc6dae63a5a0ed22201e00aafcb8923192228eb09e541f271d375aa18a7f028cb70b7157c27bd608aefb16e12288e73750841945e6f92f28cb3b64b005c11726b02f35a49ddcb95efc60fe16610dab1de2de41f85059c63a6f46ebb8cc9862058bfe41a28ec45a228e84ba8515ea1661e6233bc925a6f796c437993497456abee89982502e504b27425330c147aa1861f151bdd0decc4184196ab64f8dd08bffacc57d634d7d0c4c1b332a187d1b3b89198349116feb38cb2a9bf6ee203212563553148cdf7b1cd5780f40b89d679bdf233523c53cd95b134195c68ee7e8e8a2a02644f3fe4b42656fee170837a0b6ad932066dc3642b42d20717e5b10c27e4ca621efef5f98988e4c82a8610e4f64bc0e513dc96b1164c25c83dd2866e3a3ec986734e03e742b9e45b605950eed22699e1c6e52a20d8ea7b1efed67806a5de8579273bf185d82faac598a0ba6c480e709d7234365adc53f3e60a4db9134f5971db32c3f6d0b19a8a4706d7c1558cb8a40c627c02041b834abd878b62a6f810b4acffffeb5b41853011d777454385fa806740597707e7e3ec8a663e8d6deba0d82fdca8d2213a1d4fc249175758d2a2a85b4e9a42a4fc500a200b9ab5a1aecf93cf336666426edcbd526a27b621edffbf0227572b608787c77f08b6ce2a8491c1b327f29af69ede568f95796ca0f7bde8a138cb6aa4de2148de0dd68f9650b7985cc6ac6461add5b19edf24b93dc2ad9471177dbddbcc968e19a5c35622a712ae1a287f36a805b30630ebc0367089d93d962442958876cd93776e88b2ab2fce957ea5ebb7dbe1ef3b5f2290cccba20f26ceb017e0b216e554d583231507d525dcd35b85da6fbbd4010cef739d7ca9fd2574c8839cb18226348aa801ad42a79d695ff639535a282de1ac599a608d58008f6a7744a40263bfe28c0e54816ffa15ffc8416e46e0a847b743ed5fb8d4cd47074d691bc8c624511f61d0329355bf3dd3e5dd628ead781cccc4dd4dee8ad19679a61079c275fb31305d06a98cc3d6bd838aca1fbc4197e8e052aa84f28905d90e02cba3eb3ced85bdd33bccc73fdf7ed585dcb09dd27326f7a9fe94ecf6c4931e4c21b7f78d55d89a04db03661c0d4e1a9bb0e8b539f20d89531d414627aa3e317c051f0aa2401f1148523914333cfbb941fed9065417f8283b6cbf3378f2a505cde68b7d5739dfa236d14a65c2f1173f6e0601d09596e55028935d632ef4e70c4ba7513f72aa02f555e435298519e7de5bc5b3f4322c1514640885c348748adaaf21ef40694652c04d16eef1f9bdde70e67925a064065007d18a499cd45fbd8dd39e5fd1b3ade51fb2c9f779d9fbb1cefa6c4ac690b9773c95b019854832a5f3b4e77b2de95286489d102aa4df9d9e15b7abf4b6b9723d0fca7da1d8cf79173c299e2231ff59ffd3337f6c615f7470112d102f71ba92894e5219f12f55099ce540cfa46886169ea9a16795a5c66cbc781cf1f3a402a4da9349101c5c186d0aa7de0353c7824cdc1416aa8000a6d8e3c1716b03e263f983f951ef813ccde41f58873bde77d5e83c55f1a676a7702983c973044ff64aad591cc62412294085e6921d769cddd2b5b6804bfe1762a2c991a139c13c275291f3082069f00a28547b97ebac2762fe8f4a76b24d3e2cae586f6796e0d8172f8c92257e4a18e3d1341d04d3c7a3d76700535ff163db9845884e6bb3553ad929e859df40ce6f24e765d2e35e9b105c1476d1540ad4f54cc13ead722dd3da6a60cff211d6e7aeeacb951e0e7a084b170ed08bfb5daa81d01ef91a238adb65339cd98c5dce45299460a04105d7de560db77eb1e1ef34854498269b8051f2cbe077bded4a669399a50d7f0e2a077bb0899c1e49d2170594891f48ed6840ea912e2a06f575ec88325ad6e7d86f7f4efa2d7d0902b70e667dbcd378653703a72c1c34160ff7edc6db52fe66be197e22a24784bf1c2883f34493900628ac8fdcf2d11870d34c9f0872b61ae5b53f75a839dab3de6a93c14990e0d3c60efa603c71055ddaff2e61f1d050e48eda2bf179b7c5b2f295b68b5098efe5eafa868c75b6715968d53cfc744054786e09a987daf5eed888929609d35a5d819c2a5c7dc3895805e5c145b6d6884470479d98585b9c77a4be150f23eb08cd4af94e925f4ff6f256381ecd2df5da833a15033223241de1f3e3d52ee6132b5458467d016a587bcc365be3f2b719ce3b0480ed2f7eb7e0bc0a652851b43771b3506eeb97b899ff71b4bfd9fd707846f2d92854cbc2629b7b8d7bbfa15481e8281bffabdc346d9cdeb58a9f07842fc4be134c6797fc655225596bb5d6db14ebe8b9a0eb2469e106ccddb33f0d9e979f0c69524e6e8b0afead33d069ef88df30fe3cd93c55c239c88520c9f53431640774d9e63f1048d00beeffc9b45bcc10ca5628930944a344392212b77136a9bcb6494aac5fd3518a42a268f88f7d7efd01ddd9328df4706b43bd073b0bfe63b4964a293df40039396dc01188f7d2895af1281a05cecefa8a42399fc815c9af622af665610eefab120c2c620745617dd2b39a7e53cf90804a835f2896095688602c218b4508ddb3ec137a287d6a8dbc9b3f50e2a380fe1d448501487d6df959a7a46091761bab01719bd7bd2bf3cb667e49d7ede05a86ca5903a7865ebcd5b5356d06142da66e9f7149d483f86173993bfeaef266ef27e65cd4a9cebb6abb0aa3d59199622c3201ad368339ceed9e050e061ff870fe07c18f86ac7edb028534aa9929f35caef0614822e64b0801745c5fee0efb9214e06e448c662e16c3e7fc61ad159171cd4fc869d6cd8a4c553010d2b25dbb114c056979bcd32395bb5e84cff9d8eebe50d68117be2d73d8e65977d9c642472ed9f90867d494436fe457a7fcc90404a2b4ba39618562969234a7a12bd048b93436124f9fb0bf1bd7dae965519088296e8b5e6ddb8faff84fb57cd070195c95ddc978dfa5ed9b87b6c44dd69b20ff83e0a317c64d81522aaa3b03798752266effac1c6d32572dafa3d83c2b975b3fbebfd3789622bbda6c62f5c048fdaae982085804da0ddb3883679d1eae04c6a4f66a9d51d7a378b5b5b3f811fc3aedbd47bec8acd8e83432fe871b62557e6c556e2175cc0f5598722fbd69ee1bf8dafa246cd08f2684a636759eb59a661651db16bba85b90bbd9fac5913fab691f927ab1545d66c4c73aa9fee2b5314cffdce864af0d141981815e95e32953862a715890152648d17f467018b6937c495d5898d3d517e502925b0be8edb87a5fda9ad5d1ebccc9eb5bb6db8f48522fe5b14aca6e4490d7a05938f1854d7d70e0923e30163ec9a521ca35d386f620c1785cc9b13d4b4c6d112bb206c13bb57f1ffd26df04e08939efd13efb759ec09f2af8d8fb3513bb0587a0fbea5958391b5f0b87001ef1ea8c5b4c69ed06d6f69130ff28501e1b3cbe52fc51ac516fffc8dedaa6a81da54f4f667935b9e9ae54ee0bf854796726c9d968515536a58e5431b6ba23456ede27b7a840712c6ef1a6aed06299175ce260ac55f46faa858a2b3d301bb9f2d78c79376256746be8cad9b824af696f413360543d1b4ee7146b7c7fac0af31566a7a6e1a8c1d73e9fd16961124eec37a000852c14dc5cf896515a7ad60f8f6298d6da46e3248cd32bc11a95bee9c4f5f9c3955ac864aaa9111a21dc2af8fe4da42db900e84936538cdf1a2bcf226288b87109ea2ed89ea98a9f9e85c9d391284d930e48a88d83d6a0c6425a1d0c6a49a0468b7efb7354cdc4d1b04c47980e0ee42ce4e99e329afc29ac469df8cc106301fc37733417297f6f5f52fb55877c4d3be6fc4dedc43cbe9096f08d3409a3c43817aaad33f69dee2c5be5e4eff24ec0c1cf0d3ce7cbc53f505daef0dec12fcb87837747321859eff0538b75f270736eee01574d8461d270894902afb70581d1839d3306a3a26c5d6b87ea711099d5ee7eec3004a879213b94bafaeca79e5629562915d3df4074cbb332c0233759771f2fd8d74337d957da374317943439b5531df44d3a027662a84bfcf38e880ea02e4a08287d30feb5114b50afa3ebde3725339f7d67f89e8c7148ba9ecb89636df6a21e3621ee23180f6ce1c635429bfbcbac9382173cbb5566ee62595f2b9d78e9fb5ca2c32fb6fee27302415029f6386ffd7f8af6236c0f18465610b666935a9d5b607033f82fb8629661f9a5876205d3c4fe462aa6438af45853e8371195ac5e2763439270334944041523eb37df7af00658c394b1676115eaab5fc8c333bf7cde605e3b975b926084ab93f6e935e4798c8e3bb7fb1657801641a97c728b45372e8fb77ea2d3a7997893f7465a2b47e0f39852d963202a3cb83755706f8d9c7fe86bf4df755db890bb22487b764e96e0c3bc5684f753a50f2c02633df9f4122c853516ce76684782e70db81838161450e5e2c9324c45fb7022de9e28053edb9136f41eb2847e4ebf4c2c779256bb08fc10208b9ccd3402a066c2d79d0316c4e7e5b173c328af9a59ada6dc09a9dcb6188f1bcd3497ae6d86a818b78ce102472ea4f3909c4e56125b491538b34d867dc161993a23fda295f5ec55f52fae001e2324534cf23fd06f1bb1982231bb174e47de3d84e1183303ab87e97db705034cbbad20e3b7d67db76eb030f0c618e09f6476fd0e5bd9d94a20eb51b3d750806664d6b6d94b157eadf12b036423c41a80c20929499677d66fad64e06cbe71fc2f8c8d376cac52c59d30e142d11a0fb020cc664da1ccb404840b2d96b7d60ad85df24991147ea274bf237c6ecfd0301ad805de47d4427c7f00cc771ce20355641b2dfb32ccf6c12da34b1a77662fec0c5bf150792d61259f420a7ed2efc7a506988fad5f6c51afe167dcced7af9e0a2ec7cae90e10cd9cb0bce0124defd47cb4f8e7201afdbf7bdc06e174c048ab53009643afd3dc84c274140b79fb643c5f71a2cceee8a7b726adb48d48f362ef47d4ad367335239e0e68e62bd1c7db145e02177caba6f6290c890711cf7ee7f1bdbe27390260f52941bb5b5f75a95cc15f9c31c9bc940a052551d93ba5c0b2adaa3758ab769ee98fe1fc6595ff4ed6e6a111f38a58d44df44627c9ac2778c238cbfefd32c5bb4b736e72bd0a7c77c334ddf545e578c50e0404ac52219ec43ac148a8770f5bb8d07e3a8757a56472529e801181d3eee6e26f424adfbc323f0245ff583c152a6f1cc92dfe04515a1bef43aa88ca09917b39052beb57fbf4b60df866e67fd1eac1fdb8b6a5016a9f9fced9eb657a3f534567ff4d39ffd98fdf7040401fe13e256dc90137538a1c4828b80f060ed76c534670912e867c8416e4f9224d53d0a043fb14dde0a5de5dd5305f23c969e419336ef3d06fbafa178bb356e4ba942b49c3973abe8758d8e63f8dde46b017ba16c034fa2ab1822ca12b4dd3af676fadf7b325de3c0883f9d4200c2c76c8d0d131cec49b68602532aff71ea46512e061e1b51135214fdb2787a620af0bec05b458235907db3f40d539e86f929d768e80b5fd0e5cd316a47f79d7ee79cb15777134c5405fd4724977728760906960ced689bf29fd521a7685931061477dee0217a2c206cf1d599294ef0220053f6dedeecdcdf676a062284927b1496ed2cbe74b213bcc45fdbe7f4773abf8b36e21f3e05812aab876074188bb5f8ea73cf39fa1f0c95585b257ae42d793c84aa8724d02882549a06ae29c1a2963add650706e080305823a4a7d087d7b004253f257a094cbd30a391394c00568255dde126f244144a198b4a62261e4f2dea45c5ce03cca8a20709d028d4f25efe7e8c9b4ef556780d0ffcc833ec642fc3f772bbe5576c0aab60980e1a2c6e76d91a93b70ddfcce6354bb072098128835a513bccdc8717d48f90e80fbab6096cf0656830f5663c51a8f658fea99a4ebea391faa29cdab3091360a63eb38713f1ba8418d6324fadac1cbaeba474b98f6b2c6e2cbdaa5604351e1aba250b4b29a8e5a4f429a59593f089a0feff6b5220122f9fd6cb6cf5b928b5fb606678982497ba08618ec5b10a871f4bf47ebbc28758808f2c257db87d76a0995ba37ebf4db84582993cbf964f906e682fb81671f5b616000e7b339d40b4c0c8d611f299db0fc87e4837f84af72f557cb2a6480f16425adae7a278e7288d5a0778c3d7d388c849a6914686d37a066f9308f199a649474298ccacd84acc1b42ba472786a3762a59adaa7b8ac565d9ad62a149761df3b72bd6d888c0ca0560717b3a93d6d3b9c9a7adbc865834167f0dd1168bcbb1513747bce0647511ccc828125ffe50d4585e4c729b590648f9ad4a30347dcc58969fa9dd00c57302e4a526dae1e4b4f4bf66caa1823a874a2a0ab3080497ac6fccabc2df288469df04d97faecbe04e43559a0264d2da3185c021d596964ea8ff9ff0dd5446fc820aafa67bbdca051ab3a98d5862","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
