<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a72d6bc75b1ce6fd80859276298530a105c7e949179166caa60954abdc3d623b9179928c0bb1140c828df52f6766f64cab3cfb141c9371b65a4f7f5ff001a827c1330d21c52c1c4dd2162c48ba6355eab5feb84006509be7daf57faa3f3d8bce573c1cf22835eaf445f84767264cb27a4557c820d6aec746c7ab397e0412e0345aeb2feaff4222ecac65bffbf9cb78795fea988a0389a7fbee44e3e587ae4778481453d9511d49f0b64970e860b165de1848b5ac440c4c999c030cf29e9fc33ffdf469f11aed5335ed942cea54a1fd7a160a7cad0518613aa273e59153907549d56ea017e13882500b1e6c7a71513561ab9f75bcffd98dee0ba35dfa6a0fa96b40bf050bbfd2488d36f8c4185e170c6f6356931b5540b52033d213383becf2b15b6db3007e6c5c6993cbdf33e1cb6b860246ed8e57e9966bae528e4b5cf1b7507673bb129990570a62a377646e8499043403e220fb8230d99a3b114f780888874affabf78e6af8d0b34db3fafd511ae77668077a9b76a43ac301397303fd58d60dacf1b24da482ed2bd59cac9daff25428392ecc69cb9bc6237f13d240e69e6565091f69df7a30530486c9f1bacf2ecf5999eb095e0b81260f3175c490ae22ce26b72c1db50b69e53308ee015595e51da3f1f4388636410759d73684539183bd7e204cf1f4ffe8436e2209e5cabb3916c443cf86f3e685e6527e987df3eaf0cba54906f5a791bee75145c9d2cdf2d09632fe0072a108afae4aea43aeb762b96606c96c2aae81536545fd0f0247b684048b4af66fdd3ee9e86bd3a2aca0913abab2de6dec0a28c19d6593b849fc04f9e363ac8fb56270706cdfed9c9101d4c0d7fe49c6277eb7aac521edf822b49d3dd557f8317f181dd1e32bbc02a1b424125908d8420fdfaa0e798f05e3b59f02da9f108ad5c7aadc461dec0d0a211bd5fcf234303112da3fe758b034d4ffc0940ebfc6bbc8bb1cb78c8fb6789e1c93aabb5698e0137a0ee046aa066df7b19be1f54a69b367a20f9cd5022b7b47155966c970a6d59f08bf2f52cbcc9db837f0e1f2b29ba8580d1dceca9488ff76bca0559b8a3064f2b6db1b2df7b7b2fc59a02a379b5561f2f05f7b1dbbd0f3d7af262b0a5dc79cd52bcdbf2a378387d1b43b972ac1e5469c724d3f51cac22f173210a637bb9ca67a6c81f3b083e76c41b1ad75c590bbdcfdfcee30287f455aef3e435832d9716a0cb18142c3bf7f936c4a93f571beda8d1be0f38d25385bb2ce677eeb3d991f7dd81a3b527d49e0201c96a2806bce97b144b7104c0b6e9cd8ae460e5a8897746027fa4b5a071b426056f899d75f4fa09bca6ad615d2796f66ba86ebb1c3dad5993a04661ac627a9c122dc0e50cea128220d5c5b441ab59e15c32c456c76a0bae88033091838f6ab74024fc499435773e1144cfc6aef82c0df5f9a534516993800ff35ee8d14f56b4a12cc7d0082ac98d783f6d79af7b3d272cbcc6bc2e09e6b203bd71b594eaff2e22ca2e76342bb038b30a4cf5a51c8777340eda74ce2da35dd8c0c117ec47d3ad462e088120fc52bc314d73ddc26d5404e9f599f5618be8cb91abe3354157c511e8806bea20c3addbc44727b70b34b0d63f54f92fb289dadc92cb105d6392110ab658d88ab85ff54c7dc0b287bb9a02f247bcde6bf8dea6605447f6f454d5acb9813b13990b65ba1359890dd3351fa726fbdf96c71dae518bf3d64e095638399f7a20d4310634cefbc4babc48899d5ce67499e16f257355442c171d6804d455b890219911432e6c1bf78cdb1ac77326c013e8b27e8967670ebddad8616ca9829b55fccf80a1f406fca8787509e50d3bafcf30bb012bcab67954cb22366093b10b9f7208330db55f7c9ec5929f8d590ec6fc4d6b7c870c10eafd518c1a41c32ac7f6fa6ef7985bbe7c22755b71393b103844183639718123d0f0a468e5a39674d7940b556590b75c4b21f3b6b6cccd4b9be373a50b1c554478afdff71b1a5e72f8da536f0e93de35829011b655c82cf2464d27002a2b665358ea3cd1271578391571524868090d3897b03fe9519f4daddfd769e2a28cb693aafa4ee9aaa7c2325594ff08bc1923c5140fd109381fe4a35517f5a914dedd5d7bff2437bd8dc4838577873356980c70828fc50179cd068e694e5a02c006104eab0dbf0d01d3b3aa07ec28ab9a44d9b8a8238e3d1f03edbce6ca47e69af46b2d347cd128c59a2a7a5cb780cd95f99ab8680ef1a16a14234acdb36eb130ee21c396742dd1a49b8eb8f95872a4fd0178a4e4faa269adf39ed7643eeffe443e34f25a57bf83f49bf96f6a662cbed750cf5a512e7be36284fb5da5168026a3181550d131a2bf502af6be2daaa9051e2b1c13e2cc9128ac9997e3c090c214c725a551a9dc40638045967bd7bc204e1b8d0b54301cdd68effe70cb7f08aaecaee7e6aaa6807d0b9ee91233664c2dc3a350b65061772acbfcdf97de19683d8c97e68fc7e54c3464a13bd7891ee87df3de6cf0779cdbe67341fd298a46738df9561c47c2594177518dda2424901e4839d60b93035d9ba5fad148114540bcfc436ef536c4cf953b12d12bcb00f2984ddcb5fb59448dfbfb6cf5c7a5985ad43df7b4d1a5da207c42c1f5da2f7e735d4b8723d3c8f502552e5bed9bad98e19e675a09b3cdd17de82fe94b258f373b5bbea55181d119884f210dc4cb996b47f802328c36704d2b34847f9f9752dad35654c4fe1fab1abfedc83713aef501cd0b8ce4c057c9e6732ff4d2daaf78b77959345228dd25fdbf1c448c53715b66d6177fa513e04a0e9c6fc3eb35214eae7ae95d57ef7137d6faaecef0231ad9a73b851c242448f937d0e5f6d4597b9a7f1158bc06f5d2df4de0576be49db3b54115a03086b734d6cfa5cd4d28d7d810ec68c81a51a74516e62a3b8dd3d3950e326c261f53423179aaf5e569a478e29c0f624b51a1032076a1e25d46202433a6a200fbfb4e8978e96b17a3b8d7cd175dd3b8fe679b78e8c9a1315246e580cd2bd0a371b342dcd755854a22048731edb281e92f47ba2087d1e8eb05fb5614be2f4585b806f17ffcb9f507346eaedda1fa34e011c530a8d27e70f5b4c6fb2d636d3a90e3e3593bc18b241da8212f4e1c762a060c3b06f238be1071e8ec3e1ee277809526309e7ae04d86ca9d02fe6204dd6841ea694e64f8a76ddb3b526896de5133a3caaeaf4d2c40afca4f1bb11d43206b79d3404cef9ad404c0c99a795348d2c7605ef3fb0fd235711d8e0c6986633c63c2816c6db44d9297e7e28727230109661018332245c0657711f8154259865d15ea221183d8d3f331dca2a387f8e504065593cdef5c9df23e193d56dd5d8949f984c6ad2758c3ebcf775c7043ae1e8a4137795b303fe9c85d549593756407885da99066399533fab2bdbdb539b655b4472cbb9581526f83befa36be2bb6d77e36b3ab22c4f6ad029158f422f8958ff6e9d6878256c10b7c69440677ff281d7ec01420616339eace7d4a47fdffd2ebe42c18f016feed039978b51806fb4ef6b8185f32eabb6cc29d7f3a153cf09c8343b7369cbd5b5aaaf8eb24de471a46e266c6f01cf18dbfb21246028966216229da627d7557605e3f8c213804227805339a77e90a793db6f28e3c7f5e51db14aafded820b6b02411ca9c5ee7036690baaed5482ba527bdd8880116e0fe351a9d60dfae785faa0cfd5e850fb88fe78d1d7519684a7866ab74161f41e057c188f143ee9f8fbb6ab5f98393b50ae25f0cc16d7ea4352c37e3e413ad340bc9cf00a92750a030d27c5e28ce7a1aac52c683c4a92d313753edd94a96b676f9be56cca8d97053ea33f178b2f704176902b0af93fb96a70c01b14f59e59572bd54772ad89e992b2350671d1f6368f689b085c023e294d916c66836c256e9cdc3d4754f93beab0f839cc57bddea1b03996f3e8eaf2a7fda5ada89fc182ba56cef0522572d49d1527119ef98e12e12d635ab23ea42bcf87e7ccfeb13db5eefdff3d29510a9d87eece165b900608dc13986156263f590cedf7c08a411517b8dd140dbccdcb45fa3c6f4be3ba01656b8c64fa8e6f469a5ec10183a5e21c399951c9d0c60b7dbb7b4da25048c45d260bb844b8cfc1d58ef53cc6d5a9ca4b3f4a9ae7c76c58e5d9a2c0285dac5bb57babdda62e65900ab717d456cea4fa685b97538b9269137c7a08b359fa93b606e2258d7f5d75e783fc8ef9acf4a91bf8a46c5eedcf2fe932c9d6d43f72a50180df7fa6e19f3d42d9b2796e74a284f0307bfd2a1a604d6fa0d734b549282effc4b4642390aa7ff9f5f181d176a4f017f484442891ef7187ba8fa6fabb8418aeb1e8609cf8e79081d784e3872eaec1e8595177dc70c93d61d401a56c25f234fb532d0d7dba930cfcba4f96e624b84d4820273c47ff5c1848e8c0478cea76990ad7791c3019cbba7f2868cab2f3f32101517f8ef4eda9222e453092ebd47125fd0c437f534609e111693525afd77f69242545ac049aec281632bdbed6243efc1f9dc69b9eba22d2788e8926c483bed810f2105f70b7b3d34bd6100dc85367b11ca722ea94662c73a6fc192d4d4cb1dd32bf2f5e3403e9b3c49d8f6a065fba694147cd8beb453c13bce3709846eaec371b085c02c45d5a4b89b66bdaf698656c7de3bba88d5ab3aa306743a214f1c5fb60fb036d5e8af3becf318750dacec7e5fdf5b82cb681f5c8c278994a05439291e97c33df6ebbf81ea433f953b3be42721f95b2ff6337e1c07cf50a437aa65182657fba34e839a6c29c43dfb5a52f8f93442ffbe616e4437390856cad475804fd2ac7b13195522d7129e579b26d12508ef55b7286aac0e9a1d13fec97f85bfdeee971a2ce7f08141fddb753feed525155c4deb48390c97084e90a33d7b7bcdaae2010a2dce8b32f35e4faf3388e40874b79977c28a1e1dde0ecb219c943e51dee2a9d984e83c79e628b0cc7fc8337db1541d06d7cba135bea07bfb92bf2abf567387825a201b19a0518aeb8352df85aa89eb4f7f6277ff6d06b9e0b56f7937b9efcef680c91148383c64ffa6f1ce38fef8fd5926db7a6bc253e036b45f428ea72c543404ba308d6144159744679a8aba347d6c490c4af041a7292bff873122d253b131d4449085cc455dc3a499c268b3a5a0f46e7cce63e9eef060bab13827ab6733bbd4d2734f362c827c01d9f0044f40b12e430f712398257a5df14ea947912c1f145689988b8afc616621e3ec88576b0887f9aa1817a029d03816997ab200985999aa130875d7fd4307541805774dd3c5d5e6297ecc621a534cfaeeb4791bf0e77d6daaf2b951d1908ba15ecc2ca20d0583aad191d76f9aa1d6460ef7fb852a9c5ad15b9bc03fd7e8c56badd5d93da0240cbefe2686d5e4bb18f3ff630c66692625e9f1ca31697672862a9c5a726acb003e3d7a0abb8a62866cfc532caf134acd162f290ac86cd2e13067860f94d0ad5dce62a2207de7689a15ab3b6bd8a27290f278816e4415c7cd33bcee66c77d8a4e99e02d5cefc490d91762cc7db1fe1d0e874f09f7e11bd97df7f834f88fd975c1aa64360e79a07213ae3554fb25493c4995b58b09626dc1d5155bea18d65542b2427bb09a4f719dcd647323e957a5ceeea9f09a1b2874cb3df14ce17d4273fa9de4d7f8e6bf502684f1bf2cf8dd6faa12ea7ad46947f96227757393d154a494a763a8e3a1df93d0f4a21b4bae06e1b052c674aea5692ea3eacbba65c6f28063e11a1196b76e2ab8926723394006b52fa1bcc9e264b37ff77bd653ca7048f6323aa8993374808080965c8f497a7bd676bcbe5fde0b5e0c876e73d030a2ba56aaad19c182563f347c05368d11f5b8a7957c050a0821a833d75e53677e1fc6d6b96380f83ce3b13af327d58f490d2c600ae5d62885ca9d64d15db210702b7e445d7803767bc96809ac41b043288a18bc5831e12dd4f2b4cd7470e44490122859b3acf385bd38e7c6d3a4bf64946e82e472aa7c51d5f92708c5183f0db1996c1b2ec47a13cdfbc94e45e3b597ca8d3c702b6ac84ac6a2600633748698ba34fdacf4953ec20df93cb640f321c3edafbe736c30adef619bbb4708a997fc01d53cd6f014074b541b7406c3d777725f985c828a9fddbeec86494acd371b6ce8ad4f9cc3fe1995298c8e8a01705c0dd5c6c206433f326baf705adbb42b15e2f72fd085214a7d1cdfbf4926c66174215c8b463a89227086471b2298a8875f0c793cb222772134342d77d88f21a671ff29741cb876e166ce5378c955a23737a047c24143e18d979a1f8a221cf8353cb4fb101d378e333457e84f53979562cd904244d4d63f08a2035193d3c0482a88a34873dae04dd506161a401c05540143db2244e9eeea62802fd74cdd1552dcf3681f0a9dccad1e46c923235d379dbd0489051ad08864eb65d4f7b7a97e56c93bc27f5daba40c0985132ef3f82e66e72b5ecf0378d380fc5069b730387ed7a04132936cf9f56e0cd1b1730b119c3bf222cff3baae90f54557b29b021c0fa7f4e0919a7c5531d90a373734de9aebd0d5b7d0e5a19ee3a9289e12ad21d6b5c4b15c54b3aaa4d54c9ab21b907e122bea4e41c4a4893d99d56070c3aecc660dc4f4e0847a5d6db18de2a862b9d76cb4805849c512d4e56eb3bf3ed29b35b21f3efa26b53c08de5f228316310ece4a5036468b4815af0c77b555106e533e90a9e627b5972e634390bb973666deeb96a9b2c60d2e603f8ce71d6f0b899cc7d9a4b6c8cc3638503d982e02fd784f1d41341ab902126f416547b5919892415ef8941233f859e99d52b76b0267bd6d09927b0e4e762cbe57fe14bdd705abb7f5380352215b9cec5576c96f490151d3b16d26876521bb30f39b0b7f7093863550b209bbc64aa480b963d824d0c9583c4ef2568b64a6cfd080d91e73b8989053e6f5fa9c911c3dd0eaa3633f1e37580f7a245d1d2e8e3da0f6ac3e3526a24d9d4991cb4e3eeb84abf13449a743b0b6936813bea2e779ec5894b7302f5dd39221abfbfe1691386c177fb8bb31828641d2fa4e6ac29b30a9966dc8ad79599fcefb7d7f859bd04ba7cb3d2186918d9e88340fc860a80a19c730ab41db21b13d680155dc39ea74f861547a81584ac2833234b977f3b858bbebc691635001d7f623b3fccc4fdcb57db030af042afda29f259ff5f2bcefa321547edaa89a8ac005f6e4a65a013a57eae9c0526651d618e8d2e46e2755e0168808d3bc60fea7ae3245988d85280aa9423be31974605a40250ffe2aee4370675a93f06fcbf3df4553122700537e8dab51017af526b7fac23804a22c72d6c7c483c1ac3709d486b2be37b15f207fff3fba30928bcad98b38fb92c53a21a4d2fb5f6f86a5104f87c34f1b36d979786c36fd1f93bfa8b0363e3e5e218b6ec71a7a883a132bdb92d8c869285b0f1137143f05784b5cee00af28e9bb21d544dbc938b57cef7baef180bbb546d39c4497e702cf84362c88676eee7a04fcc7a363e32d8b11b014251fd9dffa8968cb5c043bfb435b0c30c8bd39aa9ba603ac449c6fafad442959ce0635d653314fc0a127b53feb93be812d343055c323c7affed2ebaed5e270e1840e148ed03bf00ce378a378ad6551900892d4e4447444794f8ef66c1e1e8c5b3e66f74637f24271b1f22b873c53d8b75e325df9ea52fa380a0ff0ace1fc095390138a92cc6bd8ec9841f64ba48801406414b4128d70a354c45a517d4ba0ff64f0f9245d97c68e980bab0032f5276418a29828c5f6c45195fb1dd4856fe956903dec108bbe96c583316d73c969fd1ef2f2c5d2b97b9539b353881b590a5bdea199a5a6584e4354f555958ad9fffba7dbb80b822edb63864bd76afa2e4e5a0ff444c387320e3ea5e1471391cc7ce48670948fce5a3a1ce1692e183c863df4912f5e5033e91df73f9b6ef7c4dc97b5cc56955dd9172ae8a27ff7d4a7965ad6c0ff009f7dd8166a3e7fbddf223d3a60fcfdc2331f14b0099cdc597f6f610a53d553a6c9850a88bdce825ca73294f181497d39c0ad7287785f43f06069bab2ed79bbcdf009bf8344efcfc0d1d3a91100180023aadad324c42613dfb5022cbbbeba696814c5f2b447af76141eb8bdb8050406bcf2053582d6f1278fc6cf54ca8fc4aac7cbf2d0883db16335a3af0a70dace95977d7eb154e6b0b96119ca356d17af2af540e7e71a3829dd1aa4ec79d4765a8c58b3004a3b2bfdc4debf0c316dbff4d9ac696508d546e801726b234a87c978b4cbf96d2f723e23c78bed29c34874522fecbc73eee16db539575d1aae0c26f32b7d34d909b996f59f1470e8e48faee3db3a2b9d941822901647a7a57c556c068cdf3d119cf0c5740d26bcd1e743a1f08e343eb5f56f0da653d4c381968f071b19a5a480c8a2d3c5de063516f21143fdb096feade45ab38489e20fd535931690de40686c13bd1495368774f2a2a1be39e436c2ffeb9a9f1c0a86865231629002d0c2d4ae86d5267d830971002680eed52ae3cf4da95dac5ff61c7cb572869c7d401cf1a87c85bb242e6b13dfe428eeda685f635c6fa90ab04abf0af2b66f2ffd44ddcfedc4a9940a3cfc16afecc0820182aff101fb95ee8db52e20d1ac656b82e1406f7e79634a4a1e06f6dad14aaf5ea2d831307c364595b432a1714b90657cd6fcca68e0e5ad7367391c09b81befeb4a14b03ffae9662a8dfdbb62399ccb1e7112d23690c03aa3b81487540603e40a7e3aaae72c12b3dadf2562ce3ef4799c2b01399029c9d744907fd92792ee488473913f8acc0cac68e769bbc878b1daaa6661bdf448ab6433132102928036aaf1158c6da7f07a6d6abdf8f7e32b785d2b361714007473b623c90c32f0a7513d6c6432fdf80a05a816b45fd28cbdda084c27db9ef857aa3f325a981da8e88faa6faa0e033ca2b3b5e88726b044347f55582a66c53e05afd60f1c524ff29038960bc518cb0748a9c76065faded163d4b230ded51510f5301e0351d0c42354874d6a4497426456982e10038b1ac6158f87306f4ec38cf5d75791819cb8ba7de0db4362125db7299d44bbc5381e35dc28217a341b71f7625a05d95e19c93a091f8355a8e372e0b13f7d4a6ae9d06e09b64e8f37fc56e0201d3806f7af9683b569c6b184274534b33991cf6dc94fa0f2e745e1932370ead7809b60f114299ccd65433a31f00d278ab1ad6045c73831cb5221d0c52619c32bd4e5a14311a459f6fbf6a1d00f4105417b11994e719ef8a92085ea6e898ee01b25a0dafa95f2dd11fd4bade31a5c15e9d09ee3c2d8486a1b16372dc7528d6470cd989126195ca5fbf03fb151bbc8476274e7f9f3b619358bc2da27502b1d09a4b1ff83b78e15aacfe764dd0fceaf007e121b16d8a05fa45c299177fbe8a584a1c978fcdc6ea215a2a17fd17554a57af6150907a283bc6ab093ab6cfa2c2cc535fd4def37ddae41a8a783fd05d4e283d08d28fe24f776f652015f33b9591f64af1b0d26a14515830d0e5c408ebe601ab4d5c3d596bcf821136e1deab7ecb01dacde638ee1791c239d87721e9cd152eef049755aa3aed9d0aed60a3c2bf3f0b3b6da5ba072e6c2482b83f8e1fe7cad23a8bfa24843cd1abb09525468ef90943b11af96a877d3631ba0bb84bd9319bcfe5e4da65b3a348ca4d374ca8d67bfadb649f675a639f7a06a6d1aab6562b9ab42ee0e7c1c86f295d286c719333e6e4b323ef33a0527b372335414297df4fbe3002284ab6b8a133bbadd0f14cf5b0401937dc39ee0537e032492653ff73943c4b7cdeb3292362362166dee6400bdf2d8ff310e91d792052d6e5f0f67e20ab3cf62bf0ffb1e20d796eb4d5c5ed0c8110d5bb8b7aa46f362a9978d91376e267dbf6952a289ad1f2807fa56cb42cf317fa986f08ebe0cc06195cbd7c9b5f155937c47452884d56056d0530786e8a7fcc9cc01baf701f06df5c7fd7c03a5fc0643818ff94149b4019136c53cd4b9d230398fe6dc3d6795725fbfb2ebc802e56d087d679e737dc4268ba6b8bab0450136db32735ed6b0d19e08a55674697d0ff91c1f647567657328e5f1ae1e6d1018549c013fab4803f0cc0c5414f9669b0f8d547e3881e8634d957db69e805b0a83d2013736d19d6d21a3037a5a203bb455618b3aac53f115e4ae64f585666fb44d952f6f65e97fb60e95a895233ebf21bd51a444cf9bfef8d15991d0bd8512dd1d0bcab1ee63df8c39267a87f30fcea2c9c551a995ea2a8c804ebd4d53c115328776af4f45b5c09e56c2bc597439103109f1e1c180aaa654dad01c3916a4980772757a3fdd5fcd76467f5f461406a627f2def9253eaf428057668eb80bb696f3e7ba3e2bce94d5017e989cb1cf63725047e31866f6e9c313ee32b787ff5421eb1cb849833afe1bf56e703b410dfc365bfd9fab2735e7a7e32efcaa82ffc0e44f95446ceb997e90df3fedc6f1bfb3043d05a41b97cc022c80738098ea597a36e981dbe9e7edbac37579422b8f48d6b1c32c8af93b49c32442d8057ae41aa81d38034dc892f36f7ce37a9d8f448c71f65c06e065d22663369cb3f120d3f8ee2f0e1bc6b00c4585637815aa666027e1d558f96c4d9b8b0ca652bba242049fab4794f56506c7f4d522a42b1284be2821da0f657edbb5d6ee437f4ffa4c64960e3a47c90779d60f397d72e2e766c52573d3de7b6d165205fb38d51ec7277d701beb3eb20614aa83828f6742c95c79be2f944704e391e5aa62e8d7a1b98078c1a71b43e6644a6e4df82ea243a92a60caae903e9eb77bb101f38cf2e71c8a3cc2f3da471e9ef89bc93a9eaa8b2b21e89a308023f77848b89d72e17d58ea90c9d72f9242a7ac5b2d04a385d35130a99d4cddd424407e27a15073e4d8106d9799b51bff8e6abe4b07549cd7a443dafc56fee4cda805b17a19d61c0e71762515890bf3f31b983094c7bb5c78f4976c9112c0d571f8b6fece0d4f5fd19adf15dca92c63e88dd4e64507cc82f700699f2d9defb4e1811bae6d5ed235a2c5962f7f8cff60fa35c14bb70dbd95916e6cf61d51b0271ec7de1f3c87b0835bf267432df82c587b9bab9a1d5707d2a2a465b01f09a11f100beda9eb58711ae27d96f362c94409795e0112029cc62d9d24fc7bddf381fd25b018fbc62f44672398d2333643ec6ad764754763ce0b7e081e5568e47e2016fd4664e050c4239d2ed9f5a6f69a2b5b44ee642c074a84c9525f12e150db3d78897c46f1ab14783290bc285ef0ed98e38e552aaffa01242eb2ea46c87b93637f0b5beb44b1874d7755ceb327c5c813b6363fc60628f518fb8deb90dc57b040711c18a8988829f917d9ae91f82ba543e9756c34b1ddfec7c1476269c5e1c36501d3f9b3700b6a16c5d0b32a38e82b730dfc8c9f94699cdb273702a45e1053aaa1f850a5c99c6825b3f576369baeb7e8f3902a017f8395dc441a3926eb86d1a576ca2fb58af21d7bcc8250d2bf1637b88228f7a0d6e1dc7e138d8473848310b048da5bfd7d36d91db35c32961e4725b3f7838c37151f512a4181611adcf5db34c29668e2c890f7c3126b6d76fd7cb567f9620909d0332bb957cd978b01043826a0a8fe81a1390aaf8795eccc5c100dcf1f1d12527a8288c0021a040350c484d591673e0a02b107fb0de1efc68773a21e27ef9302da3720d1749a90dacc54b29708a35b1ede6ab8f8d7ef4b0b24a89e1e33641cebef81af231f8833ae4ce8c6f19459ca8fb67bc0e59596f7d9b29f25aa95920c50f6cd16139b6035920cf334e3ece58f56f554faa582785b923773209aa9dd8cc557eb6721484e2e761be5f99f80b35465105532302b4f92e4c5af267951732671d844f5b75332c7b9194a8c8253580c11dff4e4268d58a84d992fcee2912508e0e6b1953bc2238649a8e797388382a53b2452ae5c17cdcf2cf705f488ab1eadda24e06f86a98cf923d35cfbd0b334a72acb8eef4b444bcee0c4385b507259b96cc687fa64217350643068abc6fd70ff45ba98d0379cf96cbe1823b1bb594817014f82054e5a5f5708641f17aa13f200d2e4119ed0b0296e1407c0ccc1a2685ba64c4e017dbb1bc4b404ead0d0183eaa9aed6c8d27ccfe2789805b7f0892fe6e547d8adf7474adff8aaaf4b448de1f0910acf085ab80707cf9150a7555d6329572d788acb29752a9e7d3967fd983fb09debf129c6c0f6900479c18a8a357a2f1d16b3e6988395fb6c4a69edf220af811d4129454dfd980631b268649b710e64a118ed9c79254c562905241519ae998d7a09737b6a6998740eb3ee88e05b055e3347fa07a13f0b2e87fd6e3654d16e3efdea4bf5adb964e5da9ceb862774f8d2c1d379451feed9bb38c0ed49f75ddd64e924c1e409c3cbb1175dd2320a9d6ee8077cfa85f58016a882a87b34f36225a7caa76608480da5c6ae3d84a9a6c778cb02196f096ec5d51044c5f17f268172c2f3f9efe7cefa636ca24bf84be9b3e4fcc37a3ae627de0741952d7100b45ff13ef3f9f173ec5135ccd86b62fe15d238df3a42beb005efcbe472b2e4c65273b8ae8804717bfee59996e99869cd8b96838e3ec66b090e7233cfcc1397c7c7d1e0e7d4e97d4794324b96f210268c21bf3a1d32cbc329c8b70f6a91f87128d543d1e1e4efa81cc92468ea3401d75d98b05fc5cad3865304b7148e8724f7a72adff49493109bbff09fdd2c363a299c4476502666c76849ebd91915b53b466e523e057ee8d368dbfa08acf2d90265583e62d24e17340e4146efc0d8f6de4e393741c765dadd57b32f760bb438a10b6b48f1f747231c2d8dfa1dd95d304a8598de47201ff42d2e09edcd7f4298675a4258bd8cde475fd8f980d3d8e2e4d90d1ff40a83193b756e8e88530244b19399092afcc33ce1dc872af0acc53c5a18967fefb6121bfa4feb706770ab4b35abb76406e92c156ce53f5ae6bea6d47a59bd498b5418a37612f85942946cfd4a67aa1ae515dbf6700c542e98261c1a73d8e6d21d9105c63c12132cb44448d064b7b232fa2f6f5fde1f567082111984b1d3852808d557ee1c8399a1eb1a91816b383fc520450d27479418d8f000256960472ae3dfd36f6ea0246fad94a5e6f0adff7f2138ae2083d26aee913c651afda446be0ebe28f1a16503729294b736ce055e34b0a2c222d9b53c3ac0ad4e005f9099600678ab55f016015b4ec64a9b57331e14b2e69ca48658e588cb55d5bb4862d86d7aa84f3344b93ffd82b31662d57e754c871f4fd1fb84f5c4ee47d98af611665fdb01f81708815e0ded1895a1d37af09c4ba2881fba44848f9d66f247b06d2a58fa6f2cf9293a21f1273c4ecf10ac1e2cb5f24256977d874b2811d85a0e9ecf42d9b6b6ef066329e68dffce6d1ccd056528d34a24e97da10dc4362fc0c64dd693e2e40418b888f9e1ea7857df867717682fbbf750f9ec5b5562e034a3f53ba82c3a944d3359b64671f980ef46820541a971f37d59878171c97160a6cab7ed674660914c1a535972e1136eeb2eb1098d9bc7a71814befefd8e704a268776898e87b5432de23d561865ae0fbeb005b9184f52f3afa4c657d4fa54576b24e1bb7def00001e27f3fc5a570cefbb2a4fc8342347cbeaf55fe886895c90204658a7ae1b168fa450117e63476ff41cae28daa71b5dc75e724277c4f820c199644fc560d2a07634ee0674224b2b85a95b44b0e217d9fa7887ec292ca9837be639fbe948951d39c18e4ebfc0d3354ab35b4082b4b3fe83a1fb55183005885e4aaa7680760057de01c890bd86cb0341e02f5219074307c49475f833d2503dce2ce1735e7470bee1bfa4e59a92d514cd4a2a583bdb77a43d8f5944f40a4b817d9625123d87a81fdc7da1bc0bf774c46e05e26b67685a8282d6bf6c642d7958015dfba506d1a8eac5202790162b37a89020320682037b3f21103181ed47bebdbaa1d14a6aa8368d855d8b8c107d97c735bf72866df364ac25c5607a053e9e77c983abd94d4230eb2aff1055d82eb2fc0c50f66afad293d107daacb7aaa63ba15a1aea0aa3eaea3c01fdc6ae2dddae78ffaa9973ff17e4369c016e48ca97ff0a8643f34f3d99796ea360dfcb7827195d9586723dbb2d31191d364da53f7df31806176aa20e582babbc9c88e62e0e5a18b29c9e87079bd01c46dd440c98dd3638f5a00d1cc2a418f3637b92af6a4ef72f7d683c2a841a8a7cdb6587192eacee8b73f5347cb924f968e3e126b4ecb61f5e7d3234a872ed2e03be5e29ae50d80b73f17baadf7171371a68f54564af78256d5765b4af33e0bb3c4415ef047fc492c2bae6067194d24755b80530a14cc31136cc56f3da56a54cceee51256f57623968f4ae7368417ca7fbff6eb769280c0135aabc071548ba3d903647daa271947dafa1fbf0d47c6d361af9759715ec2a2dd909f0f6a4c3895e7c0a88b9416f9613f9cbb4ca9b18cbb0f1f20784b062f4c8f20a4af7751a4672cca5dd4c1807024d1dde8cf853efad1122548768f4e1381695cd30874c666b14d06db237a55ad7a8bd18b21e2d376ee24fba9ef6c73adef4e0aeb60239664010429c17bfb4c11fcb373efaf0e110bb52a8591fbf3e96aaa06811a230c1a67ec9e9629b96f83ee871fddf8bcf7cdcd57006929fb06b6c2e66b1b677be5ae4f3cc6362255668b9d33894590264c461e6e52beb23ebc67a915e6ea4012d1e1c0cc66d9f26e4a3e1412ae62c4a573072edddca49e6d81692c482dff34e88bf092e827abc04869ce39bd1e87b9516b79c071aa4499057a6c6b3530f3a61c490ae6d6b7bc24acd1bf7d037936bdf2da4fee0bc4d31c463778d93117a8738beae10dfef38c574146518c7edaab05829980646d0d5775ee70258678f18700ea9f1688871e17ff6087e5e96cbe1f90ff06cfc917d2d0734eb2e93a973af031ec71db5f737f34f0b1e9f15a0b76a29616a7a4e1d16c4eee8fb4a6eacea0ff0cb965bd394d468f91776f4bea3814fe5a375648649fadbb9b286ad4da288ea469b126106ba07ff57303db538d8d685112dc23b367b2fbafaf06798cf1324dee4cef1f1b58492a1bbd61ccecaef228031421003297edff3f14fd3db4ef97346c133a2c3fce1b3456a03dfcd7a8275891e87773c74abfaf8a153fce110e89faac773ac98ecb0f1fec60f86e5e637b03fed060b84df74b735321e5cde320af1390607ac5fdc7737749b5f6f4c318ebb27a7f7e2e141a4e3ea6daff317d82c6155c3a09eac49546684ed91267b34fd6711d228ea35b007672de227e3b83ada015053a73bc9660db1cf0e22049e953a61315898670d0238c325780fa68ef003577d5c2c976420769ecc3e9f071233ce8d1d6f9eef7cf6b67af25cfe4379f30ccc0c79479b3d1ebbebf2b8afb16fcb21b3149845e0f90b8f9131c72bdc53942b6633400a28dc5b723bc48562dc0b2448b383664243f8f6b202b1f783dc9c2d6991adbb3617fa59f0c7780e521522872ab0d4d559bfe527b86940a669360ec4914f4649b715d521ee0ec42132fcc0f91a59f1638134fa5415b0913c3ec5d1a676a7ae899e51416cee105d5ef22668fed1c5a7f4e0073f730e656f4703338bd01b51956a1c2f26f16b6c8730d67cb0d1d72ba1be809b60998796b1bdf97dc19b88a21bb09d6f3f2e42aff8c82635062db06363e64e52e43b80558e78cb671fcee712a4d68ff89214c0e83c2ed554fe0030f6c581ab2aa901501edf925c7689eef65f92e64eeb88927012ccedcd1e2471c7e1eee6c8c5d0402992f23d52adc0d795ee20d5a97c1588","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
