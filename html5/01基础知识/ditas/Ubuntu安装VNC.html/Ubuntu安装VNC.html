<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"518535f36e4d8d9e0ea8c6aabce702075d77ddbe725f40fd31adf32c374747ef9a8bc730282df250cf3f819b11d9289c977d9f1d4aee2f6e6ab8db276527a758da0684b2049adc1cb6376614595b2d21627d0906d6d6760e782215764c8cd79a994a2403d71e315ba1abdc06652605e5771380861a08e0ac95862e51653e4122d8e33fb9ab77139559d7e06ab004d9edf09725c815f2f6bdfe6db73d3aefcaecfd0d1682045d26e1b57f16dda195ac851940e1fb7981a7ef85ed8fe1534f2fb92f93c1eb27559e9e251f0fd14478fee69516485d7b2316c1861d234b4ea2450e647bfd3c46831408df8d5f1296410a2fff8e090ee338653e4ea18f0a6b344c8bc0bf8f9b4688f3d18e70e6dd59ca3a77314ca9b403c0143c1191efa8b325be8d6d3c9eaa15fc2b47b0026ef14f59abc7a29bcb807867f1eb54b94f52c53f305fecdaa52cedae282720bdae22e00ddb69052e6c0630fe104150086c7e06a327113fe6bde2d75ce68d8db8d4b2534d0071c05dca4c0d28d915955c7f085ba0ccf10ebdf3d0ae36db125cc53102dcc6f1fc902da6899feb0f03f9d95dc5efa8afc376deddd0ba36228a24b947782c21f1f3769b7f0efde15404c03251a38ea4f05ee3669f69804ac15fe8ee5bb59417d8904b89e5dbf5fee304798793a537de33e774e8a5df64ce12b4ee2b60debdc57a87d943b841262daae60f9092d1e4e33e308d3af83eeea5f6519847d6a1524ee5f3fe30333333193271968da47903a8cbeafde47b0bf460ab203ec63ea87ebdf81fee27dbac3e60bb6c86185d5957653df7b3bbb2d1a6bd52b47a6ba3bf85916871f35a81ac6239d7a247e6f9c8ac3926193cfcde0ba9748b5b2190bddc74af2df9c7c6ac427138ec968ac49ca0e98b700d892e3d9b888f8c7b76dae5e5c0179827ba6d19d2ce8d433824372e54bc5a7465fadf83bb77be4c441e4987482f979aafd1cf0507f267ec6ca9eefdbd6753f1a04d73683cf716850e3e474d6d9e937dabd2140c3ec311df125b4a485b48df6ff3402f498681f0b603d8d078caff49647472cf2169376bbe2d0218124a03c4dc9dbfa7005b473a746442dc27c9149264e14157e60f2b01c29949cedab219ab681ecc52d6dd76917dfb3e7f039e70cf8168d66d18708b00489b95604018bd5ced8fe45041a029fb4d66b6fe5c3d707fa853c9a51607a817be86852e8ecbb61da9ac010654b92114187bed574a958da94713be5464411aee0f1200d22001ad6be2a81a2cf5d5fd5202b9c1d0b52afaee93ebde4481a450f2a19adf812d0b85e867c5eb3f6307027db591fc3026ca153fa7c2f5d25b03c6a7d72746559a4215926bb40ddb8df05b5b8a10f35f43c5575d3252ceecc5f63370a13c5ee16118f80ee20a506a6ad6a530fa62934dcedd84064a303eff39b7983a0674743aabedbec79813dbfa23fa150808b2dc86603a9a9f0d8a969bd156c1e2debd1324f8786a98408f5592bee563db7142b31033f853d80a4204b6b6b5f3cdadd9858becd55f1dbef6ff3a59ef8b0d04a470b6c30a2189e1a37ee2242a17a704721d0feaa3ccb239eb12f86a166cb220f9da56cb7b1c5878679d589843812c18aa545d6ff0ba32804b519aed488779cd6f9f7d4f0eaabe8526312c51752c3b9f40bb62ad91b2021ca57514359c2d3d59eb432dfc3b3644f83db3501d5e80d7876369a282e9140d2517adb7eac23bf46a16420a994ee05ad7405d38f49d04cc46ba042ff391afa34c1764701d44c09f13515c40a21144452f0da421d02a9f72a1a9cc302e77276bf9268d3ee772a0d75a36fd6ad1be6d0a97795bba114b9cc6b6ab594d6037e298716b5ef1e9c5cdb27109079c72e63661a6057e76b4f7c7b776ca9a640fbc275f107a240329cb06f9d542bf73e48b0b40c25043f9e84cf302a34df631e30faa260dc008c41e9927950352ba01454d0e9e3509edaa596c21c1ee25adbcdabc682c8939a68449d397f22ab2c2172792afb22e86fb5380e237ab2899643cfec6bc4a6a5f905f1fcfc6e85a8bc8fce07ef9c6e86edf26348c2b5be1e292750e094927c98ab3680ed58dabfa439e7bd47e6ce1bf1079f3025a368e795763b7e87bd08bf319d10350ee95e27d5b09f0748e3f12cfaa0af08e7dc8f2528d0dd4945557ec17d58cee2ea4fb399bcfb98dd8c282006e376a08f50520b95674a942a981fae2b2b1b2f8ef3485c9c4c6c3c05694d268d8ddf1d1cc456b3e3c86c04888f6f2006d0a5ba0ac1e088e6e1f4dca018d351c5ce3d6d37a5a2e5ffeccda088a06335dad137dbcc7cc5a57bff713ce77a8bc8a2c882ec76314fc6e06f664e8e7c5a322083a9f58beb631c8f0e52e06f673ef34f54e900be7ff73ecc64d3fdec62a5c2f6463be4707c01043cc1c7242d115f900782d8ad5d136cacf641e6427687d104a1a9887eed90e0bd4171b802ae7f8bbc25b12651975da3dbb847f53567f6a691b55f684ea2c0c61146dec8ae0e561012255ac911f28781bffc04280c342af4c7f7bece759b8559c0f97ec82da1c1f9a7626c34ddd34497a7055ca834c968b65c3b5091e0c6ef205ce541d262d86975fe4a2234a9de84a990e4d77d25978e518b0d8366d19750179c2cb8d0816ac18fef0810356b8ee09da4dd032418da45c839062aba62e8d220205f9b0ee1047943ec2dbbdb5d29d790fc0ace69b8b6a7205eea2e111f7c17942ed7b0c5a0c31481785fcf279beb7bca0a56cd664315579f2f7f5b6b4122b603324483af912034acd22f058cd617ff202285c5ba4d49871820103e7b9f2dcdc85e4b8fac14f691c18af9434da43124a99c1031fa6bd84708c57e273827e579cee031c9c73555b81e030275341ed9ae11f25c71fd1241d479fd75dbb9f03c32cfc71059b190744c25c8ae72956eb31575db0b50c2c40c710aeed442eea37ad4534ef976bb5b81f3b768b5e9878fa1b64e45a1425640ae766bf36899f409cb1147cfcd3e5a65ce3aa92df20bf730efe4ca28c2ecd8baf3f5996cd460749bec27138152e96132de744e37dbf18813fa59b7488cdae5783ba5d895fc4c2377c78569dc22b629c46c8341d8781d2931bdfcd6477f227f0bc007757339f9fb3e844740707245d5041403ea87b130cf1049f99ae4f144ef786a1b5ceb26de17f4fe7b3953dca13b48e054ad5f74f5a39ac7e1c6663067c0f7fabe1d2f852382e91b4f0880026629a579e230ca6033044a0e3da0556108a04371d5aed498072c2924880f9aef8b66e97916635677eef1fb33c15527f1c36f6bc4bdef1b0cfb6066e21baccb2a9e1080e2f099a9f5f0287519e5f56490ef83b274c2d0b8c4173bac96549270fd9668edbd87f3916de537343f7e5cdcbe4a9178169f79ef20c45133626646edfd674372a581545d62ba59621b277b871f29175f175d86c2cfa632be9127eb5b1391b56c50ad697c574a298cc149aa87169dce8e6dde8590246b0791936af7c104c07dcac0315feaad3f6638f8db971248c7255ad1bf6db704f67655172272038bc50c195eb51ffdb0d652099a695c1cab6d863b0dd306ab9a34222af2b90f2e45c94c83690f1d5118969c8d8720ae1979bad5c1214cb1a218dacf6b5721510bfb725d200455d4eda6b8439a42cc43fe2add27ff1a79554ce5cdd5b5f320840deed68e36c05780defaf306abcd3644214e133aff44c2b7aa26734f7c5a77b7059c0be52b9997e58c2c61f70a4183884364dc0b639fa5894406c3f7a6dd0dc641841f6e2a04441cea91becfb388e64cec4a0bd9f5f648b45985f98ede3b9c80a993adf71967c24f17bc6096fba015da4118e0f2295f7a444e6e84b8e5a8a5202e47a798f9b077e1ce513d5e4aed04340b0f21a1b4f3a1172206e056de7685d919053472ca5f92c4e81e98c7d39762f10c35738579aa5f9d6769c7bef7650e465fe2fa8616f24492fd43e85fd145c6311faade9d06863de998e15e2396d02aaeb7f50b80d50cd62a0bb9e18c5690bd968fc5c51375579dce52446b8c37b8ba0cd8fc0fdcd5878ef717c2d4245a5ded25ef48a3a7c46b693f019d29cd8e59ac9f699d5a8c56bf6db8718c09265c3a8cdeaaa0ad06f8fa151e985ec3621330dd8df4ef7f8e44609dcf592534e27b1bb8fdeb15868b436f16cef849420f0df5608d1746adc1c53ee44c999b9e20c69200b1ab14de3adb96af7fba70d565aa6cff11e3640273670792764bebd708a59190bd79c6433bb89e11f081b2a833a9590169141cf099356e8527d22af41f1646b65c20fa4440e9d86cb724d4192be649567e3598e244549cc8f05e2346a881d3e7c34e3ad9b0db00b9918a0918816d38a20f5b0e9617557501a5313a5688035eee12979ea25a44efbca2a40bd03204b2de69a6730697e1411bee271b22c601793356adfa1bd875e4cda35d0b18452b400f4d8128de55fa4e99223a51083203a01d3f1ebe95de8e8c55c058d24b573660e110f99e4fbc9b64678b09d742721bc07ee760bb45d74a5b9327f38145eab5cf68bf6c40df759230e8b10896a1bf3b1d0f747d95cce49370677445cf18b7b67ad02c62ad5b991b01a7b06de48d94346058933122357ba4c022ce4c49335cf594dce649e552ffa349e32d9eb68a7331670ca96dada3dfefedb8c737cc0208fa4bc8b122a8d545ed9b1f809a2dee5aa4710d4a2fdaf3bba738aaa18f5538befb877cd1076094254f528c405cc99436385bbb506f54001fc22b4254e4df404010f03a705e5a715409d666b7254a33a62e1ccdbe28152dadc537672f871c06053a3081d78dff7b6a2e3199668980c5d83786f3bc67115271a2b65088216c217b88763b1cd106c22f99807f83bacdd62f1ce0581dd2784c56ed121d03eea018708f85b004adc94befa3eb581a164f696eeb9bd6c6ed991f7e9a696794b508b0f81a23ad736794acbf9a1d8aae2253f82097c72b3b3d0a051f2dbf9db49a4a5cf4b47de691622cfcc8980348c50f6af13cf57c553f4d685c8c709841fccbe75a150dc41279923d75ddbea86ebfae30f98e679c5c7c22fd1730ee83be261bb244a9128720cc1905bdad2267b649cf89faa86c179b1867c3e85e3679d22e994354786e9c6374ab3405fcf5069b6dd04722abf2576fe42e4df5e4df73e27a699617719f7218919fcdd875fc6352e1799fbaf02e2fbabf83bce043ab102add77c090a937d2f8b46408c0531615d1ca5c80fd88738604c9a0bedcc1b24b1f5ffbcf8cc0c8fa7b158acb33ab1a753fac1d6d1d6ab77cdc21589fbff47905c80b6c0862c6123d10426ef2493abe263dc86e14d8f1fa27340da91260610a2e9b176ec25342a56d20bae8f7e13fdc92b8067d42268f6c2ffc50c80423d918de6b62fca32ed7a7dd13dd4c76f67a0c6c118e24acd7b84ba823551594a98b01eeaf77aade4b14f70509dc91ec4bcec1a837cb3bd8d8e5a8243c0941061a8ceb8a2521a5e0bc26cd3414fd6f6ad5e3795ed4c8d732c8cddc4f2b4b681d7ae9c39235b3ed578fe3839f9fa55218af73fdec68a5364793a49b65366c61e9ba41ff1efe30423076b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
