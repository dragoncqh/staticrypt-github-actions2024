<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bd7219d283eb31427607efa80726f14d044505df9690671d28bc7ee0e7baa15ef1792cea0fbbdc79c7b8f95d7b724369b0bad3256bfb8a6873fcf08c776f86d8383c924fcb132b0cd2c2c6a2e8e0bbfa8a05342df0441a85cda2fe18b7ce12d441e7497d208fd41092634004d3932a2450cb664a8517e1ae601d2725b00f58de6a28873e80772af2a28334af5d7ac43a626666fa8929c557057b79066aa23f8d7874b4c89f55a5e87046bbaf46ccf1dc59848cd3f2788e317fd243f3e57322b27ceed3294ddb0ab38ede3841207c37b97a890317a66aeef19637e563e358d1ce13594d803d3a9b4b463c0cd5919c8a7ef1b2bdcf0eabf950c856c92d3bcc801f20357d1379c6aaed3f73a93bb6321b7385765f7d79a4ec7e43c2cd6238dd5109ba309854760c143da5c86322dc2ebfa5405632451982304ff0461cea157e7baaddbf44f3a885466b65c7f1854b5a2165797692ee1c55f1ef2a52c3c932ae731931579b022d31fba4186831eb286e5afae06dafc0efbc2fbae51e6fcd7f2015dbcca0000881f59e32b71d0e9733d4fc3cd93855dfe8b715d34782d54bb6515976fb7642d417e899e35d6e25c8ac97d6cebb20550119a4ce82b1797a92b098587eac84b00a4414d5ed67c4568b1821aa023f6fb96da10ae47d3de4283629ede4243c0823431e5924130eaff75415a04b15f825df253f15f3828a58a8b80e22f320aa5eb6b66dfeeddefdb103b4420c1a1d541f19a49fc5135034e779eec9d56293abb33c0365d60869fc9e70d75dcfd00d7a10d6ad69dafd173f773da5137960ee364558698ae32f4a49cd4b02e932d0dec2f1ac11ca588731d38600add1f46ec303021061e380d0e70f717c21d96bd76d4b223e5adf76f1673ee1f0208674dbcb5701c4d4a935f8fed698eae401dd3c744ca8347c1acaf36160076d3eb9841f6b68a12ba69e59fb01819d5b17afe93ce122c06ad8cef51352bc1270eedb3588694a1ae13c184c3789d69b2b8b7a5404e783f7af6572fe2c5daccbb6caae4a5cf0df428cf4aa7fc6077438976c38d96778f3e396ced548a1a110156b01c1ee88e18c3461bc274493adf5721c5ecc0a41444545fb7b0cd57d6aa9bf0fbc312134da906151da626190145a2ed4560b058b69e5a938df83b0087b5c5986d51a54652b2bd234caf877f752a494bde866e0e4ad85df3c6a33a9a14b7c981cc0f9849ae6623411fc96d9f3337516a2b0de1aba24c3bb5579521c750acb662d70275d8d9259fa783f44e392fd612ab2c0f4242c08c47974f14f3b4447374b663cd8bbea3d2d28b3911484bf2f3981818d39681c706d3a68fb416977c520e1a3d2b5a3b78e5d5893cc1229b88144f8317396a3c1006e63a562f3db63f803bc9ef0da6226238cd3a5e9d666154e073b98a896d431cc64e603164a270d370578cd80b72422d41b9b979d4206a501a54b1117aeb7095cf9571f4ce6a6ade855ada9dd3762a6bec5e5930002b0713548abe5e2dd4868689cb99cbc79b9a5463fdb4d0a67976b722b9924df3b4e527c7248452f9dd1b5b6f070451127a86942b6fcbcc5063ce28def1a26cd8c1da6d399a8269c7a74dd11de16218d7e978e3d094c6033b4bdd8aba9221d59ad1ddc9682418f41fb197e4b30cdccd35da497dfc3be3fd1ebb2927ebbffe9cb6b1c34133a35a025cbdebab64bea6f5af824924cf4ca2f6e35b24dc5b9f27fb0701551770cbb6e50a70a094d0f7732bea4f27ecd26a429519b53fc878d6e015c6db8f535741ccc237da841b71e86944d57d297dfb4dcb543fcd4dee2e59b91cfe318e088a5cad995b851ee136a52fe9029163d1e55a10fc3a901fad28f77cbb90e26402032a4feb3d457853c9ed91e42085c915316c4cd3223d7cbb7f02b4393f1b977c8b243616051f2d48212fada9a04fb34a6e990361970c954242deb02d9c62a9a6bc931353b7b2aef498d1f0ee4bad19c0e3f821f1db1fb54f0edb30089bbbfeafd508152a46fd5354029ea86287c83245b2afe436b9e77c4e12de768a22bb376be8b2122f3460392837eb63053c3be5a4508f9bec043db75c1f1d84e5bbc5380c76c0b595bcf6825b16014d2304e539324018e5e5f65a0a469f119fa099c92eeb93f20d9a71480b9ba35e19474c991864eb867d1f8dae67b57d8c3508c01a951fdaceeef1db9210a6601b51cd5950c5fb46b76cd87d9c07c308c787873d2c7732b92146aa0aff5c5fb5e0c3015ba304007e85d34b9a5698f3148bf385499ab79deb164064c567b2eff58709020b544329de99bc9a368180540e346f788c855832a3836542c9dd8122984f64bc312800c63d8af8f758d7209496d7b3d49d733a32675fc80cabf289811df2856ec86b602487035c2188e3b48a948a0fec448cabb5bbec992fd98ffb225d05c4a79ef2f7a24a3638f2e19e089381bcbdf8af9037bd2aa6161e075824db55d81c4a59f905f5433ec84b2ff19f7a0f070f0207a2abeb20c931b3afe39570df8a975c35965820326b51927c568d03d95e637f075d415498c1668f543a25a7166538ec47dc9b2557644c51459a440533e22330aeef3fc4ca20252034b34b69126d75ec1601d0b86bafd80a68d6709f6220c99b3f1f13632df6fc97c53364433c9068f7dab427fadcbb9406fb1c69a5bb6c54f2ae770074f5ca6c2b8796a179972bb43c1cccd126d1c8473d8ed0970f309af7fcffa60ed0c5bf666afe8ce464d3e47f325a16fff37085b80f51392319d8510304e10bf46a45fcece6ac91178ccfb71b6172a1f20781be8b51478b4195d81b884b49818c6beff2fda95d36602221650fa571f3986e8fa410243daf1281aff429e00e82dc72436b15dc26b7a25640235834ce981231ded1e6244fd36f1f8fa291c7331ae5511e687ee259c89ef80537ef1fffbef95c4eff5f4c7abeeb1b9e0469b5dc9c5f13cda619a1bf86db0e00f7392300e072053a5df3ae0d7372475c1d8cdbbb6c3b4322c6b92a6fc855b65c7097045080225a4be1c7c692358b746b0bc72db44445d2d2bb4de64587da2cbc75dc4754f959a6fd9356859064c9950e6a67a9957b01bc5948206374cc4308c348074614b487b4245bfc424e1245be30edace74acc8c405d0def356b5ad88420c7ceb16c46910b558e90337ae3f5e0ba3d8a30c9d855ad99cb2f0d9af07c3a268c1ffd9b9d2a8b8327a2dab72ad397bb761d25a8e08ba113f0c4364f7baebed9bc2ef561c2f35900e377c7e8402593bf164e3d6ca397d51f30d9bd5bdf9967188d937d8212a8cf73c69c9449d960106b5829fef800b1f7f8004526e3e542ff862ffeb514cc2326e2ba4e92eecfcb81569cfe3eea3e3b0ecc40a9a7b69475c04be5378d089ae0ce4c4e545a3cd513a93f0794ea636a5cdf4ce0503d0a7c17bdf90e8e1f8156412a2dc88a7d24a83e7d1cf7c25bfb3c8981d91da51d670b2ccd7d289c2c86fda814f0bfbc48a73c62be836662730341c6b01b16e141976d4fa4b326cb0db631e6a2ff60c00a186c2704a73980bda884f418d0e8ec92ee33da7aeb6bfb3a0e7b03281e81e024d41a45bd05c15b06060426c75eca46bddeac29d82640ec7eee767fcbcf5f66b5fce2c5a8aad915b1819267d8aa28222b142725ce3a26544d3890e9eea71f352806db02ab39431db1e2bcbb0cda7555905b5d13ce3cce528e8dc9ddf1670e7cae1e0c56acc1c3a9e26d4f432de022fab89a79875c90ff926a6439979c270d501326d80dd71b443eaad5d238d113f76f2a694e8973d3590cddb3401c4ca7b13e80b0a30b5fec7e1df84fef726b085c080198bc6c02f01b16227da2ec7328fc545aa4cdd53b37df356929d78e58213653b386529086535d5089f686addfa59c2794e9b46542c8ec2a634ef062d2db3a124b3f942b5e200d2df168202590a1ed8e04c81284f232cebab08cab06eefde6bfa95f62282c916ef4bec8c3c5c045da907f4880ffbdbc5caa3a906c92da40aced1db068f2e54eaa199bb2c7054f23d9a4f77bd1b09ff955a6a4653ae9685b7f89d229395db538e7fc6318b63e8e5b0cc0f7bd74790ad5e85d396079ac2f68b50016ac376a7c17649bbb36f15cc5e6e4854e91eb400dddb9ff0f2adf5b9fa24e50b8e33e6a29a2d4adb75402c3a4d4bef0b1e4d0db234cebc1872f856f09c417f066e8ea0b9304972107831004caf0e0439fd12fe793b03128a44f8b1baf44473ed486bbbd14300f228b4221a948614966550dc654f0c30807da4547219034f3a860465484177c24613b58438fbb856c020d91a24daa09e6117ebc74eb714f405b1d0ad20b4f350f8895cd10d44245c8a6a3564e53a4339ab321e6d1adc5c7a55f53d72615acf73b1b364087f5d1790f930cba3dc2b569fcfad8de5d79f0ce4809e7b106431faa9957719321cc1dcddfc112c5118f72bc7c217947cddadab20a7a320517bb04ba9ccc60d5be07336e72a4dc7b8bdb2e6a14f7ccc2b80556781f9d262811c1353f5baa1c118c77677187cef4f1fc47fd4836d709f90ec124bf06a4325cdc42649a48d6663819368f9e30e36b08b91431c76ed95164c5a3cb6df4efecc1eaf7f835762383a0a557525973cc0ccd525ffd2a9674d199c2aa44a71d139dce847f90d552fed5c59dab95a357907aed43b82996d9829569f9ffa29a60612d12cf1fa4702efc5f143c5655fc8c0cf882139e405794ac67ab60c58cc3e5edfdf1c3d6a143c3fcf9297bd904818e5b3ad4467581849681c326097fa4359499c2f9f019675ba02398ddf46e6b46ed03faece82da388e65423abc3b0bf25cc240ae68190ffaf045a17c3fe8ffdabc094d1b43a0a878a1d7164a3cbe8ac14d104645467a8b6097c0bc788ce667e052f730b294e2480cb5cb2acd7aaff0df6f7a34801e5ee5e2cdcde9ac84706f509cbc217f394b076786b7b3c5a38e7f42ba1d48f60986708add9db00d5c8d23de350f1d2c59f4bce5b8498ddbc1e957826613133676112a9d7bb146aeda8f52b42e133e2203685f240663c50f08088b6086ffe2e714b095be7ee898a3bc38fe270da90088b8dfcd2824f32243f068d25fc40783958dcaae3b7fc8545495fe7de4bccce21d99f4b45ccbad79ba987672225d0b71cd9fc189daf5dba54116e80bc1bcf589f535621fa8925e4afb0d21d405843c71bab923c004b786b7a40cb7ff1d2819ffbd261d190e707c6aefb2defa2ea54fd7c7dbf0b1e060bc5ecfdbf845f1bb8ae025304fc926ff444fff00c677e4a12674f98825c624ba63a69aaab85c813400814f899522e00689e5804f6225fac545f19cd428977eb51fbdede0aa9e33a2e589e52bfcd0fdbd690f99481c470b832dd0d61011d6eea564b51a643b1d1d341ccb940c4dfad2b0ecb79b9694e9942562b936718b471277552c8dcddefa95a64cafeb6ddb5ebf887b1991d8227c3072ef6c250f62e5c2a0ec41108b0a6147fb03d6d41f6be5e1f2341728146d989fb83ebcb84b9f5682890a123d898b03fcb001df04477e38f4f8e133b8ef48c91b233167b3d55a07ef6bdf5a5199ea65bc8cda79f596109117d9678f18431a244f06cae01608cfc3bbfab97ab2bcc5d253ba89215a0068ad22eb328eb9c50023e76d1a053f078019e5d3b2fc21677e2a38dfc13004bcb19a9ce9a47505253137592010b84fb2d735eff0b066de5a237d6980654318771732c9578f1cad0efb2c9efce5a37985ed73e168311ba15e313c26bcd7700343d0cf8d5d10138489c2466667516e701b15bd1bb1d3e6c740c2dcbd51e5cbd3af064895ffcafbfee6e86896e7cd1b021ebd4ab4e255078b1915d3af61941c422a1b84ffcf32d6fb207177bab5efbaec17198cde77c91f1249be544401fd5a159e8117813e5f2795cdb7eff6e438b54302881c8987ba96af4e22d21d5128885babf5757c071c302adfe8ded9e01797bfeb722888838e370eb84408dfea867531a8fab852e2dc23a79e1e464dfb33338732ec159bcbe9eb8a830ca8cf109d294549f00d519dcf9510730f3003cbff2689a9036a148d84c4ca6f5435c1da703bfac163b874d4524047e8ad956cf06d41788328cbf483bd779ad1b654008622b40b8f060174c327686f15deee8db4175f0ac77768f075a04d5a4f13335e785440a564026d8121818fcd2a1805ae4d57669c1b0d1c44f36243042d0ff26c8a270e87d0cdaa7dba770b69f25015fdad196bbf432bff5dfa500bf8855b6843900a208f0933017737b2e8bf0d6ae8c286db786790f401d93628044d6a348b2e829e914aa5b73398c362d250bd183978fe03373b82533778cb45d9b35deb7554db95e246bd4f01b9c230467e68d356c3692acf2eba91d8908486203e6c99ce6173a7edb129751c85008b6fad8cd3295772be681a876431b8ac30d97aba76632743908dffd32b53248021ad42d55f520b60ff13846b65d260aaee114b3bd6659718a0c64b6d5b7fdb31fa8f9ea531ca266ca0c32794b6cde92ed6a4474ab5718c7e03061bc798f54a704c290898c8225aab6cde67dd9ad9d38ac6ed62ce5b4bc6f44c3361080bbc6d4dacb69f9f470ff56b323a76079694fcbb888e45d9cb53092a847c0baa6fffa9ea1a0e7a22f083d9577964d310b5cc69cdabb9d07291a7f2ce67a5472ed53b5e2a94cd9fdf352586aa702fce33dcb2db815ed1fe5ee68764997c1e42c88b05875ae8ba6f231a1adc9810e8a4af34df09a6d1347c25c7f07e3fabfc6df976b1f8fc6eec659c92c735dcca79e018c3ee6dab461ff4df971edac11e7f134307ae442110928ce92388930d1fd9a19416aaa92d6405cc05b5598e16d95455c19529dc4ac55bd03dd524567f02f8df1b904e8e752b31e21086fefb294cc28150712635fffec508e2557059c6363aef2b2b6c66e2d06c5c8c0b3eb0d8a349841f3ea2fad58589dcb677a2aeec7fced9971786eb7e8e8232a28d1dd03c19ca7275f7af0634f3ebf443c05cdf42e2aed46e276bb4ca105a1a4f7098112153a3dac0619931a0c258db4661bf7df446bf83a81ab7e96622e954af71df684a3118417128082b76f8101ac096b73e9c859310dd870cdbe08746fdca9f2c1343c40be4807916f44be8429ffc73ea260598c76ea80d7109c1c446e5cb73399c37d0577a363cdb5ab82996b153c9af41e6fbb520562412b393dc25513779c2f97bb0d0d21a0cde44ce9f5e76b26a9f3994e06fef11a9b2f873d2b4ea0f8dc8f161e66cdf8688e4df4265590798ad7c189351f531b48bc0a362d47ab2c48a38e680555cf1107e16ad3274080068da7efd031977aaf004542c0c07b7aea3621409f034f3e43a35a5359922eb0becef8013d81b9c45e26e1a32c2bff7ca67bf507c399d33270a443d2445416dae464d25e17e98fb6fca058ea1f7dee2c826d977b0a7cf91aded1daf0dcf040da7957e0582523fd776d3c431a833698f65c9d596af41c1fbbc6bd1d059288b5de92b6f52bcacbb9c818df8c1ebbb6770027bed8e94aadfafa3fba49433dbeb1308cc8e8d9980a11f186b3b82c8e50dc0f452ced93dc2fb3764cfb8cbff2928b4fb450fc13421b6d270d02dc378dd02124afe935e81c0f1e1e04ca472e8d0e38891756a5a3d1f4edbede1bbc7570264dcc129bced026fe3e6f9a84673bc01a866d187baf5881ae50bc4fa2db1e8b5e26638b827e5939b9b40a83ac3da612cf371cc1ac832fb8adb4f7adf04467df299299acce27078624c3373eda0c83eed4f3684f79bb784b9cbb65488660a5200262b1112f91607d66b17e08fb41079d5b035b9a3b7ce36fc1af13b9743af90e5726adee680bbd1a5eec8f107c6d9467108691d26f893e5747488fdb3aa78a4575fcb7d970184b7f976642c9c844f04ad3eb27f94435439a8c13d4f19c19efcc31f6c03bd541e0771a827ca63309d16a7c966b8008ed859a9b86d22b9b4cc5ed97ea58be068f9418a72f17d4c1910c81c122b1ddb03555e9332688a6813648505f879f8b1ec7ebe67db3d20e38905080c9fe787ccec8d5033ef87849fcbd7273cf4c18db03313af5f19549be40876d55da1f1152fb9cff1cfc3ac57349e44168eb25c9a101c3a3ff6fcd816d8abdc09b87f8331e4ebf10e1b356d0bf17e3bd3717b6c6e7ca971d9f6613f9776cc5ec534d97c61262c53ee8c60fc974fb0052151b2dab231de21a9cf5c189bc7dd1c97f7276eb456195dc2fee7d27ca0d996d01d37920ec91193297eba0f2c479e5a4af7166fd2d534fb377b03a18f6f4d6f9deffdd0ce3bef1efa772c6b1fc6c265fec141cdc16e5ff68559c7d2548ca48a7a4fa02a11e8712f6dbd2b99a715923278dee37a92f970dab2bd7c447eed916d091a7234605f17fb9f5af844282d97284b10aba48bab10d8f1ec7d9884aac392f2a3e62be367b67083950a0c8c7ed9734c5863edffacda466c967185fb69e8c4ecd28210af47ed6086e2046e219054bfc970174acb6820f992827bde4dae891b8ac1aad8fdbe3b840b4b76e9f25dca4dc14571e634417e29079e247917bf430044c0208aafe5ac86379f1e51307d8e847ef0a21abcebc0f7e1160fc201251ee0b6c58b1df14efe0c1f036cddd50b5f23995a93c70f6b499f90dae468055e52e82cc825d90c75d35e74b155fc0f94b8bd37b724cba7a3665bb0def2bbd3bbdc437ea6fd25247ac35d235960d65abbe5fdffe1430082a2d9088c7ccec8640eb3d1a1874550505a22ac60ad8c4e2ff285b210cc71952be22a350513135488a1efd2eccd4d96598bf1f8ac068f17eff5f2c82189e923289f5d03782c03a9810475b7c63c7a706e7a8c12f1fc10a30f273d4c769fbaee7c60fee4f37d4bcf22a3d4e7dfd3fde674e4ca47435a8773513a4a24c126047b9a0450d404d20e7f9cfbf8745497d91591707c5a5c27efcc19274a715bcf09088b0821862bec341635af3b1bc2795cf35c4077f0549b6623b2a8eb09e76b0848bd0083f4678ae1a41d630902908a8895f386bf50dc40247fac6484b7e4f1beb66ac36ba84c3780a78eb1df1319625c05cd3b3152f228e977cf3d746257dc0b5a81d2b774158146f966d9b93277facdfb5e8611d1e9e6f2fc9103e99226cb2b8b6aeb95b46a6f39171d6b7b89ad9309cc3b88abfd96f39511cdb7c132f1cf120f3b38e0ff0005831ccabfd5a8f5a556a68052bdaccdad0c8cab8c521e47ee26b5e4e63633d427370dc5118823cf83a1c8740c0e0b6508dfb6ef09a891aa9e0d33ec6c572c24e3e066d3d274f740346d9b00320f6a5cf31913c937d5dfd0f44b1183613262922edf295e4d0f3d5f950154ac1cd14e20a401764cf4daede39a11ca3b389992b3abb8c420051e1fefa592c69cd279838a90baf601e947abc23143ca1b76590e667c7728de8adbca936cc5320d56e89551de1532e69003bef951193eff6e9870e2337f0d85fa5e11bd3526036ec3bd30cc10519fccfd21965a95bfdb945553915e36b51599ff1b6c20a4c3c134e1c2738a3713818bea262fe38defd2f46fdde77044774c4dfd1022b526de6fb09703ec57174f8ba7185bc3b9671d93f0fcc12ef529239823b37e300da2695daafe25d23d5ff2e2cec2ba9ce2cd3e0b75fcd7e2d328cc0dd018d0f35959dd97c640139936fa28dd498934a554407aa34bee51306fc7474ca98dc93089d55c9828e61c577e9364b891ac92697d1c9e647d5fe8b08581c8def8f7ae6d233edb8bf3f4590b0659360a2109f50c5812ff63538f1c0f742330f4ff8e3dec246abe0b0c28a7b557012ccc89c9056339d6e674eea437ea74ed1c26a500957e4912ffc6e0a3a7e145e88d61932e25621f6a64addd758e4f764f2d0322bbe6f730f504aa823ecc13a9d2c0ab9be6f7f1838c6954b24954d4002962b7485ccb8e8fa10c8e2bdcef07c82a87624f3451c0664f140e7756fb2faec2980ad1d79a65b581daa9a222fb841e7d2cd682b0bfa45be611c06707f6ac92eed767699548db0f6dc19359df2c0224f04b11727fd474756d83e339bc88f6af192076c1d9b0fb47521199f4a3f0204e23f1738c20c0b8f74c6eb8f04ccd9de5d7691b992ba94982d4a1c0bb09fe17101a24993f963fafcb329933a54b784b850ecf0b0907a5005706fa6b5f6a0fc8aa351899a824470286541c18bd8bc7fd11cf7583839421ca01461c95078213e7621bf4efbfc19d813c5785e96d106a4b3d9c8265c8487cf370e0bb9fc2fb27ded5066fa529ee795058929df7c11994eb2fa7d00163783caa20489b92e3068131702253114a61115062d889078b04d6567300145be9bf38dca774f20906a6ff6fc5271aa9829ffe0c96602dde5e46e215bcbd0a044e746c010513b7a1b5de4f558060c81af78bca5510cfea310c6d5a0b0d30e8ab5dbf77b95878500b3ed45df9bb9aaf3bcd4dea6292baf5190f3966b615f4c80f15e4b4eb87a28985b84750b76e24d7c5b24932109a43bf36ca80cd624c7594f9dec41e2d146ed0cf36feb0a8d518b5ac3182cf7f9c751161ec1c3c529e7648fae251cfe08cd7889c0445650dfd136e351f24dbebddef7a20658051c5327d8593356b971062529f0eb83f211d30de6298f3caa61b175c28f88099e7f7f8f7a23e7ee177b08997f53eae751489557b80c604d38202db932d4608f70fd3dec58cd8242f12d362924351f52275d7c6ba64a2628f50d98d01c0aabc8a6a3352a86bf29b614488d0602e80a6da652255185b17faeee2209cce3c6333fd8c5a99ebf9c1f313b6517dbaaf751e9821481c154f2007023ac18c2d12a566e134110faf2210e515cf8c88cf73ba79ddf2905d46c43978b2e73cdc40b3f7d1f960718958ae95d83cf242d6c833ec9b06c0033d1678a16794dd63139fa748187e6361b00704ec0ccc47a0d6d1ed4de5d2124e342453bd30a63905b3a96a4c4fabc3e00c8507e1d4a04843ecddc0223b4b2c85c6715140880ddcaeb6f81244ae9f4e860e5579e0680818aa14999709fca2d86b564e714e8e41c53bcabcb7dd0028bfd0abf27e98cc01978524543e9e8fa1f36e3bdc57438badde8cf45b8f5c6e228a89a5f1e21b3bcdcd63d4828091bb8b9e57ed666babb959b3432d02917e12c7d8f8f97af1f091926bfed51ca74e6cfcac7cc3c970ab52728710179a7811b25046463117c41e202c4f663d015c659f72ed2c28457dcfe3432a2b214c271413f9314b867afd350c2d980d4fcf846615bd09ccec0a473a549ebfecfdd2e88ff80c88b3be8b5a6ec6c0437357162417f76b573e0ba2c7ea5844543ee45007b30691404f199fc89e126469110b395f018c3e930aa8a0a4c89e3010b44ffc8e06ba568528a2b09bf52edf754c8a408f5c09343c97cb30406e771636dcd367fb14146c7ea21fb228df50a33ac7c87c9f4aba10441ee510680151f5984aac4f8c315b37200ec49920885833c8adaa64f0f61a040ad3aea48d1fdd0b6f82a62ed296fd07d7a6b4c2a6b1080031ef9a91a4a357677fc0936d3542f365ff11f594bc23172b849124f51ac665e25fc97e3f881a75521b76a7e1b8658a13fd5ca50e36b79c80b6314befeb09b59e6a77ef17317f050c931c8cb87a2fcfb1573e5433403b6de25bee2f4469b9004c7111642ef978e10112b0f6d2cab2d6e41f6c55ed00c8723e7122171dd0db5937316b0845e3cdca2a98ccc57f681ac9cc383d1eb9cf40507f9a59dedad5629d6d868bba833f0640b1c560b0f0dead18d6812a682c846e07c872ec906d5301fdcb368b87ae7fb968e565779d0756d328ae270c2f733f0e67421844dab6f011476de9bb8a13eec2ca4718a151fb0c7a40c5e8827e1e79272dc4a4ce34e27f60f737ad104cb5ed8c33173d98670baf49fdc3d784214502af2f6e8b28d074e0308e45859c73b50cb3d6b810151c0eda55b064c082bb47adc7447774407e7022329587d45454bd7ad2b3cc2f93ca26a47db6730df4a75a7afb0bf16a18ec89b9bcc6a5a2244fc28e10853545e86ad060e2f77decca07b4329a9dc1b6ab611d2df3c5fb4a67c2bee3d12adac09c0f9ab8248e70d78c1e2332f10061225a0d47e08380e46435c4d069b4731df616850684c096ef84fd39ce6a643a9c3f31d33b657c113d1e331d7fd868c1ceee2fadbfd445b50a5542b2bf28abeba7ffd2d518a7b370364251a069309f7d02b76cec652f05621568f2ab77124c3b9d608e2d65cee9fa3b8820658f2d131143d4a1010c12c761cb48e0470be7669df7788b194f126451fd6f5816aec637326974e56d23281f924d92723b92b152dea9ba7e9b5c6e50d3ca4a02291aba1614f0f9f49f53193bf898f5d9dd328f2b9d090365e5be5c136dca0db070bf8abce6fd17c95c50d7f6f58c1e7b8799d9863159bd1b9d4ae2da1d7297e978986ad572ce9913f040774270b672f92a52f2e3b3509a9eb84d7b875ddf4d784833eb9fadae9fdae61c5e600c52b3d0a24f58e6349c928ac0c6f3a77988fcf70b0700c125fd1276951ccd1240c67ed2dbad7b6f3a395de90c38c6cd86a5f07fba3520242f46ca155e9d3e60ccbbd2fdfceabb27de02abf0c83cabd4d476984e69b7e94dc3643f56ce9a3b38b5ba8c820deca6ec2ce537e589a5cffc7ae737b0004bb7d076d5a65b5525efe421d4cfddb0368d52838fa519b61d8379ede33942c665ec80f22f5da7a56eff0753986a17116e813b53ed8eb4a6f793b991978c5cc44dad905b93b9e882986ef78a84822362cd3b0f32e4a8258a5b74572d20f3c5bb0029bae13ce04a7fc0e4a3b57f6e887e3484234caa59b98fd57bb45159bec90e5dbedc1e4bcf0799fc4e3dc407e1871231df463570a8f6d52e0f84d848579946773163dd5d00a7a503a67927e3dc56bc11a1648eb22e8b25546198397acdad84761351409604c215736b8b80e0d5fc16fa3a72aa63f744a64920a6dc77496c765d6e3ad6fe481ea4969250e768595e533dd886799b0b512e790cc9cdf50d6336451e9c9aa4f0be6cd1c7a5c10cf2ae0501d4725d85638418770ef97f7983ad4eadf8527a7a4dcfc3ee313ce538d9e3d04b59f0242e75471efae5c9dc94903fe329fb25e97bf075eec7f383fc29c7526fe36528277a7fa8254212955638daaa11f22d634f573179f41bf01aae8c0920740f006239d050e3b9cfac31a8ccdd3ad23ede5a89b6ba57316a0c00304b1c910b1947985e1988bd96d4d68d5b4391b3fd31c38051655b0a980864322a1861c2ba9e94aa57ebf69bbf6dd353d422e9c2a3a3ed56fce8382474f2ae8ee44be057947182052c6be9ab316a62b28aba01500119ba8d18a9cdd5b0ed3d01c2f46a12e255dff5840f06432ab6f2783579a286221a8f0b70dc1654b60a2fa4898b8dedcc578d207abb14ef15e525f022e4eb491fa602c6e50851a93f0bd43f2337701f18972d298cedbfb428a1c9845017d8002f088f7033729c9e44e7a6817daf95f81b36e9ab6baf58870724ff5f60318c031cfe5b83ff397a79c5c5fb54d610666b73529bc3fa19f867e89fd9c93795d47090e5e54bd706bd773c6190318d7d785d40a9632b8acb5e47d564ea56ec3255fe99297167a334c1248be032a500a75e6f5e9def0167f55e772045adee813ea57ff7886ef029623ea873b6e16c85a1ffc82af15d71d955343f889af5f458eae6ec1dc506f404ea6979306bb52b895fa2e45fc76dcca7b960edb588fed1d9822eecb5fbd766eb7d28fb96cd3cefa3a8a099b22fd0c55391f5823cf1335cb01fc4ce1a07cad33736f388afb10989d88bcaf77b03ceb08e0586efe8f85f5d7ddb348e1bf20f8ebe5ccfc039e12a94bc24aca3f5cfd37ad63182b52220f32fe6522cc45665c73bc5884c90d0e12eccd37aff8eb24cf872cf7251dfddbd91b8aa3a945cd4cd847da1f5bfc89c708ee22b6acf4c5b749945f5deda331ae092151e8ba36873c9024f31f1a164fee7018214c16f46c5922f2a1f8249342ca0af72794e3f399ea977843f440c30ef56040995fbc05a9e192686beb442e27e3cb54ba3e66d2510adcf5e84d2fad7a71b1daa43730d075c5d26107afa41b5f0a41b191d54052b00a59659be289a71ec083842d3e7f3dea63bf9783bc0baffbb18875f2512a6c73765e00aa78c26b6a672450b4d5a01cfd379c4d1e08a49a2005845aa0ef366124368005144ae361f131442cabc7530aa8ac937dd25f91066f4855a27bcc1e48bc30de94a35af9e76bc17a0cd7a2da91dbe1402ed0572332c25796c36a48822a0e5444f96f60c5275650be910d469be006345fe900a02592773f88559dc8bd5030715061d38f5a3248c8233a6d052c72c46d75eabf2f486f7e07e06410067f4848cbc16ce9e6dcc005c6981e8927abb5975301bd7cd4e1854e53191ecfd25827954c8bc66e1ee5f0a3095d51daec9749dc047264b0e34c3e2fa7627f9a42baeb6d5cd6084781ed84dde835c3fdf3a1942f0205da109f8861e1251af6e33e87bb26342b25478f641d2f7880bc91495ec663f608d653900d27dacd192c7d829125111204f37e90ebb698851de26c8ccac1f6a32bc5012b4f9b7309d906bfc101844e6698d956871e2cdbe0a5a57f95b04a852ca0020eebb469d865673d1c4f5b3e57683d3523bad3908c81bbafe81e33ac78","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
