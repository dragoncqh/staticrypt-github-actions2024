<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26eff4999cc7bece8c0e6e64d75adf487ab568f5ac57c72dfe51ed85f2b156fa0a94215e12f24672bb2403eb406f869e9d71391bc01ac6d7249e04562c853097505c08329de117b2c7908f4adb485da76243a5af9e2fcab36238a8c283da064abad8bb8b2b3e8099d24c7e90cffb26d92ab757e0c57d794c7c9ad59702a752ae44adab34263fa5ea286d30f0a4daf87aea791617558f7c19a645f45783ed25ca81fafdc2bb68e632c2c597ec9839a0111ac79f10a71e37306a89c9c591f807736fc11f2a6cfd9f7fbcb9e80389217c570346d95f4c9af20e2b7d1ee7162d2441b7467f60b86648fed90e4f6c0b3fd8d91ef8063a91b0fdda1df2b5f25fd466e93a4899a4ceed39fc4bad23ca1f39ae75e7bacb1d61ad3e484caf7b08820f127cb8ced44a75d3a413c1eaa4d179bf648b72df5c6f006f3dfed85fff6337cdc22c22664afeae61e12af288b1c8d6696256e304beeb9b57b7d3e927272a92beae377a4c2cf482a28e5b1e8e3997ce0abd77f0c2a68d456f0e996d5febd47efbdf26ce15c9137400497bcd07dfc1079bdf1df0a05435b4fe48a08aba363c0d5e3cd247fca227e6cbb8d5769041dfeb2a1c853dedaeea583cf4f0788fb5849ef8a3e6580262c59f34a66f011ca122d572411202eb762765b0932bf3e7aab596dab0f85fb69a5754ccb3e8c4fc93c50abf4b904d3029ca55c01440039116599da94ba6302dd493e18593b6ede0810827b017ca7e500705876a1084d4693909a94de55cccfa5074bf76c71ac8dc85be3c7cf79393ea540d45be1f48b8257344053866e06f6b7ba7986f18fdb5e11c20608fe556063f705f40f56c8e6c41a1acf71afe1f40da67de1d4162c9faa1f6be917443aad1f2164db4445930da84f3011885638bbbb15d994bbaf45255edf6f09bc0f70a22b42b13efa3cee674e94e301d09b42192ab99f6c63e449bb0d60306c054e6d9e885b90ecdad1147830ca7346b08f68bf98f9a8eb19eed0056b7c54dc9ee2781d437148bcd5e1dd643a5e1356150ae6789a26d95eba624e192a66b583168ee9ce260dbb3f6b82161dccfa977727a39d2e44584085b404982724fb7e989392c9fedafafcdb761ae69aec9f6aaf9a4d38c79e53555dea7083980523cf42aa03786e59eee93c40f4b3e710ed52b4816aa54af963ccdf2d6632eebaf90a61b9260b135deb82765f659bd5e489cfe52d8060006ce2405b609657a8e4a6762d5b123875170d12da8a58df02133303bcb8f0d66079776aa1d97cf828ed3b96560f74d7b3b66c290ef26ee781d0c548e34964dc687059e8d35bab061510504d25329e1b7c706c369ec85b33d51dfcda46cc82be74dbcc2a2d50439ada6c4ee175a9f16c6412a5d5bf125965094021f26958cee68af9f7a422ad9d45b9e5b923e3af98d52bbdc78047481f814ea89a8808e7f4fe12a9de095ad7243021854b982a78868c99c577a2c8f91f2a7f39ab9e3b0a41b7931667f21fe0420541a76d990f434c5b28f8eb697d333cfe3be77e392b89cabbb39ca99e0fb9132e48280d839551246e88355955b63e5daf001e8bfe578af10dc880e9497dc7a99b36ccdf6c7a29d8b65e9ee2b56b738629b144c499846623f7bbad58c8cd1d41be7a77e207996c4fc16782b4ed89eed9b524cb7d18e78e9328689fce3a89e3859c48ea49a116ed59c6a53cc12a74f4f2ea67b2ef0d5dc69432af1347b5cca5ff7759ad45b6938adea56d0161e5cf6fb7d8aca6ceb93653a30751a605278ef00a0eefb9931332ab9b130a8124ead5cf0ec80c9456af5503f0dca7994d0e7d96114cd6242b5e5ba86ff8389e869e5a167a6d1da13d942f7665659c9354558b129dd83b7d08e0b290f46d6f8d693b0d80bdeeebbececd489d82c5c0f2c0f8fbe5c7f383ce2a87af4ba2a1024cf8c37e46225cc40f8f51c378c9c40b900c0845793cf8ba9805efb741ef61b86ecc7ee9b1abb3bb803dad7163fd3b439393df9a68cdcb8543dcb005e80ef429f96aa5ca38959ee0eea8fb5bc073463ac29f2cc4fa9a054e39e6a7f9cfa20a72514e4e045aaca187e161be5546eed707fa48e5f1ea080ad3eab02c1200550d5b10c3a48cc08f27adaea31fb7a54137fa1cf54ce93dd96174d5a074718dab2e397357f9da2623fdac56812da0ccb265c29b0486f6cdf4e9e7ddbf4c2f78b13066e411cabc1186d041240cb05ea95ebe22e09837ce01409de83d924d7b2ca57fadb7345af1bf8ca1924c354f760a9fb49f826e7a351ee2e16a3dbff261a67012dfe974b9183e30e3f194b1a3093ae572c5d10652410b9ebf6e866f330718dda70bc441c4007d669117423048aa972ea40e9641dcfd5cd48caec0f9791e77560247babe5aa2a5261cf2cdeae3ded00b8ecb3cc6672849bda7fe4fcc6d3795e5bc16770156a859ef179c77a8bdabc8978d465fcf7a04e9bbea048e14c9e75ae217b9513588ffb0f662679b2909759d75395d69df9acba6f98a29156e2389a1ea256daff2e3c1379834c565ff03c7dd304967a62ff8d8ba4baa024e97eace7d4d150856f49ce44ff8d7ba060cc7ffb435d45d3ab1175254d8340968ace0a5e0dcc26f0db206f8c88f6d48ff80607e5b9cb35cb9173152a82e4a4b78a4b2b1f426194107ab3dd65b6776cf643d105c9c547a44f29455b00cc5e6956a558b0562156bfb10c2eaface0bb23ecbc12b6c595db213464bd7fa0a292fdfe52b86f8e396eb1b5ad9ae47dc50080f43663872b38db6b45d5af95265a96acfcadfba89068a4765bb9de26b762100dd284f2cbcb346a6c1bd2b95aa030d71e7f9143b2e66a804b28070e083f3577b8ed39bb8dae7e911b9c650f0e3284770b6b934ee6e17516e961049594eb443643d086195bd85d87b0eb76c7686a43c557944082569b281c71d4b3d0b2b45d71fa91680301d9bcb6d393db56dc57f66bac13a25d60ca7176b0c8c72ecd2a45b76afee0a85ada1cec908139d339449acbb02b0892468ab395f5c82329d125c5c083de735ff40d09314531446906a0f018f964e180361e94505b2e698e47cb9d764c05bdc5231d999c5bf8b5b1e05636f94071f7d0c1ff1cf784c88d3ccbae5b55333654f5173368df01523750ca70a8752c9013bfb1920a13e8c4ce5f999eba866a6cfddf2954d18108afa23c720b4376e0c093e04ae4b3ee39fa4598c0d730d9c51fb12848c291a8c038ed6be1037f0100904e5698caa11626325efdfa2d558bda104ecb211a929f2e63c2e26d7755c66591e06a582d951a8926a4ebf199aef23842016c94f70d69fea679a5ad9bd99f52711e879e334130eeeddef4fdde28b1365de6f0d0435c17d3ea5d83f2023acbe89cf3f138d74b5713098bdae09e793793b0b6faeacdc5de83dcb5648315e3d82a883256599548e4d068be3e82efb32551a0890bf14adb02597c04fa3915e1fa8f915e15b687cba63837bc9f039a3e52974e559153b1d18464ac887c168295cc6aea767af5ad9b5af1b9c99d770b7ba60950736c539d31b56bce7c46449097ca2290d21e93c2e7dfa863c6ca6db14976e186bfd4b0abbb2ca83ee72cb8f3ffca3548458997797d0419e4fcef0271aa0ae5b298f683a07896c0dfb81578e29409f1e2d40bb58626c868aef9706ec497f5222a031817351f5885ed13347357e21d41a2d5042d9e27b64a4157ea3e331181d5d28f330eee920db33d4dec68d8e1bc4859873cd1ebdef1a27919ef0dec5e7a08ff219d835d1c322d0da6bcf464832c45aa65d0adc2f9364f1c6d188cd42b357ef80d1727d81bd782b84b0d941b72ae32e7c79092ad3f3bdd5a5565b5fe3381666bb10bf0547222da787abc2c81455d2958da2f02978fbbfa353b13ffad579b6106bef6bb8ef0b1919eda5019ad8b34c64610239cbd99f5f9e7227d12fb3616e4e7b8187579b934b2389096470130c5e049f2b627f774238cfd950e9e837b676c51daa5834120660f66047f994ac7d9f244313413ff26cf94ee61c562ce9fc3ddfc77dadd55d9bd4ba0a4cc37ae6751e0c690f95817ff5b49dcde54028e525aedf7acab2400afa80cbed8a9e037c9b240ee079d8ce98dad026217255e7f246f4642f37f6f58f0762540138cce932159ddf613ebcae87ebcdc1aa9ba87ab03b582d444c4b9b491aa958cacec3496b4f03ab1154d5e0a1008f03d1b6b1a692e95a744602878ab1c414fe9dbb7dbe1403ed8d995a44850ad6999cb9c2d5e0f22aa9d42a6426ee8f3463641d973011bf9e008ed95c8d3024b52102ee46fe166a95e5e793c48a051e7bbad671a16c797ef0abcf1b693bbb12ba72d8beb47de6d3b75d9fba0d55a23a8283bb9f8eb565b0f72cb3144c11ea828ec5d422ffdb3b7535f408d3de74e9df49f60ba3ec26d22240c5ad7a6d9fc81c61371ea18ed96dc913f7f5c9baf48a9c50625922a6744576b1a6202df17c0237f4c3d1dcef50fbf9dc4b6190cedcb7daaee2565ebf92b9474d07b6f3f2c57fa6be944f2ae4381e06b8aeb0c23aecb5eb625a69e803e339e6dc995fb8371a4b94efd844ddd2b9f11f19c69018043bf356d963d34011a9c070f9aa2f7dbff2eea417838d3626a54a0907f672f4136034464ee76e4b2773b122be7f7e37e1ac566552e7e1f8a162464c8f91c48c5d7bdec8222b67c3eebf251c7b21f02e619b604f8f1648672c89bf6509e230b70bb5bccfb494a2bad4720fa8f6f15b5a1463953bad1292b11e0379d0feb625bab69d40af48bc5401a0149c2983a5cfaae36d1b7392950d076bae93ff3e8d4dfa2e35a5dca113cdc86edb7aa944ddc641143a7a20d7bc1e7fc6f6cfa95690591703a42cc9270670c57b49173103b41df794251319286ed2ad92858dca0c914127cdaba26cd55d24580bbaaf0be618e9d62e2596e7605db0b98ea8a19d2fb9654c6509bcebe2b1e895bdb963003651d03a13a6f6ea928a12bf2fc715d594a0a6637dbd226cb4a51813f783a85492b9a4147e04920e323eadcc87c633717893fd7bb972a89c69e1ad5ae6fad4c533722b3706169b0c95d59b1f4540d1dc5889909dc2391f05b31fe135c88d67e07aa5f9c3e2336ddf73a62b3cdca749c5a423b5ebf6ea0784e9f0563c6a5ebbd6598f66c7b3219c2cfff00341537deb68b8e07efab6e002fad901317270e4fcb7634c55370e2668159c3ae43df46f1e5f0043d0c3de9aceb5903e668704cc1dbc92d12e170993851bbed6b66a926636ebffe8c561601a9c140d2ec907bc3a92aaa91c19b41697f102f89bd48214deb94a8c59ac3b5e9f637c6ddcdc1b3c2d127424dca8845d5d882d11620630a789e7d5e0941a7020a6cba78f9b6393ef7187627127dca880ce7eedc0a4f943d70a8641dfddcce3bafc772d31a57f6b0c7e9f8d4177a65bb053863076c968e08a2a201fc1f5e3efd1982baafe5a38b47aa40e391e8dd9d201a215fecb56aba8c34d3aa1802c26912339744a7be9d829224554d2b5f77a2a5611ec25bca041995afbced4b218f8f3292738d6fdf16fd878459d97ba67810416a2777eaae0822308c075a705841ee98bdeebdc9edf89ef4f8dfef5a548ab08227f2e7cdef200a6ce97617dad42f913b409bf4f4d375ab19286169eef94fbee8a736ca80eb9a014c8dad44adb1df586ccbeb9d7864335d09e1fbc3f8cd22db6c9292523645c312c00ba64b8cd77d989e28eb69c800558e6d3c58b8cd816beb1a7bafad70485d4e441f7aa0a4ce773f0145c957aeb0cb7326815e60877efb139d8017202287cfe4929f8381890de78e142fab94e138838c83f5f1597c92e8f2997d4773f814176d89817abc9e8ebf78c4ac241da411dccd34f384a10a319149c203e96bfdc4f454caef541cb93ff6828a7b8bc1619b50e95078e58bf0d71c4eb0130127a3af64ba9dd421fd86dfec041d04f647a42cd00742a7d8a04432bd229995a911163f74d300de8a50955703be42dbdaa518b6276f0d2051be37d934fdddaf26d3b4cd8be4e5b8e6622ddd8357ccb6d4858ca235a50e655f3fd5b7098a066f0f85bb3addc55412f4405f300bd296556126c85c9057c2bc200b78308b08dd9eb07f50f10892d2765cc36dffc66c428f213e1dbc7767b96a0db85e226ae46f0743a96a2625e2ed930401bc17497674d1c492a00479b17b273a4a80d675ce0ee80867f3c0cadbbd6c3d3052565ab9be7b190b2eb12a41789ee84d54b4f5fa7034d9c9fe085abd0f8d35fef5ea927b54f65657872d95880519fc716fdbe16384a5542b7b999f595949790566185c5caa8b8d1e890176aefe910e51d7fda69776b8e530d09ddb4b8c02251893641722b5cfaf7e14c4618e50d2b8fa879ea8eb621b3c2d86429dcf15feb3d356ed4fdca9a032239b3f49b9485dc063fe405e7109c5aa7de5929289e65c7749da8837ff85e290452d81e71813b9478f033d5708dc6d48938fdd67dc16fcda158456f80b2ae7fba029fef13dbf8c7dc35789e5ae42aba4ba9a310f700e6bf2b2b6c57e7826a94e5e2d4b454aaf11780d356c221ad27dab58b1784ad8112b70e4eb024848096e99747b39456b651da465f0087e7c806f3b263cf370fa3e70481fabf4844ea453a389b3eec715d1067388ffe2b08763419464c3e7ad423b8c295bcaa78f8fabbdf2a5f860d2f21f83cd0c92cf8878e30042090aaae550bf98433c4eee01fef0a9e992887c6bdb51fdbf52139681272d639b5817477127d000b1fa936067d5620ecd22838ea5232c145b266c6cbab084a65c3a4c9c70c7a1352433436f279ec49c6853ca0f2a35fe865447b3e325a91df53adc97bfab0adf05ecb6acec9ebe4cfe1ddeb933ccc39125d4ab23f4b8a04aa9ba0ad1b1af714cf8d0f755bcf0b2dafdc286e722f85fb4cd39ac7b2626acd1173e631bf89dbb360a3932f1a62deabcd7e18264c2fe42107acd91e80f2a8d4aa6a0166440c9e6e96c3fe593c187326d1e9421e3c97d42ee9fc59268bf171ec937e3de9db7de3be566125f4c5682634e2c69b60eae835a02ac9d2d93da89cb70f1f1f081e6267a71dba493579e758c2e4847ff6325099a9c4ed1d7a8202ba84992d46df5a64376f029b4aaa67b07dc2673160c9cd1d1c8ffb030c3fd03cf4be9cbc22178142b6bdd48e7bd034f2e9fb220004e83b34289ecdca1b8e1b0121945828e629c4988648dd834ed220f87ba9bd5f9f612f313b280bcd1c35c5364c107032c6e5dd2bb2ae9fe6bf6980931668b58754a2e2544db651e23cebcc22f2d3e6be6eaeb662301273d50f33cf52550fcb29c5dc134752bf0bbd63f7c826d214cb47afdc578aa826f8b0e58ef739e2db99594380d7232598f0a35a17cc8dbcd6f4d49573aa5df71d2f8b8b04a3f7d055bdffb3f9912534b8ff39f5650647110b596335f793a77ed8fc2236375c892bf1c17ffd9959c1bbc36300fe12799255e043955e19c3e152c11de37ba448935de36a6102e1356f13572991153ee37ed8a163f2303c12c57ec929453ee3e2cfde2a1c3a2f948f22047d093b80a85031e85d423f7d2abd3028a85e1eaec5c1feb2b491ef14eb20fbf9972672a60f3f31f82c023b43ec85d7871773c88d33b7f403a29434017834e2838c9010767c43826b054f1ce6439d1f34bb8ec62290cccb865392b2c890ffda359308cc7f7c721f72698d4140e7416edd8813deb4585ce81496257ca0684250d13f4aa419599117557593adb79668dee2854974c1699db68483d1691690bc98ec72f2aaca65d5971680728befa0b04dfdcda0761b24234b3da295cab6b32d98ab8cfaf21ad2ba0233865925daf815aa200ccc81db63d4312c8e6d9187e8299972a6e095db5c11550ee6f175f74b29132769097427c9d53eda9a7d332c1a6c87872932ca68b900d9c1c3f8a822901c33a90e1670a2249469d6033dd017c83b7ef2b95e1b4b199a3a28ebc37068db038ff1791d872b3f28530ec0dc43bba1df4ddd005c2080341fa17281c52a361ed88ef8210ff8e8ada1e9ab6e1f76cfe6e4b84dab666176254bd9a2e9684b2b8e215cbb4eb853e4763b3b8a160aa64404e0546dc02499cb8645683207160d6dacd46a3b77905f04f6661fcf93f675616100b0d819225999077b916946f9a376ae2b080e76ce20031a15eeb79227f8e8d4027bee2a8b60c49eb03afc368cf8c03f8c8ea2c54357f54290bffec9e588487eda5aab719ec748da63a351a8268397ca81637ebad950f2d7410739001955e0f0fb19ece653ca0524f8f4a7bbb9812cba9f3e7aece71baff96c5811afd7f6857e4b5e784cefe639382f895f5ebe46de97680f2ee704df0b4910eb0c79df6935aea439da0f2c318aa563f73d938d750cc07be92f25092fc9332ba2da3c2391fbcd650282017bfce35fda084318a987b707892f48b7980968c9337959c763adcd554aab52fc8466c6e42976ddc7d5ddcf93cfdaed45d9fb5c46ec32f4f904b2cb6cd610a3506ccd4be7b8cfda1f3854e97dc79644e2cfb35743e933cfb880e0326552783d44bd0736f33c19e57f408ce42f4be421b93dff1e466740e087566e35456341c0f83148625b5e6b9c1f529d0653fddf04cfda7496b1eb34fa1301344de3e452700f8e019684eeb8a7de9fdcadc7a47358dc4bea518b2dfb15bae3091209f336316952134f99e0ddb90d4de98e77ceba8ef46e0c247fc9beaa5b038f143ad8ffaf892de98af110ac85f50dc9ad95f9dcea3d0cebd401f5cb8b2d5f0f941b995b4bb83c8ad109e9fbd64c6a17f0fe6dbbb3b3c54341c1a4c3b9559875c43e8d954a344e858982ca3f194afbdb41083a47fa58758e80ce5aab96654f7fd7d2864047754c244b46aa6b79cecef471f2110dedf0b3ca68bccc5b8ceeaae4b3866afc9900823b7ba78500512f45adcc40085303dd42a145069f372232f59890d8a997b7e92ba94bb41617118fc3ce1d41fd3c5e4507fd54ab64ef68b89d6530d01fb1a9f02ad0d9a8aa3af8e686bf007dcb6e0953aef1c78d4f3e307d21b3beb1be12e5eafdf7667f14a4bea9c0a2fb00e844e0a0c564c8ec6ea5b19530d83b24e41015cc6c3513f92b82f01e9dc0e45883a9b3d180720999cd6483b76a8a970ab55192d315a8225a14a9db26db9c7487d45f7a9d7fafd97136fae9724c11bd5fe2d04805496570126b1ecd1566028238148d02bd039afeca391abbc94633d1a239d5686c2b26103c336ecb13161696e3f53f009e72e80204666bd0c4fc5a0bca50575825011b6232fb2dddc23e48e3df86253cff6fc0406391c65c1872f74d1576a6a9051d067539aa09cc905cde94bdd9fdf253f290266cb9bab1b5e119c0768f650c6c4bcf63136e6cec8998e6d0a9040d474d6588c31e7d6063c018b6a2d721bb356ed13f258dac07f055e7807590e4c7d3f8d550fdfb8da85cc921e0c9cbfe4269715b9029db01e783736ce53d9cf4daf7f3a2e420099d84dbd7d450b1beb6e57637320bb21410641474dc980983d4f7562a7fae8e84b3203e47619ab028aaf834da45f48905dc8dcecad715dfb210316275a88034331edbb8bfc9f108c9e1a3618a98290cfaf01ecde141ff1ef620dde95d8b0d827aa99fa3b0090bd226971362a0fe0899fb49955f0bd18cc0ceb2808d85de7422e8f89c3a3ee375c384ca9e872f10a4a28e5016955a36189c35f3943195f5e8cf6e974130afb24ce023130c99014ac7dbcff2d81c6684b5216c06d47428e66df67af913c750c5b1450254362396136a5e23199e33b45d030f7c41d95c1f3d7793422dd04be33bb3e419c1edf0e67a8eeaa72db87c761eb27ba993647b740ebd9cf0d358c0075bb5cb18e6f26d3743c3b25a214894de3170c9d581db606422d2b505e486d6eaadba951a9055b04291553dae3c697b8e8c73a5981f874630503e30086bd6f8fe704c6e7ac130fd902eb9b3ab1c23734bb5bb49e0de97f3e45768e34dbfcac4c93b99b27c94f2abf77865c4daeca0fc4abf48aa11ef786ea0e9ae011e768faad5159ee7db8d6b35b73a28b67d120bf9a1efc68db75eae28ba09345c3a0d8b8e94ec7e50c2ff198c4a8fae1fe654c7e4518c8936288ef8ab61216ff98cd9516cb858ef5daebe02e54fd6cd7a58e4f277a9b956542f102081741775f965e3fddbb31b36c8a7be370607bc74bb063413f96bf017918884e282f135301147acfb27dc96bcb464926d0c889a228da6e99e4c652df58203e242f2e84c8875d27739b659a30e75208e78bdf97407ed3ece795fe9710c78c0b7e30e75d4aab719fe3802c123a0900b5be075ecf60be12b4395219b27ca58eff19cb84dac553b8c7ca53bef58c0b61dd91a01c022c6ab358bab30562a47762fd2204987c695fc7d782d036105b4747138ce9f822e84bcbde14519274e88f45b1db995f9f6570ce1bd4b82365dbd432cc0d3975f2aa84fd64862611e6313410020d37041926a4dfb92174b9905739c3e60b27a27f7701d39e068e6aabd31c51f2d4b4d3245d1ab8740903b2a8918604139d7aa920133c0049b061a03e42414ad94f5a96606890dbebf3a4d6a2fcea822940a72be1027c7a7fea85bda6452830e3d2abff55d8bf13e5e2bc3f5b8795cd1eb4d1bc91d25fccbd2bb4574758f0078c4542a5bf60ca63e5b51f73d244d7227ed3257b666c1f097f7c79bbf73f3171f90ae88c5665be14364bf769879ec2accae6c12bfcbef8655af5900cf9b4179ede5651f0898695c0b5719555d46a40c412b3d554549ab7b9f698bb3ce22f1ad5a9e709c17f0b335e0ee0ff99e4d47c36bd4901d0615cc7f563af7b35fa6c2dbd39dc71055612f098aea0e18e096a82e8d2666be97186ae09e2179bba334619a4dff0e6394ccbbca624b6ab2a38777df7309e2b9a2e11f406ede0e4aca324ad9154324ea5e8439911000afdc9c854e824823c886b5fc65c4fa437e4d6bb358e0ac15a55dbf3828b8dd86014f3d8e37f8fdc61b5ae33eaee19a7dfd6a6adb863e0be7aef7e36e84c8054e6d909298d1b462929a92d5f551a3f8eabb6626d02a37b7e490b8e40a34c9413ce070dce5af7d1334e5aadc9c778b4cdfb24724b37dd5d8384c92476f8fc8b1271a09946aec77feb1359ee96d172ddb519e0330f09e7bdb40c7f4512a5658473ead33b9ef566e32c1ab3f7d2d63a4a62584533c5efa0781651f38ee6582305a1b8796ca6a72094717d421cf71456cd18c331edc88345774733ef646830152db54c65936a81e656f7443e236d1e2264bfc804133533be2aa3dffd76e00e8986f978e80732f7e216771f2bfcb8f8e150e1c184ecde1e0c54b1a6ce66615d418db7f9a882470e9382e34f7a25cae0ca44368a4cbde5291a14c7a0fd2cb253c428da572aabfe52bcd3a143f651e3ac59a6809a2cb64e40912e1386419a7f2ce5e7f392398d1b8952e423c1c52f294a1f3761e3512f2e72a06c0b454c08dfe24989883c6488c1caa85ecec78ac1cd61403693411d14dbf52eea29c9513f7c2f50754224550950b88f1ba3b851e09de7406bb2a3d73d422243337e97903b3c749731f077802debe57c3c833f28f5601439d913a63fedb9401c422ef675444cc3a627c0790e699f1f107003d5d6b0c99e086e47ee27e4a050b52d89c865d67cb389c07bab38f336fa6b6dd12feda69d7a9985b0fedc087397f9f5d3e139507aeed14960013c32052ea19309ddb33d1c71443d3ee8483577be5af8e5755fb8d7d837f8f1e77234925bfd247781b1f9d1b5a131223e2679565c442eeb293c8e7e175c447727d6cdf94b46c53bf44adedcb693f21007b630c68953fb79ad5141b5fddfd0b322139f163b884576c786a0ff0802c919805a8c6eef8b3db11e05d5c3f84f85ed66c5928aa2d1c5538740c91ea77f1ee4fb1c11e1c566cf098b1dfe7357c3f17ea16185733b1a71671bea072c6d2b04e87ef8080405beec843b38d4a2fe180f557b3186693b92e05483848bbf0788b9181a43182f25d5db51824de51fd6c4d52133d3a389bbf92b39d8056e478bfc599b863e48c15e2c83a216390097d723c6499caad937a27f8f58ef77336fb756f45eed9a34f913781209921fafe314ce349395684805bb2d37c8d4aa276c22500e0ecb7c264484c930c7970b541d01d9f1016f7369337da01e0403502de20f33ac39f300935b9e604d3456b3a4ff9ea086f822bafadd9fe86f609a9175d6669c7ecb083e63260fd9f7a40de79917b24de4882c1321faf900d26e544b5e2abdf91dbc36c2b05d52c2e3ea6df507d6b8d566f9e7653315925107563ca5b4c9fbbb8e57a6202f7abc5926e8ec5928d5addd2f0acdd1f4a801eeb3d0fcd040e2193a6b57d6547f86d956065167612d49563b32c004deaf54b80e9a70e1adc1e30d6cbebbded2c02add4ca31792e77ada56c51ae996194f91d41c678256b9904459b7a92869c9feaf2ec95326fa29779bf51fe6004964445b01ac25ee3526682c70f367b452959aa02a04ec929a8c0f76ed2eb9866352d3f5ec0aea71386340186f1224537e86f9df3209279f1fb9d19102f74b06f727980c87cf38148899b0d6c1977a4263aabc2172230f03fc4c4975b97e3a518c587bfed7d1a973ee1a8213a00b04ea610307cc9a2ebc0fcd65f6e0b39689afb79f9a7cd145d666a5de26c57e4fcaa05be819dc055c203f7dee548db2c8be7221b6d4731ad290f323bd7fae4089bf9e7864abea5afee1b23346f94b050f3317f713639a22679a13c62aa94186e0e370f87bc858fba30858818c127b468cc776df19a951f7422c2e5abfd854d779512005ddce536d5672f73bcf4ff05ddda67c021c121f93eeb86a96587d723b1ac892bd592de130a10d4eef40a84b73c512719460f925b038528ad23b8ed2abf4588e79297dd9ea552951fea7d7b93388f0def6f698e496dbcddf70cdd5454b33bf06217dce06d57c41510d0ba42ce3648d340278862109530285ec52f7404a896fd236a68d5f7d5d473edd3587ade09b69b2de5288e09bda3ef5178c84d0ee0070d85311c2d7a6f13e42933dbf5e9719623265b1ab6d741a73cadee1bd41e277fc20fc7dc7938bc026bf4a2b396e9cc783f616675ca5d5aa6b14b45e55ecbe4bee9be7234ca161af3e9aefa3e498ac684906bfa8875e517a7cf1e7876a22952d3f6dbcf192dfa6c2e15a6139ed8480f685b979a2c75cf82b06f63b9ca3b27d1165cc42c8042d767524f1965a10c77d3a71d453c356595898ba570d6948995df836e922089c71f60ef6fce348886a9aa7dee03dc84192644846cbd4ef6c0062a02e9322b1ff69aa32e0bc058ec77bf12a481cd545da6acaafe757eba1c726ed40c9cc906b7850c4a276dac5f81b1071d96c67002635ba81191e661d9eecdc7721fd5e33bb02eee53ad150a5807a739ebc2a36b956f8ec1fe685ecfeb6c335c0d22f1149469296bc42d0b78bd9cfff0ad0541663921e0cbd169a504ae55ce50d5a86fbb14d03508384830c1c85b2e4e843a8bd834e7b379156439c66db11eb1df3b948811185cd1bb82ef74bc8dc8f4cb5726e1e583f400af3037a9ed41ae59e9b4e4237ebac4c7010941cf89679f5db59df0307507cd18d71558d5f0bbecea2ca35a564512a3df621d963eef5e42c3ec6c274f636ca19b702df5b255999d4df9ba783fd6acc39b0e3b14953dd1e381ce85e3a113987ac06af30a4c0066f5a680825ec96442a1eadd08a6614f2e23b8dcd3eb95d03c1413d26d55e216543d74912da26ef4d1e6316980acb10205a3c6800e3bb02bc9276303e7484c19afaaeee5e3a522d97f57b0b3975ad841fc5f17a2c4ef44b3c8417a75bbac082e12472a9e5b49feacd64440e280d19f024023c9bbd046dbd7b85f01690aa67415f7293610563f105d9fb8d81954fbd1cbb15b08d38d4b24f4b83d15fb91aa916e40252ec5fb738cff75007c64a521e49d8afdab5c83357e6c5b5d52115e3bbed72c7278188bab70e174cde17ada554ac8c10c723a046c30325a09c1e6745a88b009c918687f9ec4b0b51a7a310eb9235dfc9abbe78e5ec63995f6673146224755b68f2c2afc45c1602f8ab831a7a12ed518a48c2bc4c7eea03d506a71a2b8a4900b0375f8ae090f66c1a1df623fff661286950ffd9040c1820ea763f34e339af965cf20d6b424392c0cd4a3673aab9c17b5f60eeff7aba7a32765d3567bdd4a235e07af709abec808f72c17a861f127286494ba348669bd10412869475ca21f26e2b1ec0ba5508547dde405a33ee8b20fdde486bd78b14d317336e6b5a563ec67bdd8222ef445f854df5c35f63731b24da0ca608fa348e43f810cddd180deaadd2833d836446d3142b8aaea98d878923bcd703c0c5c34cd583245ddb73313482e118a0b1c1cc61e7510a0c4652c8cd4c6eec07b2ca57b589e814b6574c7ab99aa7010b4a7522f38ae87f59d8d4d9c6fe8e0930ad5e356c9e6a24b55065b1cf59a00d30297cba091fa3258f0f6d6f66e94e374434a8b5a95535fcbd9f1556f5310debdc5e2c44de33a61167aadd967627bbcf3074de5ae5bcb89b124ecb424b15fab61555953166e4eef7a405bc460a058f97d14f6d2328265b699f1d11b5cca017d1bc501340b390c8fefbff123f4c8eba76464f0ad8a03594d378f4abbd5c18fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
