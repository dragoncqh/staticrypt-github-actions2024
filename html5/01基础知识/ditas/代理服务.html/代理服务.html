<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"322c4b8fb06c26cf7e2990d8f618012d26d4c9f85ec7e722cc3f7e1475c31e5ac7337343696a7a82bff7981287b6d1f72b3a1d92e4bba0796255762a3f13a331e10c721d9c9658da0db04235459b036c058d23a20b43dd7dd47a3e13b8f94642e9e5810287e1691368390a53868a1b6b82097261c25f356b224021af7bd613c7eb713a8bc383e26c53533b98cdb3d035cbc2b48b388fd66b9234270669269dcd1c3ab07a39a47e70773ac919a8901db742ea359efdc6533764645feee7fbc815b72466a1657807302eb4e7b16a63b59c42d8e050536d3d4ff46d6dc66da2d3f2622abe47b46042cf9dd253b8e5a436b72512a507f4f325bf7c12dc12287ae2a85d3a0f044da57e87bdde0ae334ca40bf6ee7bdf470d8097d4c4568afc02936dd0fa710459c8d4579e411c405368bcbbb37be2af201e31eaa697a1ba38e5def03fe4cb6eebbb90a8731adc9546ea74cb830e4b9c9a9ce9435cb5cc219245c8f10227f5c8bb0d0dacf5c26b9444d235262feb25d8105ed2ef9877060f758e5222b7765224e02e9fc075a7ed9e682992b545e290a9782728cc7fae79db109b98314b936e7c5da8316f8004e2e2b17f9174c917297fb83bb04434895be6afebdefb012522b6041588ce1f8957dd05d987577a71dbcfe4d1ac94e5c2a02ed09ffba9d641d2a8f048f6f81c89ccae8277d4924baf5848e20750feb8c6472b4d1857c0393ae1e2431a5ded2de39565ab647f63ac1a84374a8c90bea9b860dccd8b0713c732135a7f2bb5b6c2ee10d8065e1b8bf06531aa06c346ed8b32c82eec3d0bc12c160c9dec66a0470705be5d57a35b113046df5f4e6e6870c55783a299b2a65db90d5b5c432e9b304474afbde46b68d6158fa01b9ac6b1289ceb7217bcd8214abe306d051126e25de77f6711f95c46a8d37081ba8be1173fec14f8d9b5e7a61928ddfec186aa0ba1f7b6f64b79ce3ae032888e89e8b7476761015bac0e6e6e2ed38c43c555207f062d6923bfd5f59f4fd8fcbd20971ac122c96b23ce5dd7a2b65da4252ab6c8d42b4f05b54e3bb58b75bbe9f459866ae5a104be908a81e08ab2c9f2e8ea84501d352bd6c55a383a299ae8463f45d2aa4bb8322960358288a7cd642ad359cc8f6480a2409f2b2e122439599af2340995cae001e87678730c1e79c68d9c867c7a730d8282010a3266c13e981718df385b2aa46ae8950ccca50cdc2b9ba941117124483d3c2b4b6b2e508076af8ea1a21fb53d818a2c9daece53aad4a1964bca8c1983d798de9c4d91d3df8905348608dfa0507f55f5af08b0880691a5e41e6fa59ab522ffabbfd15c8442ac79e794c7dbd8c27ee8477d052e7f744ee86d940365eeff68df1432fa87fb241a0ee88ad697097becc66d7f38dd9b2baeacdd2308e6b289ffcccb2c5853bb45960410d5c89b5dcb0fc4385b99e68af420965605bc30947b46324b74862435988bbcbaa4127417e1218ce2a4f54ee8d9f5e8291ea14fd7e13ebfacdc860d0f8ae1309e37e75eeba3cf5e9a8b9c2de3e833dd21dda11ae8f486af0897e8dd77c4a7697ea91255642692651ed6bcc5396db0c7547f1319224f1af40e340d419db9b212038e6fe81ba124f7822488903b6a04f49f203e5f778d3a8b4f0288226285f18c779670da125cde88831f82be4261ff39e34d2e6891551f5200d8de993ade60304e9fd23f89e110d824bd52ebd4365d376af5b19b134a7674f8de3c30853e123e17642452e43929a54b6d800e490b5ed3a7ce561d85668ab32fb3f0a6c70bbee538ac975efa899c3397c99ce3806fa7a627f3652f08456e235eb64eb43ac8c177493accc6874769cb3010e4aa8bd0d6ddc89b21c6733e89d0087a46ebab14557c4981bf0996f7f68c831b5bb81f49b7cb01278cac49d55ea2ffd4d3869ff552bf06f560f65dfa3c52c234deed87082ebe4dfe4933967efa2fe83e5db0ce87086641ffe8aa80cc0318c3470202a108b1abc6958f9aa855fbceba42d294dd67ccdb1dbe7c6877d2c43302acd1d3eb67ad47339bafdbf7c6d60df7a38d52d5f0b419b5bc66da61268f041082ccc39a38d5d12f03c6e32812c2f2c804d43a1e87adbf99d7f8173a72a13c99c770b464d4983ca2e8b199011dbe9aa7e238d84b70e9fc84b0a3ea7abcff26efce9209963e91393b7df7eab0d89bc947f9cb6162e989fa7d7dbc9976638e63815ad92862e28415f27405969f35e241163a1a737b3f18447b80fd29c869362a1b37ac6a3b946439cccb58bb00348222f461bcc5b65046002675504ae316bc4e5d401f23fe089d7e6f985d98e547e2d045362b0bfe33b43a5ea0734dd2391ed7a535a6e865db0975c971b0008b65ee252fe931b0bddf3566069b98d85eb2279a37139033a709095799eb7cbed8bb881b4588f001cb6a8d07e08b36d246514588f17baabc0f08bcf3e0374746a7d8bb4d03459dbc8ca5440c24a17831efe4d43dbb31b8a75acaaa806fe2519f44d170e96582c9d5feb1e8eeb7c11616a948437344eaea83a7cdaeb4c5146ad3fb42bfc4f3df62661739878986f5bb02264215ada8334c00e2c65de59f9d5bacfdf2201fb54e9354f23529589badfb5a97e41f93d892c28b9929a4ab89daee695abde79335d7c284174f3e0a470f2a4a4ab902915c235f1e447784f5340a488c7ab9c910bc96931deff931ebc71ebfd9c12c74ecd52e02c137791fd4ec06ad174ced8cfd67d60833d15b59b8613470b4da005bf43ffe574dd09776bf7afd3400d877065f9a1f2cfad8ac91ccac8a2437069a8c3c3d6a07d3d1cff33107fb2820d6151c6bf565815177a9c1f224213d4ce908b5322f235bc56c5d9fdc0d1f256d9e1c6843c4f300adba44f658fb8bd1498c031311ef6ee3fdbea3a5ae24d6f776e7bafca18bef9bdaa4c96876c1cbfbdd06ce74b08392eed99ba0c4c772fb3912890b7ed65b6c92c363d06911c81c4fb24c67a6126996449541e98328ae168c1f2b922c59ccd56eeb69746d37e24500255a70b08e520e47e60a2a713595b88470d4a64e3ecbf656e99d45907e0f0a368c7f369b13426df609be111cc65ae75449cfa4c2a05859d5d9a50769b35e579e0c1d993c5dbce3ee498bda90303bada516ea67b6a2ab343466ff8e70c9dc2fde5f7fddb861c572f8666a1c47d3515ea168ffa76fa27f7e409f053ba9283a321a09e9bc9809d10da9598a4f51a720f5bfb8769f6f54f4a2b13c82d1f4540299f01fec01bddc73da6a139d539c7458f55f3394b22efb6f69c695971693f1175471ad9f6f739f6b86370dedceac649d4a4aa991c4f6abdd2be111daf226250f524710d89a0f652e16a6fed0417b843706cad985e5d52b051a26ecf10e3e3f50cb01a19ef3ded8a9cbd2ea12e98036392822bb6019eea8a99e3323c7b94a647d84ff5fb9cd6dc28689fd1e040994e11c73a9b7ac748d5b137cd6ec6c3f799f5d2badf722a502df53e692532282070fe0a4180a577b9a9cff1e9e88d3312608de6f390c3dac5430739873e579a76196fae74ceadbbe98bab3a5fdcf5bdae8c46736089e587bba71e0b8172365509ec09d467ea13911307eb992e9e0a2dbe0379206ba43c7f837820a7c04f6165a6d4833052681b3c422e8360ab6dac6113101f6d6d826671c600d814bd1334b70ba3f925c98c96b731d9bd79ac481e18365bf61a65d8067880dacc1d3437aaf36cf3c0cfb4a6c278e54f5b31f90ee291934985869b88b3efca85bdf00968dd3d6abd11a2ea09d1782eeaf44949ad225c48d332ffd1c28da1af82e1f6f1016a4c40002b02e9c42845050e092ace38d08544f4e02a4ec4679fd59f2e18a7fc3338b0dbd8b3d1839603ae8ba70e49d7fa46b8ed14b68cf875a93af494e624bb8410510beebd5fb124449c43a0ce22ee1dc2da60eb9f26067a3b11cf4b4d3833bd732e00d15118f0c39795dc01adf067a0e04490bdc6fdb80a08b82a7753eb02ab1e543cdfcb4831ea17553e3789149abb85ea0b5c2cf5fdf051d955de5edf0817861532a5d7e8c0f9157d743a51234bbf80d2c00daf4c4d0dff4918e67f5d6363a5cbcd470ef69410602f05688cd1c577d9f18da3d38bb5d5a268019c2c5ed04125382e51ebc757947e576e0433a4d3c876d8100f0969f719dc0cf8e30615268941d76432480043f5346c22b8c0d1a72d8e61fc879d59fec04eec7fe0ac6270b0c668d48ea657af62cc7a80bd853ecbcc31b37a011c44bbf054513bf1d73ec60380424532681cd0a93e2df724e48812964fa64951e08b8fc1ee34a10fac5669cd786c0b27fd2624e1dae6461a14737e3b03ec57bf5d5a05ce0c64dee3ac24b0840d1f3c7f98523a34259dfe6ae16732a159b8a6082fe22bebb89281a4c2aaa49fca7ea55fdf489de814f321724992dcfc2d11d11e9adeb53cd1585d03f06502f2d13cf17be15d0b7bb9665e2fd65b34c5fde869bb44d9b0bdf26543a3d1c66007fcc168364e7e2177e58090d0d13e0d6302db65d1b132ee5bdf12c15b14a6fdfa7de012ead38114e93460a6becab7b2bf01195a774ac3a5af1820a9826473c13194ccb1bd0c33e90a4020c9a1e751e444714f377636c2f77b5f4cf50f7efc03efee94c738d410bcb8e9f1776b810b36d786d6b82510b76a45bfe48a368c8bc2bb552a4e9ebba8324d3494c63ff2a0dd77f7fb691165bb8646550cfa7be086e4576eaafc3995c8bc91a4854b20fd6bfc56cf1d323af44c94adb59ee8d6e452a4fb5a3dfd094b80a452993fca2dc27dc005e2d660c3af994546cf7165e3aeb1b6edb229d79dec63011856eb37b260140499853a39591082c953b35ea781e0b996fb7ea5f1b5a0855020f7454cca360288f28f8d1cc4cd755bfc248e620b586404c0ab5e512638bf466968e7879cda17f55223421517c03a312c289bfb009b3a2d8a35ecdb35bdfec40d10f758a4a0f9103c87b6cfa87224d52248cf901eec518d1711e2376126e6714c2c0e6c3336d559ff03e58bc23634b7129d10ac1d429dd66efa52ac6944f86ecddc8d095eb80150ebfa97a15b8d3dbd46c38d68271042b2e0e530b869a11970350c5159b2d83184ac9599f77e487609495fc0e9847d97a8cb04c71718e98f5bca2cd4560dee1a68ddc97081e27b3d38a05b6f6bad60b9bf461cf80eedf161f7ad499a2ccf67d9fd1c919d5d369e6a213909b783cd6488dea1caeb202a222da372f3ab806007e48f3d512e44e36965ee3af17be6ee426e165eb5aa1768ec660c5b430ce5528f9b45bb73255810d5200c40d1455fad2de19b03c62d78488a4ca619ce3e8a08406724f03f05b7dd4dc7cb8a067d97c85417de39937d93c232ce9a608d9ec553990cd181e2fd20d1307c157efdcd75850fe409aa19aadb9a453ac84a540b447fb698d770335264cdc326baea471fc4ba6d75b00ae10027cc6d4552d71f3a7c2081af1807ea1982105ee4bd0c0da01b577e1eecac67e6899ae2b8d74ad0d8bb4b683fdbcf285ce93480adfd1646a492148a48ef7ddf6d2393bd942603e1fe3be13bb64c63362ad5f7fa077a6d18bd20abe5816a92fde781cc8702761daadc6bc9c65a796661b170d3a369c50e62860c7461dacdf5773eb50acdd62e606d971525ed9e9a319f79e3259cd45a78156b52cb20aae7dfcfa57ea765963106effddba9b06ebe0faaf83065afe4dcf179c044e63ca5d188885cf2f5aab57a956f9965c0a58df9151ab2f4ef5ac0cb6cf2cf2f9e0fbc7556485be07c9b9a2afdc0242c77aa0ce73ed57c0a62eae802b989500a64f23c7978480beb9a469ddad0aab6b46b47f09b4c5e699cfc074b7f1cee3db4ed88cd957a2465685d69f443a2ebc46577ae6f290622cc4748799c16c2785925a88f174375c8c5c3abd847808893d44099a9f9d7ef11342397f4234e57ada70fd56983fb9529cf08b139185a3137857784e1d5e604135811a231058ef7524391a46739341b196506e30ea4a889963b1a008143fe6a90eb4089a9eb4d5a9956fd64a3920f78d2cd25ffb8aaa1d2d02cb2a4d3f38065687a094edc94426fbf5ca105f28c3f86a17623a3aa39acadd28961ea6a0819dd016f708490fddf2e66c201483ac88eab27cfc2775d5e62c981a5a03d9ed58901a97c20ebc773c7cbc0230327d16a8a406ea4bdadac6d60402062a3e03086e528e688c3e72d5a65d528e541f233e38868f9c6877d29e540bd34687cc84f63e8373d467b1b9d10badc02c481919f6bbe84657dfa2d9120f4462fd09bf1e07cf942705264092951df7280d238dfde52de1a57e3df627b1ec4c37df26207230f77eacd8383991d99e1a3a619bca11d364cfe8d17e61ae4b33699c341f9572a2c280f20f0d1ec0cff652712aa873494fde4c18a3a2866f6732f4019cc7a3f2693da6c53e9539b18d89fb17852eaaaa076e25ddd92236b36e717f33ced49948d69a8b84c058a4375b989ac24db0342045624ef63844689e31eecf8c081f9db97bfaa2987d914fdff92bb54296c4d47af5482c52c451097f968966149befc27bba5ad473d1045863b718013d5be0be4df837b6c8110b30af252cb8746e7c35d0aff80e881512282d0d6e4a1eee2aa59c667cb5ecc4bbf9c7a85cc2543bcdcca71e60890634105bd4b833bb01b40f462f87448580c408b7154c3f64567557cc983eaea43e03c1665b08f6c03a7a8b170bf92a3f980fe0c60cf8d46b456cb7702eac01678c80ebd204155f7b2bc6e35305df3a9be0a3becbc65f3c7a37ed74b77ca03bf5132c6dc187997124705c19a57a80539d8ea6ce91a3ec40c6aff6eb3a964e7f3022cd7671d7bdc7eac7fa3a1dac835ebb5bf7367805722b9f872491acba521f69749fd6c08a6915abe538ab7575474cda50507456b1673c63ddeaf3ae6c6b65a8e51cfc81797cfa4006b097395530330fed979f4e98617be215507014dd24b14e35c877d3880af8b6c61c04ad86474c48cc2ae732579c8abc77f2d0657d089c64df48af3f1ba3e5518ad7e7ac824f1655358473aa3f5a7a6941725c0d3565ec2006808e2e10aed058683f9724b25443e3b21d7b6937e4b3ff552c270fc28666fdc46634fe8b5e21db42db30680e298ce7a7eddfcfc173dc2901cd8afd6420be5971f3a8cff13eee5b5aeb9acdf1218e988f59fed5d712d1ef7ca5e21324e1b31df7c568625e29167844851ed902e9a4586960182ee9721bc93ef2490628e9bdbcda397ff2d9b7701eb7ba352dc77ea7f7791cb6a33478e0ce9a503f5085df51afb02dd207f988f2a4748a79a7430c237dec85db905228bb33f3aa031a70d6d02980c40fa5e59847594b08524966ab54c2ddd79f81bcf6438b7587df242cd2e5792051d28ccd03e850601876456866e5e5b909815d6ff21f7df3f0617abddc5e1410626511239e38dc3db74bd42ae2f3a445f6bb9ec09787b20203512a2f1854b6e654a19c34860296aa62d0c68cde1bcb392ae342ece0b6ca52b48e532eccefab04cb3586bb8f0b6f9a47b5b3ec210ba7e3bac8f07c10c6a91fe2a0a1317577aae6cd6b9f007cb6688f450031427b3ff38135dcb4ec01732a53bd41df1683acdf0017d2325773fce2761febfd1509e7dfe1cf96bfe7b4daaa5fc22c20bbbe0e564b36c258c144a0df4ce3177386c88851dddd890cb579f66d88e09d0d27e47f2621e8f9e79e139bc7dfca4e72be4e9a02aa831b71107d1176111e196bf6ac4001c3f46c2893f28e8804112ce793993d4dc84475445630aa3094bf689903373ad4d76b74dab3fa128ee10575ba9ba482e3886eef7d3949e27193d3e1e2e143454a4490ec01096c686e77b05f011a300f331928642e0b46812bf1d2d814626adcf3fb86337965be1dd7c3c114c640098b943985007ee01f092686d286062b763e3efec0de0337bdb7d433a03c186c39a318399550fe30416c23144376487cc0190c63b213985e0346cb394e7277460f10d77bba3985563a6248ca9ba8d18012f6465d7fd5a8f0aa19014285c9a0cd415fd0ab8e8f3604a34b6530806c883f937332643b4c6b1616bd288b13dc96453a4368c12b904c46d3d6d23b2c65f778036312c0658a96024749a462b65ebd25dfd748e47225c0768923804ecf2141b4ab25cdf79ecfd6df432c4ab88648980bc31265da2b97f6517f6bfaa1575662eb7bda6eac7183277d8363e101d796165d4bb1482d03aec5f35a33ed475013551c8092d00883488fa98e2f1058c07a16a1be37775fc41b6a9057465588c86c3db259a98b95d1f7ac3dbc1b3c8aa21bfcd64164220ae5b1b4e8f2ad7be352d30975e670213997c409d1b1622f9fe57d8602e8c3f5e881dca31c5995eb21a1e8f6eaac49d6c312f78df6afc26087fdfbcf0fbfe7a01b4158c440338db927fa748116d0f394bfe192c17156a5031cf66f45c60e212f9e33fa7e1f9a0bc20e5dad4c247d15c6f8180c97d36cd1864fe53e357ab566db3d51c71042872f31106d22074d5504e0aecdf707379be61aa59efa1b28437b5a6bc347013a4341572a1933ad52587e4fac4816f3772e0a3150f9149d35b9a7f823394005d2107055f06a1d6391e1abe479dccf9f1b8d4d028f5de74bb3e1d625e49836b00488b6ed75d3cd970cdd46e05091c025a358acd9f324ed0ed007a17ddb5e5abfb551a997e12aacbb5e871ef25a4ed547ace1d21a0922710ae75943451d121c50603bf401c463d7df95589950c5d36caa2713821b6f9baf171cc681b464df1675a8abbbb1f224a14bd6eb90c2dc8430cbb130a39330a8c6f0f7e3f0a29920638935493c7607dbe73581c403a8d12704bbe68b8dce9761d62bc826b170bfe760eb25b54dea05843a36f28eefa1f5b804e8dcf56bf83c41db88df99577ef2910f30a5635619209ba641033e61197e12bf7e36b5959d501feadd3ec791de8e654f96ef4c6061b414bb2e9cc6b22682da4b3efd4452dc86eb7b9d94084a06fd7863cc1f4ef5ccf580d6087b900776bafab4d88614b2960b097eafa0d37510c3feb6e6bed6b3e936f4e75098ceffde1d37c82c2ba7ed7dc859e03abbefe852ef03eaee20012fd9a5fc4470224123944ebe59080fe22de23ec9d5b067acb3472534aa05638b04b1d6de10964aa4cbe06559858c0c0c2dbdc5de1d451f6a35da00f0c057343c7c88ffe32fde6aacaccaecaac19d9891002d5e9b7b9b2fcc2ed675c137722d8fc6f8180ee89f52c1405b63bded3231df0af23d7f248fa47dca39ceb6c89cc05d56d68e7e7e63c9fe25e5d6d4261006ce7e4eb34480d8726f99a8d692b9db93f193a025cfef09a0f8973e464e20aff054fe4cc9a000ed932e41f2a0a29d0d205a83b10f1c1da8945e9cf27e2f994cecafa9aed1e6e41b82c7c59ca89408da983fca0db0d4a1235ce753b139a4c71bb714d317e7e76c7ed4574b9a5f0e434132ee822ac1fda5acbd5001d233beaeecf0412e1dbad5b0f875b0c99a8d64d4f89fef6e08f8765beb9ff49309134e1692eaf3d5a93c006065c5b56875741027694ad2f8ec51d14b0f6e9c7aaa4ec71299a6f79cde68b78c052124acd5e7ba75a3129757df9145d8f59652dfd0a9dac23915884bbdce7890bad569be8b45befb4cbf64858712dbb13c3fc5e9a5ede35381435a056775bf0fd60763d3593ab9f20db14550bada92d0643ba9c9bd554f6b245d24604647707b32855c5f329ab3d18f5a0ff1929346dcf6a12ee161f4c8339d346a04362cf93d0ad185e1630cfd3164a438248b6a6f0317b30b25334c39c51e3146713d48dceb9dfd3df45a610790d2583868176055a15ba9661070d8e4c747571b61ae377ea49b702b77deec105097de8f25330039b653732d5ccb5d04d2deaef9e62443ad22f00c6ed34d01d6cd6d13446a2af281c027e8ac242d157a1ae6ccfa5c3c2839c53cc9222c515da896f426bfa19239712b7092a6dd525bd7b37b26a47b1814de9408823d1b7fb8ba2d3c1cde72fc5e5587bc438e118c60c2f02a321f87b5a4f97364a39c1487f84b31aff4d0946458594d78ba46bbe34c7c5780e82ca58a4c1969c6130e559da3a3db6dd31e9b5d3729b867a538f2422a703205005f70a83b86cbf2550d2f9eb9619adb1ae81d6875484eb38c0b55eda3d0e2fc9478285ab91d339b6ad8b50adb1a2b87add6eb2a765841bb4fc7b8d07cb026d1541def90e993deb9680c087e296996a2b175abbb1897f6f57bc804f4990f9a67a159b10cfb08248d2b1b30f515958f04e052fcc68a12e7fba17fc2c65ec839dd1fd7b6515f1eb36cb8560e3c0f664a222ce53d590e9cbecc9db5d62954ce6e5baf2d59f517568e9d54f3f20865ed46372211614dfb2c53ca09a272ee323e8025c384f1868fb2dd9619ee72082531e4c31497259b3a1a05bb1c934b3e79b788fae5d1c4e6e06910990e32b6cb034a67d7c61e5bcf431a0e1b95d3aeb6273f5db540188f79429ef51ddadbe0b61e46c0686b63204a5011fbf2bfdee391221151702dd3e92d7f837f4e8f6ac5b58ace974522e86f816298d47d455dc9289abd82ac1b642aeb661ef3dbd6e8f498546c5da5b73d21977257d6761311af0e20085f3835a6ddbc2f136e14e7ac34b2eb040dc3f47d4d41bfc3f7587a3e03373fb415f10c37d8ee0e33e905591ac4f0634d02a8ff08199b614c81c6f32917423ad467f2d08d8c1737c8bc2c697652e956f5913cb5b93860658bb32cdfcdfd04eb1f1e0a172d8afc885494a4dc79764ced33cfb9f6f609ada8e993ccb68d8c5fba95655ab3049d4f0f00971e31ee63a31ce110a60b4398c69b869cbcf1bda3db9d07065438a044ae1889ceb5b5371f9c6c88777d964b8be7f52f1e81a4eb32bd6480832c97004c4a5c325c5c816c2a3dddd480cbdb6b66e7842d29199a5edcdc369c4356d60ac618accbf660b7c69a956aeb0a1da65963c45605483447a5e2988d6776a5d5aeb0d215dfd68ed51ce8d7dbe9991984b46eded0b77d0a049dc292f2a8cd6d41db7bf1709377449317ee909b29db94a424fe90339aeb78886f42ae5ff5058c61518ca32394ee7dd7a051b21897cd76de5054a1156777ea4f474a6447d2edff487414b559c8ede22fa86ce4d0116d1059e8330b3b5357c52fec1fb60527667a8640a95202d49d68c1995fd32fa903857fee9480d487bc7cdd53530b8c6691f940379b9f73a66632c01709d5fd30703e6a9e0fb706cbd338c10e3450e06cf635c2b66d123e9e355dbc710cd202139627099815c35f7e6133e2cc879cbc1acf434097d447a98d6fc24d7cfb74c9b244c03c97d746db5b168fe071f958e2ac59e60625a6a0fea1c039b8e3837a68c7fe2c4970953c93d52e40012da72ee41c4f57d0f8aa50034906254e8307dd29d50ef72f3c1bb23fb0f81aedcb97851dfef426f23e7781d16cdc4485021300b10b5ea2b3e3022bc812078ca0ef3e8ceb09234e2c8385e35020215b98f458b8ccecc547d15f8c2b6efb3bc202dd129089e9b218db79abb20f2670a6115543a2cc61770cec59aba8d7cac8c3f77a91f14e4b9125d817eac33ef378bbe332fca82cde17d0f229d1d0a6088092bf3268eb9529d9c6dcb6170422b5f5820bdadfb79e09414afd30bbca093827b59b4c6901d629cff6a1b8810a6ebd07cee3329152eaf620f6af2d3fc45f277c82585e29f726384409a90729e197ca114a36a2b10879c25fa8d921becaeaaf2227d0b4dbdbc58e755b6454fbeec0c417358e84359ee01b394adf80d6b243fc72b5f5c26d7a2154c074629be45d5c932043ddf9e8bb5765a69e473a7132e929c3b4372eabbc3d9c3c4c49103753269db84e632d8b9cb86d30c05a3ef31c00553fe122c25bac4eb662cae5c80223e32c4f22572d21937cf44ba48fffa439b179c1586efc51cbd818fd53d8dc02372621111588ead75cf48ba5a85f4a118873478fffd65e34856212d5e043e613c809af6e782b0e19246f5ef853fb9c2e080f11294b8abca271621f5e287e939746368dfd7849933c8b92ab31a0e48fba626cc04040f2899900cc65d751723a9f25b4971d9bbfa072385269570f594b26861f4c7963c3aaef8d8250c7141a60cccf0367ccb7d4e5f3a1b7a629f22252597af5a609b9fc7a3acbf157de83c0bb58e9a693414e41e3fb7b8a238953d7da0dc6ae31f578b79743e40a5ab2f324a7fb02863a426c72be506515004b80199bdefa81c016502a65694e0c62549eebe4d5043151cefee9303ad2553855bc4bab7c9f029d31fde4d00e9fa3fd1f61eb8bd4a20e6ed2c3494fdf4c56fb4390475ea319621f67ac0d1f5e7b91d35994aee3333f4442d11739313f8ce21e84aa1abf7f2ed302b76f6a516b5ed62ed8f849558309f0c2ec370d8278c393e47854caee2486569fe2fb331206df830251ace0cf8e452a9cd0422651dcdbbafc8580bc67d6ca61864d66f31b4d7718c31c98a1bebf9eae656cbe28befb4969fff5582e2117b2362dcf71641402221538bbd9bd6aa90d46cc3f8b21d35148a46c9d1e201a5ba8eee135ebe7f85b987f9619d7980f27a5a8b6ccdf9ed2890143b979a19fb16b79fe5ab2f71af90d90edaed58c42601421f0bcbd12f41e87873f5e6eba7cc098d3aea7a15855b45a249ff2a816904d8db09be74397881d553e4bd557c1f3119c3126f98d1d7a4d67b2be8d38351cbb138619c47cf6fc28ce0ed132b69c0b9adb992b007f682f521b2b45751dfe74443ed72b3d058648a1e7cb4643f8305b05067bab67494f190eceaa2184754a567110d069c76c3325a3fd3a83e17ce4d6ab10a95353cfd0b8d6a6827b03ac072adf1148cd5ab0cbb5d6964f5d5b559b46bcb1f3b71fe4b24f857a579864b7e788bed465a9821f5fbfd00d6eac2113134b765172a12edbe98b3f9f94102586489f70ebf6990b918142ac18f836f420707f3a0c6621d2cfbdddb6bf53d5ad1d425c364bda6a3d0b5935be23f20431eb69773e1274e3ffa9ed0503b4736d0f4115bd6238c399226031ff99b2702240ad1856a034ffef60d6715af071cc57ca049d0e3fc397f9588535d1521229f5db1ead9181aaf96e66b0ff1d147478b7b11bde4a11e360555306dfb0e15cb65380cc6af6ad5ec4c379a920e688fbbea4e5bd8de89d673c1933b4dae3ad961745606e8a577609cc293eea87d60c86ef53a3e1611010affc3753ff72ba6d9b43e87c7cf44227a48baf32696a51b9a86c86a4cb182fbd0a8849592414f6e754909144130d23b0fc969fd794943b9d0357a431b6c5a1e046c4a0a20c33e4746c4b6c8735cc072c57d0f11782080d50d9e71270f10732306518fd95cf7ac4e0eb313a78e61aae3e611c17e7631f73ac76a32734f8f197d7c7c8c3f5e9946fbd9a4c8ba8681557482ef157ae286eaeb21907497152bf808199daabaff7ca58a864d91e77a8c2c74d1007a2998dfbb91d144e0a3d4e66a284265d0aef3337700b059f1d52aa94d0ed09d4ac9df87a902899c7732a7d462dd7e1ef41bf2cf18d7a044db6a487b2937445fc707c5debc472fd4728b0840a00c2d8e9e0c81c5490fa75edb0c44b8dd29a8e1c4e2af74d34d6436a2431f6f4a9f86276264acee63b27ea168f5da89980b28468cd341a59c44dd0ed1d1a023c5b60edc70d2a55668e78cf0f0143be9a03db2eb0346b71599c838de44a056c7d7a1cfeedadccc4f81aff008cf276cf08652a39ac640bffcafe0c14416ccd1869a568752e445dff84107f910a61e6105003965f1b2d648c9ebd858c2ea39a5af66b10511ab643af158a13190398bc84dc3df2a80c763be6fd793e5c98b675c9ca3c1f8078f939ca09d11b4f41c1353d0e7f52aee6b69be7dc2743487df51b47fba8e5a0aef43105143b5dc322c3f7feed194d0b537bddfe635f195bc5b8b3ee320e47e8a7d87dd2e5e44b6cc70432bfa5896f46bc2272d8936ac66e2b664b62f1e71c6b287c8b25f97dc5a1ac576eece1048103264deb6bd2332a6f04d693909e2f1fb8983eba0121186deeafdc1435f7898833d28b0b6065c3bf7f1ecdd804d8644e9f2e06219bac86aacd8ace21c8acf1e4a6735b21bdf295627593c7a49e1ff3d9d91510319638c37374339f7088575e443d01e4fc3e1d2e3c6240f1eda0243c9e43e8cee48029ebb40c83110407def8bbc3ac90268f5dbea8f60c6b68f805127da7111c39f7254c3e7706fe1724690eed8f67a0f361193d4f0bdc26b176fe6b9001a8895fc4bf953f828466929cc1293a7a5ae023b1418b4f5617541cc723c484d2f19f5956e9c697b638cb7f095fb4b4c8d4ae7d021974fdbcead799f27797fba82793fa1583c999ace9b0548d64583f02ef241b4e20b182a448c6215ba52fcb028e58953ddc42ec1d19f7696bc62950aeb1b39607f6bbe933d9150d517592e13a64d1b94c2a6ec6c523422ac09ece4a77a5eb59038f3a8c5255e1cb50805fc148b06a58c1e5c0020e988a67ea771108dce0bdeeb002341a24aa1015f4c8b86e6c7009864cfb1a3b5769b13fce8b9343c2457c3af8513c8dca4d8d676a36bc3ab82e5ad39d06f81ea79c48765641ef11be4c34c7cad3047adf0e8a80778e907436da5f8184993098fa888022e424e89a35ee7bdca9f5b8f2e26fe78d59dd9f8db5cf1891ba8135dcc892296df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
