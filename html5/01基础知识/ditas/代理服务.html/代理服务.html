<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25c0a60e4e6447c5f5a594a4f9640d27176959a964325e0e515d9c8c96eeb8d18bb228b863eb8801c0ee2b3bd58b361702b76de388b8662e3172f79ea871053106bcb2c2578cf048786c4c9834168bd51515a1d2864384835f3ca5812d4b9ad68487eff1177be74da3affdade965b0cc6324deb4cc330e4a1b281b3bcc0953b4e7bf43ed05461be2716dd1542456641c9eb80d0af5783ee30ab039f2997b7de22826854d8b02943b295b44556ec29c7e8ee6995230d30f5ca0d88c38f16f4801ed0a7e3584e3348334995c8616487c005a57214665753bb928b679090ef7f82e2e3449dc7eaafe4d0a38a0334d17d5d62841f76e9d991bf312ec21776d6c9fa31e1f8e7be3a71cc72a342b1dc3a1102d2a72735df6c6cb9b0225b7c3d4d1b6f4f82217405302df7ea4e87773486ff31c58c54e2b3e7fb3fac54ce7b41aceb9e4293012d277a015a4753e562ce4be17033e3bf23ef7b1c19b47be1fc9d362f3a2e980c03d7df0c8a85d883351a6d10d26bd4558fd51a6eb9f531f7ac50e28c7ef403fd956110fd6ff6696985399cd579f4b0d357c66f5e564d1314a2a62c23a3f6ded2bdb7a91b052989ab0c1df55d1c9f6bef8afc40c52ee1f5daf75331a384f7852e9991fb41368abf1ee17fa3010b5d57db9220a50b294da44c1c10867c1470ed6851c4a098848e25a27db9f490385066c7d637c3eda4e94031f79af41602b3e53ece6cd9e1bc2e9c23df98cb4ca5ef6d38f584c6059c16d98b6fb87a95bb7fd98072e247e1131e7bc6debffbd8dfcc0f600f42f6b3ce9e95b383e3c305c068f0df088c85bc6872fc7f7af8b729ca5326da847c4bba2b296419b5f0a598c820ba3e436a17a8ffdc714c156ea9f978118e8be6cc072bc600f7f160015b1e246e3058102d158b347390882f0365b115c60673e5819f55f0ac40bd20a37b68d1a04bb0d5515bf22eef8af82b7c1148f72b4db1e6adc5400b74643c0dafb373ad3bad207a7c86d68fd641731c0a568ad0c70405d387272d81b6aef8cd3f2067030f408dc38af8c0cab95dd49ce694217a8e9cf1f82de10fe4fa14a5ff09df0fe5ed68819fb57847d0658769a653c53911dc8b8a5a85c7b76d4d7bd111d1c62fc627d9e5433fa7101b60805de9ac848429a9122238c9fce9a1e73b9fee910c8e13c02a4c7e7e3a9b9ab02236a3a2a0bacba9be2df6588aa44d28e0782d1560b92e23f139a74f9be5fffac7b820b58be6b3a205d77efcd1a29a5ac44bfb60aa1ea034a763bb47f080838e59b9d5e0547ae168039cd36008243507e08de6f8ae673170ae3bd674cd2c0bfb945f7509cf7108c8b56e30d9cd809dc04a731d722e3d4e3bed3f7d733b02be4646f1981921bc5ad3d395c5f4b2f4f4e432ae16af59435354222be7b759ee4fb31e858b7202ca1f55d1922b2e532af6735bf3d243b477664ffbc165f6209193f6da6a918fbb764a89ee0022f1751dc5fd663227dd652e5a621438e98e675fbff75bd15c4f567cd4a551d595bdcf67eb935b8cbfcf2329cf97cb3762548727b76d88bd2c7959e45ef793302b6a05788f2f79ab98ac4638dd31f2b31948824ae48b03c6fa975625a1733fe61b7f2feed18dcea44030608b78b93a8dec70ab4aa6c10d5abc54fbd3f4fc010989256b01e0fe6b71253bfb464d1888d803b3ea39cf071743166befffe172bfd71c476955aec73bb51948dda4a71bc981947283951885f12c0bdc80d159c120a19f62c8247c1c885b7d2eaebb6eced32a1819559e7c0eef07ae9d099cb8901dd6fa05a30b8dfe5baa8043d93b6fac60c2a8f7bdde4db4b4471f9c7c999832fc8740caf834293a93e7468252c06763e276e2490e6e20a2e388857ca70ac900e03967785f18e30674fcd43be4d7ec05691cec25e7e85eb23c6faf8fd147b22dcb562eb6e318d55f502ab3d6ef196810339e0a4ab1742e8a0963e55ea633047fc83db4756006f1a66546e8866cf66178b1ecff357c7a6cb1a672e8a0f285238d49219cda147000a511c0485e20ffd6b50f488256386b2a5dbd99075f8406766f914d9d9856fff8dbf6a280a763e79782cd8e975fb4b0048406d77cc2e62fbbd3b07ecb44f3bc7a3952a4ee65e82f53473a32970c67dff03633cdffb74aa7547ee4279fcff3474f04b2a4a0b48217562b7bb78aa522eaebd2e64eacd2b69cd2b45d175aa24ac8c437918bfb0fe37842a13ad7388868e1cad1def2e11511ef29dbc29c2ef9b9e4d5f872b48ab5fc30d629caffa29c22e37767a35ef00e2a1bd1e1e6d57216f70ed7e30b9bd8e2b5fd3c94809f133b223e05b3ae231aa42a1bf98b1e1e4168eb8457687ad41a6ad1aa721e35964272c7dee6d545e6cd69a5ebfdf914e51e79466fc834519c484e59e5c782189ebfd5c8b3874f86769f4a412929df143f95d535d320522a7ab0cc5fba9d2e88847725dd1b27ec3a81246a7754a347c2f9cc389522e153a835299093bf88617ef4cbfc066b696364cd93e735042b35ec8cedceed40b538164fb5120df2fa12da98635feed52da0fc8b4574dc13c9142786204c52be98d1de2c123915c40dca9a17ad7bf8ae6e6dc9e99976cc6caa3a01398edf8fdf2a7062ee26f562b11ed16799936fab413fa037f4bd6a1e5c2eb334c9dc6b1bda40e8ac4dbe3defe83242eeadefeac1aa6317aa416e7b1239efe6b8e2c508875eb626cdbd3685a0150419f673906f163e624e341cb3ad9cb34bdba8160aaf71afad35f410b5d569e5b0aecc41a7d6458587ae2e10a00cd263494745f09b0d580fb01398dfc628ec7b29bdb2310de89083ba8f305232b910deb56b364843813416997432b4135f4ebce9ceda5c51ebc0ccd159bff72e1ce496061e66b43ab67caea37cf506f0c7826f423d9cf7c3b27e754c78be2134c18b8e84d891b843904295dd5f20d64560814c642643ccc8d4b36426ebcfc0ebf691c31551edbcb22f7fc6d797771d373b5a5fcfbc85f029b41490e64690ef10f8ae9d2f35ec3d85b6c0d4053b45b4e4687f1ba635d634bd6e0e66c9fa7108b98e57bfee5018a6b1b8749b86748717f37bb57cefd5213af78a21b4e55260a5049c6cf4f1905735b2a1cddd4814a7950c0965dab009ee84835a8a6d911dfc3e6403d7b0b185b573b29371ad2c0f2ebdde8725f43df195c7a444fac7cda3bff25e54437aa8c077c6bf39558582ec5f44734b77b30b88150664dcde2d2f882c0661d9c055507e60912a3a0024ce7fb62baee16d373c7fa4d98481a02f938612d46f574eab06ba962eedf5d95f6f7aa56324bcba4d785cf6c29c7cd9e110a19174b7875f8f3e281726b2d30c13e09f2a075beac5bd97892aace445f0fbb0ace869457b7fdeeacdb2cd3f97b6bd3c8db9d63e7dda473b28cd6f88f5607dd4a2687115de7b4416bceb2ac770449d1b4bec39b8c21aa133da4c06fbaa8964c8dbf8dadb75d65484a7b4d3cd8049d57ad4f505f79c50d3b331d1611b63e45d8c07b6c0dabb9751003d97f428bec49a058d3a908100526f79535251f70ca2b6c53fe12849bd0b8d6ab379a2b3fea38d17854cfba6bab7550dcf579ca8902c08a577b5ad64d623917ed27aa0bbef722b9857bd5fcb488081578754c34669c1104cf802308d3217e221890daed0c2fb13ecc621e8f3d3d18900ee50ee2aa0b80ebbb71c6af4e98f357e2e3d1b233f75ec744c4474dfc8b86a3ff7188ee302d9864c2dd8667bb2344810db09d3f6d5eb92fd4d2f7febed378d1e73c57b3a0e84d5ccdb61d05b8b7c34dc992a858ff8797d52773d9869d00444158564b680bf42a4cee34b8f79f13fcd8421dacbe7478453f328d0c5642c91355ccfa71040a0601315b014c528ef0843c4258fcddc08fb1cf2bfe3026f54224b231298369dd2740fa6cd29ebfce34a329067a7945cbe8dea1de0d46d013797a90c190d6ea163f1407b169dd4948266c876e72fd6247b9d70b87f6b9fd60dd4edf0161c44f73b703a966af7981890aa167a88bf2a4ad17943a726b0f9315fa007d697ebb085af1f3d7c7aafd01639d6625097c5ef17e3355f34e8bc64fa290325335e37489a1611697f56c42e23e04a6a3684becc7f7bad0a41dad856124d51e3050af8ba9e2c3c7fbb5f6379b1c8b96c0b09eaaaed4458c36c1476d5d5e65bbdf8acd8b56d86a9eb61b274d10a06d94d6fb2689f8a4d3f2bf33c893d671b652e42909c881b57877d6a425d7089f3943a3796be48b3d5194f28ee03c72664441c70998de8eb4e9817b58d14cf1af5ac0dbdd5d160ff9f59184938033f3f7b7198ffdeede63391c32ad1c2a7ff1f8579b4bbb8a97ae77e08c02c793fc4aedf697f51bfaca5042bd0608255e82091f4564cbf9b5888fc97f65c96e8cecafcf59a68e983f0f8719d5925eaaca3e113f8a989baac0a5ff19ffcb118413b7047100c8dbd79ec21c425f864c1e4f88c569ee4a67cb1a1a5abfc8cead7caccbff981514de1584c3a040a458e8a21814956302a09c254195868d8a94e6eb2d182877973f0badf342e69be44b4005a9b31d04d5d5d6b6472ef56933a34e67fb0713abe6b734c0e12c999f518c9f14ce92ec00762e2f660dc1fa30d653c3a9c0b5a87f35695eaecd8202e07d0d82e296a87586db1814223c5bf582d9c7f1c49495e1fc7a5571d0def355c2554857a6c78e7f05584872c13c0a5fd76d00bc148c65aae36af05f01291f5620586e36db21da4f15013f493e342b91b97c524a156681f88496ce5292e3f44e52a51d71d4538b9ec30cac2b591f5ba7ae9dae3a25181d77ba88fb955da7b1f2ecb8c9133e30ccb42a17cd5cf6ca24cdf3bd160727ccec8518acfb756f97d40a7471d628d0836680029cec4f4efdf764ac36a051bf7d4535af3186a1c6bcfecc2ae427a97b1ae1b5148db1a6dc7e25448a397a0a7a416537c453dd2d91600477821b08fc636535057dfe87b970520f306abf7bced687899ec546fb72316f0510b4e7d4b0dc574106d0761a3e3d1100dfd62cdc8b19f600d3d38625e4fb946cfb5a21c6232704db9bddb9f09e7f2feba23f0594b640af349bc9ba380f8b433fe0139b10807f6eb26a5d7c2acc8270c89fa39a56d8a05b558c08aa955a56d40fd2543cf93a3f4d2b8661b2ffcfb05f9ff5c4e2158f9d1036253d58a53a618943d3a58509e64efff1450155922b7b02ae5f6cd6461a5f5a6606a896ae789fabcb2ebd995edc85287e7db10186d88c09c7ae7e096662e125024580b390bf9fe19e1ae3c9c1f7890b5a05c6abd3c2befa4fa670046a082586e0036ab73743445360d88d74e039f4c0b59eff40131a31a6cde21615a14f19d3cf307c90ac7022921338588b791c151e74a32e798afc7c400b7cbfdd54cd3dd9085add3eb218d8e42476136038231c7afb4dc928b6495d127c3bf6bbc17c49651759e7047dddf29a6216960ffe91550cfba8fb89ce14414de2f05be2fe99d014fbed9a3ce9f9408ae6b6ab5217ce9cc0d3e8708aa4454d438038d6c1979465b35e16495b9e026d8d3b2d3e3e058909dc87137d51d7139dbcaf3536573ff5172242bbc6fc8df74d7df41cba83f06490ccdbca7c2e3a5292c90ac0d8b1957ec79736fe2681402dac34cc151ff5d26f21662a349ce0bf0482eb047d9a5c1ccd2b9515214c4e959fab7610afc176d5d216832cc86c74b6659a21d19e90a59ec9dceb60ed6c2174f7cb43a4f17fd52cf4ff0353903cee34e6e5dc8503fd4d631a3c409952288db702f7da1fd7d89c90c3637cc8554109efecd14316a052e2486a9445b78d1cc71e6ed8bf9944f41e8bcbdf67e19fc98d73419415283d382a3cc3f304c11ffb0a56fc96fe83e28bcd3b8cbf94f938aaae0d06ffe0b2193df8153f0d4ba5ac9e65605b58399d106fe17a2bdd0d7b81c9667cb7591210eb818b02a71fd3ba0f5e2b48026f3c706a29e55116e6e3835009a40b5341a29af699041c40f4ae1795d0f2b356feaba390f294c33be248cb4a679ecb348fb3d1f3ed25decf6126f055515383e8a8eeef228a2049fd108502e1f016cc4fe754c1663e87cc5652ec1afa741251f72cc6a73cbcf55d3ce74f266d843b585a0d5dd5398a1067efdc7fb55a1a88784ecbdd9127754fe44d1d64eee24fa836e1b3c3a5d00cc1f872041b8f7e51cf726e9e14a7bf63bf56a0d2be2fbc4d1aa4a863340083c9ae2b290fe7db03cbbf55e7fa51c771f76de817c2ed1df18bd35820cf2a393fd45bad5b41145d72005cd9957f97d8315ad3228290929c67a261094ee752063dd0f7e6dad6a0e0b96ba057cc51055fa0c5d29b4dc7eea98c607e94aa0a08b7ca958d59fef277e0f3eedcf1fb2eda478255286ec55006947a81f4ab7e36e1bd1e87d8650d1b31b9011a71c0de76886b7e31a1080faa1dc223e2c9a0343004f7404a82dd53386a23db51451f1feee62fb8f86b11a57c1dfca0adfd38671f4558fdb1744a509149c1c6b10f7d6aba03d1bdbf3ec4d8abc5dea845482bd3f3ea38f3ad9da36b5fc8bc375fe759fd253447cb44151d6cacfd778d859f6225393555c6f73b77272c7ebf0a96968989088ed57ba3251de42d75c8d503eeaadc3a84f09365222d5c8f8b7a9ec4b7d2bcb8108c7bec05656853e3bb485efc70cd5b8a138e6f71973ccfa2ab4775cdbdf9e55ef3f70746633c1c2f72395a16ca2232796facd59c05a3d00104f8b0bcc69800dd4eae06c7ef1f804610d0e91c254fa6f930d689f0141a57113e098662195dd75d6508d452d54084946105d2433df1fa7af1485318baa141a2f87dba31952f776986839824ae550578aa0a5cf12c26ee8ba394d18cdb413b9babe9684e0c520ed933156f2bd617a400a23187049a41448127f5ad77eb4ff68d315a14098020ab12c319964a5bad58f7affcc429557a4f4b856353efcfee1e46cf8bffc3b4f9939c73901307a227a5d314b54b1a53b1c3bf32968b7bf8fecae83f1b6cd8f301bf89d07ddc5c6f7fc9e5eeffb9eeb32bbba4c4e99c00faf540b64dec2db1e3696143dfd791233a59a2aca4e75054df7d22e27c1c53859d741169c0bcfe33ad7ab9cdc3b196d274be3507e78dd7aeacaa65d5018c1e0df08609f5942a85174628704f247206658404978748b4ca061e276cfad8e5ad12d5a0af64be70723b8a197a8e042d52fa9dbd20024e288258b4d961b518288026e498ce9f1d5896dc13007cb7bc6a274a53bae5b04b254fbc4dc6c611aeec0ea266881d784c7d4b1adbcb0eace70f17f3c849c2a385219274171a850118fdc0e7551b00e2c1c3ee4ac5a1a0dd36298f43d7bd2a621589cfc76ee7fe2821c83325aeb4f2caadb1e8261606981e0582d9e902256a50c72f059fb10a257e75a2cb2ec50e16c1dd5aecb69981d7509b91bbbcfb98770a1e39a1c66962bc72858e830d37ee0cc290e85ad9e6fde7e2704af183591c3024546c3cedd1047ca06a3aa5fe60bcf441150caf1ff536cbd33cccea08a23eaec10284aea702e963c4bb97d0b7f2bc3de9be4b8491791421de39f22c1ab1c776df0241de0b4c78d84ae567e133b23b8da299ac7675cf6b4afc2cefbc615e113d687bcf3320bbc574b8883836c58d78ec0168123d96e8f8f5669c2c391b2bbb66d70be12fbd7ff39b7aa8fa33a5aaeeba82b2e3f1b4b417a489758d72b91362236c476b3fad7f182b80bfd9f04d533a0d33a0941e68220a2732adcabfcefaf2288e80a18c83bd322821de89f2346cf3fafc03985184d2042dfa17adbab70d44c4d66c18a57abdc8131c64f2571e627b27772d8acb0e33c82a0f719f43b80d490887d7babb2088fcd6543a2550d5ebd5584d75884eef93e532e5349d8445c1293fe689bdc6e6ccaa9c62a9bddbdee6cf88ffc5100b8849bec1b59774802068b8563a85a1be96993f073ade230edb9e5beb5d13f4b57825ca6aab1c8b43d3629b09a4cf5ae446609441795606b871ecc41a37f917a76fcfbf985dceb3cf09c58f95632a1afb52d19073e76db3b7359839ac0afffde947ef92c7fb58aac402a1cf7ff6d77d062c0059c760d874fbdefdbc49d9bc8b82d28fb22b51dba3c5b0e80ca173965eab82ea222973aae77d648ea178257822202cfe6d6ac448f603d2e6c6847015e7e912fe3cf92224b8d974bbd09d8f1a5bb0acd74b6c721cc8dc917c970baa9e8ffe42538e62bf6a706c76feb0138649424e4bc03d080806574c62ff362b154f323dac86beac9be37c3ec14bef2e10df3a30e83a692713f35014d82bd6592e26158010d15958cb6de7618de9903f0c1135fbc393a2621c4befc00b6e8fce7b4a11c8ef75ec3827da8a0d0e0491642327e5a840bf78942058018e4cc69d76f1b9b8fac133bfaddfd48e37989324dac19daf1d12231dfd096e48f98a0445529eca425d817f2bda0fb4679240e1df8bba77acd37c391f471ef2ab3aca186cf08535d9b0335bd1a5dfbb55be697ee7e9568f8b14b957739191ec60f2e5d2aa09ae05f328afa8edd4230a45affcedd1274ee94742e49f00a96912a00b07e9076d5e0a07f1183caceedd7cbc2dedccc2b0174a88e36d5dc24cbdd9c87886379728bb303c94d037cad33ff0c7daf8da78aa667754548fffe5fb86751d0e1b392d53470515619d11a2f069bf49719db8695774f597c6a9e0fa5a405390fcbb177c92288ee1dcea1aafe404ece19ac46b17014f8696e7ef3fbba0d35d3b2c80f57ddc246a70b6c59ae43c5b8ec1fe2f50bc566278519dc328b60743e1117696437f12dd5cf420edb08a132547b621764f4232c4b948406d0f9b06021990ac8a8c9f0cfd9ee1c065b7d2894cebe572810b34974123126a51d1837fa5bbc1c7ec32c0e4f7716d1bbbd05e18d0ac49cf9d3e4ac57b1688a907540368da0f5a3a53aca66662dba6a01bbe5b078cad355e096a200653b84b1439d3a35f29bdef9f2532055fdd9f604341ccfd8c38ba5f02a799a3e27fc96b1aa766ff868457179e248588ba70f249e669bc22dc4aad4e18a6a8dc0e50c99d863ff79b89b6ac540a14ad909939819b677c0258ffb398af83c464bbae55476f990f1dbd010df53ef4ff503b0f7057d9ad936c9a76e18658c0590bdfc9849d2dcd14ab7ca44e392782f88a86b23778293f567ece748ae0cde6b1e00cb5b902ac7f2fc7ed73dbdebaea8b61d67009c1e84cbb65b1c333ba211369de7913ed63bd5de467be93482a3dec35a6a6114662066bd7a7992cd637b8deaf3fefb673babfd9f4fe7053fcdf06662551c4d19c4efd414e22561779c4eae6e3a3351ade1be2ac81d4d328410a9b1bf0b54507903cbc47ec11e4fb98d49158f43173a2405dcd9cf8af57345521a30ae9b0196939e34a2a56fa4eb505803da7321194742ffe86a9e91aee0f9cd400abde57a7564ac83c447e073df39afe9a3785fdf89c39296412c3a0c934645a9b86ddabbe4fd416896e4ef3a9421146c7c9d4a959ec7ce496d7bb6d6ff78e0db040419f36b45269bbd43943c4e17fded2b1c8814b5bca93b9eb5a8bc05cc1e38846e514e294aafa7b4917e5aaa9d65804dce4e61c0331ee0cb0211b9892775604ea4476496b1742ce227d833fa7dd6e2af2a6dc968c781bd3cde7801f5da5dbbbae82c7b5faba05fd6f4c59b763f63e2498ca01d80b50c0174b531c27093b7470108ee9eae41c37ccfa41af320a42864617a56060c3b4ab82a1f3ad52d962e74f5250c66285335eec757f82bfacb4b6165a75f5aa0aba730585ac455b5a35d82ef01a865ed01bed0e0dc69b2e566f037df32af0454e69b58c44b91701e0d597a292466d545de98b9ae43fd5f450cc81231e0b6b88ee71152858ca31e360c54db223e3cd8b34d1d4d64aaa5aa35e56a7400e5020885d59e670c5a3a3f7215cfa6bfd316996c2f8cb52140a1142cab6d0995beb63a0d2da1c9ddc9e10d78134f2801b2dbba5e929ca2ac6812d736e63bd1f645fefff08f4e4250a19b4d762a394fab1d4082060fd0e42e121a1c46af19495e0b60118e9d5a2ceae99f3f6309da3811552917dafb433bd4793ff3198265604cce42c6ffff1665af86dd971d33434d9ff89e973dcccad6826608ccf915cf770f27f32fc26980374692f75d4a9d8b9b55e68ed41b42af117f2ae322b56e39927050b6391f0d8132344d534ad8aba170a8ab842533cf0dca5d7e2247b07ca85ffed4898aa5c36084244bce2a366fca3194c3a7cacdf86ae403cbf499ad2af94697b9d33edcadc19e134ed9e12c9ffc78dd08908dfc1ba6dad7c2099bf2e4931cd240ac1544718a5b484fcaa520074ed4384f5e6d6262963f4c2684e79d439ec5dda63665e6e23275ea16d79f2dca5bf0d0ce180534394a91ee95415862bdc5e8dc1c54e17098a706d4ee596c80378c7489926b147c755178646e5fbc5166255ed4cf4b5ac174839365a47a4bbe1b404ab3f0104faf6b9d0b8bbcc3f26f0379046588b370876c828b9556a0d9e86f2e5fc566481e6f0413bf43f996ffcf47dd40a716cbb470fd9ee24e27324a4ab0bd7949cf02dff2a5a61979259b62b3a3d1f1e0e957e0755fd8083bcee3e1fac75262b0e67727c5fd776cb2c0fcabcf5905544850f126db0ade0eb2a84772ec5341c9eadc92084312f22bf6b362917594acd4f2fce0f2e08c40c3e86b3098508982120d2074e9a7a6489649b4e2821e985d14e8d9c95ebb2b56eb3ecdeee8c4e21880475f68205754b41d7d4013ad83f4ac75f784ffd26e86e7a57a09bae8ed56d1833f56cdc985fe8c00edc8ef0150b53f48ede600fdce781b5bab5319474bda748d639b4b21d20be9b7aacd8e6c0d05e5ea12e89ee58421da9b3b4c142a02ce71fba9dee3881162419ce7258d6677578494f4e1b30310c91243160538f46226932e5aa9652212a296c89984cf203cb5261c2e1f05e1d0b19becd2de152c3e7de66f4b944e881d70f508b0b3566434beb445e72f479d2444ca12bd306a7a569452a8fb6918c1a86a8d9196afb077afb15fa7d541f999d32fc194c531e03d813c5b4e37a824568f9e76ce35db1d24587b95b568e93551fc40726c8b27302cf73443f60e9adb29d7a5de41a5ab099925ab6730a33d8a76b09f3b00c9dc652fa28686487e2356d8d4adaea9df58c0ebb5a860d804b0884e8b6ce3dade4aa13575425f222bc653c3d378e6f90dcab072fc89c92ac6bca31573f25f72fae499b6b5939822d5aca2469b0805bd6b9d8812f61e8acfcebc13f9adeadd5dccfac3d92718cf8f0c722a00174852c8f77d159d6964f6887d5ba830277adda83337580d7303a1a887042d3382397009ee41b5bbefa936356948c77c3e26b6cc2afde650a3398bb6b751e52ba713b2e369d1bd8f8ec46f96b934e3d65646a8309752b028772aaef0be9b36ea04b1aa88daf8ebeabd9e31034d6f2619ababfa1914e66e3b32fc74f63fc469cbf409f0f9cc816679d5d96b7285f1b0260ad0b32e8374af192a34a0e959f62bf0e629ba26c2e5de13281d618901b77f7ca5f318596a7a57c89058da86504a7f2855be44304d3df75554443fb9e5477f3033052ed5e8583567cda15ef8987eed6686fd9d957f4705bd4a30ba9eb6d86c8e1cb13689b182c13671306d0afe935d757e183470f68f0b8892c8e95f488effa204f0ce60ad19c2bca75444b3f94983ab1f39e485f493e77942a028619352e7545803b6d66b136306b54a461ced5984c14c7536587e690856e7ad9874591753ab563deacb701943a14b9d258f8340215cc602be6db336194625ea434a9797649023261d1e285cd4580f7708dfe0fa31bee5e173c604cdcf46063b4651fee330ff84a72cb21d00c9bcbae55f81707dfa37436a7996687e4b42d366adffcb818c332b6be25d13dbe8fb131e054a4ce4d3bf7669b5a1fa4e48b63e1875d2be349638de3dd2ffd184517ca4cf9451c25afff385cd40066beb34f89d9412c532110b54a68d8b11b9f8af839d963059bd5815a15d564218940beb35ce8b2d5e0236e0ef4bf866374c3591b0ad6060d41a7be24e19d3fb61a8f210c93226c9145d81a1106894f398e56c3dd11f273deb4b9b31cc806cb873becc975baa81b889bbb4714e3fbbfb0516c571c118668eec008c84b53299cc35f5008a7749f265cedc61a87e793d5802d20dccbd6bb983e994a8f73c18d8c953f3120c0255fffa94491a26f81b54c2aa68505a7e938467ff63d4b3899f5b2599264598ceddd6cbc9dd5ec32ea80d2799a78b4f4e1161e250bc25da349b99d8fd3d55bde105349773bc95954e63280beeb2c5ecca075257310cb15c77675970a2dbfe783bdc84e83e87dbedc2c547bdcffa1e61f71114d17295cc618d6cd30dd34bdfb5a3d1b9d5de82af04206ad41216dc4b27fe3783aae19508357f1dcd531f0ca2d64561ad1345cd33811d8cee5a633ea709ef70ada445eadc3e3f6da842702455b079431199fdd68c8b08bff455c4c972f2f5e80c7f67d04ef03b761853a821f5d7b98c9253f8f98e306e5589a95aaf8ea10515cd2b1e7e9e1933ab6d1a9274566afaa58be201903307a83a4551e7428a8e7edc79e04c473037f24c9aada1437d922f8dd37fe5d94de5fcfb76314a1666429805c81a3a6113acfc9dd90bd5a045731d5fc77a0d8aa412f179e36b801b7fecc2f195a8d64755a1969b57816e724ca9016bcf18ea29cfe861fa4962f0a65ca974aa3e02e47a74ea059f7f84274040a83f98bb6ed68a2a42311857d48e8a78805fcf341bb5c7fdadf7f244adf2a2647c51d648d8f20d9645b93565a1bf864b5a9fa6a651f318e97688014b6a45d84345fe61993ba254f06d9cabecb5b5aa92242b59b49b700b4354f2ef0814e7b79582c736968e7c32c76db9a37e516591c06173221202c5d9846c50d586964aea65fac235e624f510150f408ed51e66b86d7e9a32c3ec7f044f8d709b0b559f5940219e0d522507618789070db8be860976b33b983a2888067e144d324091fb78a6b24f7ff8cc2626437ce2452b71de94111472d1f803af0d2593c1726f0e76b4c94e99596db5896cf0ee11fc2e66f32795c756023a2924cfa3480bd66ff3bc6e18b8d3227a2988d7afa771673139c43ca724b57f4782738c0c3d84cc3f41c77c666963269c041f0e7536fee76e5013713143f10e3b944c4ef98dcbe4aac1cf7d273fdda82026b833532081146f6d9894d9afcfd241f1fb65f697380a80277a06b4a6d8f09dfe8893820ab1deb68af0af59dfe52820dbe199aea4d6fdbfafda907cc11a62f742af15833b1323f910afc467fdedf3138bdbc13573e3ca15d145ab6062fa63d01824796b67f60e2f962bf0d455bfa46d22df682827e1e81f99f33ad4390232a0548a5abd30019010f5529585ca1f3dbb81ec4d4a615f6a7e86617feb9c694a8e6f5ad62c7267a456308180191eb3fa0cd70204837eeb64c9deb2f6fb18480edf5467d8355232d8d364b059c294b45ef740cb675fea0656e8228880cac8211981bc67decde30813d2bfd222af6c18458e9ee401b0b6b13b763a2dbc33c828fce0e81b987353bc6318ba19ffea1dd3fb16bf907c935cd69064849ca827e5926f47377d419d0954a370aed3d24d8b3ed783d6024082ee6edc01144bb14b2518906c293a84dac3f910ce9301bf5bdbdd15ed112e8fa9ea3ccdf3500420967cc0e48bbb5f447879cb3bb5ff74b23ae2a199d264d8918baebb38d6010fa989e8a025b54d4e6f23019c5fbfe561ce4cb530f90941f47b5b185f8a1dd6dee4f175f5dc6aee1da804aa09df1e6b6f9d37a80e5272eb79d634a6f6d1c7db6b31ab594416c46623d0e1044a0b3a99dcf245cd460a383ee1eb826368053dd9632e29fbaaeb83920d2a6b44ac43e54696a6b473149b3f33e875d43c014ad38113d624fa93b98ed601a612aa52dd0c10132bf14cff95d04dec8a645b9179259fb3de8561b6690d4bea2b9eccde1df072c351ad05c67e1e5c85217610bbff6216cf42ad5d19a263ce52044d21bbf848cadba6760784431f5d861a8ae79a16c152792b063dbdc2c8b930068f7582148929edaafcfb8c9fc9a5b0b8e6764e98ef236c39fb6f3d362b4c0999b8eb1683b3064552da19e242239f413a2e83c095cd52785c70d8e548225f8eabc4a6e65cc998d8502edba9a6db52ec0601ced03cff548250c9d2e0cc04a92fa3a7d5d55be304b86abd9560951f0cffcbee7f94b30273a2a4ec0ccd13b3d75893837a5edce2fd95a180dfae1d3ca41f97393a04c00d3fb83fe2cb0c7ca66c648b3364649f1a07d87415bcb97c335c3f7bfbe1d8b879363cd6cc4780bc2448432b48ac2a034edd522ce5751246db1d3ad3dfd0522381fc119e10d434a0ce43233bf23016a5deb0dae1b23ca2d325d58119c2f55e1243e7a0dc61907eaa457142c76dcaecc4f75638fec159bc7930f9fa9aea0d9616efad5d9dfe4ea5ea0bfc514b9c47b61fd576bd258e73c7ee5c677478c896aa1a11f379f8b16beb8c5d7abe82e0631cc09ac83ce0e8493379f9f5f9c4e80f0016eb9ff908a03ccffb9632def883d51cbf779ac6b7b71cffd249024b2b42bd0efa5c93c8b5d9d414de98d20b623fa4a035b887337c007498e4b8c8fc7f72c678b8cd9a2a9a2c7d404cf5518fe5b798e11c26fada1549db54d3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
