<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec8f246d2b5ad85cc80debb57acbf5598ba6d0bc46edc0d6a7a1c9270f1c8fd5a81cdd73f92355c6673d9c5bba65d55f23b81b5e837d5ffa3424f7d1d1c4d894cc931b3ccfea09944e4b4e1adeb048134e9585e7ac7c47540e68104082aebf3639646cd7c40d018608d81bfa6d267dd84b8c1bb03026cab8793ddc3cf992acaad8ad04413cdec14c1fcd82542c3d56e8a3c4036f2055d91ac8651b9cff5d73ae72ea2c0795f5a8016f6bef5e684179ea9a1f3a8de2ed4576432722b9b407c6cc7a3e2a4c3a71cc5939fe0f4416e0e662fb26538af840a221474dc5172e56bf950f9eb695e22533ed18eb54f6361c896647bf6b27bc579aa99bf45251d0c209b35602d87c03267374bbe49fa36ed25b59d8129ef2835322b3e94e3c0ac4cca5d9f883b6ee9e7b85226303954451bbf98e8d0abb9ae25be27772b4ecddac32fa3575286c632a5e925a37eb4ee0f880f7bf1b0a0022c33e78f23261696d130faefb492c4aff7642b7f1e7974f195c40e0a8d0accabd9ddb4b20995bc1df5255560bd4bb6f409637d625fb9b1e86cdcffdbe26ac99061489a4fd681e182875fea4be815c86781eeca09cb558c84ec3858de06c10295b3744082df199cb2813d834bb0acdf8620170061efee344b24e24c9cac67bf57c5b90605a5cce680488be686323c1b9a17935a9844e74ec3b697faba0eb885da576faf3c130ae8119369bc5c77a65f72dbd06393eb490faafc1f0f341e6cd73e137ddd0ab6d9737cf52e9be7a314095dc89fe954578f8afbfb7fbcf26023720db79cdb55e8badb4e7f255df99cb466a9af1fbad3feb3b7494783db7a2b42a52fab3e1b383c14416fecf7a32df36d7d46dbb490e003096acc4cb6f0e8771e64e37ff06f8c54aad6c7570c9ed9d4d2d3b656995502db0feca2c894b6e28bbb152250f52b57f8de35e93d4cfd3fb0695cc0d976d9a4ef2ac67564dd23d1e16b5dd47e18716dad3ccbdcd3abde5c30a478caeb8ae0962c4c2b1cc7fb07a59cef7c993ac3e34fbbd78da2f5d43fe22823c9d1855634b8f7550abfc73b2607affe4f9d0731355a4f51f5774a427d16a46de5274ce5568baac7e555328e526d552b996b0cbb585fcc835f287038c9ee468ab728310962322d8beb1a8b2c1e17ebf9e2890dd7c8125c33e0230de47b1020ea4d246df466be6c61a9a1d705a29b0eddb2d50bf59061dd9b69be727bed347c393783ddb824d197bb9a2b182bfacd06edc4f015b2f77a0ea14f565d51218c187b14b0e691b0abba174430a86c806750e9a66e1c78962f1134b9bb5d7377b8e2e37cc28051b86155802cf3deaf7d0e28849bc251353db450ffd4bf51118c83c6aced77331d680dce54749ec7296b91dddc79613ff270392ef1e0a812e66b4ae3c8d5cfc17666f8eb0c78864a7b035a59f58f3407da8a5389fe7169247b55e7c11e3072d05e9d944789b6da2030c216eb3e816bbdc74544afcee4307f87f7d6ea7e5dca772df35ea65d2426dfebcc0d470ba29cdbf1d58c6b0545271caf33dacd2e14c1995e4806c1394d58c4f9110fb15fedcf27118aa132bfae6a97ddab66370603f2b54e9826483901da9f914fb32a16eeb59d6ad91fa76af45a9f84fe15fe538e62aeb707353577be3f01d7f730c2d7dcc35e170dceab9e059c23d324dd8507d905b4e411b0d118103bc2da44c742b73dd5183be40ff0ff045755b56ef963adc466cfcdb3752d28b3cb9e2de9394a7d17c4605d0745ae3d6c472170ac5e502a7de25a27818cacd473cd812222a2977eeabda430489b7962172e6aa8fe42f7ec4f8fe64708f3e9ef6b4d5ee03a6d395fd28c0f9075df0b372f183fcaa13692219fb5101fe313c4b9d4da1760d1f0f62c410ec5e472ae85822b47d41144b0fdd61cccd56d2b01aa2cf1760e500a6823ce11a725c96b259d2c60f847eabc1f6c47e205460ffff3cedbdd598f86530533938ae92ef4c39aeb4a03db9ff0cffcaef2e354c6e7d32e70d50b9b86bad1c550ae28ec908c281e3270d822801affa89d89572dd3656b3e1f4bddde90c1ab553b0ef2e6aabb16e09dea06ee15084c85269a1b0b71dc1bf8625979eb2261ddbba19b152bb0b792b1a98c62146b33bedb95d8b34b01d77ac8c55037b973c5f966d63fc7c82b589380c4102ca7d808f227677abf043b4799c01ef6cb493a26cf805578690135f330f41336486ce5d8a8b8ad9020aaf43f56e1b90d531fad569525133874157f44ee5417727ad169d102590c325dd4cb6baa5e383e5eff43e8f29d36d98856cbf67fb016bb6491be64d64472ac36d29aa8e4dc37905ac59d1a9467286ef04a7bcae0626e4d418a901eb7cc128c21e171c4c03455e4630e97580de224525090b8150fd5ffdadff358f57ac6c55558e0dfd894bded9c7ff5bcd9cba65b6f7f54a01551f2d44feb157904b8bb2a39c68e32711c271d47244f1d58f40fecc92dbf630e3f251cb95aa0823ff09bc8284ddcdc04043904d63395e176f89b0c5283753f4905750e05f8164fdc3aef239969fd4d81a889507d311df4085d37b41d34366972637c6bfe1bc56e0cfb75ee28e86a8f91f794f64cb5429514c1a7973774e1db3552877cfdbceb09f5e5114fa57504121c71a91230867e999483a25f59f9e43ba059bc47d38b346963dccff59576b9a8187303893f3e5a9d3c248559f755d1788aba6f34431c6cdcbbad7cc4c88d59df2f2174cc63d905b466368d6d46103784c1e19803c0808f7b6368c0335ca22d715b46fbc0bfad0c227d62b7ba93eafa036a4a5faf873f871c8f7d520d6fc943c8d294ed7f0fd23946ae494d01508a4f2ae96af57cd0c74a45493f578d13ab8d22dfe779316aab242c2acf21aae28e331e7a372a5982ec191261cf9a0616e4957e29c1df56c8224ca9ea922d899bac19e49bc99e515c5929d4370868784562e44e6f992e39ec53be91a34a7be3931017463896ee62784c6490674562aa3c21e92c25857157476210ff6b3e7533518b567b616f01763eecdaaff955859dd2ff8156a1e580b4f763421915cd74776b3bdcaa13670b036e02cbe41a0d8cf4a698d32ce4e19111d9cd2ad92db3b21f68f5e3ebaa4074804fb94cbba3aeebda6625002d17efe64b8b4cf747f2cc3b7a02df862e210e494b24fac5b8f0575882aabbe8c8c9c795e1cf4bb08f7f4da5224ec1f436207a2d95a7342ae5bb1ee16f01c7338cfd71f198ac0bb0e381fe9029116e34f81c8d105b9b0c4f0e3526f974c947c52ff18253b5f270ff24e6cb596f4b611fda4489499a1e578ac0d3db36ac21f03fe6225d8199df8d5d850e03c8e4342ae3d2fa96990398b3da5b495f275319275a79d9bd0046fd5f2ad7e84229fb5151357ae447faf002bb41cace64b68798dbf5269daee1dad834fed7c990983f491efca11158a1f75ebf87f5bc177cf43a533ca114e09f3d426a1f9a1f373c4cb79cfa98ca8a9fa77318777aa70b5190e96e2c69e3ff34db7490bdee36891401d3c9cdefa425c13e252e98808c06b5a1d3b6f029969fcd31bd2c0352f1948172c5a363858a12375d5c0ebb0be4d511ed894b6c172736fc1bb5a34d3491944bab6dbdd1e3e12ffffb42f5f54fc8f9b6b8e84a52b29ae47cf05a0da8dcb762152b151fe16568429feef96a267702d850d3f054deb527fa437e3a6cd4e319528946d61e39061ac0cd0655394bfd7459c859d07920d3f8cbed7a124883e8f29b6cb2370c0ac97792b186c73e9e9ad476336c118c09ef72efc9fbd2d5450d3b48d33c652faf9e64d4b6f349b6708821c101fb014d00825350bca46ae0ff3647310a6b3303a9d92ae4a15f94aeb9e1782cc32ab025689eb36035d9c9c578d344ee18295f6ad711197668decf2c38f6628add366abd3e3d76b566ec7aad99568e77c6ee9cdf92c15c9020561ceb8d7b47fa53b9dc1d74c072c2deb6bbb4532ba3ffd086e0411443c95c0ca6d56dc9950c7779e2af8b5356ca368b41b43101007b1951fb881e77f5b0051b408d98ec1ef22dbda7726258ee46b7b60ea6bd69cae430ba1541c02e08608d86eec23631eb2e918b40b0bd3e1d55c85a1d1f2843eb6686953b5d9c048f3a36de1b961f334afd7e3e209931aff4d71ce8f2e8e4a6773ddcf9c519b89f308d792355d85916591b4889489003204e9faf40566ff738c9c285bb81473dacf6aafc49205461e660fb8259853ad6169c33002f12c6e50b17013feef0ad00e287fcb5428a94b2fefef73d841d76360538810a1e58bbd2a99a75130a5181d74288c96924d3f5a9a44641ab48ed3239313f47bc4efbe31a23fa03ac1338342c053eb5f495791913d6d1540e400f24c03d323ddb2c99c48be23bbdf0a9864ed14d6ff1aac8056328ab9391c0d7616f53acc0d33c74ee8fc3a0d0b80bd2163c082cc3839a629d91fa4b6a2b97aa17d00c74ec3c5a2971593cb2eeda345435893368d1a8b0900b8deb1e7f04ea190b0502e4c2ae9dcf0d7bd3f91382c92e85a18ffaebfff68d20483e847c9828242b14008b186de985b4acca269eae12ecf292684c001249fcb0fc0111f4fb89253b25327b0781e9e68f2cdc81430f523b29c31f838e17d90cee2901ab09001eae1f37dcedfdc2e34ca7d51748545b90d74aca6c2c10f3f5529cf2b2fe0d005e2bc32edb47aa45d8c629c42567123d2db5143c6d0fe23cdc26d457e963460fcadb4f2443102e8aceaee53513abd171b824cf8ecdf838cb06771a0a1581a84e1e1b4f1b17ea166a76382fabe664f54cb1c5f78076eb02e911d322f32bfc1cc82fd3614defdb80f3bc71297a2842c211906b4454ee09c00a8f65284712e919448dc632a84781dc3ced44ca292e6df6fe23fd61f3cdb735a9c439477bd911d20fde218831feceb35854e339c9afb01e59e9cc9459a8a61dc8187aa40f90310d6b2c09861d3aec117489bbdd8e88d9d69e3d4c4340b3a5ce8118b010ab176940082714dcb7b89ffa7701258b4c64970f16b60df983bddf53c90b2c6040be9dba792f2f93d945cf64ceaf299b87bb4bb5d2bf8aa87e48f63291811e6914c3ae3e3d6729d86bf8367d406b317f11fbf4e939be121a3f5dc53e49afdb53e793bc34aaf54bc2cc3b84091ba2baa132fcd1b952e7fcd725558a5049265139b9ae908e9aa7c10ceb56e614c9fca2f09298a9cd1b7df1b2438b1dc82189ddabe1df7893395f7b291d573577ffe8380ff8c5d41928c5fe5d17d8c312c174acf32a7f580626efb1069afa279c9c4087741eab132a834a330f2000205665ca5b33d28f34725e7e28e67e2d1f0c31fed95e748a295c2873ce06df8e9ecddad611ae26dc73f830e15c6e9257b64fc2f5af6e24db9e0d9bb28040f9e4df8f6324f523f549b4af772b180400da1a5b0c128c6128b7a5ab315d1860c632cc8916ef6f4ecd27ff774f668604e7e0d818b7195fb0eae9c91a341e9fe879205ad7ffe5b867c72c70ea625ec42465a463d3ba887dff81a083af3c9ff54001e7115d4b7f70e514a991a05b149c00b51cfa145635b0f78720e17386a4f69c395ab9e269cff9065bf39ccb7fe444ef2db28b44865ce2186f8f5fadf9f451320a4a56bd87de67c7fe25ab37bc8dfc7d6d543459e87f9c31885f72a74823794d075e9e53dbf358f61a86dda09e26b6158736ef1114cff5cd4508ba4899de8d528705cf5773f4e9c44bdcda783417a968f92d7b10caee3fe9572666c2dac4172098c3c75263312398d5adade9ab852bee0be30aa3a27655c64ef4e66762600020ea80516b52465741abceea144f1f8627301266e86f0fc96b53b11ab8654175560e2d548a49a5f299f85faf7a8597c53a52cf1c0636d43b752ef65cfda6ed37fbaf0559a8ff4218fb7f0e96dfa74ece6eaa39577cc9d17b9d336ae42c4059ab5bc543983314127a84ebe7dd8666c2603df9b85e92ea34f02c997cd91ddab899b98c960115b8cf802aa8754319ca766ee159883d6f200985efe78e71760005a10bd09dc8e10ad456b4ffbf21dd070f86c3b3d914c552bac887da0bb056b71feea8c8982ec057951168fad2b4ce33714bbc662be25981ebf8e11f94d4295911b41c87dcf6bc9c436c996121b8a692b4975a06c051a3b02f37ab5616d9c19c0f3959f46af42a96c2cc44aebbab5753f14b3de9a45de923e686cce26b911d48fa988d2b166181e3e1a09bb8161301224b1b326d05169f16b4b055a6d572f92002350ec5a64c8a4b98b57cf5dda0d57a87df0451fb60a6d61fbf0db6099fa93b88b47fc65b8d6afc3d16ff0be93ede45e0c89a442f92527e363564306df99e148c24959565cb0c59de281c62c709739383c281cacf8946b5ff9e8c1da4cc0f1d4e9d392102bdacf011dd2c19a0b8f810b00a496e30f6a9513bb2b16b07c8d7306b9e531acf57ffd80a76ad1a3f81235c2241d1163628d314ba0e70eba68a32bb381cf4824ed5fb1b8e6b9da91d05b81619b52d3b9ac1cfd8aab34b779ee43effc399c436ca871416c8507d6aeb76570f77ef243c3d43b22ff9b31922122748945b92ef4f67e3887656ceff8ef1965e8529160a4654c87574d7898cdc67bf2606c58126a0990bf57bfbc681a70416c922f8c7e709f1f36ac0df9f293d49332ae5cdeb7f44b2c5ffa28a19bcf81b2b5492f4dc79d1db627d566f06fe171ca3df94efdb3050776a3cd752642458385f98656be50f91ef6aa90c704f49781a3cf036433d79229a4a6023a82b217d1a942fe492fbc37009f37a09d315649b23da2ad6e4d13c24ce62db380048ab184079491ff4c79ed5bd14a33f8596a5487c6ea1a3b89805b1f36fd260abb51ab38a04b6ba1a238b1a6ec4f2509e9952118b76cecb527bb8b076b0db81e17195acff04b1c7db0b2ecdb9d76dad141f40f72d7977c1ec393254406d4331256ec96963a5571544655e56034f069d46395f677c4deba9db7d53911369edff3e5fbb321cb2bb4d61d1597b054b711b010b58b400fb8a4ca8a7f3b22494dcc8ef2a2dacfd88f3d71a75ce22629b97e462d672180475e835507f82681255f6dee31e6a8b42b588e9f6df95339053aa1db1ad3ab002085e7f40c41f0c68d91e74819175a27f8a31c1931104189eee404d4be59848ee4f791f76c8521ae02b600f5274dfc4f35045e1edf5eb54b0d57b9ad2509e30aec502e3aae47720daa16fbf27260892c271abe6644a5525449c2e09272ba021afe21b4856b99a3d4ae8346bedbb2b40c7c0d7a20c983dbdbf6bd2401a31126e4ba68ab3d749422e171767a80d35f19fa72ea572935595fed8c9ea47f7698f0562f388764ecd49b8447e4ec905faf80c11562cdb6520da03ea3691c53dca85cd14be7a25438c59964f869fc9b313fdccc0e2b4538a200f8a0cc6392e0b6d171e1c9cb4ba03455740802229e92ef1be84915367291d36953dc870d87749857053b55e5c13e8853359d3129a07394732bd1fa2a11f1161e297beb9d05160868607dcda4f4c56f3b0310e491562b085e33b7cdafd482a087002d7caa9dc43336ffab45ab812abafc5244abbec566fd9dd1cff55c7371c524b39418af8824caf10c5d77a41065cba44bc839f2d595a39aa69c751f6cda3c9d14d7a10351a52a8c59cbf5f5188aebaa98ea6c8c840eb0e67bde7b60a54174f2f47cd195ecd43afdc0e0f401aff774b07bfcc3b239d7dc63b3da8dd8603ff2e542c903f8279509855f7d27bd85868162eb85143fa4a0e84cb91d87a826dbd0c86108420cb1ada3d5cc4b63ac49901fb159b01922c35eecedc353588ca1b71006d6ed19549337bd4ef010389d0cb131c144f708ddd0a0118a8666ceda55150fc071258bceabe0da02dd965270cff748be4dbf70a66432ca74c18f52d351aaac8aa2191ac44ba1a7724bd1dccb31d13e09565cf206531aec0aa913b9a75cae3155560280298e03421db0df5645d1368aaea30bf041bb9eaf95b00e706065423c34d2e99dc1bff6261932b8d8bfbe8728f03eb94cc28987921c00c3a4a6655fedd031aa2e5cc9d3d002ef1bd489346fc58f0b8b8b4661ba2ffde94cf86e52ab7cfcdee9a92ad3d2eaf62744ed2aa8eaa29bb644ebf1232bb4f2da28d9377dee4756652625f72449f2e1945707de12a58ddaca12ddaf795c94a26d64b5020cad032082b9c5b04d96aa499cf0059c2d79feb276f1669593ccc09909a3c691221b3012e3e23307fee2abdc489d08555240c6792655329a7e9df34bab8e0b607e02099814c34e1061e4d235527ce5379843aa5c413d7fb40ccd12d99f5291142fcbfb4b12ee24dce9de9c622d568172609a0b1b97c441d2f93f059d319689ff703f25246afd61101f0e621d0027a8c1788008caa59d281f25ef88dedb19bfcc897a8d32fa78cab2e9f1cb112ffeee6e9ca48127c45477f1c873cae7e4bb7209deee400b355befdf5e57721ed32dd59ec4cdd140c2ba281fc1358c985892e9ddc5d4692697b2e5c410ce029f9dc5f18977ac73835fc69885f5690c63845dfa368c74692b8a7a091b1c4f63de2500f7a1b789d073f27ceec7b6029713d807a67293d66796d23bd19178d7309c5df6f19c29993e166c21c2cfb1af1ae6bb7eb9fb57a29c48bcde559bc8ced850ef3cd240d62c5b316c2f1ed02d63ecbe87d46102acee1c5ff03679626d58ab00af16be1d906d77fd46a1870112b7fa18c2128d17105821b435359793264a03dc8fc67db7a8b7ca8cbcdc07febff4a47c67863ba059da95f8345d1baa1cd4fa855547b3d5b34cb754c55665c11bb6bb98c766ad4e5ae31ca83514a7027bbe417260e709d114612ebc330626cca6f499e09ea6a11bd4cc05da13bbf9b4fb8e4845360faeb7b428ffabad67ad45e194f17e4ac83d03d9a8ef346aeb1f3e543937f3bb965e292f97d18726e2b74d8eaa2b9aefdae5f26d51059d25f98d8329dd85c54098e183d76670bc47c738d5c43932a11c83c7090e8c4aeb79323b440c3a8a743d30b9a44ba17d186fac688e77a62d89a86f5ca6883fa64eb028fced2f1ee2fc9562e50391e10e49dc3e4a9f04f9bc9de921f84121039c0e5a2ab3e8e9c33d78167a0e2c5160b521a29b3dba5e0212af0c62d94e07ab7e6513fdfdc1a09586c417f3c6f50bff667e4f1ba278c53743286af74827c08ee886c7dbd54c7590136aacf3f4748a4afb158fe5066c9ebdcb27bdd59ec87ff7bb093f2071a61c689efdfc12b4272efe075c194a3b26cee5116fe21058cffdbf17684caa621542100c584e2b6a199068d389fe419ef0bc7d6f59d7bcd0331d2fd743fdf37ef24df4c043e9c827179f4a5d1e7d58b5c4830c93ec5043f1385b179100f949e970f33a78017526360c027605ca47a6187313b39dceb9b06a8b8c9998e67eb53f27c37cc5d1f34c6718c483251fe95b2fa019cff6e4f12068199fbc0dc6dfa9d225c1fb14ede1af57d96020390819e8ee38fa3a30d198fa331d31f1a677350963400eead5a7ac2c4667ed24b1d4ec9e1765a675eb0e771d495aab18359c4e85f1eeeb18e51f240ee368e4bbb6b25880e1e1ccf34765ba81d505d4f1ccb72a7c897469553a0278d913005577e7f500dbe3dd05a5633ed8389f1c1f2941384b381c5c70b5d8f32f6f3834a279cb3d788117fd81ad9c4a4bb82b0742e02ac26f86817712b840ce7f6f94a4d6365dae7ab32f546b110767b01ea64de4283bbedb3ba3b0051af593552cb315ecddeaf9d4379c30b138c6ca99bcc48704d0880ba54d554881b7a44bb4472fcd8a8c579b7edadc5a9861145f5f6f52896b50594c0d1276021a954443908d60378427e2348f58e64363f2c7690a6088c3e336a7c5c6a097eecf5ca1ef62fe1db1e778cf35cf3289076dbe3cce34de3187f5bb9847e73dc30fe81c1b27d864748c17c418b8322ba4f87225cd115f85e3d06b3fbdb7b8b0d32d66f15975d96b57dfac2753990fa2c30f7004e2f7e25937323e5ac458fbafb3eb62d6322c7cbd0916f1dfddc14538385aa3aa66f177de411d9bc434ad9f28898e658dae810edbf8c31e0caf31c4c5f7cc7403d136965d3c7955468c13eda7ba289ce203070daafc940c908d9e1608fec8c22047920ad201ee2e98c57e7f9fe79d2084ab3ca3d0afce0a1c5aafb01d333d9024efcd0f2a9633662a0c4d7d79d9390223680d9533fd9d74e45a0c751224048cc52d5b744c4073526eab1dc20181f38ad41d744bb3761747ba7435becbd8b4e0a1d89613f96057a96ce14471c0dc170336b3e1884561ef2d93d0a4cde456fbcf2831a75863a743daa0909a1cd682e23b43c8655f5a21aac703d6f971ac808383ef59f8d2d30ceb535e2b65b6dc4940e6832ef22e5b1bc5c9707a5021c6158ab11b724a6be61889fbb2ec92fa619f55356a13e23beda4551c185d230eb7a84e03d8726eea6ceff62ccbf931636c29b6a2283afc4f0a4b1ee97a4eb8eddcb7e9674cf978736368e167e87528509697dbf0ca7d661cbcebad030452326f30d9d08f473371542bcfe453a375549899b6bc1e495ba3d6d1259c530dedaaceba022d7bfb997abc1049cf7c4e6784af93186e13ef61336bb1a8e2ec4f356d19bfbe3b2c84743f487e05fa33f8d2c5e50f423e5e4eb8523b868d972b122c843932ad32ea8fe345e94885b4e6386818e997eb7daf972d445e37f1cea74f09bfaf64b8134e4b9ba1e92aa2c799c8572ce7fbf64da49ec99ca660f02071a3124a82a970c73866cc3128ed5893a88fc287a5d5230eedbd6af92195b35a9042d565efcb4b45f80238dcde2be60cd222700eac8e6cd7f3a5685df6cdfeac81dba8d8c93f4355a4291b769a4d7433e6af3b76a5eff1ecaf6c49256a0d0ed41895288bc1315bf9d759a951d085bf25e54d74268a9d71d0663545850eb1a270641eac658eadbcf045fcb82455bbe1ccf4471f22cabf7beaa1773b566e402c9665ee3751092a4bc7d7d6b452e48db049eff4104ad61b59daaf9937600b22f30846ac2a2ed73834fc954a9cfb08475a3e3e8122abdacb2c6acd91ec193ddcbfa9eae48cdb88c5276091520100b01f9d6cc3820a2737a41cdf65d9d462c1df0637a7f8890bf938084ed0daae32a5cd0e42232e32b79734ea4d74be8da413d33f82dadae2a7fb4fba58f110a4ba8bb6568a033193468e25faa93731022e0b8ef8cbdf7bd093c7039e1b8b3f50f7fa592a108ae50324f4044e4ec1cc915052df3dc20bd34e9eb4d95d3e5723084b8806b06fd59e2ba18c80aa851a9a624aa866d29d158ef0ac8be6a8cc9d197e7d5c906738fd5862071861f579ada91ffe208042dea3a67c812a603937353e57e723f7aab7e8784b84272b9c98488ae92fa58e6fb409563d1bf32ce7b77aeb5c2c809059c06fa31b167b7ea03a3b68a256fce1817d5024ed3ceffa0f3fa879a18acfc7902ee40fbc2d105a32cb30cc2e4c6f88ddc1851af1c5965d5860ee0f9867ecd4ffeae497557f8a6acb1baa0ce2e1da505d2d79bce06d319199030a7e2dcd8dd4a928e9f433232fc8542e63a3f8d9561c6b5bf895397c379f1f8f69b1317006df6e43867685f10c893923fde620d488cbe394360179fbd2fd09d2c0dc79b7ae28bfe6f018ddf087fa8268fc29fa3e6dba6683d4044e2fd4308a025843c8376e4a35d9df2878077765eace69c6f1f0b24a569ab735080eae4a06aa8635f73fb036856dcc2f2ee30e6eac0971df739b02d9def875dbdce99d87dcf369f16b91de38734d41b7ad798f0d3cd3ee0f6fada7e7579cc74b6fe748ecc08de777f5e120b5bc82016d9e6f13340274840439bc471c716f5a867e09a53dc04f3181c36b20467c8b73f34f8b3c454b395d099cedd57154d2a769853798461b723deadaae576687c00b8ff5eadf69a7b2e96c71ef4b75f3359599526ef621c54128c9a9b90094a9d7ab5b00b53cacc80a39366c320081095d86506ed602af17a23190af9bf5c88c16754e930b4d4003df75df16ca714cfd4bdc51fbcc4b3cef0397c8c3017c90332a58c2c40d44ada9df912c473a9d94415b3261404799679a047161d97217f3533d3f19a6cbf3757bd9a7a3a6faee30ab840feb5ef78931f81dd8b9a04830add92814edbc8d2af857f3c2a06c091a089d8bb2883274ddbc271c67091532b2975065b0aad43b20397786a80ef36eab061e29a4e653680af8663a952e25f78ab7c2ff05c35d50e97d3edc1624a59fe87bffa8697e986363d54882891e9590ebdf0ce886ca45645a6c1d4307b14a9c323c4a19956fbd623da7beed22b299a8f383105dcd729cd867fe5901c5b94d944d465de1355a8a1b38c9fd761782b79378ff792a36420c7375e116b101e92214a586ccaa7562c2a02bfda5f233b2c4fd0628061bcefeb7aadcf1e0a2e7aea34d45ee2c6e179f0532b9432b10ca56dd306dd52188aa16116c4fc2f54531098ac348124aee044858efa82781cafb2a60cbf8334aad8f46f5a3a0f99401df3502ac211d0fe0cc53163e2da5910f539c89c9cb0aa5b187621f21e95c53ea36957cd64fd8bec460bd6d932bbb43df7ba271a50ad9520b030bdce9b0274f67cce45def86c79aaa07865c9a463ee1bd09f8c5d907980cccc1d3283674aeb9a48b917e835186e5ea39ac007872e855fb7f1b6ea1b11b41a7ee1f7e15088e6675a85cc57cafa4607a432de8c2e36478238055e35edda1d08a0839e2dd5b838a51991f499cf661caec537c0acc5bc4974fb5fd178db46f5ea2839d31fe80a9cc0a135946cf84568e68cb008c826a40ede5508c18c9475a9be718740cbfb8acafdcf28805b0d705f5f5476a69eaa1faae62bbafbcb3586db81ad1e32e9432f83ca2f8b38485768a21b7107ada4e45754a4136a8d5900638aaccb73fb55565e0119ef548a44b8c04b98a4e20699ef9d1c922a649c988b5c4efb16e4b47b0fbf4fc881df7b17fcd732caccce223c4adc75854154c766b819edf2fb04b10360e545bf37c0e9cf44465f5a3759c6db3b3c657bcacdca570d1232a187f6735a9ffc04f96d780ea9dea9c05a281e71bba9ce6abe9888d46c56ef31c7c61e259ceb1d35df788b0688babe6aba92b899a141d73b5e6865f986a6807115a180f76c010119566e04b5cdeb0988a7c15a5f622b320fe58ecde61f38d13ff8561c9b4932cf095066503601f3129036104aa533f5d3b53190adffb16aef6d7995339c39d588d6ce594b89db6631e092d5b544deb1f1c87c0880eef0331d3aa8d0438cb65ba782e9da8e50da5f63e82b797c376dc88f4e73e0b632990062a205964a636ba1f7df9cb2ad5a7d23151408270d55748c3678c27455e59a380422881e47a4e685c4c6cee99933f9bbafadb69b9ee36d17a6a20322eb6dde43cf540737714fa26558ee4483fe73d58ae74a20e02b8953726179358237e605b3ea50701086247e4c978636b85d627f99a0f73ee44dce59f5886989ea6741bd5428b93771ae15113a4c4deeea20053c29965df5d42a701b28d64654196365c722b5d6f32ef0634779d19d896bd827d6f54150c2aa817179a6f74026f61a490daf05ed6f309b4fbb7ad73d7bdc50f9548e167e64449ce08dd623f92054053ba92ce9cc8f1cde5fe410781b240f8cff0d089df8440372de148ef956afb717b8e700a3051cf3b82307d3db87f419669a4b08f00644ba2d63c4de0ef85051b968c6e6eff9f2668c4fe5bca0b7247cb7435d2951edb512856e956bcc6a29d9a65ba5a0a08c8fa9515d45a82e942419891a3d85b39a4ca76d1f24b93b601b8399f50db37e8540999b6b937ce7694fddd28ad708b14595bc12f9ee82daa0b14fe9de1c0d777186d790d9c715f8e9bd7ce9485897084e2c993330240e9e4a83e8566be9dde31077d96f951d1caa0f81db7d34da2416872121bc36e2ee7f86b56436cac43e702684f97bee6243af35e223d2120199ee9246e9b1cb1ab4beb8d13e8536c0f61de2e8a727a2edbb7f0211c0cf62e7fb7154f17431a6628df17addc513d7a79492c826f9ae093ae879378827de59404f3d574838f1633c97b6597135ffbd0217f1c2ee145b17d1cb66eb5c4e2f59951d16a4385470acf3bb28485b77f9e93c5fff7acaf75f7f3a7061f701a615f538f165d85199cdc1eaf91789febed11f66a0ce7c2291e9f04e986c24261ad3b76750b78c43f800c4b264647393d4b1c4bb6b730e3c7c3ef5e879e7869cf1c4b202fa46b7dbc8f108e2074dde90e7d7897a079ddfc3ae9820735d911536c188d79c76b265dc5513f240ef4a5c323a94b1c3852a46344e9e6d09e17aa699666c0515681e40ad11370bf01a0ce371a69e3e5735c979adb2c7d418a0d37c76e9871314ad14620a8b4959f376189da65827a794db64bf49bc98af2877e75d60b49d0f1ee00d2415896f2676f551eeead939921ae4e6ebf7c124fb4fa9814bf929133e2c8aa327336e8539629f8215fb8f5f22ad8f130d8b819f62d1c41411a5982729cde10aa0ca42f765562551cf16bd0f4b7b7b98055a197a6d79a4b6f2efe4614a27c867427944e7f2a9e00688f5fcaa26d03ba845de51462093916e594ece662e1a4c700d3f8579adf3acdb95e7a95fc1409d5d331a2d6af02448c9ef019b1196b84d428fedcb13e28ac30364ea09a652def9066d40566e82592","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
