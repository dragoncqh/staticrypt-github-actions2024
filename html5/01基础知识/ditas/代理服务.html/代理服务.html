<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"173e2ed292c2c2cccd064fdf5173adb3e60bcde3ab8e3391866bc87b78f143a50098d680aedfa9b3cb3b0ffb5bf8bb35bfc36e13c6d412be7037bd2c1407adf87baeaacfba6d2a5a7313a8db0836b911204859f4783213445a48003e3ae09338c674c31dd6d5114481c15c559fe0d1e40b3b3d55c161e11d0ce64d4058160f4f59ce2a3403113ad60bc3f49ba0eb45b7b78abf03978fee6a7dad18ea19c5602a07d3070e2f14926d8e22c9fe14690aa96b10681b4ec711f747502984c5148293427db087a3cd1f23e276c5dca48288898fe3bfc97be26fd88defa4d720ba55dabad8771e82b33d918a46289abebdfc228eb1694d6a47ec9692f9269e674826c820cd290bed3f8eb997d7c440092585e226c92290282544bbc420dae57e1847072a55d755d8c4651a415e97d20dfba5a8113c55b1d50a87064cd91781771fc52f400837999116a840fd434a1bae5fae0b2b96bc92d86d370da42d00ced49964d956a6959bf26c53d16ef36ce3bae2c4c548e751a80d31f754746c20935787f7c94d3e951c51355e0e6906fafbfd0634f16550b8106833df9f5259b94bcd1c9734c7bf2eb55441c16c7b214bfc9ade59baf1277d7e9118a00fdaaf7a7437c063fa8b31971809aef96dd51233df72402a72c053df8148eca4fed568a6047575154db2a9ca5ace8ea2f7f75fcaa6906b264e5c512ac97a1fc4d7d77884a0ec43a0aa86d3ead84ecb480c6c129b4eaef615d1b0f9dceece01602ae136cb831494f993e12f28b0358a1eae1acba25ada6fb060cd7486370b9a5cdf606e1cea3ef774d46f62cf97808d5f8d1cb8cb0c299b9c63adb9a8ace35ef5800589f9a6b3d8abca3380337a647494a527c13f010f232a955908f61a32243ad4892e46526c98dd78e371c85cf9b5bf28ea091dced964e3b184fd502d6cfc03672ff7c7e2915c55afb7f21efbeeee93008912194124dbd750aca40cab1eba6fd629ee6a6394238400c464b9530c6522ee4a732a2eef05c0077344a7365c63fa0331624001c33f943ff6758dfdf46738dfee462c11082528bd52ab759ccda06158b3df1edc669c5f5380258ffd6a8a493c38b473eb44d6f0c933be44af4beb5d2fac690bd09d10e305f63c3bf3707ce8dee200bb059be35bd059a6abb34da965c07d04a9133033515fee5c906884fc673171009b63f97ec7915052fdaf17742367a619839642a9f1d2c6f529ea369550e43d0bd5d1bcedcd9c4d8ac6c29b5b185fef1a05eb44cbdc6425f2c8144d7cf3fd73dca3ae8589a50829708a5053f6b5ab3d9d440f8c41bf46a6b63b6780c6dfed96a573f97917636617cd14c0921625e6838c351f4ad1e8d37eec241c22e458b4661c50c66b76b220dd5731a2ce1ab36a9abd1731fae8d608fb83e826d4f236bc363dbc355066d6357e28c9ce47a918bad7972b65cae4ae5c803ebb479ed17de36a4bd21dc1b00b0f920c0baae24d5a0aeebd8b873bd021797178f0e2fb4973e8088f5170a3a802df7a3d47fe585b6d9547060aff7d7d68abaa94b24bd496ef226bf5d40e5e57c79fd2c61928c03b832a0b79b72fd91e12da6b85bfa07326be672825343eb3b5f306ab4d3b769959b5840d5ab45790aef2932c3654eaceaf48ca389e796268b943b986db716645eda27bd5dd510494f1653da5de75ae92fd41a7200d5c5354766ea3e3723d4a52b3ec9efbf3ae4b6a40eec8bd69ecd7b72b9d30c9353e001e27e4d506849141da513115e6f23d96545f5557fdb9c790f0ea44e1483bf50f23e48ae29b0d2e9955362f0e97d3d058ec095092d93d61c1b460c7426bc6d25d7958b9b22f33d2a84983c565b0688aea4b9f869ec59e37c48d2b50956e0e2d3cf855eef1504090b7a469aac8a694c023be3678c7c4c620fb21233ed97a03749cdef221dacb2de46fb0431e26d0865b9f0c0c5bbca8c1e73bc3a200e0c19742f89ad6c20716f10567c7176406500b98232efaf5a0dcde0b2ee28eda03e9afca8f498276d03a4232291cae1980ff1c87bbb3fae54d7cef083b7d3df56a031632f8934a2339297860e40327522794e787ce48fb50e2a77e53dd12a98387de267fc1a5427cdf1e01491d9e9390c9fc600a4de55bf151c2697470ecb060ecfb96db11608f699108a81dc8a8ce89a69c610d6d660e8296560ed740da9bd269708ba76b343811facdfa94f17dfb06c00b73df72e5c62b27d29f673886e28dd50f8c9dc45153c23ba579b0dffe0adabb7e8c09bfc52b6f29e47adfafa56c9e221dcabaddcfdf513c788981f887c6b7995f703523c089220c45ee21327f51bafc41df98e0c2d7b625979d7bbe5434e32c6375140766504d884b463ebae32dc24c1c8dc96fe5c81af86f29c7d11e0389ad20a0ea3cd568314cb595e71163db5e733c8c4920b1d71700be505964eac75d162331fc4f9dda96137684d53475608f73d7e31e97a43379c12c7c7f7aee93cc2bdcae33f511958c60aae0eb65c0ead3bcffe59672707f26619b34284a6a1f1f7cf00383dc819bf625fe8a7f51bec62cdcbc9725ee38a3e5e2702ea53602bbf3b0043b8d14ae4df5c101b91e651089ac3d7163a23854253c4356fb979d7a0b6ce5aaefc9dab5e05a2ea4cefe4d59c73e1314cdfdc350005648fb4898936f1159c260acd2e84275933c0cb11503d955e32e8259c745d5c4d25ee02ce8b4c8b97248a015ed082edb9e34e4767516b918e83273202644782c5156551290efa6d579e79dbe8a6450138ce566923dca709d95d4041c2ff8ad0795a5c93d647e80a05baccba4e5e9a54bbcb24a649df245804cec70b555ecd62926b0f0b79e539212c8ffc4a620f08a36b214ac9a7531e30a82f6f8aab19935861fc53d1b89e4fc96cd009f10cafe834d260aa11b5ade72b104682c5278dc1e0a5b9dccd61bf103724f3252e05529ebfd0ef8071f4175166a0092e6ac433e0fb9636e35978f1db4bb1a0e53af987cd22532e6be121ee79e07c0906537dccc8c16732d5a57143a9f1d2f561094163d674129c25bfea19c2bdf48e4bb250548d77bf4bfc9a22f015e2037972f4ddfca791054337b6e1836308d45095231f3be4995213786860e8b7e63666020c957fee53b57521ac2d9b3980b860937f4e8ec67707e3eb00965563c2b917236cb345e07bd689eddacd6bd917087ce1db2bee82834d5cc525c0510dc0e692171dc67c868a51e02b8b130fa6e9a16efecda6d472d6580aaf0f1819a08c2c9f2679b3845472898e378a00dededce3ad9b86cc9d34e76795281fd7f889db9650952812b26d0a7105138c4e2c8bbada297f5bcd74b686fb38c3d3d65da95c15a518cb8b06b8933cce01aba79b8ae04a333f1dfd0acb68e1f03dba46d8db0aff6c2da9e515c4f414b7c7daf977638530930f951a33e5988a0215b42a14a02b1db246793161375578306454b3db5f1b521e89313f4911a3ed2d4d8ee8e8c52f45bf8d1db65f5932feca82e3a6d9dbd6f6938d8ff1fafae87e793f8126f8de1460ecf2ead0ddd00f3a430d03ba568bb1c8cb01b7737148e1c52678ec81e840127a5647e7212f2c50c6de541c7e448aa800f9d9668cfe86f619b00bb2e1b633cdb473834e33e9eae118095ea9dd40697882bb871cab5cfbe853d20cbd8509581864bf53875cb87bc32263f16160b00a02d3af4b3ad3c8edb84b86a2a52eb4ea4a3334de65deca2e6365300dbe16e28eed0fcb61b74e48fe1bd93391e43d727f3df38180ccbf4fe0d6d888686c961cad234dafe3dc9a29d323647ab362ac38be3aca35b3cca156da5d8247c62923c046fdac7c4dd431e0331d3de523883e5522fbd09a1fe18c65f03c50cd42b56cf01b1ce7d0d46ae3a20ab6c8b3dc7fe241b64f7c20c244545cfbd31070b5b32443ea7ff7e91254dc0802157ebb968b076b3c49f7f8582084cf99644da56bf040a8ca4af91052cb4c4a4268fca8c1bbdc2866418304b87c16b5cee58a1b58dc70d0686ed51e0cc1518d2b83ad55dbdfbc22b8f6865d7d5fa3f55c853c3c7389d9354a5aeaa755651d7176bd364ee5f7f3b60cb7ba688b59cd6fc31c8c75acab810b63631bc1182dac1ec7c04a8b7d68abb181604b94cf150279d975315045c5f8f38011eab280c561a7aac26d8816eba1eb50738349758f49c6cd8a6d49be6e09f0bd3d939e9ef0594d911e48ef1d40302f6bd3a310d15153edb5d934e3c56385f1413f4f22d547450ad1e6e7aa74de88e376ff57722dd9a1948922effb96a5220d344b9b47021c794c4e1ee7042819b76d1b794ec217dcb09bc4c0f1d2ad308d1fa859f95d00736ca9482a672ecfa313372b464955f343d353fc9c7f0bf09b208e222439dd27ef9bca34cbaabdf24c2341aa0693b3eff1e8286632b9281bdb01a8c94bd078cba6286259d0365f0a1946bb491e237f4e9f756cf4d63ecaac1b5b08d381fb334024b3377063638a8e35caa4c5cd5bca258bd1d3ad9db53ba093047255b0e5af5a28791e333978eb42b7faab7b5452ccbad08e73772537e88e16cf458dc91163d42626753c889e41657c8f6f787cdae7126ed8f73e547cff896aba654bf1cc9e8c1a130e8bb8d97340b6a3e9d9e81a2c6ddb0dda79349c4d36716119f5620c9839297bef4cfff73c0941228a10c5d47fa980e876c925daf4c2b29411c628d6d0fbafde5cacb6f1d2d822f9653f1fefc6df2907b6af5a0815007cbf23ff583e47b1354e4bc022307a029d43c588f881e510fe810d020e53369b28eb4845993bfc08e45dc13bb76ad70f8172584276aab9a3011a0d34413bcdbdf5d4116bb640c198fcb2ea732b6ab19be0c238e421c6b425514bd97e8666c8fade6a359fd1554406b69705bb6f160c832cddb4d729e7f55a4ff29d156d81bf8d7022db3d9c9ffd33eb6b8badda0c78eda7b524feed7cbc9ae589eefb4f525292deb9ae00c42c8b8645f6a6d7deeb0e5805bb45e719d07497fc21fede33a53978c4a634712b76faaef3917b68f7852cfce31e0ec163263f000dbea1fef11382eb2e61f2ab8569c3f599713911924c81f635732ca1ae67f4c9d0f593955f3c60c0f41361f827f6c0dc440d6e4c8be1429985a6e196488cfa59d429e5252a86a9fe6d2b78189c053da92393921ef6d477cb852ca3745aa811b1d1152529af2ef58057951c7b2395173d3bf9f78bad3713ae1fc55dd5de6ec6f92949d79a5620b410f2edeec5b500b64c2a92c13922ff35fb857a39f36c17f7426c2714dc93a8f570bc7fa793cc5f0bac7603b460c8d8acd5e2f0b386cb6539e6c8475711ad4b001000b8eefb186f701b4c514fdf46358c28f8585d9f6e158078bf204b8ec75ccff4f16635c3aa1e713ebe47307eafcbe8c20ef616c4b0fb39c0c53e6d4dd47e1a993ec4ea0d7c80b26b8aab8db53aeda669b7724d3e082768c8e6dc9041571dca13d86d3892182f93f562344aa66d34b2a5b8a038796151bfd4ac818d2d94008e84b61b5d3796a428dc9c77ab84c3e0a567d7208de640bb661733870db02a5bf6859ce16b87fe527d7066cafe1be13a9317468a53e0b48190e1ebf3a22dae9a67ceb2ed2896394538d612425116f4159dbffae42cbb91d2cb9a3a5d275f2926f72ef0fa171b03c55a916e0664509a43ab45cc5545d9b98453913f9045094cb4fc81cc9e448391373d65fa9b880bcf6b56e6f3ac68430a2a8068cb6dc9a5b23f2731ad3e3bb3b1a4e489a5b901bcb04a620a2ce468872eaf2bfe05510f9e9cb7b37ce89140b8463ef24209dd91e19aa316fa8cdebaa391a922dcd9f8e30c4ba942a4ea5f5d817d88861172e62c024b3ca0a3245662f596d7bc2bf8f3c6898586fb3a609646d65b2622ab6208edb035162c5b24d48c7d1dca503e690f8031039ba0a29fed44fdf440ecb670c48b366fb3bed382c6cc4d4281ba1fc1c6f4a63472cfe487818aa35c133e0d1ba7684bf5ac754dc263dd4d2b66a8f7a6ab598d9510105d6118d4596b6da8817e09269fd90a1972f90abb0bdfa4fefd105171f3ecbf29d0dd0d0c5b23ab4f529ec19a4b20851dd5498dc9eb3f09ab2a92591576e0f09386c8aafe58bba8876132bda6c13cb01593ac1b00f2da89d39ac9972923d7ac4d13dc5ee8a83ab92feab886c784e8f6997b851e4da2e3109520ca42d99c7f156c07512a3020261334e417407693313c7e0b9b5a8f356e7b42c12a66661dc5777994001ad14a286d3b42e50e1f1c18bb3b9110eaf0d13c1804502885df3d07f8e3f24d9c4d6ec330c792e492142d6809a5eeecebc22a47390639ec700553102e39b38bcbf1ca31ead0b878349c25ab0f0499e491a4151d19fdf6a03e7f191c8c81236e51d2fd1baf4ff8bbf3e2ca10fe0792a0cf0352237b2a0608081e574758f8c860ebdbd037a41fc89402564a275ddeaeecd16e7d3fc7b335c3b8310a87e29488837bb1a0d593316ec4b95a05b67302a3da54dc74ed6e5fd9ef1d3693d2406757f2179ffb68dba995be86dffe807f4b0b06972288be7d14d39b409ba74970c1620ecfe389fc1b6e5ac29652d6654680ba07cf3d7d269a5199a4ab1fff73882ae53dd311bb87f40297d694e153713ad39c175eb4f5ec3e2f3e3874d2ef0779417c932f1285ab9d8f156beb2330b156da9e5d33ef85b9a5bec4b6a2a88d9fbdffef55008d41a5c1443589fd5285340aaf9406507444f781f3a978af9f6c5af788335831487f7e3dc277fa96c89097cbe3d6be13f921a03280e9ea5ec81df21ca7abc2c313c3672233749c2eb45b6171e5a037e7ced501019140770eac880e70e6b8202e8d5b92636bfc6e50d012df3dae5ab1e60f186e9bfff848dc81ef5519ec7b672d58bbd749ec6645d8a5c4abf10198ff0265473345cbc70d93714270361d90a27606147333684e16922d6c96c26a5213a3c6ac3eb27fe41e11d95377edb007291818bdc4799f0b77a1f9652096bef9613af2ba19755714ef349037fbe7e0bfb9c19a9d778d83a4e84213134547c96a5fd0808cb3e4580fee15fb0b34d9f143470ba9e49b1ccc7fbc4305ec92455f120dd8afce649bd21dfb92ac8ae1ad419d1985a1e5c8aae0e07985d2f7995b9ac732e6ef28739492125bbe9ddc4d81b2f2b89cb837b93656bc0c1f898df65cda86b7d80e2c28053b146405d427dd8e369b8dbbc577ced9a8aabafd90b09bec1a0a7e7bedf980019aa5a4ec7dc43a3dd228324a09f47edf7700574abedda7434c016d5c6fdb8b4536780a749773ccfd7be6c5c8d425ae6980d0525f4d263b5b6a92becfb193f72c751091214dc00b74d1ff44fd349400a55dbfe6bfd6095112d18144c40cb1e88cd2f06f089c5c19fb67522bebb2228009118575b551e1f3f1fb9858288810ea51c6abb4685115b1e3c7518bca22063fc3b9016254f23358e2d48d457a87ee9b4f33ced062a0fd3120974f6e8f1e84f46373f11c860aac518c2bc8bcc2e27b55938f118334d223847b5c7a610a95db670995d0988e7231fdaf72ae050fddf774436b656ed545ef64669611a2aa4ee2856745c3aa78daaa0a2819ec015bf9762b15355d144a60f1741ab438030465fde32384a40b1e62dec88890fdac76f963cc4f9a99c56c1a98051dd0bb5704fb048a7b563c5c699afb2982a752b48c3f87ce7b17f729ee175b9bb373197a60a37b9ba195584c3cb26fd82482f49442e3a4c798a586ba8d16960d5cc55997f97021aa1c17e04e968b768e39ea31adf1620b55dfc93c99ebefa572bef1d8c7e24262773d087c93ef5fe51d27f48d4ae53bf86b18e6f8ea5ea8b51fa6c9cb53e5d6cdbf643470abc76cf48aa2435613a4de9a70ee0b23736fe9a7e5b1b282149411f5561ea6f7e674417540e4ecbb58f3ff0a09798eaba5f6b306eeb6fd45c7a79f95c397022dbba80c0242e6aa9c5e6c3e4fdf6b4f1e379ad78c9b8a42c492ae15c9941365f1c9c017af1103484fe32f3376bc9b6d7ab9f8bf2c0be323c108445df2d8c2464b4074f936fcab1c55e7d37f4bc507e097fd4c850aa3c1da8c4857d308750d6dc85b1a6694001b0f5509574c6e932ff72eb703cee7fe795537685d6d79f9eb43cec4d79cf80848c9841525f6c1d7c653c7f46ffb663f4431196a3a483aac972c015b379d8fe66e623637c97374e7a25bb998dc6ad4150c0389aa4462f86f63c2790a9d45961e734bc97456616d3c7a3787d7e974b35596b10a4724a669af39af1b82e1c3d166a5098173d53d60e470cc47252601771f36ea94776843c4adfb0f2b009cbd746bcf6caba806453ab04ff09215c0dcec5dced2c43f606a581a08a62c02cffa13d8a2f5d189eb8b5ece0c4f216ad8a41d7ad8a9dde3887657040b2f180bb37171e0dc8e138afb5d9f6792b54e5033bd5ab090d54e60937c80d0e7c9d975c5f5d4dca15778b8f03815862ec116eebf14f93ab5a6839cd41adc825127035dc8f5ff73dde3d1041144b617c80c6391e019f36457e54548aa6f6da5f1c753d4c013c8251b61cce8639ce3b780d647d791d218cd5ce9be6547f0ae03f96fd4cc0ed4a80847f583837e96c39a8a574609f8ba5cee8fa8c71f796231cebea9c0ca127b5ecf809804a8255e0b7835a4bb4531d147be23dfaebf8aa98337ff83d4f004884d016518c8fb394c52af5d8ccb0fbdf853f75f60907a66f17f361e9a1ab18e55203d53d8feb2e03229f37e70b4c5b5202feb4297fd5d6693f87611c283752d8745fb125f57d0aa4ba595e8c8008914374e9a103aa6042ebf144caff9466cafad43aa4a06e89c145b5a59979c37c1e406d450b827f628de0deb40e07e1332239867a4f9cadaaca2ee8e11305f5e882a7cbe7a97f6320bd89a7bc7bc6a1296c959ea65e159da55f7e71702444929dd7f6ca894e7d5988fb95e9572cc1bdb95f305413fff1a8626f4b73862b2488503ac12cbe7b443fc9e6f7d802c490532f2cd6790034ecddd76e4174b884da961d85794d7051fe1b91293cdd86377e5b2834501b77b27b6067c0f897138da88330adb378218dfe636c97a29818ed8adfe851b474bb1e7b76b3f1c937c6495c6fe13659567fd11e98c3032a4b78aecae573b6fd81d88c020b4a5cb23717dce81802ea9db9b66e69a9e487e86a7bbff74d9407cccdab58737a4f0a5404904882dc8f4fab64627c767aa5385b8b89c17f30bf8dd428852c232f44baf1cd610b387d9c177be530d9138998d16d75bc818dc270b70bb9c02efcfbae7b08cfbbe619420962d2409b2a50221fd2e6b64e1e7bd5674b4533bde572db83c07de08d5e9b83d0238e980523481cb329280fcb9c7b31e72a5ee24f7bba2ae5258bd6832e60509f8b8fc1b97b296f7d5d7a08ebd38420b3012bc91963a20f09493ae61edefeac5159fee6a206794a420b66dee0cbc5e9d71bc10448660af25547b5d6b48cea51945142d58118e6706d249e28a71405bbce3f8c38b44cca11e62ca0be9a66e54445bead0a3a6798ee07aa9e8c69bf05bde13a0ec408e2e026aa313b0f463194af50d4c92e8c9c3f7b127d75ff3655e8b757f140d05e9cb114666407a0e2dd196e472c50728f04d6d547a3a7b20bdd49bc91405633d5f7bb9ce32e0ef6fc5eb67047c6fe9478bee28addbeeb4b5448f6d1134bcd4bc49d4fb1625554ab6fc05226755f9cc35d1ab1bf4bfe852192d1340aa9e59308f74c57aad7d5d967635de5541444459e957bfa5ed7a9372fc9e2fd0a78b0a837b0c2e79559dce0b3645b41a8f1405933874f87b3747a2efd9b2a39f81661e99076b0baed59635adaf49c397f1a941c32a0d251ba0bdb1422b9eaad315a8f1e6a937d3612b824c3bbdab66a4a7b3418681938952fdbc4c6eb7c2a62a5950077c9b778ebf1add2c17ed78b9ac8458448f275c69c55d702203034086874c9664c27a0c01d7a6bfe1098968eaf582fb30d08b7fb1fda5c9e80428cc18c1c71e3bae83121563cc33d37fd62d0939a215bff62f9e107e2ae6d588fe82857e436dfe3251ea8fbfe0c4c41cfba29cd032980b280b188c64e3a511aca648c18dd449299686c8c5253fcef11d2297d77ab03ded47ce71e7df89c5131f0f32e8294f1d8f27cd1be4b5ca2eed9cf6199c089c25813d346101bde73f6a9e61321873ebbd7517fa871989a24ed2166d5d24d3fae464103b9d9d0fca9b2ef8adcf9b5648f25bc453a4891a362d833b8b2e0554ed420d08e8d1783ab882b69e039afa118d26d88b77a7139eec93648037348edf432d9ff9ee16892709b9c072d3d6ec5cd9191886b58face930d1785896e38216eb3ae2c5cb8b2fdcd8b85ee447e33a8d0598b1dd4dcb5534dadfbe8050ab42c633d37c4fdd732b05f77771772ceaf4450d35c8c73284d4ceda7280cc360ec0c64e056cb8c32e72ea928af928e89a0c8e4ebaa8c4fb69990ddc9a68badeec6a41a8f5b812732d2e0393fc457055de05b2fcc645003fb51820e8eaabc5bdd406a64fbad557b0617ff97094ad95f2c09693d606f3d2fa74dbdc0c67c5b0df8435d2856751c60f85db68159a9095e534ae340ce57a0629f5096c470624874300673816b94a5d66146ea178b2d9bc312bd959889f9b31bc7937307bdc7ff60d0f2d5d70d8172807389c0e9fa6e8120f12db742f1eda30c4262f1fb2b6062fb366f2c7cf0a6c893835c49ded58b8f28c8a57cc77af8e863f2377c3c1dad24f4f434cb3cbc64d432bcec6a0ded344dde59ac51089d900b780c638295227ec01f6a3bfa1addac61ef816967e27dc37049c401a0327680cf15a28d2d7e5914074a286c745db7b0ab7f1b22003a6ab7ad200f4ee201e568a5ca1e28a16a3858953bf30530e0d30133bf9f60502c1dcfd22f1b3b22c0f6043c1c604cb85470146f261f508b6b28f3c35c214b30fa5f6996affb9fe920737f9142ad3f927cd0d8895d06de7bf7c1801e1d12aaeeca056d01f99574e9baf319de92893d50178f4ee5d63855dfe4ddca002d51c56dd2a7de4e837b9a342ba1115840c3df0d4e0df1f2e26c13fb907ed8173088d450586f9c8f4d7abadab72528a77c2bae48121c131f6c193db7f5a0f2c1212310467248b5a162f40b7954c9507f9ae8c8b0ca5ac8280f8f40856c12c1d087c67ad9afb2bd478552972d9da90e2df1eada94933d849356912c55131230eab08e9f487f2f3c062e896486f0d3a7330de1987f3ca5d041d47e9be8ffe545e22b0d5fc28177a233b2a7c425f32065066275c741ff7c21e06cbb61537b484f0a5bedb3426039a99425687c0edf1c8206baa2eefad46d29afa6aef0ccb6325f9e54690b9cf4608a598eb704f04663679cf51b0e9c409fca24027f7fa0519707b1be4f0dea40aaa5a017b9ab887df0ab392a56b1b54dc75a8e7cb4716a745c9391dcded09999300de9aff93a11ec9c02e9b48131535732fac4af309acefe2716fbff0059c4046511b62285dcc0e9316824404a770aa3e284c31ec439c8e1c01eaabbe70ea317598097edef539a1209d4eccee1e6cd2d6f1c7c9a71e6aa91b9b739f6ab48ec99e3df6fdd9cfcd6658e6de5450e7aae42e5800b1828e115cd497f5ca2ceaeb7f440057de1dad1f4c93a25c5d1319b64bef525722bda2b1f1a838e9dd2fb49036c126c243f07f290826097c2535fabf84b94b0df3615b01057473374ed6924bda3302f9f3331d311fa55a359d83ecbc25293e5c20abd9e92cfb245848a5d67aa91dedb34c0535795ba009b9a19190dd77f01bfc6e8dc3b72ae2a50877c8ad975d8c9f92858700447c043998f1f283a7238a1cbdc521f073e831a6c91641a417409d1b860bc8cb52107654cf0269db1ac856ce6a276aa10a9a39de6a575f876d8f4ed0827d555c70634bbae975681ee1fd2f52caf9060fe56e5b85753671f0dc1750e53c8eefef8cd1d786fbf0cbc4d5b03f09eeabb75787d07bb3fc30f9ef866c33b3d61a05eb4f4dec54a6acc61421f7597d1e074560a2976bbb903b78938db82b13f48139457317c0cfac1290f809b0fec1a67372e660c17c4745812328990b6f3dde3342e81c543a1c1a687b81f0d6ad17d3fd2737ebb93cbc9eae50fe48f4b056dc4c6b21c05408ff11f84af34eb225c6cc905477c2ac09104af75e9ea944f8b6d2a75d518d4e4fb63025c5fe38ef26535840452bf8d38a1cc3963dfd8c31d354b8092a121d5c7883185443768a6413d4a67c9363cedcd6789d4e707448e2447b8229b3d0d6e42720199498715bc2252968f5e5fa739126ca078c82ad03779309455617d3f4a126c2a362aaf39f60041d61a8b8db283b9bab451a8c35124f264eba1230d8bc76120c071b24df594bb887c2294921e584427636e38948afb980e59f69240259d377ca6d5e811d86df350497f6c841ba8b9df923a8335ab50285c96816b72b1b609b46a0eaa13fe58798c0c24f23064bc021f3cbcb49e7a89862dc7f85946ff3ddaa5f744c2ebd6c57b8077f6a0d846687119cc1c91c5643251d216b9694af82bb800aa13f8ded59d47dcdcf71c351ad2ca2d6d8b40b23ee53384924d308ef339aea6c285f19a234970084c8b40c33f19bc252460ea221e8a8b3383ab0f7c41f617574cd5a1957a92b0ee575d5773992f5a9388cfb809a23b264fb1f98a50abdbc8151da09bffbc4d24ae7a83a454d695b3e1a1b5c959d9b9d1f0a0c0b709164a6788e53a2d3340f37f28a36d82e80caf56fb116fde95515df54bce78d30af0137c76361284b3b7e52cc19b60506cd8ed3e9402065779bdca9b17a8483ae78ee5d9405a21ab4ac479d8c87bafebc902b31051222f5b2aedeb0fb8ff87082d6c1065659951185b4ac4a40c03290e92c1d677a79f8ba87a50d277bea81ba4c2d499b04f214dae4781994a16b63194dfb8637ca685bab20c1296e1c2ec33bb890e4e18eef1e31c1569d811faf9fee488e2d0ab2f05ab346177c1a1cb6b6c4393945b679fee27de4499dff13a7d8992f94d1e9721ec0f92535beb5e7cfd5870a2c5feb3a2d4ba3142fc09526e1fc63a2f6fedafc241bf5d3e0e11f0ea27f264a00649ee0f804c908b1ff1d7fbd1b0d9eec34b7e9d394ede54e02232cc6b9cba86e4ea2828a78e359009c005d2a353bcf2d07168302ee5e3f5864c17835d87c467a7c120590f4ed0dd3fdedfdbb90a8028451f67c6bad8c37fc94b8b605d5072f11d6f1f190fe8c522a6db85a2818c2c84aa2111c02c3fc0fc13066d4b17b9e2ab8899e7b8de177b045c2413429a6a41ac83450552ad4e37a9bedd9c0973c54ee8b223c28d6cb888f72f8054592eb40500069876f4845acdeaf3d0df56ae5141a35fac1f65ae69b960dae46bf045e0eebba8d30efdbb71964e2a7f63b2d9eb1e78f694dd45ca06417eab00258bdba06f7ce450b0900660244798833f8968d028178fe55912af80faa49f85504fb3b528efcdd34c2adc4f22b7f40a8b1197ffc7922443b1a6a13611eb821cbe0361d13185e16d48447bb00d88624a2d69d47a35918f4f2bfc043980ec610860a0b4ad0ba9e35a2519280b8b8a8c21abbc49991be8a39717a9aebdf769a5af36040d783eb76c94cbbb35ead32d12ab577dacc1934835bdcc02ed5787fe5ca37f813fea1f42c5b5bdc0567b9f6de8aa5bc9b3ba2b1004be4c6dc86e4cd3bc69be93b4c84e05b520cd98442a4c2e9f4028d2b514a73cd624f47d8598544eef363ca53b7895816885c27701c51f10700a6f2eac59972bd4dd037937fa8dec7de0ba3abfb52c6e1a8508f7d38fd6f00064ba54b9acf746047e277db5a1e721b1aacd0676855a15331ba828187c995621797b64a6f9ccdb5473d55145c670d42defd85dd1ade1d70af3888845c877255c699cb246388e25809a15025b66878ddd4da44df846f5d26306142ad6f6f00212540bf3103a87d169c5c2905c8d150aa704873c8287595a0f751a3c0cd1021bcda9f3b3da10abcc2235471add3d1ca599578cbfb5050c19bfc0f4ab0385a11c273385b7ba7e3515ebb0cc056e974e46c21946be9350dd93ce3966118cb0fe4bf78e9650086a7d8ade801174bed4b1b77b5d8884cf4c058bae54193ca0ff1847747154b2c2148908b5b582fc74b273d2df6856061c35fc9cb7ef0c4b09f5551b98dddf598f6c9fc077e6de7bbc6992e4cf55fc379a23ddcf07618db06291d1ac4e847410d5fe61bf35fa26903ef4a9db6e96093739802f8d6d761882b9a61e09b532dfc3deea1f55eb027acd45542e865e3eba5058b63a612feb51bba32c68382c67fd6c913a0a894e421ff108602d66067da459bf5e2ea608e700270cc16910537282d4f81634aff4ad11757222e84970a7db4fb88d61a76114a563a343d45c8985ad7dbf3de3656634504d14eb756e4f5facde2049df567795833e7f868ad1b2cece6886ea76835db5010439959b568c588eafd23dff69d6e24a71fc33f6d8bf55c72a486d261e59f7690e15866503c4a42a96f6693e735362fb1ba3f1563a5920ac4a9a3f1788b21f1f6b9aff2078d5811dd903cb8c62f56283ab8b299604105565969621ed665b5ada851e0fb2637ad8fd132e233079fc298e039d9c28193cfd361ba370b49bd3b4ac09defecb31e46c6bc2295d7aaaee6b5f02de02456a3d4356f9f9769157c74d97cdc18dd6b14b40dc27d17fd6f53aa39a93fc7418570df5cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
