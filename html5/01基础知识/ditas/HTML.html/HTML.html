<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"800349ec4a1e3db5225bcfae98f57c01fa13b20aeae2b87af346c2ca4fab94133e1672cf1f180c57e936e15862181a4d7c3cbcc97562014bed974352885db120eb2c7cef9fb0e831dc2123d90580ede376ae7467f9585270e63dbe61b5166c0edd2e5d06d50280ef97ad20e0af5e0e6679371b73223b1350754dae6209b8e9975eb336e353b98166648a85f6a2ccca4bcddb542a104a107443dc7e9b9654f96b0586455814b6950230119f37429806c5e1896043b35a611c9504ad1a0f5d1f2d146a37d11378931dc7d1b157b06917f15223171d2c65d1c705cee530a2d44a1fe761d7ddeac532213a5dd9fed4a0535b9f8ca92cc79bfb81ba203a4601ccf99f78fc08c438752cdbe297742765d0e7af60d2e54a5b56df73a2f6973ee0ea01967e1c45fd072f348e7a3525305acb217c980fb77d577036d934ee549623df3ae316e444784cb38f4ff87eebd372ad273cc67acb630894582c598b20eac0b764e5d3b620233c6ab9112e87dbe2bccf1a8ca5f757fedeafe3e10ca95059c06e93b502726b2e70f7aef9f4f88b047d9fa6fde10838b27addef122dece103514e26c34bcc0e76495f5a79a3f4d46d90e041460aa524e8bcb14a1bbc3ddc03757aae93e1560af49daa916db43f6b36e0b7852d394e0fd887a6a521a620fd310c202460c3e99870b5f42133dc2a4fd68da5292e3d3a84406d97e80611c8b3220187bf96d3ba34ae2dfc28d40bfacd3ba18b1596482ada1373b00095c1ca535a4ae0715fc925feef5e9d0e1ab1256267e233d1d6990564e68cba3c9461294acc54b98927e49662670debc36c661a2bfa5b2a20aec80f90231248a594ce00aa8626d097acd8fe12b0d949fa63bc99d503d30291280936d41364377c8f66eb4b53b095ea2b584bf1132534aed7f2aeedf1b9ede28d032d2b3319c1bdd2ddaf683195c5f100a4b6b4415c242477ff9da6fed6cd290b0a3745ed4466ef0574422ad51d2c22f3f000b0174589be992abd5ae515db3514ed5e6c24f286cbcd661ba05dbb7a53e2d2eca80aa12d8d33fbbc64aae0a4dc2b0f1d4db1751a81dceeb7080cdedcb53c1c38305ded0423a5404b2012cccfcf20ff713bf2c917d474c3165447b75316f62690d334d8a5ede75c6bc5784b4d84bc5489066791da4197fa65c095609230aed5ac0ee881327d4a9cb3b51cdab51fecbcd4738bfaedd183029c4ad0243ca3e09e3f3e79da91692f299fa71a48380c7866ef60db324f114324b25594419c11c197831ec9ff0064d76d6ee567ee7f25652a389f758c5df6a3e943f83d86d5972fc607f64dd59993faa662b0d63e0dcb99123ae28cb36cf55de7c07380590525977ce490e14726e57f950efd4e36e0dd18ebc4f29dfef6be134968e5e412e587096e199d78b6773bc03579e318d8ef529a466867c77e3597034ff0a75e6d978bca1cd9630e670f12279265fd30a929312da67f497683fc51f29e2b9843afc3553b85bdedc81b550f286c9572cc16adc62ecb809663e0a1300ce0076afaed612a161ce29f40a200af2ef124484d609205d7f09514c197f9d86de9dad65ea005a862b4c16b16ccd191a8e8a34e908b16a4e83564bbe3cb6d52730ee7bc55cad7c38e383ebdd22bbac8dd2b6e9befd803cf72ad87e17641c14f742463dc945664b9fb933c8c75c6644e6e2b6aafea409ba3c535a0c16459b7086def95fb01022de12d3f2c5df83b1915b6ad0bf9efe52455e027fc2951a0f2a3180b4ec518263377948d5f1dffaddb3afe789d0b779833845ed7c3921b06771fc49aa1547ea1f2f1b74ef31cd9b990878ff87f4c3da982db1b5fa0bf00999234a35090ec1310952c9c905755e4e1bf76060ae500d48874cacb81c88f3241212275e091287624bef9d83a94b9bc5351ceb6f69ef1ba5a5b2bb2b32c8bb2114db3c08c82d9f03e31a4248527dacd0f485da5c907d40b868fe1df92708d4317f494486cff912919798f3ed13a46301b3f9fb120d3b6371bf6658017e4142bd2b13accd2fec9ec09ef116dfc379d97a549e5ffa917518377cb690cb18368fac74e200050f623c02673094f7d72b8969ee9d19d5d87546a911ee4fc770475b8eca07edafb52eee31efd39b5fc3fd9def34878c58df8c0eeb326dae40fe5ef5f3dcbde8d1421513f6e20a4e80d10e1b7fd74ace213d10fb193cd3d216bc2adb7813bf85a61c019ccc65a1dfc0e1da1445af49382f5137929dbbcd12570364a4290426c08321512bcfd57e40b9004854894498f69929e95f4eee4f6490ceb1394363cb6e13cf3dd2704fd61c0f597003bc82d01a505650bb7ee25d2cbb337268f6d97fe4d5f3995daa50134c21b03cedb72a7b2f0d09184dbd1ac63776d01664cd189c14ba76e6db7329b81fdc74106bc194190d74540a936b605ac8e8d5ce75f78d961d9b5f84049b85d4cfe2ac3b0e18434c3b538d53f529d99f8273b44a1e4c6229b5f30670e19b097026dfb8b82ccb65b88d3e7b618f42c9ba6eb6b109ac10d18737ba0fbf8f0d2dbe92323bafa12b555197821a1a15aeda23d8ae8802449d7cba545f4c550ea60baad670d6e8c18e03277863c7074582854f54f2559c7c1e48d7e73fb3145fa19dcc6dbf7a2d054556202bd71240394e70a22fe49d394f177e0a4fced57ecaa51eea1a687dba0c136073cb7379ca7c5dfb0f524be62b1625f7041f244b633375b098e3c89fc687b5fee0a85b7ef680d063bd185d7250ccfa82ad09a9539c202367cc1ad60417033244b0376bc099c1ec584738c91cee8daeb54365165726f39e6b2812f11ae1d6889dc3f02a8c9138b81ec98edc8ec9226fe8d20e8f870f566db07e911c71841a6c4bd358f9e7e2de2ceb86de540279f9ab6e1706c2807b1ebd0ed9c53514d7fe5bd9646816bcd1b305e0c2281e52d33f60103e1332e91546e61b1410fd5e375d802feb68679c1b0e2cb828aabfa83de1ba98196801ed9d46dd1d1e87fcb21fa76ba708ad5b577746e9f7ec682f1f61f9004da1e225e8209df4eef86c7e085bedef69974dc43a99ade3e92c2f164a46dcbc54c84aa493d6f7f7eb9e547abbff6477ea05cc1f2a3205fbf83e5ec6e7adb74391a8ee2115ae22b79fa78a0e8ec9ae60761d9466ff176c813247af4a85ff2e09c7b0eb1c63eda618507711f4bef0ef10dc7773a6e72d308a7658ffaf1275c7ec4c6b6fe4e38184e402d567d159c7047888a9885713be3c3bf0f66b86bcfba1608d90d0e5fd4ed1cc20aad71921c071aa0b72b54f619029ac31c27f3855fcb9d4cef25148e5797d632d3d0946dd159f15425481234e1df073b0c8b0481e7abdfb69c3f3e5a2f7073f047fd777e80089f277be7fe90dfdccdf57d04710ccebabf51cc67d8afc5a09d0e49477582a93f2f51990cf3ff8a29e18d9b8300ea887706b4701bcb2a386d791a876c1a6bdc099d1259e2674c6f8c3f071abe0b2e7c887c5c5fca10babe8f658108c41e882d215988956ae38bad561c5adaacf7b9ea01cbd7437e9d9a5781eed7efea76393c421baa67d0e3d949e09f95938a5d58aa357d6d82eb0cf784baa247d9aedd17503ddeb18f47f2688694ddea62eaeabb345befe24cb06c6b42aeb00a79ddbe4aeb9dc4ee55af5a49f879a241dfedb8f109b01df942a68dd4ad5002a03037741e3c6839c0afd8d202876057cc3c34769e3eb68fc5a5bdb39f6b0867bb15b0fec4fa06a1b67f9b9975803119b22d144707d46ad37ed4960b22c37cc2ea50022b7e398c0b7cf30fb426e6260c5f7cddef15a8dec02ffffa709efbd013842c298e90dce171238b721a4b67de9d58b3917f61860ad0eddfcd5ab8cb82a8b4983877b9eb84cc131127524661810db1e5008dce298e4cfbd4475f15aeee5f12b1c54fab0286bff2b74816194471375eaf88f9a9cd977146ad6885d616d2f135ffbc557892df4d9674447b5e3b71ec7171da0f9a2ecabd85dcd1b5b193000ee8d7a7f8b6daf0ae8b1d3bb2555580cb91cfc39584b610e68b56e9e42f423e3a36669b8a887a1f6a65c540c4f5e828a1203cd484716d66bb4b7aafe313af06684fc7e55163e4ce653042ed2b97e2a7d466f4c45bf4bacc3132329bcd22ec9b876d4d9f753e61dc7283791665937f588854b14dc6c266214d64f9a37068f663313ca5ab54404cb728b03f5c3c0f618acdb465f65aaa92d7003ef7030b5a1fdec016c9b9a0aeacfefd6b3b5da66233ac9101afb4113a12b7336e93fe7aa31493c5bbc35421ff8b91ca48aff72b1b46a88ad05c15ec8ef31ecc70c1f52a42dde52ca1d0f4ea2858715ac1630fc04a37b6a7b018bbc93bd81dec05acdfd8f61b052929da98a2d52911cc476866cbe69ced21a251ef1a981b03b763db31ce9f87ae790c2c623478a7e221532f31ff351ed87b6a095bed431d819aa51c301681416bc5c19f5eb44e89e4f34946e93e0ff98336b685a29a51b074bb09cc262ffecccf6e7d262aff19018d59dd23ba6c2e0152977938e415074fa4466723f29456c225b8427c0275d3055e877d6b07b121539c1773a85fa02a3d270038d3f3df33e3eb722aa0eab8ee2bc5fa623f561afeaa74db5bc51485f0b3c22d1ac43e187cb8423a6f779d7d8621341f1d5cc0119ba3beee66f58c796c0a6bd64951f8d2283be6bc38d5d252d4ed0f248c8ef427d74b398d7a6092f40a40b2a0935659cdcde4fb75fe5c13ae5a2b239e6ef1586af552ff535e4901a93077789f394d43a2c0be64b1440578c96e62fbdcb6a9f16ac0467f7c56031f2ec352c03c26976adada5c83a908aec6594fbd536fd9b172942e192ba8fea84774916c50282cafc6e5eb3716e372e4f26cd3d949137d3a057a2afb90615e8b9867554d11d6b99510f6f36bfa11d0d9928d762b39004dc2c8fa55202408740faaee809f853c150490505683575c18bc05a55db148162c26c6b0741e75a9cf4039e2875c326b9e49675ed3af95d4f5dfc2a2df4476db5038e297967e4f4f7ec082a5ec1628cc394325d74052ded2c5abcfb87e248c2cb189dd15ae0bf820eb3cba56ae00529421a9731552f2622a2f3c904b43dd15fa1d79b305ae0f63d7b9d1394c2722f7728e28ba32f96efa208aac4237ee29aa56e573a70f483cecfce9889a45363a7891871bd133bdb0a1ddb9088d6fb5a95045f408780eb2aeb9a74c674ab86916672a6ccdf0b38f94c4ef5c9738f47fd0e25f93d5c7166dd3338888f3f9e6f6e719829bba0d9e8c42e7a182542fe78da3eb59a2cdc58fa2a073e8e22430e7f64ddef09a35642aae1d612d44ae3a972882bc75aeedf0e1576a48ba64f8fe2a9f26ec44caea80fb8b212cb8b47f69e9cbdb0d3668b6abd341527433e209d1dd72017f91c21803664f2eb080b1b19e4728a8fbdac1ad751e2e056fdbfbc080fe07242b151195543ddb8030f632d671d185057778f19ddde6c7e40ba4324564de4ed8df82bda82d3e9c462016287b148d4574970950eebeb66ff80fa0afe87c8959adddadf1714a25236a8ac7ad1e3c41f371d921b3835164a88009859c84f38db0463c9dbb5baba69c92c1a9c6561def8c69b7103ad07b2196daa99f23a3d2f0dc992b904aba88565ecbf747a03d6ba0d1a4954d20dc3dcd4395658ca57efce23bf605c0ba07dca05f7d03a6233b363f26157792a5d93428f9f7a84c5ad256d952db946412b2f996d5f453c62c78ca9ee079711fee4af6476f440a845e356b7abec7e4f8cedd7b9860b0b47b3b86a95939c3f7c3e2fabbb9dbc4bb1fec765f06840284b4b18f7bf1d85ed31302d2fd24614b67f1e46e6528496dd35863307a66a929d4a3870f17fdcac46a972480b96af74f386e6d12701bf4349a255db65a02456096823315e85f5cc69c1a0e1421299eccc3ceb17bfeb1980c5cddbf9e351850abfb395ee3ab99cfe079c4ca3078e5ba0f9ba365e4d3bee7e28184dbebd868c5ee1a22687930cd88a3b7b02719cb03f38a934f99abd32f09583084a98f14adea8e41ca6e58cd612ea20ca15054882011daf1816e3ad95514eef2bacacfbe1e9ccefa75aaf7ce9b50372901ffd2365849bebb86d24655062e9a0373b2e83462a2201eab7acf7fe73b76f586c6ad72e15ef0034a9adf158938de37cf332a31043daf9061e37bee835178b143244ed70de9e7349d13c46d69642408d22111932baba6d8eeb3a0c732ab1a06aaa21187c7dd25712ab62cdfa215c628f2dcb2d0cae4c770e3622ed74f4edad6b625674fd0d2fdb66e3aa416ad499ed398e3dbd9a2069f8a259cea507d146d18bc3f72bacada8a43bde89a3a46f8df55f3d4d567a6bab90918f4578703a50b05a43dfec42924bd1b55a7ac6717971f7b38399703a42e52d41b77d1f74f8bbcbcad70c885ffadbc917fce3262e8111925f93aa4ef590c5d479dcfa2c8770878e8b08592d33a1e28dee4b7fba87df805ecf1dd979d103ccbdfd833af9502084da9ef46ac377abbd56f10422b7a65f44393310f025c11222bdf5c8b33919d11ef1fd60c71bfbe6447bcfc73d56b9bdfb2684586de82c0313b6b069d9ea8fad3256503fef3b31f4fbba016872eed7c8e802e3ab28edcdb01c332c1e9cab68189d3ad955be14790eb06a28a2217018d33dbd7fac7f9b8348c7a366e57d22bed1e3f18f3f23423cfde32fd40661ad5476de0eff1bc6e53bc791f4fc51b18ef284ca71ece4d902ec539cc8787b2ad9732b9c126981caf7f01c39c7a2649e058c9216db4992f011ff4625b7aa1e210ca772f5e0c21c3182f6a42c7e87e6f433b815e9c1c23955d6bdcbba4955f891466b53ef9beb58e3539f421a8860450de6c0e49d46e506919ca7f7cd35550a5b5de31b8abea3afb470eb7a20f3b8a1af5e72df34040565e70c940f808ed70642be052f5384621e780ea9bca1f2fc67f081560b1c7a6aa2f582008f85e693cd76f7efc0281b3266589c0f8c3be7b8d0ee42f1196d1f9256160add8d1653caf2f6bd0efdc96559e7e7e5d63bac076bdd8c9396801d0a0f3edd84d57996798de2b18f746d0bcb578f4232654048f9866cf83d8b849bd528eb3d67b7305eea611e7a9d2ac9fcf8e61da2d7bcbd158b35c1a3d1f06f937c4147311b10216630594a267ddbd6045c0c86aa2de058fb2e1a7356d702d9ef555146108edcd356bcb24abed3dfb0b78008a6e76c4d61fd6c73a7abb1c61ac8e03ad1dcdf409ee78764c637c69b3b9f198ff648a52568b871c6d81016a1bba8b35323ae86c372a63392c06aee514b46611de0d04c929e7ea571f7605ad75e22e13e691013e2f668efda8e7c17e128abff4ceedb1eacc7a404d44e076ea84845bcf008d66d2a4e15c9d30174fcfbeb8195a6442dde6cc9443c21c9e7dd773a844c9b89deb76554e9d04b00fc7fa44dd48c18fe6b7f86eb77e7bc2ee7c708b188d8787ea0f23cfebb0023ddf857f0b2ec8b81e9147b0278430e91d35ee473c033b54365a6416cbda6dc1e97f4dbe4c64b93c6d391e7d98389297771ef8fd44d90c0c6e1bdad31c6cefc4ad91ad96e20f19c9c927384a5fc26310a9fd268ead8cc690edfc47b9b8e11a5a6231662b43c2772df38c3014abc8f6c45ce231ddadc5bc5426c9bb127a8abfe760c1fa87700c5162d580cea4bec61153244c639845045aba821dead22d68a63b77a56b3caabe5f405b4f1bdf8bb65ca94aedc3f35129af40eb182455a05279a0d5d8a8bbfbc150312ffe53a394a097b6d75476e9dbc4b114c2d6bfbd5a105185c3b772e421a5d5231cc631306d0b6d53cdda9e2ecd2cdb247a6f1579b6e393aae3d3aa41a6ae0527206cfa21310f640edf50f61f07328021023beb8bfc42bcdc9a4e98276a69d8ad6807faa7ef1522a62e72d0812105b42fd51628900f0bde6aa2d348a2727cf0407c052423ac68ec309e3e06c54beabdcc619f6c33210b88685c4fe46b80f87ae12c2eb727281fe7ac307b7619fa08a858c5b64ee219df459bfe79c777b529d6e113dbc12e8667f06f6b9369df50c2e403e8886248bc22d335ecb85bc06db77b263e4d64bd2f6757a25381e10aa9c282d1ef89c0e56b7d29c82e1371dd75100ade71096897012e449cba9206fd37b5cf1f0310fe28249f595fa1ce9f3b1753d89e2b54a1d9d5377073c4a6b5c7eb027bdbf78b701117b40c2a0a4390766cfa9b2ca3116f9d7859af11cb8184c544a55b791b07ea03ed6f9d27617d41bf0224aa9142b25c0ab4c97dcd020db9766bde6cd22d122ef4fdfbdbe7713e43ec07a4fbfd29ccd1f7bae92a4e3010b7d24dc5839263053e41860d29c587b46375250b69eb3acb9371a5d5c9bae7dc180e5a3d0858c23e3f722d880e0023afdf0eaa441cdd69db6d092ebfc70791ea795598cc4eefcab951ac24a3fdb0783e28d92cbb09c65f3de64c6efccfab2e56e0d48e54efba51c7b4c7c63c5ace6baaea10c51d82f359203da9b4365de743e2d908cd0c5e1981b55fd62757a8fce80d489a27ce7f80e1101a1f2940f37cd8288528aa7a51a6ff9fa7d22733ada2a0268060a489d19624d363301c0a821a4a175cfa0194b27d01a55edc2b0c7c5b9c570ec413643a424db5cac5b837635de084379294dd0ec85359a53163117603150c83c38f3639bcd28013c24565e726c1f6e13c90a7f6792e7f0e04a12d7d0cec1fb9739e6df18f93169810f55f22f411d5641705c7b0ed459c3bdd5ea24835a0af7ff24e88d334f3f49aac9564e2c19a126727931957a82f2a911daefc4a1159dbbe357ddda140002ca5e7d6c3ec278fd6f72dfc2dbe4ca397ae976e98216142fde33a82aba25cab8c59068e121a25185ddbac13208449ea310d3b45a3edf7b4d7e3ce155bb9e15467d6af8421752fae639911f7ee4cd23b3292b1afa981d4a6c8560581c18059a17121f5640f6b2b30c04e553365fa74244d4b927cfb66eea033ac9681ea5f08b15e118b2a5e49327d139f13563245d203d9d3967821db3f07dc3711fc9f269316a0a2e5f7cd50c30fa7e8f9b08855db8ad30863779c625a7e94d245e50208f1b472c43881cc9fd3465a98032b9bae3c50ce9cffe9bf0835e48d9826b03a79b93eaadf23b3be02b51c2e70b25abff8cee462c55c93396bb504daf7e1a2d317f4c43bb5e1ef761526cee6db148722be91872277350966a86db92a97c94088f44f01aa547838bb0d7f59aaf83025a29bd5e3359ad9bdcfa8118dfb2fa1c0199e550e5c5c23363d9b7795750fdde7adcead9fcfa511f3908f707f6889fc69b07a457eddc9e0787c4de696eec646097d3ba598a41fcdd2988328776b3c7b458d8f1382c5c4a27ba31a3c539347dc0163a79f337ad07e190b87a95fcbf194fe64afc7226a049cf5597589bb9afbfca212ee3575375867abd03ba9686ff548f0044f664947b27d7815bcc74f0cb9694b9673afefe2513688e2ddaf96265eab481c883ebc8e5c7dbdae25562955d2f5412615b3deaa1350cc77aa4f8c296f85912ba4032adca128ccb66971971896f50128b15eb170c5351636add15b786d806fbfc0f80b9da5bb2ae2317f8d93ee04444c1fe5d846e0899184d060be8bb52d2451f2b114da0d79e40c2a1e664381e538ea93b229e5ea63068246c93540882fd5c7c609d5265fd158bf2fe9d676d556bbaa013553de9f6935235c78cd09fd1aa1e34432236b29be5985c3822e83ce8c883ce36d2f87fa885bf42d2e66d167bd8640038d6a332d04d023d2065a2c2ce3ec726fc33849186ad9e28a915a955b9184e7ee357cd2876fe34f73097e160785b55c198e9585e1e5b957be0c5258e119dd4a4343eba1f202bd93ad01c5a4f4e32fd74ddb5313baf8af1823028d53933f8cbe9947ec65645f417e66d34156e7eb916f863cb79c53a0c11cc3731b7ae08ebaa69e1f179c49a67d02ff59fce3b2eabec28b7b5fa36c9bbe7e4e02fba313235d6a4ffef9c401bbaa13903ec057b7f8d80b409be84dd8036a0a513b9fd839b83b2395fd6c71113aa4be7dfe1ac9e0845354750e7fd919c27eeebc13dd13f7a12d0b0ae15428503f2020ac8d63aada82b47c3660fcc3c323e4abf2bd69424827dceaf28bc59134fc5c5837a8572c7a65ca4f73b7be3c51e95a01e994ef7eef3bea1b10ef3e207cd0aa26a48222c86d784803f56c20ad218c12946bae331d1bafb371b30d9ef4569eeb1c1dd27d650a8fca741afbc240d3a958ee0f7cd417e0d8a5d22fe3ca8686931dd4189b6fab511892fbfac073c01250884b144eb6d65c695cb38031c82120e73ead3550ee32fe094a289e386ba1b3a9b5fabafd9e750ac21d5e9cb7f65d99d8b79289c9ecd085ad0995fff042a412a33a5634c6bd9912352f2ada0ad62090fd1bca5b5252b3f50e87f3b84608c961e8d1789578b85d6aa3f2dd7c3289afed9c630f1015984af73e4b28f9e2155d3907c42597760d8ba6cbb5057d3657bd0404a5e33af3802db78b38a9b88184d4d8c3c3cc4e952ce6061810838540365a28925ef7fbca71ab64fac08f251fd372c9516a1495a70154128ccaaaadc162a1ab222e2669db7bb7bc35dc2992aaef7e184cac6200253f54ac9ad6721bbdf745a98d77944b83398554c2f3e5d580abf64fda815218e371c6dcfe1228e4c687f81ad1e846790501c8b361ec1a280aa42cae827f56d6f24736f2e52271424d8b0863a9be679498b5e324e6aa1b723c68d5f7a19918331bc893d4d1598f507507ab098c8d6f51962de84886afc8c99755e9fe159868f203c1a1edd77d34cee0ab4747a6d65cc6d1379f420784579ad2d557a9e8b790d7890d3b4898af4cff49eea4c6a2e0df046b34a716e2b550a77af12ca018a35b439d0a41f49381fb89efa3684d2eae3df2a86f1e7e17e428bb8cc3bb829d44a0c1197186debfc2383fe5f202cc8359eb839a0d480c69d6222326bd840e5f790c48838c47592efe4f76f45c4a4d460b7d7888c4adc6ec2fb0d7be24db4c26b0b214f5e948b914142c2e03a62492aea265769e09b09c187e7a0e0148e7c6c120d24cf61ad7168ff18ec923610ae2698ef91af845c35742dbeb3e103e92d1c821c85aa10cc7dda0af39b56e1a6f6c8f4ec9560a5364960afb0ffa0dfd49f21b9caa1b59c3ff845fada78ada30d69f8f353a81083c8b0b3d7a176f9c60401c8e90a3b5498c6d8885fdc83b3603f16ed8e676f4d14dcc02d499a11808a624092d2ef44796f7cddc9b7c73fd41118134469b30dd9d82f18daf019de4a99768986e202de820d1377c4dae8a8eb51b1e5cab3cf6671af9993e2eeca684c0e36e3ea3c5825b206c0c0bc54fa0a3a135e7fb03aa95af8aa772e952654966830f8ff8c2af0ce91d7c5e720d104bb37da08d975a3e2cdfc3b60ca21a18fea15ac46e35160a0f070b16d2cbd1947c76a8a705d45a2395d3d351a3109585f15e5787185f61b344fd56184c2e782bdec13c55c6b210956afee5ed2a0622c93b9ae81472cd69318e092197b119367206fa94b1634d2c60a4fa793a1c9abd4f8efa40eac0b8cf946ff65297a0437c6e72b788462b526f2cca892af6d55390b7d6cf0b732f6334b469f2ba2e8d23389ad17ed8079fa676d7805de8a917ee134340cb4cc79b5b41e9ba6a11e9f6dc2700b1c578cbeaca60309550247893645c5ff96f4556b7e49994eb41723f9647490cafe51140a3d2ac8dfe44ef97671d6e02aaed9cb62108ca9a5ada0d8c67dd73e7f1fd2d4d6678d050f57fbd5c27977e1b0597b94b93f26f68f971a499a185bf0a7d53d7a466a86f17a1d113e5aa0689d30e5a04b46d16ecede1c8ba55927687d3c94956f418fd3485c81b6ea17efc88bfbc465516ef228d631d3b1809468820d109de4bb4b3539d620092bf5ab98672d801a84a194dd873f78d583d7b9cea358b3b3aa56289736dc2eb884d7ecdf49810ee3efaa793b333165c55af91579db28b780580f55aaefd19b235463098f01d9a0861abfa1492ac236cbca1ca157d51fd379b4719a1c7dfaf3ad5425d8bc8209eec72bba55828a0704be6bcf51566f10059840c266a12ca53916e7163113bd8476ff963a21c1021ff10e4f8f552fbe5bae5fabf55c2e5c2e5d86d321506f8f46e34b1abea47f85d1aa774145cb6eb39539476155f2ad054c37ca1e74f05a89ecf6eced702d2103d30aac86841c3e203de2971de91679d99da90818663a187c9d6d16b91c71737778d6b4cfb7b4204036ad503721be3e7f593778fb3b3a069975f70807177b6bc5c28edd15ad6719126fcf693bbc1bb13eb679e8a9767839b29082a10ffc14cf9bf962645c7716b6c01ae69a6a4b3ddd1fafdf573d176d1b6f2ec8100140f7bb408f3c48c2dc3621560eb3cca918bf1f5a2002f10bfeb982ad108543512bb1a9e50ba3cb44830690ca9593d5d4511e39bb1624eb3195d39e573433d18360e4fec0b58069596c2669b9aae3dfa33d3881a32f2699620ac7c40ce4364d4bf08c4dea251f731c44cb806d6a94895f2f831554b5930a995bf9e3fc3c451fed7ca803195c3221af7a6a1b505799fc24e4d43bf1c8b9886e52d0f78fc920be01aa5a993f7ec7208ef95c364f236080422af5d648e8982c6241bdd9ba201e1fa855116668aead13382cb4563dadb267b9357734e0b886820a9f40b1239f9f4166e36ff890bb55cf7bae5378455fc1ec21fc354f762bce05e435893eab1ba33f7ce998d8c6ba36791733bdc2b1b674565a62acba2e1fe665d963553491baa927028e4634ca9b8ef83dcbbb6af9599ddc2a6887d1c9576d677a7677287e0068c54035e6733e9817cb6b557a54f42a54c021c3d9cb0b1d6d9ed31f45aedc9e9de34ffb3c1bef2666c67e7e0d38660cd5c2dfc23e81752ccefd910d0a5a2549fcc2663bf7f8b7064cf4a202832bedd0a80eafa0381c212664ec8c816f865a0df41543e09dd724cc0b5fb4fe964f47380b1a476abd380b9ad97fba0858b05d45d82eda8a347a0b9810f5846b8cbc6a2489b648ffa827b4d6daa24f6670ea4c2eacc06496872d1c70e58a92188a80c6b242fe5d809c245616ffac83060e40ab3c428d3396909a19035405b5b3893256a15fa2b327f219710b76a59efd899fce3f5c5c9a3e571db0cbe357c3edcd8dd887ac081521d4d55fffb8c5815c6abb46d87bfccfd83ff79e54d484b5bc2100d0378973f667c9db84a04afe1790bf730b3410bcf641eee50e1a636ffb9b4db4928aaef31256131759de8e56150199ce9dc8bdc7804de8ff7a02e34272ef0e1a09371f5213e4bd7e6ac1ed737b2e1b413e36960180ad37afad4de95359ab004f114b8aa124f4c8638a5525103c8bfd203cfdf8cbb1a87c21ab40374ca097f740223691692e3f4037a1f55e52b60721479e17268d8159bb1f87b4f9c087556cf69da41c468bf3be92c716bfd685811ea52704aba3369a7e15a29596fcd48762b93df030243ccf639aa90bfc0705ed4f4953548670ebce862ad3a46d8946d5ea6f20b15f137a01fead80fc7fca621a97f1582d1af2efeef0d4b3793c3ee801bd2d0d727327d1398722f3530ca18e90e3d7349d9ac3137c31a9a848bf60d9905a9e96674303e0a5b299c43c4d98703f2924b7f90ab3343af740f980f8a581129bdb8f36080c9d5862b3ec4896370e9ea50dd6fd9224c59e539a3b9aad8d174a1903e09f678005079d0e0677ea9ce7ea3e3aa54283fa29eff0e6fd407fc39f15547b7ba9ec7a5c5742656c0ddffca840b013b617532c5bdc651cc46f5020244a64c0a478f9e1bbc965b4854884165e9f6f48e7fc7b5e2854cd3fffdfc02a3a787eb7952b9c029b664a582befda91072b2cf9439a6896e66c654e280c2130a46d579e4145accd75ed1e10a3a15141c80eff57ea45c8dc7da84b0321ce038f22e2b6232c076d528d867247abedd0749bea4cdf61d3c6ec6f74c3514a9a6608ebba93cb734e6f61f1093da4139b9dc36231f214733562feea9ebd8d76f8ba4c5298b58f05eb915b92b8db162cf45d803032311d5868afbf0e93f1b203058e3e4d99ff97de5f25910e16e41fdb85d9eaf14a66830fa0f75f3e6dde3131cb4c2953b10feecd17de66dc30812604a1d0bc80b427406205965a9bf2f7dc73cfff4b2ec3d9cd47396c33248cc079021f0617f7ce266e31d3e31e00e92b666d912307ca53174ebf3f1aca9b72c97eda9eaffe75e3173e049ebe30969e7111ab90ae53b6d4b5393d2ec157a1e07516dd3d6e8b7c27011ddfd8fa5614d4c8cc08f912e66d5d6b1381778b69f13a5cf3665eef696e3c0ef51dc5bc131d0ad38e634e06b98319c68182eef82aca2ea56b1a1ca6af03c83eb7655c353951ec18d760ef8d0f18cbc456ce145bc1d079f6124b9828b5dcc156b78a1a7cb307887ed908e935908f8263b86e849e4fd0f2b6a81cc311a43001802956f40e85f9e0ddf172d7ef6abb7a57ae3aa4d2a772983f01de66a28c34ca3b7932df0b2e5a4c198ad63890e8f67acf938e4d258d4e53493e751bd1fdb6cb616d916a0a7f989d59807b2a9586022e617a669ee836535fe7edd3a525b709ed82f2d505f610b0635b3e521c54b21cacf9635b020e7b834d7e051bb721c5af5cf7e87ae7191d420305e6880b1038ebfc11b6ed3a98832534d8ee269304b9a7dd27269d3f1cf830f27fb1e039c12aa9c112b997d486b1d6ab66e31ab625eeee2998b6a1e670d996b0cfd48b7bda5ed093d1153736dd7d3c64bc5e1ff49dcfbd5de0f920637545f076214b85e59c49bff4f5fd331f80b2cbcb2f5e845a661396eed85826ac0b04966a12b952553e95af71448b5c05c56360ce819f947c102c0d0c549fafef787365131a48b3d0344459c4edc35211af11c0c9383b2e2d1e72d25ad0388b47599216ea340629c3d075db1534d1b4dc14a64a1937a62f5df55b9e22e4bf1736d766b60fd07ff056ac26a0040a347d2724394486c96bacc1c7a4e58a694918687b62de256316d787ff2c0804b4cb6fc713ffa07b22e7c05d5518d9ac6b337902004d5d5cbd75783b55fd0d1c164e8af92b22000227e3590b967e78bdd7d66a3bc7b189ad4eaea4fd6b833cde7fade72fc592e98ee7df223e28db0d3030d1dc8a55fcd5fa2a8cb7cc56e4dc1a4f280c2a9a3a102d9c49357ca42f85b6264724da51768785fcb744f0b7069dfc8422854cbc9bbd0a797f609e3407db2490e67bb7742436c14d3843db4d995c0d45c4e4fab3f55826cb3f6e1394382468f9a42e8ed1cc2abd62217ee70237a7a90306b5a8533412ed5d6abb95473fb313f9aed0024c3795f6aa26a8a2de10d78259fdf813ca0fd0bb7ed6f286976df931d18372fd7e612f3192982b6c6fa590175f148593ef2a767d8105a904f766c9134ce82b4892f9b838babedb936ad73c0f71228932cb4b294c2e0b1bd4bbb50745c11c6fc16982a06b28522b3d1df369ec752210683e579a56f6f45544a236e6c24250620b62999029de878ff8ab0f22fb4fdfbc327890f1b0324766ce59f425af5f979ebe038b0799af3672a6c42419193f62168c9ef16a81ac17bbf09fe22ebce2b95dc18bbaf079796970f3110c1d5bca8876e57deb9c6897255bf87aaa0b524431003549a5ea41bf95602e58875a41a9fe1120950347a64bbb23e868cd4fe749ac1a89ba99eaead96262b80ae5e6d636406209f549ab84a9a396e2e9e80e49faa4a2ca555c9eb7d3c35ad7b97675ffd0496a46fe2e24b25a01402bdac5fdc0850d1e5969da44835ef93e482d664216be9829302a4d728ee20071b77d5526f5e3ed8df8ebbb8ea2e9833fbbb93bff44fd950595aaac7bc451e7528e3c1dbf93492f3addedb8624f571646ee863aea4d9a976fa05ed33153cdc792827e317062d558ed5b4489b38fb859437393d3cad1648fcd9b76b5888fd4d309b1ea98b0402ccd94a96eda96137668fb8dbd9fc543fea8e1181199d0bf7dc1863d523e4aab4cbaa3acd6329e7d20d072aa3f5f954aa202248425465b84015204f2281f0911f1b41128ae66906e781f2fc2f597503b9d383abc1bc553c0fc6e0b6c47b802e44a83b8fb669c215d94f15816fc84ff0d9dfdf9301b8a788b801ac2a3ddb31d646bb4acd66f5648e5c9b4f73591e20776cf36b239262fb511c53a136f536ca39123956cb2cf5b2e4031faeed38c66bddebf5fb7a83cffb49f57cbccb51a47d67b2fcf827f4841c204aaa07f8e67c7818c89a276c848bbce6a43e3636ae89dbe4a4df67675b7c55819a856711e6351b048564fa5716d4521d6407501c37c853910c36596229315f0cf6a91c07d9917623a60d81cb348beee5bb093f79f0ffa920279eede73a774c1466f1b592b43f0c43d29d7c1dc3ae301d067a1bffb0636e3bc52a508112be4183f61697ce90740096c18bc14c3247dd93d0e985190beeda06f7c9380f383b81ff66d40097210c294a6d421627f7a7767d9cb87c10d90a7510f4cc46d159bd0da76bd62c0d4ac7a7e9105550c68c2fb1b6b680f05bf175d4416b8265c61999effcee7cc1aed2fab8a6eacd061c6bf7a10d011cb8a316a6d677b1b23e15fb760b8f1c8e734139a1e2a46d3f24cdf2288973e57161196603ee8b05f8b8a947d15c2dcf51df535ea983370ae88247ced01cacdba9666a0012bbeb7ca042862123dfd23340001fe5bfec11a2528a48ab419c72af91016c63ebbb4f3dbc8b678174929db5e8d32aa5499df8fb2dbe79de049707dc7f6b8264bbbf01e142dafbe271ba4d47b97a57a949710312ebb7d7f61c97867fe04a165c910488abb8fbb7537b1577c7737faeac833d1bd206f9b1f55137b1e0d505e906ff36e14761739a603481239bc339cf0daad751446b55c72fd8213c89848a2a177e7beb67a5d48fd21e50575ce1b59c7828480d0f64f799e19d7cb2d53c4ce8e74c7b91b9272c08e170791b2d87e4c69329a09f49f70acef253a1f82b188d2bd8f5198030949324b89e34d379b56d842ab5ed04bdb3dcec52f58b92ebfd8f6f72ceba68565f2695e31ef89b845a311331151666a32f1b20382b8cb957fb3b6a8bac95f873b85a513b8a58164a75254f9a418d92350bbedf9db1ddc88376dd15dca05c5ca70198b3bc5823fac71d3788eb51107fdb043d7e0251cda04cad2a7fcc20310af615f52778c524cbed88de91c3e31e297159a7b09be20355c65398401dbaf2f4557fe8741a92bc4b6ed789f25fd55941660ae7dd709d69853367e0b52dae765a5c7e4031765172c3e01c8e0ab39ae7b9d050fe90a720b9bd279a4c39b4faae474a8c33dca65b1faccffee3389261b41742e49cf5dd9a3ece2f37d348e5a0a5eb40011e537ec6c302d949d506147bf31e8a134c480e0a220bf9a53f64c86abf83271ccca34eb6da28f596391f5dd68e1b948d7fc466564b187d0c111e8748cf8f6d04bbd2cabd9160ec6398f91a51babad8b0b83cdf69b4a994fdef55a8d355269d996054a56768b70f2abb2059bca44a0bb8d8d17e741a7306572be986edb7eb98e3abff05bcce792517405e3b1e8b19c297420be69dec306d1a4bad6a5e45fe0cd6443168a606e53b66cfc6870b4d717c39384dfed77428d0c6ad0a9f8e21da54d13ab82fda56971b6fb3a2854c3d684fb4f5d0254a6c5a32fe27343882411e45dd7b13f923bbc6b2dc1cbdee367d368bf09383a6c8dfbb4662adf421d253831af62121be97fc32298832bf798e43e6f43ff3d69cc1ab4b8169619afabdefef3864ac10db13bb7522b8e5bc2745efe0a343da7e4267b95d69dfdcd4a49e378c7abc3ef61dfcebf99dbd1832db34a1400ef713f03c9bc93863dd19a43f03e6650ad887c3c3377b530bfddbc6727ee4e278ee36024702cf46e72a13cf1d385a2f17aba2aa151b4ec34ef05183b2d037faf5c4ff4acd51a06349f3333c3bbc0ad77da74aff3291f95d0ede3f4355d99fd40317c399c9e3ebe282e0059e30898283a33a27601bb6afddf3bab94f392b0ed85d457aa5021c2f1c449f2c1adbfc02f244417bbcfd6f926fef6f7e7ba6c0369a9105522df59b7f4526616a4b3aef6df1340fc3010d3928d206ee326aceab8e027474e6777ad9451b37b58fc5f03ecbb1d8317e3cf17c0ef9e762a21645c09c9ebf31d58bff5fe88595d585a900614542e2d27c9e5ae45591394aefa862136e9c8228e93d0ce05f0349cc4c601de099d7807a053ff35819f90416b20880e86b21d7dfa03312c2150df8faff80862a025f5a24739246a511cf43bd19f5a76083d033b3b90a09a4806c6b63347273c2ad70589d6b32cdd208d220fa2c6da238d285d9885dff9469b0f125adc5223514d195ac1aa0d1b57e5b5c43139cb21524f791e977a1c9445b5e9fd12815afef5f535e438d1d596a6ffb30ad79f7dedb01d4413c4aa965ceb258251dd863d1f218e3506f3c008e33144a5d9a4eee76ea785615b8f3a3ccd7ca91123aacecfcac78e0069c020d609fdccf9a7139cef49bf3fd771096f8892574766b4a0091e960bf58bd7ea2c1a6fa1b887cc82bfd066b0773647e2d5b96ba82a5208dec131f36276df2e179201c91f258d88bc80f205a5700e09f77626ca40b6db80eb15e550481918bfeb61c5384b023d23f09a46616acab03fdcb31d4241f8c028d67a60d16fa134649a07c42a4f0a5868d148ad22c0de766928135100cffd8179c055a35caf742bffd0372f83157ca2a1a7b177e47ee78df8085eeb6f2e757eb12a98abc2498a8ace00340cfed677bcf78690f916656b1ec24a06d2c36aac0e0e9ae06391ae67ac898af6e7829f8ef337fea7f54f7905621ce81a5102dd2a94bd86590cf9006452358fa2ebb17227da2ae1040fa10172447f0278c5950c2ff367c7ff8cccb416103793be5f16c3d2d04c37e198ef924ab53fb69a50d5a7b4d8105f7a3896b1caa284ccbe9a17eb695fae2ca900ac6de4c6856e7b090f919d47cd995aa039831e24b71a2d2622b80eb5169d9e0f74c4858ec093fd05765ffe92307d7a6524255d09168c65cbd99206295e55d58acbb135b6c36706664a517d2c86f6e28ecddd0d8301c4600cd96dc3459bc664f3ded8d4660d8cd6008f25ff1c1e98dc569386589d6800410094b1589f5d26edc3aa44e4e3259735ca0c2eb1fb89aea4cb0229ea01e778558feb78330390201f247918af7a838722d5e345ba38657b7bd727e13c41f79fe8868337be9d39c5119534ee6d1ed4d2222a5ef24a4a689ed9586785938cde3ef29fbc0b16e06933f5115b1d4d533f3e79c1eaa702645b75e51f4be001aa0e681946aa30a253b0debe45ea4c4dc5d8a5856c6494b49db8474b6ae07e4f25e1d0f4774953b30ecdfee86802f777607e423afc495961587256169990de06a8a60ef65276088cc34a1224d25056eed95e67c042aca05be87ed53a6ea627edf9d3bb4d46275bb745913818d56f6c1a63dc93e5edae4e624d3ca7eb75599464bb2cccc397aa41834560caceafbe0292c6d9bc7cb1819dc1d0eb571c3bc7f87109642aaf8443949728bce120f8cef97978eb95b4752f49b011500ad132c24ce5123169e2c5b2f10e4cb3526831bef5fc119aacacd3cdcc0c07d80fbb7fea7e0e3f772ebbedfee48c4c39ff1997b0b77544133460a392d40eac4021ba2057a712f55822bb1c30782c41cd6b0b67627db47d83df40335ed83823c0c1b8e3eb52e3be6dd54f0fed91d0da1c00654f7d9dec65f0910b56c8aec9b71acc4e4ae4e3f1d307fcd878bc01a1d5e8e4228e10c403ccbf466c28ea41baf905873f936d5fd43de0783f9459cdf24619a876088c0387e986dc58094d8646992820a0a4542d138c93f3b7b3da334eb9a9f25beeee96da4328aff2f4edfea72eccc576f95e389bf000b747187703d3f3e8f1cb4d577dee8f72eed28ff56bec6ff3c83f15e1dbdb5bcfa37e59d5670c95a4915ec08eee3574ab4f994b7c9e4457966bb3336e52def453b8079893aedb8a1007bffcea6d165ad792fa1aafc104c18e03ca17300f814498a36f5e7100388f9995082b4db9a8b7e41601aa69bf02ba128a424f1247f28b2c53c3f42f2019c5444496f5df3626938e6d511fde5043e1141006e7678","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
