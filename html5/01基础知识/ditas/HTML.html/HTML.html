<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4b2d746a648b47bf6dee85f88c3ff10c10b61c59be0c18f24155c8ce66214c323b6c0ca33ec4b9644b7e38ab3ada93091bf5a6b9d15d0909ab0b15ab98a561495bc53612a790213a2a0d10e1605e87d8763943e4b7cb09b9939f66bd5a72b77b157c422bb977e341ea1728307ef0f29d19e381ff442dd42689d500287c3035bf8ef0986e183a0bd262d954fa0043e41b01503b6b853c2f1762ad24a7d64cfeb5815af40cb41b25362080c01f84440c9b1cc519a65e32d4285e32666758edf581c8217da73c7a704c517c7498277d0cf8d2f962d3e5e64752f30c7582d3c5b4c113153de10b1bc8721db29ae39d4c9844b86e49062528c5162eba1162c63d2d66bf2fe6bc5bdfca2f55a0fc2e40a50ad96bfb1c063673be5debab042365a2e8ffdecb8efe5f32b1329543016e17178de26dbc87f51fae9028d74a6cc9e684e48fc3a26d7594d38048ae87a0704c8e15046f9b11aca82ae0b23659e279814d17babfd88ea1992a361797827bc198753a2b0b2c41c14fe8aab56cb429bbfe11973e00741ce2c99632cb539d7a446d2ccd01a93c62b2f8cdcbab49460ec5c548678b3fe85ea8ca3cbe41ca5285a15e380ae05aa91c3535f050c0c77f6d04554feaadbfadc9692e49f4696dfce117b85ed72bcaa56e09dc4f807693596425c70fbca19d73cdc180cdb7d897c878b9fb8352479f68e6aca8182d04787b3c079e4510d1d4cbfbed0f518952b5ac77418dc1180ceb7a8b4056302a66c824ae27400a609aaf05e853340c345be4016262b8a28714208ca5c4dc7081fe01b11bc4b469cfc64da8012aaac4a3e7b11db0b1bdc2e18c79bf8416b4970c67772b2c6b08ffff8f2f039d8dd430e8f2a7ef91b89e1226934d0a77a5c21367a471e3a16428f7e05eabdc2b6cbbd840e5c5100d84be33086e1b6da58411d53b68b26b6a090a072e1797e62e3576e7d8837681bdc40603d9f314c25c48411ac6fbcd114c467617dbf900de972be245c70d7ac1ad330e5d0a16c76b6baa7e80a6610334fc7de0ab73f8a32379601e41abef1edf6531865df08450df72cc01bbe7831b78d9b861efc180ee58cb2e805bf82164e2eace68f3eb25b310b2824145b028a55ee2cead3b123a32a4506d142d991ce66d15705e05c8c8a76d59f045108b16a0c4be5d623f47a4b0a42d6fbd035018998812897f1402ba0df77bc528a6d3f6cc6608791f4c9c9809c9256d4d9e1db746dda0a3ff572c0ed1925f7310cf423fe0f90647960bd46ab51e58aab4968a095ec05add685859ff36129eb908b86309e848e4a2ca3c050d7df0ade8507734077045f4869399c7663e90e9dfa001fc059c1050f6744e4a3e6639a3675f7d8da37179e8bcd751dcaebfac0b88b56da66866b74b1c6f6e0063dd389aed4bdd7719ee4bf0eefddb17b6c28bd7fb99a495bc74fe90e097bdd404365bc86443d737214c7e2121abf304ccfd05c00ca45a3fbd9867a33ece5caa895675c70aa4bf6a4552cde96012f45d90a7aa57a9f559e355ef6de047260c01ae4c2e4053884d8277b7aa9469558039e4ab371b89036d093be888bab0690975ab8832abf99a1c19baceca9bc36fbdba2d96153be9f64ed0a1d172cd79cd11897463ef890787afb309d2e54dd568c38f725f71b3c884fd89b1968d57ee76283614f9ff527fc509ebebfe10aa6aa1189ff6364b16f4fa5a4ae2a9d6ed42bfff646e9e5ce0df15d1d79473526a687074b28763a59708b3d324106fc60a616b1ebadfaabc3d249e84d2e83bec21db6235a3db9c3a41a6e7c227d5e1af6cd6c5e4cf5b1e4c09cd66d8782f0e4c3c4a45f81e6bd03c19153f63267024be51f51c8b623b68f0603d388a1478ed550ad8799930812c072e4d9fd25d88f8a010d4896e9d2fa24ee65f2542a51f12d4fd6692b9c2e321af68b0a24248013332f3cc2faeb54734a815acae5d681729be3ea5dd1e848e3ad1f9edd8222f6186a136649dfe9fa80b1f86f5020836de8562692cf895c991a595c857f8fd2ce2a7a9d5a0114893f3c7e2a22bda456ccf0cc871ae03e133cbc4b6d139257c9ffc39bda6230441cc1bc13fd74c48d86a97bdfdeb3272be9c03cfa763b84d1d3457e12ba3974c3697e8ad38babec5198f73fd9713297bfc79df172e128abd30db23819fb5489971a11d61a3ed9cd94c0e5de93acc2d438316280f463d988af94fa77dd28941b80972c6c27f6ccb1ec5ac351f5f913b2adfb578b534abcbefaef4782c2b70b07fac454ce45dda5e70abe8f8ea0d13a57638fd2cc5fcc675172fff3f19770411ad5584b299d8e877d8684232816683bdf043c111d4845240121ed02073ae6c361048d5f9359ceefa03cf65ba8756473ca90af69bad779d42bcfe7e3992ef20dbaedbbb617bd712f8e35aa915b303e867337ec56ea6c0a6e08d0dbcda58658816c3751ab45b287981e681cc2b1e3288bf0cf824da9234a2a0f9b6fbfbd6e891e7dbe0efba2f7dabbb0d063374a297864bdbba51c96462a967926218e04a9cf4404b4b30d8e7dbed90e362af9d9430ba443ba736cf29c6aae4e800f506817935430e08bfaba4bcf389790fdb8444fa060422d9cfa8dd4b544307494f1ea0456e0c698ccbac503f5e4488d8b75e7bc67195903cfff3f35b84196bc95eb1548110c2c16b9a720d5878e99c0fbd8ebb072e30e5ba2cede1b5ea118d2ee25de0cd4137339bf05ded27a77bcf45ef7a1110dcbd96e7d78726e543edfe82111d02ddd2caf9c04b01481441f5a2f17fd2b471cc6041041dcd998cc539915b2c62273f80242ee5fc01008e0d1836e1aaf84026a0780f18df50f13857c345a8f348a69a8dfb1c8e74be39cbae814b343ab3caf60cbafa71f16ad24d5c79fd8076f2d8c514c04c9f3809f50f1f88756e502967265990c5307e134b9d4b855a02638fd712ff54f970689fbbc3eb8380c011c5ab694a316098bea0dd2525f41a56304c6cc72c077e1f0069460972f8f0703f71331f36cfe15ab6de5ce86896205d334387b6464b4fc5de10aa3918052d980b095e3d0e289cdcb579cfcfcca4e6cb8d3564c2fc08e6b85564d4e30a1455cae5890803da56a377cfb751f169fdff485decb6b68a27a56b36d817b85a2a86631095be1f1ab9ce32198d69df0ec966346c88e8da608659c6b9230bc3af4876ced0960cf74e0015111004dd9c6d1b87b01e931a91ec05c87cf88d4d1a4db9a1646fe45aa664568b6c4ca8560d12caab111fa56f1ae9af76475877811c3fb405637df60a55f2d8e62853084a5f15195c03558b0e0e2b4ae64e671b91ec0829dcf4541b0a613d41ca86afa632b99f46487951e1dbbaa1a1cbf480e6bb0f28d43844d717e2d10a7025396758ff3c0d79083887255ffbc796a6465b33b322573ca3e6166267fba475876250d7f0cd90fc8dddec274567b9d3b23c5ef1fff1fe1ab0278d2831776aa48a5b9b73f631e2207f707afbf20e0402a6f30d147dae60bc7f243faa8687d430cd66d1501b6f7b2236ab441724414ee24f21ccc89fd29914cf1fc030e136a6617d62c8fdc6071ab21dd0789266b259d6bcc7d68034fb80d87f77a30f1e949acd5127b950a6286072d14aa86fb926e1415ebec984eacacf5ada3cb65bc1712724030e81bb17c0bd28002dc401e60becaadc067ccfd0f5e6b97c46ca7718fccb7c3881a1d1cf7e8614d128ea0d8fd83c22c279ba980da447afa871c1cb2fbce0a82d2bb3a01b11277f53382599899e93182f9ff9cd0ff684516ee483e530715a795abde99a426495f35de9aa8e8a773ba7c9f39515242b5808e9340efa92b9176dadc888331a5d64970de1689a7b12e0f2ce2bebfcd87932da332e5a03d673d519ac8155c6a7344354981ab911bf01b66ca1aab51bdd359b93f9c33425bcf7b288ccbed556b8c75a7311c1fe61d3663873d748858738826f6c51b5d51cb5863f55f0400783f38bc2b46e50159445f21220895040b7c7ff4a9cc1060987989b71b2e1ae258a479ffd93a5b4dc3b142a3facee0d357f78d96a89c739eba54d0ee2fd172e7835f007d168100ef9f319fcaed1a209c0727871f5367e6a75ac6c2e790eb59de3ccadd2feb9d24e1813047250d99a0983b1db0f920569d3e21c4ab0a84145a0a9470150ec00b7117fb12a8b759b22585fab33e0625edb02228a14af87a53a5ba3f8ad0390dca6511cf1bed6e2429267ae11b41e7194720c2d8557e3f92f86bbd04ac41cc4fddce4ee512836fb45dc6393f17296530ace745dfcf6255aa548a8a8735d8a237f55f352a06915f3a20b1a2634dc237643ed0ff99fc22c6a82be6a6b20e2a9149f43befad39ba4a6b827f282204fdf7714b5866ac2fe3dfe0664b28658a08cce5dab92e2f73757bfc67a0fa370a538f9bc82a7a6b06c5e3504ce3b97fc4071be5aee2e0f73e412c35d93f33afc16accec384e45ac77be41a3aaf26ff462a9a2eff611ac5ee91119b56cd53fb55f6eeb59522dcac2f96fd632d00c06cdf5d5c72cf70f5bb452d4c5083b4668bbb80055ed4aae8cee25cd7d1126ac65770bb016c88bcb8eaac788b99ddd12203cff1569a6685eb3511513e497f7ce4ab78a03ad174c42b9fbd48678a6839a395ad36fe5399df4062cb5e1db73f7e21b8570be72d917fbcffdc5359ee9887d3f4abec32992559ebe960421b8c2ecc08df0f8436961e909d65c95046d650edc5ef98afd453ae8594e210bae55173edc74e1a6b08752f6eb6662f29d1360ae727154fd7bc654b4a53cabd1e14eb0dbbb007c83b51d93c6a1da5774ee1f0ad8c0c384a59eaf098fac66fce5604b2cdd935ad52b25482f601b8eef56d72b9587329ff763791bcf4359197e8ff3c5fbb5a05b55048b2b845fd4e4ff9570d7c624806f16c48ec441952b0dc893a854527671080cca7a571ca330cdeff84ab653bb6a18ab88f9910e0459c5ad9d8fb9fc4ad4bf0bc283cf1e26bf8e69a3a78a4e761b26d3367ed99dc3bb6d9dae6c244f380185b2a5aa7826b04394cf26c97402684a4747245196d496569f55c15341bb83f90dbb97a0ace412ffb43ca2504044dda81c3ffce6dcdd2a5533ab4eeae005dd843e17f85f62807b5bd56927bafef118925cf22d69a04451ceb219168102186ccb8944c81d70905d36827d3586f2f97142ef7e5f5c94da75240d0fd187340be30e7dfabba71e819ca9de46300cf529e1bfa34bb52f4a77337aafde5279663772dc693977b424069b7a7e5f7da3095bc6a5ad59cd7c924e04af134d4c174c3daaee613edb9ea0cd971e10666021fdd09b63b3f0deafd22a82ebdc1b520bdba72e5df1a919689f6a3fdf886918c7215ec691ff3991c2adf3a2a7ae91cbeebe42727907d3932a6722cd8f82476791005f4348daf1bb50a9fd149d2c8a0c6438ff2e81fe43e981c0247e10f53402b29631d2c04b277a53ea18701a7cea1ab70feb2125c8fac2027ef921636315c2fc29257a96dc578972a79a838fcd57346ebb73b7ebcc2693db13648a01be76b434d6316afd096ebffd441f5778c5eba07ed65b8cb125b0e323e42f9135afe893647636d347bf63ed11f2146ef908a1d0eeb9bf18cffc1d473dfad780a2a62a7a6a4a5136d2196bca720d20d291a4dc305a8685ec02673d39c866a8abce267541d3cef9679c434d0ee592eca983959e9e7e92e873b4795f12f6ed40707e55c771c4076e222d528c098bb81a756d6544096cd05cb6befb09bd45a1bedd9eea8f12429e1b087791f898aa4065f6ea87dfe34b51c232900635bc6574f584a7f8b36e48ee6c4ed5fd782c7be0d5219f9871a176b33ae307e5dcd8d145eec86e5a1e162c386a0464f8fe2090cf0e7816518e9bb2714a2c22e49bc0dc0bfb65aa5fbf26f3427d7860d81b17efe5f9c46d94afd0acf2b80ce0f6d255310f901e801a64796094fd1e51200e6febeb303591a2de641374218581741dffbe1738e92f6631c9533432c4f64118ada05f4d7cd2c61f182f6f0b4a036e6cc149ff7ad163c2c8a97feec2e621fc2af4c086a9ded937859eedc84522457c76db5cc16fe5c343c0d1fbeae20be21755cd923f7bbe5a43aa069e309f97191bbe83a5d635e8a353e89a6a7e7d70e337a1f3e439faa1e856b62b42360df29f4f31241ad60fef864f3355b25194b550a25737a586d9ccbfbc761a97b37a81aca3f999c6287b11f37092a506e0492908ed83b9a2e61d89072907a45cc9e9154321bc6a9459cb2f6e579136f4e06472e42acfa927e8c0020d61ba2550fc606776cd7023afc44be672193134044922f512b0684b4c63470c02592a7e374803f21522564781887775a941833249685b6a1f4ffc04cbeb844e76290d98f1d98a47eec0dea000104932b892806427ef17d87db32969a96ce501666a9ed108db517961c349ffbfedf35a0931e69e606ffea4b617b78db06dabcc378eece31e12686332f9536cfafbf07236b7cb4835e5ec6db75b9812fc691503fd4808700d9a3739685a7d4b56c20834a77ab1ef6faf27b8b69cf9429e0eb458d3bd2d1e97805ef05d13ae2ef434e8bd55c41d97d59343782b7fb3cf20c1527b147bbda6de7a530730c62d8e32625afd74cd35f6eb4960a5182a61b20f3d9f0b264389795af60bd76ae5a6515b8a44866d43cf2ea0da26ad7b20968c20d939447a44cdcfb4e80180c321c9c65061fd24bfcc781e1b404e4295841e4a83fd3fde5e5cfc80689638c2ecb756dfae278ec452aec60ca606ef207e470bb1c1f474748f9680d7e58e3f10ea077e48426c08e92fdb60b69b6971fae4f9f91ea20667264c026e65a71d0fe23d842a7b1fab35402f53be097c7221d6213eadbec8342f76d5fc05216a471facd22f058b4b614f8777f3e0c1ac44d3cff5ac3ebc66b3b5fa2b46a94d6250de040d9162158dc0aaab7d30623456d7debe0eddf226f5b1f06855ea040e83fa89215d1f0eaf7c2818e0c627c1e1f0ebf746863f8bcdb8634936ad1c66e0f9c69cbd4cb76e2259e512e6cc68be088faaee7b64cd33085cd95f2c4067b06097f3fb4dc5da2aa40140bea789be8625ae5c92529f1910fbee5945ed5f07c5ba0f58dc209d66b215a8663db4f17c1fe9f17803b8181e76433c9140e1a32f32f7934ba95e2debbea23e338bdc77556a2f663e5a01998df50a611235dee754d8d0de5a9ae92fbb9aace579db2f24d54a81b3e8eb70bcf701cdf36f010ad2ad792435867aacd465e615bec8df7e170de8d36fdea799acb08838ef6692c7096727b2056f952956e3c18bf7f7dbf6a8eaf9fb8000e5c3bdf93549337c486e2c574d22919a5836aa5b9473f71dd1209e269c38476554e3fda9655f5f5886eef062deaa644e87e96788686fea4aeb7aeb60e936a379ef4e63d5668059573a7db34130dd7dcae53294bad66ecd78b3ad1648747d5d232d8c8f54b1449f72d476dabac968f98a75cf16033b931dd024c3aad43ee5fe3895cf31a0ee156afea7217203a06ae9b444b45448282c68a8a3e354c65574fd88dc3ed1ae586c917dd806f0ea6df227561596528bf2a7213ac584ac83d08f9d1ed485d268507d12e7270e0ec6f254b919b4b28b0be5388c423f7ea64cda3b8728e28d469ebc275e294ce211ecc63301d0ec3c91e412d7e4623cabd3d12bbee11b04f52c98d00c6e26f99b642fc7001c229b60cfd21afe9cd335ff6a954e8e610e111b3a306078a0340edf2df5a727dadeafd405c894ec3894244c57d536cbb49fe167934de16ec69e01ea69b62afa2022815c21737d671bd886327751adee6df3074960d45ff180389f089842bffe2e92d415aad2489a21f46723818faf40dc76909953e28e36ff5749fc1ef702c82647397486cb5503c830c46eed113e798449ce56551aac82937f5a4e97dde38bfa529218e1e798a9db3bc2823c8bb51d5132c258ba25bd34024ad592a3a41d42f9c37f597749268dcc60e056fbf58c042bb1a7f558b93a5726ec3431ac747a963e086d02b6952aa83c9b62295f4929c675b2a7322c9d59d77bea08ffb22fa3f70b92b9cec99803950f274a6463836b1c26079a187449eea81f1e6039f804fcceb647ffd1127e75ef2811a63a48fdc36ddfdd31a6f56fc009d38feaf86f65d8d9013db9cc2599cf0d007d4011b2d58a617c3701305ea28dc06dee7226b1f511fe57ef315e77e2f195110dd3d2567d9bcff4944eb5eaa8c5e5806da0b88ef202d3c3089f8423d4b166fb9dc13aaa7f8307709f646cbc7b38c65f13e6012cebd1fd856466b2cd1703c148bb10d41dbe5a260103e815bf5d16eff5a5aa00611dcb9a8591cf3b30cd56a3e4959e30298299498ca78510c984865e8535c6981712db851dd3a6af6fad44fd8fcfaa4ff0605a1707a62b245cfd9432dad88a45f8c1cf30bd9b41e6a896cdb4240a4d9d460c4115b396d76b3bb90a7d6b89918fb522e73141867bfaf76e69c6b727e746f8e8991acb9937eb997907bf17f1a142b88a4cea9d0f2c7eda5e499f8545248f593af1effe66c666939cf3bab678ca06bddca19a5cf8f715bfdfaeff19bb7cb11ecb5cb1616ecb348ee5dedadaedfef877486818b80d0dfc99e120de715d3a19b6842852eda6c4e6d37ed841216395114445f0d7981433648459945b4d6d539f22e33d451a64b91c537fd6aa774e968c042bf55dd0a223859e7c5210a4b88d50a48b793f63720f5c0df5a443ca2e969bb1147dfad76294d3b90abe5a0e0bee2f9077f25c3ebd47cf353c978b49731a95fe473804d26214413f7a548c05d1f8b9db0d851be9345b369941f705448b27d9d262aec9e3967c357a625f08cc4d200316222cefa0236c73cdacc5849566828b52bb21950c7e00bf20d461521cc34b1097d289b2b0c9d8ead702b7a5bc8a4f3fc9f5c9912c88a9f4a13ca185865e1c9e6196fa37e3c729e75d6eedb3e48fc03a75886413caf69e29deb72d438e2e7934b68d732868e73b5a71a8b26de95dd110233e708e225b726854815b5944e0b0677037d3be375359cd853954612aa8dc69b88a82d790cff06655bb7d7eee7da66fcdc40d5850f0bc6cc31fab6e99c58e42f3646157bfccfd25f2a6fd6f9cc9bf479ef14c3b913040408517163e5100c9ae166c5692daa5c59363bc1f8022727dbe1a3ec1f0c0329691fc7d62c2fe00f7c34ffc03f8283c0ced170a090fef1df284fe2f02543ae54680deb97ad4d50cef8c0cca557099de3d67f6ead678724686df9b95a6ec8cd5e53a8e3a28aec55aed41181dce87a46141400be02d4456982cf73fb10c86dd949b50890997d62fcd06233fd04bcb89f5f2be20d6fe5a0b8574bc988bb42ec1377d9eddc0e0ed586e7f586d0e7d93b175acd7ced2e667e0bc420e77753b31b2fecd3dc7d5494e774c41e0f674043645f5848390b101c2f41d21b566f3fe49fefce4f18491e38cb5c65507a8e737e97effc48a782507cec1e6e04d4678d7c9fca7c47211040a84d02df509bf89670b3e66f6364b7f50d221a70256be6136fdcd3adaeb78b2717ae7472c5baf7403d91a6dd0caf001735065c4c4929d71578de936764140ed5e6ea43c13add6a02595a2b4a39f654757cfed57824c87817cd1fc374d31d8b2d9ae31d60df2a568384f15738d154408776b3db021a6ffa1e8e29645aed57abc58c2864cd0f91677abe9b9b357ee2e56595e9ad7df4b69212d10d27d7924657e74f9f73b5a8450a4bbcb31bf9168dd3f4bc93690f370472ab8b53375048b9dd9bbcce93eca9a23a596bc6d58be83b93b2c3abe449562057d6ff18fb8c1c20572c595dd70bc0d1aefef08afe923bfeb917e8b5c02e4057add6a7277b5b3d484ec2c88159ce3fd96b39b076d904411d4005183b16ce264161d0148950ee65667f5e61afcd2f614441e6223d3d043991bf20b2aafc726ff100012fc80c6e8cda65f78d7e771194c50f3012b50eb988a3d4b60d4228ef31633cba11bc50c4d05ec08e94c79331c2fdfdaf109a4d9e7e9e84edabf820305adf77e79234b572616d5d34721b69a08fe514c5adddd6cc14e3dd39bb94ee2372a7aafbf2cd0322422681c8109654342f37ec71be9e2349b14b2dfa17094738542c34c07dae2dd32be853da67d3e51d29059f74bc41d0aa7c0697aa91b3a5bbcb1217480f058f2f3359982083149589f94b556bfab366d115930213f8076e9c8bbe5d79f20cd58d6cb7f3342cbb614fd3c2ce9379a3c5e7e21739a5d3fe8f4fd6e3bf34fb12329722ad4057575a2f6d0ee822fa0b01d912fe6b6756d241fe425fc7fb8dc601be56284a3fc4131d9cbde9272829afc173f1284f2f61070fc2097edcfbd4146075003fa891f8f806b3c7758c75464e2a0f3c5b94cea02beee51adca7d217b07005bffb8ec6c7d8a31f830cfc21559300bda7a5d2bf3b44b74d1650377700b9ad6924d189e49e5b119ac2621eb501f5ad61695dccf42a000c185a08a294c99bdba7ccbfd313804b55b45faecab86883072cf19c41ef84aa645e1a8b308807de86a16ebb0757cc1b620c9826a7436f878968cd8171c7560a10a315fcdfc183b6f21e40e0552873b39ac369ed6333ac087282638069bca635c26ed7415c77b9f632f0065300a8d28ee02fd4a01a5f40fa8d624d8c58790bdf145596160c2ca8d50cf588f938974127b8bcf60dc6eebcfed1328da034c847552d726e3b9e468e32dda9210ada51f8cc12e9dbed75c7bc5703aa6d4f43db86c3890a7af1d7cbc12b7fcff0df51cfcbb8961d0dbf2f894ca2448d1a7a6475c5f1324aedb0e8b656f17d1203e96bd956826d0d4ef95098414b925de3564d4ed588f082daf0296cd424373ca5c00340ec668fd2b82c73c88c87d53a1d511d525059bb6c0a6c9bdf55d7ca2a318983e94c18a0afa67e38a06b6e9204e48a21f5ceba9f15f25d0b1ffab76be274687e2b75945a75dd5d3ccc08ca4e19d09de0d04d86425c9879d5837176d44044b6e92581961cb515a9eadaebbea42932b73860b6275da4a0b965d20fb969c559107a93d72825931567f4c5e4391db061b957e305360f5f5d508097c48924d539fcd245947897d4ce55fcfd4c19715109e35c50b9b82bfbcca212853e4554dfaaa99b7a1d534fa874fc716734d4b4f7010bd5f4b33ca8e3468575e215c4e750c8150344e34ce9b8cac3d23e2bcab13cb86fe019f16d257c07ce3f0f3954af77f9ecd2f7d367cf4a6aa4e81be79fa35f8c26fe4faaf3f0b11f4aa5054ec17c6fd4098583cffe3382ba966bbdb2d2750b454baf204172161d5f8984514fad568f13f58f1f564144eb31c4104564f922e9c1e7a75f12a47d2ee2bd566caff4423937c7af01cc5731151d6884d544b18aa426f04059d889d94309ff6206ad5000f48aa4597d332face3f57f9c72c272ff030b1c9c7e2d2f109c9b484c90abb7732666d38004ec8ab53b64c96d359cd730a7f05cdef067f9ec7d96c9c3c4315241a376f1e44d63077c2877fd4e64def4ad170a2a1680e2f251d70e8f98ec4fcf1c9a1a6dc93909ff5c67056ed0096ac60e6c9a144cedafde63232ff1c548b680b33e9be12368faed4b23d67c0ded9178396896eded7c14f546781b1010ac5687928bc84811e8fe48da95c70f987aa4362cf56df6810bf28a21ffb8e70e53709e06ba4f466837fd954f8dc263e733965034e0bd96b421b594af79ea628f62879de8ab36a670b12e1842023af1d6421d6554191483f5a8d31621f8de7b655d98224761c0c337131a6f28b39ab77af5df9389d32740330d9471da370004cc73e89168d876ddcf93269f15010eb05596881640619a508315881ed1ccac4a36282db811cfd87c3bd8a6a07b57f2c36658d67706d6c9b0358232bc61b734bc269fbd6f0ba351f5b782426c0845061fd72128834f418424019e50465fc4e0078083390b5317702811da7ef6ced80b2bd7cd2c2e4f154ab8eb0ce0c15a545c0ebc3a8a01d0362d8f314f6380e7cd4c3c9acbb7cebf11bda3b1ede007ba86d1ca0f00ee6b4c4ada2efc4478e5bd56628e5f44374e4ad4142ecaf82511942260d5e3cfac8cd3b9eea72ca346d2a80467bf45d15ead42dc053cbf43186052fc32ff956548f718cd112843040c3ac0a1f169c07492a4f16f8eee618457c819dac289e405282118fbffc7d9a8269ac66ef538aadf90a4115a6ca6b7a7d0bf0aabb050c3004e077ed476bc2448c550215bb6cf7c12acb362a56c428cd6cff82127b55f5263376007813af6351307fd117ac3879be6da3edc5e3bd344ed3266a95a08ea63a6d4094a856fedb5bb8afc95f6541607cfceb2164b0b86369b4beba4fed887261216fdbe26dc669cd17709f7bff6061567c5b6d20b5a91a680e846b352a87b2e6bb9c9d5bb0be0c6eb91ecc29e14f8028cc8773770da9027fed03cd1a8b42fe11df6eddab63fa77e248a203041fa8c7410b2252805dbc83e8240231ccd7fb9fc02f4c8718c55af153706038116feb50441e7f0b1cb1006b79a1a0aaee371c652f7c0846c92f7efa58f167c74c2602b27d7100d06e0eda6741e0c53a426c08023edcdfd8ccf20b6c9d5c86c0caadbe4402391cf8bf04a149e0ae40766adc7c548156fe68bec2455e849466be45b54d48d3f3b3ee5c05c47a5a6ae641bfc60a4d6794f527b8f5c759e7ee36ba861ab94ffd98dd4d28edee1db676acf8102299b1981311269e97eb32d10f86488c069d89c29aca3e4a060180dc05b0ef465c46eee441da3cf8a47187aa782d0e5590f60ceb7ab039602ddd08822c94551c196702f8bc3347c0732fb6880cce66c085f5595fd4222b8ea8a27df24ba328c4af62d6961cc114729bee7691b58373f7a21962767840f6751d2067c6f4d8d6a15713ceb7fe9b66744d39a94c72d006046007f70cdff6215bf80314049f9f920b2e6494d742b081988b382bd967bfdee2f56cf6717a7c7bac389d09468efa9884f84db27f6d9b341d863dc8ef14536aaf884d75013cf278c0df0796ab40615b0080720bddde46c4c7c72cffa8db60452f99b7f20515b8fff57ea2a30c671f636af47eba02ea052ada0fab9a09593e2d6dc0d9f85ab0f4320da2922b8142be074f5cf4b89b6f57ee83808589b344b06641f820ea911b31b798d27c16823ee06fb351e289e7bc3cd7480b6638eeb2b36e3b13e9d3d64f28427523a65e203cb37e3eb937b0bee59fc3af2273653284512c5a3fa1aa1d7ad5a1011f502f4518ddb7a6883a9221455a93f673c0aaf777e82d2c500cc08281fad5d1e76d3c8e7285078c082282a00e57a38a5630382b325e8b2f7fb5adc96160124d89ff3935ee6969b92a60a1d5ef948edfde12bcb0bbfd832842539556239625998a6a78e3dc35f4d58b9359603aba59aca82f6fea20c7eba33de1370dfdd2201b1912ac14c01b0a861e3c634d76844d2c636d8247a006734d964495a2f1c90988e56bcaaebb0a53a9dd715261fa12977e6f5adce93f8249c0d8886778247bebf9674935eb79f744c1d7177b54f3fb4d3d5d8d0a9287cc960c1c7f51ab70f317a1c3e1861d9104955d39c7db7a2f13d6ddf251685f6fc5e238f9400062d604a1f30ee61e085dc264c428a30d5992d54c1cd8ecddbdc347c9c3bf9671457fa412158969a36444ab2ffa51053dfa4e93066535fcb8f95638c41e82ade75f0b4ce602d4da74e7b4ef8c0890c345fe451cb2f1cfd81d3af5e03e33631c8aa87215075650a6767fdb8950fa25ca8de0e0cf43ebf1884a7debb98454fcbc586be7da718aea979c5c9cd10335861be94c86005724e6b4382fff528ed2e3fabbf25b87b32fd7a06f9755da3fbad889b4fc4a008d04ea7f2477181a008cb100a34da1f5f48769dffa282e04d81a23e22c4404f3438b99a2c7c64a5ab602cc1040bf1da113d2b4e9b3cf981679d37ae0964c375bc5b7169060ce6f1d0d3fefbfc17b3d72a271b4a9e69117a83f05e5ee25ef462e46776cbcbb448afac6d80f6ba254390121fe623bc0cd323e2a84e72ebb2128ab66ae84e507bfdffc735fd5dbb4313cc29673064c8fa59024677d05603292b41cc3d82d73af778ded70e4addc4b39b87c4dc70ef209b43ac9ef6bfa31787b4bbaba25412a404058e444152a752d48dd3657b59783f8efa5a1f68a09a53810699df0ebfbe1d524333a4a95e9bdfa3f2d30e2936a8895d5910aae90ce919cc4bd1bf96f970fbf33f0c14a72432b6682cfe4f592e05484341dfb944cc6c126f0af89bd2ac9a498f70569da8e390b736308b1ebdf445f5b9ae656c00d5bb21fcdc237485082ac88da2f071f90d1d64bd70d21f3d739f0f0eedf1ed00c272062baa0154db35d8484f6f59e34d709dc71e9218714dff18bb76a9c747d89fcbf29ae98383b0136dcdc4b1e780cd25962ac1b3e9a14a51ece98a94ba47c4eff7b5cb427833c6819c10bb078f8fe56313508566e03a1a69e7800d66e8007383e257d6056804805bae4fbbfb8f28eac356799489ac3a4acedc940b3a6715eac1ca7ae29736d63696ba6a4a388e94488790f140b6bb8963e656c3ff857362f7bb1ecbd4d675a1038d7f0347e35e4a3e31278940aeefa82f7d291ebbfe7d7594ee302cac37106540fb535d982faf8888e376f65ce4e349bc33e1f2b56d77d1a17b35655f4e9ce75974e2f3bb9c79ac9116fc92844d11c070b8da3e24bc26fedcbeb559ed78854f8602f39ee28000d8cb9c51b6a0f554d8081a5b86b3d325130909ccd06875d7c97c5bae08fa3213f4d7085df0bd3b68aa89f5acede2bc0c2ea11a342877b083ed4f91995a01cab5a68ddeedfa1e461d2d8eea4b1ee75fc091e691b3aa8abf95661917517754a5c0bace2333a27c2e70c3f1492423ca0d8f73250a505c8381901ae1e2a89f0c2963a977734f760f2fc91ca06a32d8c58955a43afd5f4f19bb7d76d5f97ca109d1fd4134713b4b4930c615cb24274b61123d80e207d5939896a6fdd0792e1a684a1ec447c47b2e441aea39c3edfd0e5decf49dfe1ef2c93d1b3e2490058b0563a461c395ed73b0f1751648ae2ef5706aa3b4593c2905805198726d0e977cb9bcfd0fd2a776b24d6fbbfc3fd7e58e1844ae86326c9bc2b97c790457f1d63ffc604c5b3cf4cd0e1de7afc56402d5dc064c1e264a5e7358b8379804e7b57770f961758a54f003c1ec366db50128b63c5dbdaf7553fd000eb1fb1fa375fa55059c9fd9d13035796c9009063c4305e0a111c13316b5d24e1439ffaae4673874218f520989abb57bd595c37f515a3e31dc4dfbe911cdac6191214c1b6c7911327903061b8b7732e9c236cf438a4602a4947c70af0261350107268aa2056bf36b579fb439efaa246089af329ee5fe1f27d83a032ab8617e10ac3af8aad63fe3d99a897c2d98fcf4061380125439054851440a7f3be59027fe6b6f339ab5e1396587806a8a3fe9abb5dba536663eaa8c14254b40a828d845904f13e3c3f85e99ffaff1ce8795344f85f4217d7aa57e1559f1bfa780cd078cbafe966c86894aaecc99c48907dd92c56fada3b64083c2b23f3a9678030812870a5ea7123b6cdd52268cdcab50e0303165284c249bac7331a010775e8bfbac730254a675cd062efaeef9d5ef901f1c0acf78c8ec87bcf874b7aa544e2eb27297f1b0bb4b1834bce85865a80edad9f8cc168f99a783daf58cc49a0dbdec05d5a686c944f9905d12070ed6756024fa507c996316f8c33c6b9a84a2c0b3826a082f1a1692bc48e93363bb5747435919a3c69a942ae8cb3b3c1217cf715a1b72cd2ad6ea80fac017d6fcb71fbeefd9deb68898cd31a627859baf4b7f405a783b05978f6f86e9cf8c1e2fa00ea3fa1bf9ffaf9b626207c1bda7a632b77fc49edc2a498b68a4d993d8a1d148df4179c9d2414715b22e4a5506cf90e73bb869e0d9ace3f1cf0b8ac24bee350a7c09c889dd82c5a79d8c9a1417099a5c7c24942d267631a63453895d35872f813070cd490fafa2c5851efbac782b7f31b6ba32e1bdf38b8bf061eaa4949ad230fb658f1f9c0ce51839fc9dffb5b51b6b9b15dd422c0a2cfced5d13bfd4b35168c15aa8e654ded0f61b36fa306a8f3d61a7daee1ba25faec7398ca412768372c8da42af7a23cca298b1d9e2c41b6e916e0e1f10c132a132b181e07a53605ca7e55f751796a75946db31af51225163259fa8f2faac74cde97a132b549bbcef1826af13529651f9d5f32aa37daf6f490aeb54b7db7e4006f3287b114843e04a429c60055b36d9c7038d731f7fa113bd12e1b11f082252ccb11071b36073fb456fd1d7906507fc5f2576692cb979dbbcf4b1b071fa90f4835e2ffd763ff9a9cf0ed9ae9d8bc322fff19e83647e763ee3409f8161665bf939df7c96be37c4ad8b7ab0d52c813a108a240ee89cfbd9814765a185cb9bfbe39c18f278f9f1eb5abf622c980875d06641e5656e1ca615bd8e383ca1f5fc7586934e933f17012e97ad38aa3a3a4e5c775ba040321c66d1e340d88a896527169f88c7f4269712bd6c26cc7e226979fe0361b72b12c79f6a0866320e4acc36b26adf6e932ce1e17fbd5b05125e9d4942a2cdf3efef8283e9bd7c6015066c87487d6a0d1bf9ea128b3f480f5573610ed72ecffefd3a90f8e5d0f9aef8977501587b4b858268662e40c0f0bda3d10453159e274b14e024f166b1a201606d05130e7316be0ae46d871c8cf682d80c24f2383bb6c539926c367a53e3be32de5f382b42af3bfcb723a5f2e0ea95ced7907a4c8ec8aabcb635a394e336ac70a446952afe8a04fee3c8e6b6450affedb19874bbd70b65bff733354389e406e40d458221fad6a9902c467a173bbf6438abe55b120269e0f238023622dabe629994e54dd1bd9c04c3812849890285a5ff37de47540166d56fe5fbc10f0ee0f1c879f0044f823eee3250fa08517136bf0304974d13d80d93d1d34efe6b6a58be439682475efda1caa9c03afd67c0e4c6b159cd7e989ab1e0bf0ee67f0b9749aa0a52b783202d464fbd0ba41649410893b4f36ab62f7bd6385002a7ef8469becd7461e168ccfb12252d86851310d1bef0b45f9cccfee6d44beb4ed8c976b8fdb0bb3cda9b3156eefc07ecb432904223361049b30400c726ef33d3437ee8c6dd11136b017c3aa5294d801b970681a203778cd88dd9a1a9a99633238530495cd612daaf1a18a9f0d48bc9936cda9aeba98d9f2dfc1e5dafdded46761ceda4cc3e2da72cf198982186b255ac46bf9582da5d8997fdb73e595551f5f4aee5ecfafefbafe88cf0034eb90da43b947ac9773ab3c8ef30086c101347f35aaaea8633742d8c835b29e0e5773e0cad60e3bce3764b2a4ed95c4f51c1e338d08d158e1f1278631c942838c4cd11d731540c7726b573909857c802b828c5d587abd53d656a9d7766dc70f5ada8bd7b315e2030baabab11b7cdc2a32a089f0db7ab156ff8274b897453d64e22a6f9b2cddd77b7295b2768981033f8ccc24b5544b80b71301721351eebda921e223c07b5ec82fc861ae56f2f2103e48bcace0525b400790ddb7789a31e497f11d8861f0f92ac7c6f253fc088a3dcb50e7d48695d165516560bdfa70cf46d0349736fb094fdbe5ee79e4c6858d96c9dfe13e3fdc78fa13c8573011352e654f6156ac390a5ee5922f65752c2ec407745adf87671694604737fe561cdf4fd2111cfd23005b1d65b9b7b81be33055add5055b63d4112e61d0711b3b0bd72bddf67073845a5b140d48d4f980d89bab3e7687c14c9bc89af6a35873205f0776799732b6c99e2213398ba3b2584127b472afadd8fb4605aeda40f2433102cd2e6be14684ff706d8b661c5bb2ff0ecf3a95d2e5840f66fd8176f8c6cf2f4719f558f45f9d434bb9abffb00c9d65f8abaaf7143d1b4f75968ed2e488fec02fe5b29a8c4dfd3e94da21dad05ba5e6ef62e911f5a315e98db55ddf1d303885a94b7f12eca78216a6b05a9d73259ecb4f3eddef0ecfdd91453e8b50d574ac6ce18e5ec4cb0c4a578af717ad02c6fdb3c5836b364540f1048250642453dd2c8a3f1b908638b423f6791b82eca7cbe45c317af2e152d1c7baa3946df54e5bb0e1ab0f2408b5b4b0da8acf0d378fdec22462bcf47fa7ce38d9c2c11001d40bb2e946ca1034f34b77ece43b5820fde733efd336aea49e8ca8fea14d3fe3b0017ee540fd9688e7ff5f4ce00707faf08054ed89be1893f2e35c9247205e49371b39eea9923b5e8d6014ae3558d8bb516e2eef21ea94780f697615038af3a4a0cab32cae36d51dc2ad87ae139b356e82bce7687af790af2f878b89df3588d8b9405ca537ae115e05a501e3f672ba65effa22d744d56a6d11c4659889bf80ec08639c9db19e9480c7d7c819166e287c08a86c8c6395d3b116a443994bda46df3c2cc2fa15ce786929beb7383cf9bc13924edf66ae0bff1d57c5ec0d76534f6c91d81302af953b672884aedec1343442058b2da78be95d27ff60f6e2df8f1f59af21a51b522d33c7fb291b896909cc2742e6898a4e54e6eb21959813aebb07bf630e31389c02d274a74f7cfa9f5c4f5f2c2932ae75a6d16d2c91d097e9672986a245fd66b406efeaf6af642b0466d47024e6838923e3badd923b7c27a13efe6a7dcea2185503c569f2ed308a832c2e19c2f5f0f165961e0e0c06eed385da031360cbb7660dc4b2c499da8a92febe88ec68a8e9db17032287264cffe27229be6e0b654b249460868a441a5204008338e2b73ebd93d4cc91fb0bb8c04a45ca6ecda740ca2c2feecaedff948e8319a9fa6346647503b857ab165f961b709a7c334caac27e76ba0cabd44a8925ff939c683d0ed9eeba6604a525d55360fc6f040570b804c5d64bd7364b8b6ce09558e2e9435588b45fb3b864ff86c5adafb1a17a1427a664bd568d940a96061148d6451866e65bda9584e4323ee25c4a08e8ff2eb4957e552d786a74424386145ce096a5f20f33b939d0978a90588ff489b12e245cd6791660930899298950f5be0ebc3a6778589be53d4a0fd764c49692749b9f76dc06015623541e1b57490313cf04d54a106b007885193e3f183ce26304f487d891139778727a29149818252150b453139946daa819a0b5677a12bd5e28ff036cfabb4cdd29163b10d767e87448c8d52b5ac20eccd19fbab2ef9f4a390b71d2958d97542b482262f070d540c5884bc6103edf22bc81bf141cc23d85dd5b112d1f2dd1ea9086b2a59d7efedf3d6a402c0eda86202f4211a63f05d3986f32a2072cacc569e9e0a50f52b537a4b35832cc545fdd4eae23846713758430880fe1023c1d5bd24d742c5e3118f4eba27bd84ce293b5f0508f8837279a6238e2af700fa28401f37c998a343a74ab896189e32a5aa3b1e7d28c9a7e7bcd00fb5fcb4350ef01436511a28c8129fc0a1af0cdddd77de6214d6718791122007f2bf5d3ea25a04d3de72f2ca79f6bb4428d6b15ab73f818d226621920a478c19fcfca3b1e43eb534c98a82bad5d55408c1bbb856ae80241731d15da849bd16059d36fa54d3856cdf8035639da23a1db267bef2819f0f179874e50641553517f85a8d446137a5a847dd273bede82e10a8d39479e3a80e162b66b91457f613c8e660fbfe78b3018bc2b7a8573bdf1666b0338a11ff04742069567b7f2dd7079d31368e738cc511d252399351529a4290a792919cf0a3c3a8d792dc5a6e90d2c95f7a362107a87da6ee2196c9a3fce8b0d2f74b0cbf031d9d75f0673e40b93e5d473959fd59ca27080eec6c438c96e4b0a18b1850263a7895c0410b2a42e2046c274d27f8de65a729a8fe8c01922f7ec68da11f8e6c750d76c9009a0c41926d083d1f7849a5da7732fdd1cdb81b092b99ef5c3321ad2f26ef402d239b8e6fb0c4ffa6114b3f032d99ee3f2b34f2014dde15b753effed481af91b7be0c5a0fc6f039186ba43e5ae96618c31c359b4449f1343d42765728bd33e35ca9c9ac9990f1e1ed7e8723fb0730f9159f2a864fec0bf08b813467b1fdce8e55c5fe3efa11927b0267b93b08cc80969a6add4f02fab7df172c37e8501dcd9bcc967a0398287378b0e34f06a1e0c9707b0703840d3dc23c8de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
