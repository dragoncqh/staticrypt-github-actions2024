<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1c9aa885ceafd393be63b8ecaca5b53883a424d802d94d152362c206fddc1f6e76112316bf5488810303a7440f93a47292626a3b5fc9b400804cd194e6969b9f78a9b94620d34b03eebb2caba32bce614d92c29489f5aab35ec873ff5c5030a3077d27ed68d592cbeeacffa4e0eec1fa05811c6c6ec39f9f1af38aef9226dcbe3a1b79d2bf214e5e78484e3e834b1b70023547ee16e7e3c4e118c9d14905eb18371ac3307d669d675b294b1a6ad53317d5065fd66f651d23440c8f5980bba6a16e63c45419e510ef2f62eb1bdf2e46fcf26ffe441dc7e8ad04928be47f485a8e8b040dd555dbeb9e8a8c4d66f5e34a1e56eacdc48985316dceaa91bd5b2ea08622a7a62ef697b5ccc11c48794f9e7fd61ed4627dfb56a6d208a705d9f2634033cc13ba46e0208830935e59668d1180359393ecf7d5ec11b6d888ad81bffdfeb18b88453fb2042f583167821d9cda97931c8e17725bff0e20dbb30efba1d5ac2178d0dfca33d2075290902ac706e03f5dfe325fe01c17ff1e55caad7cb9bdcdf747c12b47859c66e3824677e649f2a33699f7a6d90bd5de04a5188bae47e5960bdc9fabba00822a56290e09b1247fd488bc5b7471a41e5fcf1e80a0aa412b881c7f33b405d9c1fce4a519d96bdf36a983d3e67ac56edf9f581966b6a9f54d620f23c1337c59fe9ebec55841a023607bd4980ecaa2b753fc5a5391f6d4e8deaeac1a568eb2dbb8b9ea6d4750248eb32399ffe4badc2178250950ff577899c0787d81e19ed085f3a67b70d21d55e55dd1521235e257d2a0a7dcb438800a34a187a1e62cd41b29f5ddb3fb2172bd8aa92ec1b49d7f7a81b1e3bb5d7036c2728dad5221266c83a7f654d4c58cd2ed6b41af2fa594445e88fe6ce5975d25fcf8db7443015188feabe8d0c6d06267b85d4eb82977f62536825c9ef1202c19d22a0ae271469f10b955447f4868cef5db0d3bf52f702ec7009d0f881e0fc4b702fbd5e4695ab8838509a5e37cb7f3a86ca6afed15184d87e6033f34978ae1d1a50bb56a134286cef1527c989d1522e4d8bc3f4202807733583af2c121b692b5e5c3220eff6f5fe187ff1b64cae60f06b18def5defb2716f201ff2bbcaf7c6b160495a653da2481ab2aa69c24429e1b754bb0455a53e1b93f514d071322bf11d52a534f47328ac62455b471d5730e7c78266ef6dbf710644b28ad62c0f12a0db0c8f35ecb4782111a977add03c3469feb9a7f31120341f34a031147e16e8947f10000888e6fb767eb4323c99b944e14f694e7ec0a9aa1cb64d0eeea56a9a1b009efe2977289b9243bbd41fa8cc25c63849dcdf672b045141f5132ec22feb2e29d6b46a48db4b7f99298573651e63e3f73b5bf265896edf563ab446c9229e087d583161f94431930f03a1925926845d05e9300f5f310719b88e6e8c3c8ad62e58bb2c1c5b050bef0a58bfcdf1818fe988a12bcc49bcf833f8816f5fef67ead649ca2741acdf24c07b116530cb4ffef6236edc9da7bba5a133863903b8f10452da2d445160cdb7b89f82a68652fc93f1652955cad8613f99a363376c1ec0d0afaa560713fe2a07383179b844c8818031a2532cbb80a08bcc839024ccf0f1fcf30dc2f09c78158eac9a117c01f252cbd51c3ece200d8ffa787a770b6e0655b16287ba6d96b976c2cf87da24fb5ee1440aad736783e92dd0935292d59dcf4a1d4c52ec763868c62ba77de25550b7faa8627ad846b6dc5279954d05b7e932e9b4adabd6856a1c2ef8d242bcd7839a8886bd9783c11fc7bf820a803ec09c1b1f09c6c188da8d426fa7a9f044926a31d3ec02d62df5fc17bd9d20ff48991c98cb9135d0dfff052795758872054ff104769300c5742c64d5015368d247e097cdbb73a04e1325cf0786b0836303ea91ee2370d245daef1ad96162716ee25e8196444af08c7b9b159024f21d217dfcce2d862a9bc5531e28567ea214b1b2d713d8c5a338dba8fa4d0c7219151cfadf6f2245fbc3e074a90d3f9fd81d7f9f6eddb94af9e94b1b787eba268d0fa76d49944ce27ed8e82d76819a7d06749e9462b52cf61b4bf661ce50bba11ef9ae5887adf63ab2ce742b1f2e5d503ccfd59caca816a9a94f275459ab62119b72973a26ba6390cf2e118cec28f2a88cfad22731e95afda74150e7953281734c83a6779aff46d05eeaaa984bc6c3e23dec81478ceba9e9be09f9ae6054ff656c9ec4936516f5d6c25074fe2e83d08caba79e77c1c28012e6c1b9fb8957689c1670993f3b43a9092e2d16aa46aa6688d63e593d5b3c858ac6340469f7f0b425295657a90f99afda9522d434a3c95d515371cc4d62aebff3f984c04237b1b57697f72f934a2d232004438cc1533bad79369819f4cd2f729b4195ec4f1520034a2e76d24efffb1280e13d709b37d71c312d1dd855bb3071b587545e36fc7a1cbd7e84bc719a3e5ebc46707adfd15c2c16086070f11a5f74a2b05054dc6afae5d76d67d0f0b117d8b3025b0a18c36ccf40a1b250249c0ba2d6528e48988799b590f2c1915a9ded21bcf5e93d7d16f3b6538b3dc1d95aec04a2455eb1b03a81f99fca7589c622c997ee91fbbe9cc3b03abe0b8a84f8bc9136cc379dadf1bd638674a30aa7f3bc423f855fc92f16d209245783b143876c609a4495d9b6a4ccc2a6e9cc06b781be6f3e1dac7056c819c347847b9eee6f8a0f3c64bdd282760248259e2afe6d1579fa1a07d350e7020dd71a0e33c418ce0b98209f66102e6f5f7b99ed4c4d918f0193cca957c2653ef1c3e05e6d3c483121bfa766da2f650b2972c0b96bbe7ed9d4856ea4c14d28620e8f07bf9cbe234af4ec0e10e5ae3865a1c84676cb0fe34495a5c70fefbe5502d172d7e487833143398b9cf2b6e047db8901b47fc9e355932fbe8e0f1742cee268b561203d598d10301a5ba48a7274e4b2487e36d0dccbe2cd97ad2e1f3b119bc632831be3cf413e692ea9414770f040d29997052bab3dbffa0cd510421e761b2ea580d7f5e9dcfdc2bd8cda3ecaabecad895913fd8c7e54537a1f588c346bddbdba7834b74f705eaa1ad4fa933c608f53cea28f4521b6f60317023c363cab98be09d4498190df96bf29559bd992479448527c35773b57352656fa5e57e606ce031cfad2cc17a6142cfee1884a5588b6838c0c7ef7f931f92161ed4af77ee3e51d6af752d3385d3cd092076cfdb0cccf1bf6ebaa9df3132a4f68b76290a7af85b17e0f4b2da68298f73417f97ed8ef74ae82d00cb92ad7ee12a8e37fd4cb474c37982605f12c359dbb34f7d0bb5bd2c91e4e9aa6b7efa16f5297c0608255b9a5ff05b1d3f778a70be82d7a932d2f57cc10e74e5de6fd5cf5117bda8ce350ce97c7b5b733b990e235b84e5e446442f94c5dfb520cb478933025fd592814106a94e6227ec9783f4c92081939949f0b9fd653106fb2d99b08b51eabd66a76d843373251d42e357f63d8b6cbb169b16af2d8e47e5bf8630342444c088058ed74797b19161aa62919a746125d80be1be8b1053bfe58c919213d44745b5b8ed9c036e7ababf0b5404033259f69626745aa3efd7008ae6cd5b63fe6cf242c1d02842216ee1faaa85fa73feeb784ff20ec35752171250a871cfab7efa8543bcd455106f40e07f9a37e883e822f854f4ba7c4ffae47b877a03b6fcf048f6fd07f71da97fcf1c25b6f4641bf7522b0cbd52ab0105e5c1917d051f0c520fb1b7d10ea71a2282c4549eb46baa6b74aa1029905ac0c7e16483fc2e9d6d76658abfe8eba3841f9097dcdbd0a0f89688de181d4066787ce3269c825f940079956919a53055d4ba010a7b564204ba89457312c9dc6a94abb89ff3a4c4041cdfe61a94794217f85dbca6d3729e4a0a70ac423a2a117edecd499ee4f898dde6c195c96a5e0f1d7358361a25b3cc23de1654f0ba34b677daea76ac16278643928ebbdcddb57826856470d5ef8bab9b9e6de5eb02f132717085167ff1e7a9a15cfbe64bed1adecea9340ec3a77fcc0b05c55e7e2ee608e3386328c8f235e89f2213892c755aa4efb41c287da45da6c857887807337d552660675c4e2a0f961b1556abb1b2bd00e9ccb5851bac3382317a34be7e741fbf4dc54a9d58dcf7446f3ef4ddd6bd45492bf9ced13cdc5ab8b9e43d7d668bd521f7cd89f2725a89539af5ea9dee0b6eee8b7cac49c85964811ea123bdd544651382bf756b347cbbeb30d4d1433181e3fdd5131ce7a73b8e0cc5b4153cad4e1edfd3f68156dfa97e5157484a1e91870a731c967daf2e4283898a4fd7a59858bef8d37bff947cad2b6b3b43506a87d542c349eaff4c3aa764d70874075b4612fd26e9acb8fda231e21d455ff40cf43bd99fb0b796555047ca1c574382cc37ad9e4303172e3b896b4187b8a9f978fc1597e4f53c03cdfb04adbc70eedda5dd34722b4cb95c97085456b58c5824ed293354c0d8207f4f2d712ac6ad77f4d03372c692a77a550504c153b1bc045517ba9a3d12cc1c67a2fdd06ef343cbe99a476748aaf5fd4f50728ad9a468f23d6830376f54679f183a31e64821a914748b52e693751c4822554e19871e2e82c766dc1d185c1328098153e27d88c05fb5d385e42a95941a36e96693e7095cfb56738607f1500f987ed2038f15ce087cf53a92a947bda6d239fd3eb4aea94c86075bc6ae711f33751d1654164830e30c468836f60311e6d38e6511511b036a4a0f9b103b268f2554d5dc97a3b1e2a11d15c582b95b3020abbff181cdecbc5ac43e00df6ef0b8cd34ed195941d50a0ac8d202d3ff217dc82da47ea0146a020064551f4bf5c7a91a5b1aa326e6ff8f2e81123f4faee2ae8b9382a531840e8dd167c70e36283ae82279b883aae6ce9bf49d9b19dc6e4a63024d110805d1cab987e502974cc28ce371c10e35eda9b21ab19b50770937cf86330ae43d97bc7ba6164696366b5e96c34f4130b649bb67aaa807e465180e05f22db8480abb8400413ee2c933cf489448fc94df4ff027b5108669660b073a33c1f6e6900849831410a67c7ef6eeb4df8dbb8792f984ce74dd2cea757c70341272ff3e9d1cc9735be8256df60fc28c4dd2a840dc280203d15a45648db59c8539feb97f9e5c76c3e63cf6ee2761f9acc2ca929b584a7260ace535c36d9c896e789bcff606fa45cd58ddd4279f7d09fb1ea972bff1498e9ce17361459f3e01033333549acbe0eb80383a6efdd21f14b4db3aada57e50a7dfa09f22bba4c9661002db94ee9d14f13259a50a04dfde28d5d32dcdbfe2a8daa2875776cafd518e69509657997bb99427cb1c025f0e9b09a0f4167b5fcda57be764a06948766f6726903ccb98aeb40da1b9961838768a63e294eb9957c11b8ffeb20c11c951f9dc9b6d47c28028c6dc7abb1fc8f710a9d4b27f23605f0217a2eb619d2b2e8549ad2d16c3ca7e4b1705017573a0e62a4f9d89745a2321cbb701dba408bc4e26d70f3ac2269df6d82276ef4fa354f55012b85f19d4ed8e1ceaddf00dd77c252c66b083774624393b2786cbc003a801f95a2615d258e839493ed70b0b5e28318b5e3ec3dc1c4db66b155661ce477fd96ed797f7f5581abb8fd152c8755d15e873f93602f40f0887af50241062e50d33674497f9c8757e18ad036cc2fc1cc0f69fcb44c84d2e863a272c615fb7019d3ee90c7967ad71632ba66371f60aaac4ff0830bbad34d17e57a7677a73cba3987fe76d07f8d9e28cc7b3bfe57e272ed8526da93f0d6b9ad2f3aeaa2343546d22159dd462618e2b4996022b64ac780132f0040426df9baf32f90a7525ceb5bbb7efc9f037ff6e51d58b375074a42bf895725df44f0a874213aabf816d0c4a0110651bcffdfd63b3ed795bf14015d3167f3ad2b2b21b7c60764667c067e8cc87ede3f98e9f348e8a0dc6b8bbff9147b8de641b4662f1266449bf70f124a5522a58ea80cfa07db6fd04356a2642d6874c2d3b454a6471560bc91973c31b630d2280c028ff659e0ae22e7f8c9084191853d87a7f81bf49eadc1622e4a03f57bf22ff2dd70d8d32eb92caf6bf27e581d3aa898935c1065ee8a567ec18bb1324f7bf5c797a124507dd5e806667a846be0ecc828f015ece67c0d2fdf270d5737fe30574cb80c493056a69b6c936aeb316c7f10bfa2947398944484b0062dd95da90776908324445775c028be18c7899becf0d15f72c4afcaa9be3fc30f1e53adf442dff6848f41980295fb98c068815d25c70933d7e94683265e5c8d3c99ee5fcbe29186ea49ec6cc96718f680decad0e762e4985e6b45d7cba9c92198b1fd7d037e4a018c978f5930e9286a922021a035e9ef39c6a9c911090e02c6a6011db3ac38c0afe221acc1cad46820e4bb70d1d30ef15b0afea1d0820825a676691fce084666064810aad0d45028acfcf398027b5c9846b46a137c7f73581ebe21927349b22c90789f38d57f2dafa7456e3081af5a8204139f09807a2e2fe9c3d1af276fad951a074c70752ca9136506a72d806ae150f4fa302c0add0b234b7d528f98fb5c7bfd881c21887f7200a4f24a996548f47fbf952c867031656afa7bf368fcd0944433dd36cffd014f532117f82323d8933b8d5413a12023187ad597074ea86e60be2b4d4c40f6f8741c5b4b323ef63c49cb41ef2ab60953aabcaef2461eb86c1c64e2a76d0b80bd07d4d521aa95c544f514ff25c22469445bb9cadd959c97d5fd4f16fe2566a745c5405b45ad7446db13cf5846ade30023594148557bf3c7934953974ddc1053fdbfab140ead05927733a0e48234c430acc440531121138ab0974b38eb823bcc736545d285f32acc0420a35774e68e39976ba376edb1338054b624f6f9fbf8f48c3fbc0a5218f9ff10e0156db7f74babf79232feb5c78d7acd7b112416cdfe07cc3cdf258ee54c9b44591e08366a0bdfdd74da165b09294df81218594a567a695bcfa5e82207a0e8cc5944374fe87a7a0c1eef1e41ce9bd053ff16ecc09ac26dc2e3dbbbaf19eb669f964b3054c7b48a0dbd501eb9702de4af366c62ae251d62f2040c8f3abba7d4fb300ee31838861bff042321d75f22e249c9203338dc140a0af58b1c1d15e9017a05d38f6d0131f5e96fbdf5f530544adee57ced6e7d5a63f9e5ac9bce69d5832b963e4f0d3a13f7b944426cbe14b08233154563e91edc35d2bad5dffed6e032becabdf23a72f8de4c5082c4fb7c50c1bdaa8188f0ea7891c9ae4aed019ccc529aa98f1b43d67cadd9c799e7753be612676e4f1222c4851b772c7a20d07dfd6ce9830fd00f02168adbc4a54e2bc645e9070f817aa448053a062ef29537f6f872fb725889a3d566b80b9c9c587e56ca24d13cfb082176f3eaecb128f4d6843174d18dc3a9a92593a2e3a5ae0674f0cd0c91a8595d632f388c831fecbe43fd4f43dfbee11b0b808c8a56419bbcc92d0f51555f55771552f61e44148ce8dd58e9e770625ce8b7f6aaad0fde07a3ac5a9a5477ca08344f004145176ed92b56c09bf0237716787c5c268b5a84c9b01a100f7f4b700b6336003cfb63ffda96e44c5664d1f82c5c722646af83e5c6f73e1cf14cacf6e775a1f3461e5d8d7f678d1bc0f9c1375bcd51014371ab14b5d11274451d3158c6a0b219657dbb78a1929b421a0cbefe9cc35f6b35da2b09dbfab919442980a4de8496584ff541c307d50c085b8da5f1981860e304570e63c54c9ee3536318d3e115d4939566cd79375327f34188ec50f7d8709df2cb71b30dfc5ea5da7f66ec186ebaa6c688f89fbfd3a6fb88cec82f2fd40319dbe0fb01239b3406b9da251bb40247504193571ac6f81197d930f47e11f6589b4f11e73c3bce7420e6d74e9b7464cd2fac3f36cbcbf196461b3c79a6bfba3517c4c0eccacff0c63aed23c2ed078a341571f931be0307e4849f2175a7cdf43848e2b485f132bbb392c89548cb3aecc56dc45f26083449a41fa007dc11bd3b6038223c8238b4e3bfa12b723700504300dec238a9f87b34fe43c019e11baa3c47727e864e68c5850681b3433e41a670253ff9fcfc1ba07f828e610937b213aa4d9b6ce8239b212727c0bcab5beda69fb22441a7acc755742f933dba308f1c6a7ff9da5fe5b0794d0445d7407e4c291479d9701c4b3ed5ef1f4a6f675a78d31d514cea109e94984da1029da159ff6a577de6a4651eb3314cad791d4a424d6486566d0845b782e5e267d912a351b9bbfac1197171801138bb7c6b2d7eae12c44248e7b06d6686cd129cf2a436b11d71115d6d48dd791a45a9f3eb294c7dc2e41c06e555d672da6fffd3983cd5e94f52c6efb7e7da484f182d52571201fc6acd450647c1fd5687907156514999dad923278619c8bb502d5d57b2f5ab8166df0eb86ade279f6e0bdc1347e873f312bde4d9f6ab913b7907f9170617454b966f8cfdde82237a3e13e0c6484d3e39f24bd97808909fb430702d76fec7e445f541b22ae4140452b11d5715fef58901d13caf72fc88f495471249c708b89f96276350c0852b9225339522fbccb80781eb783638634ca43736ee177a11bf9bf8dd4162685588ebca91ab5a99550d97f6b6df0eea677980999f750752daf7704249c8faf6defe57f2ac02f4e6789c57be038f2c0e7b45b8c7adba63b7fb9ad3692e5a6f178c89f95881e0ec5f535fb98f59654b6154d01d9eb2215f6b5d696c53fec231d8783a2a8046523e38171a9275872dbe6c9254037e9cd6fcebde0180ac7703ecc1f97c8548035c753e5cb23bc9b9a136ce94c2b853a39f8a4980037eda4e68ff13d56c06a4e95b1e1cc5c2c845527a0b7eaed2e6ce5ffcf988e60214703742735813ba1ddede5ce0977d7e7f8f6ecd5ea37d2d4feaa8d90cfd96118c3eafc7f2def1b6ffe08098d28bf7c05522ffc09f3ee16f3088276c581640e820a45fefdb8519689ce0b0603be052ef1fa72606cf4dd45b783f79e8a7b9d8d7a5fb3f1509de1c4fa3ea7d134a8b5f78088c1bcfe97975f1343057b2cba7470d83b20ff9b95d1784aa46fa2d9ddd6bdc38ae706264839475b0e11a53337e8f855c80a88445b018b2ca480dd24496175c7ef4dc458ca527d5cbf5f1f062340d06b02e4ee919949cd0de29569867cc75160a3f8ca2b4b75387bc80f9f740f9a9b04a0b9637a28853aee99d720c5835b310f3d400b9280030d2b6ee07f93b0375befe239f3ad4e3b4848909d3926ea4e62358eeb64d06558db9309edcaf29c7ad60d6577cb1c565b5744ed6daf14e2f005073015e587e72b15bea3278197f1efe8320c67037ada3c7480a77e9a726dd9bc6b093f419c28a207bd04391b0dc59cd40d019f39ca2023d205681d3e1dbfb76c0a42784aa3cf9dbb4fac3ffa108f12d38eb556c407ae51824aa19710f6c9759987518bc6718eee9c3004e0e9889435dcaae974ea8f353389fcd4f1763aa3896ad87aebd73c473d0b6e4ca57cb52f05fb4dad6eba7ee9861c241fe701a7ae992bec419fdf54866e3bea0bb4a5a2d5876f5ba7c5e63ea7ed72734ffcb04c5c71b340e6e87acd7dd7e1409685194231c34deddfe1fed519bb7adba2295515c9ec79c28b938cf655bd1a4365dfff778cb7f7c9e2963e4f2bed1cd1e4688cfae1c3187544d58470053af6160477adb521a3cffa636b5d994befaffe60c70a4d5a9e47b8ceb6a10e2f313aea19b979f24c9fe65a6acd4275add8ce1383a2d914634f59227327b92876b2a8c42432dd5c65ad177dd5c9396f04a41ae959940e59e0daaac700cd851048d2b4116e1cc43a62090329ce3d8b0c5d710bb961583b8c5fd7ba84a11902060ee0d649b1587d532c514e5f66c36e38d3a1f11a82c805ddc73d0c97567460621e15fbb77862cf5177de6caa00b7042a2f9977f31373050e113dd4c02ef23fd103c169095d0441151b9161b278408e564fcdef6ccae5a50c33ae3902bcd99933d07bdb65827d160cb896b5bba01b69af216ae613122d04e9ca36b100ac7d4cebc290184234c039eaa86b595423d83e87b9e01b7747fd26f0f6f2f77a4d2ef7a297dc66c458a85ab8610343389240115f5922f11f77855d3f440abec89a865c4777cab4f56d02f9831c121f8bebf8067d3e61f8fd3ffb10361f3443060a9a4ce043b8ca8befc4b0e7e17d68ce29d63c48a6dec08431f5a3513fb05a906595375ac5b91fdd789b63f390d656cb60ab1f9c0f3c98ca332d0ab0aad7c11d5c0c549e8fc1dfc4293d1f263bf79ff97229f739c60b5c6644019971c82f45356e7803e01f0a94ab2422b5b17c0b6d60a22ddbad27c68efacb4d5569622e8b53aecc40bc112774cb070d7f2d9c308c8a18808be0e93669a3b38e93b830d6a0e6b8bdb4d7ba91c5596653bbfbf10677accc352921f97eb49d7b2e8505c631b76c0b925e4efbb0803b4dedab02d2f7a1873498b2d0e5627ac0f66cb203fee6184d892235bc227210cbe26e632b7c96904f48d55339212fa7d5e9c6595ed39195271bc51446cb181c08ba263d2bd9f2caf7184fa2083113580269159b315903a6338351cc7b052d533ef918b17895805c2571b01b0641acf58f79ad9cfbe9902d1f732df9c0fbb4e728cab3b2497f4d2c55c0183d930cb8b6eb6ba221f48fa42b5fbc2219512fdc54c1a03e9d461daae9417ce5d28c5989849b7c2419f9511cbd680910b4e25133f8f4d09a472b7b5ac06e4f9ca0833f46a9e20d8b5fa872d33ee84ed1f8c8696dda386a81d6e58c356d4eb5c1d56492185b761e653095b8e1fcd279f6f4629211360b9612461dcfd27c97298da5b4c6a108ad33e1480350f79025065c3524bbad091a8bfa119f6cba8e914a06325d1a498bcfa67b04ecebd8a9595058eb960d1914c675fa38d5cbdfc0e3a80e161759d75f0bdefa6c371e5a545e8b1bcea02c5978f229273af02ebfc6bdbd4cddd9300c89fcc2d0aaaba69b820fe5a6ec63e2e194f846b9ad1b7471538102f452bf263a0bf350177bd1ebbb80fe6f2a68195d5a10e85d1573ef30dea4f1be2496ca0f08e995bfb07f8a466a9ca39a7e4a3871c896c597d012b5f7fdb04185ecf3a1d7bfb88116b2d899b656ffc8f96d8a8d8fa47af0c6519b62226a98f3a1fbebeb0f4350e045b122f8758e42b4664cac00057452b88d745938d02754a9c252414e44f2b157c94381c486d8221001d3cb55d8907da67acf7305abb66fe7601ecd56a1b89440842f89a8ae8251036c3112107de3fc01162d8f45b69532df2b4879689a1373986e7817b85dcb7a8a36bb6448a68e21726d9c41a6ccc931fbdbe69979f9df22977afab7bb8b0c281ce69489286a470c5d40bc5c45a6de56b56304cf93e8c3414270f03cadf17b733e4174b2ac8737a8b21ceab496b584477af1578a1e36224d457fa8d4f9b03ff0c6c31d86eb64b2b4e65745278ac99c654a11923cbe92af65fa32513eff86c954c1d80aa30d9320dc08537ed0d193cd6364e854917a213062fac26072f272a073a4367fef0d137a6ea7b6dc610e56a9ae5bb3ee0be85edd325e299232bf38b586bdefc6861c06629d0ec269a7eb1a2c550378d0eeb602f701f95b9cba8a34e4199bc599fab1c0bd4b651c64c1f560626e0558ba0f25c004e8ed5040621cf271e9036232960f8d13f4c5992d8d69bed7995e579de2545e1cfc4f5ead3536a8c3973c4ce75a05caaa3e186a70b636cc02aee7ef73588d5c67ca1c054de9c0ef4d3b370aa1d2bdd332d2d4cce440c076fa15615558904443be6761374e61cb234308d1207892feb8594d3911c4307573ef9f3162b2a9287c5d34f382196ece12c362cc69e9b5c84df8a8f0e16f2f5341cf3f7e4db84409a9a9dbd6a2fc20185de076d9bc1dab44c5562cd3b3d5266728f360dd9fddc5e5cd56c6a6dd3d33cc0e48bbd5a1278ec9967701dd4185ef4d8b89071095c552258b78231b15716bb9c5893a4e4470e875c23dce06725d65344d5eab5cda3d1e163fa29e2d6a38f8a90a620d8eb567e806f9e306ae17a9a7cbc3166525bb0441f6f5ac8438554eccb2484c6a78651666ae71c04622d2b4538f34577afb08f265d987bcbccec959489be2c4d99d878efef6b3e569fae715aa10aad3a416563f1a049349f7542bc4035b8bf12f0cca714e189ada4731e987230d64cad1f6d4f53e38e726b08ff6dfa8b7cfe43cecd0fc9c24e783182fbb8f9edfb1442e41ede8cbe3d964a44ce754ba72571398f030b25a2e100de8d10234c783e03464e07b72f2d982e1d6f7d58ec703884d4d191712bbbf6d859022f8ffa18355381dedaa567e21aece28a3188f2e9b1375ef08b7314804ee0abd058034963f71477ebccbae4b2ae7a400fdb6aeed0ffbc488c19bd5d3c1da1802e0f1ee90650923810dc855974579235aa66ed4daf51edd7c96ce5de3435895a5621b9be59d268fb2a76e7bd78eb49d5322a69eb840809c2dbb7d2b2142026187be603c52cb423c29af753d4320e11e9976690f1f8a7aabb280a22bbf9c68b3b1a2bf3a2a86190eb60493ce42f2363975edebbb4f922d5c5e89f2b83c6559075580565d0fcde63377734994b055c5b5ac85bf4a7575465d104608313b98d47282da87d8b3a6578de1f1062f7cbd1e0e52ca97eefccc9d200c96df7f778a1cfc43478c943b0f80a9761a7f8cacd76531587c4b96a46819a43d6e634b420d220d4432f86f68bed44aac19e763bccab8190d58f0280d59d06da3034ce02f056f842613244057ee019920366f2c9d1a6ffdfd11dad90d4c456e5c71079ae128094d8fc3f1e5792b7afb53b3ce769626b424645604abd8ee9fd1ac7b917b393a8aa1a1de2843dcb9a823d05f25887c29e936b671ac4c145b375d5723bd38037ef1f93b04a0ed117df127b96ed4b0c0533d80f74ff1c22037234d1698f9ea5318e5a39c29a7a95ee8ef32bccef353a4bb8658b501247df6d11dd0e253e180aa3399fecf787cc2c43140058fb3c92416d41de700c5949c04983113eefc08df92e289f62126748c6303f9daa344cb7a9f9567e3f9f638ea1788b327320aaff2c1bed4d992e97e188dd8ee7cf96bd36fa8fec72e0794beb6ddba42d88e73522f690810a42e0fa8ac02e0594e2e4374e4522374fb14a95f307304b457962f2fba88670d914169fa24060602186f0ceb1c32137566fa91f9ee6081a8d42bc0e40561adb1c68a0d2c4da3ef43ed2d1bcf101234a746bc841b05d38231444aa5db9aa04d90026c928c391d0e9c0a17ba0a40c5e59024817493e5c09fda99c6e64f5fb4e8eba1e6f1c61a119965f62936070c26193ced4ed8edeafa1e06fa8d705ed0eb92d2c966cba58208b0b8018fe6f28e201dad5f7a7fed7182fdc7416ff4ad796b229622ec990d7dbdcffd764af47d1e9212fbbbf0311d09ff6279107aedc7b1ea4f6acc46105a40608798a8a0175674add23953abad917fe30b85fe478f74a11c2e6d3b16284e2cc1a5044ce3469635fa9fd6ed6993a99740f69d24afbf197421df0ad523bd73d84f15316824aea83b5bf16c1b6641594a2bf3fd752fcb7fc941fda93ab3c4c78309f5a458dd3c6415932464f92615620015c2bad47d3a6e8f2c92e0bb7ba58ce16d3eea645772315645709ca8511e1accff92d529ff571890ef0d07df0194b4d0ad12a15b9a51dd858781d2e87ee7016b2a1801253306d1ebc9640b01c10c2fe4c17d9c39967763684bc5f7a1dd03f9506ddf14ce44f1ffde41e7f97000d85cf2a67a02fec2ff466bdb0d72b0c6ebc68f2cb9542e52fe9ef3c14185472d5fbe01cd04201a374c5a05d8446b2bdf8eb01d1a2aa67a6c91f98fb0960e768276cb9b4beeaef4fbed1833782b30d6f3447dd3e6b9884c68c17367a723de1861c40341f65be1e0ce100b54db2270c8be871b0e80b4b32026c23fc5f559a394c9ee3fec28a423725b148709a4d93f355c78d9a8a8e2da826f4f12802b5a5377ddc9536ab6a480279abf82a072b1adbf0bdc2516e8129bc2227e870f304ebfccb67b1ed7401fbe4cb8c16be37d539d0dde919903f98d0598f5cad2c5826d8d05ec11cfd2acf9f0c9b14ff64ada69dee4ede6a4670b337690eac2be370d4ae74d5e5df0249e8463dfe82984706b7977b5c7969165fe1ed6599592632c5b1c3ed24573561a209c8439b00d9b1a0a08d9052501097676ff6c1c3b1135e436336b5bd13f75f7268a57e6cde0d69ebc71575b8463015ac9aab3d0a0c1a4983a52447ef48a490676e8d230bba19a558c327101141a22cba711311078b89aa808aac16a4de601a70c64fc048f3a215fea7d35df27a069474a05be771cc33e3e6e92aefc7f75475fb8a5e15e875f800b6bd29613a63e884a76f4474ba10988fe0212c55a82c28581e984fa4945b1373f6b116e1d7eabf5168bc8074677532f5d2cb38604a29176a12b46764576b619b606a6dd6961d88de083271973f046d4d891df51ed103027c198bd36e9682d133f157386fb697ca07a2f0a579c624497129766a514eaba53141d65a034e2b959625283c6c4dc706640e236fc88e9197d09c4df7f903aeb2cd3457bca6a2bf9a795b8804500995407ae08e2da28d0c14007f9d859182723d753516dace014768f7f653f47a57438c0d3a61b72cbaf0fb8c3cdba96aa32d2f5e110f5cbec11ac4a02b36561fd036bcb11512ef2babae6f9f918ac5b42279fd549fa82e4874ee1a2fb7f041db94f2925210fe4d5175f7c6efdebbc36e8a84d631a20ef84fce2392179e73a603ea5eee9b12631b2d8fba7dbe450bd1ed1b2755c8dd2f9cfaa9c97b717d6b9aa4581cf2a139e98b4bc0bfd44de5a71b5eeb047851d014813689b48877e17d4260cbb71febf6ce7ce1514dbf6ba053da097f6af3979835aeec30ce08a4bf17066786bbbed8c106b82fb5bfc819cb12a758dc673d0ad6b4052c696d7975c5b42656521d8649fb7285186486578038af72826bce9844a8f76c07fd466118864b7a8d1c362ff07a16193bc579fbea45f96c03cc02873190346645edc3fbff002e4dd4ca3162af408a0d2cd4eee95823dac32384ffa9c17266fee0c5bdd5fd819a9b7101ec6a65186a6f8d206473e96367d1ef57bb933f04d745e3488b6bfcf1299a048f93f2627bf8e784d73ed8af765a4e091b91028b0d5d0503791825019d96c5c0e5d534dc28fa29b27ba9d2815fe4ee5d96b0e1a69b3bf80bcf89bf5a8cbc6c2d1d511c8cadc709da9206547262c82022a6f9c9db3d87d6d07a0b91f2de728f1bc0b1a5a7020d59a21cda12b3e1b2d411ea8808623a852911937b2d3e3704ac70d8350712b12d5a442dfc31b2c8d155b290644771daf91a275f733e5390eb6f25b10d4f2aa1616a1cd677889a2a3e143de09f47f760dbc4d8ba0d4256586fd0c3294bc0ea7f6f1662964151939046ba5a0eede609e2ee362f15830e4562ded0bf78b1487502f8ff3e7674029a86756e7e96a0e80f59230435ff351d9ff99053f129ca15e0d6fd4bba59d02958d79e839d236e5a09df43d9abed6467af343492adbb8d38abed2a753ba28b064c32f2e1e9b3b70e8e695e46288298b067788de0fb53544fc7b3a10e32fd5637676a098305bf072044a0a17c7b0833efb03aff8f63b4066a39b2c7aff03f79da852ee3256e5383a5d27d3a90ed10fd61dc82731fde2bed18b8641c8b258372179789e23abc1ca9fab4caa343facc2335570b63a42e5f26ed278d6ee9d8d9d14b39877331088bead5981a0cf744f564e016d26801eff0f2040972bfde2fc9c8b572d9ce7bbd65876caa36bdf64e2c7a580b2442a40338d2e911c707385e7dae7787c467d7bb1dd8a1799517c4eb02092fd98009b81fe70091abc223d505c3a8097a9987c7fa54ea76d4e8b84d14ee6a9258d4eee8ca5038c033f135e4c26af7e4be33da68a03edd25f0a9fdc9f9f3763e2f8edec91b111b8a78194918eeec0f2bcfa057a73db9d1a0b538fbc08393ea399adfcbfc12f7e21af241fc35c4c7f842287e7c767761cb7a03e403aea26bef1e7008cac9c35508bafc286a8e6237301d3b8282dab599416481ff1872d3e0a1e089cab8cc4be7fe1b1a5e9e29063ae9524df23e70025cf23fbcc3b909b371dd6cfeb8f1cb8878ce6258ede92c9060cd8ad0a2046e18d46ac4cb1894311d195aca9d8105313ff28a13444efbe9f059945e7aae6d0484a8c3314700db1d2f694ee6bd53a885315bba6ac639864527a5bd7f78b9c0a17edd92f2f1c7ac8b55ba4094597ff654ab1c78efa4a834241ea35e9811bc72a61e0a184f775b32945951f3a1fca944a8bda78b13013b500b4766bcc6b252781aee1361ac95406971a8b2028f5f640051850ca3718d2fd6e660be69e28646140887900348779381ee00c2fce1f4303f1ef75c6d7779935218198257b02978b1ec331dfb0b6a48cbe16a7fe5c058678b164efed11d7971e61596c7a8bbaafed68a6c4e5c773ccfe75cdc288201ad784bc723aaec070ab0e767c89f199e88a7cfd84990e78c68fd7f34514e86ee544e1bcfef246ebc3f5844e349970f69aa2ff62e971ed6bc396649a055749eff8d72f3a2215b42d9a256d98bb0c0588cfbd866ef90d632919fad60982cf79c5fe5e8f495dc242fea854a729c9d1a01cbe483fd40dacd1f9d77537b3875ed980b8752357d8abf974e0f5a143d9b108198945d7dd36fcc33e8eb1c11b56bd562e8813e7a1b14d8d30d100959839b56eb3d63d7dd2b13da3c34d9da3cc3bc89966f4c690b38a55a1ba5cb891b5ee1d78695e64b8999f64f2c8955347f1561b33b34a63928147d8e83de64deb5dacc22a6b34fbcb226091de61d2a6dcba19e41f27a6376aeccc937ebd2a69eb6d3cea1d9bd612c5f9bd313995a4a4b56e3d39188c75a44ba3ad3b3e60e05d4c77ae15a03fc83da0c14744ff208a67b955d2d731cced74284be2814c5e595da7b724e2c8d513fea129d7535641679fff581f5b4a35c412657fd5042f1960ad9ac974850f9bfe1e357e518ccc1fa78d117243af0c74c39d06e592c7ee4cce50a413211a1981ba8cfff493e0fdbafaec699b4a772e7e44a12c407bac21b0ca21075a86c15657315de212ae449812a44030d9e3f988504a2f743faae75af7bb16cdcacbf8d2054a7cc5ffb4123e818d15b985fa26402a56fe811bcad2ea68caeb0ee9f7414a5c74af40b2d707087a3999fe7df2089b9e86ab8d30ec45932d7f8c97a1722370be8c98b922e0445348787099fb1f0489204ab9feb4c7ffbcbc13a7a28535f4654eb1da7a64e4492c8f82c4d45096c1c9f4a5b6bf0e39d2b5fa9f3f57b58473bef7a449dc895bda577de4d454503244f27c52d4c2a5a23c7ae02643503eee6e8bf499826fbfafe0c745a93ffe22780dbc8725fc8394ed593004d1c9d4b9b1c474510d01a202bf08df53716d47008c5819c2e34cf92be289e094d86873b78b0251e1b4e978129d6dee2f5ae67f8966bcafe3bfbd813ad306a76f3c27e33b5b768bcca0768d8dc633482e145226b80928f7f8b8734fce7760d64cb78e3c699bb0d709df1966221e9e15e2609a63eb36cf083eac63d2bc92d0d39827476e22c9358fd4e2b4ddae366e51b118c5dd09a6295a9d28a95cb32b05f04e04b6070b6a705d0311480403e876de68f5c4e7b9c1d20e0ab267e6b0cd45eb0bb829f8319c42f17c390be34abbdc33b347891e3b3d0129d21816516758d54e1b313ece8339b90ce00efbf2cacce1bbe323c5aef9dfc583bdd2838c4918f2213994d09d2f4c65af699b9798de6349f5d40f8844f7306c234cfab0835cd7ae18dcd50c6a81ac1a872fb043ae52f89e4fef703a3c337e406444006344b957ffb121af6056af851c501d437dc983347506bd35e209fe9a8f43d83fdf3f830cdfeecc47a4d0149666a1ec75075cf6eaa8329cb49cba9ba84235f3b375e3b7b0dde36a4fa453f3a91bab335dc6715a48d731aa22f07ec35fa52a20065e030d995caf3edf98f22d15d8a3915b3ce01cd3db31950113f756dc6970a4e36a2f4615263274a531bc18c04e3c3c4c8330135ff6324faf361426fe9a75cca5a4f9826f7a25e9519d042be21393b972891893476e3a63ff514aad7d2208f0c1ae92833ed475bbce82f3993cc7cb637b84bfd1c313242a6f0383e984954fc6d0935c3dd004d47de34ac9f5c255168462e64ff5cc7e2bc12cc1c1e145b85e8f4476eb5f0aa896e7cfb3260418debc5cd9decf663b982c9d642a13dd89814b4617e98b54df17d912dc19a79ae790ee22b4a178d0f99f9e279b2ed2af4e7728eaa43217660fdd7aa51cebae735f8bb831e08fcc6ccf56fb2ce6f23aa602d3b9733b0b00d5acb8ae5e458b7e86e37fd9040f2b5c1381f4f73b5a0f99ff5bca5ab92514c793698042711ad1efa207683e4ad952457125ecb5b1a85072e6d2ab22a3ecd5a36139861e93755cefe15f6e478f00827df3172c878e4ed31f7b5a271b52f80c75ac405040bbc48e7d7c6c7bc8029652665cbef9d566825be22353afe57099f5ba4433f4ada023f797b1e5cb12011255d87b7afb7cb7edda1af7e321c6344c190f1f8274a05c3615d5bb918223f763b23d0ddf051fcdacbe7b8698777b85a0018aac25f69713e3d1dbf523106bc9a28f3acec94940999d53ab4219c7860822abf37e5441b2ed0a3b1f282de50c78cde281d60a9a2a190ed758eee719d9991605d2b45f1a31698b248ba1e4a3123910c07582f2b9a8a161ff7062ecfdf1fa11dba6f5f1967f2701efd7fb43dfe7ec01293d4416ccb8506433367b56aa2e441c068453bda02628b5a485fdfc48980b96d23d63710d232a60a396b6f5bb67810b1053095e987322efb829a3147396fe71dbb42a5626b9bed5e78eeeb3d4cd8dea3a988d71749773288ff0362e7bac2401c4fabd947cdc20b4fbdf294872117dba0e23e9efbf7f67e69fbe4da0f0d1267d8c8303cafb214ca291ded28cc39e55cd75f75ea6d664a01e813cd5b20697a51f43cbe8b186551e23281e8003091e4c982f241ebc83cad2cffd823d41cad3ff151befcd21efcdeaaa8006f8fe52639ca6fd6bf4d8317892846724ce74fffb8fc4666d45804f7e9393b3c285cb003f924b33fe33b806f3a2e62596cd2ca4d215abc12223acc546749e0ebdf84c402eae7f3daa0017705a2406ab92568bf72b69e8e2aa3d1f3858f40dc969888530a1451e805fb63f62abeb56c7031ea53d9d64b8072811c002e79ef97df902f6b7d3e388c7cf2eff6b593789c247e5edeea84bacd0b10674c96fad507b063d5f1e362b6accf099572d88d4ee7bfe0edce067cfd874f414641471b37fb71c51b918338aaa5c240b2cdac04d215f2b7323100136466169d6b11cfddb7d8102fe48efe167eb8deb93bace9def3b60528ef9b38647c0e05d2dae8dbb48a2b6c87de29b55b38694733faaef637baa0e8e218b827b3d528d19d5470f9ec9399dbc1f511a6cd069fd2e550096c3e97efde96d21bc59f23a567867ef68ef511a09c50885d1d62c402869c62ea8714342c2c0277ffbb752789d52b1b5e18dfff7e0d792e5866224ee8d96b8b3b5893a28804f655b4c351498e74389d379ce28b22e420b45e0624f1cc4b761d6421a2d2e4610ea9bc5db895955c3134456464448e6dfc1b96667a07f78145df60ddd25913d25c9c2e17dd1856957b5e2df162a452daef9bbb7936d7f96c54e44e160faf3ca2f6bb9de14920d5d2b610d0170c9e052d5cf5988cd01549860dfaf9536116f6b42f3241a719827d3c6c02adce595344e4ed3ba97e54a514ab04d8f4d0a500b66f0e69db6ced50c4f9238809d48680afb82f159de6be885d33498732d389be55c580dcc05dffbfb220b554918ea9846e95d11350158e7083bd409ff650199017b3c68f3e23658d92e8fd9b2f6385a4a5f338056160c5f4b003e964ef09e1ebb20fccb2e512f346f00770cb7eb4ca8d7b5dc378b9d1529cf6bc37b655c6c4b7a22abbc6bdab35e542810f28a1ba33922088de766139ebf3bedd431df1bb432a8eca40ea7a91c2e9387116a94009a548b8040162a3cba728895fef55cbb9e5212187f10d948a2251bfb889b2cc8b928e17ab51cde0874032d84c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
