<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d35a21e3fa6edb22c64bb267f4ecee4604bca17701b43d634b65a39f0a8587a20da87d8e843a39603cfabe7062be848f3d50eefa060141e08cefc202ab3fb672efd62f5e6dc2dda2f3829025aa406a43af0fdc49736b4c4f52042a4b7558d730e290f27b03ee5fa83073377a5503cc73f00cb75ad71ea8c41fdcee5aff4ed56d4cf45ef0d6d8921ee35ec8af7dfc9fc97bb5f946e0d77a532f254690e9f8b33d3446591b6e8fcc421ebe7dd0f77842833daeb5eeaa0f65a3d03a51a7d37d7b0e9a458a52f77e1976d55b72d85ca939ee847c69a92d7877095e11301381c77aec43f4b8eb899b50c4fb192068b6cee61b059f3774982ae2be0c18bda181729a09e216481b9f2620d60881258cd912093ce418c555bb50d79be68a5a2bd5457b6a3d2dce45d4afa0b2ef643f89bc536e83605ea87f7da76598fa251b3159a3d54c824daa484bd10d3983994fd79c9454713622e96d49bcdfac3591371c2b2ae3a763aa874d7ac2e055283611550707da96699bcd78e1237584f5e4e5d9e906bfe84a1780f26fe3931e8d1be3e4b6981b76a69a87fc0de1999c4ebb60833a3b26264da248c3dedde4803482581ec22ebb43f591f08633162890fdcbd1cdaa94b8fab0e7a24a4798e54832962b0a3967946ae1d6cb7401559a50a24d9fb8aeba0847e66b707e163413318848b15571006e56520dfa3473ff5669732c35669676359827d0689752194498101250faca97c4eafe8bc1348fd036f43da4e70c507f2953040a0fa1525d0f0d988cec029c3fe161415b1bc2eb4331893a6e1e4031cdf424bb5e2b5bf368f5ec73a538b15551eb0a148f6a1a96ff0b4d1c1a682d924c4f77f93529d7a492f9348b5d73598162d59d5ff1a1961cae27155971aaf8f06d3ac6da497c284843b03c543d8df5a426bec431473df2842ac9b9e951389e9ba8a6758e541c80f10eb61ab6b289487a2374c287a9c1d5b5dd23577c313fa63f841901b372db47e45cdab68bc571a94a9e60ab7bd8be9b21409a9cf052494ac61678b14b79bcb5718f7775161170199081e521f9afb16e4d9b4fe7721c72234d6aaa2760cd5c8122b21e9018470d787d1f24af0556ed62b859302c67e6ff13ff0ea881b2d1121df23085d75c1ee210f346be0d00bfe64ba1563c9bd0c019fb6899ac536805f7900dfa2bdda462cda37c06de4133d85889b84e2c1c6a4fcfd9760db909ff7840136a9e1961127ca38b5b19aa4644d6c84161541cca221d02698c10cb1847604f3de601ba32173f6e6e7a3401b293e8054b7e2412e592e090915ae8fa6a7f86885d4b79b87fbbe473687fdcbe575a7bd9cb3be8b1949400cdcbd6aad5e6c27949963a7810671e74877f05c09fa784180bcc6cf5f8712e53c549e6591d36c8960c9aa0f6a0b1041131e59b6cbadedb07c6157772789283ae3f57d908e5d2779c64c0127e70e57f47ce6887f2a4e8a037b74c2d73ef097556d7c885143ddbb36ba654b6b36feaf1a482544a80c8d89ad311e0e5d1030200144446d31c5df7a1adfccd9796b1c31de9ebf7a072c3a4b06f34a6a5b97fe59454b31d7b274b21a193309e1b7a1d03eb9f5dfbf39708083c5e4959996360322f3d87e16fad3b63381ccc70648e575d83e047b44d5cb654dcb45e6eceb47ae4b8e5921a5ce9bfd3cbd7ecb8fa283e0d93d74473b6139696f1dde92774a8af13cd0b001d05315dc56b761a75db72556932844be67a68abe8777e2c469c147cced5801446a5cda2f1f0e7da6a643305dcd399cbeb8aa6d124125bdf87e229eb8ea298ffe8cdd0f16aa1389affac05c6cadcfadf470fa0bcc733d69dc4206cf2775339914d8cf330ffe0e2297f871bbee84acccc275a7c68787362e221aa9e671c8b95eca7f3385ef837d1a0ca73d12f4d514cf3dcc4978d70bac6181f22b0d627ad022c6ebf3d22e9b22f798b8b8a1d9eb45ea4937b29697fbff3c8b5c98a6e73a44c002fae39f918d2c0115b1e70ca90fd622570f2af8c7d4a5de217cfcc5a0b521b08dc7c4e090b55a0c7341c4373d52919a5b75a1bd0d68e30af2d44d1d2ca40094690059c65dd952fa9101e413c9a8474fdc13e6a66a8a414de5b71275c9a770390478da63038828674378f06b6cf29bd6775f30e8018cac022b8fc12affaacd80feec813eb28fd4b9cdb0fb9e417440ed4f1e5a16bb02f4ddd2eb894478154e9a11071d9148f7385ad16cc0c62d5db842523d0c78d777ed06dcd36f0fb4bc3463a57d178afab1b4cd97940e1dcaf63e3ca2f00cc27be74b872c478e0a1fb4e56573d18704a9a7f708bbc460f3a3166a2a60f764bf2786f05da2d67aab28b8ff2649865b6e2ac8ae69b788a4f9221cb4c2ac39e44fc0cf00f21e19e8754d0954bab1eb59e14be0e4d73c531c83a9689b9b0a9341361a561d9d3e89a7af77e2fe69e806dbf4d377435a90633edff838c74314246604982dd6a9e1a8edaf45e0501191a983a83bcfe5f01c0560e1855fa322208f6d367b5bcf4dbe4be65e0dc70485385df376a8d2633e6e9ed448e3e885b7a5c0af27c8ec56bf9fb944642523c4f3e50cf66819bff7ca84b38ff031a9dafb052108b997698070aed09cbbc3ed647628bda50be856de3f502419a411104a860ad528c2fc1f8aa8cd9b15acc6c3ee6ca38d1147a39be151f488187839f345b14c8572aa22ee8876ba7603c53a18dc547b3ccdafea3a817e52e429f6339ecd9a0c85a8efd8050387b8ee2cec6cbe035ee25af53a225a18510c2c1076625068bbedea9a721f491eb203dcdfcf42ea21351662b206bcd0963f12053d4a180ca6dc6d594b46eb3bb9097c32857fa89c46738a715cfdb5362b713611e7f3237be7e1c7414c669007fab4c1ad9f749b80e4573c8765887c5a1e44e396f92ffb0b924751ef78856023cfb2e844645ce20e6b0304eda2c31582c90c20d76173845d3a4adff850b28b5100d42af27fb50ee84e87eaeef5a1ea49d5a74db64e17f9d33d685b9183470d613d24e134d7ecd44ec75cd435204d464ff426e2fcd61ab9d79df0361358bc2090a4dedee0f8c041434548c5d73209287ab221638137ac505659d00fac393cd8913b32d819a83c12a2ee80c8f2e580667e97e75a673680d50ba3cc744f1bc754022f783550404d4d1a64c7549fecdd8acb2f10666a78c3029913ba0cc2accffd27a1dfa1db4243c4fb5740674c9bdc8409c1b7d402e0a0292467a2bf067e8c63890e23671774c0c37d6c35423c79480cc0d8657b9125e93078b3beff8f4fb1fce4d23b1bc3744ac5308e7986e2d78b06b0c258b07d223e567aee90044ef8afa934b7d32b8e8888b0e6faa6d92774c0e5e1738685644477ae9f818a67e4c44e7bb2a9e56d350f0f35b4d3d35981055fab58f86fc34a7b22aacbebdc287a85f0feffee15ba2a584433c2b5f830e97636b9914dabc5e8605036677e210859346e07a970576db52fee61226ccaa467e16753b6dd6a24d9a28cf32e934d340bbe57ec6eb2df995969f1377522707d5491ea73b710de101b10a5f4b66099f345dc24a2059fda83a3d55f31c4e25d042786f1b6d155b63121db366f4bfa9e4ab0649b7080b4a505c23bbdd15d5807262dea73da9cda9a8bf31637bda0584e46fdb8479187112132a77ca9f38611cb96cd57f79475e742ffdefc8523488ac5f4719d6c25d47af30c37888ea571661a6ba366ff5b54f9aceb24c9c55a485311c5ac7e99fd1fed5d7be2e0832a2fc068806b3912ff37417cf6ecfe70ffed010a29c6f7d7d3cafeacea56bc2438d22c3c9d99b1adb64ee26729d391178a28d03d3e1be48fcc6dfc11c68738482b0affa60bcf9445c52db83e2a871c912b14ff3c0034c550bedb2b55bd8501f1e502e0ca8e543b844560d9cbeea5b096bf06ffe6ea2bc16201366480965bcf922b8261699eb6e2117cf2169e689a4ade0582063d52276d486f5c50308b442f59cc2643fe07c9b96a9ba9b62d38b47b5315f82884cba17c2e957d181f94e39a7009816fa52a6973898d46d3def38c13f0b2ce1430ccd3fcb471b7a916debd1d7115dd7a66d1381bebe9845a12d70d815b37315641d4c9fc466d82624d79247020286d24936ce5ba81638a6c4e3f3ac728fd729dc59a559dd895436edc5e2a28654e85744ebb941f237e61d6bed671d88e46795ca175f1e120059532c0412e52781ae33caa93d921d522e7db045ab0f7d61c2df29287add693f5e1bc9aac7c9344999a4d92cef37d2ad75d59ce401ede031c8054667185b598f19d06cdc1ba9da75f414185560af0d494aef1122eae4a8defaec5ed671e37b9e9cac5f7f78d8de56a82caad2e559175221a6a363008e1d707d0e79721814e75a3d74cc4e04879e4f6c9053987e6db880dffc9c7f49deb900ebc9732746b434d095fbe654d6300db716bd1a24e3ef870a8423e631198e937d5820149cbe2506a5051068a2e91e990ee89a37485c9956d5fe28e6d375c02e04773212a11997860307e321959126d8ba95f814b02e9c9fd7aae0b36b7ba60293aa2dbb02c7bbfab885d2b95025c70fc7efc3600fbc36e33113a19c18377b53d743904c7f3918d054c9462ef421f8a5bff83f4470873ab971076e6dec5c382da9a76c807b1ccbe33fb297b38cd573f1dc3ad62260128cbdc388a60b5446c3572dc312948f7b3fa6537d1123ee7b328de60dd6df0ebc920a48029e0a3b6aeee1b4070d34f50aeb9b7e4e50b30e7ac501876e8c37fe87ffed34fd2fe876c19c5b16c68092ea6bca9f8ac4ed80d1e862f0ba72e718439b0e65ce161bf2a3b9861fc97951603f0569a99976fffb09500c88380b416b5bca932ec4631039d1df246cabb80ff7698e8222db828b250470778d6618a8e5b97a7e0ad29789ad653c8f65827a4dc9274e7c2d9318c30dd72413b84fd54adb4348f03c116581074b0f4be31028fd4139ad4b1a94583b3d0c4c71387e74281ade76739041d9523a52a31e84f63ea261282d7dcc94989b65b7c4b4c471cf6b4c041201169281e7a8155ae31fc2247330c0e2be936f418c530ceae542fd4a90d2d4373ebd5b85f39b7b2da96fed4cba97b3fc9b675cc794635b6153f0b58f806afa7c44c5382ec6eb1f9b1ac9eee7b85348cbe4eaca08e2884d0feb02489b8614c24288648b9b132591557d9699047dc3ee676f14e06e32b1b7e38479fea0b930250052913b32f4e7825e0a30ee8ee01ebfd5ff86f4980a33fd347001ee437505532a89661ef255f2beb373a48187c528c1c068d11486c64591849e1bbb72475a6604d1eecf79b09f8312437c1980720848c0b6a1f85cf8d5dfce280480cdad3b0b8efee9e2d560ad62be95145f7fa1fa7d3c2b3563033a80ae39e549ec851aaa2562c4970a64019b2c6972b1d812a241ac1961edfdbe227c48bf1405b5d131f0648d6f30107f3c3d8312ab73b5aead12ccb567e2ec5715d046eac87bcaa0883e34a55f3677b3d95e3a7a0dbef0ed58f3f41ea5e306e13120da75562adf94785fe017ee44d9da178da374daddee4ee5dbed307b67cffdb1676b56fc7e33aa6fe66c7d213ac775a22c5e473070e9d9a718a4a3493937ee4e09151127a37ced43e8c4c4a6b0b1faafe263694723e9fdf93d75d16b9d315a9e5e36170571b47074eb7a1ea4a5449e382a67d07bac5aa7cb157c2ec79381caf91f28bb975ce29f9d25bfc99c33081a3675cd2356d2a2018864f8f78111110d03c6a59c03580e37aa5db7250bd2989517563e31b24f2a9c10807feb3aff7cd6d5629ac0deaabe3b706232027f9d7177b3c0e8e7eeea019dc7e44067f0b396f2c17cee70c22d856601c8bb443bb9ea7fd6dd9dc1ed01fb5209d1098f589be2266ecf32074541e3911b6706616055e934fa1467fd1dfb0e6d6c2a553578e649bb4958c6197f7061defbac59981c3389e8056baa03fbd6dd50fd71390676b18f9bc1800eac465db3b5e287cd35dbf5a3f0109c637b72a12edbf0a58e1ac561842e4503d935dfc666a3ec9830760d0f58dcc25ae9cc53bb9f8a69d560776437f4ee48f7e65ab8184bac2075112357987726e7e279bd3d6b8f68e18182f2f6d70515b24bad741a4093bcabf5a0d49d9ea72af977f3f33974b6a7f287751fde746d1367f1519ab22df42362dd72013e814f39c0c5815c9935f9ffb180d10e83dc8c77710890a1feb3c5da22eb36caa9622c3fa4965556e37154ed20701341791719042214595468771105e0e1ea8004358e091367ead2d99ce28d5bc0f4284c6a4cd77aadf849c37b74df26e6e0d5957926d986ca61e9e4df02e80fe9e467e5d9be2b6dcd278c88e22a796b66fc336b2a93aff93ba474a976d69a354858c233e5760ce722b0caa357ad0f463dd540005b4ab310eeb5b38b767a845f049379344bd33cd5a1d472e4a4a5519d1a6fe0e54794294897138f1fc4a08d461c6878543f8bcec2e565c637acdb0c403d07a77fd417d61d01788e6f78254972c539be7d9d8df25fe9832257fab69d80d4e8a1e0b5d3a89266bdc3cf2cd965d35347fcd6399cc39627e1ed2e40667163db4fc8cdb3feb9ca8bd1d9627e1202fbea34914819287d3ef044d2a5bfc39a3fe6a7813f3aa4203e3181a71096ec57163fd9e0a1188f353ce669e48b65d100d3f8c8f6cb06b17fadf076567ff1cc7bfb586859293074eca9ac4a10804dac23ddf64ee58db4b43b6a6a775011b2e25b6e15384901affc52c5f900e9b74f5b551a2b206c80b9ee62b4de1601bf57bd6f15160f86f53f749d0ea94b9258593836fa25f320ba1881b5279e70e77dba3be6e67590982f773cb9d435cdea07d0c629ec6973327a41a555a8c9a337631c3da95af2e86dc04411ad23b1f9046434634305ad23a8b08c69d69a915eb6fd2a47b3bf6a7b2b318002e9a49b16ae8e36619a1c010bcf1b18305226822a301407ba8c7cbfa4ac67484493eed465a8c8d8b06d1e301ec7d438934c54fda06b139eafa8586a84f714d70a5358edae1c8377f39993c71d6a568c119484eea55b16c72c2c746543c3ea9f904d888ad7ae5381daed9eb2456ce50616f97872f62e1a3c710768fd0de0c7bb097a88cdd6fc4c7ce9ff0f1aaf2c8b17700e574981f212c330b467a28077e137c383aa57eadc6d4ded2cb4dfa379845639cc1028074645e0cba10b04237066e67ef653dee8ccadba431f69a57f3ad052f8f2293ba5aa99bae183b3e7c8092f0ba0cc971d6b4ec9d712ebf5d5c421305eaf2a9622d6c3ff6b04c32471774494d666d643136c6a24565138b4553501981225d1a4bbfbda0fd22a4bbf7d002e9387f297c76adde681c19742d559f75773175b56b7385cfce1dbd2a4aff00d15a9a1c72ad1820fdcb626b3c847da1ab71435bdd57060a6653219f2e227a818ecb85f341b34e36bf13aeba552f0636557a9531f3946e178ba7a6ff0e462cc3f27f3353b64ab00cb3458b2d1cdbc1f6f5460e04c3dda4eb04bcfad55394481dba864035d3a94dcfefbb5f96e0ca76c8767190dae5c02fa1c3d0a79748bd7513002caf7cf94e342351420ff4ff4f22e1d953f4ac8fcbe0dc5d387a0dd8d01ae812d95fe5dc5cba0ff756939b643181ede2fe9768a542f9ddd5401185d2dda8b5b0f549233a2d8d00119e211e84cbb7683435cfbea4613bdda17bd282d862cc6d204be948f1007b754bde2ca03c75ef5a3f6df5ae4d254808e66c070cb3142a5d127ff50fd1b905055a88e737fc50e461244424196a9388aa93cef867d66b05a07a793a1673edb8ed346a58334e527e9828f30a9debd256f023eef96c078d8a8a4714a677bf67c0da33cde0d2e042282349a46416d1df03dfba54754d5e0c0faa6effdf4861796ad2067f994d25b27253b6c569ac215702f62d553b2e2d3c0190095e58f3e1109eb8319aa350880e03cfacf8d139e4865e9064d66c36eeda1092ab38081c39ff6aff98347e804fa946c8639fd867d252a0b624505cacdc0dfc05317c263e030d40e2d6f5c83ed13a8df2b539b53ac03c42b865249eb8e0f702e4b92a40eb875c954858f0e34c7313833059f7cee09245931a4208bb60419151e14c655652cd31c39346e410a60cf2c8a0eed384b4021a93427730620179532872b20bd3ae8b8d9b66d9586151fb5a79d330e6a7c2284b6bf48103abd6cc31b4dacb90610f1eadb803478812e3b69a037281fe3d8fab6836aaff8a6ce114f8b4291394348637da3c9cf22bd36214e3625db05ed7f5cfcd50979822cdb9e3d5f7ce45f7b2f87e3fcc951460ee9b9c0e3756de6e405f4071667bde63dc8d250ba0104e3afda0e05ee19eaf6b0a1761d695292798b90d640cb4825532bc6b9d0ce6a3d340ea27cfa1f87c7e39625b482bc69891da9c33a9f2f7b783aba9ed9062bb955a5df5b4fcabebc73d6e05abe3f882bae0fe9b7c9d0951f57a3c69c5826772133ad41ae1ee4825ad6a2c603b480ca0b53017fafd3bf91906a320fd92dff28ae397268abcfad9eaa6cb0e8d3d06ccb29a5e7d957af5ce3fa828888fc6e7b8ed54af23ebd6b8f9066ad23f29b54bd740b81b172748215990db69fc1190c94ec462755d68753689af3315cbc50070a59793a2d4828610aa991c5f983df11bb53b3f8af1b87761fc55dcde02c64eca44294962858cd596e4783b0f1123405c74baae03cb7fe4182748402eb0332a540768d0a3009b21957313ff2c498e1d62a2480895913afab19d8e07867023cae6e3b5cd9eac345776d05dd2f518e1d55d3194dc15784f76a7fab39ff782f6b91b131460243a63b3673e128b147894b714311b2385fba7f8fd5aae04342d919350a5e65dedec67658fb7923d233ce146b3aa6bc6fbc58125ec9b6f90a632ce435e3074ae0f5a11c512fc9d5c739d672c7341ba12014f26fc2308a009039b93c773394c87976f2111482da39d8c59d5a2048d2cc3d4619ab184676ecae545b48c4ffc8d4c7b101e0d84cfed9c395f8af869bd0ebab466f2e2477881dfb09825f7a61d1704719344ea49da31f98b8eb80440516911890152285bae4ce86a783d2a2307294fa3b62872e5ac45c9f66a1d2d894522c024f186b5a3d64b5776bd8c1f651d923046a7b7625b5071941c736a85676a00f753c8c096e095b52acae567d76815e6db184e8cce7b43181ed5151a3de6fb1e3209312d2042e9efa07624e274758ebb8e2080fa1a6cdb489baec65b99ab1f9bebce49456b832dac8d6c6844e6f719334fef8bc0f19ac1e6774d56137a733bc69f40196cd9a00ac967ba45a04d03c1fc1d49fda9e797df506aa61fc627081df1b445ddda196ebba2a6f3a620e3103f7378a8613f574548b292acbd2ce7e6e829b508a837cf611bfce56fd4785614be25305fea4c415a2de672b3beeb8a9d46fe2874f25d1f0cac68a3f4af0d5ed89bbde37eb8ea796df8b968973ce5549380a1b30a5c99b768550bc84cb595e44b21247cb78e020ee6561926eae70d42f849bd154deb8e891abcecaab2ce0295b14b9f89060b244b9c4e46922a81d4a7c73089bff9ec49a5fcb9999fc4eda46d45922308d3b196b17ca9a2f90ababbbfd6e9748c9098151e6d5978480b4b2d526acd3da53676960528012819a89891d156c63ff0e3a9fd9a1c5d4d1547b66e9b198ceecabce48e8ce910d39bb08a3dd4f358a7c69e62b0894593bf06468efbbc285281b1a85a82fe247a451071172407bb584473f95a7d9bfd3e0b92a545c806925de9225b26f01eb17fb4e539f795ddf64337d7f77ae0eef15491d54d4c917a21555ccebbec1df2e05672fde97457b54cc46ea1f39a9b6e71bfa6f4979467a483db7940cf0832e4726907947d699e72ca738937e6667ee5a03e0a3b853945d795df0f1b1edd1c68486d6aabf3e9f8fc03c98609191790ace51972240638992b6c35efddb8353bfc068138fe185ae833b8aa2bec11096d569a6c347035e87c3ff6d509e5ad882107f98e12348056d3f5ccac0610120c1ae16a760e13f87ddf56655fbe752ef4c1510503913b58ba91ff6aca7f0e3202599ec76af1b9ad8deab9a5a1b53c03d1a0f34fa1b4e989a8c5bd2af688f723e9db90f0016fc7a59827686e37a3240e68d22493ebc2f22373bd1ce07bce9e8902e65ef1d5fbcf971a42ff60de2464870ba6b173f242fefb3c17fb06f3cbb709c74177ddc712ae5b79540e5efaf020d457950f76739b2c20bbf0e7d2a1158fd859948bb53f7cd3345282bd777414c7bb3a6a71b0078559741560b1a310ab7182b51e06c0d90bddf95f8e1cff71ec8d1f1403e126242e99a406c103cf6bf288bc3a6fd1751b2f5a648861156ef649ec3f5024e80c977d37dcbcb5d2ca1d7123fdfb79507c7bb34e1dcba1e338a3c10c33493c601875429cf00239300dd423ef6e10fd8806761543a0780b0945d2a38d5431eb57e1e6bba854a9be729ceabb433f8765ccb041d561ff2c277f0d38e97fc86de0e07fad3fe95b36f3c5555ac66b9222de9443e8c12c2d0de9aee4a5c65109e0a0e9fc60745eaac27f6d1cdb28bbc32bc0aba5391e068cea8660ec105aeae7b504954c779289355af97bb6634d5b81e8a1f23f235040750c974a918d63d444254cb65f025b1fe156d1d64028d3390e52528bd5871150f7d9e34227eaf6f0489dae6b59d6eec80f907b93ff558b4de22eaf8aa6f20f4e89c96c772ba811aba17918a248cb4164f87c264c10aa0e973c3e8b84c91be70f4a912fd9d5148e73b7f08f0eb57dacbad5849b37b2a76776f71497a13fce4fcb86f854ee6ee7d339e5de5bc75b6fed8b119a8f5720e52f4497c7dc90ffb3b428772d54084e957bb5ae51dd992903bb827b9789e3af5e1cffb74c942b2f004e37008d7c57bc9b2de0b505ecb7eafc0346afe0159d47c4a7924e2256e77b0c794df86a5fc2e09da6dea55f2aac635448cfb0de50f96d0adebad469ca4e02a82c8b6fab0f65cc10a05cdcfc4826b52413aa82a5b17cec4b09e8d53b76f695e3cd63d540d4f523bf7a760a8b07fc0f79c215200f441d75b3ccbfd76e5df3bec09517e9901226a5da88914b3f6286bff325e14d75b6e0d371d6211b576e38664d8a69506c552882f9c28c9c45d7a9be7004001127e0f7066dd0d462ed9c3d73d0a450993294cde0ee6663b2e91236128ecffee1a7a4856e80360b46d66e3994e305018baed16173e4b1501456730f94e90049b7b0203b95008ddb0a66b02455f20eb89e5fb8d9a5c6260c16e2f16d3192cc21ea711ecb69db844907b187c9d13fab6f26e1b33bbb26764e223cf0cfb2a5cd82a51d593c1e80c35ada50efabc3f3e6d29f42898778d14666590c29677df328cbbcb072587323df9306e27adc6ce7d4aa897a457e5a4b9987f3be4e1f4c15e686bd5155e9f852eff975ed778e341ef177f26f1f8bf4aa18bbfb38b20b14375abe929480fac761f0b1ae5bd1efd05f0d3ba51ad3f8e3d6f956b9f885e9f80295794544ee838db55996e2d1a3ad0d735ae316922cac54a1b4d3fc3d32c48d9af79113cf8d420e6f15b94378f0c03f1c1e222fa4bb3a4347b76ef53c5e8ccd6d726386186111daa368b177bc2f4e100693a9b11bc059cf2ce47850a2f57b9e1da0f326278d358638e94d81a5c937b16d421539476fb2233ae0a81206c0e4ffadc308c16db47b37c2cd4e08982fae42061e6d050fb058b4e16e293c318e33fb4d72e7195eab47c5eb37a56502385af0ebde7a34b26f1e50fd3764e785d6388ae6258dddd7f9ee57c110fe5b1cfd2824a73aa39f204265517d6d41b49f37f7b777682470de9deb57430ed070c73137f3e90b7d772c197f6593cf7c44a73deae630e4e4f0d3b3cdc93fd9dded564514f72d547916460489e61f7949f499dc8074fbede192569811548f9c6fa3f2fe90407063b71b52de8e2596b360cb432172755f04d9a33f9bb16a42f135b89a4aa8faa0c2e1e3c6ebdd924ae03775df2ec6301d8952bdb74f18e4d30e540cdeb1ec4381848177a6760b89f07a176d904b6265d4e3f22c14271c2d5e8f347db6edca099f8fb304a1a1a1e4dfede135d0cae6ce1644f8aee7b3714b1b9bb985be576a438ce73663a535ead2f5775f0eb0e29845fb6cf761b98f1808d739815aadbfc6c7301e9165748f4e3251b08abe87c3173325a6dffee63a2bde5dc7d14405083a8026d4eb90345635c8c11f0c02e8f22898011b0c755ed872efe19d4f22b56b1917aaac5395ed6dea971b3c61892cfc4be47d3fd1bf20d771bf84bebc3cef1b1744c7ee78dbeda86c7b2a170a635c1e45d8dc798f536d55549e4504912e1e872a5121f09f92c57e4865319030b44e5ac0a6fb4ca59e8adde9a9410a33670a41f3920f263469b10199a6aa35f8a91a3d0ef511ab45e1c5a73bd3a8b04897e97d031e3f2cdeddc9a5cbcce9532fa75c39f77bb0d71a461c90d00b45738b7c6f1e5d873eba90be50d12b87e7ed2320e8a9f32709a80b7b750b6b95b0c3c64d1f0ce749821d0d4dd5ba534f657eaa596d29bbc608841cf5fff370c538b18c36c60b9808057fd76a25f6ed319e829c7d0dc395adc023c66ef9ef8151227678cad4fccc23f90a77cf03d77567a47e8c8deb82baebbe56b0c8c217fd6647eda577afc426cb3984997a4f1eff7fbb6a106ba6aa4313b8ad9a2196505a099f0e350f8200d3022d59e09e8ffb78d669e07e804042f9ef046238fe84c6a033013169b0edeae793199f82ff8931220c08eaed153ab1038cee20edd135acd33f7f1e173de839e515829f3aa1e85c63fd85817ebf69b148acdaef4b21fc15e2ca844079197c69c66fee401ae848a1560574e96bde00c03a3174b222da4f3bbbd295262ebb8c16b198d4691181a6eaa2d8de571db2f1ea70624c7daace5ac71c93e215b54a5b38afa472f9871f6729622e0a676cb02524f34bb411023c07b9a9b0d05d174f26d6e43caea27f032130cc35a400abb84bc082d4acdb784433ed7288a940832659110a990e6b2f0f5d5c247ee62ca72c063e63b257487ece563e736a9b48c1eaa2cf2872eeacee5a272306c1248e80571c8731c5cb1f5fb26cf1f499372dc102d6c7e576a172af9db9344fc225f6cde28c22204d311e1c2452a457610ec94cf5948e44bb04ea3a40647925c22e5118cb574e1fe69430ceb4344cb1eacc234409e4b111e4107048d821b353096f90a359a869ec2aec78fcfc882b112fe85c437be465d9778a59203b43914ecc530f690c78625d7a9cf31e052739b81c6b2799cfd7307ceb21a6e5fe8b02177fdfd5fb0bcd852a1eef6d80b595c9195e05c7c0fc4621b349fe46e3aed9e22a3fe1b281a31c686b1c6f35620e2a2638e6ec9b6ad04d334b708878a9eceb28478ac7635f939cd0c70d0f2e827d1e05699f95e63531da1b9d2b91cc677e8c773516c18e64a3deb9cd9f42241deea41630d6d6e577d781f37c3915c123d5f3df7900962be6569e2ea8d444a55360030faca0b41dadedf196be6462428e8a578ccee843c664f6d7c4a0424b20ba4a4054bd9419ed7052a77e82f66fa65195f336cf8a82cfeb05a90458efd00cb00220b22b9ddb1e4b9d1c79059c9dd9085663ac51ba363e631d80967d1ab1c1b813869c596f4d33e9009f788029edb55c73c9a1d0936a0c1fc16bfd9a74d1dac14591f807b148f11da2edd25e829b009166aba545079266be38b80e6a22c79878f7a4939a9e1f918e01d6f0f18ad4d04fccae8ca805d63ac0c48aaa2ebbd92042b8436b7e82c4dc5e5fa3d6b26a859ae94d4894bf84cff4e6b377bbebf5c151d114fa100e969ff47e6c58c15a3704ec4d9990d2861c54d03ef5af19bf7d556469fc1152d03bf072389af90c17dba5236bd63e4be222846b70f9202958bbca5a83586f18272b0fa24417ef01004cb62b064522f0ea2463a0c637c9333a147e0e30d17be5bcb296337a14a0e1ad521d465ee845844dc13e9b66e9c74f34bcaf52f7f12c5e6f660a48f9c952fa3b7226453a1c6498b825c0dadcb36ec846a7269388bd5489b0670257bcad32e2d9dba644f39965de11527909617e5d7f309bcbc6ac6f835a489adfa3f0d978608c70542b06e003ad74765eb4bfa0c5bcaa70c1c72cce1107fb3f432870b237c0199568d29820190a2584ea55cb472c54e80d832ef6c6ff015ea200afb65c29306fe8e3f9892c180706aaca024bd0f8da34f23efff2b953efbbff0346c9708906bfd74e58890992def6871a131636830ef2ef65527738c0809fdb581f36b31fd0e18d5a67fac50275e8428a17426efcdc6c3d7958941fff1710b612d07da0eec758624de735596d8e73b988969fbaa565254a9b9bad960426d50bce08b3d37a92a406bb74ba75bd7b2cf72f3a4396468e23b9632775c54797a3e6f94de2d9f3da28f3fd955bb1c3c8bd75ae2a57301fd16cd9c5aaa03a4a26e3889787a285eebe8e18d39225e1e83a8dbb93d9eb349c119a18d9c2edf685fe94e1ffc71b48a7df7486674bbe6d509a50ec060c6d3128abff5839daeacec2af3dd7355609dd8382ebe164d9064a8786d13cf346f52a7b3b9dba13072f0e4e8c27d0a9e1f4bddc391e555a1896486411ee7c6a1dc59afd210864c30f5bfc7601dddf8776e928453671f5a57e65eb2a5f5280b0b763714f555347ca8a88fa505f27296109c494f874548c3c2918d42afd0e7946672225c34955d164a1f622031df71a6cd3ea0ac68d5552b5fdb5b0259ad8493c4414fb5b81d8fcd8b50cb44fed7a2c506e48e73519b5cc024680c37f68bf44cbdb42556a97265066fc09ce0f28cea9e8c4ab6e8c90882ffd669a8ff8807578e93914cbc4303eb6ae7fae973ae6a79a07548ce15849051ca7e50b097aa624aa4b2eeb09f2dcb31ea1f746f8e88a355a03d105f4c61a9e5775fd7ad25c25b807058ba6d1388cd66ee210c2e50b9cc1e6a9a8915a001a8923194891b029fe87958303f4ceef8cc6d720cd9bdf5f26f38ee8573255349ce66f85eed1ea4f69dfda112c210bf40d6a6d63f779edc6743005b0a1e43837417f03ef0ba5083b6f2fba864e8c6087201c2de23ae3ff7dacfa629714f45af2a7d97f7bb4a681193a29277702cc9c9bca7d3fc82f3f1c199b5dada96f9b6744a04bde2594a969e3dc8049311faac2a3ccae6760a96b67e869ba667a83dec9d7d9b1ea046efab82ded040d695313b3ebc2a5f74c0d0e0df09ce3c9cb52b07b77fb81d390d84e1c1c739d015304f91d8ae5bf3523c6810a903c19d1b3d938da58cbd2666b8d8aa4a5a4b4157ea117f4d056043fdb1e3c649658f854b972333a8f098280d2d584b0a4eff9a03eb6d7f42b4809f34c4b31ad161fe74f765e1559d028fe2adf3d0fee01db5442c368505396e6b4ab216f394b0c4eb5050617d047ba5d958889daa6caf568cc6bac48ed6a7d0c1f83d4c858083867d69e1c98ba6e75415d9aac7183b4d87b18937fd614fae46875aad812cfaa8ad5e7dfd72f8d8fbd12250abf3fb58f914658753789f6da62b885d14b8f2d5ffab96608abe1ad6d7a47ebe4c39aa76dfa904025fd6a472ecba6685a9b4d27e8509746d51406882b052d19ae7c7252b8f23ea6c6b2ed4eec5f19b05b95284e778bf331799137c173674bfd2f6b753b5f68089eb4a6618948185e1be760d046945cf5c2c77b575848809e8a8b592177351b8e3522e35c75c27ce01def285ca6ff905fdc822770fa9b28f34080e291e68ed86489d0580edf13f4a2e5bf604b7b3ef8d1e7c2a1323a51aea35ab60ab28da43bb5c074110ba41614545af4db85162d1423732444c8f5a3fab02fda8a36524e20eba6eb0134f0e72ae04f4624072fb9ba51a89e49e198944be459603bc265a0b7b3a81ddb233e3d74308ae8f2c54ac51508a25d28362ca30e46754542753c78053402e2a424d1d62fceec7ed844f3f4b9650ba4d1735ec1afbd602884276d33322971175d797a422a77f353482e3ba1377f18cfb336aa070a8722000dd6213ae2b7e7e671c5a2b98cca0d99b019ae15f288913ab5adec9d35cfb702ce2a482d049d4e8cf86a645f227e792e5c338af2a47fc51f8973ccf276ffeb77ccc22d95a0b3ab4dfe8e71a594f4c9524592130a44348f6845d267e824567e6f55083ca8f63dff09488a4b1b3311c89ed29186331241f3af6b055f33f839891d068856a007b8dfe160986171eae54cc8ef24df4e31b373ed8adfeb655fe74a0d31c7a66136d7876ca5720cf4949657821ed8cb2a305e83b43b323a2b646361e7b66fa8eb48c387797ea11ff492cc7fa0e3337508da952896ede6216c4a1e02005a85164bfba02f6e012b4e9a70c38b0c254a466e0e5e41512a0f406ea286cf90b5daefbc1f43f9b905c10c723bd9ecdcbafd8c6e53c2fa2dc4942867f0b3e82576ef7d7ba476a6115716b54b7c9b4d33d444a5eae2eca77cb64aba51f73c76e203cc6dcb889884a7f4a069494230bbcbdc6aa56764e5d5c23f4ce10700b79c43bd9594536d352ae7a39d8490828501dca720157f802a65e9751e9d8b04ca9d2a4154285b3d3ef45d02655cc1e4a828a72f0bd8523d8c373ae63e28ed665d5d0524e21744784b7ef520265817ee65413776142817b97ac37658404b8cd597d89f795f035563ba2cf32c4ad4ab500a0b3e3574ae50164d10603346c348868e8b7f8712c3bc6218205f2a2ae9f3ff5953dcf214d31508422bf33a31bdd12e03cfbd33c1216b780432c45e6eb841346f0aeb9dd9d800b4b2a3be84dfa73ba53f0e631f709099fc0b7827dd713b0be8f82eb81b6500d6c2185cb3b524d0dd71899ff4c4cec3adb7083d00d7f1d07ad625f8240a24a8cb1da87fdbd5f37fd397cbfaf6df99fad80bb1161aa3cbb626cbd35618b87f815741ac253506b2fe665b95f9a755c77b98f4b97ebe7642b1ea42b389ad4c4033a7b0c3265e940bf37568ca08a8fb1787e8e0762112e23d97d5e657cd774a48dab81c965beb5940ca5085366953037b0eb577939df8ff6157384710c07b0ee40bb731e856935c63b90415ac9e3517f67f4bcb1c2ce34cc2a4b1f3aaf285383f92c9bfbc1df833cf123b15503a787c22789b5d1f7032fab5e19dfa474baaf1dc5c3467aa30edbfa6192f23f4d3e602e50c4730cd2e5f2c0b42fd41715bee669705ab5d037ecb2b3ff1b548b6293ecef0e95ab802f07bd95fcb5ad9a6e763bf92600e3564d6ab1d042c35e368fb81f8f15d69835f21092162f58dc0291fecca35537b8117e48d77cd5cbfac875ea5458fefb6ad5581b921169acf8f2a71967b10c2a42e60f121ef4c969cf0800fcb52db21ef19e26e0fb2ce6ddf2a0e4166ce12bca4e8892b4f8659f5e483934d1c8203954bea784c9203c7f825a0fc19d1fe706290233423b2ed9323402d8fda490769f1232ef3ea2cbc2a3101f5a5062db1f70494918485d6568f4906e32189ab0e91c517ab3d3fe596ad645e4feb0e53464a1854174400d9bb6d85d2df76242c234c970c5588477e9837cca5a96d48c2e10c1ca073cf83b156de8a53b047c7cefb8efaedf443c66b4578ed2c291b3107ecd6d77033f8082bb23178aea565fed2f192f64bd5d0fe73efdec3e936de051916371ed999f70763e9b7100d1f63866dfe16fac217e0b73b672cfa4a19acbbd99eb5901e444ad6613481b335fd93ab25be32e1ab62d8b06748a3f469836d65295eb7ffa41458ee67754f734e4c220e1923a1a0f235cd9440f02b703a9eb6c0a2b13801b5ebd8a9794b7ed0a5ca22dc829ab6fd52592354d07fe4c591cc0018688ddd24ff104264a555e90dc48f44692f7a52c910cdee98061ed5e248921a205aea9dec3ff9bc4eb3b63ae5030c6db994fc580d2deaa4305be8d356fadb30bc9bad2287116c9f3f16572bc60ff30979d990249fcd3dc07052f8060c17c87e546970a2593ea4947acd3ef625a73e6b72c81f5319096b04cc629c5d7d865363db3cc75367df29933851908f96a6433b49cfb11c88e9ad20b60994dbaf4b8b2227aa9ca3524a956b1a4d0a85d4812a20b3b1dfe7f9b63bc0fefb9ffed5221299e15fb0d5de930839961d11bb5a9f0ada3ca7b6a3e1df6c92fd15eeda3e0dc6ab93996a7eee25eeb082c6cb7d003f3d36d72b2d84e0002db24755853b18209d401e3d8e5aa1f29f55239947ca9a2d21298e8c6cf1cb79ac6e1e38a210e82a0c929eee881ab9c752d4b215680695016f5bf1ed9f9c9be45c89443cefdd260b5e36bea6b2b6d8f105bee9aefb33c0bcaf666afb0f283db75d6059e6dd622e6c2eb2fecd941ea04f831fe96fa2452efc2a87ef526b6e3d9f9d62ce05fa67460484766e3d67c741209213b4690019f057f321e85804c434b27b833ee04f6841ce19956dd6a2b0dec4d9bb6cbd320c68def1352f3bf818ed95d8bda76e69cf811c0920cc21b378052aba0887ffcdfc00d89e5dd4891eb2228f1896cd2f2265c40e4d56fc3682f6d4f7f654c190944a17884d06493528127211c8aaf9fe45e6d70bdf75b1447250081257af92ef3ade918dd35ea0187b6a22b384eae7f524b45dfd6425fb35d0209c419eab9608ef8ad6be50beb8179ee5d2915cdb9abf4ba087c973fbbef0555f06631ed7cc0eeb03d697dabde7ce20901cc2f3fd3a2291288d721e4c77a7124596de7f64bf3d00a0f41cfc5edf530cfdc41e1135a14bac2cf77bd4d09b8a1315300b3c61255f1004f8801df134b53b264854aea1cac3cf5f8e71fc719523582d0825ded1abf80015aa8097a9da1d5bf5e3d03452eff6572cc6e757ef26dbb2ff4c8618bb210afc080fd4150c910c2ef9f6a6658b89a4f066a47090b303d8bd6a704e747047340e23e0b3aaafb42aa2fb30bc041179e945af442c319be57536cd6c33da404928d2eb6f00993646ba510f7621ed588e0562af11d0eba71ce3ec53114e3b286a900d677866315d4366bfc385e202af19673117cc8983f1efc183644517cd2de7a5cc2e59cb7ff7f512b55c0a52df238ad69e37651aaa179800db3af53fe57b6b1df20952cec8ef3d38b3f4f21ada58edd445518f8130d5196c02ae09e523db5844379af154c673b7ee26540aec8fd1f151245033915c4200e5a642ff138d5f2159f5d33d380ac08af872b482a2e1a9dbc245a5a6df4c62e5ef211f2287d6c2dc66decf1200a22d7aa3003e1d4991700efa7dcaa0731314525b830731cee5f2aa03c8d230f54c41ec86be6395637adac8e58166e32960d84f63c4f5d9048b85d02d72b1ef35faee9af61546a0e89ebec04cb435c9aba4e87bb2cb4044df84f2472f63c74cc280debbdc4cc0490bc8af67c42e7d196798b4bbc2c6a0643410cc890044a07155fa2cc04cfec8f2372b1b736d3c37cc5c119fd4ad2951f0b9555ba04ced63716956c07921017236ada4547dfbe4d2df48f653317392683eed763680fd18079d4874771cd9b2f46b00bb7169c11177bf26400068b098b3632084b796079afa218485f0e1106c61957dded91ef474eb881e4e35765a2685b1a24a3e1696d607d98bc6a020b16442166bbf25c0b7fee62a795f58d920749acf2cb314c88411197b21f798d1fb74a495dec1d12706c8098937832163caab42772288b3951dd1da8f5d8f94074044173d2ccef22e6e971d16d9995a7ac33c1bd71d1cc3e6f9a0cfcabe78ae446dc479836e06e8f7874fb872018d5cbf36eec1b1a1593f92b99673aa0553a918b00838acd74e24bbeb4ecd5729c88f9ab49d2f4ca9dc53463db1a9247a0e77b571beffebdf5a9fd24ce079a0e52baa60afa8c87f6141c4365765da881528c604e61754743b9fca794c09e7345abe1ea3f0a53867b278d47683f487c37bd25a0ebbfb97b43d499272148580aedcc839ca62fc883baffb8353c003fe979b4f38ec489d03ea53d7490b186c1db70a8e4ef7244ba750bbf2cb65668dbcea667f7ea577a7a1326b685d371330dba2c5290030934cab3bf6251d3012d247c73521954a5be15f0a4d377d752b06bfe012fd99518692e7d8f45af0b1f45d8086c6ffbeaad537ce54300cf7f62371bd89e6658d38576782947539e3b835ec69e6aabee89bf0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
