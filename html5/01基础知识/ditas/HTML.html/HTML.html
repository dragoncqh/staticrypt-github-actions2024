<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4454fe4d900b00aa24c20c8d9c6f25d56b47b4b27ad066d3582d1006121b6a3e8096f9859cc34a495ac666bcc455150e9fbd19badd6e6ebe4a0739a062985b77129cd7c161d467e26fc00d1bd8005d5af1b3295ebf6174939cfe5054f4cb31e6933c6a1d6d71d659e804f8ba331b4976b9bbdd090bc53f3b00f9910bd1697aaa2ad38d72c11657a09ea25347da1e8d53cd9c8a47e724a60e43ba8d64681f1b2f89fa31e68b95aac8ff91f4665dcba261b8bdb90f65039ab77d311ca4ef9251bc65d0a317dd86a3ab13e1e345c428a7e3f2bd35e86c5f01672afa20a95e31b684d4a4330ec2583becce12c9e68a89fce67d5cf2d83e94e115b4cae74255eab17e21ec217227fa74e618afa936c2a05309161c4d69a198abbf8be1b7769723b0b578f8e3fc4b5e82df5beec51163700a1487599b1539a50941e8e537360faaee8b920afdb5998953415f6b13884150c99a46b97524ccbb898da48d253f8ebb5081b087fed261dba1fdb258d632ca5570723a46d805f5cff345b04c5182ee90321d22f7aa9b0401f84a1d4d89a132c55c687361801ec209005d4942b0506917090b35c51b0e1c6434b65411820e30c376cbecc319f6cdda58927f8332b5c0f6f78c4fc1d682efddb59113afb72d1282b020d69f5b52afebfd3210c69bef68a97bbaeece867e9b915968cba3b18298eace2cf05b2d9c4f46aede16edfb4141e7bb95cd53494ce7894fde6ee520e8795ea245442c0f7cb4b2768f9fd06052ba030a7c2c52356f6ce56a02a0c75ce474b03b532d5230f4795be0b695d6f37b14ceda6c42d9d2a3cd13d6a97aa8aac282bdce27235f63d48b7db443f6131dd89e46dffbf9ffb208f00f4e76d2411275356a0dd8d534e9dbf43e519348e08561e687c18b64dfb835e20df1dfc26f65deec6b6bae346cc50c0af55610516988671adb2ffa8113c0d0348f2ba3f1bb25c04d7ae313bc1fd90f9e9ed89798e0a05501155079594c3d27f8442cb437c6ef13cb6d5e70629b0cb37a0503ebd5a532bb0d9b6804234f2dd3b5876ddf0646566caf9f02c40aea715229beca61d32a20afb656305298d7124fb05f4da3721774a27b44bb547d668384f7fbe501aea332017e6eff7f9fed0c5cb41256ba6374f4a35d2b0fcae0bc024eb836da6ee9037e5bf220f2662e83aa45068f3068b073684de68ea67a293ae31d557e91a0543b7ce2cbc3356ebbc722f6fb78fbad424bc87f2cb0a2655705837fed702c8aaa3ed5a2176ae307474fecc1d3c670cfb9020c96c6e5b54338b6ba9bca6988e24f083aa941c64bb23fc46965643e90121d6218a850f2e3c540fb2cc119ea1b578d4995d3b3f0a7aec48faa8be73860bba3618b2b459857a4ac37ad75603fc0391e07284aed0d179d8231dd75c754325423aebf87ebfdc436b8e59920db3e379bac8a25b18bc8fd2cd4cb23541750592b14852e81900e8e44937cab7e3803a1fc70c9a48aa2021bbd1a612981b034524ae03a54c25e2d2c0905ade4ecabe133ec5e6889dbfc10d0bce0d58998d5198c1d3d028a23719e40192093eea37b07f9c5acb5c9c8d53175e3e787b5dc33342b8eff1d46b4365d069f9561a59fdabfe2060eb4d11680059453194e62aeb488a8d320ee366bf692f18299a96afd2556bf2fa88823c418fb32fc1ceb512a3de8263b2851d9066c57ab3688ae55b8cc6b56fa5f17e83a8cd8cf125d9fb824d055c5f2e0ced5a5807211cb37f186f9668ff7b16c2ba49b26baa45d2a12d6d9453797334f4f8d5bb7e48fc403ab7156250172c94053de4e095f1e889b5f8255483c251e33387ffa36083e4721a0c6a449c34afa1400269e38be8830dfb695677d7af315b15272f3edc40d6605315068593e4cc12fbb62ae8f7baa99c1f6cff1360a0cd42dbfe70c4b687f0b1e84e36b6da6f4e54303a5098d402479f091e436ee13a16e2267336bc440a70f75eba07310a1f8019e44263bd445fc173a36203c248d7662900f9a21ad7964c42072d8d0593ecb998f80a10399402401112115479ff8309ab8d9c55d61a1ce2562354c61962fd44d3edcb700205f8df41e42f771f7b4ae05370c6a240bde04a4b9bd7c8547ab0177e5496fdb168dbb9b02b274673c475c131c80065ec251a1cfdd9af91f5fa63ff7991bbe0db81de4f8dbb66b1ebbf70b736321fc4eb76edc0d77bb6d6b339faa15cd26a13392f81c6d7ef43fb0513c5ae4a8575ea0dc4b49b79664c1ae3bd29adb2431356c5d93903cec8cc9b09498573b4e022aafd747168995d2712a7779c66068ffde01cc44f8002bc40cdea5748d8035d0d393bafa5b61d81ea50f72ebb46e458a5d15eadc9c5f50b96656704671d3104de7c7e8ebb83118a343b8768f39f31800e775fcf3379d15ca482edcc26b14dbfdd4aa6e071bdf34373a89fdffbe2bb7fa749a1d6d2f87e55b5eaaff9844a99f8ec301f5ff35b141787f0be82a6cdc1f2940eb132551fd1a5da545e8d7b6ec2528cd855ba6773e23d0ce685adda920055f701549669f288ce1858e0b42c412cd4af0f2ae65b38e6204b0f0daf56e4c94a22418a72a6e34acc4fc3fe2a6418a33f11dc7bcbc77c3ef09238249fe4d48876316c4c7267ad7758ed17f602b7394d95ac22312f671769aa6e9e997c06811e53fbf6cafe163096675d62f4cd0876e9525bf568eed44c4725d11c35f19f699afd1085a16fb911de828a43ac13cfa4152f974fd5422c3808315465699dae2e31531fe5dde5fd0d4411d4d59ad553c1824dd125ff09e6208f32add5377ce4814ada1ea924ddcf54803c2d8bab7cb5952021f384bfab97540a310516e62c028c3159d4578d76be9c64844c5abe7943a7d1f964df0b38da6cdcebdbce56c3ae13a3f77e1785af4aa8b2396f04d0853cbfe0da23f724510c604acf75434b7a3118c581e7f8dbaf807fcac97f7fce6c916d22b0f0df95e5b3015c3f24ac795bfb2117f75a0e67e39bfda9216dd819cd20f9f1a9b1c2ff1b2ae7ff20ea322746da05d21b27f5df5b409c7ce8904d75f0e65b0cdf7a759bc4e1b0c52d0c75b90d69edd4023707126305766c19f9113062d4386bc9ed1344f29abbfbd8af5bf7ec81c79ef8e8980fd020d2a4be9e9f348b1ae381494f468d37fb24377493db2f9a47233aa7ae19ca584620439b15a95b8f741f94368228ba8996b9091c17e89750b05395ae18f3600f69eb908969e8d39e11cde2e7cb1dc6a036e55ab820fa3dc51726b0acf20286227963ae578dbda02d1b938e4180ab63445c8195fa32466d55fbf0810e95db27c929f9196502e7a8731c61a8a0b2afa52fcc6fdcc92985db5110543acda932be73f7ce7b285b3cb4bc7662c52b849681c40eb0505acaaa5de7adcc4e13337e46d9bf41b2306c9b96ca65453e5af5b5acce8c9854da875a59e6820657e616a9cb72fa317ca03166181588134fc50b409a8bc421f91646cfa5b14ae315cf9d4e2b5fe3fd1e0614d43653bb84139ba79106f3d82f5f519955f94b3caee4d803a40ef6dd32488475abbfa9b0f0e116130610f8b4b0bf1acdc08a8df69d83fbde8cae6342585401b02d7f0883650f48910004b1d1585595fd98f8890e292e77cc6cfaf203ea138ea227faa7c520e64bc2b167935faa59398beee998eb64ef8d337c199fc5bd16e95d862194047d62a70cc797d7afc24e63f821b8040c95aa4c5f8e1ff9d2ef322f5e647ad707f5e1fa57ce239ca3d4177ff73fd3f6a914515b715987abfb61e411030a6656d4a067ce224eb2730c2e85d3ac989bcc71b8eb19009039b4c36cc6da3bc266f4744d4d03adf3f36a1b410ea5b187729159639fed327349fe2338fdf1661c196765feb6280a9ba2c2b4bb2291daa61a2c268f6912c887589c7bf5c74afd1826911cec9abfff1b4fabc37dca29d454469f9610429d3c13f513f5592bf1fa7003d7ca751db161daf89df07d2fb7ad13a07f036c92c33072a53ec56529e15dbf9ec6909fe30bd586db9341d582f063dffbc8d0aee3b17a85394fbda5d96a61dd721c3a326b2a09c1af2c6a31218849e746dd2a85a68a766e11b287f4a9bc6c6b49d381b0274b0bda8fc851d2eb40701716721312a762b03dfd708fa19d2f4ac820a3dcbc791a686cd6cd4fad7565f0eff876aa4e42a4d8eaac47e059d228ea4c908d472d8ef6f63ce8fbdf2179b1c00a7398b2d1a0b2fbdd1085139175f021143f803bdefe2e2d1162d7b13e3dccd629d2b7dd9d21db35cecc41d2a9b5fb0a5a7cf06a45f543cd5663f4e515ce7753bb6d629abe910b743bc63def6b34d70a9460d7ab50f05183d5f86019d7be56f1118d03f1312c671fa0164df9069201c92b105f1d81ab6f3ddd3309eb4ccf4bab81adcd0e96aa9277556f2ba915216c736526f1c65664f14595f6ece29b2a87809761b017ef07c57c5acceda0fb38f02676afe9d3e9034347d268127980d138a3f2eb0cf2007bcda67709000cbeb01c0566a01e8480a26bfa7bdc374f8716e67d0b566a57c4e8802bb558bfa967006dee7b1c600747c7c418bbb2bc343f6776b9df1782c1004ebf4325c46dc9886da55e935b895a623d06ef6c5ea36608040474f943b8e2dc50bd793ea6bb5d02e9443a05ed98103e8f09a93232511b14d9bbc1ce203bed5983c846ec4f208edcc1a006204795d52de5ee0066a807c0742b280ad04b08b191b3491af9751ed2c1c93cf514fef5623a99500cffc9785ac605086c751acef0ccac02eac8d4a58428157fce49db35f6fdde316a68c257b02efc78eba062ef4017c7005ec09361c868625dbb19408da667db6413be2a6b2c06cb3f1dba89d1b8d0123371cdf39099a6f98e1c3fc91d793ea710da13358c0822b0f422d9ac7907d9a880cf609ef8414364947619fb3615f211bb9288a8b69a56738f61b68215917dffd7f8ca828423703f3de1cc963837dc1bac66ed758c721f028518e147ff1b7442549cf6aa9c679163c52b474f5634bc58f5539e6d748b1827a857dc674f6421dc61fbfd54120eded445d130d24404d2c41987343b23874439e898542c577ec24633ed2eeb5f606d989e83b373450b0615e69f418fceef1cacb444d8da9541f42452bd3a7672fb8a107559ce99b65c4fba7c2f5a33449f03b1493296d3dd0ddf99b043de6bf4b21c52a379bc34f4aaf866f1cdbe759f8e3720684013537d7e903eb52d0ccb89c1b59cb13d6d4478f8a059499485c98e15491e0084b6997d7d58f399831265da3ca793d0b3d14296ef076a73e9e89c37b4cf9ac67a74a5ca77ce4c8833042698efc7883805f716e2c53f8ae83d764d2370d5854fdcb0c121e955e1d8798d5b28b7c41dc1877fbe26f11805217062f41bdc912e2e55bd71b3942e0b3dd1f64049e061058dd4f0e248c2d2a48a57f86fb3c0a5a64c7a5b71bde3d9254697bcec6a4908ddf2cae48c136f164f49a00a4964f15a56b2453b7626ece9ed7a776e1e867377d850f15b27a944b307e04fcca378fae2f271c4d77c856ce5b6bcda0e75812c3a4721a05b9cb4e9583d105f99a29721d624bf85c176f0b3a20b72cda93b325d949ed9383ca8f251b3459d5cc9e0159cbd733d6947c0de427371a8a4f825f02a9aee16d89371bdf151b2960548dcc4905d2cc24585de8219c3be71b61c5679ed834acf9249296131bfd1304495120d37d21a3e11f137c20ac421852e7df0aa97a92ccd681a6c4224928e45970903f67ce35a8bc0b96dcb5cd55f665ae8399745e137b6da29603e76c1cfb22f8aabf60ec888042367c53799e526bb8341bbb324b0e29e0ead72656f04ab0ad661fb318ba955fb93e72c4d378bf6ec75f9bd35ec65f047f75ddeedf04ec94771db3e18d3b849a346bc3d8be39d916be39c3172c7cc5bc7aa0fe20b238e87aae7be4a93e8b5581edfc94f00b1165b6f90e26530b4f41075022e17015ea199549b3863c53d91cfb623b9daeab2df28947282ddc69a0059d30187b9799fe22aece8f595458c84facc2d7347c8d1081eedb13cfdbb7b3007a22c0f0539b05ee0984d72f7a942078a0dcddc61a6ecee21219c6754b8ee98029c6d5d77676be31962f7874e4431d3710f95d28433ed038bfb69cb57f082c8ef9cbf169e21840e971d500ba163a75c71a9f1ae5958f6da1188ca623fa77b47b866a7a157073f65fa9d39cf2650eeb09a021b5d504dd8fbd1dcd87db739dff6f2144e85c527e98099df0563f20d26694e94b1efc8099dedbca2351874d05101c3dd4eaee658801a6abbf715d9877828e4cda8b353cc1f04e2378ea294ce83153eec1eb3a5bef294d8777c41e0750442c8415e86d9769b7360f9fae7284a2faf842ff6e62075fbdbe68989904cec4d6b8fc195487817a6381f6717c0c326b2c824c951bc79f145cc93a2c865cfadf3c945a744fe06d73ca479c9b2cfa1b9ddca080a5637fc10798f90d4177e3afa21747a0956c7aa59ab51a3f4448ac50dfbea97d78d860ba887cdba2adceca3feb89a38a766e886a795f4559c0f3ed9ad4e35222f40bb3f4f9d712c96366aeb3c5305c185624be13fe7720774b6552184025db3270bfe685a17fc194de4a718fad4e279d9cfc61c6d62ff5bcbc75b323ac1b9aa6a7a5ac49b5252ef58a25af7e21adc2a78f14dce464a5fafbf7dbeab1253c458d74a1dfddcc4fb11a8ff6eeb2fd54721fd39d6dd7a032078669c06958a6810f3f2aefee5dffbfe41aebc388fe92a46c47164015c98d352014f045c76f67f66e3a47ad56821dafe5168dad2048ba6a95e7205ddd212657e7b4048b8bba13e46ced0b78c11e2b3cc945e40c72fd9f1b15fb6a7511d15ab2dfa576cde1bbd8912ad58b6d60f217e6eb580f21371df06a8349aa07ca24e7f4f0858f7198928e5303e0b1aaa086a86e90f3e7a3f5be84a4bff0f36ba33a9c94091e6fe61c7f1b74df0887d9896942fac08fbe05bed5aff74d42026a29bab772836fac9c14f76cb3d558525a37c4be2a373c105f86ac9ae34fd19909ea2ea16a15b403553c9a2e205b4a2f7cd88fa9999d811a6d7b9b256901f9eda3f4bdd172497bdc82ddbb6e9b21e292a13cdff2847b5a119783427af5fefd4dc0872c83fd294f2f748386de7e407809b7f5c7e85311c5da7c26fed89194050203e43775b92c05dda2058e2119eee1fa74fd105d24b9660bb6668c4830d2cd31c83329b88f060a3e6119311c3f1230b968af9dd348f7f2d13cc66be75e2eb88b7a79ca4cb07d7cb1fc79ba36ef6084cc4d28d388f0e945f4fcf4abdc2b9cc5e2c9a533a41eb439b70fe909118724e45dc566fd2e566fad41f7bf340b4e00b2f1b62949932e885c8ddd8aa11dc5d79c51c49bf678dae21e20333c88e94a25ae582b1ed80379022aa95ae83df1fd7215e331c7b87589dac8c48f3812a05e80b98cebc8b1333b6011afb6367025dd6b29a6c9e71b098a0a5e2e8c1f4f5ed455f76efd564432e11b546178f5438be7ecc0401f295b580c1de86d539a48f8217b14814ba47a25926cad507587627659bf0c7fc5c8f0e62c08ce0747363d38a019da6d805e4dd2dca4dad0d677fb74064d8096dc4a9f3d4bf303786b03df5596268e73675116ec2ad533ba8f5667fb59561dc9463dc8bd8b16c068bea1eab6357326f74071f91fe90103ca8db531a6d3d238fe620d30d50fc6f51cf0cafef5280b35e75ecc71a16f0a23153b08f74ab50fbf5f995d89d757598c4f2eb3b18617e469245cd55e3d0d173d70bcdab28e3c35d32457914d759b9b8a4eba1cd5916b9f67b70c3f33aca12d3d50303962adad62249fe84fc4fbfbeac407250cf989bc3686367f9355ff985ba5bd8c388bc0a0297dfb8fa421e6f241c169af71419f3d9d57f1f3f34c7dcaf47cf5c26a20066a24d31d43baa3bd2ab7446c0692d81fd5b9c54e046f09aa61c6115d164a3c8d73784f36c20da6ea551b0cbbdc3f2ec217d463cd9ef26df499abaea944627ca866f3226dd8e62173161fa357192577c35a5ed0e86c4d0dc6b62d8966b9752d4aabae0f711bae21d5017ca891fd615e5b1be7eca7bac6df1a61b282ccd91b85a0794c3e4abf719de6579269b35d64eafb3dd7e471a2b6b7fca9ac38e13051d544ef1a9c1bfef37a4a1a1c5b86355168381d4983c54aa9bf488345ebdbf62953c2c24f66bd685114b29c6f19de46eaf68372b1202a192d818b968d22d841da3aa3c9f41c97ab6c3273798aac89b7d2a653d35a95c35ed0d97c6a03b12e3aa289c5ec353aaf7527985ef53f4a6cccc25ef95cc5ca916d41551ec03e699c15b39aec90fb096623345e7c8f8de74f421e1e5304929db1cfe19b7cb56a3ae53e2a4c2b5b535209634b2c2b8476017bc0616d6a397b8e3697a7c5e9679aa0291c529aeea012312456e7f6c6586d08bd9ec8745790a8ac488da045eb1c0fecc16ea5cc48eaaa2ddd526c5b397d6bf5879d9c0d93f223d50d589d44ddfa1cc1fa581233d1e9bc7696080a8d30d382221a7a4303763efb6a7014b1e5df5ca29726885e7bdcfee7a9a6c775ea03f76bccce1d8fff8521bc855c57560d6b7b458b049d0594c2a564918e4d831e25db8fd8bf4d496df69811d7ee0b1c15a06584c8f3d6cb87fc88de17823af3538f8cdfd55a4be63d5e20bcfa70e45d023379f25fe5a6b0370847e88afe28253ed66ec0636edcd4334a43303788c2b53667154242136afabe62c0eb2470fa2d5f13ee0373227b284d59c5dedcb52288568f3dc33ec7c336db3f2d1d601c97b3b6d34cab1a24ef2c51fa5cbbeb1e5cf3792ff57585b9079156de5f5301f54bf606b188e2463ef486a87e7819d1fb379a2d4eecbeddaaf46e3e1838630ebbf0bb856af705da9627080928403ee49cc1f9f95e7d887bfba97896ed06a8a9c56ddda13cb50b23b0dca3423a2519aceb54daf96c8c185b8ed53c1a7d6d6f6256527d2b9e7c023095cc4fb6f0b78926850c0bc6e3d4b03324e1885fabf6be6067527c0d66e03e7c9a88fba09f2abc2f6a5ac0bf126d563f93fd346b480d3e6d73619bb91b435c0b08ea0db612916980e13773b5d5ee8f34993150b9b4f2e98f874726fe5734ede609d66bd2dba7217595261ded690c728c9de9ee60c6130da067a6c9d61a7f0c5e3298db735e0d0cb5d2135f76bb13956b26feaea6969631c61b31380f49925333947b821b888bc900dbb7ed84d59094b74db029480459962e28ac979f5b7dfedec1ff1377b942a439518035c736b238871fd5fbea5f10b74e6392034ec2d340815848e7fb476a29392f3ed352a94429e1419f290d4f34659addffd6172d7f57283f61aacc5fb282eb9ab10ab19dd9582584731b59adefbb16f7c9267c24c77d4b1e6d2511d38441eb14c2bd929069f585251af2f579570826dc5bf30cd0b2316b2a34827677c77e1a64e17620461cedd519a6a315448de7e305dde77574f2004b6ce43e847d5e0cda38397695058beb64ab2299f22cc43e4636d3e0f596cee6fa9b999bfad5046643ebd1c95f100cb2c97da0694225c8b7c99b8e75855adf911e7958085f877ca9d4d9e7a4f808b6c52993c5ba7bae1ce8f8847e44110aec90764b1c7db86ffd809557d9a474dcfc7599899f1316dac42b19e5ee4715164b7954a3e91762be2aa7776bc99425e575c890bfcd84644ee3ba61a7c0989da009679a903c7d1e979ff7262a099d112a3e60eedd2e84741d0b237d7296b5b4ba4670020bbd7b14e275172c306f91ccb586a5d5d3dd95c37fe7b0fd73f2f3a449890f67092efbb10b87aa002ab24a5d146d2660d48f1de95d867f3847da45bf980579c810d9ef4fee0e97f7dc7011c32ca59404f4e6cf32987f32d43fb13a5e795a3a8d5930b37d42d906875d58219185d32718f5075a7e220b829c5a0e7ed830ca2f0dd45686ab57819f7b23e6317f5d013d94d68bca922ebcbc207e23dacbecae137a51549809e6bb080781d48345f14433dfbabbce6b9e8e64b9a39bfac72bc37fa5c6f3b6d81c93c75dd0b99a020e9386ca520c5eee179b7cf3e989e634c6f6bc77e4eca290a8ede4c06f34f407929f462b53d8ab6fc7f114ca4a4c0ab1e0da35f4167152a09214b4d806bb71d9b9cf204c0e6f627e1ad5d57814b05672b95f071c66434eaff3ea721c6439776f72c1a891a18e0cbd5194d9e52e6ae88362e2f09f934801c5923430b9b13fd63094ba8e917ac750b7361fc66639a06e5fd9791ba450f3e8ef32d15718b885eb6163aa841d38e323bc6ff48be5e4591e8df878c1066662d5ce9294303717e292e7482aa90c0ce6e95dba6c6f870e4cd1e8c06e5c27c593ba2d0087f605c9bb27b08f354285aa5217e7ce802384b5d8d6e33d27a5b1700d77a4b24cc1321997cf99cc0617f9bd862685c95bb3a3113069cbd46345293f3fceaf12f484b9f7567e3c3113814aba36ffca3bd808864490a7ec58920f39406e2ea514ceefc3bfb820958c978f85c5c779b56a15a80e61e95ddb5b5440457999cc64d6a2cf16c80df5d7efd5b1e9dd046961b5c7502964c58f0082265cb2d9dcf13ce96c73cf917aab14c907a339f1e3510195483a559545269a8b442285c25d997813e3db7d1c267a936994ac475bcb86c871aa895fb670b76799f79b54509a73e5392b3a6aaf9ec200796f7dc9c0a3560337de9790ffe7883ea17cf8cad56cc304e342729f24f6ed90179b2100afea060217220725206dff750db3980587ae56795d6336ab3abe69e953682767b49914491ba6e2e627e54f31049711cd3389554ade15216895700c3e8cba336b3339d57e1862ea8685d41f005746e970412cabaf1dc8cad30c2d0bfc89375de25fa2408224e4ad43c6c5861b96f8fd3e3eef04d86b329289b9cadc49caf20b97cdfa29eab6e121e6cd96e4de38cf426af23549ba3bd38a45d968f7159ac6ea14c3e4b2b25b4b54cbd6938f49af8e469d3bc8c92aa35482b0c8dc69bb7ebe39f15345fdf920cd914fdd30cd088cc106a07c46d16682ec3c84e8194dffb099bcabaa4d628b049ba4f54944bd75f0151b37999823d9902f91734809f460ffcb58af3446fe4490c6e11eb645ec4b17743636369abadefac2c9d0b579bcde668ffb35d1146151e97a79a55614331203296ab95aaf2dc3339fd87674f6c3b249a8a0292f822641ff7166c15cd7bc7bc0d309cd7d8436639d898ed43c4638e62932a530f90b35872cf31885b1f0e59b51efd764de6ac0f62de5178dd66511f0d6d1dde8bbe79f0b22923561d7a937d5d945f9b8a45fcf6d91ddee2cca1a8d780523166fba4bab74a53208d265ff1d9a6d60d6396bf96bf9371c68176a2eb445988efd0cb39aa50e76afe149577d94614a930cfb2af5ca0d624ba31118e25b4baf4e8188ac3217c4212beb0d658937a0d8b069ef82eba9062aef394a6518086ab196289b117b6133138f230c42440c310fae693c8c9585cc85f1e64da9e7d653d468e045b00140f76501811d39f2854bb6af05888afa39572c5005faa427b3623658d424217a5f35134a1dca8a3b92faa494cc175f2344be1d52a98c5f7cc436ef998bbf3ea1865d79c21a66d4fcfe04a50db648b5ee43b30d63fc72a8b4610326ca6eee4862d67f3347878340c81025e81dbe98fcde001ccb4e65b6f823566f40442073133d2e700621378d491467eb4adb9c6cd298cbe9a745f0a6ad13be06bb010718b74e476ef85652355a66f9ccfaab4d93e6692ca84991a230e113e173e0f4f3c6946f8c7214dadf8b51fae6a7b65386c85c33c41f6afe1e933254637600a12a22da34e3957deb064419d2d506de7536a333e549f3143bc8924fcf5344ff535d62e1f6961e7a55b5b0004bbf1db8a1df8942bd99f6586e46e56b2684d87b6ab257c9db4be37543a9ceef7b48d84a1c1806659f95130b5d54329bc18dfc1e9f7853195058ab356f690cbe894a55f16369140f97902a42e7099d6964aab24233c5748a3ae9fc074fbe9ce33c114e5b768df7db7403d80d0e92d0ec09e78b36ea5d3ba2c5c3899bf66f428b42dfec85317d3539e1da460de8649b81dfb2583ab4e4d97c758dcc6fe835d6e94b09a10bf2883e89d172145c3300ea8d7c48077e6e88bc4f6e6d77d838218c5008824f866e08d5ad1fab1eea51a8b743c134d2946e88c9a5acf042e45a238d2394b316938bcdec2734dbf0d55ea4bfcc8f2acabf9a11f2b02ffe4e71dd135e1543848e73615be39a06574112a1314a55ad3f71e3a9f263352bd080c17feb00c1c702a2f8269e48de18edeb51fcd9e9ec4dba61f8577369e5a9501c58f2b69687dedc1fe025158b8fb5fca4f2d734983a1c03311279203b194f426113eb88a3526ba4b63026a65ef59d092fef45b52be662f122c0d9e1a98a10f8f7fe66c9436bd3c11e6ab25833518c96db7a0d11a71d5999568e1c4591943d392f8deb05f571c3dbde627f22bd9ad0329434a040fc359b0d63483c2ff269cf8aeb52a6f15692c060838ac7b499b97c36d2a89cd4e939cf9f0bbc8bde963083164a13edd967c16643a3c6651354ccb0af35164bb2c8f70f0a3d83e7ba4167fe54501fc7d72f1d7f0175f7ae89a344241f84203bf1b33f38d0d5b3975579e83f8e779fb9526a0693d725b31ad3afd2bb0b747d2141647ebc44616d4799da847ffe74dcb436c97a04097cd28a1cd92a45a35accc0ee4e40200ee3a79a77f890d5c58b67a4a2e359e841da5a0b1d663950ba713b57b743895030752607d8d9f478e4f0001a6fdd99c0c259f9792dd22166427d43c25d91aeddc1eb8112b772164cfbf04f3b7d9803aee4ae233ed7296eff8e783a5356083f9d247fa68af14373e2d4107dbd1410515b81122033b277fa9bea452fe2bbae9a2756624685253cd6326549f5462d9c3dc95939f1192351adf6714e5b5dcb6a426f31abac81e071e68ab56befec11f7df2c001c138469f052ce33efb4c330a9eda7c1424091a7c2c593de11b2f835c0fb64098f1a12aca5c38f1ff962779499c4095b2b3ae4bcd092ab8eafc5d9a12109328aef9464dcf8eb7b8264cff57c9cf890d4d4ec6d48b6ea9c26b9e4821498c61b6bb151a05a4bc44cb99aad39a460871c1cb03e0f60d9e618a0bdbaaa20dfda688f41751d2c28c5b62b9d3447c49fc561579060a5636a42dc256e723bcc6c832a28d6a55247553b42bfea6cb13b1316db2c5e8b18337a280048c26bff0e8eddbf63c6092507c8c48b39786e180cd44ea21807d3175a92223922e95a358c3eff69498cd91735e63441d2f686907bdf028b4fdeaa99dd6655da1069122cfc9a84834c038795678513ad3a492bc5368d8137005846302eb56c69870d9c0951138b686a18ef6050162ccc706d14f5ad2db6470b6c3febcbd97f66f002c0a6ef00b8d537b8e8fd7da2a0ba6d45b7a4405ea8e757bf67e12eb2bc833b2c322d75bef7cb0f07947ce72009d25bdd6afe16bf270950d4ce347abf453420b64f46af7ba0d81ef5901efa9471c0881b440e3898d2dbf4826a5dae8ee8057ee8887220ded8fbc5d3b7a2e5b20e5c862c45275bd30c48330e304fdb60473f10861c050c8c12a67c67164806b6ea5801649f61a3477a64e7204110d5a284330b4b70cca644af4c0bc3a8037d6a74aee931f066cc766c94a415ab2c580b01a58ee5eb0c33b4089d99e1cb9c6042b772700e26324bcaf38758837f67947c6dabd02879cc45a6c330a8cfd8f74d0aa239eabbc77ddc9c3907568159e92bd8b025c215cdb1db3a207f7bff5878df18c86c471ac28908b18e21e2e169ad14652e314f0e0f9e60a143276f1becdb6891109ea8873a34d06c2f0630554902b12ecffc98a4bc5cf85883804791427fe49373060424211f44d8a84c905665c1d16ab7db32bbd07aab43be99bbea8626e1ac96248b9a4ef4fe73f683484f09ffc65295a17adaf127f46dbb40dfac17c519d016d4fe42c5b2bf46690b26bea098a80e98dec552c564856dd059fbe1c111252a4c254a69ae5a80d5b7012a84c97b62455c8d7c64fc87b15e0cd5f5629026f02d84495395eeb0fa7cef7efb17f277beeedf5ff2bf788557ce34b8c7531d7750f0e716b00aa85fa1584c2ba6e0bc4ee485325672796781df28b01fb3e1ef86dd03b300e5d960b6fee844b30379541b7212e4f623d82783860442ebf4fad61dddd5d4d55e40365581983d12de9881c3ee49d10f7c012d743be46a339b399ebc5a68ae771eede1bc193d5e76a4188b16bbb619e03ea6bce80985fc3021dc55346cefd17145175b8efbbc0c5f97eb31728239883fb287a2429590ef252af561bd52a90055cc50dbf5951d7f8f3783b22bf0ac4cd599abb52b306a95476ad101732c832a0d09fafc30ddc3cfbb2b7bad5ea859af44650a4fcc98b030f296768e2ec54a6a0f1b337ac9c3824792cd350008d5ad3330e9279199c0b82e56128c5ee48088b67407b118861d713b3c10bb19d915c0dffcf8f82999767d145aba2d6940ad541809a4877647a4e9b2f3d112ff4b0ce0da69bf9f0e6ef2559810d0088675b3e5dd6f91f2f59b83892099ae9a9b1e9236298af7216f19c547f5bb50dfce026af6032f4938402e3b5e63bdb94df3189f1e4165cb1c4fbd5cab0564c5598e98625d9dfae03e5dc4cb2784f9a9392367e93b4cf233a848ae9e973177776cc413063c79827f225f92bf325cc9a5d07b181e4b30839c8b81df32cd3a0ccd98733c47346d0dd225b9edaaf1423dbfcd0bed66997863773a5c8e32ce5bd4576bd5b6f48fb7b276dcb2c7c156d4b29ade1ef3a907757ef29e4e96a26268d4d1b0c576970f0ef1729d50a72023af9495f174adf0fca83080b7850ff9b80744ae8b9f1a358f3e658aa89c59180c992a514c704be5725b4de650860f7a837036b45ee1097fe61ed6662cd364d8cf368a44469b8456df9dd97e79eedbbf6feca2509f3e8e287724308c7944569261100edc3580cd5b3dfa7c883cead5e3aea186f30d5f3eb6c883b26891bb7cc647fe04327051fa5438a726979e683ccc346b620e869d6c8c3e0c262525f14af2ceb4565978484354aa85f68f42de3069a68442e2b705d81cf57b77adb669375aae1955b26a0dd474f051b3156b6c043688d791694bd1089eda1fa3aa4d34546253c96b6a5beda9f804a225adbbfbd5eb334621f393704c3e2e0c1e226107aa8b8209375fa9ba3619b825c1fa95a4519f27bc3b8956b03f4509258b6690da4cf5f3e0bc9c57e6a4f3acc7595641f60fc78171cd6a86457a9957e3495dbf5d240a819d547f46bdd9da6e44ca46b49b3e010c8c93c58c9fd238f2766f259bfddc4888f0bb69135c59f667d38442885172b695b2696778f79d7a7fc7d1baa033d03b4eb716d20cc8f6fd1c851051fe88579014e749120d05fc0951b2415977d6509f2b32eb758243c46bc4b46bce2aff4c02c95173b5bf62d42c1e06290a6a77a865932e88ad6b116c53fe4c0b2d9d247db588b8b2c46b01250cb6d3593066e83940f6cc624d42c35981eb36fb380d9bd9b1b77f0e23f0713d422691abb731152c78f6eb4d6151d171ce2ffaa2fe9e387a2049eb16b0cc649441a3dd21cdd857c263dbf73c8d9ebdda2f69c923f215e05d645f00b29478eee831321cb9fb7b73c19de1d1e710c70b3e538da2f9dc6b229142e617b2c19a37afb9660b925c45c0b58ab0df427cbf7c5541d904b8665d6b57f2ed9ee8a265043e103f66d1c969a6dc9f87ba69c79ef9a9db6493711a5b2a110f313fb936c7a23b831e463fb04651826b567b55d58c3f8381737721803b1d5c5ae478a507959f2f8e0c000848d4c11e26cc723d7755d4c58b59a9983b72e4bb2247d6b3454216c68d7c848e330b11e3304af8b97de680ed189764cfacf32c2334675d8629c2efca38543c5d84199aeec6050bd65c7058ccf2095a0e16bdeebcde32b3e7a930513742696928f18d4b25894b0d7bd641db63df1c491eadb803850b2635ff74cb4c923663329ef17bacf638f9b58f5326eea91cd1b5450a57069f014125c13a0eea2e7c721dbd953c2c7ada82c164ddadf291678b5300ca141cb1824c2f0e7e6cfa4f825669142afa674101de1a8a72e347b5e98e2a27b82e208bcc8290c8e0bcc1c499041513278539006307215b504764b0476003a1a66259a6fde965d4b7fa001e06f0fd5bf55076e1ff7f03e0f34cf96ba62aabb3c0b90b5827cb86b2eac74c8f83e26e7d1fd3a6e4cf6034db1cf1a291a1432b6619d5036128faefe60a320f961aca51d25e2e801dff8f6d72f240436360d7ad0cb8879db560fb29fda1dda8112c2f9b5200a55c7582005fc060c6f48cba5532dbd92f2a485cfc62217f6ae343b5dba70e86dc618bf5cf17fd8840acee577071d3634e483debaf3535533e6a99953fe18db35c7c238b975dd2ce0c8dfa87f77b699e0071b035b47827fe6d104a196def90cfd81570c17f4daf01a8df82fe75208c24015bc68efbf8c3d0c39a421768197ab382f354c178776812676767a306e8df570951028a6df36185648854819e109d0b3fc51edb642dfbbb42339e4b60f3c7c16a9d293e3c9556a58d0ba52be7da91aedfbe83422e0c7447803d1f070e2b0b3bdd009b82f9ac6a30bba551d604470431a10da125bc4914ae90d7a1c90d14d787c7c0e0e854a183694bcf3f95787e939c647e18a69c53169978505f99f3df4fcf9083bcd983b8f5683eff5832c4b650e9317569f1db86bb5b3745eb22c600f73a1855f811d18f22091e409cd806670b04e3731bda54aeedb1d8fefa9d5ea25daaa4566289b8c689d75c4d7662360a32e0ec8856f8d62cdb95ad35a4db35227d9e3f3a9744cc3fc56bc798e16650df7a3b8355b1ca2c2050491ead3f0bba7e4cd32580bf000a69528a6961aa6ce7d0d4efc1c68964519ee56cec3d2275e06b7bf3e50aa306477f6c8a32b98e702dd83925a26ea26a125abb363373c0a3af13fbf0e3886430e42195a5b1c80c7fdbb5e2c1f0045e2e88c02ab31c40a8c5613adf33d030500465a1412d6b6a31f379cede174d08e794eb916ebfd05095e083b651599d27a23baa544ca3be966bc9e9ad8dd6ab70c166e58f273ba9f9ff4636ad1ad298d3126278cf3bdaa29906fae04c1916363b92e621985c97dd8d4f0de93ff1eb4fba5217117966a3ea245ad1b5288d0bd94d747cfbf7a88e037243404845c0bb02610688f97c8f53fd78a76da20fd129f339a7792a52fbf909360278d4911eafc74d27b248e4a6e1984e68504bd2363fd6be36e370caae0db00ac45751b234aabbd653185c90348f02091ae5fab193c1bc368eaef1bc098169a19094dd9ae6a28b9d449853f5d52ac43ec78ceb395e0489af8b26d4faf08dfbcd68868dfe5ce6ceb6a452e6fdc019661feb413a80929b96a10c793b7945dd4d3c447be167294793cde9a5f0bdf65e392c005f1f54122bb1a5c0b88ee9be7f7d8d7a5b05716bc407ccc16934214f4802abac09839c9c55fd80b062a2fac85ae3dec9ca8a6f5fc98450c7be31a6afe96a3445dc3857ede7b9e3e7cadc00b257d910a822abb17a69e9d6acf7b0603b38269fefe254fdcd6a03da6c3580bbb54466bcbe8e4ef069572b5fbc78a6ac777fdac20543e71f0142c8a4400feba261ef2232df6f97dfefc559521345e2e10e8fe339ec36cb162bc2eaa7bd7d65d7acca0c6fe7146a54b48d9404b4999ab8306ba5bbb714f5c0013396c11cc74e22af5fa29faf2c5fb5c941dacd3460d6897f882e27a7b3566d903504045642f1dc23fdbc21fa6ba7ab544f65ce2f5fbb2d4bc51e322d3b0da48933a785602f35e4f89f2879e688f2660fd796c8dbe8c4562d9285612ae454165d80a00a0bc0644ed981ad419f3cf2c9d89c26bd4301582d2e0b3a496434c3774ad93a0d5a6155f5651c90af688190ef0981fb095b95dbb9b2d16eeef874d122584dd494143b20e924c4eb8f161222ec1fb52ac25ff086e2c2ebea62aae2893e15084dbc1da7eae40e14b5d783fed2ccb251675fa799003c4d13b29030ea40e28fcea8132ab3d7698149b61598c7cbead455722c224161478fe787aff772ddea31611d590590e246d06e6aea929e7b78bb97bbc70ce42ad099192fbbb464dd2bfcdf156b3c7d102018d2c6bcc724ddece74bf6726ea6aa3e7fadb5a1e848f53006d2366c909e45a80c742c88a4e890b44d5a3b6056a8c22240f4c4cae49ba181d815546aeea47144be169110a16c326a4e402ce8bfc91bdcaea4ced49d281083acf21d811080f4d9aaad97bd2c5dee4b54759daf83a89db866aa6ebbbbcfefe8670540c067c666df2265e22268609487d4ae37efd75c85821ab2e8a73421dbf08b107f8577033df587a8f219a6d979e2bd516d1ec1c91c3984ecc3a48244b745f0e73cf1d85f039eac109032f6ac5b847e736bac6af2b8856e9815e4bbee43838cb6e43fdcd615a5ade391892f10e865bf0cc3ee309420957dc1912522e92bbedf2cf33a9c1d387ca9d7ea907454c3493319a87c660dd722ebb06d2e594f4bb390466dafe37cb5bef9da08d6239177df2685e5d5064dfd2ac67d3133081686efb4a9492f6809cc841b8b51f5bdd6212504b9490d3b61dfc5c18e159b9d69463f94996ebe63259f822e74770a0769b6ca79bc8526bc5ee198f5a6be7a5e446ca03a5c63b0fe9d80aac374ff38d825f81d252bafa5c68f51d960f432bad3b8642fb80477fd66e8e3e03a148d1d0d8c7e5b177f56385f43fe34d3c43577335dce5e6de8baecccd7c485429394dc03d66620172b2c9aae6980ebbfc4e05637e4f2badb1add46bd6b7fcd2d727ce24971f260ef405752d887203d7ac0c7fad714e15568a145d5374f00850b99f6471d74e786b664dd7bc9dbabc737cda6e7aa28e8b76c9aa12a3e5004390dbe5bc39ad9c37cc9ac426eb77475cfd928176db8dd651bd391b36a91e7bcba997628a7d0c447ae44597549d3ec593c965841b6c02d11cfe558841d40bdc65ff81d07c63bfcd7e7d4c8e1ae24310ae80e775fda957dc61a3647ac74bdd0c5b8aa742417ab5e2c5b81a713eb947c2e140804e7558510d8485e849e03bc1c2c6d0e8d0e904908596cc0ac9b1138fbc89adf29f8f0da94b39103287a486a6db24c76a6b47fa8f8605b4ead6090686623c7f3d415bddab1eb6668078fe6c577b12d2d3640b9ed104d69bb6c9eb7b70c025998efd074ab9a93c43b6dddcacf3fd4234345b6f6fe6639ce256a2f9eef9744af845ed4112fa56f2edd961c9e80b31f25d7281fd577a7acdc4b2e8066c9f6b2ec80ffd4cfe1753a386ebfd54bdc19da5e256bdcd1e5311cdf35914a6f4dac2011d7718ef1fa85805d660e1aaf258f0becad826375504d56ed22ce6ed07b17d674ae2090ac088023d3c186358895ff36055925c1673896d2d6cda1d79fe17ba1853fd0db3fd4470355dd3955233176615d59203b734c5963c94d10f50608a4b9e8cd633cb21dfaa6c604e6ddebd646b866efc6be74b1018a44d814e3cff89c25aaec25da54acfe1090592d8debef909c5a8d7b8d34356915aa2991e05d4ba2c47226219c944168509c206c5c568f741f98f0f74e58301ca9e5f792cfe7d8c590ad26ca54d7f59679ed77ebd17152177702dfebeb58868750e167dad87f010bc5ae9705c3960d111d8ed63e86b5b4633371d2abbf5f3ec69e1419e8c8eaae7d39b2913a77e17bea01155b7fab20e7ece5d39025decd7c3e871d03fe73a23fc31005a6b184c24691363ac614c3e3ecf752a0b0200393cedc333e30d9e233c08cc07e02645c9fb571388f8e21823010883480b3ff39f8afd1c2da8d24dc667d2ae7a21a3c5c95184b3e9aa1d19c4281b12a5c8d3b93920753d4394ea8831942353fa30c418167447290ece438d2a0339fcc0b989873fbabc19e63fc971cba30151d7b79e490663a6cc9b47145b4726c6c84217def6e9f304a37aaedec59dcce05df56693efa06f6519dfab08935f2f91fe8011d9c07bc44ee74e5f4da980e9c5e4f6348fd6f9128f897bbc24c2fbf48ba22321563dae4c736c4055668b376bd9828747369f1ae6430bbe2974351388a68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
