<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e53e52104328e097e5c4e3c8cfce29f465c49908529e623b7bb14c10c7a79dc805f5a3de827f34c77284fc1b1d8fb564e1ddce58bf3d8746c5eb1b6f39b72d56fd40d94319bb4fc792adbc50ec8d51c346a04c8b07b9597eca5b5b789e6f52a2793ad4b09d81e82f90ffa33fd030ab29620db7f0d2ce577fae7a01610312e0add1a8b0f89389f7f61d728a2732cf66f10906a4bb334ba87a090f63c81eae8ea8a74eba3d23d60c6b1a6d0fc1fd8bd6794288550a0d9353f5ef55c4fcd429b4994d96fdd4d97ad458eccf1297c6df09928c182249acf25e7940173dd5cb8fc8a341dde2d8fbe28cb0975ccc82cd37437483825fbe66dfe220c7dae39cf0e30578be5e0326080c6cec80014e85056f534ae01c95bae61d002e87810ac9fb52f85e0c191c6beff6bb7df13e71e2ca034c331486368b59119249e13e648a736dad0c9f34b3735bff743a5b31462287886a4c227b07c9c7c1edd2d3a4dae837402a2d44f59bcaf99c7cc3ce3565c990880a444f3ec254872be70ef0eda54d4d07959d028158d0467a1e1a01260c1bff62d61d7263e144effbaf591a5055bdb47a2d699a6a701be16312bed752d398a3553cc2b92ac713ec206811762e64fe431c19d170219d64f763a6bef564b223622910a94460967febd122627c07694289fb0242b218615ffcab25e08b6d956b11e05eccf892ad74593b3deb88c8b29c5e99b5ecf8bb018e718af5b005d0f92ed7efa20fa58e74a6792ba583b120a57610e1805d71af3364d37096472d38c816b7451ade1bfd98d69d25eed73b2fdaa91592510ed6421e7758eaef32b395cd84d2cf06884f8dd183c85075ff0d6b12ca44362949c6a13444d0000aac10d19f0a2d0419a2b9408d2d0d6f1e79185c85802a93db36c2926dce017059e531aa3418d8b12a26af2e1679e64343ba7912c980977da49b900668b23bd975f0c21cfb06a5db8270467c320cb5583134ab407bdac3cd410f7b1383f82d39c1674d3695ee9bf6c54f55db97e59e47163382954f61b7edcd62d3d852b50ba318969a7eb7e3734cf8f497c0c101a7ef01e896554db04fd1c8ef04a6ac2cb466ba971b0832e00bf1fe456f0a208e38ca8b32fb174a794a1c2b20e9c1dc9c0fd086fe7a3bd1725a3cc376ae9919f3d032848782df1ecb3f668165caa920c94337c46476c3af9d4279683e2cc9550c61131ac08f81198ef7771aca5ad6b4a1cc64d899e78a1a10ef193dba3ef875ac68615ccf2a3a910a4f665a7ee651d1362ec462f1a917927cb1499f2c587d5bfabf2861c078d424691a3c19448aff7ebb1d7c58bcfdeaa5c9d375d1d97e731ed59092b1a6503a51db138ede768170a06860a7d05ae23e300a3819c1398da46e5693147d1820deadefe25557472786dca8be99e3097ab1cb0b0e8aea262cdff67ceb38948da1ca6ebf35c437d5b3db4d174899867e43058344b656a2a66d42c1c62889145c0aed2a33c9da0df08ed525266495a8cd562f93abb131eb609b07b2d3cd9b68701bc4155f561087206f962ebf3e88476ea608447bac2351f1dc7314a0759c93863d806001797b6947efeeb86ddc7a5154d58ee1ea43f254b750246f2f813a23f79a1557079c019fdd0f2bb290530ddbb311e9f5101a9005780036f8475cbba82af34d275dc6a641a4c9ab11a3bf4beaf5c5316efd4d6290de1e9f4dd3c42e8efb6847c301939293291187b67b0f3a3152ee45415f66e8deffb96048a636ef567e335737a681b611307839664339ba1f3051d0fe16721b38e28eb21fb6c2ac467a39fba5da1e40b844284584653e9aa6be62e9a6ba1aaf127dc8439bfbdc84c6435c64433c7fb5773febdb79a63430700cd325f04790d7ae6963f8f284fc9d19b813c0e20de3961481693f2fe2c42f536c4038ecff01ac42ab67530308a3177200afe91b786b8f228490cc3ece6f5d05e8bf4edd89c0edceefe1df9a530c5e7219ad974641f744c8710a6e7475b893514f9f1c4dd41f7522440b9e93aa514cf7b8d29b64d825eddb66aef8cb07ac5c5336c50efb49adc9e87b154284cdc421803216d552ac5ef27e59f512ced192abc968e8e17c7fba3366962b61b23b3ef6a9664342f4aee3f8f480f5353876796fac8dc972496ae4567c4ce742646d3ea24d4c9528dec9d6bdab600387f2fa3c7dfd6eb09445bf45b0cb6d775e37b74a4770a0ed4aa43814b34ca7a99498c94439b151800d6acb34254e990ed88b5c24510e4d6d329e584404dd3b9316f50b96e199d0cfc6354d293554e6d54596dafcd684c6e6436f5ede5f6d82b715545ae8c25703bf344b820ff38f5c48b3682908e720b6f1f0dcf569b78de4b3301c591c9b74ee8f174ed4de88b8f8e0cd0112396ce645fdd060fb5aca742b66e400d048b92a3f66958caa743930db08befa1ae5cf351a477c8493f665b959a59518db3569f1eea43741f2fa1f5b28779e83a165a28ea58c5712b90d2387c66d147e06ec895c33589f61474c5565898e9c9fa77aea40a343c6d41a15da9f696ee903de31b3dadd0410b6f4a19366f3849a200a2787e8bb8c27907148d8bdb420f7c1fe156acb71da9b2654699cd41407412dbfb93dc882fbe41be0dc360382639e396b73c275c141bddf0c97c3a4eaf8ba32205cf1135cd177adeabd9a2d1e67d1f65d4de5be1a4491b8bd7d9d708e6dbef899954dd938ab8fb02c9c1c975475726342c16fa4baa3acaff800c71e653ac1487547b05e5751cebe19493440443d67f351e9bda46a188a90a3c1826b1e646a2452046bee01126f96ed8ae92e629e2556d85e4e31db576504d4010a35cfecaad4fe97f7b5ef35bfee15067d94cee48120cec8337806e16acdd2fe5fce97a32c73d8c0b86311f5e65b90819b646af9c1256191fd25a86089dea76c6f16bda326e6c424a7fb5ba4d05664f79e917f0389cbcf4f8c17ba13db62c2ac0b02310bf6e239d533cd3443dae71142dc0f73783f64c33ca5f51c25b4851d384a7c43c00b8c5ee8ac28cec58d1bb8fba3d3e3ae7dd92caa4e7035f5de716b6e83caeef01e053d0be04a34854dd833a42a80c4723e411dbe0a605b887cd771358540752c42d2adcc31057b203f8f25bccc6934f929e0e473bfdea4594ba5045b3f99a1173cdb9348f69e08cd2e3f1d3febade725252512be32e10d442d354f990ee518fea79ba5d28ab90ca6be20ffae6f43df95c666a36829a1d5580e7c0ba65944a061ea2ef08e29ceddc03899397ad2ecae551078e46514dbee90b40092bda1084c2bb4e5c15744611bad2ec2d74c7f28472b0c0ba59edb0d214e8ed5b98d6679e255b2a154eee630bc9ac2907f597cd10b30b49efcbe89beecd9d3a3990050340c38fc56cbeecc16213688e74ca3e4611c2eb4fe2cc36f93718087c58132f160f092f192b3762078e17db179efb3c8d126a994677a3ffc7b8011fc881c2d3e9c94b238ddd852b3c01a2b45790ffdea62a5bb4dd47a24d2fa43e7a94b663f08b408974ac1d496bc17aad21f2dd8f98c8c7e04b70ed3c554383f84a67b8aea5dc1b08110ad6d44a4d0ad51ae84871e32c982622bf0c6566119a9854cb5f54fb1f8d19c11a8a2699238639c3877055e76518823f1bc1f97d276662de667c5ee48fcb44ae742711713b80bc655f6830c66bfa142570cf6bc86ac49c7dec235c1b7400a7608a48de2eac1fdc7b286206c54f9791b20f36760cf38a2dd3b40e98f5a9131b7145dabd83849c19ef86aaefe46706729e5defdc1e9f40938c6505d3cdedcf72a4422ed56e48d8e6b7b7965468501b12e5aaee0be8f9a0a6ca6d501b418a496abf32c67887b1fb868c4f27bc5f8ced6638a59dffa1fd42e34de5a4d7822c2d0bc2402ec88ba3fc17b624b5f2592a0c8a6d38c0ff7230154a18edfd07a4d2ba5d86d14a066ae8b8472cf0db405ac550f2eeb9564b0eb4f954fdb5020d333cc1f301cbbd2435b4fcd0beb976a70f40658aad0f6915e0a19a7e08640e82bf56a3c32f74ed9ff2526f3adc71de4c368db0c5da1f11ba21ccd58a187360433f83470f8de3f9ef064c2615538faec197dbbcf41483570ef9460be466ec1e68d5c1fa1893d80062efea0965010cf84eb1b9a39b1b99c0c6af3c13a323e0c6009650f15bff23f1b79c9b9bd6fbbf9c409a344c14ac18a25a3412bcb4c8e5f4b69556577eb91f14e49c9df54f80ab290ac1d5c210b71d07d64f50a5a62eb27d984f4b7a3483b621f66d3520e7ee3694b772c8630acb83d2245b34e8900f6ae923d1d46e1c244df9e3a951f72e6190de52fca16b373b93c8f9beeaa8b623b4c30c908217822e38a107549171b19ed84688a45005156ad3d2531b1a54047c8b54a18ee169309d545d67c0e69c5f715991bca5f239f1d93b9b3cb5100601fc1c11ba6517ae614aaf68b6a452aa6e1b50242b98099ee9450602fad6e8942a555cc639b67eb8554bb2220619f05e97bfcca7f99895e2ced4619e7402fefa8b2a62cbc85c30eda18b2474fe765bd3b3b284a2dc0562d1358ffa7fa41163b3e00375da99cf2c0e0363e25215fbcaa61b31144c09c5f1e777b4e65b173588fa50e6ccdf4c4290ba82a85b8ce88e2fa606d920bdbd9df8908c41d8262c770c5e5435ff09c7a6d87ba13bc1ec91a61bfd6beefafe7b6bb96923b1da11a293d1f095a5fbdf4133e893b324ed9c465c29d6059e680e251511a5b251c4058498065246d6520106716d4f7629bf01336730eba0c74a5965f8a8d78885ce4265892de6b30b66f212c99d3fcc638a94ccc5f5b258703af804409555ba196649c6accc020033a2bbfe88078585836b65a4be74581982abe06977399d32bc9a6fe8e5c54296155a927889baf0940a1c30347d510967f4db655cb8448f74a952b38264272840ef0dbbf4e02f1268d9a2b1a6566267290e73c1a24c6ccb96265169329cd7ab10032b5c1c0b20786710522767783344079c0ae8a2d15b957abaa8d3886443a5a3a0f877bebb423ba830f25c403ba40a5abc13aebc10c32d28e7f4b60b8db361b5fa1b252ef6c6e91455f49f680369da28526a911e767bb7a45396d1c72222ee7e4f009a10ecca40437a308383807c3fa1644f0e3522d8b826e64db72ee1e1aada70025f7698c81c9b2a10837efdefcd97e6518c333e81ce2c11514dd5f8dca9357006a83ebc9522c81974f308f8599ab6d7efe4772a7f4e76da2c26c29eef3964935d8ed86d5b627138637788fd435f674e9d315ac057e6eb8b2bef832a2ea42c9dd7cef7667d5e6e4b3e896438c9496b7e5610a718c61fb93fabb1da216767df501251062a4b244e89f86c35b97625f8a658a42646c99a2aeab6ab0327ff9dabe19c013703fb67ae11f6f8402dcbf97d165b2b0c6fafcb93de27828f55944ad9b3451d5c3765a3e203f42503ac296e0236b37bfc89a1f88baf0442ef00e6bcc34c93ca8df35f9e627cb2ab5f3e209474188938723aa20838e097a6a096af8f17f05f409bc7774d09cfb55a6e3d6e817b7d8bdf0c56bd9ecc37d231f64a7aed3c02e1088e52eab46ed78c9403f278d9d75ba886d595979571cbbf7e654adce644032ea8dbf3a3df79c02e7c60205f99b95fbb6767109e4a59f747f487faae96145efc83b065536cfde03da8361f1d6aba2e4206948c7bc6893b19fc9264ab26e9b62bdf143be64fb8619660d7bef181fc2cd705bc9d8ecc0b89eefd8fa280d87d623bf59cb59bbc73f6ccbe8f9b6b46cb27a671ce89b3f8d92b5bacba510aad92b5da518890183c3c57f3e55b5b27feec7e252057837a709cfe2f814df3e04b3d2e192d96781d916ca8f179f30d90fe04945fb1033dc422d7d7298f4646c45a4c6e8ac51c0dafa8e7b9c6ed59e95aed4495bf1a9f4925a0b9e344171da524dcf7eab86aacb6ce672d6038aa9b5f70ab15e2e703de1ac205f9b6ce714afb5d56225c27dcefc6876941a1776001728cf443224dfd9737a5d31a59183912c7a1ac1db5d85fce6206a94c483b94ae9928d18b41fe83173225608d3e1e13ee4a71bd32121f3774723cef70d24ec70923e2b22b293273d3cce35ad10f0d3456d2c837eb4b7908a250654e1a90318704a13ddc0b680d45e71318ad72b77e0c2a3ff277119003c96e1f62741286a04d48c6f3b63b44ecaf63833b0c3d9227c06b95d426c0b3280e9dce40bcbdf0a0be9d4383c5b2414a8e501b71eb7672f1af5d23d709ceff818ab58705df50d9fa025394bfe86a104db2d282e94365b817e9fe848a48382a78a4a423847625b0cc06b3dd5f737f74ba4b6beabd1b402f303172d2ba0c9d8a7e14a8e484b636d94db8cc53a873112438326c2f9639963f18a3d62b0c0326e1f35086e1df24969420a228c463d73d83dedf8647055ea6649c2866b273371b93df5ee13ffab0ebe3cb7a157fa7cd4776611381cca18fe74cfc324e8cb83b844ecb467ac64ff6bb53bd6914c49a1ac361f3819cee18a2f19547f858480870a328296ec9ed47fd38ba8509ea24375274f4d5bd50e93315f4ba2fba761146966a93e4645d8c5def2be802fef92a6372287cd0e2b67b9adeac3e2b4db9334670b0aaf02ad07070c1c25ca7d265e67baa4f6ba958d41242eb7528baba430d93c7f20cbde6545bdf5f1c97953011c635b8a39fdf0d8b8c85868421aabe96dbda596bda427700d8cbe43a7301b8be9e419f81b503fd89d970731dfdbcf9cb3a33150831e22c3c685034660a23420e27f5276dcbcc1a8c8eb4a45a0ed17aee0cb90e06eee743c1f328301d27c97c6c6ce39cc103bbf67d7ba2a69001d4b01a633d9f63fa3c461bc72622d6dc79c6aa2934f2f7fdbd1588ddcf96b29e3f68bb219127b36e9702892b8bd59c719f07331fba355a6b19c7b30f0614f42dd4286dddce6334b3e2bbdf52f76b160882bf5739f710df32f9c477309278d81aaed7749b7ef754af7ba46750d50e193729b3f9b851a871741e95a3115e43babf9615d968bae329ef9c93f1733f26d9437417781cbbfcb122453a9a15cf3d1675e6abc7c9b15c583582f8a08c4b09f167d909d083c4eaa683b5797af09b307a0fc2e2c237278e8bbba678511c31f3534daa2764d7458ac27b8fb74378de22e70e8d9cf0de627568c73f388d45228af53c6b87cc107169da45547c3ade6504954d0db6658d6c44a88666cd7dbd7b502b9c8000532941879e3d9d2d69ab10c645b2c1843ffca9ec724eb4c255b3f44dac3fb527a7ac207815e8bb71d4335297f0aceb205b341c7334d0f60fb3d9766149dec33fb9ed3b3123ce5849d3bb2ab411f064121c54981c5e7e8ada699c0e733bc8839334695bcbd97c7c79cf57e1b41b18cc7cc99ca43aea8dbd6bb32fa7369b38a478a1842598ac8bb1258ce384c55ad4f09806e70804372a2a2e7340972a2dff63f58874aa95e7e55b959fe95474b918c62bbd9f86543b1c17b9120dec90aa0a2d59ae94a19d1182e5cd8e37f2246b6c92030aad0011e3b2ffe033a3d73a021ca787ca022b8e3c23eb283f857c9fc6289dd66e5bfe81da1db727b3f2bba81557336fe70df6c289b578f6f257e0b7ebab946d5bb7065cd796377b4a423b47dac1670edcdc74506b002ef8ea09627eab0a1fc7335b080ef43042cd9d0f4f422ddc6c4e9c748e8017f9d42bbcc35591b5b6909db92dcbf284c054d35090a4c4604b8bf9f4cfd00259e24103f7f7aef2edbb8a49ae5b8405837d58f529e8dc0a8597298362f10c772c5091a97ba3ab7575df1bad387ed9cdcadf0c3fab0d98d87be556dab8100cee466c78b138a90db88fc2f75bb7f8f7f5ccef0c28d3a9cc18244d29144cd896cf833fffc1abec0c6dd7e86244c5bed476bcdfb5d5a729f60f4dbfafb5812d2323fdd7b3de254e7ba579c829479fc12662e629d4e1fc4052d27862b9e47ad855b6f01a666ddb739aee5255f7463438735f5e079cb049a25d36e04d476460ef12ebb469b756948cde39df271e63edc6c342a7807a392faa9651cb231244e5d3422c07197a52282d652041e11f070b6a333031f01a3ad113df91301fbdd9e999617f4b401fcbcc777cf7b07dcec91703576fc1cdedf6ca36f4ef50f40c5c11cdc4d91d0a39b286b9607ed0818ad4f1cb7dd536097472468348bd9f9dbf3df245097f1381592ddecfc4d5140dc11e2ca9962d0b7cd95a787bcf85f00d95cd427bee186677a6f830ba67611d82328e37502cf978826b8160685efc6acc51a803a13bd5b2bc10c7721190e9b1f6f219c1b207face5b03b62e7e82c386d94ca52265eed2849bf7bc8c405428451ad4ff632539408165139722b501e800e062ef8420435b4c715998fc52d2f4f8495ff4ef04678c227cfa15bb33d372c3a02fb2bbad7b207daa0815d9ac0bf09dd60a614c68a223db569d79f7e1f9e3faa6bf52ce8922d2116032faf9719777edfff8cf9d5f78949b90c81cdfdd55f0822bee29e2604777e0ccc625a6ff31902df7cdbb9ca451c87593c47e4e569d93ddb5ec419fadb633aee0aa3c210351e6f64ad30cd17458c1ec672a60d3f4c2e42a7241f7308fdd42123111be7f736f98a209937639d9d2d9623610d8c353831013b6c2f8c3d72b92ae938bfd5d34bd5bdbc2daaad06f4b5f671d5e45f354b74bd5b2ba70a1abd487c4cf6c05ef5a807e7924cc90699299dea583493be9b3673ab48d9f289f4d934079392a82eedb86582608a5124349353c54ea21b38f71d5d01f87a284542425c8c5ca55c9f47f2537a6a926f8446b13754238002899fbd7b418659edb07dc3fe96f91bebf0492724112b03b384bfe1c8dfe95d610ca13c85720e6c93389cc4dd0980fa58c86b9ad2a8a55c071ef3694ecd82b5a10709c8d0c07df0b1ef77835de5d3148bcf91fe3836be3dec89c8d9b050ea7ba0a75dccf89537d367491706ff006c23c128831d8055ae4da114981d68c99fbe5c104132cfaf902382580424b340045c865b288e095475f717d7c8c2094e36b93d05ff06833999b6239c35c7629f95bece5d84737cba206a960cc1edfb635503087b68f2fd82d98b2f320a06e663201a78dd360382ae9cb0e4110ca2e07df13f980cd1ef9224d20956a3ed5b1cccffd167434b93e2780ed6e59efad2e07598a4c4d27a0938e06e72c43a56712e9ed331b579d82e0fab2b64cf481407602b0ff2f5552661ee0f5ab1cea22b88bfbfee2cb621cdb8dc80af0ff2d05c7763cb40a6b7eca7251889e3521c15e3eb832f683c5eb6eaade03abf5f67303c1a717289656e697f050396956d0e5950dfac791b4ea28ab9a0e9440cc81dbff3427af087881ed1bc5783cf37def8b6569a9228a6a15dc75140297b91812ef7150ba921eb9ddc11425627bf5edc82445b6b1b8fffb8a8282a1884202288d58630869e8eb1c3de43b72bda12413bd3458927155c2b836e6d80c6f71167e03b08be479410e3a65b6102eec0c0afa6952f65caf22cde7523c2bee995811651c99f68c873ba23bae062e62ca0a9ef56918c07b8e7670b4cbe971db55bb34559532928dfa78cf7d5ee6f7489b100dc6deefe05e7c5a467ec8b025ede53226a1ddac63ffff3d5f0d27e7a92ba43accac67132383a9c4cf4fcbe38aae9196dd0d48b765f5b1e2dbeaba358378cf133731e598036855165af2133d2ed1ecfacccddf0eedb7dcdcd7b9fb6882b57d3f0ac1b74d00f14f7eed50a826a9d7f002c095f4e540aa636c1f895a924cc964878bc63a389312cb7b11672a47c35cab2345524ab4872912fcca0a9f8049bb712c7a331acaa1891031dbfc03155719f005a4b2a997178107288b94475a800907d480f538afad4941447b3a45a7f1788df66bcf2727a0c323bb023d50d6aaebbec2870726f6bd146418e31b8a397d6ae596de922906818a72feda6a02df8cafd8461166efe1ab901a9521b2a1d56eeb5da2e3fba08ec18b426aabd1e40e5a14b90c3546ec385847ffeef99c30ce18602b23731b866c237ae36638bc70b1f2e041f9ab98c49f4a652bb641429a86a07ce386c41cb8cd914168d77bbeb6e57aceaa85b669083b1a56d380ad00c1483dcb6fe2b29ee1b4d11466918a53744369084835de2c95a35b7fdd70c356661d9d6e8c3ff6fd818fc29a6f3c054a72304fa28b2bd0d6f2cd21bedf8c3e6f3adf3122bafb8ee5c8e3c1bfa111cbdc0690c59a9ba375a28e9f5f74d911b8963beb7e38d07fbd6feb5fcaedd4b3bc2b0dbf1e48b2ad6389f5af6775fb440821a442f570eeb031490d2b363f3dd587b22f4d1be03f497f2d7d75d95c6f6eff9779e60d71d7d4e0b6e8feadbc291f31b7c4cdd5226efd3f596b6586d369d948a5c1f8766bac381276bb2c18deee307c2a3d28162d0aef700a1f546d5571b1e928aeb8ab614da9de7bb4bc1b3043bc913286e8c4efccf35a014e9ead779e434f15dfd36cca6b8b75ffeae6d63a4fbb4d4994f4ec85f5d7fd62a0ef3e853622ed082bc7c69c5a25b01ab37eef0a59716af7b1b7a0c37e752454b153ebba27af445029cc71e7155626a7c271a618d94b5afa46e3d56009f1b647505d4071d82f67ae0d0e8e6b89351af78469e22d0ed1f8dbbbb9f0ee6cb963e5d6f91be418c32b7cfd7fec6c28467cde56cf0e458b2be0036d109119cc0edee86a6074bbe72b2dabfd332d127b6a43ef8ae2e47d57cb8db64a47c0d3c412114fbcd65d508538168d1f6924f99bcaeb44c2720a9529987ed9825c9d0b6a45ed3b3907107b7097ce71749f2e7362d941c09e3fb0c1a59d4805d2262982f116cfd24d7cd9ea85eb0924d71b310e632d80b5ae53bea687aef5fa7990b3cc9c64d717fa2b3e42d7b181f3da5bab037a443326637bf709f4c2e77deabcb57b0d1e8bc0cc7a11f9c46aa5a46faf016d443d89445dc1648a4a009a3e68bf3c1c53b2b8bddbaebfaa8f19cd633c5b5b7af0ebcaa1bdc0460d11b046343f78acb8b8c3f42614a748acd000a797b8ab0c97a75c8fb23916609bc462796ae53da8f7c156bf6f1c1776de3cc03cf9ce6f07a583b635b0b5e6d74a5564de0f64b93ac4c4b081f4597c0588437f6c64387d0aa9f42c1ab106aba3ff1353100840a5e4a4a283c4b564c281a0ae8a5f520706174e2d202eb455a78de76a22b4923a7daa2ca256e55a3f4675af1e542d95bc5a69aba39c0307f840fdc5044cb2c04bc608b80820017bbd065b18c652576c157fb6d6bc29b2e1166bf4a05d1b73824a14c2ef9a860e885c5b6ee078fd3b9aace349b1a40c13f5ca99786b58dad67a6f1908e7da8bc224d31fdfd319ad7707d9cc98192bcc1355e9c52d157413521f7c639872a1eee05804fe11726e450602931d22e15354d4962a092998aa8b550340ab3ef5c7a85a6917b87db25c0be108f88b494950290fe48a76f5e7a9b57df8a80c1c2cabe754c571670c8be7dcbf89911cadcddc1da3651cc4c52be6ed70b7e92b990b126fb71d10ffdffe548ed2604c3dcce0ae429222b55a08b24101b8a1bdb8322b29f39151cf94fae6bdf78671ceca25ebd78aa48e08488456e4a20df36fd47184aeba2d9a646d6ac8204ac58b0e74f7575b0affce7d3c9a6d38b0b64c2c0a927220485638f943ebe5a08dfe8070fc20e39d2cba57220a003c0dd704e64cb67ba8a3fc7ec181be0fb37f26e37f5ca8b3383d5d971db2a26eb29faf4abab0e09a12f8008f46e4564a5cf6efb3970fb495bf7bf7fc4fdae3e030f733ab2b6c375a829c44501d35f6c8f45fdd3bd0c8f45b6f0a5b4f29fa3ce954a4a968b17bd84fe589e74583d1ef4da7c4b3736bbef811669e9d6b228eff5e8f882c59e7d761042b84265fc9b8ebced2a4adec8688cd5c343e8adf4cd897efccc109e8b022f58a092fb56f4dca06b77d72675e6778dbe68f26546111952faf769fd903cef646b5df5c7f6a1904894c370b2b26f06fa0a2fc00af82e1806da47c585011e660a2fa05839b8fc4d39d7b1e2d56cd7d0cab8d9b3256ccb235c59a905946f8d12c12ba4cf8f567022db372bfe3f6adcc10df3acedda86cebe6eaf5f5be112cd452f0ac9d9f6b7577846eb7cf9f5a0d6d21716d4500e7397c448dab0843bc725b924f07029071f3d6284c97e943cc9c00d4c58477799a2e4fe218b535b3942489cb9d66f6c6bc86f5ecd444ddf76f3e1a783f647a1b911bb6e148c37adf181b8876cd9d198d1d49c770c18e3c0f33bbfe7cb153ada2c61f9ee1f5ba681a8461444189131efcd6ba6c9a87efee15a583110618e92bfa62601f638fc1b36d0a76bc284ecf0dc3c6af62a0f8cc0dae24c8230eb25139e194bf9937a6036e6f10d339c2e6a293f40d10663378818f9a81e6a4939d55862ee9097ac8e9b756c47845e74e605d040810fa078f43a4999f14c80f8636654309f2b00a4dc1ac22715faf77564d4167022fcfef176986789c01f3d292c0e0ca4c8c960ab48a0f525726de8232799a3610042ab437974c734870aa88e017118646c32abe7fdd635fdb59c556c8f6b1ac9c8a5b4df5de8b056301229c2411033135c1fc98f2146a2f48063b768c50a2221298bcf47b243e6edb7b38a1bdd36f8c36b458dacb5307aabf6c8e3c200089474d0ac5f03b9a44cc13552ec50395eef2e7061086b57e916d373a9d1ab0ca00a0f8b87881ace644bb22b6e0acab6a2bf2ab04d4949ee726b13e6c6e01f3cc59f015e276765852047157717199cc17fd84fb710d00bab780ecba3a87c63e12939a4d68a9d5bcfffd66d27d189a920063b75bb3cb42f1d89acd33ea6eaa676f686d5860f7b3c64720600b474474841224210996fec24c76980a1ea262857c34ecf604f3379ead05fbed9a9a06c85060f95c680f92dc7f2ec1760e2bcb4714edbdbb6a7f2ad4944253e496e28250fd7029ebe3f5b3980b5bb5ed9e820ed887709976dbd1417f24bb4c557b9a6b242ef013711f48c1f49d3562decda3cc9880a2758e85a2ba2341d9253b8aa2c8928e94c9c525f005014231b0d3d78d03d074e85ceeb00bb75dbbde0fadef5e747a64d05b579252627995d09d1764d076f18da8178a37dedb8f296590d934ce7ede1c4ac14e80ea38862293d286d93bbecd61e697ebfe57e336771222ced10bab517b4701b38d3d439d89cfe58cf9127660725f4784125c2d9ae625bb568ab303ea4042b91edce85a319d3aca5b3bc64efc6b8144ca6567e676e5df778922809ba02dde8c658f1ca00299ed5f13996885cc7f44c348036a1e01d76325505995b3368521939dd60f4e87534c7215d7beb7222b7cf9155c612f6827a5cfa075bbdb584d3ee2af0635f822eb1d0874f7cfdcd99d16e60546e7caa8cb384007c876af227cb67a359c76d0d091e99580a4be4fb60404d56732f502ae5b331f6378d59a5be27903a12aefcaf4f0b54c9a09e737232fa3968a736599b0e547e5c30675ce542a0594fb4685f11072c3c500303168341d59ae899df9da2e3e2f924a6e6f8d7e97d038e207fec50d6ca0ff24817d71a4762471b1484a321244773cd078a069331d9bb1e49fcda70716f9206dd7e8c93c636e3248c5ae6168d98cd43182ec8dc5be1ae911d4c34c3f4320e60bd69e9189b72fe7307a10bf330a4799eff696962a1a3d79af1af77a61749e1d6f4902d57867e4ab7b7699765156917e15fd53497ab56dfc4ae6f0b471b827b2876aea875b7a38f4315772d69e2aaadbed4b218c6685abe8d1783ab0dfe57ca1102caedb7b45e70386e8d89","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
