<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c54f17d43b07bd0fde4ca9a04acc8a509af96a2af0dee5fc7db7ec5bef6f5865dfaed9622b7b0ee390ef900eb1dad6dff6d11d17bae5eb0834bf0b545279e163489b08036c54f51e54a5ab61c3a436ac2f84d9b415de9e31a14775116859408b31e00dbe77024c6a2cb088ab31f608d76911fbbc6c736c19e5e59c80c8d803e2abdf1322d546235a048cf629986fd59fbcd0b3e8bc78b944e323000cd3c26de70212ef06dd6c48686c52738d207456806b12ffd310b32137afcb4406b02e309b36cd7663d8167817f2a23cb002e0dfb70ac0cd18133e425a30c5e1f728b2ea92fde5e561244a79980eb2bda79999c278be1f232fcdacd9baec1ade80595f34e4d8086f1976cd2fe59d34cfb3b5262ad200c51e0af8170586e75caea3c3b7c53737b61b1330c358d55f664c302d28810dcb074818ee3feda1dda669d61aa8fafbdfc2ac99b0dc13afab7a18c95e1dd8eb1989da8843101730cb665c487cea81642e31eb71b398292cd82097e0dd613b198da0f01596d47be23bb0fb5bdd8bef370ccd79215f91cab07a35fbe36ea7fbf94a0caa70131f4d129f96a324b05e030c05847a8844e3da4fb1da305d0b9056a17a93561c89393327e726de0643657f402c3e3d4339d9f51b27050fbabef6d8ed4d4486d9fb60ad83388204a04d1d62bf81dfdca091cb6e28a6bd7a78e1280195b18795cdd9651d7d8efcd85349cd8cd843ef711ac770dd3f6c7a40edcb140bb6fbf29be67e3c8bef6246701d357546e333666b53dcaded06fe7ca7506e2d38e11512035ef516b1e8bf57cf0d15c14ced3cd75610f11ca06a4719a1bfb3d634ace4b6769b6bd175dc9899ce6166f6943ae0eff29405253e4fe95479189a1c49059cdc0247211dfeef908a63b1282198d088c799d5f7c61f668af5f6a901969c2c22f3afd2456ee20eb3cc66966e0ee26c2960c2a6e468a1ce01570fc4eb4fcc27091fd3fa9e6f2dbb37d7ad90933ef322b6686af9b91b65de586a1dc5920a91f7f71688a1df2b09cd3a52c2ab7cde787e43a2fd3180aa61f421243229030bde339484a575ee9539d1ab7e78e104d142a318f41c3fa05f8ff9efd53db7d7ced544c0e1813f0726d5ef54719857b46e8483953551901a95d5153266bd47b318249862d83ef75f739b2b0013364a35c2ae92b28a18fc77ee31d96e30d2e1ef29d3c091152afc45fbbe730e4f67e8958aad6d2d512bbbd72af49ced673906cca7a1eb24994dcd9edddcd2bb8ced4a2352ccebab71a2beed66a7af35b231183aac522bd4d04c6abb6f4c89b0bf6f6405059e23e91e209d69e52b33b8fc07df327544d1a59d0120e09f0542b1cd6333cda48f740df776ba5aba660dbb0cf8e1b61afff8deafb82a82773c04ed7878a1dfa76cef4b48766c7e6458d0a9a60667cc2e56e4b64427e15824709006c3262f720d07e2e48997c21de341bb1bf2d61d7cb59704f941ac9e7f26112c1be3eb3d2222d8c36d7ed670d7239e968bfc7c4d149708c1a188a6d6c30c105b1b1069d68fb16bf68d0cb9a9f3884b0e3df81058ee81955881a77defdebc6bd4c137ba5817aff02b875fc638e293d009402a730d3b282cb2c3200a055046c5f83f8c47cf0cd95b2c746105000ee161d368a4b4e0bd8ac8eecb0138f808fefbe13ba2ee136a7a461f2ab18174e6d065417a459f7d205b6bb84d4466594fcc4782a33bdbfef91fb96ebc52d18d04348879df69ab0b4d8ff7fb17b28ce211766180390f8760c806b282f4536a3aecb45f7c49b8c17dcf987666b00eee595d96e9fb9686e4e52de6a801b7e9573f96fdf92f0a05e98b306c5c597277c5e21e9cc90c321fa27dfc3fb2c7c6638e01d3ea00360e845d9f85df4e3f6c4703eab1709be1a3f89e08dfd6e25510e68c0b7b09365c52d68c2934d81703fd365f37e51e4c90e1e147c928d2536538b915b9a7968c010f4f202f0361dc3d5e045e0e87d8bea26cdd0ae9c0cc134ce46332cf98279ce85e249437cabaa7d60e0d2ca590025f1acf21d37574980ebf5c53f328e77294c4c322b223e217470cd4247cf629ae5a1a360ed10144756cdbfe4a3eed03b6b4aa488e6f88e4090728567fe7bcec968ee8cd419c600c2e9858077c75f4dd0f3b30865c94ab695b9345c9607e2385a8d0e5a771cee8b798951eab062bc0a3dfe867e890833c5fd17b729617be3fc0fef290bb09f97894ec5170b47fb4db96cdde8d60671b1872bf196095a145e2da4d1426f25dc9bbb8bb566ae7fe4240eaf1c429e12d6c010be9199d3865a9768824dfd716705cfac0ed88f71a9927a0474be7d0bbfd3087db49cd4ca65bc4b82a552894a34085a0d3fc83fbabdea9022184da45872833f3ce4592557804e07f2a96462d747c98e2fa44b84e31d7c4e56413b234b0d07c11f7b3b7ac51cc01e148005eea988500eee07972e0a1b943df2e24970e895b15ffa9aba6e1a003220306198ae7907a37e755dec0ef3b91bd786877e1f818cfe626f85a1762a6e4b6bcd6c0c0f5f937abe27b425db95f101e1b33754bc7cd3de4b134e0223a2bce68f24633b532d678d503b795cddaa41a802fe6ab3686f1ac5f61f9bbf3315f954a450a40f6b43f9b6a5a1770433b2885072966499457d343dc72b7c5e5054bfc79b1a1acbeb0911f9a6ba56fc5975bcb68bcda773fef57f973a28b4e1f93dc94618a9bd32f340b2afa70dc892ccf88589c982b30dc16f3971eaa74251a0242c19e4dd851ddada420c2d6bcb8d3ca1685ba54dfdf2ee9093f29794adc358d63c80bff4eeb7c70e6b03456bb85c8ac2c2df0c47b0b2c876930b18711d1ee4760c9f24c0b5fa524c3a13e2c86343af04c625003e7d11e3a791608a6eebd59a1311c92524ee6167101a6ee1edf44f116272b2483c28dc903847c93d916342935b90f1851d496e7cbc358bd85e9be92963962da323028510fe4a05d38f05875bb0c80f0f42d8d02cddd6836bf7b1de7fa3a9f14e3037fc3c7554fddef3e4b9572da6c3d5ab00ffcc6864ee68ecd163e27297be1e7c5e535cbeba22f1eacbd0ee0fe89b426f8c76a5ee109be9c3005662baa9739b4ec57cf766a12be4c7c0f7a320ef96cd1fb30331f65047daec4f08733809c9f0665fb7e1455fa964125d526656242489fd62fc172ad08528f667d6cf11f7cdf5852476e8417f173c0f70af3318d7799b9df5299b561955c6fba939cfbc85ea9e9a72e1e97cf048bfcdda6a967a0de38163c9a15fd0cf3684b775c032352a601672a9661e30383a69e0677fe1ffc8307d5911607002f5de1b9704e196b38d80e427456effdd9f4bb7a1214826dc194722d8a84c935be3c75ec8330b16d536a40960a3d7d1cd65cfba1fc07613e66d59a532a7188f387987513fb7958ad5d1a41dd69e434fdb1b86f624ae8e45de336b2bf1ac45d95528f63d4c55888b893fd529d68d132c7062c67ec9947667349c9cd16578b66e5041c7a79ba579686980f987c757cb0a045d51b3fbf4f9f0183e0f721f5b282aadbdbfc7e518f4a217abc0e3b868dd761bb5cbbd99337052b8f401ed1cb1ad01b1c8cb4d9215edf9406dda0848a2dd745c42e868aa7c019aaf8392a0c675a1b1d31785ffde75986a5ccc860c99464ad1ba80c949317646dcc62cdf1b3aaa6b6a46adcf46c99975770ec616bdced3667d0fa11b861229c26c5669041a9b10a46530ef52a9f26e5cfeca78e02bdd0136c3b3ad5448205e87f125cf53581e07ee514b0e35f20f7e323d9eda95c3a16aedb633af933e07e7436f558447088ca4ca9539862e7d4f270533eaba778827e5a0c295ee5ae1e049e7695de58f88af6754a2ac0489bddcd46ff1dfa53007dcc6c3bda9c5808d8d260aa944b793040c9d19b672a6dcea3e68d4334de2c10842d3903b94a2ca7cea7b8f9d877adc4a02adbd2b98081a3902335b8d94aca70df9a9a103435df19870a64a896f26e44a39eac0c32f438bac0bf18264a6814d5260095616b8ac06ea1cfc4f5e0b77cd9028cd0a51a340c69a36c00508db8d1bdf06de7df2e30aa04802e7f4e04cf74e968109e1a3f9c2749bbd1b0b58ced1add5ad0c03b76fb21201c8c2ed816d0e2d2646de1c1d21eb711a27ed08d1693703aaffcbea687c0a914d22c3366094dbdd23ff5b127751452773b78aab9fc5d579fb9d1cee7ae521c9203b4cac7877597c644c900584d520e4151eaee2247e625758e15ff006353e50be83c28b9a0fd453f92d5184e91ae0289007c5d0a9819e6972acd5338d019c6deb270907f854771bf29d67bbefd3aafa89f2931ce2317e90025bb37c8595b290403814ff1f955f0b15e5ec76aa4180de57c8bf8b7754d3271b0e024b8e5e864912c71129ed7a6237a5e411b94aeb47a7f63d3adcbd761968aadf412272a1d8fc6946f47be31aa858f55383fde17fbe2473c4d4a688c3eafa1988ff9a004855c47dae0d4ace7aadae130b8c7decaa5824076fbaf5de3f442f502be1a66570d07598bc0a8fae781cc60655ced1f14b30e69a67e0595aec9e22c9cea43de960a5d44d2ff1d1fc65d37cca25fcd9f2b3f55abdfc48d9ec2bd93fb8da21a6ef099e4e0ae2fde0b8b9b8bcb254851ebd90b83cf1d84d1f5dd5dce6492b4a896387090910bb218f787dc175a101e301d33b5966e5ebe2ddf750e38d7001df9d1697760e69f1554fb576e1edde9de60735506035c88304186a5cb613089bb488f17e410775147856a31d51eba3c7a739794b162428cde16e9dd793203deb137d65a6b34923c9c5a814b72d330022c4b2598f401489b4ab71522dc06df1ddfa4e96e626a91afcef1cb82d7d760c9430832219b5ea3d6475c8618c1d5647e56d3110cd590e2041bf41c9c89150f958b14c33b2b561f8974a6fc25ab8f09f056906b4184330ed1cb523689fcc074941f682e227bf0cdbd036747384b91abaf42b84edbc3f63eeb0d2774b82b0509ce0d71342f13cfeb223f2d89391abcedbdeacb066e032b9ade169ff78e4bf93a50dd4ba2fc47ae294886eb6a88490ef4f4294fc2e09f50d1f1fa11712910a0be1af922a683b9d9f70f4b666929800330515d3da63cc220c51d90f2ad148401c0617bf3007ce9525f1834ba0042fa4093a1b3bde381f0ec0f2b66e5eb46129098d0b4856e420b6efcb10ec67c576ce640c94fe0397f6d9015c9f2f936ec2f0fd1f72daaf2a4d415e0b416f78ee4bce6a64bf9dd73ad74e8017cf45424b8721a0269de3f7b4e5c0ff8219162eb9ba3d16907737ed3b71b5af006edbe51a8c0d296d620b1e6d4c7459d85d9efec0735e45f0a75a7a398d4607b54c9cac6104b678bad7df048a9c471b1dd116d1685f572114f16962f93c763311710315cf83be90bbad8bf500522fde55a726ad95dfe12692be10a39fabe48eaf207cf5e7d37047e4e8bef4e1bae7d8e9102b7e0e150c52d434f8dcfaee89f666d243297388461922802dbefba48346e9063c0dfbd0b0e64a4e1cdc90ff9606f63359050c071b02a69806bdec72744d91d81219a1873c925e99caca11e09a3d8b8938e782d5ca3e8e4d7539bb62eeddc477d63b605aadff8f342d702c71d876ccebb010c4faa39e6cdedc2c4ebe52d891cf6e25497975c6b44444e40aa4195e20ae6d21de4696b0c42248b0a556bdc8dbf22545595797faf993661bed36e40eff21bcb3b7f07d6bd86e8491397c0a3061b3a175614d821469d8baaef8cd64db5484112c70f63bcb5c6ef0b5267f24474502884bca4e172a8cc9c699a61a73e23eb1be612d5018c85ee278ca4e7314fe8a97e8d6fdd7bb737ad7b66695292055b12e56d0ebf09636ca123f3eed513a8fadb0fe39cb6c4105b47f5888a2d4a49092ad15757ec932817cd4939ef22e7a619a739636d016c02f651f321379c6dbd4bc116ca4a5290381f6813014211d23df81287942a5effb37fc6b6ed39be44b3948d1e471bedc999b6328657953ee0bedbf43b31c2a46e3feba9a5dac25d67728acd5b68115a98dfc333b00af7cd9bd41925c946a731fe6d6ab77feb2ab99e121a9f859b6498d9c81ca67ad339bf19c15eea95e73d98a1abb8a0a62f3fe56d4d888731c06a95b4c444348c7751d152b7161e706ff51eefbae56a764f9b450efebe85ebeac60f23902d973a417147a61d906ff12f838348c7c6709a88a2c4c325aecbedbf8f4bbc139f8af75aa8d011f1ea31ffe2bf92933076e05a668709e780feca568d498244253e5594f88c31f95f5577e4f2463d5aca91d6a7c037c013744413787c7f367e2bea2df6fdd9db9cf5f3fccedf08834430a252981edb2c4296b24735a437849f29e36ee9125fb2b12745a4086925d9266c15ca0093b9af6d681ba77cd98dc6ee116a6618f961d2f6df4586b607d6aed08ea0980a972decc78ad74ae259ab243a84dcaafee600b87226e95d07befe8ad9998d97bbc9f2452f7ac840cf5d76edee818db65ce921b5a48b32a3ba86241e193ffb8e6a6b51a9988bacde41f2af2a8e78357f05a452cc1b0a40a10d97cf45100206c86e408f8fccac518cb9b2269847f8146e3de71efb581faa97a3d241c0df1749066d2246862c88b0183cd89663021eb1feb9ba436d61b3cd3e24e4e973abe517414f7aa23c99035065e5d6a6f61bb7ae4fc0759840c94afb1664bb81912645802df76bc8b9698f51569720c80dc38e3909b885aa8aa7f428d7e9e81df076c63267e0a5183110ca030269c4b5c3b424be1a0b7df979cb3c84637d1fec94c4cc23124e3fa285648e5d988b7d1434b886c64a19a597b610b855d90063adfac54dd8cbcf18cbe681f6b37bc948d9302750abe40f693a8e821c0070ebb792a6feaff7a747420497265ead25e76e77781948c2ba7b7d3c61e5a93be42431c7dc177105702792fdf4449c82025318483902e66828a9af9b1752c56f266e128b0f56d2373d5c2fc1e9177595c8183efc861a68d8457bc4f627d996706b0a42df32fc603ae6e47396e42d2aea73831eb835922513a33a56b1dc295e35f5481a8ff6ed5b9387572aa57e1db1b8af993fc7ca958fbee2478a8aca0aaea6fed9ed204e2cc3287051134bbcfc86622bb5a9a804f5dfac654451b6553507c0878d14a68f110b8b60327cc20d342848b5397e6b5c6c5124f14bea188cc82f310b7975ba2caeb88c361e9e2737491d722edd39052f58e23d6080469fb5f49aeadf991cbf67cd10d4289c3f1c86ca73fc7f812ba200e9596bf0c449fd8caa90b9d78e8058bccbf274cd8e53c9a02297b3f87549afbd84675d19665309ecdf4184c3762226d7e9b183a9220e3b8f414b0763c529b6f8ba510a4562a409964e753c25a120377dbcdaab7588a01b8469cbc9339a6736c4e57bccce3af5fbc393160191ae91044409c073c46b9f942f16b347a573a26a1338879e6234beeec0bf491d729b3efd61073404c95083ff812053676e3d4aaf787b8e81e1b48d2aae27919a4996f88be689753127d85c84181931fb0684c332a5b509bbbf49f79d0abe001b2d0ee517b259c909a19f06e5d2e4cf970128a29d5c83b6d3f0853793bbdd4cefe13545ed33af1a631242f007c0da7b69d3db5db818ccbe705d9a697d656246ce33437b13789582be15d7eb09a16f89be1337a0c0655a5039cf2497de495ad5ef39df781425f6b572e7dcdb2d2cdc94c5ea55316e995c6dbaaae7a6d68124afbfd57369b395b32b6b3bd5ee7edce57a1ffd0d915b46e774da22f8eabeb160fa87f9333b68fb0551ccee291a528f72e1b0e7d0014010e8b2e8a0e59f8d36653de512a30b88c69bdc8cb6120b80c99bfef9fd9899099326ab0bb22d9f9c0acf7cde411258981e358d26789e9f6618a8299e9553af4675959aeb5cfc8b5e6a49dd0f9df55f3ce884d3ddbabb743cf707ecf27e98edd1973dc3e94b4c269227342737c5c502cce3483457cac2462b76eaea002c1d533f1e82b26809e907db7e049bcdad14d3c1c5e338a90ff9e9ae24fc21db2e93696c69cf366c1f047a03d10752362084b66ca800118f0d40a922871842745e58823855afb50d5c492b91d49d398b10d1a97ef598226408f9015fad0a68720be50eb7d77acdace8fa8e3e18ef3f7fceefec6668796b58d3398f3744b54db9d45e1c1a0ffa3e3624f0a0738a1a0c196a308df95de9fb7e51ff52c3938cd018ebf58e3128cf325e145d8cede20ffbfbf35bfbbba23d72060044ef605768827cfce1b5a73b2ef7deb537d88c82944267cff2e3bf2cbefe0578d05eb13d66c5f69f6e1633e80eed123d92e8b93834fdf16f5a3629a0b0caa846144f5d1504427c3307ba1c8945bc7e8cda18077af40f442a7aecc5be0b27af03705b228a59f102a2c9587d78d44ccc31956e086330252ca1795d57f0bfeb88127cc995d76c431efd4b9a257e4b08882973fb93f91fd882bd2b6955a60d6894dcae410f0de10df02e747cf4aac163019e93cc8f6b87c28a488e8dffb93f455fe46addee8e6204b9a2c86247b1e144f5d9ff93c5f3fd322c047c8532e1e0de43f62c1f4216bec4891756fc66565f375ac50c6bb5dc480e041240fcb2c9904d4469134fee9b904b714586715338f527a6c3cd1af290a1e9475001621e2a5ba5f62fa48d18d096bccd5db4a608d14d61be9d6ce875e9d6d36bab60a80e24b2289beae95682877ef663d5ab91ea56f1d7cdfe0c48f24042a706ab68d7bd2023b5065ed046d658fc027b42f5046b69aadf4bbd70f7bfec0d137bcfc0ff31ea3cb14f401bcbe345a757ee046704bb81e8240c6554a2aa826dbd89c371a6e5ce71d7f0eeba448b3c39e8037ccf220307d6e8697f53962cf6ec46021bcad3822920aa81bb0c3461993a9feb8fa66b4f5538876a3a0b21ab49500247b3b0b8b187efef3c6486f2df3487f6678f7bfc11d5dd667fee05f385c2b3dfd455df2c74959e26c2a24c8d737a7b09b6426fd414b76b51dedd08dab6ea34b190b292d2cc601b72b370b79c528ba5297a7705d76779557e34e82323bb5e4b26602fd1d8b24cd054b817f86316b19352d53383037a37a79103b3e450212d09d6ea04def721201ff032c256fd1194f45f93440e10d7be2bb785f126ce1ff4c8a0b3443529d3fade98418437a274d69299558e4389e5f294d95f44c14cfa72b457577785c273d02ca3ae50a00894c69fbb5442392f9502525f466da4d70604336391e33864cd9410da8867f9dcf261017ed2c3f98492c59c43d5b0ba2cb08a7527a041f852a6e780ef800d77fcb390d719f759ec9c32a03a796d8a430314b19a9f7d487b809bb31bb328affaaf841c6e6a2699450d9dcd96e799ad16650433a54897a3848bcfce61d7f0547846cbdf58820ccdfc579029f0cf14791ba184349909844e09ffa6447832d20ac869bbe3cccb863b014d09a7a953676882ced15b6f0ac9feb741ae224800522e94349ac7f3f5a1f0e0ccd1052e54899e59c2a5859d18a962c08f231b43605ac840edecc1964a63cc227d4416c932bb6f00fc3881b8878965693bafb23e45e1fe8044704d86a1edf13d6fff155db67f856b44b10924a2fe0fc6dc651a94e7b0bb518027c6e3933468f5630b6df456570aa86e5e1a7f38432d4711ff671a5aea56e6019a02f12c084c56ba53283e7d5f1a088da2cb00e52dd41f29824f655622e9e49eaed1b033ae28d46bf115b00bf08d172d472c306a51e84e5b2ca74a068ee07b0d49bd370591f5e9505055a767b97d02469a92903e5568897b4192245bba33dcfaae248fc6e87ad25960e420f11598adb844caa5875b9be9914c9d56b5e162e342ea2db6ef6dfcb515879e5b46478382710b5e77d13e66192f4eee908e271c6470e7d8ee7cb3516500fe4766d2853f2053499e6cfa555e1ad0661739d6e416e7b8f19e94a8f2015f64a1ddb774c63a6fe66148c80a20cf49532febc53980c023c28bba69aa8a91d9581002adbf8047b91be974389cd6723da30baa83833069690e04e7be49a68afb45d17a34bae116dc7c28cddb422a1196a1dee0faef41b43efcae2f332914ea1cb25b6763dadc94cb6ad4b08b57d5d45c2a243f4ce3dd7064e72b81e370e2c4ee4ef6a0997b7516e9deee193ff050f1e94c4562c449fc5c1e701203681647cdc2197d416a47261b96c67a39f68e3c01959eea1079e516be93503d688ba23ab883fa322647ba8ca059c78abf1b5454e8900484638a4ae3bda130f404189475e108e23b239933be5af7dcff1abae3a33c1447298a39726d1d3e74903161462d5f6ff6163552b3e3d93a22b068770df53e753f9a6e6cb4dfa447fb6cb1c6b08b55f8fb3f931a7d842e30e956209b18fa2805ca14501f93ddd797bb80e401e6989b3f8854e29e961ec1c4f7c0fecdfaea4ccd806daa1df96a64b94e22c0b054e745a71d9c5656977d8b77124048d9ba1718c771dcad7076cc064340b2437a3b22189f4e3bb206f3b2e725416fd16efdcded2e06680d2f0eb8a77c30a84b7a91b528423c499a2784ac2c437428e1f668e98b27224c8c0f007813c2e5b393a316ccba18ac080c2206d26c77e5caf2a6b52a647029af0711f487f01df7f134f7fb15e149614edfa3b8f44fde0763f277187381d7b8b13dbd5f0c2c2963bd2e59b7a62d27c62484083a03b8633565434f9b1e1e640f639333d6756be86027fb315908d2977687e03bbddfd6a1b60bfc345aef55a5c7dad8e826069bd37945f1302a610b8d1ee9e6f3b95a02624ca55e93ea2aeff071fd3cfaa88746865986c7c0769fa36a90f741eb8edcb0dce788f4f2229035eb527284cc87b50fbf75fe2a84528cc779f5cc4501282866b2480a1daa73834cad73d603b4ac418b2cc3a1061fb1e9499f4f230dd45a99107a626699844cad19310e423227b7f48a41a1f41b22f278ebe8887fb4ec14ecea0ca1187535e6c989a0b2ef85447a9282e232d186747c85e5ead90d554d40cd59829d7d174c5b3fa196f4fefc19483ada3f9a14de36a7dba92aa678968a1c01a33f22e1f7c38a121be0f87b527f0259f930f666e746a96e119900458ba61410afd53eac1f5ccccbe5d9bf8d7159b3217c2333913404a667efc90e64b2b6aa7a65d387284b24659f2feff31fa2130890e6892e7e00e383e63b1e93557226e5fb63335e145350638935b3fdbea248780248aa18014816443dfa53a51c5b3574afae5e65c96da6ba1e2b374e3636ecbec012e3ca2a2a040e13c92123a4040a485f6a47905a3fbce324e3ebccf7ce47af9287241258874e18edd0dcac19d9c74e6a8aef46dcecfb2018ff8341f881e82be5e0b49bea37ca153e8d2a15f9942142e840d3bcb0eccf57cb52380799f77b84a003e2045775bcad653a5a04855d3cda778ac57d0bed14e0c4868279832bdbaea38a0c14d1309760fe9075f243594747ae1cd82d2fab27ab62ad82d1e62af700aabe4bc2e57f87c56c707252249e61f90983f71988c90ad8b2d57f5647de2d2cb7ccd669cdde2b060fec4416a7d6755fb6b575f7a98040dc7255c8d8f1cc06ce50410905d117273b23fcc7d52da5ac7da8897d833fe792ce9923038208d6329d127217064076b8036f057c88caeee7fe26c3eac63918a17badf39ea5d5b003c9c7a30d6cd6ea34cc7b4fdfde61bd100f6a4c3bda8bc6b186dc9cab2bb1749d20e8dc5bd1615faa704666c7bb3f800561eec5be4ebf9b6b441fb1a8dfe790990999fd018d0e84e421dbe6df7786c434194378d0bf31c0fb3cf12792ba87627ba2d908072eb60f1f20c7a7472d5909c69720ffe668d8442e539449f22ee8afb8eaa85cda682a0f86e0699ff0d7a669ec19811be4f580d02cc12f102f5403a2c9bc1e6240e76a46662d7ac208ccd0b8cb3ec404b8cce9b95a398b5d2d73d75886e633ab0084b1f2662f22d1249dab9cf7c0e61c588646bc26a3e48f62780e19559066bc8b72b6bff2cd75e9c8972082e18e3bc7df3f775b724c96f0238b12b9692ae93768d69c3f119b53051811db51e02846ea8102be8d2605bf1b10a4fb4519393895edbe2e49255269894a0b4a2b7f7041b9fc3c20ee247b155661157a1127b103a11ff68cc7b0231ba327f0f4120f80a8575fcfb5bc7a083515f133864d75e892661a7172395dda2ae8234ffa92b61eba74a9e4c891ce825917f95582edd5db01a0c574de6ba45553c26e257b32dd399616a1e228aef15a0f56d531d5f3dc27f1b84b0ae5522d34f02c826e1439e2398e976ff150e543e9e31d5ac7e485a7985ffc455da6116e30e01cc196934494be9e0651a30f2d91989b66f7913858aa791a11b29b65918ebaf618eff5a61254c44f38b9657a41904d757e4113aa365693b4b3e9dfb1a6acbf9f3e5dd64978d6c2dbf49f69af73b4117c77a965f7f57d7fad45dbb47a4bc3766e5ecafcf46f1bcd875bc9ef2e46fba387fd3d009abaa0f78c8103a52f8081a9135c660e90b20b899944c2efe9cec3938c2c1deae7fa2ebdd6fd0645cdc7b3302887b21e255e271e2e847ef9ed259e587bc72a1ccff51ae96d7ac60045def76c66723103afcb3b0d887ff5c2b0f382e2443048a554d347807fd1547815e91271be4907cf1f4e1d45ff6ae2c9ecb6599317da791af80b8c2451a6288428cafddab4cbca3614b467335e485423e6dd25fe00998a14eea9637edca69ab1ca4dbd14557a4f88c1b4b53adec7aadcb795a89f12815d823d4ff10ea080fdab0383da63f51e4f9f62199350cf0b8f8887a382de43a8f5c8e9f3a599848adfdc60bffdf226d3f2f9cdafc2d5d2f45f7b0a81c52fd2a3984cf94d37243372dfd3a70b55f4dc337da0f6020cb74baf0603d168cf9c8639506d955e485607a3f6073967ed7e2ca83364bc0aa352546fb0a213b27b799629e825e066ed856dc344be8983c539844c66b3a6920bd963d9247ded78e5b1bb0a226c456063f333ca4a6348c10e62ca06149fde7b20200f14bbb1c70ee99b0b9b30673f6995cf71717ce38efbbcdb0f73e71f6e3ac6d9cbe33abfacb9d4bacf0ca536a508792dbf7aa1a811f2c5fe76c3c8c265416cb1e9d04ddb533d9bc6804f41af63023d079a2477f486cd4ef95d412a58e90005868eb542abb6369f3265a531485886653fbe8dce1d4deb12f5734702eb3f0e0b63998405ffe8a6bbcfd363906cad33d4a528dafda8a43977317effb14fde56812101b97c6ffa3cb57307f5cd0735713293986ab542e539439bd3bcfa15b0afaf1ecef0fd206b6f4112528c4c1af3ee39cf739bde5ff3345117b3d8425a44d2bf54a5a6b2c6379ed8943b799649be4da2404c3fa86a62e974398ae540dd372a601dcf0a330bcb917f68af02a68b41be5113151fa4708b8b2e6d40c8fa7dc4d66bf59410481304430c2a51e4f62ee865b19e93c36752efb74794fc631b892ef072fb48b207f87b9b93d4f449f1ab2280e55c365be156dd7a4000f133f6d5d0ce92a606de682786e49a54d6ec22a7c5d78ddc0dc93d4ee966fce17f9a53e0b16db59ec86d3fd0df69db3fee393d0209c369188965c894b978a65da71acb04e058744643ded4bec434edc5bccc58a0b1721dd2f4b5e407edb6dec8d8a2ee182730aa46276f3c382b167def804f312c5750bfdab87f36c0dadf7184b7e0046baf748e9ed653e133a174339e5b8f5be1e3424817a87185b43ce59c6753db75e50e7737cd12984811d8aeea7c4d1509019517feb2becb4e2190de313b5769ba8e271c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
