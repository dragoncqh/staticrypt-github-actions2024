<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d71c40de762c624ef2ccc8732fcfc926cf1d2d64ef0c6b4feb1475735fcefcfdf6f2e3fd19c9fd2dcdc23c819b15b27afdfdbd095e4a917143c13da09e8fe5218934f3333e34e75bb2cf00b4b5c6ace1c1ee5d809ca07b1efb2be7256460c1a6ff051e549aebca83a6ee209edb0028f6aea9a63891ec57d5c859a88a6ed330bfd9ba485046881b463712699242fc1a0fd606884ca41da963e057ed371a6caed2095fb22bf7beddfb05ad394b89a8caa866db7b231b12418a49cd469a944d48d60f85f6e4dcbff62774b24958ace7b074e674fd02945607184161af683ef2a111154aab6761eedcd39b02fb7b3304011639406021eebde747d935a4719bf07e5c02b950a708d1d2040374a992e2732c05574e0686a4d609a55c445053ca6e2cf1e65dcf03240dea4901d9731f51592dc9964749ea6bbacbc52193b7d83ed681a6f9739372bc44844e3954a073c0449e177013b0baed470faba422d663f9377f86bc7990735384b1d82e938bd025ae631a41172358b3261b57a97952ed7131588c015007e3d1805609f09b8172e33327a229943e70e804e5e0ea8d26bd8b4c47a063183662d4b512ba9d938284459e50c4ada07eb7a6c7e2764b573b47e71fd17052d6f21f066ca6e57a274c330e8485ee2b9a6ced486a1111790d20505adc76b9b54501851b965a6495bf196a33268f77a869f724058b57ec49f7e758c11928df29a4f238fbdce6eefb0761ff36e2eb868bb3eb7997f85a9763390651697f292fac1514d23e20c3ad29d609603b812d899bf7ce330d0fe0b767dd6b9173d7ea091889e5a1af0e786a34f6757640f56ef97e81add5e244100797e2ba00738300ae83001870f2032f1aa835ab6fb36ead0eaef57c5d8e29a0a2c217a3570ae1c467bea436a5c13029604c542be38381bd87291289eb9926872f7306069ccb5d6caaefabbb453d8f43814c1b6ffc69fb38a61f9cfd2e1f58f9bcb55cdb753191dd70274c19edcebcd23561c360473e6e8bd77dbc2dfeca2c4475937b067a62e3ca1c7b926d6836913b685be53cebf40b26d00977e9009fd20bcc9b7089ddcb9ac4c999e99ab57a0ae8a2bb429e8c85535a1573d9095f26f072427705a07ac2367433be30a1817d893fa862f98ed9d3eaf2dce180aab23d8618c15e3b5543332d9390580ed58dba36adc44788c7c80a25a664a0f7aadc14b7d72bfc42a560f84462e54dbffe1028f9c13bb5d65eb91f40c732f8a2d6eb537650a3a13ecdf08f3bb6f76c151ab2c526714ec74cb173ac6ab70d1e75c91145d81b8971fe092586cf1f532114dbe96f95cb9f274738d8ac7b757571150872ea34da377742c14f1974a04c2f449bbe1e5c884b028db493ed727bea1ae2fb8bfb664716b22d77b6a5cfabd24c22cd6ca609739d860f3f6a7ddc8abf68dcf21df0b51a4f21cde2f9f34e472d41e7dce613678182c01140ad491dfe5e3d0c2e8c4f93a383dbbfb85f536a28addbb14e00e37dda316c9c1c143789a1a98e99a07b361c3370eea71bc2feb4bb7b8bd984812b672627b0e9918ca97401273f5b860784a78e19470e5600d3e0bd8c15ddafa0924457b782505193ff49893caf351c92424adf71710d60f1a5ac4c73852cc739755b8ee3e031efbbe14c775c5c3416032ad1801b665468f101cdc920f3e21f6c7c306e499c1c1a150b992f57ed2d4780de97b7f179a8049307a9ceb5f0b5c31cb48f0b29301d5f9169fd32d9be2a532e58e18f4ea4cbf4f72dab4e4e282a8437f14489138c8c48f7b0bb9a133f1ff91b5c722e67932635ffcc349be649a4474f4f429697aaad6a47e0293df6e22ef67e7b7efa83313fc887496954eb59fca2a3bcd83fc64e21620d363badc6635ba026209d211f3ad769bb69b32bd202af084c51716509fc8379222263e894c6d04d762e339dc3b06c1e43c73fef565f39c0c766384a6e865b02fd8e2ab229ce0c30e60dac3b4b5e08ea1969672c1771dd6857ac4cde30d9a0a2526c70415cdf682987caf02591cb0966b7306e8fe3cedc63cae3a802aa87b98569752cf9a5788bd476594fe18b5eccbb2c1e5c39dfca1ccd8aa29f90371c5d26f2bb02def3ff578b7b84161be72b2f5678c19ce393fec46d74a22abfda3ff01f58d5bb55155cfba1ac78bd91a737ec6104c55f142762c923942a456bc84d83e015d6024e4a8aed4517d6c2f750294cc54c3750fd65c8e48a0611ec280c83e01e85f73143d13f9ce3555d6aa34aed077e9a663b9495beca7a0bec732a539f667edbfb1cb4f4bee2910f7e1e80e38975558176d0bf2f4039abdf85e470e26789876efa861c6a09f42f87c0090100e294dde3d18fc1651080bf56dd64985274602da0d047e0b977eab252e503b5969e534b1bd611fdbfcce4210617bebc7310dbc3fe17466549a92583f7fb45d8e21dff1b14f882b20d51d15fdb58b4d6f6e1299ffc73b672098ec130130a397ec1d83049f49e9583a72f55e1da5d08d54f26ab9867082f02c0a46d843aa47b19775707d1f99e829e74fa2a8eb696ff5b0b48300f98bff3e849c89f2dca01b14fbd00de1ec745a662c39c2ccaac8c75c274b9e93e5eb54380fa7d459b341f3588629832c68571e4557910a0862cb1130991544a9f4933b7d777ee27953703306fc266c18945f1573eaade01fca28e1e8add0ad0220bcc044ccc7aee0cba68866c4146b6888490932c53b9cece3314b0163c4f85253285294c878e10231e7652ec2407b9db13704fe686a8df5ac0babee24a7f09d26ae45e2377d661a62e583d6793cafc501f83b32dbdcc81dd62def8378e0e9695a460670686d990a7c0afa4e8d2e40503d742f80d1b31ee4df781b17a4b1e87f027ac9fa053171e5613786fc382cf6e5986c9962c9e8746cb7f5caf65fa9eb9ec301e62eeceb980ef5bd15ac6501c1295941f5d62a86911ea574f790fc4c7ccbd1e268990023975135f4fe657878b7ab9e09a6a29c3198dc5b3068a541a7db6dab0e54d7925a0dc62424208cc3773fd40d84a10d865ccf75c619665a889dd7793a70fc070f17b8410ac88ba895519fef2cfc4e1b732b8941720a82aca53bf7f559e6bb6c76d0107e787f9e6dd96119decf1e8db6f91f86f4932d47bf31732f762fe2fddc6950b16ec65671867c89687cded00ee893848e0bf4b800cf9989eda7d6c7a58718bc85d547ba29be7be2103353d38eb9e162c62ca1facb6b724fea6230bb8c7c839da343af32e00dc651a80957da07c09659d40381f75ab76bfe8bf49d3da1b879578dffe869f8cf280b997054c9440c87185ece680d914ce054d72ffdf92463e2c6f05b46c66de139dd62ad1d8a075ca763faf6e4b25fca14ff7d6fed3d52f4cf3ec0650018d91a652a8006eeec9c73274cee660c505bdc2f4fa3cceef69f8ebeaecaba872645b4629cabe22ed83d82042fc716566ab273da9b5b7d3f00da5df0c883d2d1cf2e8f882bd34447a5dc19e4b296868a6b8fc3bccc89bda0eebb91e3d67b434baa2fbae8d7c652902e3f50ef5706593258aee4fbe95a45823043de5044c6482790a802bf579810e81e5f59aa87fd65bdfffc7159a98e2943491fa4bdff3a096b630230506cc56d314bc7290ce3a03f20c2b18b8610013611df6ca2a3d48d00c3e78c71a765938229daeb6b525c22a023fda61e9eda0ee4d506e3a57f2cf58af673e6dd341e15e7f39f1a96413237a10d2262571f9d8a53f76d87714e421199312cb91731b751ce3b3988c43edc845f36f9a7febc7a4ec6707761a8cfd6aab8800154cfc0d634464fe0dc4986de8b70d01b2edb8839d0eeae54ad55575e9997df80f333d5ff5d44ffd854d1e3abe4f412b587778fc44596292f108f588fad67034990c77d6278cd247dcde19f5b6d7ca5053406d3c6934fbf6025b6db24f3dab5b3ef8d1ed04719e0add7d8561774c4cf24cdc71fb3068b56f5873e625a2c8fe6294a700ad640ce1f80c91ff684aa7b8beac086fcfd9b00bf9941ed1df20979c3277fdc25980fbce9add16d2b3b83f435007ddbd8c18d91ea6d0280b1bfec89e74d75060176b617fe68d716c5155292acd5db1d455cfff65e2e56ab6c740968ea834c2e059b544d3530dd162e6b885e1f7d26e2414b45e3b6c823dc29fa07517d8b68332b2a30ac19f51791a06e4d7f835813fe0ff41759b87c41cee040a146040b8318d5d24b084eb492b894211875136b83d9e37f89ba79079b2045648eea458d8bc7677493528516bd6c3b3babdcb963d43217566f213cb0dcfddb45135af75df4ad90f78bc9702f4ac05cbfd3e824e8360fe5f948ce79945bd2d3b9a87cc955f268d908429c3a36f0a6e1da29f529f7e2e4877f7068605f847d80818fd95acd951252d51d313c41bf296b56ecdb2891c748e437229baa20ab08408e53f70b9d1f21932502e2d5a73c1a1c935425a92b52438b25ee3a3d4ec371e29c06ecb74ce561b6392fc878734d0c194df68d9dfa5584d09e07476977219b50347b588bc1d85f8ff7c398fa534f1c5d131b38480ea8016ba1ec7534d87c1716063eaa3c60468a06d5acc53484067be833bff1c39c5a68a87735e59739b4604f05669c9908d1d6a816c80909669cd9351d563b598328b6fbbdcc90fafcbb72d231edfbd214f69ba5e76b196e4889351b1ff7999103757d7c0d084cb5a38711b324296284428b768eecb417e4a29288992fe8d72f326367bfb0869f3eb2532ca1b424cb4384a550a961569141ab7ee7d959bb37255de69a1be901eeb735c072982526fbe0d2d19e3367ccc8a600b6e28480e9cfc01ef69a56a3e0e8e80c319127a6fe06360647850476bb5e4cccf0265df3b2f5bc900032cfffe5a9a68ea1fbc70b55dfda2000c608def2e500417a7bce69c06bc17913d1def48c3660262e5a52946c9559811d07e5161d218ba44ccf715a72185bbcdec2a1a2d36e0097ba760260e5b1e8274fabcd673f39dfaccc2d54c5960df969f89923ea6bea1179c7828cb9571a8b44c81e6029afe24c24e62618c2be86720841d60b4245dc734f2622911f3785eb373f065f3f84f1e4a1aca38596bed6f2db315f6db0c7d62ce2b16427f4d80cff61e3ddab8df9c4e7fb25b1dd905f1e0d2d7944bbcedb412ef8194fd1d09b5f4047c709eddba60681f3656bca85de9c9688be280d891f04ace90e2fa03b9e2288fb1952daa8605e75dbc99264d7979fb389e361cce968037f90c5c5cdc94cc679b0aa95d774983260a8b5e9bf38a2bb8cc6f57988ad64b1370c95179b7120b21ad860a42d6b3b627994df718c8e24c49e64fe1b4e9f84717940ad81aa590c1362be69dd3bcdfc4a36144aa24efea561902c8161bd3f0847cd5b1703b699c3e3c19cb0647f81945457b4a3b69d7eb4dc3c9ac57ef7a13fd2b9a974e6d483016f766afc058533b2895aa86263858870b658dc1481468caf1c74030f502730256971e2e509d4dab9b14410aa4f72f2cdef937efd62d46d4f699b01ce39caa4817d65ba1d10db62e93376a7ec2cd2f004e116a7895b79fa23ad717ce5bced658b64f938f5914b301d232dcc295c9284c120b6433612fc6463707b88e33ebf6f4b1bc8a5975c47044918aab6b7f5a58044c95de0e7d81882a7defb86c85bc499a21fa3e9c16b5ffbd49491c80f0a99d7643bb21c85cb5b0e2dc2542865867c5cda501ff4c7164c580db9db0d8e2bf8fc95531b229944665dfaa79e7b0e11a06a4d763690dc32030d2aee0e4aadadc5af52bc41281b38f538d6f5d40119125e35c919ccb121f2cda474d9b05e4330a6cd9542b4473030132f0b7b9e59c57529c15968dfb0c57110ff1a8fbd8f0f51d326b2781fcd47ff837e7a133e671bd451f41cbf1355a6378730e5bafbd5e645bed1ad7cb1350ea9ee9e8f74e1f585a0e29577297a57db35e8821804a515fa31eb131d9eef57c1512b63a154ec36032aa03149ef4f015cbde10bfc69c31890d6b4582355c415cddde400e41b089c9be2d6a8fe461fc28ad3a44c18f9c5f6e8c087e006f7acba611d97eec4f7d67e2af33e58f751fff25ed535e9fd145cf7a362ee80a48e82053670731543868ee6ce5c120fc81583a23488a83104173dc2ed3e0bc0ee9583a6dc83845bd275abbe4c32c53ab20f57188448d4718cd1291a0e16beac5674162efabcee18e082e0ea12efa4a2c2ee1a0d8dc8771a12303eea5b40bd76f0467f9230c2fd617fa84676f640da54021d442178ad329be0e5b26a06b4ffe479daf1e45300cb7f1e096a21b4f190ea375ee2067010faa8a1f202ee23cb22e9da92f5733e6b9f2e1f224ef52e7b289a748344c706b5cab85d82cb1fddb2dc676656db70e6c5f99615b6d855ff3a42771bee6139a33fe65047702598e113cd376e8e83d851619d533ca5ab926a669c352ac3bcf70ce901648164eb730c7ba92717c763966879c6b31bafe540addcca3b6aef6241d0e575e4e49b1402415ac12f41eff4125b33da0c0e113cf06baed5109560f34112f2b9702091d237fdf2153e4141275b7e230d563d9eaf7398452b871ee9e18b74cc29decb7b54239a27655d20b091f8e5700708185798d6669ff1dff9fff4cceb16de26d18394186c9eee973b64eceeb13d37c583fd9d619d4a664f86609fb56d01f6bd4112cdaf9e16d099098efa34e0f5e5c6e04b4840a7d2d6b287116981f07bcbc9f5d9a1b0ef505f0ddb53b5968c761d1cd87322a41603734dce114a1adb802bf6d23f2e7b62521b99425871e0b885e91c70adae35e9f31df138df0350463337c7c33331b0a13f0689a7248838e56d887fe1ef301305b2e150dffc341c1e7acb4768baf4d03dee986e875993c258fe59858b26fb08ed5425b7c77a41fe4b467880ab861c983f8c36ba6d6c7b966f222780701debc148dd4c43c42330145eba9f63513dbe0789f69b1d41434e328b6db43888245c6de07777868737287593e0f1d41101aa887d1a4a56515b78b922312c931fa8c5f106f34c4974ae71e2f88120712c963fb05b7961e1de5ef10e323cec72ea78be1a7f4fd269ca814bbe52061f0ed5fbdcac82f84f15122c4917518d57568ffa27811570888e5ef995524dc16941d9860f97956acad38efefac3ddcf9e9cf182b3adf716df56fcae8d3a23fc9da894c237727561c4649001361f0e2b3f061485e66566cb3beb59089fb8413e6e2885cc46a40fa7d4d979a096c80e410b303761a14de7c1726f619af268bb583d1ac30ce6910cbc7dcda7e7ab0af303c38a19b81a2e589a731c9306f2cd82540555b595cc70283b3c5ba999c1988246bec24faeb613ff2809d675ed5450ee85dc348b942d2e9cac540392df5cd91f5a8b38a882d2f55940a0f9c8b7071567cc75a602f94ce2716a8045eb69c847fbc1642384511081c6d5d2e7922bbaa88dae296e9312309abb00c3e8ecba6e359c8ab7cca4339b8e8d0f0b1a16c40068642f95dcd2f70916dfd14c064cc1b970476c919947742ed688266a99a0a4e223ccdda20adaf9c526ce30342b9c16257d399d6eed0f5658bd903b0003610fb05ba0d6c8d4e917f9cf9b1de8e2d898288684ddc3ff1dadb0bae37ec249d1ea12cf452050220629ea36ff777dcfbad87ae9efd8d91667d613fb85ce4d57f3d47ea8eda626c01ece72aaaeda633b459168cbd1e5da112659a006b084c9bcbdbb9dfed33290e89a00db3405ba9282a0e75a40e6d8a61bef1609e7e4858410938b7f67ed2a9d01c5f1358e31874e53d603296025774bb52f3640c372937e32b1c01af41a6070842d3509de5171c255c1d3925e5f4ac3629915cb98d7c5becd29d2d04895d4736f03c289aec4ba27c1de75a5d93d65e5b1e75e8a6c31c68afe28933d92387a1a8b406736602ee2dc4a7602660ebac4bb4cec95e4f8454b83dca23d1de5629f9f9e4ab46a2dbd53f9240269273a96240a06aa29528752b39b39b5126751bd01c46be61f541c648bb3a11bccad2c8fdde94195e5d43f4177ee759d764363e7fd8c278594b8720bc599e8fde555d176b82ea6b816b403cb02179c6f57c9c85d2d26a6c8e83248ecbd6d14cfe055ebb3fa41b389580d0400bc8811f3f664c86848e3eeb4323bf70544525ec1f255c3dba524fe632e163221a30720dbce7332cfdbb0d3c2f9555b81f886a9a2e8308b938d79ba7b6f1141e475561d30b303b809067c952150528b13342239d573e25850ff863a0f0f18844acc7651da689154a0a5c756eea18310dc2fdb91bf0dc39974ca38c176ce72399fb4779c0b77fa3d9376c7689a17357012c2f04f2d20d6d8c58da2533037bcd4a7f9ba304fc0c7ebb374d9a20bd37ab2fa48ba4c7b1b16ac727010434706aa3932a1a7e586536eb9ebd2703409ce553eaac0f84a06509f7ada33f99336051b1f5d44d7841fed95746cd2f598809717dad165dc88937222ba4c6c9bc33604d98a98afd2463cbe56e08f84ce53f5728846e3e32d92b46fdbc886843c8f9936abc3ab2ac950e1b5d5cbb953271030627ee3176ef33d408f5e1725ea115f5d7699d5532138f3d10e379cd3274d503d609dd85a97849466d1f601cd898c075e391f038221ca5660f0dcca11740123793c06835e69b0d0c53410615c88bdb44685daa3f7d85a1c77b8b0cb79a83807dacb1f57debd84e0bb1cc99719e74dee0eb2c8d5fff45025a35c22411bb49dc11e04c5540e85896a2cf0f851a3c5af15e17dac4647c4816bb207e829683f3156d75061ea8ac1c7c78f1cfc59746c46c01fafc18cc8b2a3b5c03ceba99a69777b1c0c2b62d1677d2c6ac9d50f398359752c5bd8f7760c5eb0f3861e2cb188812f1441d2b764f093d1b5fe36f25c8f9ea7889087ebb3356a15fbac3c80469d21895dd0c36116b7df376b7bf970f3bab1d33bea22c03b21148fdc8ff78e5057d0d963379e8aa6bf87f71a3899cae065acbe02c5b685f9b96ecf2f5a81d05b7e7bae447a60725a4dcd9422b8cbc7d8335d227fa1c5db54ccf093c93f4027376e0c0a2ffb4b57731ccfd7fac6001da6378798ae6d2a6d3948c45e4fd5d5fb00dd65b410ec2f43d0883a2bea50d6e385ef219593e732b4306a2b8d805f6133e51750c9d0f8aff69f0ecfe1dbf44e8da0646f05881e3affbf6166d8283208a71e6b92f49b166ee751be0b15443dfc68d014337893eac0b85ff2880b3d87ac7d33dd2ee6aa00083e293f40067bf768a22d22cb5a1c568ea8d91d73d94f103a6a7dfd04e61c1ca2f25da54a4d9018076544e9ce6d1e405e5cabf879687e106c2f9d07b43f669a501edc5aedc40f17ca02c90a83f8f933394289e3965afb0485f7fae6abf287077bd5d73373be365c98832d15e6a4f4866886d4c4b0048c86720d042de295e817c6356dd86363ad268a93da74aa3ac1de8c03c3782c08e70c3ff5cadc16620ad74041705c7fe55f4951f301729234164678ddd7372fb7cbeb132ec9454f3e38678493b1a0809b3c9e6b09067c55e41d84c070c313f776946fa6a3d77fadf85fb104a33922d682619e1206e21f5632092996e9498b6bd3408ce57860de15218942bb72650ae6b8c86bbceeb8a5abada16da1f9ac2c846c06b959aaa97f92be7ee526be670e778aba70a2dbd67cb5da22e7661d97b49e7d4a1ffdab49ce8f45f7a1adf4ae94a434b1c23bc012b3544b7e3071e77011423d63c13ce7803f40b38d266dd7702a6355f25357fbb5f302680992a47569b16c72bddde84ec778fef4b2dfd9f39495f373fe5435fb13add549d78719aa93f44dfe31540040887d8279fdbf933e88856f41e66831d36ae973a68f1615210725217caf1cf20fc7d5ae369404bd2b0505cabd0890c725d08c5d624c6bc96f47b547a182321aa607bfed5a7372af7d6838ec79fcf7be39b69a169e2332bad2dcaa77c5a798ea6474885e138264c6b38be9036e1872cf058832b08b064fe33412d8510ab6d1965bd7371d5754b3eacf1b827d33078121a3f843bbccbf71401b55a1e705768e713ae81bfa9209d557d551eba1487595518250e024b957d6b4d06139601eadf2b2781da9e5ca6facb5e16966890912b4462e90b2b12c4c60f05b5c33f2367f0e4181a719caf3dde40e41c4183c1e1ce8c538f8816d73bd9413f2285dea78d38f12f775c9ecf30eb8b553ce2f84510e6ee4a982dc454d3cb76c2020a2bfcd69c2f3da198e690d50048e942194a0a2fe3893fbe22e361feee52d609b5877519902a864462eef31b7e1054b80bf60f8e4c078ca85d292736f335b365e5904cf22abc9fccc7adb1a030a068f3b8f469806f48a1e889676b6abe2473b4bedcd99a1cc79d4e617096293f9d13cdf7b1a6cf097556c55aa73d2736f2d3a45168d1689b2ca720878b6038e0d3cfc1ab34973bbc3e09b50187054653aef68909973a1a7fa5a620faecc853b1197985fd1115a35da79933abc31a1dd25c5ab7a11df6fcfc675ffdeca3ad3b5f9cafebd25e96b40f56c2424618101791ce28df8df01287ec5ac81b594beda18d61f878c36e19d01ef46664110a75c409f4a1828fb477a6c1bde537c199e2648671f9fc2dbe4c41b566bbefd65cdf925378299f990baf0402cbafc81d1bc1a38d79f42354ecdb55e77d374bd4fe477b6898d8ddbbc33d571b7bc5db73ffb72fdf65ff607a47149bdbe4a6cffa48eb37d85a13a77c12ee7ce7b37e84a82cb894d00b8b2182d5773d47835f4da6a0d46827d9d3817c88bf0b58f5d316526c3cbefb999f3eb895c8d4bef01e672bf81468512cdb6ffcab78b2e64999504800c6b0bd7eff4b73180c662eca90c12ef4c2632bddaafc087b83725bb80e49ebe9b7b62a87781649806ca98bff42c62f78180a903c63f0e7a365a7e2ef0dcbb332844c4ebe63d609850220b7f1db006f516418dc6244a7c5789998d6996dd0ccc86c8daa4b4f899bcd92efc9fc738f3dce06a45281f4924b48ec1f07bed8a8395b12566cbde4792903d30ad94f17d980ef6d02f43dc1c2e698a05d9f9e1e4589aeaff3d29821c19836cc2bb24dd9eeff4049a0817c293f09a5185aa5e1e9b38e0bebc571a6b592c93fe2d855a52c78fcbb839e7d2118db62087edda45f183f5e9c6be4d77be5a8c5d1864fcbf7686bed699ea451bade19b23728ef72d38dff6c33153f9ac264ddb58c8c91c30c60337f264f5b7af06b3a1579dc45d7be722e9867119b35a4f49c4b9e33ede3aae7d43c52db1643f9cb43475bdfe875dbfea9c014409015f0685c298d0900ba9e789e02a3a835f008b02fb0baaef14a8d2d21452b07f7e3ae828ddbc0627500a47e9cb15d293456d79910971a959452b0ecd31df524b729fc605d0ef8dc172f7d1e1f8e3a7ed505d8fcd46824382a3527ad66c28a2144dc7f02fc35f0ec0e6a3f5454ae9c249762045b644652463164a61365249298f8457bd3965899c513d0d691e7c639f27de4491b15fc3e16a3841f4fad9fe1449ae15a7d264eb505ad65b70080eb625a43bdc1be6ef3dafed67d7acbb75b6f91cec4e13a75f19b0b5915c1846ca583d496db93dda272972ec0d0681ad873598e0aead704034010fcafb2cd6907a9bcb7b83aa5256b7861aeb1d009290941c8dc2b97e09010b6780ef8122a60b533c01c160c07e61a1b2e1a1ab2ef25e7aeef9dfcba020420f80e857013cc79ad6fcd0cb1ffd0c2e8d26601f5fde8655f69e97e920c45cc12f7c645d52e5238a7aba89c9e081aa2684c3e3b669166607a345f85441ce0a13731b5e72ea6886a858bc96a67c5794c196beb3262f589043604bb1a13910962961e482fb74bb42fc9f7034ac2907668194c8176779c4a79cf8ec3cf69f116b3142bca2c814fcb9d85da1701a48d9412dd4caaddae79ba73482e1e9b260bd18f9566c96220fea216b590ee385797ea18926eec284bd51438ce155e46663f885d3cea557d417efa907477d1266850e68f8ca9ba9a6af61e47f9bb9b14bed3fa066b20b754211fee016e24cf58ac2c974f17a136191f305c1718fa65dc930d782cb4e354a8ae69fffcc30139bffa7804cf6495f44dc0d476c99af67af54ef9dcae136f2c60374bef964e03ff8c3202b1dd1a97049235d238c877ed95d070e766048fbef0f3a9831fe82b9de05a816aa82905e170250c0026eb744722e98538fae6f989a7decd6edd502f033f8b8092363caaf0ab8cf6259f80a5d9bb4a50d966f9d553f765c1aaa08e2b2745f2315946a64b15346bc5079ce9348b8609b61a151ea7739b3ffe9afe463d993e52343777d0156b7df981c461b319f4fe2f84b011f9d71bb1c29d804f46444864176ccca2f8ea5bb4af89c7c7a7eec98e10d6c4f714bdf5d6f61d0d8b461bfec81dc249d0ce28abc2c783f37780db6cdee3fd2ea3443774ae8bc1d9e118de2d6d5221022a37e93868fbf9133595cd72802472473bf9db2493d9beefad5a9c131487c6565bbd975c03403648bf11b2b8b174805ca38345b6309df013c49f23c2a1fd1b56259121082e357f80eac3c044a625ccd2b19ee950900a5d5dc084abac035caacea169bb66d118cae7313413e7213bcb771e648cc26b324f1562851467d33dd1c6e5169b1cc5819cb9fae8ed5907b94b21186cfb70b4eb48e343c4db2291ee97ecb6e0f3b073e4a831d2dec1d46bbc7d0813412a22ac37f979d6f8eafca586376371bc8a2bae046fedcbeb3cff74b2aadf95abbd7bfd289d3fce925d6abad5c27dd94a85585414010944354f3cc1d2cd8e1f8f2c4a0a0739d7f2a3f66e9d7df05f8ee71871e45dca36378911c452dd07a5e8a4d74cda0f14435ec9cd6c0a718a3b57795e09ad775e0a6c988aa9ee868b72a4ba1460f66709c2274e6ba727d717742043f715716e21e210b2fe769678b2ed843bd4ac8e647bca66bf091a97db4d71c59d64733f4fd6541a3a28d6e3840a7a7207f6b562e4fac47f8637e80725737485a9efdc64a163b83281040d4446ca62d1a9a3ecc87261d3dad508ed35776a02f89e2b34746aef9800ce718865449a88048f03bd3681ae04d7c40be95e81596371d9691210b87f532a4e752949039ea90b1823edc099e6864083bb5409ce5dfb8a82c4455260c6c0dda91ea372f4b136d5a6339eddb83246711c2ec86371d8cf5b85eae1658beb55f41422d33459c9faba33c77a4733b406f23f45bff809d300235546672378838a9cf440be3516c64678726732390113392993146fe277f1d6fe0b1c5dd1ecb5fd861f8d6e76bab5a1b7c03c1dedb35709553a53b3def5d1444ace59de3fdee0d7f4360d7f603573fcd0431ba43affa1e55470d0107a163b672faed9ea583f4a20d5267ffb8651b9358f08fb70c7323195d8c1fe3697a4dc15eb4cd841576f7ffa1334b89936376f2134929084d703c2fa91d40312d898aac962eae4165c5e3467fe2e6b73282ea29ecbeac2e2e8fc6e5f57614b16a8193e8e7715909d0649e6d1a898e60a9b58284e1ad7073b3fad9f80aa5f78477d605f5cfc3b5d3403150d6655a201fb63633bcfa842e22ddb093468ec787cbae76e709a439dc30fa1e8ec200b81caf99fe37e6f457b6420b46b6212c119d9ef153ed86e14042bd1c7e1df2035de4ecb62446bc6cb3be02ae827806bc2a167ba1d977b19100a50edb9108a59d8b01f4cb8b7b6d20857077ad0264e851ba0073058830f0bc9cccc2536b7df5a7bca1350b88b25767973b2bb52adc4dd4bb6a54dfc3cb4e11c8678afef4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
