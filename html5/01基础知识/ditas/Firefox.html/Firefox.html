<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd5749c5fac87e9d3cb3b0085038f4c5e7cc51bd8035fb368f131c1aa610c2f2e2f32212525edad517ca16e407beab3533b70e5ab8ba6258ac810a9adb04a30baa9af531373d9938506a4215589d1ef633cfb8026b8d8e08754a16f463321d874cfc0fbe8b8bb4acdc4e4ee93d0746ba2f98644ae7d2e9fc6de601846994790235c5c7a7381d262132eeec92e3843b6fe684104b9ef8e25e780ae13ca5287e0342cbd56ee455c96e2fa8ddef5c9956da14ebd7e5e7fede739ccf58244d9e8386fb93ee69b71461cd75f629cc7b7388dd559290cf9e73a362335f6e2d415cc21a9dbd092cb2b4fc4300415182d5bac48d265294795111ca6e7a98e71e6c2d8234b49cbcefaf5175f4e4bac28d4881b240192251e2f67d8da5f813918eb23e0f6974327f9ddf075c8855180c4dc1ec21dda28e6d0e2c8be3eb0837374c6b0cebaee213db86237b177aeae76d87a9bd426664ff78b160134ac0f266d021bedecc3e05a29f2c73bfd893b92b092993a1a617cc61c6ece5001eb8092d743de7c0c59e73be1f0646a1bbebb3ace5441ec7301285021e2c5485167dade3fe38dd71fd41107c8caefcd50157d5212080fba7a3f54af2ababed93b88734d50839d4777d3d4f9bd364fbc6249e713261bbcb1f9ab51050a1e6b3589ae2da92316bdf727ca83670781196c81cdf724f957bff3c78c24d53a25f90b45a5549becf9fa4052b2180aca13df16fa3f01d02c1385668a4d0117778fe03bf9e7040bda6bdd2e6a4f1ae1cd778e3d1e1a5f1aa13a6d7b45aaac6dab5a1e7fcca56d94d1b6a740b929b0bb7a3516ae89b58782c089f87135b957a8ec421a417aeb727867a99eed4b93a65ab07366ff6b109800d64a189614d926c57c07f88b9fc9742a50d0e10f8f05d4aa949a3a1aab6e9cebb17f50fa778c6daa83d579bb001861b4d92bd700d186502f1bffe0ae39a6a5b57f2abd2a8545ce1e806335ffa0dc0299e083700b6c335b1ccc3302b1f6f20569589eaa9caaad84a2601a9a23395fb540a7fa4face2d21145f6bd4b142b1bc416ee47c4b573b56e2b9f9890830e28295bdcfe8800c5c9f832b126c0068ec9cbb08b932d1da71ca34d51875a24b8a8dfc5edc6ff7b1ecc99bc0d9b51d6f9277b6d3c655f02119df0dfa012e7a9abdf672faa4d98bbec19c1b9d6c6de7c91fe6b82f247a5d8821e0519f36e4c04b65d5904be9a3c62834f086497bbe57caf0d24fa0f378801622a644dbb00f195233b4b120b6828b6b47768bd44ffcb930f2e8040ca3114b7938c51384500cc459f1685dd9ccc0425476e652e23caeedb78d5e953011f061d7613c5886cd096880ad73393dade012c939cc2c25b03464102c2e294956b0c16a487fb26fd9fa7dca32093219cd8915bdcfdb13ce143dd5a36e7534ff0a24e7e6067398a6d3edc32408e4abc47b001643634283b1ab4c4da5837a575fc0afd845d241d9b2dfc5c57d5a5255dc95a4dca1e9721fe1f9bfe2eec6c9f35a3cce2fae766935a18bdbdc0f3dac38dcc93dfcc384aa36b2dfb997197a1cf0d7427857b17d81df7d62aa3e2f4025c1b8b7ce820b5ff0854fb88791b016e0ee471d91857fd29a790e773ef648d61767b51fbefff5cadd57aeb73889fd83f591b27d743534a890cb158e262b3791bf38074f84c627b5c4fc542cbe4d131ccfffdadd97334ff47a668737c1ea9719b69166d5b187a7488926c9eba78924f919bbf9a88632ddd6027efa4062a9aac5577ec3c0186f5c8a50e21f5aeb11aff44976a55a2b2fe1bb57abe963465ac52087e937e780fa92fd73c87bf6f6abd825e0e5a7546eec5f7cc300816579837733b89298bdd56a00d00c181119e106c0638b64dad8c09f6613c2cba6b4ae803d3ea8b0cc980b228ae0d0af097766ce5bf2cc8d82fa4056fa8fcaa6f1e2d01ff1d23bfcf9475dd1dbd7916a8d759f29d34eb14e2da861ef86e13d744443b675241a314160e67d91db367af4ecf380e09db02ec866b6497bb9c04013e00eda47544c31b30cd0da4cb95ddd8a6ff3853011f84806190111177ec7c4a5ad084e7ecd47a5d6f59260b5aceae1b2b24969801fd6a3efe7078302de1cd3f6ccdc2cb237db71fedcd4470465bc26365ecdcd150d1d0fb4092ade7253fe0432de8dca35ec36315f9556fb90acc550b5a935a5d5721748659aab3a5fcf1cacec8e38da60c946b803a7c4f3ada0a292075c892bc2c4ecd4ef544d82de7faeb6edabcc599064fa37f464aba31c5a5c7f9ebe49d5ecf1041bba585e9c55a99ef87cd8183bb36072deeace7d8c996e0e486ef450caee53ba3500c47fdfb568757f373d0033cd7a9452fd77f4395cecc9bbc21580d9e0a163aae0185524ef6833b2ce3b2015493df26f5ee29e8b54841bd7a8c50f4e0b6a9cc4bdd9ac3144577da38aad809ab730e3fd5ecd0a639c8d01a22b4f1af0a5ba4859a6748220a37e339355735490e69776c25f5198a532e44abe78b2975935e1d55186e127c61ccc7fccec536d69153a4b3194b4a17c8cc8d83e2e57cba97f55605cda7865de3d65c4d3b123ca50b0c520f355c70383394a0f3862268cfea27c1a8edc59ebdc3a14663ae4c2a0b0a1ceae4bef812764de8ac31c5d2634ec143d3b95f3ec8f6dce42add54eb19e800ed2a663deb174e40e0a071beb2c916fa188d60c2d713fefce2e584e388f1ce9d6223104bfbdc31fe2049eddd30b2d99241c1b82c3357507b7cda3a04be7d08ca0db2de7930bc4682f9e9ad5b8a23e98f64e2164a67dd38191f06fd5be22af5a3374910e929323aa30ee5fb95c81b9179b1b337d307cb3445cc7757c654c2dd39090d1fd8238b2809ec2aa58a155512819bc28df9298c58c9ed032aaeee7b59aa00a262cecd31c4ebcc8b93d22e3949c18c16682fad2cb3c5ebbca1a54e651fe60f74f88b563b98dc73987bf7866f670adfe3d4aa910c9b9f7d470e3dcb48f6f7fd05dcb306c285d67c76b136f03c94e4f68abb3dde94c95625e015091e0cf48e23787a9dd213afa45a3f21925ee89d17f34040cbe4312388cd576a098c9caf6138b3d54d404860de48d7a550ee28d9a906ac280947dc5e9db9ef49da5b5399c89c891001d23d70b2b7d788881d9bd2ff3b1edb8711e61d4bbddfc8e6df2ed0daf23bde1eaa3a35fe4a0c1203fdc25af29bb117fc192c0f17557423de936b5318b07aa88ede9d0673a9349a2d0a0e3b8ea48ed0b1422cdc82d546f53085fd8608c0aa0e96684207451cf424a7d6779d77d8f21e35f85e57a033927e49b8599c38740b3d3c5179e6d4d9d985bdd133c24add33e431ac5fdc9d93d4dc2735f117b179ff66ad411beacaa83652bd4ea91c5f133e35a16d38b3a70d57f835cc890f77a8c90b14886d0b1e3a7af1090c010b570b9cfc1b51a0d96a9c0195faab7b6900c089cd122635334efd6466f4be4e57f7095af4e3079c8fd05589d34c0942439676a7e9a12b743010ec5c007dae6941dff2e0cfa1f7a5716994d58fee66b69fa3d84ce601a6b08ad10f0e690c85d0b7a6708bbf5ab09c4b5b362a6f983dac7c63dabbe2888fc9755af6ce562cc0ba9b5c5a2f4efd60f0f838da632a010aaaedac10bd9f55372e26c042a5fa5fee28d9836618e9fdc4ee571e7462d8e14fda469e54ea3fc26e9283109cee75f22be2018fb2178b3c31d121e9afbb47205fae8a05802a3c86caff06d26bb7f3793e78b51f37be5c8a9415ca6be63bbafc70e88535cecf145ff134bce391e727097310ea53f24197ce05a95bf4226730760d03c15eb6c3a3d2c8c82af1b2b92bf27dc3447eb938da2035221e9ed54f5b90d9190d10a51bf7fafb4dd848df8f381dab73722cd430f176877f2b499e1bbf821247a3901c25a3e802990c7f97deb8c3e29842c4058ee7c734d0eb4cfe0c812711e829db566a6549e8c8a03ccf31c6ca05a7f685ace3ed15f78b2200b3bb042db39530c4cc4839e5062719b6e92f30c7837dfcfbc68456582cd971b4fb16cb75c07960a78c6fe2841ba17d228ac0030d358aae6786c297cb0d22c3b136b0a33bb2690a9fbf614134a631d5d8f638e9d651a2171ce8124e1fb7b9c3064abb735df5107520f073e872b65a09c0d15e56fd636824becb4484836a543b97816a8c9d9096a394f271fa561bbf24ffce65a362635aeca8b88088215a89808f9460f17f67f3bc8bf0a77c41b60756e18fbbc20547e005ea2f5ddaddaa0a51c4b5ecf6d65e56130eb0bad45ae7a8acccd01afb52f04e6bd73a9f4ad41551c4ef9b4b83fe377a7f735e690c5c9b93f36f00788d1a4d38f6a128645bf42e6a3be8375e8af64bbf3a6c8f33ba9367b345c7cfb2329d8833afe558ad35ff96347a11e23044a64306810064a0fd39b7015cc3fe93cf746338f72aa1d66bcf2f7ba30c6e90f78b0baef3a0bfcb38bb395828226c8c5c13777aaa950ef51d4b226ad04325d52d8c7a517bdff5f0dddbad63b10762b495f6e10d768b9e1e1dc76c08afdd1d2620860c456dd0024f5a05c29937c0a848b7cf9de50777c76e27ea53e7f36740e7c6d0de0011d966de26602a30289d11bf97aa347aff1057cc1966a07d46503dff2b8f1338d3193b4176e8ce2262972d17315aa60b87a394dcbb33bdf3de64a67e9890b7bac0952427dbbb44996a1f5cbd8be791b1990a3072af6a77b1fdf63ad7d1c4cc70bb39c2fd344c64326e1a8e6e9ae862f93a4fe7666f4d12eb1487183b7d15a036c53002510739ae87b92be50208b52a2787d2a56081e84b9c52789d9f52a3c19db4d8ac673767e2a0889ac4c870a9d49c5c93179dde966ec61cee39a98bdea0d1fa0e6502520b01c0decc31ac4326615aad494504e913fe60e7fa947d4d787da6959fb11fd492acc9aa10515121d84ef923a04a5a07c5aa663343b4120df5b819e9d6e0e7deaa1306f714b4f55173e2ff078e3c48e44e500a3ca1bde2d9564ed204444c8ce9ca48250baf012bb7681002733908c4d73f56346dd191c58bcb142963d7fbe492c5c50049726a9d25aa2547acf4a9c5f1d0a4854d2a38a5d59680592ee18986c6b6fb8de44d6bb41c5a6e1112174b14310084a930dae22ae06093c814b05438bff5b3dd37f2d6d79c0b5a3e527cb77de67673901efa1728eb17ed763bb60971a1336ecd655dca5551b16cb32a4b3cc768c9feb5882bc1af11950db92cfa6e6fa25df6447826d9754342a82b150cf466cc9bb3acdb8d196c9e38ec56fc9b620fba441870eabc8cfc07448a2238d9be2dbdadd1e11b7aa4db9958d71fe0727daa59439e8496f352ca33ef797f4baf9d2e7453a677740aef6e0aca1630a69d681ba834ed130c8f553bec60dde120b5f65c615d376216e1361e14db1c4f2b2c49a156f1521e9c0cfaa038736bd9e311a615dfe0f494d6ddf5f5b37b51aabffdfe4132b29797d2b5c106394755378a1b870d236fa1a8b37c9dc0b8f71dd5274d9ec16aa7e13512c31653713ed145247fe393fd7a8fdf3827beb1f4ea814ce9f1a43b5ee80d522cb70c99144ca106f5f4fe60e50981e4a4cc490220baf80a7e3c0b507a869410e4e34ec2583a1e55da3feab1a2fb43c5710e3e135548f31d90bf40fd6fc4d953f56b9f8d7152881331c920cfbd70fc0f251f50c4c09ff9eac8468fad35214d428fa740862c60706416e6f2c009527f52bb98b9cbfe910291800910f9db2fc672c2350bd1ff1c6342139659b249138536f06ab2995a258f654b6d97786c7b83a115ecd41447f188c8f3ae9fd978b3f42ca2283313a0681be0ec88780f147c655b97dca5084942254080163e2410ec05a529d7a0d0c8594fecd98825f7645926e0e64ad4f89267fa055f01baa01f02560be9df4d22038a65c2aa1cb766a8ad1c170c70b81f5c15bb24f6aa4f96800c550ffa2fcbf0635c8420a1fdc6e41549498ca6f07eb6a797d5a5c1d03cde25e9dcaebfe64e9580c571ddbedb3f1c2bcf2e4605cba32397f560c9d17a95fed197311122b5e0df4e08cee4ddd23e5f2a3d5d6cf97647269b7bef56580b4ed0ddf59b3630ef5b455d299a2c7b454dc3c7e5b4842c06f7a6c5f29c7c4f18fa14047c7b707055b4b5a2a58de0c6dd211181b4c0ca70f0c68b24ed8b572945acd7a7600d53f399bd1c1489d4ebedf1d4081b1d6178f8cd0e8ca4c01a9ab79c061f08e63dce82271c58bd4265dae1efa1de74d63ed3a6692b48c48c73059e37943f7a4f419183b3ed198807eb15cf56c546de404e37f9a662131878fe4e2c55fd3d5096b4e8b5a26baa20818fa78c9acdf81ecf62f83c92d6bc9bd4ba98d241ed151204b28f2e746e8ed1765430d3ce5a3490d8738b4789470f02cb9003b45a5d6ee45c086cb76537a535f07e1153623b5c73f16c5150e2aa5074241b959175c68db5196f5b1f8220f9e68a32823619a23b28eb32c17c79472bb21c6cf68dcf76df04db674603e946611043be92383b35bc152b721e9eec84571db92d86199d592f318133ecfeeb210335069a7305a0b026f2c0694dd4f76265a9f3c965d15fe1251044a2475d93bd75d0f823b708ad019f8c78e482df7f4997a4244b7f43b5009b5ede781966b537edc555d150c2f24f05345ab6c908cf0f4d8b3f1d76d3f6be0a864828aa506fdcdd88c47e127cc28517392728d26620271cb756aa1b7242aa73545f9e32e92c538b69c8340492167087589ab4b0ba0de491abbc507b68cbca94eeda0270b98ede1610346ee4a5f45c822473a7f1912d5b5b4551ddc30c1a3f01ce446260936df3dc33fd7adfb17ffcbd7d84c1381bad90f5cf2925e5de81b9ea10e948866f1f50198f644409bf5a990a58e4634ef375ead18d0108a7e72c0b5916b616401a2c56d32d4d3b04b560eb55a338b20f4f88778922efdf7ff15e7e8b8319d16d4db14b5fa1518900874e2e9e0184cdf9a421d7695f266cdb893e61cd97f6d88aaa831fab2fcabdb05212b8ceb84f3c55a76ff32417e05080abf3bd92a204c6d46c7f5d60693d5c7adcfe245b6f55e972d33da1c107de81a6a28f08f5126cc9a407920340be760f8a7ed24824080facc890f1cd49882e515eb0a67983d275d3d665c7c3528ce02620f24044cad0db04e82a24470d665f55a03c9c793b3857dbeb84e050c1a51b553cc0a1b4beae2155b1b495c579696ae147bc8a33320e0355cedb3de6fc863ca1df3cbe12fe3dbf76f0e6e6a6e5f960f59a9d310c0795b0265713e9eafc64fa9f78ff90bfc0da596a8dd413c4469cc6305b5a60448952867dca7946f52602be653f9f9403280b98fb7a4f90d68e233ef25b2dac20810457ebdbba859df7ba4c86f895ad2f7f23b1d899703bd88684cfecc5839ecf8a0181cbbfc13b65529dbda89c7660e96e5ddf2fd64b127162eb2ab9f08a52b88c3b1b7c3cb1963fc4c8897eaceb51346a7a6815952fccca9aaabbfcd9ba56f299f27e84a92119c12c1dfeafa7acafbd02e0c5e68c554d65b20542b3b4bf75bb56c904c031ff3c2adb37febd01f91565b3bae9c6361c867ba0d16ecb48982b816e0629d7fe96b8175f9736e6c7bb7724c553443c90ee127f0275ae9680965124e5a2e0ca9b2303ae77ee50f6191480187fdf7d1555ae7d60154cfb87dd7f3ee8aca809d78e7357c33b5f13057c9062b3d71772ad3be8b4d4cc2657cdd128c469c0c0224435ce8f717d0ba155df46b50aca603412111af7a3d527a6e1245eaad0be43211d210ec6a1c7925803fb9a2f51dfa44c3a46685890155a84b64985611c10d0c54b40304cfb1d648fcc94d677b3d57baf5c0db1639a192d8421b43d25d4a2c121c2ce3db2c6239dee9899c52bae2717d0cc8de443fe5946bd0f0250c80d965da91e5ec347bd76be59f932a73d089b426586f0a26c247b687bb02e24dc268f2a159ab27e18093a0e3d61df75259b621cf2d50acafa32a74971c51b803056d3a4c0b020927c169547c9e938ee857e8aa3a6b4dc886842a2031611aea5c661f0fdde24d0d21d81ed8da4503528f3bf443c2aca30d79b46d0b25f2a900852f861783d42f698eac519ba658f1fd002382ae71dd06c0e3709b12685babd142e9b7dbd83dda20f32c090d1f23cf93949955cfefdf92712c5e804def836144ddfe4e026663e7515c32c591e2d09edce021ceb8c0e95e342cbaca267690cc15217c8ec169ee7c2da69113149cfe3eab5a879e9305d3588c3138f6f83761d1baa42158496ee9bc8907a23a52895b06b1294d64fff0982e42a89ff053dba225c298c5c98e2a2e0faedac1a5aa08e354f4ab29b2d163b7426ee2be04f8d202be1951ce9c95927539e96e78de9aa04a0ec62fd79388adcb5c779df7a6d19b09e767023f6d1bd71733bc38c848c6531c2782f431c568ffc39c85c25563a4ebaafee3a36f0dc2fd20d2681c23dc9e85054784b5451d5405e2f2253e50e1e2f9ff16102b5ebd6ed75985aea579191a9427c4a358cb31036b54bd3829ad203855aa80471cb7faa21815f6558a4bac5482d6d80e18f8b82e633691a446930a2b472a0210d03bc54bcda9d91255003184bff1a08d8698105f613d568436b8b80768f0fe90f516d7435cee984c576dad22c66d1b45344f206f4091a8b17ba5f5d8603417372a80611fea3002f5db221dd8770ad11dd27a5418416f248192eee77b461052ef01550e137eafa024ee586b599ebb29588379636e67ae445d3e3b3020a63cd290fd0de11296822ecb992b254fa87a8fb64d5156ef799a3673dd17707546c8bade58d89928f849b12e113f6bab7db4c6e18684e3759e79372d0ea83979487187a3c2cac4b744c2eb3a03e7ba0073bed9d3d73275238ddf949e422c1751baef5e1544915891cb7f60443f2c1e81ec4181da0cc362b6e715b1d336c8257aeb0a58f3c6af8df8131ce6b84d1e72dfe42c11466ad499767ba49b057f99eea2e216bf41243595ec11ae3091f44bf21be629869db76f9134fc483b7a785115d339a1c986b99198780c7d96140618751435c1ff2e06a98e529061a150cdd130c15e866ad54ba79605b6cefbd92fb26bcce498a12f6cc9034df4fff7f0c6919706e0d0cd8481f8dd0c5851a3dabba3fe69c84421c95a63a9d4b864f5928607f3cdcd9f931e55e592df0d81eb385ff0994b0832f476ffac660e3d62b4b278b391cf7a02ffabf4f3b6ebaf981d5850499e1a0fcfbf4e76524c2b6b1abe7e2dc7d8375f036d07f5d13e261f4b8b532ab74ad7921329cb26e67f7ef0c1d0fb44d03f30c1b8e31ceb12c6768c96be82ce9cf861804e61d13b8e8dae8e4b43c82f9bf97bf8945fd1e6e1e3911b3647fc907404f71f79f5f4c08231b0404e8595e1cffe6cb9d42a10bb20433624de52408a8b8bf485b51110dd5944893fe3621cb6742c41f5f2f4937c3e162677baeaf2571459b0c299decee1251d45daf53d07b382a14f2047014da79906ae27f3e7555266db614b2bc6b11e8225fb3b3061b8cac288c253e11462f2e15eebf1675cf821f0cf3523c4d2f787e21190c7cc4a0f915566fdfd100e478bb41894dc2718c49b1dfe439bb9b0263e29fbfa4cb45662ae5adc5ee83ee375d7c7a6ea75f608d3cd411702942c5cc55960a215463db0458eaae3562b57a7dfae7b16325ecedea2db16b730dbacec67e3d36fb11f70301729d7881ed7dd424141bd91f0ea9bd534988fd66472f312dd114cb7791464f52d1b5b0ad97cccf982347be0ba1a2e92319896c3a8b0d2e2d04c59400ad05d272be905d15a85565d56408950da29b38360e23ff302d24b38de3c10daaab43358f34756471f863f4582f9162f63cd81f06c412d9a775276c2a43288d3c421488d69156efcb334a66c886438f22eecfd3b34bf37bc03d5aa43e3a4bf9cae3ffea8e620433e7a4970dc617b1f77d09699394937ef2a027444c0edb779638a6a13f763a5132797f91930238f1806b9cadaaa9ebff438472728ebc40949098825089bbf54ae9e68c3a501492b9eac683d47963a88e61949843d6cae23668e192e9ef489f4be195bca15703c778b483d6971b91cd52e55dc62f78589e3dc64c535df8582242a6fb4dd3f5187744ebf1d345698b64644253c24696461d755c6f2363ee6c2265e58cfdc3ea0674dc630b3e4af9a52d58a849f87e9c3373f74ebd990dadb7b9d73c170121fdfc2d6ed4fe8518f66fad1d462674c82f3cd36aed22c2e88d5025f23128c549cc32c13b32b9ce2bf476933f5e9c57fd868b9ba7052716ac6edca166e185b94a06b94f835e2b2e9a6744b3edd03a4cd3c89e95faed7fcecbfe0e016eac7c61b2c7435b71259ca43dd1d6cac12873813337ff9d6931a6c329ef170f2ccdee7bd9b1c828105c2046947bec0e8323644c684aa03312c27cd56854b927933461e2a1fdcf4b6bf64bd01ee949b6b5f998f426320df584d885556517e63e1ea301598732c6aa7d2290c440f87b07ea6a09a5d44ca9edf7b7b43a2aa089042f58d9209d9d3fa946a9fcf466a8ce6ac38e286a1651322626d04aabb1994fdde74475b8bea1a1dca0bef9dbc94d8ef844312f13cbc4922c7c4659cfc202479744f6bf6f341ef159f5c99fc4eba27c93839f8bdb4fe3e71f1f22dc89c36f618ae35362f9d8e9de5f7b20553777b9e6f434b950a65e04e6ce95f75059473b914325053929f09c6e244cb09cf023480552f7041c8204e51aab92742672ccb3f1a25c887a0b6094f8da05a058f286cbd548ef9eb6f21ff286223167048f5d5b94240ab56f1bad7dcb7d96ff83decb1996d54650c5f8c173e5f382ccc1cacbbffb40446b77a17e192fb81a45e902341d7e0977ef188a23bac7ae93d588d1d5c3b8a0230b9f200e6bff98aba27dc3b4d302d7eb646fc0a224fd83f5ef17bb7617165377a8d2d6626a17c85bb1cb1653db9d59c63f0592ce37133979e7af563c438d7c911b3fd11ebe81d9442e089574f27823d70edeb881ee68a972b2697e01c33b60564cc202f1034edef86ff2fa8ae0c2ebb038e7955959382fa90de2042abaf7efe9fa9b188e60c29f42876c634922916eeac70e68ff9643ff401472ce45f90e3c2e498c14a3e9eaa53e27d1dc0da90794ccff7689d05323fbdf72293f8def1ee18d6d7e25316bb80ce25c76ac2820e1993a06c1e33bd8ad9dcccb76dc237f02a5108fe6cf3053c1d71ed3717b9d66b8774743ebba4785000a4cfe31d2b551a5570a07bc101627938caa91eae80f47fc7dfcc4fd0a26d0665650da0b7d324ad2a171ee064cc71aec5620580695c20ba5bce67a292f911a5245e19a75ac219c94022aa5077b87a23c0c699b55e3e08f190ae13690c87cd94ac8c60d3469368359d24c672cdf38eeb4046b39dbb6302c2a89fc1a17323ccc69591af4bfa35b045739a88fd4b178f9633e7c8f99f78d1751727440cb21959696d6229b223a04106a5e6060fcc1f50dff6d20de607c37bf685a9bbea1dce99ab4ef0d18c2679e7b9e177aba04c2257dd2595f489408a642311090114d414d50e13eb56ae68da80c94818e8431f0da67d50f65cbcf4cdf11661581cf0fdce14db5e79ce0663fe83a5236cbc1e6ce042e8db9e1e9491ccf32d063d4cc601c6c03d93a660c42cbbb71bdeb15921817f85cf1baf0ee5c99f218c706e0bdc2a7f3f0653eef12d79a84ee5a2b90f68ffe61545580dd5963afabdb5d22630d8ec507e846854c951e5f7d27497ccbb5c36514d700bac38c4b694f2745747fae6ee2b2dd8507415a49b84e793600aae6663166cfd098abf8fe1e95315a93c0e4e94b62010b6cc3a4228e7bc88a863ab472b2a319ec3705236d2cd48abe95bffa8dce8032df3604996fef001bcad7baf150eaadaf633a071c8ab4c8da497967fd3b24014362b5bc171f0e877c691e4cb80048e1d1b62dc9f39c7081337987c7c43da939616fd52cda0ce1c381b0a323e03aa42a58aa61bb82f5475360a2cde107325ff0db6b66c9401cf55cf516ed4b954542ae042d05e105c9469898f1fd9d9fea8bcd4abf0555897d3c79bebee830f13c6699ed09d011424b76fb01643c5b4388cc45d48315998f7cfe5b582479e013cb95880913965b816c39f4218b8e7643e583b59b93999293bf2c91759e87721694faa69abdca741a3f5d0c0f59951f362b23e0d7c2815f4847ab925f85af48e3d27ea01d7e3da53c214c7f9e6769b6f0d350713e8fd6090e897a95b35d2eef696cfd166438e929beb988e0ceafb05dcf6465a7e929767679680150a96772b5cd94346909905b464b61987c2ace388cff610f5efbbd344027b7fa6b4b2b1aa3c12a2cf508afd4cfe6fcef4211154d9e010ed8150548823a48e8a22abbde3e95a5aea20c13bc066dbec09eb1ea4c9eb9a064301436cc926310edf5a5cbdce8d4d52ce377ab3ce1e97235b7b94c5b273eb5130b4d9b4b6855fe73047f0ff669e5237ab0751ac356b4403b15664084a5360d5d95050d3efacc6286977bfe333c9feaf4ce1a2123ffc61425c0ca872d8c3278a009141c03e9328eab4b56f1f7844184d62c2cbd27c6a9017854fa161f5ec00a50b6b759c916f23eb6c3ae93d21666474e5de7a50134e33ddbc24ea735eecbc5af099b5bdd65336030c17bed5a79a014b99e88c643c31dbbd70d8f0591308529ec8c874557374f23129ecec87a69deef147add28f700e675bb1fce782e42adc72adb1a901cf364c730c23c73b986c809dde05ecc2224cbd271828dbea7f8a6acc43a417a9152aeed186e252ff52e75bbbdef55ffb16986527a07e446d6a34a25828b0230e3cdce7c3399770348b6a950a30f8fc10bebc7f02c0f7c9b199aa292ed354ad1a1a188f78d927297edd8bfa4ad0a84163e48c82a7358765c4b5b51c271d1ecc2c33334108fc384d007f72d53950c504bae270b86635020f1866cfae5f5e1b75f5cc4324953259b705919fdac8764a407e0256cc725c35941f063d3718d86dd60c15a106a09310fde994fb11841352a8f16bae76c88d6267100222969df0f878e299c2bf8ddab7a13e35b1f68836ccea43f403cadf99c96ca7a4646791da3e40929013cdd6084ed8ecc6d2dc8ad3b76f14cf0423e4069e8fc866b13605ab7967069598887d736ba9546128c70dbf1c1abe33d1b7118f037dda43a6b5010d277286d1a9125e89f2d4f2f937aaf6c7249db69a20a09703841ac6a402b54f3f77531758ba08993dd3250933e8dc09fa84d85566707cf56a943ebd14196c004bafd314e1fb5a7009075781eb10fe429ac5328bca7934715090fa0eba4f3a5fa29e65d950b82115cd1cf1969a87172e0252fcd0f624a48577c27b35ae88cc86e337c7c84b3dd63cf084afbccb4e3b1878759541d8b3577d5efca349560d9133aa6f9a0037099618be406734db261b415d389dbf9821ed98981a920654ce4fc926ea16edacaba46556b71cd5cb885a6c486bbd1e0e1f773a2e7f73792a313362ccb3760860768e3eb6563c1808f716051ab47b04e843893fdc017f203c255e4f22710ad8e1e0de862ff979a66115f3cf36eefef134e6159af9c6e8be5b367a65ed76f6cca1071a94d05b539ac9759b6b9717313478828478f7f507f04ba989166cf297fc00ab7f569c102c53b4cdd765f49483bf30d9dd16d567aecb1cbdc3a78113017648a26953171cd936861369975192078eb5c4988b9ca5a28513c932a185e2f2c652f3e088b43bbeecf7865d5e216f14e72bcfd94e6dc9731d482a26995375","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
