<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd452d5ea79b74f7031d6a25852766022ce54bb07ee04214fc6f0515301cdafffbc300dd34ebdabbf4ddf01c222431a20d8b0eb8edc09976318d3d7a89fc238c8a30579c58638111f8dc239187ea7531a4ecdd183574697364f9adb373d174631b067483c8bd579d6defc48c22d1f826083f28df16eabaaeb016594c2b70a789af0c880a9632ac130ef2aebe6c85d597b9958c94de6773343ef4223a2194b48f342d895377e1bd92dd42275242a7d0a001da3179315e9e2f066b8967484983451de160985c595c76f63d009be02e17f0824e047fc9670a9245536bd99a877e6b25307cf83283195da82ca89b124fb867cfc20638fc650959e5bd03d2a1ed28f51d5aa84e40396370143b64c67bb979709dfa4d8d2bfcb9d0a4413007ea2e405d6a6fe6ae655fb3c3bf7a178ee90d2fec67967c152f100b4309b94aa88c971a87bd322d6a11984386d0a397510dbfc106e4626eee02d125f693e12b037824f48786585527c27b4117ec2fa67d4e90d3ac291ac5ff64ab3f0bfdbd2dc8ba3966349d4d24e53191eb2e12dd56bbdb22522df4356f239662e23b083efb970be4d1ffbb4311820abd0df5aab62bda948b23c6941886f752d2c94c0d9264c03093d51c630c0bf2b827660fb03a5aacbe6222ab0e6b3b0f228a5f18da6b40dfa85e36534da9c7d36ce3729bb3e65e9ea8fece1f0787be1e2527bd28df47bbb216823efcb07bd93a6889042c787c50b4dfc6449b57363d899c960a568df1bd4b8bc3329d4853580f60e77101b84aabe3bf21101f69362262bece01a7b019f138332e9b028a895d6906f8afc08132bbdf68fcbe1cada745385055004c74cd1365bb8b2ee0f8ed3d9e78f664772928dc71b9d6a73fe9884afb234ab894e102a017494b41e0af068ca8ec4e3e0594167da29bb5195ad8fc2f1d55c1c61c3550e95c9c792de44cbcc05da6f4e706697f043df8a7ec44515b6b2c4f5bba7d6122e56e1c5d5e7d1ca9faa402a98d93858473c36277901e71dfea48d80dc5c02e6085a9b5cf5bf077b9d7871709f983e6b7ee22f7349be9af80724f7dc13cae8b7d4ca70df3cfe32a694cfa68f89d77c219a4b36acef77e8f976537c26b813d7249bf1a48597c24503e7d7768920ea8a096134e87199c864a8cfa550fa9430f9898f12f66a9603ab2ce657d1e8c88bccbed2cf9587e1269cea1c5c532917432a8e35b1efa81520f7b33ddf4e10a0fcce32996a7bfe81d5fbbeef1d73bfb884d46b7cf911c6442679d4dfcc491e62a25ff870ce3a034ea3e2f900cec3be1a886524340634725a18aefbfc0dd5ad7a912078408afe14636827a1b8fc9374f5538ace25da067da8bb69484801b93487e81c1a64cf5e8ed74f85927bf01897751d9b2c8b0ec880b2dbe31feadb38309a897d762a982b3f36d993be17aea57848000e1ba48a06cf55d3879ba82a5fbbfcc68f78c759cb1f1fdd48573d905cbce73734ff3cdf4301a169ba0a0148d02b445f7caf7e10090d96312219d1688f9beaec78194f4b404f97aae7317687b30ed9638af70f32077623fdacc3b3af6bf39bd0cf436bc1353c7a9323a20d5e770b763ce729610e2890aba486fac060561a92b58efba5e4fcc091063e60f39370b1bf9449828df77b216ebd019339d8358326e7e7bbde876429a448f90dea588b6ede41a229e1ae3f750d9a904b48b6e258b5d7ff8822115200e518a945043ad5a85c2d0e592447af8abdcb8aab43a16889a762a06324a4cab74a1f94c8321ce0a6be210dccdda67a6b6faa162f532cf59d2d0c9a4e3b9a8ed40e6011ff5910394ab22c16a524930df0d2bd4ccf577150f8b9734c0866d2a48fff4cb7f2f3462916c416e9e22c7fecf0e2bb1a2e0192fbb5ad4f60cee6e6c683953cb73e81e9073debfb8c609fec7f9b1f7b9992de9cdb0b52aeb09528d223c7f74542ac0f04460037172bdab21ce1c600c1a41e4cfba85fec9ae3a511a6b39a9eb79466a84a8056f38b268ae03c3e089bc583a39d00ab8593ea0e89a2778a73267a5a5d84cea69a28764246217c929029349243bddcee9850f8c33af013f0591f63345330b8dbcb7bbaad3e6d819b3bccd7fe74bc1661348da23e592d010543f8df31e4efdebd1d1f45a39a7a46b38d6b357d27d488cb843f263d5dc6ba62b8cb8bdfce41c122e9103ae3b944819f7fe935f98ca2c6ba8f0f66e92e117d70cd8ee68a426459125d7e357aafe7e83ad3d223e6905b2f679fd42e00a84294516c99b8ccb11ae66bd17be097ddc70591e8bce94a22c73c2a3df567cef7a7cbed928c82edea37cbe004f72131129cffb818216d174df41ee09783e610dae28fad6f3f636b97b5ea998d85f106554302ed37bbb21afa7fc0b416e0fcb40aeb34774b6655f767cf93d435728bd0919e8692171370d66bd76302175c173f4cbfac21ee1a2f122d442cff5fbeb85fa42749484af857e51ea2a85d1dc1e876c51adf1340f2c11ba3f6b3b003d5029b47bd87f317aa55e3f1e1fec85a4bc2553ed79ab22b66f49919a83778788cfa013491a1ce6ba2c12e4ad2e793c6196941adf433bd1700edc9290b1dd985dc5b4032e6ff8bc56bffabd8d5593eb0f75c7ed42c0437cda077cb3420c3282d094a6279f81693dd08a1743c9255ae49911853f908e5c0814f541dfd4cfdd66c32a671d28f6fd4d4a003a7bafb14a99ed4da3095d23ccc75f8219058c0bf9fa84e41c7ffa39d46fa9850477b1a420802e01f21b69cfa5c74323b3619082ba11c641206bea184e137b61a8017464f808ae9677016ab7ac247e5555698eded64a5c2edbf0dba4c6d0bf74ae4f78aaa2075db2de16f99bd3d07469a9a0c4ae460ffbb8a601471b0c25a898ff6e7f5b959d5b1bc1e3d6bdadee7cc9b2f4cf8ca8117a5f31eaeed2dacdec87f0690ab646b0da543cddada501b532946a8f5c0ee9ac92ccbcbc78fd22e04c2d8177dadfb419b94dfa3186bbcbbda322279d8248fc4515a57f6bc4403f344098e15d9734d4cef29d54c7b6dd486692fdade1e361c1280c4e88baeba56cc9fb797707d4a6ec93aa02e2597a3593dc1f67829f5647f688f1547a76a3eed6ae2ec36f7cc28fab93b451c886469eece785c1e5d985ba98f6c552a89bd91cf56eb060101e049a67986d460351ad3df0a18aa1b9e23f5b99ff8bd29dd32904b788d5984630455be09ff6b06715b49be31344542fc38677b61011d786d22edf2dd89251fd05b3cef6a03dcb43965d2f42f2f9699cbc59cdf206b4e4ee41a39ab1f9e37d38f5815b95ed69c582862131541b0994c19f53abb493d7d0a1ec63a24d89f9833284aec7cb096e36cda7d5dce6519aa7b3b53aea94c6cf6ebe3d9d2cd9b682d8a12adbc0f5d0469b59cff84b00839e1d2c9780bd186a700d8cb46bd23927557ab65967e092bc864131f121b19b78c28248b68d153eee3c78226e1e11e109b5a937635dd2eaa1e59f0eac233a765175eb09e2bc2976479c1a7ecb4dde1ecaac1996b9f9d2538a834942d54d7d307e3a58729b005ce4dece4fbc6ab267a177360e1bf3249b783d0d11710ee7cd221eda5dc88f4480393e9edb75228c3ccfc3c8ad541544271b61d59469e8b3fa817ee9def78a0fc310b109bdd2b22d3426237f5be9f9c24565eec01a3513233082ee1098ecd93813afbfcd8c78ef09afb1b83f5e7fa25f7ee7b16acef0e45937c5360e2e56c3174bb5dbd432d6e3c69f10da32e7638c3e931fdecfd0d769e0b8b07b54d8afbe73a3c42a0d17f89e3be026c088eda46f8857f05a5293b886d465c8fb9155f7a1854f51a0392faa558f41f04ed9d376a298ccf37a2e5eca60d00ae5a2f467251dcbc412e7145fab627a070fec212237867dcbea920ff55affebc3f3758c89bcf44aad561b5a16807489116793c4e4411f19847745ba56482086685e80005aa31a4828040efc1184958f9b542f94c188369e68de6d68317952028c5112331d89906917be8d639385e4d2045be18436c9b05d8ce91e9a0c77555a295f0f5f3de4f6f1de464ffc4b397650c3b3507313f3ed71371db0f75c0e5a5b09a119c5b9c8a0e80b88121cc445fcca480b87961a10247632c68dd3b02d9edd0f93041261d8cb890e08312246a7ce2f6901dbf49655e62a23fcd8f2689ce864976fe12d65bc79383112148a30105275100561968d96d401cc1a2df1bad8669e02a1326276518b2e3319c9e13d401aa39d542a6fbd07c09da39c47717cac85efbc2c782a6838664f98472e25535a43ddd539d4dd25ed72b74a21de848264ac8a4eb6af703d8dfdeac899066fb14d7621c1493e2f2564a6d8ba0c9db9ddd086ea545e21824e6954c6bb6a456eab7c7664f1839edd35cea771eba6a3a9f98c0669cad7e8c8fc2cf822a78b3dbee7ae468ac4c469012048f4336651babb3154a3b22bf3a98478000194be0534067abd2ca3fb62feac91d3f121e81539f848e4c7780bccb745b238a66bb2b2ac2d948f6cb1a61de2a9d89b4de44bb4afb4d2e1f91f6161dd65b98fc79c69cf643b193cc721dfc3057736fed4e33fac810f2d87cc2c78469c7882829e19114b9acb41d908c8ab67d8f9d76198652149337c52fa2a49816fd752d5541f8b1d5cb0d75dd2e164ccc6f6e55b012aa407791d02e55fc76e3d76da54e9c5065b0aac03f1170afc14df48ebcb95d3f94f11735575dc248edbd8494e6446a16b2a785708d85020c44c32cc383ddedf1fb86e659d78cd258bcc0fe3129b9763ccbe60dbf111f3740bfb7dca0caaf797aa3e8e5ae7ad74ee610bad8286e3aacf23a918346937b1ad1f832a604331aa6e985f61d5ba643b843ed80812f2b9a520b0995891506ff8ec8048be06f7100d5c89aeb5cb4571bf53da1b614065834a7339198fc25d362d4836ac5ab233a3089b8a3e019ec8b6b266d1705175fd2f280da28890266feef106a744b6c7c89c4fa4e0eee94b9fc5cca804786e6cf32c6ee43215cb5cc71cef09ddc57830580e67a2576b32e972f7ba8f279a14d8f96c37c3c14ba4dbb26c68b703f31b85ea72bcd47fa470ba5f5598bfd1cfca569252b7d0ddcdda86c9a8558931b53927d23a197fbb4de832066346402b2175da1768cc282e8ce77bfdd9212272d95039bc74c50fe61d0747d59d3d34278312a5b2a8f039874223d00e7aa59f19510266be0ad9cbc08c28dcebc1c6d107a156ab96e5fb16cab2363423560217c54c3bf57716102e4378f6068f7234ac83322b1b04574a36ef884156517e4b9074908cd78e8c589513569dcf617c2365a73b12c90cf46daf2662889f964a48553bb1ce95248998c9bf6723b5a8b4b3362a79de739d3e2e465c8bb33182dc0b2bffd146bcaf34e3c790967475686f3250f585c46e306a5e69c786b55a85c1849c960973a87ea0bc266f1d7148c1aaccefe7619c5b36e394f267e11e54f0356ac6e864a1b18134c99990c21bd680a759e0130a4430593734135baefb314ede2173f5ea1bb1e617144e87002323b2f197cc30f83c7a890f3a8f08cb12925d50483afc2bf7692b6fa6478baae9f4851208fe4356d9fd8fee1b196c1132642913a8ef907ed3e1152945d64f730285a7b10979a3ac86a9523aabad4aea10af4170a64087538dc48214ea6d53c08384b6147c3a3f79e0374cb320e6131aaaf2400cfeacc5367de3309b521a12ad6bea1439ce96fe770291bca116017eb7368d636fe62e4ca01cfafe2358c3bcee5487a3322fb255703af0a7a4412686e72a7c7623c05822f2b4adf0c107a745c7e18746a3e76b46481168c848c0baa5e1edded2da370307d78d9507ac6bd0363d033f7d5039b203f87034fef47f97c9f41242370bc4f714d9b7f86e8df5d153e0b6e7d0b95caddc728ee842cf15508cdc69dbda8655d871ba7cfdd216cc9dc1da5e28ee36b856dcf4e55baddc5b6bb64fdf84ba4c7eed5302b11e61e7cffd432bbd84c1df7e4935c8b27e7603edaa960153df73ae849997ad4e11c28cc5e2ae8510cde493391678d0280f0db64e692d068cdcf6f7325ce242cfb089b70d8b93296b565671b41945503e08e001c777edbdb8a14e7de4b65bd6f14ffac362a9aac6e137f67669aca86d8adec4b264bbca4578ead9db26658dd2ad4ee666ccd328fedd4c0c13a5f802bbe617e1ef04585d64345bac60ad830d17092a99a4cfca7861b7e4d3bba300121dec7a4a5e879f70d5a7e038a29aba025dfe5b86ec9850e16fbf653f21db11a5217e771bf7a7ce44f361f59bf37c32151f871c18f9c229db2ad6d6158e16d70e6f9f702dd871c0cefd927aca2b56025227ec09e93636cc74e9f19e6a99ec6b50c40415f79a5faf4223cea15f669488a2d4cee455074e75d951bfc80177bb9445fcf672082684199286e744913e69124c035d473982838ed77d389b4f830e8ac56970310884e54524e3cd431e6f4282c6e0003d998c9ad07ba47ccb77be22b8374d240753b734dbecf6a911116cbee9739504207e9bd866e98173475bfa1af9cad64f777669045eadcc71ae642bfc835bc76cdf7996b25198deffeeb143006db4d81a43b477d617dbc741464166b517267ad239d3f10d95b6a1204828f9dc4bb45a2fd36ac193db355231bf4a7fdfbd61d397cb41249897a2885ba5b4af57a38c1d463288d6dc6a1cda13b48b0094c207710af1ad54639063486dfddcd3e08e36756f4cc729701d0b2770dcf44065d5358ec4d72a2968611154576517c3c8af42e0238ae29b747e4443b83105484cdcbfaff79e4e58756a3e43337713c336b8ea5aae2ffca3a096fc7c66f3cebb47dec2071c727db67c1b031054a809258566f5f801bb9c57f15220d3bb992742690c7ffe9f2360d04f7bb52efbab80f7d9f73683990d67e83657d72c791a670660615173aa50871f26b558683c8b6d1d2bfb3aabfe8f238bdb17e1567e7aba9de7ec7a3e890ecc7ef546b5f5e4e216abf67e39a46928c090fc87810e27d37141b4fed4e8aec224847687d9178d22517fd3c7dd16c640c24b5bb8cc2290fea55a34766b2d298cc0c4820466720f66cd2b33d484198fb10f2af60787cf52f1b7f006341e3d7c10127d26cbf4c39738dcd37fa6cb8f3d29986761bc65768a02673d263f8577b1bc304a95cba1244c318a044f2537af8cd1adc04d67c1c0fbd55568064bc1ca3214f406efe4cf7211941d5d0602c7b46171fe5191264d47dce8ae3a4d987c7257a7ef39ed5ebed899b640593fcdb62101eee4f912a511d6d6c01207d64cd273d9c0206c81e722825eba626c123b3bd1a49ea88bd42d02dfda179dff177e835bdebf44d2425a2dfd9fd104b46b46bf6b2a0c5b554cf53c59efb17e1feb0a81e69cf0510cc9272767d98763dfa5da1984a376cd8cde3e6b7ab3eddc54474ad589de2a51892121423c666afb79476f8baa4bbf6ff695048eb282bd07d9c2c5214cf59424a7811505b7d44c50c59846778a9063cdc68af5b7950cd703bbb2523e0337e848042d228de0323f7e35a767e3d59b8ecddea45edf12f88bd0500035a4d2f6ce4db6ceee3455d48e8f45106f6dff20a43bb40d05b1bf018cb24839ad61c77a78886b3cb481749f3b500e1a0270a8a0325a703d162187e3e454cf0f72c6e949b402200b35727c36e248c5e912ffe88b10b6ca77ef487e6c7be9872bda60f4ad857dc0b67ca6a0046935722219b7a4bd5cf8cbd47b2c8695135888beb0906c2b9125c0167db8c0c36ab47ce1c24cc73b6df82ae52d01f68b54e49e4aa5505c298bfd446d99a80236b1775ac2a6fcd3666b013a51fbef1a3dee5bd1e2428668a1ecdf7468779e5a7e0f34205469b8c0aafb1350bb90c3380aa8617a657e1716f2788a1692036fa8b0f4aef00a448a5e1fd4b56b453f36979b38e7cea8e5ed1fa89f382d04be77eca4a99381f5707e78437640411899260e65b23aaf0ef9755d14862551014da06f15fa424674d9cd98af98601301c80f676ce280d2cf055eddb03b3e939db13e2c74d3c9559a5a7bc4be67245c63ebb4de7aaf834248cf20591363c523634e27c8916da9a6bdb7f201325fd0c7fbfa4103a3fb6d5c7de7434a3eba2ae6867293c4ef06882967c37f5cdc8b30d73cc1db0d17dd66ebec2da00a30e70a9ea7bf2a7cbc098a15a885104fe0fb9ef27ad4351ae6e1a94aa895a7141fc906bab62d329baf34d3d17ae4195ebb3ab8be7e7d1ce0ce9d876ee316f0a3948488d74d3048064ade63bc0ebbfe3b216ab73178d1d0a4e68f5e6a1b36cf36199b0cfb6374e38dceab0de936ebc02ff58345a65ea86d342c74179c22c5ea7479f25eca19ec984de7d5f067dc8369002387da7f41e4e7054e70545bb28410aacf719ca21f647e5d1cb079f120b5b1d0707f4afbcbaf2dc00b1bd12420a6bb6132f707322c8ccd2004fdcc8360b5439fbdc821c8a35d4e2c75971cb06e2a9e37f9a773b351635d86ba3f106e55f0cf29eca42e1a36684f0a4d275970c25ca60ef3be441a72304bccdab2b868f7535d1c0fe1a27d56e512c45e9d5e50987cace8b5a5ec8e721e3545b5fb869fc8c89d48e634c7dd4448b58751b390d8a049b19041db94e1aa7684a82672b036ad88435adb05ac80e41fdc2abc9367a55058d4dcb9ca44739baa6f318988e6699d3314aa3e5ec50baaea8a75ea112f410e7d199b7a38dbd5290f305c8e0b9af7de4db4861cd793f625869ae257c84ddadf427debefd6de8cbe0b9731d94e0d23929c7c2eb3992a92bbcaedbf7875843aeef845aa8140d702c24c28de6daaa47804eacf8d799477b046476d3de5f85ec7403be03069bf9170763205a657add2f25c63565cd3ec3c259515314c43997df87a238f8f73e5b737789b0e317b053197346f86a621e27e875bb4b4219da9e4c1a969d05cb2a70854547704757e1bfd5a85153e0db03a72383c7f6338494a730296eab44c0b949c3a183955afa34c550800e0670c0f7c0c0f54aaeebb417aec672016f6d39877f83390392e3a9b53bb53bf4dc96f563fb546437f36030c5bd54757cd6f5adf57b4176d77788c2626a11ee657ad1e873ec906c440a8631f7813dbf5cdb598d5822c11ff292f9d32faee7e4b12f3ccd0583c1d2d7c829a72ed0c8c79eb2c9bf4c8b093fcfc94d5a62dc234c2cedb0e19e5d9aaa01cfb51add4989150429f031b506bab60a56c3f81c295d1c93ec8738f272a7fcf84400a59ff734f5c6acfeb33980b4363e74956d198a2fdbb178917e4f3a2b775aad086d973e8e91c8740b9666a33f01b534cc16d352273013a50b7919752eb12b166a272b0c4ab817ec1883e8be35c5d9834a379fe67b76c45cd25c4440780604c41ca879d466496b6e4f6e7a3db51b6de472eff9c388e78c72bd28fec4a1009f633b122618288a584eb109a53e174811ba8f3913ed14df7e46331b2bbf3aa66d65cab6068fd768fa1a7bfbb27411e55f04981e1aea8ee47bf999d9eb4b3e9092a4fcb2ccc08f918ed258f6d2b2b989a5b5ba10dce17d7f38bfd294a7b12d8672eeb199a4cce2344fc2f763da8ff5364a81e334ef25f510742fae32e6de856dc849f75ebf38a3ea72480d2113a6a4a7f7437457e0b0d0af078843fa27ef116563f62f0820f2e7ec1d1b0883e2e0ad2d0180a28be5188a17cee64ab92e1ef91fbb523e3469b42a5abe1fbe05a48a555c0bd7035abc7eb661f646798c03c7c5d23d3c7e754da97fac0f9667458f89cc4314c37245090a5cc8e8a998f4dca34a959e90d838094acd474da0197013ba0cac87de7b6a1eb8db944f303662dd16f59d48af40e6d3f3678f08652347f7f04115903086146a3334c1d0702dc9e8805c340e72228dfebbaec8c011dcc3ee0549ec296cc6d9d5358e307a7f08547d6832d79949245799d1edb2cc30d1a8f4b383961d24a99c4e7e4d53bd88431d5c9581d087af2cb13529eaf2c053b6503ba5ea5e24d98aec19955fa7cdf6318174746e1848f5b7510f93b18598b804a0d8bb858cea121dccd18d5a66bd579e7716368bd5c8cf53ae406f300a33e63d90e484172a8087dd9ac058c4006878fd3335384fd90f28fd92666f2cd3732471e9301d0fa58015053292ad591bce03aa58e782b508b388956e89736a292fe68a01a4e329bcb6631cac6968b7054c4e1a8366322c5f123ec99e48b8661eb11603c8d6d87ab9de1c63f0a77bc37365643be05a4e0f478f5216d94caefd57015abc717ef7f6dea8d49746d10f68b91bd46552a23b5d9136531090ee127ffcef30f1a160698134143e995287f6f9a56038d44a20ddb412e1f11f022d988bfd109f5ee333f7a3882f445ae61a590fa7dfcc72950fba26883c7594df7f258114400a0cee87cd2e5c8a0d0167289b7bab80879272550838f69ba61fdb18062d5e11338b43cec1acc71a14f70bd034e43aa93f2f1d6227e068c2723dbd8f8d072dc3903c1a56687595410cf4304d3dce07e11e7d84ca96720a8b39c9c5f73550eb1c8bc5260d10ce21c8cd691288600c9f07015ffa7880c647495630ccf5e6e2eb2400b48edb28771b8780055fb824a1acf1b7f811f1ca99691781b8ee1835ff5c380077714c0d942da34378619e024c4d2fe39fe3510f4a9d718aba2090853d65d1b743bc5fc864fac218d77bd50915d34021f2b450e7e8f2ed29932fb2f6f63e0216a39c0e6f368295bb9273325d8d2fa234760476719e6b0a71aef9e9233ed2c346136567fd184580669863a763f988b3938c2c5fe618d76817f42bb5f06b43c36c2e92b049acb792d8c143ea9fb331aa33d96db59b466b66b56b2d6c4d4bd3c01688b84aed695ce7ca55aa8981ab0972c1ac2b938a6826700235141a45036fd5fb7cf9a328314a9b27b507adc5f8fa25ddc522ee04eb3ecfcbf9ceaf0b2c20b0df77b3e5b689a2236329ac91b938ee973ec0c688d313e5d5a93cd49fe7a488b123e3af5d6629e8a7c749d4f8e3712cda2b9bb1b9feaec361dc0e60bad0097aeac9168270465864893e8adc51d155786f8e39d2276401634e3f942d744880a9fed2f6bd8a35e8e0dcb86904179107104b564fae8003fb98582e9f00a7908de6052bc874a44c13a83f44bdc5618bd2d37e7c33f22574f91ec9bcedf0a5b59bc1f0c540726f6af42d38e3cbd140c44f4460d9b0176fcb5d62fccc16ed63a1b04380ca6ceef44fde4919dde457bf679fd47f49db86383210f69e742fe57258e8f2a0105839112c9a45f715f95eba0bccd163f90247ab804e9e9e1b55e7eae4d0904cac5d7bcb18954bded88bb2d2b76ebd4870d7a93f94d258ecdeb0be9a01032b1b6cd1a7c17c2164986644bc4ae1d08a1bd55942cdf5581d2bab41b97d71debd50d69f34a14d8c59eb1b9dbda9b466a863147b25fde12325adb14eba14441486a8cde6120957e391d20c8370c86d87b458bfe8db46a1d341ea9f5e90f6c0912061132fbaeb8dfa50a4962acb3358516d6cc73e2e5df54945dc69bdd5789332186951d92fc270a09dc5e0e4a578a31c80a4088bcd23010142f470d6a9bbbdebe466fcb58763ffcb35a10ba9092eb9a2358bb4b4f0dd3f833c63a797e6689f2248b0ac4f83488d1ff6f86d61dfe038480ba846c7b9cb33a0b1a0b6b57fc04fd8b4aaffa407c4c80148aa7c4da3cb75e93415bd5e3fd98c42231c7d38a9de660a322af251b114ad7644ee384d73618e595455c6f775c172e1fa455aa9e095940e4f885de4240fabff250df471326c6a4c6bd71f49a1c00addfd336f10fb02d1c73fa24a8b4148a4a09425b4d24b36261f587a37a4826c9f059c63b1b46fe1ca92450af9d74a34e5c5e732ae9e14475d45679fbc130e37d5f70819599674818732988c03cd28c3ab32878f5eaddef88a13198a72085639d1c85b567b529a8a7acc1f48be4525bfd8ac4c67d316668e1caaa4ae1612b44ebbe2887628c84dc425b60587913d328ed3747679178a10d96ebf515770c30a2508a81abfa648eae7714fe3fdf97c9e69d5f5ccb549d924143b09b690804e6887797f2fa88f07da07a3007ad735d8e0c33e0bb5e02c99e46d7087c0cda00db90da6d0cb927b3ac5e518fd9d42ad64eaef90700b82a4e65a4fcb820134fce37ed4feccfc1812aeec67b7a18f14b0a08b73b347d2b9f08ca5e7b1d5462a541ba906647a998600c1b5c50d793932be1aa8c8dffacc4d60d2d07475dbc94c9796bda77f26b747b8d131be8455ad5dbf96c07a541a9d059649b8c9989844e91d18bc5b969094123b75b27ec35d99f186ba28de4455600e630feb001df944b4ea87ee887ffef92e2bdfe9f7e0e94adcd2580ec73ebcce2b6d2e8f696bf2b0a42cf24282d057fafaf32cbe59f9bf57c2b48a569bb5f98cd78d2780e93fac22a9f7668f2669d4923d4ed5a6752bf14c95695711fcbacc9356d7d2343ba8c5a15d25327909bec901e5d374158ad24561deb582cbf9b821570b4d33f6d0e79db6d0f6fea198a65a9d182fd702657e9bc76d6c338024443a499a2c8c705994a6655ffcb8d035600095a548aec66505c3a9f47f6d6917fa95c43520e52865faea2097c8348c202e7d9ca8294c36d0871fdbec934beaa29d337a26e14fc77da8c785f6cf6ff192abda70755cd012656caaa8bd9e1f7f8f1ec39ea0bcac98cdd4ce5e58c7d2d475d99a794e5153747f0209018dfe617be569a322c3491ad2a1673040bc8304892390d4c616eedf2dd58c8cefb585a9ad663a6fed59067e0e7a8f02af6da9bff4fc431c9884abed2566078fed25f2793661e38320e46c97caf791f334966a554cce7bac0d2a92b733cd39fc37dc4df5197435ed995e540dfbf470429cbe4e78dd233b26968d21f3bce7ea431f774382dd358c2bb232695d1f1f51f2dec440299f6c653f37e3301840eeee641924deffb0f7629f9950fafee93c53d7c0765cadeec1f7c1dfdaeb4b5f7fb2fef7805611657fb349c701c94f9c47c2996dfad3017e56fb6a11013a439f26fc8c4b060cf1016829576b9599e672cb3c2b3298996b29a32f38d018d721fadd07d59603a7d293a9d5ca2dee41447c2261cc7976c511b1192683908521c912dfccb16f36c7385749ae3a856830bc954ab59717233bb9fb0d1487ff91028f1f4fd53afdf17e23aea8b2429761a807fbbbdd043c42f18b177728accd0fa3d722601fcf57ab55349c2336e41b88b1725eb0c226720c07ae74c41eb40091a8ebd16e37edb2bfc2b97b0b48c3d1a1be374cca06ba0fea5f4647d08a20f381058514e28231e50a8555551a543aa065652acaab9544dab98bf10949f07b44c07eb894e0b0f91a115af8b0c93f8472aa70978774b1a7500ec2cfb67054764e13851ed86513614bb6753301fc16222007eaa2aa310fa0c476375a14905f1ebcee2dc1b3fdbfc603c6adbd515034a22a42d54b715716ff0fe90bc5fd048af4d6b61f94e0bda02658828cfa281a74fcc633ad69c4dae1bcee9ba9c26675403174e5e3abcf8407479e2795d1802c3df5358410cf9ff566fb70a5c8689cc0b58bbb36187f356960a2015a5b7a8b604f669dab19d2082c3116d0f50e003cd4d182099763a37829d666a178053071735181a3333c2c8eda2e83454b9bf9be939ea292f861d8886f7ae496b40d8d7fc9f5c4b9c3e8aaf66de43033ab999ba2fe57309971b285c738de5b64d1a1e53ddd14b63ccff6522cc96833e9d206bd6692c381e66698ee272db94626eedc9d740e08012ec4c8e1de43a4500dee8b838cb7de0e35403849134e19b2016d353284d5c0ed17b5cb0e0f487a3a4ee24f59e58599d8c79d6ff5d7ca1f70522af5d0f8d064ec3bf73ef78943c263d75e36c6f6f652f6c034480461ed41e708a1f79b5906a2d031fe6c86e54a4abddef2c33d4b1e645b809fd46e874436b92b1f1de48428048ce2919e1544b0d9d7aaee2af8d86c202ebd58ee8bac7c707cbd58f21c4894d5650b954cc746175c5d49240921670e77656a392e281daf90743afe206ce02ac71b854bf959e88a1193cacee52205c564e3e80eac1840cd8dc458b9633f6b8432306328e89f3a6ebb80c8a06b8928025c63e0247f49d2def3f095e8ffc228ea1980306beb441bea50ed324f5bcdb65ad00f5755ee31cc6a0972c9b79f25bc1b7038c6043194e71169bb9a0b64374b8c49eb67b8ecd7701e7654143f7d38465b94d92c6f54aa5232cb0543c4b9d9cfe03ac25b8bc9cdb3dc5e82f38a68b453d09191c911f47c13a1582d1b52686fc273efbab03bedcc7e5dcbb7ec98a4fe3e108b1c726ff1bb0dd22de67b88bd6889f367c5b2df5927267bc9fff533dcd3b8a5b24140d7d0fd7343ad377379fc2e7d238f4c161dd40e2c02539f3ddd83596647ea22b2aee937aa7bd574954bda71055348b2f0f5a892f4ebefb75796614b90ca38a42d88969d370d1aa86f2f607b7bc3b56d91b362bc6d5ff2a814ea44f05b2bed779548fcffb98c284385ceb6c6ae1dfc5ee42dd00146715fd7ea91380fda28779f844143f0a9727dd3ee57f619b153f21d3154301923e41855b6f48c0b76a6624a2e938aaeb629f15852bb0341d3aa846d45de11df7cbf5cc22395006c55f7604ae96356987097e80e9178453587621e863726a64355a995a24c3e7012254f41e3cd874790e89a921917b2dadeece640bec6d97bacd8ce8704dc9a51b1238227cb88eea6a0bd1462dbc7326ec0dfd14402f50c315702fa948c93b974add199ab68c66b52ae5907406689a7b876e919ae9742004a700daed273873eb708da07072f4fc3cb089383ca10f5c9f43a770cf7a18b7ba1af428e7c96c4e4e3be065164869098e7a1cbce87b18ce49d6291e612f0dd437a96440d9d1993d23adf2c25cd8b451634eddf584aeb901f68d9b1c82813ad154cda74ec1eaffa297ec3e6b3c8a49d515f896cb5bc855228299df595341c34f48b0f690ff9eca71bf2178497da19e7b46e730c0651a0ec1bc8fce6a2f5a970182ef343c2d67a2e8d908dcc14652915b15274c9324936b3a3ba5bc809f9815a1bcc072aac6262870c24d45dc03f4bb3dd1be10fd4e62cb33459d7f4fc5b91528255800d8b0562651dc4f6661e0fe9a993385394a3422787374576fa1ff162d99fe2f1f42b81db42791256d435fff4cc23cd95b781247f12d62b46818cdcdc3532c827255025e1c2c2a5ac39c9b63ab76eef53c46db4f011ee4d3886bbf8d3165f60298c6571d61b7d1f9d0687fa23e4e60b6758c0d643050b1a92ba2fdbe6255112c927bfb803aa7013cb55890f706a7c05eac5263a82b71486ba878427e6fcad57daebf4433dce123f92cf5e3d94fec7b3dcd3c20840c9f4df10d187148433a1b047b8e4881c49da6c1c8d96952757a6af5295db8293a1a5665b81236eb29a1f0c746235f1bf74b72a75df58376a94b1e309822f1cacfea69c23db538b396b7cc140b503dfc3df2bba9fed36f95cebd3d7cd91e533b1bf0053738c1a16976bc621ee105e34ea48eadb3cf738ca593e8d4b44240b250d14eaec4df36787aaa4a725978d4394fbbf6e65c52001b28d0e9ce398d42f936c4e9eb8762cf4bed74a42b448f4a980e927e25ba6fa4343ff1c062531c28b141ebb9e15f181725a0b4efeea5e0ea5670343b4deec745450abeed00f05d2d212ea8603e004511972e04390a1898207f8a0432cc5573145c70b83ddd03a9b5480ede0e889b22e9e34e2a197a4710da3bf20e939621164379814b6066c4bfb625e9a9482d864edb072fb15cd552b1f846e6b3254a083f8b7f29997a14ab7871e4d1f982cdca247d1a8854c13ba2a4638283a1fe6d940daef70adeedb33f9557fccd94139217159501fc2ddacc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
