<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0fbcd4731d8e37276d7432f915fc3024976f0fb4a64b7a9401e57406b50c0817b2b7a8d9e8116d7dcca2a2631f2431d9aa7043c9d39b914dffabf1441d7fc65ae37652cbae0565b795e69081ef6d67f526b6928b3e433e9e1ab85cb0f5c283c2e1bbb11b48a2389c1b2b409905393c2e7679ddd5989f99f7737bc81a22fe82bba3d20a343852f54c7cb7ffa88d18548278d78958704eadfce12cb4a04deffb8bff7a97909dd172fb5fd028739fb2090d61ddf4d051bbb71243002d8fe6db65d76c0bb0f9c05c5bafebf4da604e16a5ca86c6f231a2981fb7f8ad23c67dc10f849442fd9d65f852c85b7d7b5b045a129b5f9df849272263b54ae8b6cf06ae1f71fc8c857cc340a5ef8036b570a3c6a7eaddfd58bdc9aa7a9d815801ae92ff62cb59ae925ec223955b16d8e2ffb103baa5469bec201a929b03640bd70f7685fa62da8a5aabc340e81b9f31b14ec18927ec2a19d6907f96a3bf2cc7473fbec8c5a06663c52a4fd23771bec41a89464c01b794a654bb38be4c24d9c0cd247ee910e6f6bf12bdc9d87a50e85a3110846ebd47cd66140d43ce318e53a6ac2d89c6ce37dfdaac31c6c053c197cad4ad7a1e234ace606c7e3b0b84760d4cf92ef2d002f586d1234f5b98232cc753f0af2b6ae9cad208ec8483c0453b2f44caf8e6943a1234052cd0afda3a10987b087c8df9efaff42116d535958e52691f32304e40f4cc2f5b183d953b1630853ef9e2aa220f14cece4e3309951f9f4b6fdeb5542d9b6170e9f4feca21228021be65d58162cbbfcd568667aaa3be55632d7fab0a709be33e578077ac921d60b9a072d42a840035f987426a46009f0e2e2212ecba4db81d92dba291436289d432d759ee48b21ce127ba6a62c8dbc238c16b4fc31aa3d849f4d5b4bd3862f28729840c262e6129ea1e9d8134f9a0c144e57938a2d28335b203a1056a8ac29b04954faa4aaa2ce7690606fcc2c2a0720fd59ecaef78502b8a6c357052fc3e8acbf49e86978f9180b202c637178018b1eee3050457ede5351312ba04072b415b6d4b077d42e00847edf827805db1b32caf2ec45aaf220e34a1c32f07c913b47cfcb84b0acff95bba00463be616264e8427634dd8dc72e48ce81f0cbe0c5e6f41f64f1f9733ce4ee9c0b58b6c70674df9340f98e6081f7f35702090aa0b50ae4adcc5a7c958f733ef61d8148fa69c9ffaea1d1b0f1daaa1040145549704812115a563904374c6ad3ecad95b9e0ef702c5f76eb295043f746b7e5845a55ee8dfb86ac0eb42c06d6206ca44ea0cac1337c2f1b1d9218558d5613b288f26ef28d657eee52aba46e8b6de725e19a966bdc778e241a1ad04c54ac654114fe3e304fe53d1fd55b0857ccdbc6ad9bc04acd0a2ae6b10e27f7480714b23d3654d81a2dd14ab82eeacd5bfc4175f1c8bb08daa8e22e88a3954d17574236d80787f3cb60200a8e9909cc376cf6d492a5bcd6c99c7df9a2bd5372e99c466c86ea61a9e37354c78c38a8ad12047e669148b7c1a40a6b79cb4c7782f1e44bedb6756712c18351e2be72e0609249c589ef8aa3a9d3b86219eac77fc89a33b2f963c2bf62e2f73c93c62c67f27d45cb520d2b3d531ab02d3398f0de85d8bff073377dab253e942975a0985cd2a78d6ad9e2db0354c4d7ace9fe4039dc77abaa6de65a9f258ed973a8925ccba820249a3b635fdd6ea38c1aa5d1fd37469e480ef04cef8b89495510dac88287f4fc6250752bd65c3976aba1f22b26833ee9fc12bf06b31af56e9ad4c484eb8dd6021730217ff1daed984a16ac4de765fa31acfd5afdccda7f3eba7d4609235d1b6f5f79385148c74055c28c63d736a4702291904e65b31c19dc4e2e2282ad8a0a730b07b5dda36fb6aec3e9b48be7f45665c2cec10f18608654c4deb78ea74eb1917061c1c5f0c0586ad923a3f2bb9228d5bd56aa7a0bd4a22d47f6d34f7b0a4f404ff7bbf768db67e251f2bbf8de939a81827f848cbcdaafb97442d66d74241afe818124cc2624fa4d5a495f9e47b8c1ca0aad8ce9cbb0ad5591e75b0962790606e8f7e6c982c83496406e2ab0a2312ca16078c6eaf987a8d2f581f769d7e3532f0d16f5f65b2a520d2786272f918bcf26a683e882a3a2a548ca9ff99093ee03af0e6a6904d58b2b261dee270452ffcced4162347946b70b6ad1810f8a1546299965a8876f15ff324adb3db9640d45cddad3e34209335cbd96c8a0ddc39aad796d39abf35c5cf49c26b300d87707f799c2b16994dc73e31f7d1a55b2a74e07c9ac1a519287cb937e2916961b94e0175bcc7a03bd8ef60e4df6682df22efd8611b6c598c01bbaec90be1e15bdc390f77785e4f8c80d584405bbd34eb3b73e3d7e3f2f3cbd1fb9c7551b7cf77b4419c68f828e63be420d6888af9c08cc104462219cf16f32459e2a921aeb0bd1f5974f2af37cb891c42cb03529650047ecb345ef39259200cb88bed3b70d46d9deec789ba335636150158ae534d4db8b18f95a76af4211150a6232579513026ead5bf649173dc33d3f8ae173ecb7e5a0ebfb3e2eec116e0ae02f15c9f9684bab1a0046bde8f98096e470fe5ae0d05128443666f49cf418750ddae4d240c87e0b2faf1bd87265739191def1044ac4084a18b2842cd0f9b369ab40f74b89ed15e3a804cff526be6536f02560bb3d99f78ef873d80e9ef92b2d1e05c2c8b105d397734da21098e721211786d1b759b90d4b2dfb1f1788072e8ef1a671d00de982c6481d88103298dd1700594fbc13f74fffeba946de070e62bc0d3b8da7fb35705c24a63fda0dcb18429030f1f0d49614172052d22635686fdd2aecfa040935b069743c09f605ad745da30ed7797f2162c511ade0e5d9de7df342d906b58cd07e458d8d7bf7eba414371c1640753b63bba554e4619a21096cfb289a379314095f93d446a94fae257e23788c65c37280d53f195f80f1bf55c9ab67492061a792db4fef1c70530fc37a8edb3bf25749a0e23892db8ebf77e6b5a679e1502b7a23734fe52660221eab541a8a6d0c6d336a04e388c4af338becd620e1c46afaea80793655bf482cac8358f34c659075505caa142bcab6af40a457dc4f54e48097eab0c6bc2b192496d5461170ef6549da9a47c2143e692e96de052e04b1e325a4ec692a4a05374816bb1933263753b27bb36618f59fbf1fcedeb526e1c2ee0a531861130e2ebc080323b2f56e9e65e6b16ea6465cfb455290018992ae027deb2093b5600c09e3d723ab1fadcf58fbfb7b37989e7e464d1b67ec6ba34501d82d2dadae662a59841e0da85d276970b4faed818987fb647683b0722092dcc93f2172efb2b3b6292ec3a324cd37cfb8773f670605b6dd4e2f5ed37c183dfba2d977f17969496b0deb133a8f56935712999e09a8f0c20e5b36828bc35fe5a635de9318fdf399b7792a3032045e3c80f8819830dd9f30d1da358de553195d3f518cc13136ee117ca2f1443eec2dabaadc04c2ebaf8916ea598a89cac8bff30d92e86f32b6abad64e82b74fe904ddac103e4f73f07b1230f4cb334c09a9ea4abdbf10030b2f7d358f98e531484be67f1092aff7b6fa45de23c6b52e32f631bcee008950b1ccb5b51bee6bdc0c6d12027c234ed7b3b3d6d550b646502a69520eb8956b9b138ffef524823c3ace94a34d69ed05f1106507f3e701965fd12439034653cf1dfca3b728d58856dda3742a9a1b6c84f9d763ae3d7f099dd72ea14fefd3c3c3f556428366eabb00b6e02f701612ebab6d6ac028a02161b342285980cdd9ec6c866a64c70fbb783f047391715d6c75752cf80f807a73fffe81c38a2a4e3789da5ca6cbc3df2e213115d5fb284b9b0cc71578ba091393dbf230c962df63f8d43ea962b658f7bb0ec69e61db306e3eddd0bdc8154ff6f22b2695d0150fb9d7f86a10d62f1eaf76cd3f94ec76fb04a7f6dab929d976b7e4dd9021e409091b9abe973fc6d33858f6a84c48a73497bd5f721a195411dbfcd896bdb5eb83c090b16c771d77274f8e53055fa10a32b1866d5a05e50950d5a3a508db08bb26ee3bf1e98d48270473f82dc2addba636f430c7f9e5636105b4799d791afa3408317ed41552989a95bb05d7dfa95ee5e4a0a256e54907f2d539e0c75d79e01c3b936ed411101fe30f72f342a2231e8d8dd22afa2afa88a179989a783c2eb658f94c2ff0bf8d5f1038f82af0e934d5904fb38ba2a6869b2ff50b7237b297eee0d9a3f51b096e4dbf2c67829aea540017689c888d5c6f2b8e35e9f9182220a7f2d33b1e26136280c0b5aabf862b5f2d170ca9007179d79af4e3177537c1364a67dd3094d26a6a484e8007cbb40651a4f1a52b79f949c1884f99cf2ccf892b6e2b59188e84738d07cde1fa377196176f81011a7f42ea679cc4c32c5dfef1280d6a7cb5d8f07ea1a2c24aa6f7200f43f12a3a2feb1187960fb8ab54999659031d237471003f0d40b9e7d31622b8a2d4794882cb6e1e2f5d40cfa743ca8772391f6560340c86264f46107a1dadbafe7944f8adf94d79a5457dd9d11d2c272f051cc7c51131c8488100125dafb4782cba2fae999eb89636fc35855b72927146366d2277498ec34e667b90e3dd5973fb0d370da76ad584ae50f2130ed404d4d447f2452222e8a0b0406ae78066b397721f5a9d0929b728b315df643ba024dd53604b5eb61920e88111253a2c5dbdb80883e077186a594a1fd8cb0d69bd6ddf8a791b9602374937ddec3017f3886d3856c5973063126d5ad31a14d9ad00961dffe39b40b6cda1fad3c4b5ab06afddbd555eecf52b2bf69ecb8ec4a5f7f05b54b3822c5818ae83c2c17f1878c12c05c451340485e19d08e759f6eb9f4f637b00f0671778f9fc9cf2b180165dc656c6f3a1b8d0d067d26d031f0ba6f4fecddea8ba6de92c2b3e0b29746eab92d41819d4f5149d3e25c1cb75ce6fd4a21d57d6f96903aa47b737b8876dc84bc104f753d1c6e3368536de04288bc7772af687a242967738a9218790de9215736c4eff1ad4dc88ca74e8d9c70184058b0dc4336740060a7e3723de2423b5c70dc6ac90907d75dca57ff64ad2db02fbcd6c8d094ac1f59da9e8d1b73694d00ed33cfe0b1214c8373c9dfedb1a1a321997608937f022cca64667babcf5b2747eedac756272f2c7dca835d106652a3cd04596323eeadf45bb3892227b9b081506e8d7f0a03242a96f54f9d5dfa0ae969d103cf91819bd4f77d8a2855a4808fe69ff164d0aeb1f25c02b373a26f8940f36ade4eb1373a3db8c6bf73d6c908b7c140e0e3efd1a2dc5461bd096c17bce166c2ce5c97962d509cc5c6eadf01023ca306995ff2ead94e742ac70973b36874825a2920e8340bf17875afd425ab89245f7762efb74c1ad865455e8d30009cd8668881f012b3b072b7490fbee597dec1dfdb026b237b9d961d9238a8f515efed5dad6195493da57c9b1d917279801cfaf5f586839d6b2ec3910dc327ab057c726a031abdc7a1f416952f93234464ccbe69c861d7d32c2861c83d7e224833a77209e1988f3daa60f0643b189d820cdfea30c2e81242ef7084810cf4d35b42c3e0dfa1e96d3dd7295613075e7adda040c6a3687eb7ab6c9fad8501f3718149b715932cd2cea117c1d88880cfb30271430b5db4a1e091fef97edbc640673b5886f0745992f09043aef35a877d78ad1d783acaac7fe523536874d5632309a731ec5495ccb2726cb21698f0e3ecdbdcbfdfde20537dd9329b9109ff66e851edb7403efa7dc2102e04d5f771115b2b099996c01e076a1a0927c23b7a8f272883a3e830ad04132b27f8210e2f7baeb1f7c230db0be73cb9cdef8614fdcffa5b85ee39783f0379901b501289e2daab0c594e7bd18907ccd3c137009ac3ed4243331dd0c1317227ddecb785c600bf945bde899d6299727ab4edc3da69de5b5258e9e3d56c90edc9c61566cec17de7364797a7d81be825616f75cc9d89cf423cc5de1a79ae7ea45c8ea8d4f20ad79eb7e2b1a3f762b9ae64440d0473ff44833b568f5a0cd490c587d9a601598ac84ab6b01f26cd7ec37d07a15018c0dd4cc2e491822310eb905dfac043a302796ce171c793729915e664fc5fd8881e554e2074e3a5460f6d31c8730f1bde106d2149c6cd0cc5a1ba628c434b91376d6ceb8b94f38930c888c373e24ade159f4f599b737b08f4eb6938e064908c9ea24360feaf514b27951257dc848c1ca0e4c8279844e8a47996a475edce921d7d943608d9b3065794d0fa6e1b63e8c10471a8eee0372e24c700409e244701730db69772d3123d3469761730e3156256366513a34bcccb21b0de64dfb16943eec3f0f9e0e26981a19934f654bfca3bddb7392c9b630618fb3f7c86a20081bcdd5065d2f769eae1cc22950a51e45f776974fde103941ae86241bfc7ba4c6c69000f402349df667e72327250159839896442e5a421cf7d8c51e831857d1c7533544e6cb94d02f192b34de9741a38668e8389e9a99c7385d348923ef8e5a411b3c6d0acc9041e311d155f36f04ee052fe96b9ba87f4e9014487ac4d7bc54ef64ba54cb5d980f604473764c8fde71fd9764913e01900895a921497a8cafd3d48e13f0028ca3d3759ab8bc3628b532e709d4a6e9fa259c7d7a9b2d5c2034bf92c42ffa131ca137230f35fd77212f6e89c2445fe173752f88eb4d0dbb497fa6771c9e88e47b2281072983505635d31a5c606b645548da50e7b59715b25a6bb1958aaee643141d4dae5cd10fc4e2783a3f6c970a8dd0ef08b7216dd90f1024b9b1b9ffa9bcf91497a426868727312cbe413e8dea2aca38e6c22396dd3aae736748bb41735002b13531a5bb5573fc5beef3d6ac4e8ee92436bd7df97a0befbd65ece183d8dadec7cb594f7cfddd0ac23b74c932dc5dfda95e9d323a6ce155b841ef6df5399b00cc656979c73c7b8f7cc71ce0c3920e7236f1cb99ff1ba5786e9bc9222c7ce46790d18d4b4f43635f9a04d785d6fc841f74dab9456622951cb212bfca8f0a42c5c18d061395e76096f6a110f21e457f8e13b93b72f44910bedf1c96f180f781a98cc496e2ea30054fe6ed55156be315177df024be28ecc20b13f80c12485bb4fd59d1260dadfb521b70433ec8f069359c960dcd091a921f654b92c959c9154955c7e5ede4bf4cbf0e49228d9220bb886950ef455e73829e7e70535048a95ec2c6c0b04a45a9fdf7b78f2506d3d2ee17540ebf0da8ca023a09b87dc31c12f2fe9e06db8c7014dc0a56507eeddbc1050ff66be2a9c068a19973c156545ce4f96fcd7163e88674422232b6bfac269579e4618326ae3b9010b4fa6a2545680852161fe92d31de31a0b5bb62ac33022c3eb71a5aee20390a1df19c0a92cbc2b6feecf090a07ab5e889f3806198cb4392345090cad8c93c2827eb56c300f09f09a8ec0aabcd0d768de0cd9f82f9a8757dd33d3d4f613fbe783b7227594b27cdf2b3ad8d1e34fd7fb9b8efc06c18097d1a64ed6c17e766853f11c342c5cc11921c1742b86247c773bf03721d0fbc681bc12a70d26c2ed1984819747ba8bba86389f2ab82f98a30550f8903ec7772de04cff2ea3f7406d8e33efd44b790e98dba995717ed9ed11430531839ac52efe8bdfdd3a1f2d1207639dc8568e3a5f3921a67600fd73a1d689778260f30f14217cba40b354fa9621bead3c181f3df0a9fac717cc1d3476105dea420b20c48e50cfbd08dd67795c067644c9605e9c68b799d81f0af3cd61bb3ce911a09fdbd4fe97678fa880f05d52cf4b10fb016811769e98ac45bd9fd690010f4dfb6e289a31a028cd6253a3844eb41ea186b1cffd396adda5341c52542df2fd59d258f0e9dab81b5c468f1a4ae057d22ea002cc59ba5c121ad3a19290893e5c3660199f5b0390b345759a3d44e6ea9a4f9e2b96dfe1ca8fe778d39ae6a28d2e256db1ec897c4bfc9a9fbd8f69d75d16e787622be966bb2471d4bbaf56c12cc8a10f5e44f829489f59926b14636e865ad59b08b22827d756f433049657ad4d031e24c9ba7184aca72faa174d63f37b64f871ed2dc10a33844dff91292f6f0e0e06c8134bea84b96f5583584b812b58b523876e2bf3ba99ec3c7ec55d28afc2b837d30f49e078a8028989251a7f28a74f8a50300edf22de610c95c89e4a490b229cc294751d0c017f6a54381367aa6ec1ac9393c0ce92f6e7ae702af6891e341921f4a75002d81a477bc68f5f282b957f1b72fe65d3f68327d038fe5aca2244565410b05c526d1294639da014bd5f8bb3f8a92088b1b46c71bc99776e8448fd74555aa29b8568c2b5fac1b4346f54fe22aeecd0213b886d014be5bcf8b97dfcdf4b64ee8ce49c1d58088993671c0b6e041700696b4265f11533e8d6a69749a3486e0e5eacc27a70235641773a93025ead5687a9af859b76fa5f745362a227ebbb837df5303741653d79a8b5b7fa07dd24621ad15587cbfe6e2f078ab32ab0a18a65194afa702f037d5e0f6d828b3617e41f93020f4030b46e216f3f0843226e64cd79890d52810fb12039c1e9a086b2d7a9ffc6c505d14ae692e0909fc0797fac8094e299a5588fd14b57f1d82950fc9b16ab86422be2005eeef5708e01883ab8274811eed140b810a76c85483833922618be93191d11bcb13d085911d0650b84b39aec658c868c09d04b1c8e91c0af15da85765c3ce50c1c9382514f471e1a7bf6adbae043a46d6f08a97eee562b0040dce095fb197d9cfddbb5023e244e38bd5545649961672217a4cb68acf0a9acca5a932544814ff4c603c63068577487b70d427b105fc25fcd40121387a30eab0ef30c98c455b251667dc67444aacf8e540501f4b5e9058a665b3fc61f9d002da1d771002b56550384d53eca4dd6caeeab5b2dde789b63dbf49f8399f9dfab48e329639dd191c9e216b2ab420cc225537a3203aaddd3fd06e8bead551eb9845180051792582a9c6e47de4f8e7ec0318003664c261e6955c1a8c6a35b0e7b4b59af31cc3157c41cd4dadfa6c5b6db37740f03e25e9f0025be5517bfa85526c1691cd9fe3fc3cb469cc87b27cd147a1b391136bb4371c37a42071409ce07fae7c8f44a60a97d6ab7444d831d486148a3e325fb7e76a63e978e6b887346be4acb616d0d8c2648acbbd70a936a7219a43ec9341db1657df8e4f6f70e9c8d294b9a2a67f168d2cb5c9c57a5783f415a75ff21ec703202675e1da6e8ae2d5e7aa4de80a2977d146f6418cc46a2725a847be5c8dbe10217d92353edd577b264b387ac4793e00e8e5673ad92e4e66692f96f849a516ce1fd0f0b805171a5f37585b582da8768b50c52579332dc774b4710fcf51a22767992400493f202fab6e7c79f6f84ac73cea1bbd748251cf51eb0c6b1a7ced4953631e285c03bb2530ab1163775ea6e4f2064fd746ec6081875feb0835b52ed3989f0c86048e0058906281722d3c80c310fe9be581e21066a7007ebededb023f752cecf916ab914685179a1e034f54e1b245cd6238cb33e7e0f656f82b78e13b95b869873701917b523f5be7a6e9db9a0a2f2f59dbec46f09239dc0b512bdafa1cde6e723b08fe071c08856735a65d58a21a72b7c8e75761d2d750108c71aa5f29a223734b76f7b7693a0c4ad8f638a75909a5edcb3c3a33fb1391deb3396e710314bbecd051f1b572dcad7a9dce9d0a28277c85b48e3d96d80b7582757be6d406299d5c945b75eba97cc5772610c948c7adac0b688f825f469b6b072a670cc164b3c938b3f1afac93263071c68bab4fcc5460ae8ed169aec9fc5ed8134d19c9db43d705b70bce60a55315d8fef8398de8dde617a9a7ba3065c46efdf7388226cb7d3d487fc7a6b553386b911ad8ec2c443565cfa2a38b69b6508ae67fe05e0429c0ab9f70b2ca9879872d840eff99811589252e54443530c74e168fd2768e192045c26be1b3c70181e7c1da8e9c366d933f5e8d1b09fa4e906ab0e129fff155d39ac376d3aa09440ff0f6714c449a2fe640fb9d846d19881e75a3cf8fcf90c80f49ac6eb0a06e86834087f0d52edc0fc49b9a6d70b7c9757dae00bb7b937d6accdb6bf440c08598c28f277a55b6adaa93a2fa86738b51a2087b499462168eb0f9e1bac86a3a32e52536dcf17bd921130438277abfc92c98eb031a9b5248e69ab4dfaa1562c946bcfdac26495863392aa08598adff71236e44b74f546ed9d80d86498fac28a1a1941f76e3d00b83a806a148610a1720718901e5bd4d9f78a13c14b784be90675bc9e4faa14c6c427e85ab6c59a10b077b685801ff4f93460f84de4872cbf926fa2a514acce5d60a7c72ceccbf3dd7ca9223fd76ea48aedfe8f4662a118b3118605ae7515f950caf6784126c54e3b16f257ed1d71c16515b544f7144b339e0d0166d17e13a0c6a791478a1d0b49fc4ea2a3a303d0779bcc431bf8455f3766583374912caab3ce3b1bc8faff5392ef0ca02c3641212e76eb984db2c8dd1be8c3eabb14eade21038317f2653e02ef34e0459c90419131961ed62f0f797e32a248be02159724ba2619c503a3f127744fba33bcaaf65b70f05bdb5b9b817b3d77cb612f4786387d6714b29c2655d375ba5cb83855c23fcb24042d51bf19e7e22673b0b68721e0bea62c57f3a8ba76365bbe2aa50ff86e04b675fd95c0c154c9747ae396ac58c32bc1cbc86fa4a117cf3c2bae5f3a0a3f70aa644254041bb450176d382de9619903eecddff08e93728a4b4213010399f213a60fc441b141d2de5d07eca4aa5a367d4cd4d2119d17c22978ed9f89e834638cf2ea3bab1d66e216eab5728b1fb367e23f939c2b12802a30072436e94324cd8f0edcf5b9ad5f0f73d6ac114a5dce3220d6392f2f578865488a07409a18e9292165c4428944a5af3bca8470a2f4ae6e468c21b7e8cb9461ca17ba971f1b0b97f1cdeac50c91400d63c78ba89aab8e2a33a2e1efa86836d7b479dbf91d43fb9ac06adca5afebc5fbb25a7c03851c4f2076402c8f7af551bb43af8b13cedf1a31e55da13d7d37bc67332125e2e4c8a28dfe36d7b9587dcb52da8dfee8b224d0cbdf35835c2064754475eab4b53e56a52ffe6fb8f541ef0a2bc9987b7da3733ff41ec754f356275a3819c11cc6e434841050913d88fbdc2014c5e8330c247b208a4fa724727154efc36011ee1f1cb9eae25e324c34722f652da0d936fa8bb213861ef8c30f719ada8fc51fa60370b1e146bb1b8508c6d2e4311a63c43269d4a60b4be07036879e4157988d941e11ed8d4ad6b9d5f4e52fe4417fe75aa815e61789235043336395fbf7c40c0b056954d2f0948021a2b030554ace8f2b26326ed42071abcebd4476f13bd281ada26aac9381463f255d418b696534ca2b34813be2f02cc7b339e3fc813b702e1afe8dbe22a5623f2564e521b1d19d1dae0d258ae947152fff69a3389fd43fa657a665ec28ca3651fe885eb35ff92dbd3661568592bd199a2a5b80807958ea81ae72ef05e20328b313fff262c486763cfd8cb95379f2c3155ba54475b8910fd5539eb2d57ddb9d284d8ce20f48ee750f9fb05aa106a0b755d2bcea5ae6b03b5ccdc86c2f28e1501f792de9e81bc78735367db22f10b331a5ed50cb0461581057e7822abb0beeef145ed4931bd9abd4e4653c661dc3f1813760602bc082e7eac3553d627109bd19c0ba797653ba6760d7ca85389ab65ae1ffcc89c376a071878ff72c42c430591fcd12d058e1dabff7dc9900a4b051fa75c4e1bb720ecfd75d935c621ec9e38258a5e156a953fd34fc3a6980d32b8cea3f2167853b07a9cbf959daa87d123f7340625a778d4612d1570281e8a3be322cd35ee6985a14da18678a4fe74495e4cfc1e23f94c5ce9381d37940d42195f6d25d42b68dd4a7dacc82395fac3e1352bf3b9e28858ec73c9bcb45ccad690818d6d9a372496aef71b904dbf10ad95eb4eb9b00fd0242d279121b030057c1078c51bddb1800d6f6622043afecf37ca3336c9fe0914c1ebc8e5ebc544e5bd27e3e63565b3191570bb220eb0925d214c75f3d4f3855fd333b3400f8210cbaa0314ccfd37a909f9b4b3dedf496f94f7b8df4069394c447aa81bb8ebc37978b9212f2f7b635cc98cd13f6d7d50f32ed72f8ff636ca9d23040ed83ad2c4cefc97dacb9d89891c29ef0e2a4057f881395574a26cb36be413df439593028ac0da978e8bb6fc4a19e33d44891a760bfc3a194520111c8ef1d6569924d208eb8df7a3cfc5218dd4f8a8a86a4b752bfd58cc5e5e21bc3088fc4badff663641ee278d1adff99b10e69bad3b7e0219b276143b9bf0941a06be7c09658b4f7821ad6ab26432ef7dfb1ccf5b0ea91f421ac66a56d8af78f923336770135be81cc13254aa3b20443389e4a4d628fcbfba14b4747b9665543c49859e0a8914799ea7d8a9700a1840a81c747e566312884307633b6138cbe9f7d0930d9889654199016d18b1a2999293f566fe7a907e21f320574265827a473af91dbe94f4f037ea09435a27ae7524f4152994580aa5065c9912af2ed54ce6f72069737733c41ed4db14816a0ed26dc6594bc6a6c4751d23f47b583182db29d59fab01522603fc38a7f8213caaf70987b3f5c0553e502e194c62f38dc2da9c9296d55d0718a656b304d957768b6ee01c93a4a49022f5b2e4e641a4be4efb77e7363995431ad8f6513eaf013e711788c885049107d7fcab633183adbb0a29402d7a65c39a3c551a8c3ca00e3dea189f4c9611a2c925316c4946e3ec70664dd61ee7f5f70d42e52ba45e3b8d03b829457cf12f595b20a1673b3f74e0c237ad001985dbb7e562c305e367a9a41f030136784c0f090b8f23c95749a7eaf14e75395705c4bb4ca2b8222bb0a2f71c4ce91377f8b3488d1ed2ca9b2f6aca4d8f915eed4925c5c0858757ca9cf8d2220c78b1a0661ab0181ce5db97963d866747603b005e0c3d446e96c3ee089193377eab272ea93297641d29e791ea41bd436cff026617156b03b834e5c32d71cd1553eeb811c0dea17afe5123b096bf5291cc68ca7049d1f396ec558a0e3396f72b4182435b61f8d95a2c2e1141fc8d21c7864f24f3170df12a0640e24ae94a70e0f54691c5311c4e31cab78582fecdb2a199e2464c2bb4b20ee71668106b9f8b289ed879fd460daf51dd6556e00fed3659f1212e7c7c2a8d47fef627747173b4689b40e02794c0f7fe144ebbc11af5e1a46289d80012c8bbd73772aba753304b5e7eab6df6f67c85c55e46bb99e0b8601a04b1848e000b06e59ed57e722293c305458de0089eda7ee735bc77ba0e4860968195109ec5a7bb767db46200afa2952ee520585e256bca7801c69de8a3a6f48643d75763df1dd0df1e3bdf51e721eca107cfdc6a247df664e1fec34e744fd4499c07705438ddef9300cb1693473d44b514741155383c0e1dfda346e1961f124b93956c02766d6d14f79da1b37f3c75c2896d7101d9e5e36964b6902ff0c6e887bdce432ba24d42f3dcd2144ab5d1d65dc0693cfd03b8bb24a9be5145928755bbc9857b24de938582389e2e64081567088542d4cdbd471c195a9224292ae025ef60d534676ac50c0c282b1c05457cf65d26911db8bc001519c73fafb44ee215be7a146c8147789a7115a61f6d98885748da3e902ec6392f91b55baaeb5e864391822c0328321361749cab6e1acebde540ae6de2b3224452d04e039b7828c2f1f4b96515e0b4e3397afb0d6382f9dd62f04f423c90510b5e7baf063817a88c7b8b15f4dc891b02bba40766e4bcc9b506a7893e83294db1bc3546d26fbfcd890731c68e491bbcd0fee7ec412b68c27c8d60aa91b665b68b6247efcb931950b2977f7526e1eea3aec9cdf498668fd322367d82ad2ca9e5b10c098dddb4d44c99719926f4a0809fd9669bb2e7ef0fb819c409504da16634b3d8254002b3828c8c74411df7e7e37d778bc8ced49ccb98a77c2decb38a19f2d1243c85469dee1624412d3ac1894162a37c5dcebd565a26daf53edf65861c036c25800d9ad210706f0cc83b2352099a5ad4656d62501cfa0110a84c1ea58c1cc44c2ec5414c2e263fd3b628add03d5e899d662c17a91041bddff13c10761d1dffe7db3ee9c26516b63a3df2466940ac9f383397148f8fcb98c5e0bf794d83bf1f1676dbcf002ad4b487a4d6f0778508132afce8b20a7aaaca9cf420ed5db59c7e024ea851b74b366c7bf41988becb62cf67ec08c5cf039ad5e4acd471db5575597ddb79934e3a4120da10511bbdf28cde6a5a68f1f1ac71371ee84d4a5d222ce9424f805d3e777162341e5d28ffbad3df8ddbf8b43b8064cc8de20151c04a7ec4872a2980fa7fe311ed36dd888b202296ba8854b258b21d8f49892a9c7433e6d1c173666a24afec574bf122d4b9a505d44bc337383030ace2115fbfdb4a49c2573a5181797d579fc9e35e02951eeed990115a96a6d4b66ae192a6ded5b34abb91b733f1480d9e30c28e34464442a586a0c91920656ac42424f7454ff709b3825a91987ec668fa0cbc927473f3a610e828e1700b3a4d72876e2d788b43b142a076b66feeaaad537958792d7c3ae77904df1c7505f6ba6d7a261149bfd178491231759d14354b0af5c8c29f389561f9d85b64d49766f25811a421ae290e17c419ca02c72a1f441d3c3d7877e00926afaeaac4080b6fd601f73c2bab7bbb8df67d189434aa640a1da04514b8645e3642d74fd308d1abcd4f671bfbf0a8841c665a5bdd88819ddb54591e4b45eaa945b4da44840647fb41bac84cecce14150492f533170cd21a2bb6fda2d3b4073c578cb4f6c168491ed1c0a571aefce2bd3ba69fe48c1b91861d5415b57a8aa217d307800b2ad012d4b80e5853ffe42bb9118bd61de1a7678f355469d2f83b207ff5c539778b7ba6bc446f2111d96bb26f1d3be1398f6fee8d8ad5325a6fce279eadc01c71fced51dcb3036114d3ddf249ad59624eecc00230199914b47187916d083df856a8bd07c56c23c90ee136e3e6d56f122c460382bceab778f3294baeb68f751f0c69d6751e1f52a1beebb8c01176ff6ba4749910100b57e4bd8f7b0ace093b17827166a72974e688cba38164b8b584c9ee4706477b6d3f41c8cf75b23fe43de67bfeb11ca7ea4b5fe74dab74bd9ccc5ccd2bd04603c7b22994ee31f83b4c1187fd5609e3bec804deac0a17a558014ef2271f95c59a93a450191ae2ea0c0133402c5effcc5044648867c0b67d8fda0b8c63f720e81aaea90a4584cad39eeb683903c87eb57505d3afe5bb27f2958d2ce9fdf29765e789ce22f1c65edca3e2542a1997c0ed727162dd2832e5e43cecdb2c0967cb40e3c6217fc2b3d551becf771bcb0f12dfb276d30de1988e16d65464844668deaa999776969afbe8c59115d4e06bcf9d0df6060f0c77b519510a673395576012881b424c333071cd561ec54c46b17d96e25a688cf51cb61fddfa1ab4896b8858bbab0f8b050a217fb0a810be66688d61ac5186ded5e64934cb27224e9b664438bb31aae9b48ebbe12e835705756c60e393239911cf6621171f87b6df13416e53fa5e1f61a524b91b4c2b6992ecc1645832b64a902b60007066c9452422a2561c91681dd5c7b425ea926bf99d68689968cd0e7a53fed4ea4d811935b97d8ed31c61297a6c786e84d7dcb2ec3df9fee6e7fca6d01e1b2efcdbdfa1f87a29ca03f704d43cb3286f883d34e6c193d57bd6006448336bb94cf5e6c0ff253d0e1217b1ac052b2feeb00a325f8a2e4453bdd1cf781282ecd7c2945c6e78438dc91878f3cf3e214aaf4eb853a3a38f25f436df47a33f50b51026395d55ff934b2d8533c07e23274","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
