<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7dd45315f461246de43210ad6e62d5c85ba53c2461a1fd295f2a79a84bb3f46b410ed41c72a70bdb06d2cbd73b9e4db38dbf456ad459994698c104b7093d71a0a7b8a39af603ef8dc8b9d372a622b47546b8b57d8d8cbc35285786b2d70f226d50eb4625131abf2ae72f65e9a7b42acd48eda9e46d9100c28b67704d637ad24e23944ac39df927d6b46bb2ac3bf45d3d1c0a277b88d33356d87f5cf265ce77d4e51ea5329753312c440c3a1fa4e0b49bfbfc7be584e71c4691a8c9e614a8cb94e282883ade915bff6fa304d3e3819b040a10e0ff358032ccf281df7e8438d9d3ad194466a485c8e3168df51ef3abcb28d17e032765fa6e7b13c406142fb9e560c96216789ee2cf5d304a905424468cf3615b06f45d989dd181cfd40d070c420c08f154e991e65bab9020cb5b20823f7eefc04f17417519679d59b16fd6700fb59c8846554f9a4563888db6d3333c9ec710b774fdb50e0cbc52cffb666b4fd41073e309e76d377ffc96d231a15077bab1d92d8f45d80a899c1b2b8be501297a0859e17bfd84da73dce7140f99614791885d7358667bc247e06d49b30a443214aecac0cd5dc47af8ad8030f3c17f2bc0d482609027dafceb035afe872e9b18abd96ace9ab5ea1841eebd9f86b483ff5cffbb8687c01bd80ed66736572059279c037758aad3efb3f8e97f77a6da03295bb60e261befb88b208013fe08dba19175f6f4948b23f502241c429cc73c1430117a188d5ad42cc311c64edb524fa9c4faefd2e8120c50d0795632a7334ce108b3e786aa4ba43d59e683357dd9f0cfdbfe24eaf767a3527398c5f61e6adaf3c5fbbc57b6062b791ae625e9705949e200a3234a49b5d65d6f70ab4e4e10b14b11bf0d0eb63978eb4fe528d56e759d2ee2d387b0100323ecbb6381b6c429d1bbef0a5567758cad4b3cbec4761a609d963083b5e8dc4cfaf4734c333c30b490fe4376d57f03d10cb293d308ecff8f219252e9cbc3c172c6a8c82118d36015c8508f44b07c9e78d7f604f6e91dc84e0397f9e1ecd3667adea79bbde667fb1eda789b24df95baa7e481699774f21113022f1400aad0ae4935d719a8d52106c220d43631375b9e7554da3772f8bb2e96bf432393f13714a37086b3e293b460e27fef50cab52798ef3d1371022e3f470527d35f1a5493d98bc1da08fd559c12d5c94d2a45c313c74d34245374a27b5db735432a5db51dced45759d58ac6b4306ae86dbec15f2c9492e881456981cd5eaddc2eac7357a2b488e55482e93905f61e81bf28fc3e318b4f8765c8a183d1a7df76a3da06e8b0f93de770443599fed2025d6522abdfa335b36cdb642c937d1055999bc219d7b564ab92df5c394d993b3cb4d912e9daa46ee1d4806f39a2cf6e59b3cd463c63cf6f31f5d9c243d458c8b76246aca1167a11b6e165861056b6b7d95a56b603240ec297a8712de1bdb4f70520f709ff271de42a87ea204174fe3bb197f25d762c61d1832c493e83ab4fbbac6506edf6c3a602ca6e79e4b90db6381ff161039df21af0bc94fea983ca79ac431ed50607e39ac6b6b0cd9ca35e41236bfb7d09baadcaa631710228b5dd7c501f94068d4671f4b190794269135ad295fa49a3aabbdfcce2c846f5b448f4cedde464921666843e6c0aff833216d986e443d533940c166fdfcf27c37725cad0501d816700dee843a897cc64e714bcf1df264f5786937f1832ced30079b66999505ff11e59f41074e3e03d3333b33010212dabee3470b90c36130152adc6b956af77d4b0375cdf845887c122a9e2d023afae2c0c17160a5de67f0c891d3609483ed00beca8cf92e6121d5d9314073d041091caabf4ad604412c31baf56261d44bf90bbfefe40bd09606af0cfc5d6014e92ccdb926d8316343789e2bac0a0c61d95f4870b7066f87ee6c2ec7628301345a488c9ecd50de81352115d6dd63bdc06e6a9fdf587bb8593d698dfa72c4ca2b8d080ba34d14b9637484d023bebe0ff49215ec2eeab772e811e25a14acb65dff358618be25d836fbab6235ffb89b0267defdd7854e023026ebfd54fdc39abea124b4debea518c497e42994c7d36980f0700a73c70ee6dc389cd1b5d3e64a071da6478f920f6a2e5040014e1f60cc694075274d2b3a1f305acce90a3f9f3ed1d9293f1348ce1534ec5d4f7bc41d3971b43588079d1ee92b56c1a5338c76c16b8d9d94035247b6c3efd6b88e5971bfecdf875870600b38613a081594dfcda68f695bded3c264a14c374f715603b56700c52165d0d8ba6ff1cb2838a9011798a2536f6a36c0911f765fce6e45ca0bbcd41ae161d88f56e96854047de22a0aa3c5d761eb9c76cfa3b481d0542891f98643643b761543a2e61490fe04d10afb88320dcb93ba6f88ed45d8c6a940b5769f0818dde3357e9fc59ee455432d3b1f667a0b0fb807b789feda41da82c14fc2f9589a4e53bff97c434b1d55c6b1ccfe9e5d11713aef148b6f3b623278f64e98fe92b900b96c0c937c03c1b0b4fac78a9c8ab11a009309967924e863838793dc4ac93f3c09dfc921379b95739475ca28888c6a932fbecb23acee88cdfbb2c39f634b1f0e0e8341a4c2eedd1263bb2bce8b189f9eb24505286d92560b4f2d66e80975d4fec5f9b983b084908241f72414f07f00f5fd899869b952966de21f048b2a299109a68d2294b68614776de0d8dc3164242dff10a49ad60e08d05b08f913c00207aa13b50714651a9850e95bd2665a9be2532dc14e081c57348b57ba33d7e6078ffd7e74b3e955eb39bade494325f43769560981cb5723cb7fc460630757662aaa171b431552dff5e51c95c3b1c38b735f772f70a1e15c3af54919bef2bb84fde1debce1f548d0460eefb1a5fee0318492c611c649562da2314723bd028724e41daeb0a7eefd7a2171f5da4164f1d941baf1ba7624ed4e4b9051aff742ed5d237266f57e02b55a05442fb1a4f208842f80e0f52c882e9aea6fed26663be8be73efab0edc67da1c98a3e2126fb897299f60899e246efb4bf442f8ee937e04a6f43109333e6a2d0fb415cae0b9e87de544323a16cd6fdd861fec9b7657dbc913881350241ccc7ea8efb49c9651fc66c64015ca737914283c209c6097ccf7f3534f7ac1b5e686798effbf625f52685fcb602165468a72a522574544bc6736977dc25b6ecfa312f12fa72115d2237c36562bb2b1059491b535b9e7ae534535bcc4033481bb2b71518dc445364bd374fc1c3ef0a5a1571fde00fe07e0337fb777253f530ce606a712cf8d0fc1a03aaebfb23c84ef7d6ce34b0175dcabe1379bacbe7f07ddd1e550fb34b4f8a82203f86b47fa5762182cc0caa71e05181356b0d846228bb320adcd186a7c730f04fbfa01f9271157bc2139344294df3875bc3da355a5ca46a31c8593f7375a248ffe789d8e08f8daaba86fc5adeec661029732ad5b2dec688aee77ba6c3639a14338ad05e918c5852fd0d3a1e632949ee1f3eebd5add1d1dd73ec86576cc94a79e49025a6b0d07046d70c4a236b6ccaabbe457ee6798e561d80bdacecb0bf6ec9f47ed1fe41bcb011dc15f24db588a8f87904068e784cdf15ee41ddad871460f45b6d5bd5b22b1a0add8d327e6f9a235105b47b8485efbea74c937e307e2cce74a2ed4c3b7d364948d80540aae91ce7e46b4b05c25f1d67012e7c3319af4748220dda902e3ab3aa8aa1224d0afe209f1c6fac5b3a06b6caee2bb8835ddfe2e14d3b677d2c95d0a4cd4c4772b62bc7bee8db5d88a5a7039649773da85c2b61816f33bf002ec5280ee93b457badd76b24f5d9634168e870a27b9fedc3e626869f4f703a0704ca479319adb0d52d39e9db2e0097f3495e0d0b1a7fecd6a08bc6a8022b515c556b6b5c56e186dd7b5961a6a89f0769e42e783607e57f7db6e1bd68d071853e5442eac9e851f29e85493718c4bc4b5dcc51140173a8f71001b27b5e20b3526ba1ae800d7f990ad2ce18c13de2c2e48e92bb4c6d1e329916316b031a7bb9913257ca2b01d014c46ce920141d3e941552e587421b50aabcf7076b7a0091284caf4067a5e63f88d0e05095aae4f5c9534ee277037189c27ea12726a93e97511e6004c85ea733b17ac68b76268b8d1b4284621c1ecdde8d05565cdb57d8cfe230517d3b609f9ca7b5aab353bf59dddf1297041f42acf96bdb491b1fa7a0a77b39d64cf4ce61da2ec4840e35111b67fa4dcab3a1b198912616eb244f680d0b9693e1e86f80f9e160cbb1fa4b9c522c5f2c1395183a749d9ee9c8d506b80906a4e78b8b294b474a84c2d50c1f0c6a2f68c850f4588749fbe4a0607457e69d45de3e1c7dd9a46a00e37e6c6e6d91670c26658b46ec9920c4967a200d6f6849c2f0bfaa473b3b9145d0a93744502b2283da2dfca2a6e6bc2a621d32d3cf8340dc57067b8654342cf1850cf6bb519f3921b0a06e9effb15e490426b2b7d17248dc4c1e03c2b99713e760c925fe5ec99ace753b30749984e3f99ac6bc6c022e5cac6ec0ae1bb9e1d548a1f2e40bfdb2a7e0c47400b3e9b48c9d7a018d4d637c2c4a2aa94d5811071309e9624a9d1e89d25aebda0e0bc0b9f4d7a5188c487ef30c77aeea79e416214e594c75c876af0e80436c4d8c6a397c20e292c361139d95a493139adcf1e0028263aab2338ddb6ee4b5d75dc079e54ff635d577ca63f4d04d3f046d5e8a4ca1d637223c69925d9300bf4a6281f34a945c531fd22746f517aabf69706fafb726ecc45c967419ebfdb75e7345f99354d3b2288abdc829969ad7c559732ad01e1a3459025751f0d4ab1a9aba2aeed1922dfef9a954ba372ea50ad04fcf6df8a5fe39fb0d01eea8b5b313035d705e02a4dc0f12fa000cabc92c6171fd2354d20c58330af91674690375d8f3838f79a8a01085da779c97b3b0a0fd2671e6f5a560987b29147f3319397b37ca62b47bc2f7329960c36af1bca80efd5faaa68836a4fadbd7edd5fae3979ec5e01aa0a24104cc9050f404c78d6cf97766a4c3f2f8944792a883899aea353a99add470b87164b3d1d7b92ff7898a4fc3874d9e7812d3d7e75c42426a5b0f63004e11b70c0aba80574e98f4b8fb5e3a5d433e03b80943946d9684a416e73a483cc72c09c6098256e24d4c42caa468c222e316a657da65e914ac8d3e096b777b5f74dcaec2a73daba29fa5b465a3b298104f40451d8354601dff35d2d0a3ed318445beb4da390f7f1c37cf12b22c6060096b091d26a75e9611b9a144faa72a5f87fe7f6a2788b4cd22d6842c70cf18dac6afb5e3a755256c8b177c525f909a89efc52a6365daa1ed89f3d4a9f61da8553551c23c1ce1deee56ddf163000feaae0d2131d4b7128544cc8a70167464c607e746fdea01a9f313c68d8f7a280e0267dce166891e4675579e97bd733a0fce5113c275a637e207d13531af6a1a97601b40ee73a19ba149d0515f48b370ebed9f918bd4c14a2e0aeda7d953759f854c4a94f4dc09190edfbd2862559389ca47dbdcc76376c6630df980da64f4fcd3b730c9bc6df44752869fa34eda45b8789108d540689bde95f9d65946c4ae46c42d5e7fff5ca1734eb8f310c9501b6de0568351a9ce9825d3f50a6edbc94afd88f31b02b0c0ca354e700c0b64be2979cfdf2e62df5bef0d94829e3b6f725a65df391b59a2e37ead85645c5dd12e9e4f24e48cd0558c716580e031ab93e1c44201fcd461efe477ec12c112e7e3d9652223356bae076321ef950f160d5ab0d2a60b413f8e23c2edf3edab9eae4de2d5da2d3a0d05945bbf4ae781c9bb33ed2a2170b73385b4055d7d69098b1df86f9a8d5b677c4eb1b37d2cc9b28d9cee2c8ebc5494597edc2acb16019cd60848ae91b701ad0427612256c83c31b155432bca1755f1b8041fcba2887c676deaeb1a8d489f174515ec8010d06567fa37510b3f47cb89ed0b23ee677d071838ac4a2241d0c0e8e2dfb4276be50bc8a3e18eb8c08f57296941196bec668c2a93ca17921c07873e24ec091c4d9a4999e7e1869a64bd1e3726ed61cc53760db45ae1a41802f4a765ee02beb7b0c7c190eece4c2982dc652ca19669811f12ba52979df646d8f45f09753f010edcf3b210b3803c395f034b8cf0f02de0abc34bd3e7d812d3e54bf2a6fb619040cb36e97186e4c5c76ebbecaea517bca4f7326d68d0cb106c9f3131601fb1f0ead923c84176eae2a0e3c7bb540ed7bec7d7e1953cfa47f711762e7a300566c1a7a66b0965214c40f1a0766f5034f2d019284f484535e0efb9efef54ad341077f69f04ea13f31456474eecdad33cbdc07286b0cb3259605ce2f7cb3638654ab80506a6f0f26d5b37d7978ec325468b8ddbe9aae740484aab60f54442f13dad389274c0ae5a46efb965f29aa8b21f3801d53c2e626892afd1be292fd7b50fdb6519c97c13a437a898f29e5faf1b06e2c1d7f626ac807197f8b8794f3bc5c7187c57479c0c5df20baec965fd3ec3cd3ed7742f8131eb64c78ffc18c66abaf4258037918ddcc5bc12a6e9ed8a15a2305b8b99806c6d31ead009ad634e2bda3447094960dabb961ec5c10fc52f075e85a86b9d2227c430d59ea3f259ee25e51de61f4fd7591a671d6496a6eff048bada8104c6a633499ecca82e02df05762cfbee0d1d2733c7001651a0a7399d8feedd0d97c785fa601ddf92e62a61e601ab2339958df87a471f73923205fb8013d46e293493084646d6e38b995a248fd14e0f291943e6500198534051572caf86c06d3e1885b91ea5f66c75e0331c55c55b9e5a5fb9c3ab0b7e5ca004579fbc73a6f9a22a2542ea54927dadce8aaaed09c55a780f8de452be0beb27b9920da677d759a10ebb81320dad7953bf868ed21ca79b2d946170f5bd52ff870c1030b0f8265cf32d450c488fc737c06432789e327797fbab6293f33060858d4326e0d7cfe4dadf48c29f03b8952c2844e02e313e2a465ae3cf2576fd5f1fc3122715429fec45527b3bffb78ec0ada5008075dcc734154f701f8192861a7cd18e6f07c53def68f6f922457c4cbea748eaf87c7adbabf06adfcc74a7583cfb3da6b2481c507f6ccc38ff23eb3eff6cfd0c941ff7fa1d7c9accdbf76f0514b398a896f00e655a82c51586653ce6fd68c68062be8ae3cb93fcf0f212786f78bf696f1d66b78125a5be99d8844f6cb9edfe9a3c9ba33f8ebcb6dc79132e8a57c9e8ef7a7e904feffecea97da5c9dbc9d52e54052d72ed17e89bf5f63aa0a03e2e6a06901c98de26815715bb36c04679d2b6f5efbbd90539db3f5e107d487155899b91ba7f2154c7c4fe76078303da0dc3b6f4d3bb105cd513b3e9f67c9d528a82c7ae3516609c4ef2ad0e5a379c77d632221899a5c1154517a8337f17f01596707d078db9a1006cbb371254a7aa5682783f3fb561ec2d7260e270e78173aab4956947189bce879c7c13649bd0ba61646fcaf65546af0ef646593e437cf131a9c181955243907944fd9ba766b4ee60bc25fadf36a714156540d9442303b0a3b3a50fe3934145c2ec600f4e2ce15274c0f52006444fa5b13967cda19b93aec0cb64c9b4649fa6660fcd786c59b6a97a51773563abdfcf90d51320f549b2f9a2108cec373461b048ac1e16cc2c1aacd069f5ca770b4da5dde51f8b5ab070eddabe8744a24c0e5fd5262879b9b8dcb8b656848f50b8af4f14d342ae9dc677b66c45a45672f11ae5e8d81bb019c9b5322bdec2bc315669e024250ed79fcf1f30c31b64b43098f87b2cf4825be5615eee497f1285763411d4c89e3ef7d8ea25a4e48ed4edfda218487cfe027f55db93fe7afacd5ec96b39588b073423d615654300e4b5a3b839df0fa9b26b393c8afa0e4c7de6bd6cdf4c184c8c56195b84ae2278004219f759b1206bb705801c72a5f993e366e30ef735b2af25671f09ce00d65a1021cc1a73caaf45b120983010647f72f02a67ca1f3d5a904ec8725552e2f1830b1c126c269709804232a61593aefa6b30aae95cb65221db39019846cfc9d458c1c987e5a6703d2c82435e3b40c9a8b432a38456b4d3ba14aebace18a81e0f28835197d75e4f5e3d54d7418884a5d5fb8796bdb77b8a1ec770402290e94242a3d01f599a3f7070b5e50d568e733f90607d57df68868b448a31b47e20da26a4c0d7eb0725b5e1f85de77f8fb27911e2e9bdc47ee031f0f0f71fc257d826d0a7f1f1299f95da90fdcaf68e7f5eb1ab7467e5961129e6f55c754572ff876d3ec60e368cc7618bdf2ba44d7f8c44bf3657498cd3c9f532ddd458f1e1f3eee26ff001d9d0b164c108b834d1e09c399bbedcef315c8d28b3fdd0e9f4290d785d2850a8ecd8f200d821eb159b9e6fa75e1357ff4952269b8784e2800c4d8794136150635df928f98e01c6ddfbc92eaa5cf1bf0b32d7074204644bcce0629d3d1ca81f9fedee2b93c0573c97fa4318071bf6818d826a88f3650b851f955ef5a78c6766285e9a74e37fccd821f11f3b7e7b03748cf5ff4bd57f56e794627b1787b2c1dd79c23e764db445504ef6f8ccc837db04d0a2f91d4b2edc4013bff6927f6e963209bc24b8af0431e6d9d87a35cfa6785ff32cbaab754ca5e12c2498173f5c5857f1b52b1aee07fe613d6a57ad844e319922ad12162b225b7e5f6bffde9a457f7d7cbe510aa4bc8d2e4413e7786f280e37577429803c5ba971f83a7df1536b666d522117793e98fec7c77933cfed5b83912ad83c208b6c319e18035cb8d9084171c901b7516c9bdfda6aaf203ffc0e3cccd3efcdd47f1b48c05107af15bb9efc17976d20488e08caa530878bf80aaf14feed2f458ca2d627ca655396fe78c3c965112c1c8d7519d14a87bb78e0f162ad0884318ce5d960f5741a28940710b0c3dce1b1146f9cf4fb5c1502981f5b9566b144952c4f790537c838299c2537ab117d776b8c4f19e2a9fcd7d39cda5d18eaad58573e94d8afb16d8f8488dbd47443e1fe83e2f543e4098c1dd13db6ee8a15cb22c1fa48fedb8c24b159b2b6746399f4b25593ed199fb22fc35f8cf1767c3a33cd9692261dd0949fcceb3eaf64bc39add367056022096af3f477d06f3ce5d270a8565f01db547475eeed965665ce838dcc0dbd2a3bffefa58de1c94c575a0299f810efff8f9cb18daa56f426a6cbb99e5d2f5dd2d3ab2e0be3a87832a15553dbb41e3cccfdcb4030c720ac6963863c48ccac7bd80860a80a17502c40e47d12f2fa58f13c41f53c141b5721f9cebf6460d56cd7c21e0c42974e6127c78966a5afdac465870399bdb6334ab35aeb5225567fd79eb83036e07415e86bff2e37e3392e8ff07475934ed4373a900661659824baeb7e45c64a80d293c266553805750f7493d8473816e6aeaf8f9335b7175730ec5edf4320444ca6f267f55604003ff8bbc7a155ee89464abad5ed5024e483f567a607a23c28687aa7ae6ef45d5ff861e497a5767ac8fa48ca0b5fdfc87f829eaa5698a7bf9b214ff1b115ee1547b6679557af489b96cde9630f0d6272a40eb114254d2df3430a58a3f66618572063ad4423aa51b848ac6802c551490f7ade565025435cf70b46538f7b27705bfdabc2733d5be5dfd1771d9150d460afb01b3de48107c00a9d8bb5251ecda0e9432199b98b807010330e2ae566cd1a59e02d64d703c0cfb0607f9cfd20073ea3ede0f0525533019cb1fa1ae8ddbc2a51ae861b2bdb62b6e2586094d22ee82816a9c64736deda8e0a340d8e747e46a89c82a92bffe15e9993514c3f970957ed33a41798d65e8ccf3f39ff8a823321dee247c3796c7386597af935445846667be4ea21bd66d1a9f791c67137da51b13d381f3e6733cf7547e9300077c40f2d435d1295396a8257da1c3d8511729e1f4591b50c390aeb91b6802a2f5ae2c65f26771a7b281c8300a63b048be44dd76b737fec1faf73c2ab96225e5d7ac39fddf64f9b153ad588254eb5f3cf6f7fc75352e4ce1e5fd20011112a35f90090e308ec418c10ec4b2723be64143aae1d4f303e2b8a8ea3e518dd958dd49a581c6862405662819e97dd33e7d395e4e46cc8f17265fb0fec6b106a3ec53c7ad223bd38a704cca6309023619d490e11b2b22c552cf3685b27607b1ac376e6bf792cc9089c233a53e395e066f7644bb566b188103adba12acde947f95fb8d4b20a6036e87f65da9d92f30025f25b7aa261f42ea455d33b5b7b966f6be3bb7319d74964297dad12398e628f59e6ea276e4300bcf0a2f401065306ae8c474e523f7194f6974e5bf49eae58d51a87a3c7f3518a3914a8c7b2ebd9a5b037bb61e08542f05866a871b151f66afbe3879c7cc4409ba2d0e2c6120642dabdd88a06e2ff161f1b83e625432df5fcaaa0d51730b7a32044bb186b8ef559ac021c04ed123757116b6ceb4a5bab8d18cdc10cadab356732eb406c5431948a9f7d20d8adbafd1b72f616e947fd1f2fa3f6f21ff4fa87104168fe02f1505d74ab5cb462f85c0c258fd217b8987742a8f737f3869155fdebf6a12fd848e7335067bba0b672321459c95f83007e98a351e1df46e141dcc1b940c5dd9f71b243fc629df81b3e4b9482ccf7c2202d946440763e7c75a3fbecfb11477dce1daa8da1b610974aab765329831ccdeb6aed0d80cecd2bb5a8cb07d73d98a3480ed781fce79cc37c87aca62e7522090f5fcd6f9d399022dd9c3ceae5e142c4395559b124bc3323727d23d0b6cf5426e146026d888df856c283150b09e2709941e673ac49406014a9340a92ed7d2129ac9212d038e02a9f19d8f50d31f772b2b43ffcf0bfd78d011e2187dc6eb20b6d5f8440afe5f5e51b999ed8e1842a03f72e0a17d5446ed4d03d549cf22ccb29bf6969e1d740a733d7c9fb0ec907469737b873492cf7ada43e267ac61ea2143b13d25ea9e319771de60674711e61eff844164f6760befe30e1ac0a93b503b22cf1d89c26b7d8d014c4cafe63fb62393fe1dc7c0c24ec0b0ae034449d90d950125666384cc670deeab79845de117d5123f664308042cc9d1b0f99fdbb4d586f3b85c8371fb9001ddf87e237e6eae1ea3cc85b011b86e1560230e2ec40cd6275664b70213c3f1eae755da20930960354888ba5abf8bd2cd6aaa3e1918ab3dd46cc6395edc434e2daf64b070eae1fc4e368458d70ee934820b19bcf8f1a46461fff2e6861d3734e9662baac6ee78355b8c2c74e59bc51225140567603e139ccc9d3cd38c258803434b4b375247dadc95668d980b9bcfe89c135a1fc73766abcab78cfa395c42ca4a01c5a3b014399b3d125ac08780a68fd9e8e0cd2200ebd54a2965cb2c6713392bac554f77eca0002964c320c0117f6c27c4f46bd73ca562c64a887799918d45cb664818f3cac47fe992b9bff6142d1682e050834da099dd14908a231cf15056cdbe29c408b1eb3ccd361f156e77fe34db5c0daf14508f01c87626350b4b4235e8094ffc798fc4949e2f26d62445a615c92ecfad5f5671d3026db517fba826e1ba9c57b293a38cee0c2579e79d86386204abe35eb5c816043a33a3be8a9801f11f8f2df0b3c19a5049bd556162a3c9bb229f46feb188c998247f1a9f1e2329a22c1ecc6a89689ed03a0aad626ebf61fc3579609fe2893c5924f7d39041e5020fce7f600c96e93b087b56c7b07da2c5abe71b6b89b3dc552bbde4d054b0d4db7cc05d03b8ec41073676669672f8c6193072514b8b7a41a067b4724b81380f48ec4afa5185bfd0268a9f20880bda3d68a609dc4b7fcbc20ac48ff9f3d00a7d53b904d54cd55ab1810094309df6de73813e2e4158222f6d89e5039b7884655c18d0a880321bdd7dcf1c9a895ccf9e098cbf02a30ced9c14272925cb25c87d89c515963bb51ae49ae86608836eacbceb367355fea4645ad892c3e1a272301eb2b588e021be7d40ecaefb079fb9df97319b240cf0d0d440fe2ebd179cd6300852bb623035e9e5ae7e2878db2072733a5ae2a3041345312b801aeb27d1c980c9df9aa47a49430b940a5f7d82c27ff3d07fceb7c22f8a90ef1852741993bec123f16b8a85701dbc9f63560f197cfd10c3cd74dcef0f911f1ae1aa8f8b5fddd73b567cc2098b7085b202ecdf611dddaae4df5ebf6b7bea3778c4ec5987c6bc45149bd256bc007d0a98ba29514d6b8a96246a0962a899329a2bf1f3cd16a50b7c85437c9863ff04e1905b3aea589679f3bff1bd3fb2a2f09c13b0b8c399d48dfd9a2a4bf1fef0befed0d39a045d6f84bcc8244e1ab2f7d8f7f5d96ef184644d0dc82492d57fa0ad5cdb788be7bc3211d8af31ab155db82866b815228ebf26a7aad040a803176e5dc71ff5eeb12de205756e759a47d905132380049a0cbfde5f20a00b71b1ca95e1e78e26f703580425eda027314232415e6352cd4d99dfb985100123e3d01355cc8747a991b63f110d4221f8c510bcd09a7facd8435886464ef81f7309f4e28a6132f6dcb502dd935ee75a0f206ae272babb76b28df165c3105cb19affa584f84d28a79b41494faf2a13bbe0ba0ce1d52690336767c430c5cb1fae77fa6d98bab859dbe985709f863d7bc82f150749b216161c211c3bca7a7917ca9d2c41d704918b8f2a6ee6701cc376aca0f12841b799d17e1ca3568c5429e01f8f2ebfda8e25141141516af79404668da6ef9ce9b4627f19ffa0a50892a632bc90f285962bd226f6c8c2590f4bef2c8a21f34388e1512639181993dd5f69274527ebf7afc3cca398decbec8ffa82afe264a1d6be8c1eb8bf10ea4b60d5f800378131329a3e27684f188c82f0f23d89a6ec24c69603359e72dd0590aafc2a9a0d991777de38b618223dc0c92f6b4d0851965f0904685216d77c186969837733448936a63f6bea6ec45acb61b22c40ae15ed87173493b2c9667be2228d92037fdcc43c8142772ed9edcb89614621c562b7971022508bd301061504552a8c3a42f2230e7955be8fb59e2454794f46d6290befa529df3ea75b4d8548f50d670c1cf507a18f1b155a9af697695ead978854630ab351adefd316175634b42c4b7a12cd8d87bd7b382b85864e6826ef2f020661da78f4350c2d3e21fbe575ca3fc2203574290d128b27611999100ff386df1cc529e51f87561aa1b6b4b580c204ca1ae2ba076662bd640178aceb5c49b88c02acc7c5ec6c475fcb8b5d542b406dc43c65340a30e95730765f5bdaf378fe79e4cfe5ee8f5c5e77c8db46e2b159bbceaf4331d6be15724584c4fe28001e6c7990b25303cd742bd5008949df5561f79ca7447768ecb4bcc2b6b9bf3afefb8f205ec515ad88b22b7bc28aac5bb04a0b57a0ad4b8be2b2d28788e85fb4bab269cb72593f1bc142f97402eac0dcd030ef1b15d9ee89e5f250b2044153c1d826ad7165a0436e358ee886c4bbc35fc841fffdc021dfe09096574fe22ddbe6abe55dcaa53ec28b9bb53c8130e4cadcfba19f00a1ed754320cb842b553863d4a83b2d02214e3e3498545ceea382b824dc40346d31a392834d5ed7755cdf58cab4e4837694cb4074ae297be785184b9c48b049304161be7c4100787f98a52247c0e713db379ba608c88c5639b54bfecaf316e8bd136b8044f509f8c4b86a57c69904a5c73de3586dfd1a6ddd0ba714c0d817f6af727965f8075842e4f01b0e30ec7dba986e4a7420a266eedb7a030d27ab7987e175c152f8b0d21fffe0aebd827bbaf3cdaf743de4209db0caad31132baca45b49e4c44cdebc42936ebbdaaa7dd561ff7cc0dd37b99743118d971e7fb676c64e82440e02f8065b4d9b8aa1e46bbc84f2d6fbdcae1c41d046cd961f3c6412cade602674a9d27bcb012ce8454e156b6d7f5791ba351feef54817cf28ea658aa3655cc3e5d15f889448f8ee9f5711676c24a83df01a8f35c6adc3130bdf11701ad9a25ee08d1ed9eaa143c88822f8c7be3eadf3ae95178dc7a50bf823da43e1430932666db7cd6f5ced3d50062870a760e7f392415dacc3f5ef63f1f56b1c226363cca9b6f9f526107bddda4cc7db9cc500b1178cf87d49405f460f3da2195c38828498be1281c6a966e9a991891b3d87c7e070f6c8fdf80a2487b7956d7a9117f3824a1a7f5afb3d6e02c4f4df4d6fc1cbc3601316ffd9e09748b65e94910350e552a18e83bdd9438fc316ac38737e6fd749836de7fc63da19e7012717fd092cca41d1eeadefdaf05a9fe614f6d504efd5b95ab0d663bf7093867750b52859bfb255d8cf602dddbc1bd38a1674a047f28beb769413e4b47e023f2505998a6710213c78ea9477a0921ae3217b249bc007c5bc2c5550a6df26d9a45ca353e99c50798a5177af97b520b2d5ef70c6414453998a1891a804816cf075b453e8645ab662c451a5adb9ad5e5d8fd78f64971e143a980e40da3cd7868fa23f937045668f6d1ed3580314f988bf1a77eb3ef956ba413b193d643f867d624a91a47ce0d247301414a78a0faf90e7f6ac7201f7c253f0b67e5bed904f4a74037ba1f4d4e116896d6f071c6127d8febd36fc0386f0f15e811e793e5b334d36934eee672649cd7569fa35737c354b0ad7f2bb7c34cb60f0ad06dc199e7549a420b830105275350a081fa1419edcbe94a76403bc7718dab372a4dba0ecd0b8d87adb101aba82949d29d95434d937bbcd5cb4af1c34d4f9c1452a0d6a7a9af3141c5ba4047868248fd1931e577fd89c8889b79f547dac7b398e1f67a328c7a3e85910e20d6ef0b1fb4074e6b1002ee9eac5354ed83f7d4865dd3ab2d9688626121e7a34d613f57a1f905f5d8fab6a5ade75b38211f1dd9ac99c3e6fda8c2912fc17221061e060462319573c63968cca936a15959c06a4ea7f3d54fb4f9df214178e64cb663b2355d0bba1833d8e1069b1c9f704de183562c9c24ac90634dbaa907574c5fbdfe3bf7b34ce3c00c8e0a0d7460a60083336f8c04a2f597b4a1191f5af116c1c30cfe8488926f399ccc239318022a9e3c13e4efbe6a29ce5f6f46bbc4039f50816cce88eada06747b2257f23853269ce8c1e9516ad0dd1f8398b7b400103c25267d11cd643f9876db036a7d8b7e96eda8bd4a89625ced29c4359a54307071fab05d9ee314d7744f7c18c839f1573aa57ae32b0303d667104b40c14b04242c66ceae761469870f4b2e5a7fd3cd347ba06d5d5d1bfb2f075219c336e50882999f1d503c99a607967d3d0fcff607798bd7c10334f8fbe349dd0f879e9973b2d3555bdc86c6ebb393c7a884172a272397dcdfb0127e2c3b8d99965b3b6758b736657b2a63226b613e89f3b583581bd79c28d7ea206842724474f22814ad6a33680b9033c8b31dd03a225ffea5d49199a1fdc99f74c9301602974b629a98ee7f63136900cc9ed0512f008387f0b50b7c15fb9daefacd85ec62d773f2a0eb2b837b9a40ac787398fa4ae58471e7e728dd572b70631afd8091fff3195baaf516613f3f7d3e50c9bb2e96a6d5edfc5d96088096adfc2e081b2728c82c8aba519a4058103d26f15fd6b46f9e64aff4d06464de6e49add97bdcc4f0fc034867e096aa998a77c41801450efbb58f7ced05689c0409b58f7891323fc927e235ba2a1c702aedb8593dbdc3800340a7ca5d4a3d6217e63f1c5443a647f9bdf0ba8e918eff95765c797d0108a44069752e9ce7bd738f3239b968712279f27ec47b0a6eb6aa08d37404343957d84333d7a48f168f6338b101bac474c27450d800888f0d86e8681ff66e6d51ca89358d4615c51c817989117f6ffe1d6eeb43241d91b9bc5d6e76bf5ec61a2e72dd9a2b8e53f0956c91d73843a689b01323c736bf88eadafa8501893e4ead5d21c2eb46e33de9f1850184116ef27b608fe25b90e3ba740b9f5bda482c582fefca4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
