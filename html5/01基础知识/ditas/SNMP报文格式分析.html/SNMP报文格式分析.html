<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fcca719891b56d74044dd8dc1dc0c0e33825a95d8f272486ec2d34ef55288a4c07955aef0145f81ff5003bbc556128f39e6a6fd146070f4d7c520f29526e100d5438ff5a8a55d8316cf0128e60861d76ec3526aa40b530ee620bcca3b0d54f244c2aa855ee87ff0595de3d0a84bc191c02a780574eac62dfc03331c4ea68c549aa23c502de4154aa9e2f7f131bf3071a916a06a5090365abeb631b944749e922fbf44a2459ba788d9e0dd9cef64743798004c832bb088afc9c0aaa48faa1ff6feec346f6daff293593319a708b5805f37f7ad34fabc2590682810f5847c3bbb2d285d6030843c3a19909d56e69d9730501a15918a0420988f65419916a17e14f67f058ced61708dc2d32f6e74cab39d0bbe7e179881ee7b4a9a8234ce87a85b27085b603ad2562ef167a4b6118a48fa504b12d7378204b55c9290546ce243aff38b00a1f2a944c2a027b2975dd8131ffdd62fbc01a282c78d169d26ce12f99606fc10353849a4a0cd3c783097646f7be2a1c55251bfb56bcc662ae93ddcbdee1256457af713cbf2e2c655332e9c1eb0f73139613d830f876dbde2203238fc6bf54a01f91f84da3309235cf52c5e647590462a3600849fca9b9be2b3a78e80523fb9b3ccea82c8b672e25fc3806be5160ca136addb6cdadfc24d84d4d39ba9368d793e664530a267db9868fe6d7e3af8fe515021519a527c0f743fb2a6f63008590d7fa6fac7162b7caed9fa507487ee9669227886e7860a8bbb6f424d9a2cf02f1982cc5900268755fe2e7a85897fd5f51f887903b4b0a9554bc9547bae08d04f4a08361b99515d5e90caf505d697624610121822e651b54fa359fc8eb885600142a52c1f6a7a0f63e355252ac2551c6f2a6f17a9b4dd78b974888644be8a9bac3bbcf87bb832580e15745123d2c23753ed080b40aee9afe04bbe8868f90e24a1d033849acc21f53e35accaaad62354442f1377ad445103eeb64cc3623644c5f0b419c6d88f72b8158ea78447072fa6f318e77a324915d98469321815ead7649e85593d012f9cf94a4ad4cda7bdad5b78af5ea93c093b6fc9dae6d52bbee43e81241afb69cb81363590cb31985d0271cfbac6d8fdea000ccb59cfdc63bc7f4ef6abc89d2fadce8fb70332b4ed17f2206335a3cdf6bd0185298b3334a6802f8b9af8d2c486ba446ace9b9a020a8c6ac3d341493816124077ab3e846a83743733386fb27d6a07b321f24f64e0417c39b40914f9aeb4f2e2e6a7af5e90622db42999108bbf988fbba7eb267840e64aebb1c21eb7697db9b2bc63b353d3565d145d9d25ecf6e78ef142fed95a723d134ad0b4282512677461465a9a4c94ffffd1446d8e14186fb099aea82dae0cc99054065d63c25c09bbfe47605f741daeebad511a232c240e8c8eea04e6deb17998359a42feb4be9585249457ab105f5a9d8f495f7d61bc13d338bcf1af5ee4ee2abbc4ab43661ea1ab956c8d7d0d6e5755b06652cd87f301d1ed507f2da2ffb06232da843bcad517e848468676b22dff1f6bd4f4877870bb92ac1b58e41f62ec3fc81e84e998f7cf5ac3ae9e70f87bd335e56f403e5b40527ae69ec3d54287cf3e023d8c157edcf6689dbb0dc9d2a2928183e510ac819f0179417262a51466d7521afaa15620bdc1288dffd1a6f059b180baa9c7a056dcc66f3d32e1fcbed523a5bec21d2bcd40510c61dae261f741f62a89c0e8a7465ffac3fbe37f7af4e36323204f20189eaaffbebdd3af1c5afca5e7c10449b9a4a7e52fffae2b35b9b31a45d072fbb425b767823b5120804bc7b6e14f5e98098f3900e56871177ea744eccb237e08b0a2e20866c9ed5588167d254ec3baea567d5283977c03b3fd249b7b7b27faa1f79d1550c9e52e2190d01633b421e36f00d5b3bebff9ed6b3ecb58a50a7481d2cecc9f597ca0a17b0b58a9b2d40e208a50cd1ef5f5d64ff6dd05520467f7e2be20f9b8c7482d26cb3aba60bece8907383647d09729fa2e20020649fc74b0a260f4096f0762be3d732f17caebe1d4d097593169622c9f00f59b5a17a743e27c912477de6f999ef78c55071e241bc9216f8735435ea073b45ee77cac9b86795dddcc42b802a0ab51e6870f2ccc3da28275af7212a5a06d9d3e477e5d9f017bc29ad9a412934773e4b2c06ba401d327e8580ce9f0e8b30e0492a7876583b8e03e59c1adcded2501982fa16c9ccb47ededf4fa0ab668cf86e5410655d87a138d9d28d3348cee7eae3dc225774171179349732d957e1753db078f19b9fc7786e6f49dfee3b012819a8ed7e985e1c418eac139a6c0c1f50da5096f71713ce97026bd05d5d6588640bf44256946ca2dfebe92fd7181a9eb143dfe4570e8d1c345b75df1288a237ae58422f3955f179f8dddf7953730476f6995290a71e753814cba47275e09fe8df73aa4984059e7c32e9e281e47ba77aa44140e1f83839ab389aa20aaacfed6f03a03af36b8c1d33a0f50ee67d01926e14c4683c652aa16f2216feb0210e71ef47f4e3d61d2846ce20248ce14a1cdc26ecbb912f3fb1033b367ef8c1e9984b219e1a6df281e91a5c2b903032f07ed0ab36e225292f22303e9b5901b3e956df8e60076e26b048ab36d8b33692b3e2a5a61100bf1f1d7ec98fa31a8f19caf6ee3e24e4ccc5f7860becc3b8d374b9ab8b128c0c29ea6a92a368f4a404af8a07066e492f5403beb6c98f597cafa1ef6670bade4cc5cac55794de66e5b7892c5981c565226105485a3a4ee40e9f73fe77500c18681827a22c25668aa9ee47810a322d7594b5123796dab06c3961eee4f8d2119aa98be9955dfcad0da5209cf38cec8daa030b201f868c01d3ef4ee5d1833a9380279f6f8e629e157093eff6061268741da3c053a3475dfb8401fce51a4217d6657ce9c386e934e0ab56f78df99fa21e86461f6ad712d0812b678d46c45aaae5030e832967975b5e98b03fab1c0a9c436c6a653e6dd5d13b47087e07ed9b23070360adb83d2282659b9903792348efddea80dcb75013be23e36d537829872610ffc15250a402f54b80ab7766ca00f762b1b572c1ed71ac1ca911a783cf7cbd34f408bbf6aae955739d54439b89a1579f24d7968642be8cdd00ca8a03e70c0e9ea1fca96fd140454989d47cd3ee7f7ef1f4b70726f6a70830c0704450b7c8bb9309c74cab88848a97826a10c4118c03ed2699e04345029be6ee3c8a934cbefd72db299d6478ed8b33967414ed9f18e554449293ceae340dc954f7d139128645c431d9b756e7254504f3248481aac050956ac11f19e35acfb2d801048a89ac8a28def49abc913a723701e7894c1ef21783fcf70c4f51e05a157c8018f2791166ab86c3484c63965fe1ec0050c4a2d26ac64ee0ccad273b7d8ed0f31a051141e2c9a907d3b8a219d00d1dbe4b5290147aa219879f4165abdf1c669b9e92ed1a12bfd0e384e487048b8932d966732726e1dd734416f17946f2268e9b1549cbaeda6a0983d19778c406f2a3fe09297f88fdf80b98e4df91bfde4e29b7bc6d93c85ffbd3936a2aa9157bfe8dfe8f3d70e1f9619bef13efa76787352acc85947df66cb3d498470c1e5be8044b4b35a9417318348ff11865e0d5b6bd6f1f829cb38a14954eea14f0b35b9b3e80efe6df0340804a798edd040c3ab1f96482fc756549519192c4aaefb73b4d847edc7d72cd1b0c8f1464e07c87f5ac71309bc0350a2edfd9177fb2e176a55f57683439d2e6f6297273d1659da2c438a0ab28f867a152c744d92dc9dda0f28884ad1e229c243b05e684dcef21723c028dbd57deb486986c232f7445fc687e7f4c99b7aa937921e4cdc49b9cede85d89199529c1a674cfe72bb1c8fc02e8484137ffab15fdb2486df7ca4d46a96092349dd5bdb34f0ba9f4748fbe976f0d6f4289774254e0b37019f931648f4e61be0001967d845165b31a33a7a6aa2bcb7c06e59197342583b77a4df83a753afb9da0036118f4c3ae66e1a0dbce71523e1fed040deec11bdd534a6dfd95637132351e867947452665d75deea5ae7e2ba27ff39ad41da3ded52370cae5e77e8b0df5c56fc947ada5a889e516234993f26ff58b17a712c18dad3bca66ed78884a7b706fe3b2113689d57d78f17f3d6d52a5323abb8ff8321d06e6de34f4da82204573d2774c5c28926d14219dad32b6b4947a99d97463558340c7d9628d9bc6d8c292bb06f739f79f3bf29cf2b703cedf353b6dbc50d53e37832845714887b6608aeb28ff65046a80ad0aa67ef482dda1c89ac208b8cfaaac5993f9fee42d9f391c58444dab63b5da78ff05ea76effc0bbef9c9070361f9959f3d9f52e52d6de09ac316ae04738309dad2f78f16c5ae05180365a8efc16950f7db897a2337cb171a49b1268b2b44ab3a3da549199c87127299d2cee75f6ff317bcd5cbbbf8205b5222b0df9e28c7018d4ef02fe5b9fa55f01fc2fff51a027c535f2f6ee1c16e48ac68a71da670472bcc7c5f2024b15b313bb4a7678bc7695ef5b33abfdfe655af2d5f7e9bed0958757061d85de30c85d9d471b883c0095279133c58ba645e3042e26199dc9bcc7010f221efe01ab6beb71a59fb649fb09776837526024ef5e51ebe790b88b2340220e4107ffb16de56f5610dd70cc352be1f0e712418112b89d19afdb39f94a9720e0f407f591515122efe2638e3674e2cebacb90ce171abc0d1723ffbd1673a8d26dd6a1b052c1d1593f1256a7165998588c2bb5a2d3f8cb026396ad80fe9f3c9e95645d1d5bc81f65b4b2abde9cf4577cd350d521f9b27b18ac9d342f4085374abddeb32fd5b0b2dc6413e31cecc2a280f488ec5529ba1ae3aa56a4e946c435f0299d3e8974f7bf287cc2cb75e9bc3b21518a87500de482010eb9199e5f928442de6a47dea878e3d63af1b9dcb2bccd7cb228413b9a68990fa903e53051037fda2950b69386153baf442ae5e906c2d760f4bc2f7661eb52dda177eab2458038fe4ab56ee452c93cdd54daa38f6c1df067cc7df82c24c5036c2362f2fb66aa12df956ae111d5dafbb8a2a45d34e97c328393ab299d37e36efebdeb0c8a6a722b5a24bc292ec2c316b65c9d7c7c4c28b052e9b4cdad79399adef7ae3927e5251b71581fcb9bbc320e674851feed41c29f9da72165c4396b409cfc469a03d1fc8cba2f667d4590ce11666b6febb5e774b675d141f7b7ae1c2b48b55339cda6c1850c633d95709dce429c9db63c20f72152bbb460c43147c95de00fe0a71ea5b31cdbea387ac6d657694fcfcc43a6d3836c6902c115fd84e52b3fb7ea10684710963db2723f951f5200f4c648f9f536d13b8bcf22281db1e7dfde207c55fcab90908eaa5fa986816d92b6a0818a9c170bdd82ff6bed81b9178bddf4d3c108a06f9db42605dc4b58d2e0c455d0662be51c3ad2a7d627f50d33d134bc61ae7a818e1f266bddfcfbfe049cd3b47b10ec8be39c813cf46ca05c5e86ca391caffbfd65a82287498ff21fba36286a6332fb3b8c34c9227a6641f648c8c388de9e94b6b0fba42d03df8ce36e9481ff6b1912b833c5822d5ab0a5a2a3be7d25bb044f9a98f1ecc279dbed109686f9b35858e07e66f8d1b15bf7aea94027633c371b5afb14c333d59c433134654a3fe7fb015706e555ab3e34ac4af3bd28bbd0290dafb9ccf15ef28e40bccbed8f44eeb40b4eecfe2247920708bb3b81ed2dcdf540c384d715b514c635873bee7a16409fbd0f6a5d1269993f84454a0ece7175d703a3a2d7ac60dd4ed6f651ed3ff334782000c3cacb8717690d9187f515bf0408fbe30e19d9be587bfae2e4f576eba2d559cb9f0cdb1558c1d3db4142d6400679904425d1127e48b215b4762cdd352183a46821a318e36fa8e68954543436886be95b60cd39b9b4c3b2817c2f529772a3fec313542ea12dc8052a7d7a54a642b301dfe4c51e8cd07b7a695f7dd93dde6e7b356be24231f1ff5835df7abfbe1d4cebef20c2ba2614c248b904e68d6162cde4c52b5f33da91a4084c0353472caa0fffdc96f23988534b7932a61df4ed1c21863dd87d8be0999d9daec9bdd94c34e55d74cbe035f86092da1776ed355d0d51a59d29245316e3332edf64cf71e1e5c2f4fc015be86d64731f56ecb7e8308f3a2a559af2d916317878a44c692344c0dd8a0d8f0ffa2b5b8a81baf2db7cbd5b63d504f5285be35535d9aaeee0b0f4a6f259396dd7d3a81db20765cfdea410e2dff81927dd86a7e308052c4958022496dde158151aa291c0502ac266b7abc5ef909f72f7c47c7b6b04b6603cfefb30c868f1f0768d583cea13deaa94d1b5dae8544ef0ce107e4280159f62ba554503e5459991523af20f96a2512798a0d657893437616a0573591180d8ed841ab5bafd429ed18e766dde37cc43bee8cc55b3cedd51d5be4903f639e7c715e0612c70ce765a6a48454e61ddb00a2b9acddcb12ba45dc4e9051615c305cb5f3c41db3025bc6f97fc245d60685476d5cfdea5dc10da6e1839b1cbf4fcd44cac317bbb52fef789c01a0d6d855877821369c4bf6091e52f62d8e6524c911ac93a46084f9727e8ff43a1b1f490c5ae3e978da6eacd6a9d8399ea8de7ab5baee6d9ac78b17e922748b0970063e5fc4f1908b073d26ebce778eb0d27cfbe9e10bf359bb01b941adf234e4f2c89092a78566d51e5f060299c5dcda10e61bf3dde5a0d57c714d430a13428bb274090168198c173262eb186b4df0ed191d22fb1064476c90c35d6a4fa04975776e1ef604d57e2f157f432f809685cf2c7333505c18046043a9e9c9559bfa7011210eaca69a2b00122c324869c7b30394ac6329ac361affc801963b4540792de932bf4134c1d29dbfd91aef654ef1fde27be87a2f09bef99e10edab8f76c93420f3d2e9fbf02314f2a7aa965b47b7f20235d6e6a7605346f092fdca787d9914576f7823e679db18d63546f5d347e146b7b6c0a98e8e0bf53b8b6600943451edc374a916e4c14226e484608421d744ae5cdfdef7e302d9b1a85df4248e5a55896e958e5ed080083d7d867523127e22b54ec967043f6e4fa220f58b7940a8c964eca7a8a4553dc99e7e1788c3ece055787679ff37d54d5265885ee93cd203aaa84c0adb5e2d9e471155fd0fe6f75761f3cd3d138ef6133b37f88cd0a3da7e7f8decdd85948097450823fbabb44752f9a04374cb42206c1910d5d9aa000957434125cfdc371519397edac70de9e51e2916cc206d1571f1bb8599baa76e7d641a5666490e72907660c689a102bbed8b517ad0fcade3325d3656a5b7fe25004486713f8702b43eefa102943e9727821ff57215aa462c5f564ded8d548e6a689a07a0b31603463b7fb0f180c93dfb388d90153aaa3c61ba78c2e216b585b31d2310e36c88c2a8fde4303c72b78a20eef341072be7bb8c5cd9af5f33bcddbdb32c3b14f2299ab575021bb7a1bd31956b0c98e4430bc312acb5e1e287dd6f00d7845fb8f36d1101f84b4c7eb5b5b49738ecb7d4bde0959541719db5e10bf40f977b96b404b0694826a9f41f8b59a680dcb50eb82a876e68ed1c2f93087d5d6f5131d30d28d388a32881b704bb34511374c3f2042bb5ab642b953563264f8c08bb1cbb862d748e62ac33698a9d4f84a60754cf9fc20cfe992dd239c38b7450c12e11ff4c771d6a17c44b154c1749ac084bdea2ef7c97efe08920885f5f339ded40cd763d69e684acaa2086e3d15a0170e70c27a8f0fd1cbb59e05040d1a39a655105b66ff5f8c9165e44139760f172266cd1a35d761323f9740295558740535584d985f25281ccecbade9c4939b827b8b34517872f313bf052beb410c8c421db3fafb6b8466cb375701e5114e7670a3e725b606b6b8990cd9b2d8eeb60b8e82e1d4de011fc56268f616f9de9007c5e11d785b3a3c20abb0165663d1a9eefabdb7a488bd7282dc79988b66cd79e3a22cf52d769917f441426ac7450d9e94123cc0e0666e05a37a0cc5bc65ad9d90a2f0457ad6b0fe129204d208defd1307eeb30c967da3f0cea5b6380d4eec578fbd640e0e5c88fd1411f88fb310a768d3a4c63a5dd9f172f36a0530e112d1fd193815c7bcc64276c75bc7483cb4ba6e81fbdf382c92f8cb3af8a57571e2badaed1cd0bee2588fb003634e0adbfb75cb04aab8c324906ec6bc7c80f80fdbb4822e745b285989eda595c287f3fe161de4d5405842696432f0fdd9a626314bb9dee746050dfe7208fdd3e0dd707cef2c94ff25c0fc3ceeb9b7c9935dc3c31f4a65f4054c8aff7307ebb6244e78d45964e80afaa128be142b39637d050138c106c2f042b7ad1319b222b709d7e5d5d642bb1d956cc9378b5852ef716a0ddba4696f12445e4ec2ac9feacde7a1423245e201b1c20c89bc364650986c39e414e8f6c666b792eb39ac14e2cdcd06ec3daa64c1492f754f226b39f55a622c4698171ec42cefb8c8acb23ddfe488a466d75ed4fe19fbe813943ecf57cc2ae486e55a304dea80deb0eb462c858bf10aed1dbc64ad3e42bc598bf242976eda1a362017bfc67e80fab0738b019c99f7dd012e0a13f7632138b2166a95ceaaacad7ee871453b7bc0718284a3f816d727ea023521790a33a18298f2f7f50570bef5268a3f222d4c869850fba35fd23140cec9d58365a9fd9ee6ec6f74f6f952dd005fec40b0dda3ecf14285819beda1a80b5a4fee5b573071eaf9c34931736fd118d5047be7de5524559b9812192c5a0b7da5b35f3fbd92794c11efc2015f16530bfb1902dcd0378438cea6a80c5ed45d2ba8d8bc3054a40a1fba508a84e1faaf7aa68d52ddff9a5868e1d841258dfc639227c260c0af85f5f886bc5057e73539d44e872f4759341c0eec8380b923fc2d90c4765097176234d9ae7cf71a572d7750ac0ac70b4b1da77da6a8da66ec6375d2468c682634d3a775178335dc96df3fea532938c2aa016651a3201152a7edaf237687319750cad0baed5f342c9478afefccae616d1314699ef1c86e0f457cd33b531a4fb9cc1052ae3be4148d3f20aa533925bcee9a91310544fe6e8f24d6fa124b766aa293fee0851a71fa2c5ce7160d729e19952851ea646b8267747c5f16c657fac173a32e02feff04a92c11bdde3a34a50d2390ca62d5cf90c9b1cb84f927dd990b2ba941cd8fddf172de643d25b2866c485e5a674ad6da721f6b811027e22f341f9ed1bd86a0f6a79da84bf823b27b3485a43775e49a15426dcb148cf5057928737fb06eb543408111e1d5be963848e55ce40134f2ce7a1282599b25a4b1e06bc88a59df48ead9f0f65a6137ad3755a19183d507fb9b9d948fc98853e1713bab11a25ce7122b310a45df971ab6a68ab720a48e6ee2a98c517defadc5f2e2be3c09e4dfe44f0298cbb29683eb1ba1e1fe7144e92b46e272965fc1bc1c353e1838020b1a5b9b8551bac74efbafe215b55d612dc6382840528747f3aa760bbf675a7acd5c8131cd07ef077fc09696a7ce281473b5f73cbe756653b88e0905bd3b945c07748fab3cdd75b7843df63f71f627932f45a72bc111bd62adc9c8de79cbd9e31c76bdf8c0717082092422680d775459ea25f762b3de485c453564b095c4c198b6da1f7fc01ac5d7983d472f59c007494e0bde30f67fdd8c2246dea62cb6d27bf67a01f8b253803719f0f8960c32b84ca926f0fc133154bd72402208267e42ed1cbe98f5323a864b6553a044403bb11508f7ced6cebfdaec3654631320297200d421fb6136441eb009c411996bffe9de8a77d0637852998d2e206734dc3c8e1d19849b27e12ccb3467c145ffa12b37b01ea8bd269da99445c4f0812fca2922ed4bceae35c612b35a7bdad04462c75a1b00206dd21cf8879e1342ce5a6ae340a3def0e964a184408071a7e6e181a41ab708dcf4cb59fbfef4c097b61d9fb3e69dc07aaee95cb582caaed812bcfd858950337e10a076d0de488c2dd2d8a6d51eebe370c86e6ee61a870096a0154c3b45eea942cc2de6760660abc1cee186e83f40da1e84c7ab72ab3535cc6a2bf95a9063ac1afaed16451d78e03fd744d7139b0b8b8944675aa3fe2071dbcc003aae2775e800d7b4d41e86fd9e4b0479c4130e529f39c5359b0f05173c49096d3b7c018e12b0a37c9e0a0e2419d69d0ff5089c333bdb21eedec39dea3ab6d4e10ecaaaf80aae3337cd25308e1cc3804f0a75cb18331c74aee76a648e3b7f1b14a0b8927338869e6207e962136a7d7310d159f0540e141a387e0549fb8e0bdfc2801ca810935cc681658ce2e9af77e2c1fc6dbd643d9649e5cd78cbfa7dc988325c19e058e6b3809c42f444040890af7c3d266b89816b58c43cb95bf05504efecb89e34a0c5997526046efa107410c1beb2c17cb9f10111c9dd12eea46d9ded255fe5f6aaf5828ef67d49a8f78751f6dd133a0170d0c7dd01989eb7391a87488b6143a59b278e154659b883bc58b1d4f9f542b1d985bc5da431b0938d1ada5b2ebc015ceb7fbbc2a5227e7293edb4a5cd78d85b550669aefdd135edb8ee686b1a0dc01ea3a82790fcae4ddfe240ddb387a55d788a4f8ede375d58cf60822dc513767cb7eb622c81a8c3b98c067269dee5288bdbf65b66cda6c5846fb4bb7ae6348ac3cc224238638a4a5abfd09ee47a7e59b1ceebfeb86ac5e3fc525b7fc6aa8cb939029738c5fa0af2b40e2997e6b42feea83553efb76deae37e6d1c46928ad7fd27cde9e2c173aa18776caec1d752fc7162a92e824b8ab4259a121625e4ec890d0f7005071d571e54582d320ef196d1adeacfd9ad2d0e1e3dafd65e78b1facdcbca2dbfff60fa7a4d9563c8b14887a54de213237c3a4ed91b50208ab4ae15fcaa74f03e2e299e640abf6158c4d6d24b6fa63d5835f5ab8988a411e406552540aa4416198091735f24ea9bfaab410aa9621640c140ade2dc0b8f2cbb8aa0229157a9d018927902535f97589401f6f8b247b49a5541ed8a5173b5b4d650d47056877a6e8263063d55267d7ea2aea16a201218a14d427946d3844eb56cecd2ed3cbcf7ac2861d2ea4abd6916d1b34ce427561ee2bf79e142d1e7740774b55678b2dea3b217990921f4390840e7cdc6435c0b51d81f3df0723420a8f877928e475d3ec2b839417d5204ff613668047302179f5407e57e2e6c683ff3fdef90ea1b8f7a5453c7245c96604de0d4027073a1f2af95e1003d7604e2f74606c438cecce3413d2a54ccc7967541dc2581ca7c62510e61c74314ff01028070a6e943ba2db918521b344f27c7dd74d1d59dbe36d43829879b7c577cdf4d1745fa8c25c74cf130e8d2aa94afc9e31176598b6697f80379bdd79bb6e3769fe3f9858611163cf152592e1000073c00b9be26e2156802193e990ef12a91ae2557e55601c4ea397959e57d64ad55bb758b22f9fefedecf32a829438847789f497de022f764b3cf18042180a09a6d9616143d20750dad35a4af5b556439ee4a575b17d72d0ca3159396881e5f15e4e61fb1164aa54c8660c39d26804258fefb54423b1d49b95775717124bdab461ce63d06bba309820771623a6e78250312fe5c7d2c81e301f184da04fa904104ff5bb2867140b87a89f710ab43acf4d4d220c353996f727e53bb53e6e9e581e8fae5f9977000e64c1aa433af304d16b9064e9a7d13f24c69aaa4a7b47b288880358679ed51f01d042fc8a7aa3053bd7878e345977d7351a04a8a4786d19624ec3356deae9377fb6270b932e6cbffc6533cbe690b0eb18324fb312d5b12c270a6628bcf6165dd5b9695dcfde0180719c127a93aac385700c0e6b7dc61db85c2ad9b344e52ab66e2f6f4c42182f63ed556b1ee18e73f1146244f69bf7bfd810685318b8787b295b83decef1f5348077e00fbf1121280a273b6d98803b2292f9b4273c9db1f5089c4ff36b4f618cbd5aa53eaf10ef1090889da9f56ff00c448ab5892ed7961806815fe150625ebaac44ee03d307cb9f44f2784da953b38bc2d7de803c026e40776a3ca52b9c6fc6503bc7c36dc95afb7ac4fe5006d43bb081cc6adabc350db109e5bb6f1e76b4278de02c1c7a816b422c19cfa412d76bbc11904a3950b8dc7ed65f2bb55ffd713a0fe37e939d8e78275283d00fb509491f913e0385e53efe1930a5ec8c2bbe318ae9f8a5f94bb9596c4f5fb81a1f37bc393fdbb6067e8600673bde0c9f227aeb8dde431e8a00f79ff907d43d9002812b835801723313d7e8c4eeab9c13701d55cca21a62cb83b556b9da8b6a28a86cc820bf3c44b22872f60b70fb0f1b02ade1f8f77ed3a5e4c3e4670b46731cf22baf1c14defcd942fe27ae9281331e0b330f6b8861b41e3ce9c6a6f198ddf20d1082cee956108355a48790e7fd40e2a5823a1dd9f19d5704b0a50d6882705ae94db00466e56b052d3ad36dfdceedaa39943578c62ce539bbd3b60aebe952e67d9813e7c3fccfbf9979ffa8954e161d98ea6b7c16a1809b9582675b985a0d176d52230a995668714e1fbcf6a73697f24a02da660a9e636680685c69a0862a748a60ff217da4916791cbb97128ab4b9dbbde89b221f8528e83a941877546e5036b451a13f69a3713ff35d632ffcfec08eb5ad57bfc17fc8eac35aa5de14be8c3d378088d8ba8755fef0626ca90f411eb07d8740b5940c3a172fc1572e4240a7327219486d6e99630f956b42139955c01752d0ad00f48b2ce65add42ba362f3ff382d2fa027ff5807023756ae66b2a4b27f932d8375eae49e4ae7734c885556e6ea8b926fd10fe1b7129ca08efabd63d3ca3b9c0dae3fe801b5232acb1f0d40341dc78e049e27948c1723c5163d121f46e4d688a4c263f58fbb0ee5c50ba9d3dcb3e1f4bc5859a244eefd8ec6302b49e1e070e872eee07bacd7c5f267b74e5bc3ca7491889d9e629b5b79e6b5cd5bdf893c059c51005d89ead704672641ef5daad456615a5f55e1323fa4ee99e819cc85ecc724c04cb2454d7ce305f90a23577562511f15e0a4af9ef739c58105b5ce8c7dfcde4e784af6b075bcb0f95b3afb742147b5eedeb575996cf263d084b0b0ad14c4506072f26781679515e15849136647dfc8c822f5e479eb63f4b932374d0bb854b4d237d57c9076449a48db8cc4172dbe015d10e77f02eeb11fdcbbb2f7b4de3b3af4440723634307ff168569fc5e5074e502601959560d0e45d441180f6f75eacda7ff8ca57770751fa5a20b36f81266cdb799445b9190adaf85d47dd45c422811836fd575db28d10e14eff4721b0ef58bc48983a13cdc6de33157d4f1ae689c6bca0e78e49cb9072702f439cf12a06d86c1818b0fbb05ab5ed8caab0fcc6ce5d7e1f77ace8789c92cd9e46066e51814227436bdfe758657be039a60e946a29c701790965f25869eacf08ee94da66e434d03c07a5088e41423aec73cf35a52be0df08070bffd8264c0d2c66fa919f07d70bce51095fba5e6cc52582fb9df875986097f3cca69f49208464b1da1c1f3d48c2ec91272bfd89dab06fbe646b133f71c4ffb579978cc6f73ef6f271a63f219e2a2bb876a1cfe8a663297eea904c1cd69b385610c7478bbd3496312d534f1ac285c5d09d60994f505da599cc03d373620d167bbb7b357fb119693028bafa4ac28b850a0559d3dfa87f0bd76d0f663e5e17fd97efa82632a14f6b715c347dd63f4e3fda0c84bd669422a659f187e40c5036614cdf63a49a668351910351ad2474eb885c4f8e8e45c003f9603cf9922857c059dcbf951aa30211dc6cb0f7b2733207075dbd8d2d560a3e45f4a31d7c22a802922f82848474876f260677f8ae88954d9d8530e7b4ab35f918fd36e526c6fc474b3a0407d053ba744951203968f92ec7fa36fb71600b4dc08b64fe63d46857b5483950d4ef1e1e710619d39e96008cb3caa7dd33df488c099c10496404b0fda81279f1801fa0bd1fab5925d794daf4db99762ee6cac98f7d8aba2ef1bd19f53be40e3bc19d31fc84e556ebe451338b3b9a79e784e993175e173601a67e9c9bb0711ca5911e5ada2bc39bfa6a9ef8e03c806e0929eeedd1eb50da1a3fa269447a80e79ff2e6c626d0bf8ac2cac9d24054267b5ca1f5f7d103f15131ee314473b5cf2221ec53ab2a20604a7d44924fec1c6aeb96415cbec34b90ebc885ec56e6c592952a1d33c85f69517ac14dbaed82cd9f9068b93b4106b00b8be8539721764a5c1598eb368fccb0fa19b3f62ac34b2a46fd876440825d301ce07ff52464fc4a0dfd14ad821234cd1ccfccb0bec2c8d693e7e44dff2a7ac50f9011c422304957f7138fe7b2e3bc440bdffc11ec7c6c1225f337be2d11d735f0ba8be2ab3659e09b32a910a20bc5934556c112a6a4277a9867b67183833622f9cdb37bcf652b2629a6cbf99fe4a75b5213dc042a1ee3ac1d08bfcf69057ae53a2fd6efe0d3fcb2767ad5a9a6e75bf5aef4dff5e05e56f1a744962c85c945b2d363339e42713d17fe5b45b211e4540c38c38200dcfa21976f5d77d1f878ac7fdb18613511b0545b006bec1f4b98445896c59c9bcae86145f7ca0aebae034e88cee6007ded04d5363915857efc13e806f9cbc9254883e8c02bd14a06195c7b79c3a4f62762f8f9bab6f41e0095e577ca58ab7dee4530e9c7b30b40be60f9adf7f3f7653359843d31b5fb1145fc5d102bb58656eca584e9ac21b0dc26ed939ea87114ed787c827189913f44f220c2eb2d6434de4883a36b3d8e6e578c67e7b72695dddf4ecf235c29cb1eb06871c5ac07bb6adae5d55ea46b3c0ed7db23fbf331678cc2ca0449bb06d429cf57a7d9227178a9fff779478928907caab07896db0ec720aaf1069a8b369fa0c5e65ae9401b2492d3d81738ade1ae5bad0fd502cee9c97208ece3e77d1b0666b2616dfc01304c80cdc054ce4b3f94ccb9b868f85aee93df74a161435e9e8b9522a09fd02f41e9c59753e987629d1ffc69583a8fa1901a1c34e7637eabaceb984013923744a063e74eee66435ba1cdb36d08403db2c83ad61124d42ed6e796b60ad1fe5ff7fe44b295ebe1ccf115b017b7d2acdbe7b3ff0ee0d4d17b0a4b6a8f5b748a22016ba1f5bc567998632a58cc12035d9226d3d7ca7df31770d12587088fbd37d4f1075205b74bf2ebf3a9cc790ef6772b9a01dedfd88dee94b60ef7c174af3089deed1aa15c924687147e7f29a1d9c0468b30a68167365503da56298e1c597352cf1388d362543082e69c972a3706101082685c25287d6a88f41c42cc20e58a36102d8b550dd8254601568fe0aa7a88cc5e9dc6d83ee4fc7abf0130237d71483336cc4ed511c2a2210b16052b61c8d3b4257567965ebb37ea065cd5a8261c786e3d8ebfe0773ee7f1821a6fab4462f38df7ecb8532c23fd92fba601df5dfb92a3ce9a1c12da6ec5f4c640b1d7cf8999d589491721e79312f1f18a79b7165cd3ab3d47eb620ba0b450e91048da27d88ea74cbeeee90b47eb0b8e074503ac57eeb0a43d1867e23119caa1bf14b46b9952c6634d6a1f3392464e3e39e618cfe9c5b53b7a78537f5bfcc8faf42fb84aaaf79b11f5725d4311ea39e98955edd4d9797f0ef26873bfb9834f0945603dd6a9c6dce06837ed65e10a585ad0dbcbb5c47dc69ca7f77ed76246513260d2caebb6885f65555ecd3abbf48c8ae3b6dfb8ec1f842cf6e3144e7070ff6cff8cfa1516ad9c7671bd2f5d7ae2cf5647bc5558e5190c208627653e9c2f5ef8ee4d4929d8187f256f42d4bed69702c8b5d479ac41c70cc35a86e8352775b7862f2d164e63e37a273c6133539777a70aa3544432e4c22ac682c22fc2e849c2ac8c929b846ee8f7897daad1c5abbca62c8815e5340d14e28f6553d979a5dd6380486","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
