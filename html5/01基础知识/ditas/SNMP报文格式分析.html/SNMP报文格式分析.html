<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"07aa9bbd83010507d3fd2effb84b256c8e267c6df85e04aa0008cf2c7f9f8801b5230430ede84a59ec9c736782b3c47865f6f8ac2348b40bfca066d7f1013e9dc2fbefa58778c5e104d43db1be12ec7b3de9ca5913761cec386672ba3c234033a8f03a02dec0567c54513880662182355a0ed2850e393a535620db3ae73aab95fb2b4ff53e90107089118e1ce0f157d902f0301d99f1043ada656b0e41d35b4bd87eccf6f1142e7f5ee3f23e7b2298971ebe491aa01c746e658d7a8bd9c7c6d9bb6e91aa160d323077c64d8ffd6786a8796b8e42d2c9b0b2fffbeff767ed812ad277d70bc69a5790333e051b9f5f1c724bde9127289471bee530e58b176cd80d3175cdfb0d7db9b4aeba723d49ca18db0af8d5d1e10c7472de991fb4e1f002f79b5491278dbc0b0ca3d7797bd6ed62b4657a918a84b0a40839632aaa80fe21206aba0b09370e2f31f2d497afac935cadf5818972c3c8172e126d1d38e32c8a223bdcd13dcf52d5ce65de875f31a761456b7c06413721b6569e10c869cdbe0710cd0eeb7c7ca8f166283f3e6cddf6221fdb74b3a0336e7af5408a41fabd4e1bd0757b038782075c7bb77fc2452294547f27c6a42d5a558047b4e455639e112ada40ac81acdf51346c3fbefb79ea9d1430cfc44a72351a43b8011ce9210e7548d7495a1604e668e0a101f30a1a3aa8e842315df82412b7759fa310c703d14fc5b08f5430e0a05dca6e5bf805fb7ca8b10861b4fb263a34696bf146f3f5eabd6a19c9ec5bab4a2d7c70779bbf7db9a6185a8ac3a1ffee805dc95665d57fe2aeaa9b592f1eb410018ea1e3c961742ebe4bbd192e129856a1d1366c7a1c7cb9055b037cdc7842bd193a05696daf371cb4aac4047bb3ccedede4c160d96ab1d40a50d637c86608d52c6c28d9fecad9f96cd2b63ed73db2df6b352812b5d841e7d5639db99fc9f01e5499832806757506e30d82bd77c94ddc2c5411e2d5e6a2275d64ceb08f6c7758f75164947eb9227afb3f3caf050ed6373c4e99c2e906f2fd273ed0ef89e6fd9ad2c0a78030ba355d831ac0ffed3731bcaa9a47c8a8c14a21be92e011443553b5fb25f5fc2d8fde140c2d151b5529b41cf6e76ec728954c0a7a01b24f4077ef66346b4b1a9e585d611a1caccac5cc31235cc5029bed2fc49a4a8c4045eed003992a1e9c6a6771428a5f787eca805f45b47627afda3cbb32f250664e0d5fa2992172e80805d2a4c8dd44fd54e60b021dd841f77627f485cd998bb567cf370e715d3a67eabbc9f536e567255a2c337bdc8b1fd6e3af7ff573d22990fcbf711d2c5a854427e3fdb13c1ab372d6c3d7caa24bdec0d1b8a47ecfe3d1582acb7687d4eafef58cc83a9797995176f5be4cea299afd9c1fd134e7b1bcd8797e33c1baf9680b8f2694fc8170f403189ff1face813ea60d627028daed6b86f464590e4266d57e29cc16b48109580260b1375eb41d65988fdd5f2d760b9bdccedd3e4516d65214bde859e6ac9edadc7a7d7f7a53e6325b2d9aff73bc0b2b7fd072a7364f6158e6039e6995bc78cac21118d8461ebf815225e97b6fe8f1c2c1091324c7c71eb09f2e5a0807bc768b92c227811193b5a33d31cad4db335bc99fd0beda5207af8000bca982d0ce60feb1b29c887354590d5283da4ac147695263d5caae231e1f047eef1a198bae9f16fd03c3b3ae634e7e2d58e302ccdf93efc0999ef5985c22b0650ab66c86a2a3cce0e12b3fea4d44a3cac5f6d537f7818b83938692ba0a30776884d1b1841f7e2f3dd46b592c764ddf3ee7514aaa549934049ed879ef7921b71361e0388fc90706b548fa502da2c835bdc7e6b01f656be48ad14dbb5e286104e07491b8851751bc85d037c2f85b1a3d398d8ed652185c6a11d619a7e135047a5bfb6912ab35600ed61bf66cdb3f791d619393746e59f90a6f9e9eb1a2d55079653a8da1267fda4ef644cd793de3e726e34b9fc7423ffe87e8023e5592d2f58895ad9c7bd86be73dbb79ed09e460ec52e3ad7e003f480b9183d340eb927c50b0a2314629181dceedeae01ab3616dd9236f4ac4497a4c578ac2da457b3f5b247ca6f8ebc8359c3393505b3e07b001ba7003d7c984819bacecae15e25ed52b8c7eaf85486a13ebd35866f0738086c8a7b2fe4e93c7fd8e56297e15f25eed3ee2e0003d4e808537e20d2be3f06c6dcaded17358e998682de5a3500956a15e55a82c1755fc38f5f74f13f8de80794d79b64a915465c24c3259fb8937a213b3949bfa6c06b32200a52bb6837314d08dc6f1357b94f1feeb6039da9ba26c46f145d98b47c9a68d3e83e632d02e899a5a1d6459361b1fe043d440522e235daba55f2e561544ff421e29842b6191ab51d5f2e5f0d7b39c2c03b41b5fdc4179644697be17e04d0dd3cdf5c4d99ab444d8aabbb974272522f7f06ce69052a0c812150f97481722a4cd3de82e2761ff58c14d25ad5735530aebde41f7af8d6c8e115f72b17ebcfbc462a50ea9144df38d91c12e5b5ce3548fb8063146dec6c54f0f902f70a305e6ef8bc1ad71b5851f356893c26d37ed6399f272ce0e93d7b3baa0f4f8c03a250ee989e7b83718ec53fc6fe6f06dea36182e6a4bd5e8f87c3fb8f3c2191b44358fe6c1822c5d940780cd410adf05c07aea1e039f7a9e42b67749152bc4112a90cd28390e625baf9f444d8199641a368d0bdd1fb356bba250414ae292ae73c229445f440638aa6e6a9f081b8d1ca18a2a38f97d2ffefb5acb4e3f19a884d8b3acc7f9f5a3cf5a4ff4f021788c57c8db703fbce8010d0e5bd87453a362838f80f62f3eda20225f494096a757be6af1f7c34e6a08fd39b10e00070ca1a84880340bbb10ba95f62b2cd38110d542f6142017e41fabdeb4880bc7fe0fba80a8034a73d3114e105f776cfa7c85ea878ed149ec35df6c201932ced02ef0fdf4f2bcb25583182799b539453d3359fee56e70594b396c4a0702a895c090c73205c45a2cdc321e7dc161cf818a3688f3ca97f27068ab4a5361ee7bba22ed6f10a462e9211fb7de73e83cf45fe285195e1ea64d20f277d7d81d9828f64594fa5e618ad612d7a996d2c1a22b0af41f193cf4f031d86954c60cadc93ec062fadf423f1d3a6325bd4db77a5e7c76032935a7b6f36cb7a012c63ffeb731bec9273cf16d9ccfc5327f6d1e9d4474efa0c249b751a97042d0169f789de82fc1d6d614bb10ef75d6bc7957e316268ebe22df70cfdf796b1fbaf4bd55e06c1aa4a3e743ad96ee944f180c6b8ee525e624441372aa3f1195fee7b89c2cb9038f1a59ab1b2929c43f5eaf7f9ea38702de37599d3c247fbca028d47bacc8c1556c33efbdfd537482f4f7b0df908ef12d3629db79ab62f8298146ba204e99071a227fb575c6575d9f6e393f5899d2b9b43158654b073c36f634fac234d4fc4d3106f111176a92480fd49a70a94891e79c0af57615c8e079f64c984ad378302d14e83d0540b2dcb08c8f81b90658fab00b976a031c97e16711ec9ef452337ed143c693a1df35176128009feedc145e53e0c1dea3f107547fc176cfde1a2f292b83e7ae70fe5937faba86016d47be39617861edd47313e17354fcae3f2ae61ffbda1a363928b4bdadc67f890978e54462177b9635709059cf17a149654a9256d600462f29e06bcca6eff30c9ad3a715f299735d0f52b186e18bb143dcad34453bfb30e46f7b1e31293f9a4ebc23e588992c173c456676497799a650d782a95ef363d15c9e608561a5b73ab6c60d2d24c1021860fcaba5c7aa2ef165d6ef7d93585d9982e08a9b980319d22cc2115672b585d19a7ae8ccfc98af808ef00d81760e665cc2daf4b49457ef55bfafb9bc9998fa5689cc022ac6c44cde559a1cc0bbd11bf7e3d976363d5563920628464f38fb086f1c660b9ff07b5192c4ddf95681c299f84c25c7fd04c879f42c37ad289f679b04aa14e8add5c7f397368f82f822b295e49cf3d79e23220f485a43270f1e67db0666fde39e3210c62e826377e3688e58578d8f475a5443042ab173efe2da787e8e0b9fdea08cabb4b347448b9a4fd5f795d1eebcfddc8714f1456b47f8167706cd443005fd798da2a35303348603814ca265716f8f666208e055967eeff8efb086fe05cd04c18f218430955920c96ab22161b2836ba115f0f95bba25baf39000627b9bcfa6a9a3ad05dc5803484ed167be53b4f27761445a1e24d1b5172337e902ed73833537eb3ec98a9796b3d9f7f58f8db269370c66bbbe7b2fff4b1b33a5e56ec502531d46b344b7fd59106c119847c3c5893cd1c323b8c8a0c241a91a4f274aaba481529fe1146c92a7266fa7495e161004904d10b66d805e45b26eefcd2bf88c288c1497e92ada79fd013b105cf287e85e188da9a080be586e2df482924b4ab31ebacaf90d1cda462f81eb6a0a3c848ded218695d11b061b40565cae1e1373cbf0f82504aec5c5f211a71b88424822118749abced0e1dd6a5eced23c613f7a5c3a198f25ac19facf43b4be46e148c7af7975c685f4dfba1048f363c07d1663075a3eb8ecb86710da3cf63d9dac9bdb601482a3cf75887d342592c7d698fc44fffc720cf42215ac44b71f7b2501768f7182c02393e583fb852ddedd262ebef23eeb3bde0d2446e2d08372b2dc995d2f80a4e85e32af32612e801d5251c7eb91546e60dfbfe23c1fc511b7e3f067c4ac490726ec7183db79868587e8ffb9b3db4293cc5ca083892b1f3774ff7ad23ad62b8426897c199117cc67b29db8ded4fbbe824471f9e006a08d52493de375620878592b3a01b71b4461ea23b661cdc3e52b274395462a70d6f7bbe32008d58df1572e7b9d3eef02b34be6be30d7bafc599f24a9ffedf3c07e88ae895811e9ae2dfae0753033cf99f30a7b51a06d1b0f0503ce9b72fa732cbd167db87e0e5474a3d28d2c572932aee22bd759402fe1920329de71c3aa979aca6e68623671288b65d506a736d76c2807a22b218013ecac226a429fb71ff99134023662cf7dde4f995f4a6b7f1d3eac68c474de56e6efdd3490261af9c03df33b6dd3f5b74aa53b0de5c944953a15116dd7025885a8a19202577c43825adfae8b41ee7c468f946a2b236c7b577acb31c7959b0a649ccf05622325409e5bcbd523bf556a3a8b7285095df0e481cd6f8e7a06c9a4087fae42f2dcf21a0d20048cfa5513f9cb3d284a06a10f54d13f653432c60eba57a07de1c4e2faa0b824b526a6cb99a578eab34c3bad77ba3198c64bbfe862006622b3db5150289559d7ffaf6a17eddf065ef3e9db46568ed2a7e4f77b9e184d907de43ff8603c6e9cdf7c910f7aa198db38edfc8b02a3cdd6f5077b15f707f815b4c8872d55be56e94124247a7d91e7ab1f6b598b34b98c1065f9accc7e49b83618cf69f5e0c0cb949ac0d9e79e63cdac3119b6ef34a60e85dda2c9b17bd29048c73249801fda27cd9981405764a5e6abcbcbc70dafe1875490971ec5d0018f9e0ca627b31f82db7f55b298076f08ae53c9bbd921a81ca17435c18b4b639eef9e623ffd38e6e21676a03ef5a0b83b1e709c697c38dc50cd1390e0e2c5db7b5b643f28b1147b475b0aee386fca10ec93380f363b98fb1298a322199efcadd1aa6c773560d31e2ca2f0e425b93c0e604482592ba3a4335a7ff88dc8fc761d116b701a0d64313175a54784a2a3c43b2f6cab9b8f77e1a5d329a31fa530165b0291306ad84fd91c2d392fe72ee33b8ccffbb3cef54dd4ef26c9b4cf7aa93ddd7012dbd17fcad025bbe257fe8be326692f0486e5691f1123c36337ad0bf16c1da91e4ea438f7549fa67ee71301a07da087a2f43d84d81bb6ca30afe1faa5fd61fc523bfebab37e9cd22bfaed504d3940d47563d3d98a208ae8ea76ca6947847df303078f04e884253d44407215b0a577bccc6444c3a57bf29aa205b6539ae0b2fc5dedb342bab5be3774d0c12149407914b142a164b692b9bc4d8ff8fb17824e4a82c5e09da6c7063d20ecbc5a7fcf163d59208f2816f67af53352f56648be8c330ab64177a8fb878afa0510eb273fa8d84b10b5e863899dc57dbc99e4e6aa73d765851d3badaf6d0c5a4468881b8b4fc5323ea61813f9a9328a6f483d681318dbbc4d9d48fb2f869e1455ae27352560adb17f7f62c8f0c33dfcba701bab0195f4004c34648798eb734a3d3c80591ac4837c5986f7a1c105a445aeab08c1d65a6f7220bcb3428b9ab2ae200d376f321a6ef4f09f060727b7960093b8adb0f6d6d48454b1dbf0a27d3ca7017ef0735a4a84a21f6d4379bfe817a365396728737ec014b3fb9b5cae4803c34974b7dcf8b3f765ba8c28216d22ba1d3934ef98ac3766b8ebc33441e7fba5b17e04078fc78df9f333ddadd927bddea25e4f36ffa0f46a62bfe4cc1f9e0b05359ab8fe14724eedafc2440b91fcacd917428db7ddab37865aa69889ab370617793b8bd217f7c6ee4129a78b331c3b62b409e2fbad5d488ebdc47785a524df76cf721f305a4bf5cc3a646057e7b72a91a01618c40ff3ee9aa040eac08ea553b4de2bfae738d0dd12eed2a1322e6783547d91dd9eb28ff8a18207b99db0b563ff53db2d1c062f89f9f9e2e4a9f246651c0962e075f3c17321c58ddb731dc9b10e63627dcad13980523113bf48328035634dc15794b9b486ff3cec78d1e37dedffb012e27eabfad99de612b896f9eeacfd9a2dd83b73bbdebf0455f2c553baebbf55a2bd222486e09947437ecceeb8fa573b2364b809125124d2426b92675f5965f4070a14026b2db6714bff42b8ba4f04d70b802de9a7efb61383ea674c6257ac2ffe70d5a1e34873d3835c1e1dca5431d9652afd433464404fa4d9574c487ae0bb3a75e62ba3f8b0c5fc4039e327f57142605e94cc463a3d4cdce65f2bda6cc3c463c7d432c8c619c503927a40ebf97f25ae6b3645561ba423c09d2a0959a39e91d10f96857eae11c437280d3ac6cbfe8961cb9e1e75f42d15bf93044f16a81729b1f58877992a88d76d279558db5d10a2c83ea501a41a145f021250c554fdc7650c845d0a083c7b8efcfee83c336b247f38023660cfd345f5837c06c4269d8be2588d4793c3a6ff76798c02c0b8b1804733e2cfe3c0edc79532308fa355393e43d0609f85bfb1dce8a58cac489c1827a2ff4c29e840dd6e5679415e9af3895f45b7773a97f710c1fd027c560c7963829937740b948f509f6a62bf6ba7e30c36a5346774211e312c76956010f74aa992f614f322cd44cb0620bc2d54dc8f2476976f9944a6d6f3dbc06f4a128f23200f13e9e7dd2d72cd1d38f477a2569be4b8dbfb39e9513ec492a13c5ac065fe29ad217cdf2164af5448ee5ce33acfb7f7c0ad394594b2f386184cac4467b2ee0bf2c4489920970f1ed5f75ed09983c8cc76b92b9718b07e0f577278fe116d0b24b5d444316692f5aa0489eea284b631e078d2d72adb7b7b547b49022f2b3a2266f0ed0dae375beafd150d918deeb16bad5495d77bf8acde4fd0ef12674caa93d1d3dae37106d799094f4bd5e9b90250216982af5fcc1c24da29c74fa0d25460f3ee612ba3a15acd63f040bf0ee0589febfe09b32581fc7469b64b268f6acde995ab7c7339c35ea035f3b7241f1ade09204adf122a64c9f54c2fdf45b497e9c51fa6d040e47969a60473c1398006c4fcdec03912a72b1c15a1d28947382c35a64d2685ad1eea98979d07a9ea026aaf09777526c2360c75de7ead88f7c52d214c419f531594cc99e22da31d1440dc6ec13ef323f471447fc38360e85938ba68ceb9a32d60ab20d736d86a2e46b57eef0f65ffceeac45a02193e4826973209d202872bd3c99dcbac9c0aeebd59fa344c5b6a557026f47f138532d39b9ff9d31fd0e19f453e84b4dea897ee5f943de331445efeb46c2475dcfb77643f7325b65424ebe22d2c656f96651a3530674f7c7aa6866c78cff6afeff3c175397b02c8d4d0ad08f8db6cbfcf15f5464d718a1fbfa80f8e0cbacabf87682d6a623718ff9035ad99070e823df4e0448faad88b8f755e46309eee19bbc63e60ab0cb10753d87d44123408eae4817302e49984171fc7527e386cb54f7bd6a26f35aed32968be95202730d138913dc12d8110bb34f7ce7855a4026ce4fcff448286e81e110be5b529005a81b37b720a9c8ceecbf18734222398b4a211482e05cee6f7024d6cc22724ae5af448036cb274e1fc782b0cadd1fed216b4152ec44da15227efbb10d3e9d9175cb44cd3861d28793e437ccbd9f897545e5262c6209c7fb1bef3288d08a68d2bded2c883edf406fffd388e39240282ddd74aec3ad471edc1802093f1a6feba4208dea77d19b0fb7034ad4f867023c3b800b57b7821e4d10409445bc6f1f85e43239b69f0b004b293015caad43747ced03faea43be867b0b6d3cd6e321b72400f4a60ed41d9ada8c381eb97412caf6a9cd475bf7ec5b95dabe54b54e9b432ec6cef2aeba41a80338e096b30cb4347a1874f81702ac8bd719b865bf25286d2818276bc08953fae37ac00d17f81507a407f06b95d1f232c4fb6b0cf0cbd63d88520076ef26ab9af0d0d70c8eaa54b64c0ae30132c96ea275c48bc0dcf2462ce613f886052807e9b2c20f093ec4779c9399533ba4aa9dde0ab822cdceb1c2c57ab6659b35e13245e86fc4a361ef378af96beda13b9a135a1ce7b6f03be68540bea1233b9437ee8c2e83e27f0750678d47ed69999e52bf1ef3a97b82c6c11a9376e13d10569daa4d11169bb6a85a0520263e9f0ee284db990a18168e3b0cf27edd188051db02732bf05efe52f83020d8ea7a9ed8c8af3e47d23601971a6a7ed0560ece578b8d88ae5cdce593fc0688d14bd657a7e954f68d6bb41a8c7506162027f3e3c7e9ddbc6589a2ba5bbaa3209d0a8f5261e8f15fca9f93a33167e7e3482971c2c9edc5a102f1d969b09819c66152fd14e030fa2ae460e48fa6eea56bbe0f6794cdc6103cb8e59db472c4b37c2a926e444ba7b88e18d437900f05178d38c6b25ad9d0ce66cb87600ad5b25c806f01e86fc341d202acc670384ad20f463e5b18467608aee26c16b43b5b3c23b69d4584395d565718415a568523d93004a1ea5b0c2ab26a287d8a4452cfe1e59dfda463d1c06eca6b90b4de2eea0682be0c3a8d367394ade4c79b38660615c092e235291c4e74fc1df6a3e87033beacb2b7bfcaadca2656a3808bba062e998a14d729532b4a15d7704c4831767a3b03ac3034347ae53971f95e9f4bfc282a4740263868984b2e7360e84cc3adc56aaacabc02013f79ad7c26cd061eb6d7f2517f3588eab992f8becc157756264ff4680d03975e66a86295c4f865375c40242b7e2929c0dfacfdea270bbd299bbaad14e07297d130bd21dc217da5ee24ef397b336d712b0abb0ed80bde2b69abf2527fe0a1a48c936c0e84ce8b1ff8df513d2c766ffc9972afb23f25e5cdcfeb84435733b207156a02e38dbc3787bebcbfd70338fbd84f970f82d984a9e0eef788c2154143f054515cd9f340401c81069d8dc0360665206d99bf80f863166015d11fe66d53a2af8ab2a9891a2da38abfacff9c626427f4a5d1a1052040c80550156bc7208cc93de174acd80f859554250b4394d061bb1e6edb9e4e2867e2e62e8b840458af1cf00555aab7997d74202c8996f005e494b889861e6920a8c1c2a10563d0ab16a843ec8b364696d3c81974d8301db677474859b393c3ca3d3c90b54fa093649396bc9b3b56f667e0c5c611658a865af580a21c5c3d33a8c91130faa548b417d09843a4f7b08755f2b827eb642d9ee2f70d7d3a7f953fefda828990caf71287fc20b352825f71172a68275c099909f8d3928d890eb475d8753e55aa726a06271b5c11168b59b47368babbfb1867cd46568460992c7d89593fc1bce2ac780232d78c4740ac08d76ec5ca2b1606cd16aeae5b4b8b778708298b86634c1f4430f1b68576e94ab6532e0d5c0abd787e8ce5118915b61d0d92e23c8226a6059f912627ddea741f3222da968a5f034a2349a384da32377c032fe827718adcc18ebf12d507b1f26809fd399434b5b4cef4e0fc1edc2985477f8d8582ceba90fc143510aeae829812eb2488376ab871a3a33326869a351fa60b84bf51700b941c60367d0507b6ba96605c6d27527fa0dd66411b6721aaf7f57d56d0832a52c05a8538ac8b6b96b32f74be025b5a3348264575a4230fe3c850efa11c1f9b167fd4fc5db8600e3f7edc527d4221c013a4255b898a32b6337f1c7476eca72cf3e13980d093c2fe40fa0d5d739b2fae36c5c050faf48e9ee8b03b3228bc10232374c51b79013e3b5632c0dbb3a3b599d93c1eaa92eeb8df9321393b7334e8947b0a888eab57603390ea75bdb3452e4088b86b6e28ac744610f7e8bd5cf655807258e97a9563d290a2cca9e91a7a7ba32c6c498f0dc6dc46463b78113ae9909182806c858c4ada7bbcc8857b29737bbffe72ca186c0037c70f43f096ddaa8d425c6190d7a1f51d9a29f1dab517f8ef2d14ff89de92633db3d348b879472d87eea551da4b4af124e58b6145b84d7799edd526e1e6fdfd46688a722555ada8fdc3de38066593becd38417bd42701d83c04b227960d27cace4271b5313bc3ef4905fe021315abd9083487277dc1b5dba97b058420dff1cd01d821355fac1c4f131bbed6fd9b95e7955068f987a3db90e12acdf00625813bf24ad4f986b5264773897897d344db6ae8c5fec1cbb59c26942d9ed40bb67ba3d128e6a5e1d6c8118d30aa21f2cd7be7baebb1a766a9eb8bfe1a59dcc17c1c59bf15a43b2c5ab8a7d93faac55f561e539b199313d7560a7282cd3b419bbca7a03bc8dddcb7dcfef132c182ed64f22f050c37e04e6bb8aff1a86ff459ed3abd52dcf84cdf65aed6f1e86b80449d3b228f72928039e5fcc16f14962a8f60b00d2f02382740c245f819b1cac2d619803f821f5a8554c9fee897561e495c30637d781427b18ad9ed088a5264f7497838fa7c1014def2eb5c73f9ed5820104913be6a39fed1a7bee31f63fe776c61afe357a67d6817aa4ea895f795678fccbfc950e8550356431c1bf314eac46018e99624250650dbac6ac9b08672a99b00fd92ec1f642de370ba599d42b282571233a36f9a6d639c9afa63faa690aeb90fe685c060013d1dcf51203d4121461b8119ba9a6776d5655417c022c49c9db9c32d942b31b36963672426af7208d9d4aa69485ae1651258b46c54484eeeb87ea0b182e720422eeac62ebb56747eb84351adb71dde3090be4b26ab2e9645af623fa64122b1ffea6933222ed396c7b406993b0ee9ccf1e4e3118d64d20d1c2fadd05468186639a852c046211f776d29e6628233be487d24ba282198a438a461fb54d1020a5496687959d8701e86d532028b34acae0f642ac6dc113d837757246ce0dbd416170b8e0b6d4ab948b9ff42c2e46209800413e48eb19e1a60525192f9004735f0b5f90099c9d34e4181bbe1c4ab95ba3de4dc4d640186d4c9a2af63d5e274e9984ca08b76366b45f63868d64542ea7a90f4ddfdcf577a374c9576773d42efb288bda5007b39813ccd8841ec4016802123a816b792676cf608905037bde90ab8a2b9e62369347ab94813ac15ee822c44fea1d0c5cd80340247e29e7e4221added9522157b1af5605be41c637a411393d3bd32f9f994c006f9c750dad9608a6237e7c3029797c1ce07ba2ab1ac76cc515bbf05b98228272e63d50ebedec244bddd6bb8974277fc07894360297afc5ac38e7b28193bdb96b86c849683cda08ced08b3ab4b93f1f892c4d52468eedc2c2197e63678a9172459b9e0b3879f02926b36c5ccab3ae61cae284933e0a205799b973285ed2fa4a917cae7f664cc861879464775a88b3b7186904185c2052ab6ec1bc9dc8197b56d2dd8d1c388a2f4e6a4c3766c2effe27524372a5ef052149fddd08a48a2bb7bcb67ba7f1c2bf8bdb9e51400273dc0d4be972585c2bb538703a834b61f9f3569ecd46fe7b25f3c436bcc98d89f344f49c1151c5956cdf7bb441e706d76d72494f52c1f5507d890944a8aae3e875035297510d6926cf6f5874b64899a6d56837efc8b5f1c5116fce7ec6e1a5c1d8d153530f04c85cade4a1b0f73dabd06e9597cd3383435a00a4db3fc3d1f01444b9b20fea3dd99affd82afdc6c9c3e0abaed3e9745cd88e4cabb810c484d4a1de15be15e22f1114a143b206c9341c580f71b9f719230fdc574ae833ac5b76f19deb890e9ef21f637942e775020e7bcdebb13af4db7771ba6af9726d9ee6e23130fa4893d47ffdf8e6a7cbdee427088f18812e20c64c9b178a39b9cc0528b0cd39b893b163951fb3966261c11befe1dd751c1821de13b047209e9613188e01792ec60653f02e8827a68e134e1f682a5cef58a35a896adb04eb662fabd2797cb43b2f595b50cc0210fabe5afcab57f2064b585fd3eba59064a472342a8bc4b5742322be95a04f6ca6662905da2fbff387df55dd80a94204883c98e611f5077efc618875c042675fbac9f719487c0bda3a684542c28c37193a840f0fa4e4843a1426f8d3e518ec2ec3cdb90dcd7c0e25cae90a27b3093b8933db21734a823097bc66034f416f174eee1ab56d579c5c426997656b1dfae99dacbdedb5babc367021d3e3d0c576f107586e7846d4115a78c8bb7d9073a5fb6f499c8813cffdd45628462ab7f73ad0cc48acc537284a5000d9676f84ebb2690afee39355076ee774829ec6c5f0611a3305987d541952b0b5bce1b7fc55c52936842c022646acc96077c04816b9b3e73ba6ce9c275de9c4afbd01d20cef64e648143fe35d04bd92b87cc06f77c303f22238340a106d41f33f7320400df5cf43514f781f69c590f7e29226c74e51996c90481b3324e45dd588b3c34d315be29b0cde5c4104a2f9cca4c88198064b276f078c578a848718483afae60b372d036f50086e49f15b341cad40a933879ca8a31bbf9b76dab7eeb959a1ebfaaebed8210b672a36709cb1c24e56beba76a0042918e3890e5a28d3d73e70d22e2266c9a245248d3fa465cf2cbc642b4cdff7dd790e657c383b41319f614b3de06784848ae6686708ac001c197c0c69ea6d7d16f269abb0f3cfef483ca38ace202a3b4a1b8f1d4db345d1f40f4186f3d749c87860659e1cae8df8d9a77f6411bdf64b1a8c74ff4ba096991ac321899f996025f33092daac538f7388c2c289f998c49058455b19b5860fa1bda16da00ea81a603aed75bed5465184eada83a30e24a0f2e8af3a3b9d03d24284d10f7d434f23c3e7c177b211a743957610fce1bc1d332890d6ab60aa0ed109ea90731b97b9f4f8bf8ffa8703809ff9dae458c57188ed2d340c33575fb52c52e434996e8923ac33c0b2feed29695153a09cb1a32141d74a32fc4eed292cb741d5c20659f5165509987ab03c0dde1b4576ee9b38f26e7652c4505d0e46ed47fdb8b039187205627ce07d056f9d0e8630db279a6f26e5e903b707580d0da7e695266cf0b21e155eac1af05eaeb0dc2cac691e875db50376d56030106f15f925c524e6d268b1c3c13d1373aa1def3056d87a56968e85b57800dbbfe451c2294e7c2fdb7c5f47e4a1b8a18114deed6467ec355cb629aa48954d46ec4efd0bae8b8306c2c6aa31e6237b8c44cf42d552542785f62400b9cf9a05857f56a608f005163bb3fe62835c4b0e09790358a804fbcb8d0a980ce82175ca812b45852bc015fcb025d01eca80d88194557a79c67156abdd6314c293351d7ef902d13188c19b9181c46cc546cea9eea4ddacfccae30f73bbb2254fc82128bf7947916397e740a3e97ff24fdc0acde1479d2f4fdd8ffd5cc374c2db51e57e59c3690ba07703f12f1124d687f86a4d8c5cd443cef61fd8bd9836e1257b2e8b332908210ed7d27d2f0b7727166c3b34bb96290e142a5429243e8a1d16118b25d71096e43cd82c1a6b8105fe7bc07435a241f5720205c748fdad8098c40fbe381464c246b3aec10ab19c44b3c548d305eb3b4e946e7bd475057333165ad8cb9d6841ffd7735b1260540b3d87ee94445417a8a2a1f6d1e736a28e6c87cea120fcde5761cd00fa38e7d19919aac2df2325c12db08ed59e265c46d4a6bb93c85a661a6870c94c802587ad65c26a4d71cbf0330554f3cad3eebbcd376b85a625c047227fa72d83f705297c6b540527574eed1f32662256f2f7d72f687e19bbb8ff7c1eb5a39f89e998d5e9e3b3ebaecaa4a104a2a8e73d3fd57f951b7e4eb6c45bfa1ffac881b016141489779f46b94c11b0bba28514dd1e1fb242f780f8632919476fb8462b358231a8977986dd5456722d4756598642dc2031d08d3f5ae081bafd3e0ea64198b0b98ac95374ef9dd905ede618e2435393f1af47b733add22009e4b601a1804a6923703d8f9c43770769d5d6e61535da5a2dad60b2c819700b3a66f430b9193713d5afb9c47ef435e69d1c5af9e698b226d637632cf7d1b9bc34ce4654c0c7e23290d75ff37d8c4f3fd3658453e8f4209dc7081bd0ba8b69798f337c29b1ec1d0bf09cd478145237f5d8d8c68114f522ec2c27e179974c27b782bc83641d0d6d6d29f04f3ee50489bd367efcb29dc4542bcd334b1620d42856f81c8892938d8a7a50505331ddc1b5d1a5dad6c975353ab72fdf67589eaab9a5700c6a70069925349211aaa5fed3082205a6a33249f0ac79644b634c7f5afad5220b173adad5a2dcd783504c018edd3a29cb525d0256458bfcdbb8f35ff58fd1b0b4388df5233b5eaf34ab51a0e0de788849f6d500750f9d1e43761c0b73b43526fda935030fe64868fbcdbc866d64444bf1aedd2880b8558591f91fa8979e31e04b78455a2534a81dd84f9f708ca03866a9324fc774e3d54b6cedade14231c0bce81bc8992434e979c5816168ca2484a0bff86a34cb51cae8b20ad88785a9810b189ff04da77518de4caafd526976e1dcfba58ae812c07ecccf34497a19b4c99cc0c42f4a6fe43e91957640f33bd9bb51c03d6605ca1308d8c7c0510e74580d75349d068b62647610bf661d5634e1005095ef2b012731aeb7dc8af47637a9bedd71c6511a2ed4a3db3a1297da1b2babc2337551b9cfe55693e8849a5ee7e5089d2132fa99cfb8ced26ef9eaf0faa5efe9e3fecf33d738301e6612e0d4be5baf7e29bc34b38b294ed1821d6f049a69d8f723fca4631ed60e550093499e5de2c7b9502f1b775c26fde4cfa7cd7cdc9de2dcecb0a2dd3b9177ec04d8d1065c7836a50d620b09000b6bc681d03d981c2522ad7e7a932983ea0e338e85f4f172aee0824486fc5255d35be4e7aeb41452d19e2f74c847f14bc882ceef729ffd6fb0fc6d8de64c6e626a82bb83bb45e30993e69858f3e1b19d42211223345a6b3ac0f57ba95cb5c6c7b6b773ecd105d61843b677c690297d3aecd3a14c75e956ef458fe44f5122e65bd0761673ed68095683c8c3494e915ac938ad1e7d3119c6a239dad0ec576e25161fc52d6f5ddb00d4ca1b56b2fe4ac7b49a604fca5ba6c424e06998f212f9647541682f90e7b428f2c101add92f7274d20d87ff0cd35d230f7bea87af11cd5787de81ccd6a94560c9ea1c747ce92a666b8bc7c643010b30979e3002bbb4d21ebf8cc775a90ca34bb885c636617609c2d11fe88d57724f670a1f611f33b5b560279d3fc5fca7b1717e035aa8d635cff0a882de26c973e213669f5b15cd226f8b1e3d7673b4b961cd8e0a846bee7fce425d9550ee4442723a439b95e12e7f6665062fecf51eddc9a9e92266a28849268a7af683eb5bc52ceef2f37d7f9053a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
