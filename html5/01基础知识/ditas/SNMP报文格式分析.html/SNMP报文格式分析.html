<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"80239a82dce553feabc9d704a58fce872459153a82b27e355647a686ea5e6be0728f478cdede41317ca747493b4e96bb26c02371aa96687c52464e8afe96297010b2c46c865c03df3f53ecb55d3e24cd80084b4ecb5c96c7ee8781daac6e8056f646eddf00af4997ad3970d63fb1af63cb03346749001da1fde1b7e4003d288ed18f687b2fe35b50a5dcf2924be9e616b93ecc11b906b1b33fd9ebe59f9ec6c50e4b280594e37dabb9a79a14c061229c4f251f0f1bde115b4f03b2d23fd4862dd707b63f1c8fb119ccf1d436f3b6e9a6c27c826aa6fd47daf3ad11ed675ef016008446bf8e0cbc1949ad40e58311d297affbcc834048d877a0005542c954da2d64b36cecc83819d4c8404d9a74382072e9b14bcf6d96672e34193afeb643a3a5a65b2cdf4b5e99f97d1f4a3d55b0c2584db37050cf96d9d0617db8e52afd1ed2d13abfa6df5575a6ee220f9b9f52aa63b428f8718a48e2c0e27877382717e4f9b95df9395f8c665b2b9fc8cef11a38c29e868f973c2766ec16f3b488eb10d78a2f2239734abed5abcc3aa3b317e6527e8a49f5fd6698de6bf61029ece0cf0c5fbdc6f56b1d32def33fae4fd1958d4c5f3226a344de29ccf2305bf90f65c0860a6599bdb45c1ce3c77c5e7d8673f02e069cce0325603c6feb6cc47c090918f58e92d112d429c89e1ef52e9c6334c8ee6ec6edf2dea0cdaf70fb8b5dfcc9ce9ee95bb9601bbea7e77880e72fe406478faebee657efb4f1cf592d3142529d8cc7871ac3531daa035143914d5cfbc020aa56fd51cd8075593ab06a399779a95611580ce274d045bb7558ec0a6c45bbbe51b89ae4f048c8155a5b20762d0e79c583fb143c143635628ad434841e2b773f13644cadb8c62f455afad10de0324b8082730fc6d560b28e5ea115f9c973c00caa4df3015bd777f2b1043297b454361143d78633e6453e79f544d3598582e683d02ad6aff4e7932ac54ca7d9633781de7a5dd9434628f6d2252fa4e121b206cf3adce4a5860818d6e70cd4b1346de7804bd2a2d56ecdf92b081cb45f75dfd94cc0a89bc3f833f02c7332b643e7c47058338812397f22458a6b9b61c40f1f5566deb942dad5eb9a66e6f8f4310560a327875e33d5f1a0444649ce6c69642ca38c16118b7c608ce9074d9d79e1238e37f4e429caf5c8ac8e75f89b579b685c18b088567799fad35e370a975a627025a5ca4c91e0c9e4362840aa581c69c8d7287e78b965cbac5a971c8067f5f42dc03025da62e68e49b37bf5843b2ac8424758b8f46e2336bf05a93d4a4d4b3837ed479fd9466a0a22efc5c0e77ab1aa8ea56de4543fc50986173e5da7178442a3a7f3effc5e30606d0ca5ccee3f59a61573c9bd12200251500423febfdb63d8b395c8a0978d9d6f1f1e5e968fee6fe8e0a94d2d208e6466a590b9e380a6934814b0ca94ab8ccf7d9e355f5cf273f504660e974cd74bd90f9a98817de95182a09486ec64039425fbab08c20fee7a82902988fc7a2f596b4404283f096c9168ba307ded039f6b46f75d9e14f69d7afca1884134d5d1bda08cedc96201c1ab912f22eb18a659c27014727cf5de7b2386c9d64daf486021e2b7be1bc9cde69ba1912f4b56fb8947bf21a7068cc634945e563a2bf3fc3211b7264de0ccb93f872a30381e54f2ea50c701ae3cfb779879b0f425f93f9935091f692a10cd7f773ca33c8a30a4c8ae292e888b674a8e34aa2c44ed562c905dd47a541fdaa032093cdd493ee10cb7399a620f005aa6a81c33ad542e14a752381a845a959128d22ee494afe7bd2a7874b2049be16887829e7dd2aa5b3aa90a172ba9895cea5a95b40b996811607e6d9c732b2c2784a830b63e8233aaaea365ff9a8742afe377e84153b1b62cf0cde8c8b8ee6370a453b620d1ec5c6e505b0ff3b44a1fb62e95d1153e814200aacc2a6c92eee43d43866acbc9bd5c7d596aee575d9bbca8a54cad97da286dbf8717945c11861fbd247b7f11b8d380c4c51a22da52a4df1605a3741c332eecd746f753cf999b271cb58d66b02a424cd7e2a1f88d010f7530e3288a889ab5f599d31dfca9ef09d635b04ef892886b220dd250f894c622fbe803c7e99104d72a61226127df49943f2757ebfc9e0d94eaae517df2a02c28d3a94e6e3d33160aff6ba15a55a9251b703dcb819460bc079922a3e80a7232c02fcf184c2e4ab10cd25690532e7ee63a52b76167c909c9a702efeb49fb9f67b52e1111bd6ccd6f220ce94c36bf6df20286b40b68016c7fb92b9d69edc36b93d5ee87cc28fa94b46645334067fd07b5e5adf06d3352f3e727c9895f4933408cf55d861308a6349475ebc9607ddfe8b80c0ac3f5e49184a1d2fa0c22140471931fad3d1ed54a7b635f96b9133776100b554f9c9a60a2e771e928bb6e9717de66d790fbdda0ce225ff140ec27cca2f2f4e0f73cc6392a3070dd75a0d1985ec030c2505b400cb96046504cc68aa2531f8ab2fc494bdafce7c2fa1e7eda053b7ee4f79b37eccebb9ee490ddc7440ea0c2d56bce10a0caa4ee89e5b0a86e6ff6c6fa2c29cbc392b3d6fa598f7f165858cc08112d975b20cc5163f213d1e136b0506f5e5c8e7ae478907460568224acf82c5360056c88b140d36fc53c628fe6c4d2aaa0524e3ec37f8ea7ed739188b3fbb1cfb2f4ebe81091ceb2666e82f98aab27c9e69eb3e11081845c335855bb4ea1254eecc5604e0f74c9df3e2e5436228e10702b29ce4522aa075076068db12590f4c1f094f1894550e08372e4b5380249998caab3c7ae709e7c19fd30f9dd03d5eed9a44a5cbcbd958ea490076c300890d3b354a84e584d9d28e189a2786350c8c110aa0a07d2c8edd6e1ac0820e0760e630d91759a882de718caf2bb068df4af0ea17aff72846d936ee68a5f3a2a19a680b8c5ffcb1fd51d969c0a7f6d907f12edbe1046166c27c7070869691dbb7741d34b7769217942b4a5fc05584f330cdd93a42f5724d7e161aa13cb89db12f54366ed5cedd7e4c1a862ffe6109f8908112e9ba308e1d99dc36fcd32ac4719ce2f82bcc6bbdb48ed4163999a8a2b6488c17fbe2f198149a16c69481c726feb6383dfa77cae165b7920454a4c7bd1280306e646088315377cb8af5c0b69097acf8ecb900ba2eb4f0131f333c84a7cfbebdbf87022c5a5303ca2a85ebefc2a4192425b18ab16d5c9a2c957d24f9827e6d6a2de7d3494adcb170450b78fc7711b86cf950d973210692582f9e86bb03f9a921e46439f37eefbe4df60b48c8116e23cb8022ccb51c8d4b2d62714fb1fe5de354ef8c2416ce5ce6d80187c5b302cb633dbf037bedc3cf95741bbf0d47f436105b02d0855ec58426cab8516385ad39ad01ba934d854c7c15b95d5ac2fc2bd8a7ffba967ad7e11ceaf5bcfc2ca32f63af21d97bbf00cf10dd5fabaceebf1cf0ed3a1351b57ef5c3c3e1d8f4721af16c55a5cecccfcc3c6e2890aadf8cd7e934dcf45d58fca0f2edbb8158148a68f4f13fa7586b8ec0245688d44d17c7682c8c0a0ec5dffa990ab310a3f1b811e32e25e6df7264bf68ffe32953d78da288f0a7bacaf417eecabc21bb6dbb0715539e1c0dfea5c07c794d434578ccdb7eeb027571c8d9a1e021a38817b6372a00198e88c032f7005d4eb20638f04bbc06c4daf47d7b69a4455b19c357eccef53a947553ef62034ecba0198e3555329971f828fce089499e576af82c104c5e6da373aa0e66a37b5434b1b9bed5bb774321c542435e200f11ea91564e493d70efc3ce99372c0550f113b697434f346eb3b64ab1201bffbe4d174ec757e4d4b1f2bdd55ea9ca3fbf3286f7af4b192558f5a556dbc295c0d15739a535d0451a50dbb2f2fc69a86c27130dbb3eb31eebf379b6722af33ae8b7f19254d991d003e620fbb5ef641c6da6887a0311dcfa004af14dee8bd5fead163128280e7b33579384aa0ea8793a510e7d0a5199411dc06a9201414dd0ac6f4e121f091240fb366779be3bcc851c9c40e8dec64f8d56fe5ca58c736b157efc7191986a76bf4b4a0b3aaed837d3d019e3dc8c22b1e4999213e7f077a6b8ad0c8139636d47df6263c8cfd7152f7ffa88af923ed0f225fae4d7f04f364e7fc2bf196c6dd13afb1d14e635f5603b8eab2ecc39753f942daa04c9e4af954eb06c5e365d314e908a7c44a8d2f6bf768c0d6b4ca5af326027eaa761fd3fc177dbf43da3477740524d388e497377380942f8b4f5c9117b1e9651be702810760f4efa2dfdfee3e75a4c75056be3b004a06176f4dd0378b751c66508f5a61505cfcd3639613272c9f1a245ffe7ec8e3ecd95fc0cf1b36461978311025d8fdfcd6fad18a854c764aac4992c396ba0ac2671548a589a48d886ebaedd1e6a82473582426e38c429fe150b3d92efcad65fe8fed25a0f4687162d1e3ce8255c33e78eaf1af39b7f9951eb4a12641cc086b2fc006810873aac009996f058cfa678b7cf9a2bb3779a7633c37aeb73a69c59461e75acec97c937b220c3166a61c83520761d21797fbd08c90dd0fdd240bbe0cf8e5f5850d2de04feed913732cbc4147a2d9a104f3cf450af117e9f38cf999c45a23f5596da0ed2b447e7cee05d0d135bfb571d3b2bea3e496b48ab953698b279989eb7832da8e94dc1355b80bfc4845326245be95c504626d991728c6df3e5633ef8b661ab4903260c6590543090d62af7275a51ea1e4697d19b61aa796ab758026a51198749425c6d46ff34c1b696ca5d298bf84b0238c7de1a106f52bd2f511c7939dd2a1622a3e9303013c459662d37b47aad5e4aff9afcecbdb952f11c084cdbb354d218aa76eb83c6b3354b38106519169d48f815d8b8e7b17b7d0bc9928015cdb723e745f8e3c07f53a09f2adb29f4c2bffdd85ccd935c5eb0a9b9ff7c2073b07badeb93e96baee9b278667d8664d6d914cd30cfa94dfcae68557711bda1f133c0585767e2ab499a727749ac74d2ec65a05ea2dbc5a376327e859b479355c00561cd37b563a6252d2b1b8cec007b0305cbf1527aeb11c4307f08f798abb5dd31f043c291cc83dc89ec953fba028abc054c7115425999525633b7d000c006fa2be0760b2607644f566f30d037018b59fb8b7ba6883c96514f5cb42601e245f25b7dc2b6029d794689297719e76d1ce2616368432bc2fa24018b8291490c244dc4a08784e1d84f7d4da9a634c6b3045bb1ca1b827da8441d2034e1c8dabee84a6dccb1f3e4f6a6776c3907cd8ef99ccf23f729d6a74caa33e925b9548debf8335af920b2b3c5fb849940b5f0622f465f46f644ef0c1760dc252805498ec9a02b5b971b834d05837bcb6dc5f280c38a07bde277682036d35db101e360a8c95b4149d999249fb8231dc45a9ad9bc9faf95be125cc55574ffd11382be8e3cc9ea48f2031d67b5b7efb01888939baaf84628e07061d9fcc3c694204de543178456fba49e3e974ba8b751400fed3451ac389c335f2d775bdd013858099431fa749c90b3dd5958480a591d7a5e5266628ec75cfef49e9b8d55ec610932d927eda1039d9a43bd1b55b622a58b6b6fcaab252b336772a109f32a0505246d7873aca79f99fe02c843766e125c5172709324a4d2e7016e06ca492a911ced0aefbc2dd7fc9229a68f4808b29b5082117bd1fffe029cf487ff6dcc3325e07a99c2afcf77bad79b555baa28ea6ebd1984519a628d0c0e9cb324e5a7f8d1f7a514a1a7c08da12b42e0bc989c43b65e1166dc17244e794ca4203b383848de3c4daa118ddbefb2f57ae809378b8765f22a874457e346dd64e771b5c78b04efa7f0b76c46abbba56fa54bd27d72742c9def55709a144a06823b207a932390fc626a50d2cc93e8e300d16b4d8eea71baaa84dfe9561496af738550d9fdab8a3f6f734369dc377b7dc2ce90c22b08524ae69061ee1dcca729c8cb5bb8f9b90115263bd53f8eafbb387fb711ac36aa232b4948d213cae791f7d2402592ae31ed2236bd8478dcdc4518122b73b95a8286cf08c3fcee613e9b9f4ee6e37b78619eeca5c3fa9dc17f25b122222fb6631a94153eba9e545a7394245b76d20abc9eda540b1e5ae68b44af0c19b5f9209c6d527c9cd1514605c0cfe437697b52210efd7d7e635a77c268841a8cde9bb0cfc12ed5512f0d42ff99764cb1b3ce0fa68b9bb7b979f4ad2b2f039ff078fb968b26f7ddabc149f3e366f8c684fd0b4320bb7cb834b1678664bafc754fb768139a87cdc743d699609a177f56756fffaefbbe619155ad45da5f8741ebc72a161a8c36b9d8cd9368df6707458929589129ea2fb25d01cc73f2d8b184d7ae66941d4759dfb65e06d252062330a84b9e5f611001ce43059552aeb772f97c2be997bb3784f4756f501bee3913c58fea212a7f2b9552a8f8a3e30c529c341e845200ce8afbbaae33ac6b2c00b457f145b5c70fde72da4170fb17eb711f1673c23973378e81d12b0618e816d8f9658f39e31495b089eb7069746272d730f7c5fe010b897c4658c7b2f96b48429d6e2cb0bcef70b537ba0375f3fd592eff0fe8e9dcf2a60eda19769c700448cf391580e1b7fe812b83d8fca6f39712db3a7eb88be8d7d9d5645ea225ab8bf9ffce757ec8b3e227cb60314dfc3eb40ff8d83eb92ee78515bd3976617554ae71cebe56d5e3d28741cb8732418c123b131bfd4346707327f8358136c18021d0a2c56cdcc13091a84fa44fc43191ec0df5eb4f77d96e766a80b13a7ce55a5b514be1499c42c08a022b94fd93748ed789142960e0216ccd4199bb3b8582ef303c8b51ffff01f34f1e62e32fba993fc2c2b4f5cb0e6afd70b56ad7d537453104154be51db91c292017b81962b82ed907a99ed8d769178513f308aa03c9778718b23dc4954ba0d1bd53b5ac9cb0270052d4000dc1146422abfe7a6b649f322a75509004242542d7d1bbaffc61dbe6c2d620d89cb410cd01b44254f7b7c352d859def254ce66fe6346603c20f15c0da1b0e3ac1e79c8c06d29b561edf1845df937d95c185c302f7147ea875ac2961bcd734ef2dcb9ba8a47f59e6cca9efa428005aeefae0ee677e1edc8c86bf1c282bc73908c98cf3339f8516480701ec88f1bf0e68ddbe28ec3365fb1c07ecd291f89b1542d6f31d8ec4563e1561e33f1954bc68ad5cdc32dc5ea07a9ec1a8cfe2d93047a24d80eb7dd7e8e3f87ca833fe6cbcb87380f8e4cdb8deb3a849c95157009e839d130665e4f6ac9c570e1d2181cadd421cea8c411c71d8f96a46af29e60781c8435ea007a475a39dc1aba257e2f67a0bcefcd046fd1435a546ee031a6d2f3299229ab20b525526ff705028172f851fd3469b84c652775de2a5311ebde72028989ed196371690ed63b5551abf8b823a1a090fdc207ad4dfc844eb3d30fd1f629209f1b77d29debc280052c87b89a65657d3272224b7fe9e3345148775166b7e27bfb0e2e9d49f262b539e0cddbbda0b264314c977cb35801a819328776d932ce0257dc9559dd2b29b8d94037a78e8cdca62b4c6016b23489e53412626e9d99234d4b5fe906445b8d1f18e18bff1a4f504e49c151b81a257528ef76ca9ac04ca8920d50af8668296a8940dfe66be161e82c0c202820ff25806f3891b01b040c0f96daa1929acc26bc335fe6635463c8254f40085209b71ce90aaafcc1b54fbf0a2b83545dedf0e6cb723c7db41e0a1d6857d0c5523367baa953681589f86b55154c31b274350cb21166e0dd881d27f388d3b60fe44bdafb9537d7c19b33de36424be27fd362ceeec020bc8a7df9186a330b1734fb50327cd79e43e20f28befb5006c5352771298df7d38fba438063ee64b5543f717a80d493e338b529408d675ff77b9f3e5ca46346500a0b5d2aedc6fb26e14d7edf70614c54de6b2588d292b07d13f970f2aea6c5e05b2b4c907cdbfea836e7f2f71f8d440d51b57eeff086a8b168f0e51e471f80d7a83087c3f2d264204ab6cd7262dc7f305fae005bc591955a376e78fb349a1a4cab36f2cc1c910d32ba9e2967a688a03b983c909c572e87e15cce0467c04bb9ebc5de088be027a4168adb7710ab8b421a04f7b6040a5cf6f18b0f2c02783d52913fb1f0c0fcc75ea0f2e2cab60e788c30cdcfc3b622489d5c81564b2a741c559df790c0f986838d55d1b82b7981c13680913a48eea3aba067240765fa7f9f7f90920cf6b0d41b52f1674ce12ac5674bf96a40420add6c2c0c7702908dde8c2aeb176a179e75693d78a95368de7294650faf30d58dfbc60edda4ad5280b9dc7a5f5c979c57a239e73a48d9ce23793abdec50dda08eb017439a72313d5fa4bda69a66af11c9806cafe6c89ab43707d45fc42243ff994d237724a9b875d4eea632ec89fb236a73300694413b318388acd49dd388dee05537ca797e51a9b5d9cefe3a66307b7460d9b4b58b98f258d0ca1e8c76ac95a86234a4e78a04cc1c030bf08c607e32b938eeb693635e59e0872fb903ca8d7775823f117d9521522ba5097dc8836cc5f135f77107ea6f742661b7ffea3f35eb09b8baf848279ae869d7986c090fd02d902a90fb69f4c27c89a1eeeae98dba2888192ed02df2ef155cd116ae51037001d8416cd069d3bd624fbea0b113b7aa17b0dcf48b247037b4f9feb8eb4afd18a239e3faccc58463d450d192305672fa5190bdb8546f21445e8da396483f2a94b6b146c15d691d01d178d296110fa543296d7f95e3cf73552ae8d8141a86c98adcd886c730a155deee97848032ae581a984655516dba268cd85744ee764dccd6722e199226b083eb2bc66fd905099f12c18e3ff31ead15a0338992263274f5a01f6002ffec8222d6e50ffb9f4ff0b9a1a93e5c1d1fa6a20b7e3d7853b891c843d542aafc8a458351ac40a5832572fbc92002c0fde83ba66584cadf3fcfd7fa38e3c5f03bcd87eb5c27d26024573e4de771a1c6a316bea625baf91ddacbee00a3cb43dd26bb077dd927c152343a50198faecea0e541cc456ecd8948830a1d52127604c61d5cd5cf6969b45e6327caa7d72b4bb469547683a2b60414c95166441c0e3350114ae4365d9468846342ee99723b83f16f37311e7102d49aa0bc3604673af1012aaeb20129035300ce10e80d5a7d65042247bf1caf74d150b06bb4073d85e8919d588b9a958c6cec843f4ca18527ea96bab46a8e52748d2836c35d76de833583dac0f415058659289acd5bf28d0b9c24501e8efa52e02b35a74c6e2fad8f67b0a350d24d8a6837fabb3173454e0232465c0256e1eb67dced5208a08f3b87a4d1aca29398afd4f673e79c9c7c5fc980000424e7ca759e0c0bc947eda7b0db67590ebfc999edd082422678b09f81522ce3163c2fac8fe1c6e524a7d10865e58f449bff68f30ed528f0befdfa6cd43edccc2e5f0b48b49f7cf097bcfd67690cfe9aac4e06003971650e8da5ddcc24ae28802cb38051a611cdaf907b705b2dd5846de4164cbcfacc1b10e1e01c6143fd17514af5736b005b6cc4b809c69482a5d47bb96e96dae4b8606c824987441810059c1231066b6ba8b6f2375abc760b0abdd4306b576bda4dbb29df0f4266be4efe017a8bb27ec6cccb2f8ab0476210ef20da1e615ef81ab12f354652787f18a248b441ca9c1cb3613d086737a56273e5018fb2e58cd79d9e6cfefb056842457d29d314fe7e6f07f105d0f5b43a674e6180621953b795d312ef9ac39c6dd5c177b0f05638042a68db29d6fd9203ae51b6a3f5d50dd4d0c456b183de44f1f50f72a0f47f33c1f78ed4af685162c88456effb7fa44eddb58bc2853fc7253ad281f986e51b7ca64f7ec2de825a9746f81d7478f11e8ec26cc91530d057b12102bc6d842112720f2aa196337eb3fc1409f52b420507584e650f7ee3b976ad2b2cf1d9d8fd835a1e7bf4137fd121b5ad2ecce25bf8f4a77137ac3f055ce47d8aad50afa2e9133cea16f23d253e41872d3cef58e4b6c9b7a856cafe3f7ca5b4616f3f1ff11c3e45798204e7e75eaa990274b970c6bc8632c6c74b19a795764852eb86214882cc6fcf671d5fe81579897a0c2d303807d4c5af9fde70ebf81c03f32e9fc3622f5f449841de0b309668b917f8257aa9155dc272d3aa8cfcd21851091622033236b7d3bab65132b2e01e79ff77b14732f11ee5b2be10f592b3799454018944095710037e49a8448d01942c207c4de67c60c2d07c528c8d1ac02d113209675311a217b2a4255be6664555b6a40fbf2c57c0dbdba5141a83c010d4e1061ba0b9e56c6c92e43dc62edb96400028b85275b7090c9f62e886768c2ab89d8567b1f131f1e81245270364ecd93c16b410bf66ac2f9d20941c378d9fda7a0b8fe9e328de780c1b3c888de44fee6eb74b3223cdbf305e671ac0ca34c90053dab038a755a42f4bb784c373f41b3c5f2d9d38b6a1ac82d84abd8df3c9fad6ec3c1a434332501fef3b969afe73c59c478571ab686b2e76c05f53dd848d4a14f19bd30cc6eff8525d73863358ad7ef9f86022fc36cbb6a2f5ca6b960a8c9774104b93fd3812e7646da5073014aaf7f3eaf0584adb236747ed0f1a26e30096459c3ff35a159f3ce8f3e47865acb19696667f997e3b76444ec98682ea5e83e98d104925e0387257ad43dc86518216098ba3fa273730ad7476bee053714ae6657e5e8d797ebb420e5bbca15f3c9122c92622eccd3aa480261541881418ade0cf7b1353ae980fcdc9dfa52d391849df41b2ca2764e577f0b7611ca537a8fd1e89f6ac31a45f702ebbfe3b9134c7f81ba6822fae291c256c820410f3cfc4d23151340c07144a0bfb5148c83817ad6b25fbccbe309defe2203f5d07a39d380b13f00c1bd25fa277c8ad121c306338496faa629c80c5ad3e23a885f06755d1d545f9482fb900ce5963311d202f48556fe8ff8e19cab9a07b929a6abcf3565518ed5a498b9b7be817c91035a262e41af210016b6536de983fa06366079f88abba789c59d553b9b118aa0bd5544fcd3249f326afa78c33e1a67eb56f2e4fdb50a3146b195548411b2e1f5965605bfb11e44a62543e9790813b033fe13931b037d7cf2ad80db764a20d33d907e4311365b39538cc03cbe062e5ef8a1c285f16b2d76cd47dbdc796ec2f2c770c91d9f8d8ee4d341a50f331e55f5ebff8f50114132b867a72ed234623a320c7313a6d29f9f8de3da3630043c6560bc6e2d009ffe2a190e2a00685220b192806bf49d385094cc633d79994ec38ad295f87a370c3908d6587299d794bbd20779ed0b7bc599b6c5915aef03489c1126f0c63364293a40250716659365a85f712196aa4739047addcd0f7be6f14704117e416d8aa5eee0a2c6d476b7911f2b8f00528fc82fe0d348544433fa841ad3cb96192babeb0d5ddff1212658c11c34992b28d0f4739e45476a407cc79bbd2144e6cc84ae6521cb6940215b94b5b64bc83cbbecb7a229555245ef9069c359dddfd6c0c368034bfb7bd72d52c67d00196e69f15c1b116287d961c4eb8ecd8e3b8732c14d68722f8ab4324552e2e3e4b436de16ca721cffe37332d625a945995b8d56e3b9fd340f74008fdf560be8405963f7a2625692b237765cbbb3ec1f54ce3377d7dcf13516afd3c20a90af1ac1e4ce9c02a6e402cddb1274c357386292dd9e55ed70266b7c3d37477a1947065de80dbfcaf2367f054c687f85a68a03be9beb6c0bdee17a473e47f7a6f756faa89978451083e03ba804a1dbedb21e51c859eb6b630fb69a6900d750d27c542378a93a9234669f18c77d77ffdfe806d36eddc71d47cf1d3ce51b4c696d4bcc32bd16dc702087f383958b317226bf2a0fc8c8b473dd97007e37487fdccca5d378fa59284b67b5bb4496992d72186d0671b12d490295dbac0e39ffc8c003457b07159f1ee58d780d87b529c1ca454161d68fc91a45ae8982e6df8b44147a43f4363d1595471bbc8f6b966b5a22ef88a4664572800954c46063387ef233789c3c5eb7557a8678d63ac6ab311495c6e016bb93f6de91ddeb102e8bad7c440618bf5dc98d10dfb43f54f01c86f73fa2c167d349fe6fce888281e4f3329ad3643ee3f08ceb340fb123d56fcc50ee07944efb0bf8ecd4090d7ad0a3cac9357d752eeee23d7ab1412b78661e965cf3b053257fe171b3fc3c431bbeb79b4f24dc15dd2745c6348d871c6bb14a9cc141f304fa4a0a20ff84dc06b75bc91a3c5c26e7be6a3ed222b76e1da207ba63274176176b7f99c26949fa381f1d95041e26da32b5e9416b52687a0be0d987b292b7721f54abb5bba0721db17737b55cc7a04a58000bf96a5f4db81d33470e98774354c67dcf9c6480f0c378b178d327a7ad378d24b49f7f9b16de6111eebd3e3a553bdbd49334e36a9e4e7073912d78c27fb00ff0b0fb2212a719210024b555827dfc6c6ee36c2324e6033a8e0f4c02337c583e6d3da59620bbbb255501986209a85c22d77f7eb1dda484ad9fb65779648820ef71d704e60a24f131435ef8cd8a9c35d5e50b5f847a8ed887dab8e826f0469df7b7ffc4f64280888ea020f614258613227448eb92b5164d3aa7a7337d2aa21d46f7110a56152c5d0603b5fa3f4f8c84aed0f721577190a0b71541fb15e4431a1cd5afb74889e05e7fab882aadfbaf979dcc9ac0a6efa08c19fe2421bb09ff66777e567be1bf69aa71b1863130fe55a0002441c3bfa6b1ce3ebf53cc2c00c416d8ea2b8aa98b1e53a2dd9bae9a005bc4994e1ec090cb2f34b023449f9376d0845c61d91e5e1e81d801d3ef3275ced95684035dfdf335969e63657e407ec98461a63a7170aa650f3424e32138dfa114c60208b13efc476ccdf5c6a2b5d4eb4b65f762ab2491cdd0832cbf5887e1587bbe2ad20ef1da9b41b478489cccecbc48c6f6794e99179ec209cacf5b1b72c3bf3cff0fdf5cdb8101890d121b158a45ec0ebf6a5705dab0634554df4483dd7315cc1a941bd39be1093a89c852ee0efb2b6b03d8fe87ad1a8045024c84295f024a1edb521218aa47b586cdd1a5ac56f3bd0fa67fec180b4c3b6636ecd170f86e8481edc6e407893bbb724f1e7bfdb5356e2d740f31cc9a288564062df48ae3076b377e79805f56372501809c53eb60640b5170106c0ce3a49dcd7972c25d5def15d2cf297cb6a394033717138a8bd4b50803eca8ed99cd9b6a6d1695bc108bdc1633aaadb81fd4a6c28862a2e909fc9b4c34637ee1c01795282d8e741c3cb6fce067e2bdabe077d52cb87643c49bacd69e1671b0c43af882a88fe70c03bd935764918f0a98378dfaefe2ed7f2c3a8bfc6ccb6949b95862534cba745e44d55e7b0885619e931f348ac3257cc0b63801ecfe351aa4926ed1ac634fe27699f6939d5e64a7209e4be8719657032c79d3b030c47580188e94f25c385950f74efd30cc8841c6002265c4e9323aaad59454f0e68988ab81cf4adc7eec033ecc69258e147b17f86c0b1089544214b143edff9e80c8f4dcd8255745a7da94ff3ce54756087c4dbb58049af92a4cd1d2a38cb8182d649a69a560a14406af6a2dfdd473f50e8e0ccd85f341c8f965df94945ddf7b80f7184f0b1781b4519858c2d9ba0258eba07395875dcf15aad2892e9095c8cb058ef6eb966c123d877d69ad1e78d5074a945d1cc3093e689b6917305cb987b492816e61a4a752191843cac1aa81b24756758c8100296a54593f6b26cf9328c2d3ad8be56a1b21222c0b57f11934fb450b6cb481725b2f56ab0f5a2a514a0c92ebeb640faa4b022bc73278e6f3ccbef4fbc3f87664fae0230db1225a8e09b5c667b2742ae01e2664c23dd7487f6c86c060fd25d9e3198610e255b85d520cd9ff566cc00f3d1e2e79519208e803f263502e772501de4ef36b562bf39b04c43dd2af06b2db02b5031e6265c6031f034d3be8c290d56814d157cb7e0d324c936f08796a49f93c8518411c5859c5a6cb6e2b1585b9de2b617fdeb180f6d308dc1a738ffb133825d0d03dd57e0fad5aca5a3d318cb754893bcce9b60ae5991c2adacadbb5ac7acacfb8f1371bc681b01bc6bf976591c9d0152a973ba2c78a3dfa4a7bb0356a170b07a8b00440f7c023bbc45f6b0ff58b92701268fc9f951c9c83b90bf0cee177f18c940feb9d20a035828122911a117c4464be7e8428a3c1b9bf2c25d2306b641d6ce187a6ba392eb2bec1291a93cfaca41418d612efd35e904a38a8e899ab3e3eea3437f6419568533b8ad153b86d6fa19a1f5ea9c1b8e6bd5e8b68b659933ed4247f114efb2bd2ad17952c623d7ead06b9b9254a8367f30aadfa018fac674c224e2bb5615d34b9227c8fb309f0ae53e37326bb0261af88c2be07d8861940c60d62bf9cf37f84cab286ba09875ab846b158cdc6975b2c99b934c7c3f179ba95653cb18bec96f999e1a32eb6618d50c0dda6565326abb5cee422ba36de1483110e24e5661f34804316e6532852a5fa546e9d6d60b196f452ed076b90fd5c4e33c8a274f26f901722897702dd143419e0a9bbdc7f212e9fbcb6e75bec9ed767e87ff60ecdb1abbba55e691fe4037fb9ddf72b8534355fb92859e115abad01631117b2accc29381f4a7b9a030781a1d6cc8e9d4cdc23c2160b6c782d4ad18456900ea72c6f0e1de8a0d5ee50ea556683f9aaac8492e7903d22f825f86e2b822e12fe79c9dc93ae52e586c585066e3bd3949ffa7d11ec7538fc0e8fcb259f2ff403dadcc1083e790dace3534202fcbda4fdc29c9e10db7fa8800b3019370514723155aae873b2bfcb79da6e4eb760150ff208bd545564cb240b1b09e5d83ff7c276f5b39298d28956aecda0309ee99330fa175787f94ddb2b35aa800650ddfe76b8655b4aefdaca5456c71f96fdcaec1bd8d737a62b2e0790c75dae6006f06db0637ce7135d4f4d22d7185a65eb67e1c15063a20434e030b6850d6ee275d8e69a9c157b8f8cfe68a07a21c8fe01cac81cd0d5f81495920f6c1d6fa7bd8de0246a184605e641829d9b1533fc7cb4d640f79971e73ff4995864b85228422ee5de95d5c9798bea1071a133afcf9de059417971826d21bc85f608182f3abfc13de5cfb1b1cb36e68fa0eed318464454d72879b96134c0dc7c3b5795fbc8f5eb0c211bfbc7affe4bf62efabb5ec408dc8644aafcef223076d0867bfe4fd929886859e7de50cb21f7176dc4162ab46d8ce0fcdf845a0aac866ae00f0783aa831c6c3029e7d67ed550fbd0011a6030c3ae7706c6debda82a756fc4d7135ae8c032fa79ab1c63f278c7f590e479d67c2cc37490cfd6f642fb849bf3ba98a9ce2dc99031664f2194234f358e600b983e0ed5c66270d1e24a39d32315068cd47ea21267a78c0f5dcb77255ae6afe71320a52cf03974e620ce9dcea775df3db6aadcb71ed3baeea807d24867fdca8d3077710d0a9e4c3843e80bfc83fe324c9081bcf46b589f5433b6a7492f6bb9f9fd91edefc576fe47d2ad11c7708f3c4be6a0342689a45d705c414e811035112f11b38f4d6c934d88e55818863f80bf80bb12de4fa24976e8c46242c0a9a439a583b72772ec8c4893bc6bb904e9986b2d348c0eed42727d1457fdafc9f3f264328e40778dc4ce392f522d14a5a29f434d40bf33e6bb77631b96052aed1aa1f05e378cd7a429b431f81431c7b38efa6ad0b4f18a33c139fa56b42bf2feb0552432e9c9efaefae5fed0547a4d9f194adfdc59ba3c59e6ddccb1298675f0e8d292aaa765c64c984eb6f1da2138ce2bf69b3a925ea62e8ec3fc02dc0cbb23dc0043864aca352d210337f8e58fdd27e78083fc9163333710f94394cdef62d2b05cfd2a7b49b345b3f05508254b91d2cc457d8c471b4610e261420352a6086d0b31db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
