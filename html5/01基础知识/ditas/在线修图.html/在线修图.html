<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8eaf20d871e13e295c75fac95fa8c0ed8eb28b69ebb2fa98b8e3044f8467697b08e3b1a515f8c8026e96f7242152062fc4900d5b0d3a957eb2ae8eed6b5e655969bef19b6045254a50cd482e8b8cc1915b0e91ff63507c2c2ad6a6e564a48432cbd3a0cbefca3c1c7f26a8e82e2b834ddce7e5551d5060683019fcf899122426131ebaa72ae5fcce08bc3c072906db7beadc6324e18cad66dbc1411a4245339ec22319a9b5f6ddab2fd170390269ce275fcd05a4c68f0f2a31e663244f3de5696bcd2e127f37e267514e08ef2f1a24639131f039c119671808e83dca39c2bd33c3f606e7533f36b487b7312fd9e830ab016129d6dc1edd7b162f5fef82087cf58ee6a6202e21fe5e8fd7bb880f10a571f2c0b862d8c873314a52d297415244a55a254880a646e1ed74d794c3e947826e3702e339ea775e64ede40cce1434156a982d54ae12723e846e05cf2bca8a026629e940a0755aab7b87580776119c492089182dfd8dd9547c5a80f1aa3c3cb4162b80791c4b433f67d4bd227fef31fac3bc1f145b40137534cb844f8c02394145d9cc50f1171f74f82ed0f44bd49cb2d356718c10f9dcbc8edd82531898b48b6e95e82a1b21e832ffb7245a4758963977e09a19d01b88d0405964a022410a74026a3a0788f40abdcda39ba8681717d71ca4e8a93180d8df79907d2c6487b96b8f9aa1e84f33fc6a16a27abb5b1054b7988fa497f41dd0a9effde773b4087ff86f523a0451aa086b91c465623040ad13fb5a48b0af6463be314fb9359aefb539f6a6c3ec36db53fc20cfb156cb1ca5a8f59a46776740674cd820b2618aad7d9d2cf6933bd6aa8d6f3e52aee2615aa09fb0c4061bf242983b47ece55adddf3f8d59b425443c934301d5135d508a1aa82e84743f40af0e75904a2f2105fc17d2721de9a926300f7f00b2f368df77cdbf9c1200ea1270c3cfe85da05bfedbb728dd39c04daf5429acf4d0cd76e7aec490838f2997c449803d4d9ddf749de71f5e8417c9ad9dbbf6d0c3e6595f94beac2fe88c2c9085dca32d0694da540ccd218d5a593c4ee05f4b73ca6bf5966206af8e2cba1016e4c6121d18d4977482eafaf9bc4637d31f7c73e737c9bd5ad75ba5250cc9dff0fa586e19b84eb37facc401127d2a493f23dafc740dbad0fe7733667dfd1fddb1a24b4b408ef84cefcffa61e5347a4211cee08a1ad30bfe1b8490744887ec5704dab61c6293e3d23ce49295d4c22dc17ffd3d3fbcad08338447192ff613639e479cababc48c462ee0499b3a5ec88146c3e7741c724c8d1374d0c07e0264829f0ab54dafb8875a5422ccdeb65fe277894e4a16f535aa2bd95fa3f4b3763e0d680827003d06d28a9d1fcb31fb70b9ad03db93d6f301ba2324d157fc3c69ed692719bae1fb0bc3486ce68691dca4ebeffed41f90fcd150af62097a2fd43acb2d2d68b2d3ff4d5637cbf274bb63e38867c8018352dd1159e651e295047d11b501c0b601c97950c6b83822e4388403235947dd7ed82f666bb743eb5220b972e9ba4267f2162cd0ee45c1df17bb29d459840ced938bea45c2bc72fb02478ed1f3414efe683ea4bb7cf045fd82428bdde4a9c2a26d24342c0ddd9466ac242894c25671e8d1706ad47fdfd4a38d830452546cadf147ff65d98af10257358497f2a7bde4cc720b6f2c737e3100e716cdfc81ab36e348fc0e9cae46d073d1c927128ca4e7be271d83eeef9dc32a7ade4c2c555f8ed14f42bb749d0ead608b0aa3e8f1cbf235c8c94b21f39a7c57fb2b909ff73e83b2c3accbbc4860287aa5bc14320a480adccf6de833be9b30f3ca9d7eba7215549e85b403becd0b1fc5795aee31736e86c99aa08f7613b5cff89d261bf061f58c671b35dd9965594fcbc2485a4ad2e0b850cd0ab1bb16da97adc6aa585438e7cc7d5cd6f323d1631f48fdef27e70eda8414a06271a945fc30a36e2088287bc7ba87e00542cf55e687a6c488788b455fca5a950a24e04a43d84cb58840bf25e9c6611e58cd816cb67b721ce3d11192e0ffc7803c846a1737041d31ba256095667ebf0504dcda2c9715ba28800baafe0670e384b20ff8b5d304fc96520faea3316f1adc4c4d7b22185ba29bd512fd1f3d2c4c76adff538cbf0be4c0a309294ef8f29e7bcb79a94dc7ba07121a3a230df641f100e5b6e249003ca0ecae9bf4817b8b57e6bf21f0871da1674ec822a3660b641d2a34b0b555577904b5d2cced112d0e0a455d9dedfd31c3acb06ac8e9527b67c9e7e9e33840914ea246c52af6c9580bbea572ac2ef2a24ea3b310fc5b047dd7838da25b35257f405d95f33fcc9c22877f73e4d49ed3d9e3c1d290556b5ae0dfdd570a26c97a549e1533faf1eadd988879e9ecd0870797662a0d6b8fa3289681196300b1038a3439066985ea0958e13bd85dbf6d664c0a5e9776a80b6b1b5ef85be16e3c1f7225c69b3b372eceb73320c10fce6919fa0fa4d9981d1498374ffb77e8051213008c0d951f2e9fb9ddb60ee1c3f199f47c157ecc589a7faf86335998f2789f116ccc1059ede391d46b42f192f768b68d2f20849b52a8c15726cc4aa8ced4c9abf9f514218c8c72ad8fe9ca9cff1e824f2af6a4fe68af1b6dc81560cf51873fbb6209ed1f3266c8e2b131f0bd3a9f1ed48ffc8c21069eef2cb25157ef4428d8fe17a331b60db922a1f840272ca015573fccc993fb9a2346f4c8fc264ffb7ea231b6ff699b905b73f649426604205a659601732b4a9f662736af1a8d4f482ab6e7ba1935f460f3e2e070d3c3269eb43dd26025d8f643c0f5d000c00efcc1d0a80f42be379f7cec5789192b89816a26d518efb82c8fdbb203582b415b1862652d4ccc86c42a1fde633e436b4e6daf5edca2620ee9a56258012123c8a88d85fc810517243dbc6426470cc9b33f024aafd2812790550ea156afbf397a7bad26325792cae7fcfdb6f076c0a1179ab0d1ea3027352eee0dec69820def4abbcadf92f760c30e7420cff314c0e9c188751d033971118cc4b91f7933d3ed844d7fe6e48595ce9c4e689bd3f4b3587de3d1fd9edb7ed1e047cba125cc0494afc20bfb1ae6502a67b8d3ca1362724e1a3905a5aa9b0f35fec09787ade7cb80b40d7d30972ba2ebcd5dcf84c8a0e657c267d3fab87881c717b2f1c9dd7e2b2e847ea48059877e68ebe01e425c390093ed1421fbc03ca5340c1daf9401302f2b8b92490ad739d875617709e22ce6f1e8901241bc37e043f5bdb349b7fd3310f463e2b2254fb0ace9c6d4f4bdf260c8092667673e1e20212e08aa90a7fcd8fbc1f55aba12d676e05b5970ac40a7e849e51b0f1e1611452f9c2674532332f352fd221eefac43b28d4b1d78cae7213b9ea9c163fb0efb9dd4b6755371b18c833cba8fd62b1b9623bfbcdbd894ba2ef97c3ae37f5292ce70a59d46ed1c8a0377e9e4f4f1092e5f1adc2d68cd3320bd90c8864208ee05a11e4b9e85880fce906598a9dd69b042935eaaaad37b0e8248d5226144e5759d35fdbbac7122cf86b1869d9c835be6614d70d9b92dbb1101ffc837f94ca51d507cc29f47d301ccd68c1686eb1741e315cf872e8736bd6bffd9b1146ff240f1281bf6cf9006057a6a444e569832ed7d77bdc7e2d953d9e06b1f7984b7ede0d29c87d8c773e74faa308fabd42f7fac6f4ae2d00be654487a8298c4d14f22392a5b46320e484a401838540348b6f6d6784c0e324fb2799faf7828bec50d46a5e3a4b9b63d76e5aa5bb6755edb6dd9033c7bc8e3a7f59f48c0a60991018361564f1b5704d956281cbce4378b786a9800565c0eaa2f5c3f23eaf8481ac69e5d59147fe9e4c7541b1a31366ffd0d345d706d5cca335e7a0a69aa93d811d71d333eb3df088be3963c14a741e3e1e79ad4cf691f3febded9d61072eae68d690e5028cba44ff1f22bf4a34f9a4f4123eb1850405ace1311374033f04e03ef6dd75a64774e658e89cd89d3181379f67888429d3652b41043535845d479ce2a3077d4b171cac1a66ef23fdefd154f048934e27898700e79fdf445c0eab8d1857966680fb0346d34d4a177a08e2a5b8a7f708f3213a82face223b06ef3be476cc9a2139635d024e18bfe32a7df18a1956b172e6b6fab27b5e51ea1461e02e5e8bc246e342db9f1fe81782a361812f41d3d81f445e710b73a7eb71cf55f792b5a255899f5c76fa05b19e5789d3fd4b89aaeae80d471407dce2c7578b166b9659ccb6a330a956f1ea8ddd462013b06c28ac36c649901d1620ad5518c9ea025be470501b610a67a11aaba6cf11fe397438c0335031caefcea66aa55bf673468c25aea1aee6ab00a1463d8f13a25c5388382ce6050b815447c7080edaf5770d15a0f0456398b15bc28f987b6ae335212cec776fae377edf06a0e95604ca06602ca8d4d17d17704704666c97a9e2f5ad49215277899f838e4f3d94b3c0400f97d6f7f31aa6df7bd6c3f81c34e43bc57452a0421e40ba61b707824bcbbd0b48811f501408943bc13309287849cb6b8b5a8f4cd03fe1bf2e2c1f1b99d95f72bc483c9ea6d349876a2d576bdc7a5db6b6d3a52a1ebb4163dbbcdcc148a9a7a438281ff2c2e54852fc3e42120421ed8420fe1e1cba15650231262f766271a0cf181b8e042487cd65aa22894e2138eda2941b0005fdb313ab41756a6c06daae2eb16653af06478c65e0b7faae9cbc6a15256377a2f3106725878d628a3de1a2a27cdb997d17654fbfa7262a5dcc10005273e040332fedd445ec2d373ee9e45dc683838a68cbbdd3a439e0c0715f4359e6eadb31a5e0c85ed425d1566632f5bfa6cbd95c5f38310d401e4e3fe6416935d88a16689dcea0413c2e18668f99d1d2b080b35ad0157885a82b82252e16c00e86f9726ef8cedf7b0c8fcf868b5d9f8679a1de8095baa67d0331776ac208a72a22e21be70b1ac59fd9b812f25a9663b8a0de646b4b22bac22b10931f325a772a21bbc65f4b49eb7edbf465ba93cd63bade13b773d9e0d85117e429aa9b8846fa74f34e8ae7dff8dbed5d4c27a193e014d49cc1a981b88f1d72beda546545b02617d88f584161e26ff74a63add944d5bed7d64f86ad14db3dbf6a870cd1c5a2f903d61e4225929b47e04a0f6856b72e36b8d2f3f24aec72166930c9516216dcb0613c206a32fcf8fd392920d912b210392e37691693bf3b62787be0a52e034caa3a078d4198c795fc00ce385e8851539c9b53f67b382ddc93025961389808a5526b0d63bd6a69f88e11b1b5aa039728dd9aaa2339cd4aa71edb9997b19186f9e736f453c77489ce29728bfd1aa00058641c3a419064a0b1556e41ee2df0fa754b6407b5674efdd74f3f733a222fcfcfc57c2f0c4c581a575ff06bf9f3ce470e32605d72e3ee8aa5e0a4325a8a3c0a1fec94b815f1fce1fe31561f00761f3a1439448e98dbe04f4f697b0cb3cae1364446dd5175b7bb65ae42778dc3c4e2c684063806a577db00425c3db6f196b70956d64a1bd45b7ffc6935a77ca550f0b8deb5ba609a028597a320f9d1605f8c6cce38de97d157d832a06b87208bd47639b48bd918e6e22d54ef092294532404eadacda5bf6cdb4ce3595cf646e5a0a3ad9edbae403960aef8affc0d5749a89884dbd761023e6d2a8e977e92a0e1e6c2296a5ed7c863034f2f3db10724606ee04a01f7a8f42b4febe87dda8e6fe4e85ac84d449f64bee542ee68ceb5c35fe015815035361753309418d5be8413cfa17d4c5634025498ffbdc961aa6b99016857a0d52a9ecafab2859197ba7fd5e2f43c8e3cbdd8484586ebf363ec4b39b088a9d2c5bbf984bdb092e592be667b4141f139589b02dd8146a55ff10d290bc42229f1dd4ddc8b8139c169462cc99a2f9ab268925b494ffc336e9d405334a4403e7ac36efc35a9ac531bb4123325cda022dd1ea944665aa7fb3a6ec76f3d9372d153a3b55c1751e539be0ff6feb50d1712d847f65a14e9e44a0724f01f9af59beb774c866076294336d7fe1ff86a787218a1fa4c48bfc4c960666591b5237fa38cdabab3bc9a525d69b8cffec95d99c30f3b570c377f7113f1bacb6d2d2a7623964ff8a355e5f88f867e4f1f1213b6fe04d64cdd22bdb48c724f21835e8ca62aa5a7baa3e6c462f45145b6c0d2bda31b530809e09e876524ed971de9536ec429240630f5f47e3d96a21bee9373a7dd17264c67a50061128ace3aa6cb3ae595c5ffa33a54cc63fc568c2cad5a373a3031ae289ab6f1df8ec0ddd317dc741f440d3498417fd195d8e7f8432fe1c2b84b70750daabd70040f17c68d4761e182415cd8a98d3da204caa518260e26d554e518af74ec73d218dd20d8ab149345c116df776deafe5a824e302cdf734f39f72a78002f085dda07f7864a4e16e863162b4077e9e125498f17ae9033d21abb3f1866291794974f9fa5ce336bed5ba61ef5f959cee8d5efacd99bc79b5c49b282048daf7e6355b02240b2bc1e741cd891ef6e72e8c4a3a04607fd9d5497430d3977e7a00f55cdf8f2df2e3e4b171d39d17f6cde7c7ee4d682e695eb87bd2ed41df1880b747ef351810dd036cf9030d17810323fb48b08987fad217df332a895c90106092cfc3bd8cf08b102cc0dde606c5d1e75e9a87732d6b59239f166f663c18a7450fc51335cb3ca51585a19c7a799f88713abb0b04880ac24ee5d50cd464e2509100be2f6a71217cbc6f67a355ff5b27839e6c7886e30ad9171b4849ad7da2683c59aa3937277a3d6097217b0bafab779f35bdabeaa0ee2b29586186bdc7e231a08fbb5d3576204dcd0952d9f0b78ea934fcb979b2e1b61ee8cf437dba65d4545fbecae55bf2c041594741af91ecaef5e240f8b88414a1a18dd0bf19d810fc9d025bfe69e431337a671a50346dece12f1dcdf30754362e7b9c91f8f8fc5015234f5ca1261401ac6b0e4f23cbda5a0823b5cab5ba399fcfbf8c8a599efe200a8cd9a3857f560fa695b6a93d94cf871901f4444c9837133edbdf11372b2a0981657d0cbb3c3b8034a0eb28155db893a760fde62a04b82cc3b68c01980a03582f8a39be1369490240d2c30ae88617bed4e4f3dc9e2735751630d9f69c9a6510dcae63aabbed4c30ece2614b659e48a1b32bf3ba2fc251c035692e7e07a42e76f532bde79041a00f0d8bd424c8bd7aa01d57b7e48e58850edfd6e0ceb0c355995385a3a50086d9361f80a674c47729e693e67639991b7565003136207e56dd981698437603860b878f77d048465edc2fbda012c5c806a0e5963ea4919833dff582e3b380f9f106785f4f36fa5a69f327ac5400efa04d17cc4ca8a7d2c4edf0cf0eeda63f0948f39e634d4b55c3ae400ffdfc8f627e3f740adfada9a0c1f4bcbd146fe6d7961f8c2268e6051a111b9ed2d02ab6e9c8f3938b4c13baea25324cce92729e078693d1c60109dc32b41b837cdd157ffd8a8be58646352c29477ac91c307d344abdb072b7c0f9ee30e588bdf141cdba9c3b418540d228bf9eca21dbcb595827f31fbbd8d880f362922c6edcf29145e4756ee33abbadeeb60d628cd51ca7c3076fb6ab2f59fc92184dceeacdd50a85751eb5a984423424893c5e1560bd10bc41604b3ff1bcb801b43146bb5d03342fe9fade3dcec1cf1d920f2f69745b70dc17d5c2205104c1f790b4c0702000f23b1caade06338e73180b5d1c325c9a012b0da162ab8faafba770d3d180a92f77549a64e76e45eec39e0db3f615449a8fe5bbfce17717540902bcb967633cb908bc621f1b9ab6b102ce016d75d10908112410382e68b66e027da29fcbcaa69c012fffa7327c5d1da2532f647d6b9f51be2752bfbe7f9c5cf62f870f2e6a10819f48f49b99c9b13ff08654f9c222a27caa4cb251ab5c49e8bf0f445024580bbea9a35383a2522ea59033c2be7afeaf0f8a9f4cbb1596b5af525dbf20672bd414f4efd23d59568520051c8f0c8202488de38a6d22fa88acf2a059e9c8d6bdfdce873024132b54d1887c196caf74bec2af1d2996111b2e6e63251a5f9b6b3e8eb167cc1e7a5dab251e5f95109a6ad092563fc8bb9ae0b7fc30660a96c4d83aebf15091434aef1ea11c92e9f70d2af75c59a1fe7a71a79dbd7441d2049f3691e6adee05e991fb129dcf5ce107a4bfb33c055ef333f67f1fccec21f1c00a300cc10911fc6ad50146e39339e867c9ef071af01953a569739d67fba2fedf27af1302eb4c8e4748e9f91f43e8286a32ac0ef95db58e142c9cbd965248cc25bac550300bf8a59584b0eb2b80a167a3510ec525b1bcc7bf66a5679320e562ca8443c5d851a2c931f4b4c3e0aee852d3cf2397e01e6b72631af778a3a1d89bd8284985d28e41b6270008144919aa2d843019faf63f21b9799ec46e6044fc51b1eff94728a7e926fda782f82b14656322bd7c0669a119966ca5a34b09aeec43f87e3aba25492f50b284c55d6ff6121418a30ae01071f295f2deb28463f0beb6c11b3c7e432afdc7115a3643669f86e887d516d61b186d8a70ed05ffef3b962fe3d23c1b05313d84d15fb2fc09f6a91b253fb1c466e0f8559caee33379ed7300db7233dccf0c57197183c2b49901e1a53a756f834b67c8d0e739606da85d1f7cd3f3d1cb15e2e7389be73674976a18ec1be1840c3b3949cc3fec2e860be9e983580ffddff86863af257331d0b210d4782802da2f9d821ec40336f81f7efc3d33f235ac328f22038bed2b88488ffea27af91fc35859bd0d195ef2e86983fd111da09e769bf11adeb3da63b6adfec5fd7700b811e3470f3efe5a6a60ab244f96d8d1957451d1d4b04b6fd89d18dc4e2d114d6e660c7739caba9d982e720add76e655ae7fc19a5b7f91e02e6468e7c3c159990b3f8029fc7580d0ce059966bf09cecec021f34425601e6e30b4d6045416aeb690c4b3c18d332bfdb65a6ea2c5f786f3b4b1699e8d4f93f61b7dda9f80057098f61341c4bc48913753951094d9430bf910d2f1895dd59fc7e5d7bb2ea53b13e0e06f659a7ef4bf6c8c16f46a13ba26ddfe9c19942c4f1a84c0983e6b099ed768a160affbe3979d02bd7b115e03f1637025cfa97a621fa9a9ffed7c9b571c3e495b3e0b00dd6deaea269b1bff6ce23361d0f4c6c08ca0ba686187ce1129f65ebc5cb9f5147334fc47b05f0486c3e5d9e0bbd101f62fdeb8a53890e3bb08c2d80a3a6b7fa30f2f83a1040f69d99c81ac2215b9012f7dc3996cc26b102368de40f3d47e20571216a67d6101c5666d24c62c3e223c5aa1e463ef27369810be944af9d21ea8960e510fb0aca983a097315b303fa5748aebc15be6224c2bbf2cae10f73b1242c43ea73a36f2ba45a571f28a0274e093c4cbd0f9b52ba7203b96b7751b44f15c3bbe7a93748c546560a2f7b2ab9f830a4110b58392cf316041792b88f59d8cb3ff0ca75b94691ee78079a4bd205796c3fad9bfd0e0bf87a68a2bd0d59190cec0bc0f3bc5dce47db5b85ce7c39b2ca524bfd661b9a33a3003fb045ad6f90f2e5b0768bed80b0c30fa5eb097bf2e3b9848155a80f10abf8a581af10c81fcd31f3823eb1ab2f094db27e6040d2ad137c3bf00b76f27aad9b2d0aa6ff9641ba86ccda811e3a7cb488002852ad54e25dd50be60c5eeded428d570ef12e78b7fb1c73226baf57b57efbfd16a31c3604e26c9c5d4adf8f0bc1346fbebc57de92ed213e28b936fdd9e70e9803fd86f6df3d51648dfd9b71563c43dee6f2804d9a60ea1207843ba0e37dcc73be7381025b4196eb3d1b1c3fd78e07e619245a6512bec9812d56a1b480a3202e946027ec31bfb4ba05398045fdc7781d501443f50b8b1a551a4678d997482714cb5cf6be1985df3abc7ddce482c215504f5e027a0f1f7c265bb1248c0922bfe2f0fabfa34c65a397cd8ac4d271b4c4f9882c1f289a053ca7d227507ca2994e55b489d38fe41c577ee08b2f786c0575e0e76c16173782bf3fe751a9c87b67e1af4944de78ef1e234b7e3d6849409051418d63e4c6806d855732dd050c6d64db1b98ca7c7467a3c18f77d7d24a0cccab517426d08552b3cc58447b7edeece1cb2ce293de3a10ee121f7200e622aab3872edf0d7ef7e05ab8459d9d6c9dd72d898fa98929f8a7e343059b4437e70f2569498ff5a37fe5946996f0a8877fafe59e7bc07170826338f31343e3a8b966c89cc43fb7a0e10f0ee8c83b54d92e292480a72ed57bd16f25038824a4dcda60285b2031fdf37192931b21bee57c852b6816bde3ab8ddcf30b7792f961d4d539b0ca85497e23120401f8638203e0cd524587200bfd95cfe5b554feb0cd2b518599038d7f331bb8f0fb04c26d2a8cb5e8712fa15d82e369d878f4d4ab8b269bf7d9595c0c6b29cecfefa139c2740da9bda0baf96af5a3bdfd95c9a430f5c04854417ec1989358a6ccacebe745dc8cd1724e3c2dc263a85aec8f72c99b032cd75fc39427cef11d6758abb89301843634fc9c7faed15604d08ad8ef93b123b90905bf66e4ea099d1f9e6d5393e1030d117606e4741f98d748e2501a55e76b23a2cd66f2d045196be89604c5853f74248a66b9e6e21cb44588d1099f8fab11cbb3dfe86e5ff790980be9222ef3f82c62419ed8b0d16a615d6cd4bfbd1ee7517d16bd55f18614b9e9dc19e7b77393a7ec772480c5a4462c4c5cb99db2808dc80d668e31e77ac3111691a606a44854958003222751be37faf8ba4ac9677b7970fa5a9b5634b9a55073a835922dd46b23f2ea9e2be85d01496521bec3832d35b198abcf5d91f9726c49a6aced17d23267856dfa97bd077879b1e59feef92aa9a4dc5415dacdf4af989f89a39e415238d8e88ec4a5fc3d33391948272798b94c3511401e17cfd559b242c88fd9cdfaff75be3ea7710080793b22f6a97676998cbe0dc5c93812898e9e076d1382d15f8bec491d93a518aa5ae1a5062cb38e33fe8c8f21daa0734c2fdea98620acaa8f2bc9d2ca7490803d95835303e889a906102f7b9678531cac7160792ebe3902d1cb1feadd91c701bffa7dd4cd37c68328ca881fda553946a4b07df9aebf76daed0a086d00abdf370852a5d5707f9a7f0834459a30f734396385bc9dd8238ebf5889762249007eec1c51a613a626d8f4652279de3e282686d28b8a6b05f088b87b30957c5387007e06e6add920861cc953ecbefa0ad0cdbaabf1bcf70550cd5e08d6ce8d53e5c755d179295755992d19b6564304f508db3ba35aa877ffd85bc757abd32e75569afde0251c2f12b5ad49c1fbcbcbbe1579e0e0a4f679fa6fa64c06d5bba2febea940ac314335a493bd9ce7fd2805d0dc0a5f767c574cdafd7ffe5680e3215cb454a574703eb6a53fa36dcd9f4cfab0088b9b22431c21cabd3b6883e0e0bb27675230c16de229fa22b2e8c56eded160eeac4525a722a98b1c9b4f78cc7f96cd3b024068fd89f3848aa7596da08182084ee37eb8d8bd9285e13e8dc58baa7b4e8a071c027948314ef17fa9852124dc4a7ed880e886f87569145aa8dd56d637757308ed6f40eb98fb4fb8f1706e19fb84a8d7f786ec487a3434869814310ee0453cc1c12ed1fb262ec123f63c4e7a172fc0a0f40e12b30f993fced7be2491cda973365f42f004f09cfc2e42d79178835dd56d23bed0b916b75da9ecd82cc385a744f90f3a4a883893d0827883e0eaaa5cb0619cecf8b8f1a5aaf36ab26eb98210307ccf19e467eafe49e3f906b1bc376178cee7706e9497dacd88b5c0c76203e0971f18bd790eb5ff631e1b487af857a4aa66bca46e8e184f801ab786919f7f448a54b9c961a418af7c0ef4e8e179e7a37c214463eabfc4f8a07f02733dc74986f8ef46424288dc18ece03a6e8b5801ab6efaed6cb2fc288f1d193af34595fca694bd46cd43ee2d01da64206493003031c3c1ec33a68fac62b872e9ebc001700bb50082d6dde713889476f8be68b11c452757aec3a873d795e1094b93823d08bc49293ec1680325dc42b3c5363c7e8e8d39a1a6a6b62b531fe1de71d1235a485031209f2ff54f83495047f2efd8812e6f2e41c961dcbe8aef447c5f613d28c6e08e2728671feb40a21aa7af872f067b0c2a56f0cb5ebdf770d78c6ed087fa5417c012c2c15db0f4d8ad79ff6ba957a809a36da8339a567581afdc0aaf3912837a5b416f800216b9875475ef385cce18867fa949ef0b38a73216329a1a647786b9a16938150f4f5b60ef325738f4e96e487047de34413bffe581b849674190ab6fb8713a559a874090cf36c4e794589acb837811fb8ebd10a686d1a8144b3d18201ff87593585abfbaaf8929c206bf7e968502f7b0a38e231db1e1f4c7841b061dc99c48b80683e40beea0dbe8a19230c24f410192b8f1e5c14614643f442c6ab5a2eefb46e23f109b0d9a7aaf22cb7a23b5c8449cdcf7d1a8ccebe575d0fac723fe2f12ebe58c15dc7c385083b0ef1908af9066f73e025418717d56f626e2020df1cc039528409aaed158f1e9d8e23aaec948c0a4e2eb8a0b1953c6171a7646edbc712ed650a8bd25949acb201097d5e0340a4f4d7ca895a498d09707accadd4587e7695436835ed969a836db49ffee82bfc99ea959730baee34e23206c28965dae263166dbddfdea5cfaed5cf9fd2434bbaa04c59a4cd3f075dda4cb8a896eeed051d33f346db70f5fb87a0765f3c4c79fe504bc9ef21e4498ae6c4681edc51f3e0ce084f91156121e66fb5c7df0feee1d71b239bdd8654930d52a58aa8c4ef8e761e5b0aefa87b4e6e4d16f6d998943c1f20384a54fc8c1da025438a80c6e780880d320adebcd6fe612ee803bc90a8f902691a177d95ae1bd77b35ddd24dea7e3ff35a6ff3ef6c0d2134cca9ec0857084bf33009a82cbe8dc11d0b7f5a6981d40d6d596f7f49c34e3801404450046abdc5b1f1982a414fd3c0cb0528ad22b2857379bc55d2a8ea1713b32e4ed3d547b00b11e20176752b28126ca305a144dea54deec2b39ef32dcd0dc71ccc595e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
