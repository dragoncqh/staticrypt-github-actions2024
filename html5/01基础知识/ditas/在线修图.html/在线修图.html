<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16b55854f1950b79dc1cff8e25ba3b5f95e96fdbae4aa86a300132f147c244945e27ed08ea615dcddf62240c12ea931beb0f218940bb1e5efb534595045fdd5d9cc15e67a9f31ef86d3f27dcec778a9b3bd891eb11d64401bbba04381b5ead6111b6a6d4a465115c1eaeca233c80bedeaddc17869d81b1c9edf865c84388757229fff934056f8132cd284a2bf7a75434255ca75bf6722222d7fecdf6a55fb2dde3db3118c21559a73f4066d523c45ae8d8c4a00b9f1cc1ca3bcc0d18fdfc60cd9a8ab8b38a1d456ec754ebdb32d6b22b0d263ce201365a1f3c921fcd864466d3ca14638bebfae419e85bd93f3552baf21ae14612ffc6e604521c7db2256747de8c5c642de5436d799aebfdc9d13725d101daab054f39670e7fe2299daba28622050bd821d8ee62c9f3c9e663cbdd9d27cc15152a67b7f535e26955c7c46ef677ba90ceeb7bfc1976c51211114a1083b4b8e05bd26e245dd216ce07733658c4bfb8a54670d822ac402873d9e0a32aaf07e9d5e535589367d6378984cea10982901fbdb5c79dedc63598f638c6337582a32bc09dcfdd51deaffb9f714233858402c551bf10082a8553e74636ea50815e16fe322202251b9b3c8c7437357cbf18ed5f84cc0083c2af2502f513cd136352a92d726d0553f81e877be4fd9004bdcc57d77e619b73b413198f6707736868ada7c844de40f2a99456508141264de1707186c63b6e5ae230e9bc910eafb851477d634853d3a0cb24a12f7caafbfabde05f603b283a72c274ba3d7ec379ffaa2783a92f49ce11960a785ae70a8e7fb3bad9f46884ae9dc9eaa29004a3b568e3e8c75777619b48713e1e0ef7e74fe2b6049b46abe98470ab9714ad38a8e3c297935682992fd4f9c806ca7f0ee0677cfd4ba38da7c825d9405664a58ad3f930b59028c82c68809160b686207371e6129255c000152eb38e3439cce4147220c43b8732b53cc80e4939ca4a5bf6d54c740e463afe7804ae9fb60ee9ead4d779e363c1ec0babf535c5a56694c667f084b46bb4df9bdc381efba90e6d73a229e6e21f493b6fe5cc52c4be877edf7eda88f0119e9979a0d2a5c3f5b2e80f1b513e1ad3cb09ad7b60d767da307dc31f2d655f3f620d526f9726040d52730e05a2340bf26a5134df9cf81f3963ebb751c67ce286dc65ebebe75033e7ffbef01e79e2b27755e598bfb1d0c73923bb4addfd6eca0a16308367dd49568beb556aa431b195494aff84796aa10c55e43426e96898e48eceeb8e7cd4335814235326afbc7c10406ab99e0a4cc29ff7cbd2c0db94508249f74316731d4ae7f102928301902459dc386c429e0faabb20ab0dae8ddce3a6c96dfb2c8880b72537bbffc64c4f2747f534171d8c55adcbf66e96ad8d914306711f103c567af0703ecefa71e67178aa25a4b148b42b96ca8e5911f64c14c609942443eb3fe722ff748a000fb1e4be8f0b5a6ba3c7e7e14a0986a7e4f9e7e00fe801ae937251f59eb04a56bb2168cd517b58d8075c8e518a0e5dc05ddc573a906ef4b0b2ab5b43456268b5f5b3223709748d3582eb4852e5bd368f905a6feece3a6f6b8bdb438cf48435f5f8ae7a423ef0f219cc075262c5dd39db7d2898b9f99b8011f572679ae4c68810f170620b216c15fc1898e781496478bd3fd5b4e8065a7271938d84c8390729367352cbb7421e3a432d89e66ed211c03fc861bfa62fe51d8440c37703ba521eabb248e6320b5a1ce40250fca9197d5cb40561537e3a296fafb9b8d79702353eab1f6780bbb42645f9c00d54dada0675e0e35905d715f8b2c490828cca3607fe94a1c31ab36ba4ff3fd3711f8f2aceb86f86e818f9cbe0201d492cf53afe2120b9d739fcffe5784fe1d5ec9ba15c6628bc2c306eddb61def81a9f89f97dd45a1e706c3a2731d6bb33260c1ecff48ae447d1d582078a4931fab4d50b588b025a13e459334c59d1a45fe8ea23ef0ce5d1de7beb5f6dc40b6c916a80348aefbfd194796ec496ee54dee864bcb7ebcb198ab95dbeb8414132daf49291b90a4530b7fad5c20be59785d286efd07012325f56a5b3a7c1d3a9b25cdf30cbd25009c93d58d5263cabf9401d20717648bae3f754ed57e8d42c4171d259ec820ded27d907a26a1fc93e214cc695221ce11521e5573ca7b18477f6531d7a37b0dce0f78f1a26f31bbe21449ca2a849fec20fddb41cc81001a4aa746b1c22ace9361ccb5aa5845c460140ff2e1a0d3f63db0fb75e957249535c820c9a8709b8b941d75793e5eae089e0f74803ffc54f95473577efc94a74c929d8ff6c707efafbe4566ecdc7f6a70d74f2c79752d2f390ab9960127783d7dd3701a605da07233bb295bb99a58f6dfe032ced0001456b2e7a51f05130c37180c57f6586f0287118670cd298e4a376723db7d3ed60021214075631177b7bcc4d137c14cb651e557275ccfdb79c7b4cf22dad2c4b9aa7428efc55b860e4eded77a6b76e9b3203af71655aec67038db0c898aa69be7d60dbbe4fdc4b7fb3875ef00d1fd5e971e72b204970179f7a65d8d5ce7872c6c057f7506fbf2d76602f554da59662d4d398063ca38b5eacaa0f50e356f926fdb821b0fce5c3cb0486be39c4c9f82cd7c2cd7208c324716c46aad1a4757704ba0307bfe46ec23de0e42065a143438a81d21fa27012bce969a7927a5812cdbc1b527bfd5ac7acb968e6ada2f397fd13e0d74c648013a6e28a9914827f8438b2044e8996b33310ce6912082701933bf4722115f5a14776468f2ab20e58c7bdfe3d7b32f6263d1c26acc31a0480afbc8c283a5c2472d793093455112b019bbb69dca14059917bd392a2ecc66baff2135d9c5efc6f905d25076a4b5223d1039f668cfce4bcdbd8fc0b2229bd7d09f26fa6d8d3cc24ae6de82076135bf7fe87bb70b8f036717b4618cd53dd96934999bac32527ff7e3de65f9afb73b80d297754a9538ecb45d91887050814b0b81564c82176b2014fdbc471ad07bd758b4cfe6ca4cea40c238c0bd7f5720330af7f8076570f2f6ddd25948308bba1a3da31c82f5482c4d2bd8f10621f712c99a2f565df59f9cecb5fcac2790d209f558e73e36ead37808b02ba3b4eac124b1f1a015d272a11e136c300e6cbb70f994d124033d1867c68b6d4e2cd73b1ee1ed627a1a04d5dd32c710a682c7536d1a303901d3caa65f52b697967f1cbaa6438c54e099c52943715dcbc0e6ba6fb572150b2824ea386d0b4709ae2c6cf6458a7620d33e919745574da6afdf8d202cb2e7b77eaafa8e4ff7a38026cf261d79446caa27aba1ce06a298a29e62ec860823f45fc4ad5cfcc57c7bcb72d3ea65a94480c25319802ac8a7b7e228feff0a6b661f50ee9ac4354ddb65edd3d8fc9490ca24da8416981ffc4dab0e0ee065897dc4d10fe8f59f4c2e93067e11395fa322ebb1a65f2dea8cb75504c892670c218f4c41dacf4570b24fe036e0707af3b001e1f12c9744a0da2b6e04ad5cdd2b6d62d04c6a109e19e9f4064bb687f2b26ada6b0486558371ccc1b14cbb6db106f61b9c57859b2e8ea375540a29eeefd104d257244945dbc35a3d1e5f34381a46be6dffd6bb3f766cd587cdbd4c3d8eb2f78e3db2e83c82ef04266bc58abd78d6cd496f7cd1443cbfe1017db3baf3158e5be928ced38d684a3d6c75fbce603a1e0a36229791175773e2d74104d7cbecb70f87cef21ca8a1ab83574f0d0fde0bb194e010c5c7edf6ecbd70772de0939728381cbbbc48467850f8dcd59bf748fae5fea6c314aea3c182bd7c9b44f2306693325b1c4510072c1b5acc7c773dc190ab0559440913db883c2dc5fc2be72525f9de092ed9e6677e212af6e83a5ee0d1681e96e5db1f6b5921e7748f0cea5d97d79fe7c6c08e108df61bd4fab92475749afc6b139032b63d237f0042f1e92b283ded9de95d3e72c2ed8b7f338ebbafce3c8234d1c8711e982905b1d81b9ced13d1517d661d415b14ce7eaa09dcd65a55614e5d4f96e7822dd36857db6da2f051e1fbd6d9e505729f57e406c00c47bc33c5d626e0e9a5d67b77664e31bd46e090a0452ce4d6731b84c21ec40987c553f1459d2ffe9a35bd500c3df1ab2ac0d4aa65b2a70da37c1616cc643482797fdb5ca24c97d249cb2bce26d7913078d58c3506c9977c90efb41b339a4ebef0a8bb71a88dc970741bd1a4820fc17d307da36acb36fc5f8dc7c4b412b12c758621f9fb7d0615cc417cb598047e23a42ae569797ab888d80eca7f41c2d76b17842eae87763b875c2bf4de9eab62e46a110dfcb46b0d61baf1e2e439419cc24bb9cd2b91c245bd495ee7cff4414aa44a039d48e2a56335e30a7b93ff074c28ee1f43f45b4fa40b1e443ac06bf7e7811355b64f7261126c8999af4e8bff228c042b081387d36b7950a16a63b488e519cc90f1ae6b6ec0a442f2606721629c415e7d0abbb6f2cf8569ee6182f5ac5b89655648071f36b8a8eeb02108bfd7f60b464afae309040a293f16c16619b908dbe9699149d4acb5a38698fcef84b28adf4bc2f9e03a296473608ce9bf3b108b40a88d5997ce55ba936404576adc4c136eb7d1c7d0c147caa449b6c936b573c0c9ef2512fb7372ce73756aeacde18b53943d021f44fe8bbf998e08f00d58d3f29214af93388f0cc1519cdd5c5276d9ebbd86538abbe57a891d8f9f4d13c4905e0e002f4b25d7ac4b8f80b9ec81f30fa068a4095533fe1656faf9b87855d53ce9cee622d8596afa47d1d377c42c6b548f05ed780163e5b878d9a4b779575d362bd8de1050e828f2310e73d830106dd220d66158b6b76117e7c2449c6b892203ece7bf6ce77ba6d69a7690c6ec5ff1c28408658910a46dc1e3446837ea50cb18d392ee426cce9134db37f04dd492634e2fd619b0b3450287ea4dfd96e2d43aad55c8263be566742ea76bfe84402bffe3895ca7137f0a2f47301af6e2ec3c9bd9a4ba6d63fd93b9777732383cbd7929cac5e9a9ce160ffa6bdb9ef37e92ad2ca93104a9a482a1e33d89c62420871eae48af32e673f57792386a3a2fc40ed7ba79212280473f066aecab11fe96b2b8bf821fbe9d1549a409a8fb91d7573e74ef48affc90662e55556cc2730bba48b236b7cd21f7987f5a4616e9dde2116d6290578be269711eb4353b5681eae15e53dbd5b18108b15b9b3ac6859be82c8c865315fd465d897131456bdabbcaae5c877b484baa57c03b2df23e4964a9c02018f9a24e79cf506d945a81700bdcfc714648f2eb01b6a260578de6925b821fcc3c1ce36ed1fa1af111bf5a92958c53242aef046cc55a38de661275a908a30f22933cd6aebb1dafdfab6c1a772596249a4c839aa16c084055e1b40af47f3f012eb13bb88476288cbb7ead1ed40c2ae2559d6acbe01aba36bc815f9bdc9fa9e493c122ca7fa66944beaadb16ff1d91f23a8a1292fd9dbb3f6e542ecb85216607a0bd61b79d1eb4a5374a204408dc0057e6706b99b336afa3cd13322dc4450d06a9a0364513f5719eb168f4cfed8a2589ca6bbe59f31073a909085670e408fa9e551f8445dbcc66e675352030509a0e78d44d92397458479d76ef503ed80cba8959037445e8b23e58d2d49df05517bead12544cc4e169a5ff3b137822203043597dac002e0d052d3e027dbbef208294b4d9a05dd94050497db55df057cc5e5a0b75ac34dd509b3eacb573bb6d3a0f28be45721773021374bce180a512f4b3fbce0f29e8d9203eda0bb6da3249529329fa08f22331c949ad0f54553b1a779d107fdda0002056fedd744ef40d631d29804b4c7ed78c0393c449809649d44092416748213aaf79ac92c7872b9b6628baf77875a3d95219e55cb5a76aa91fe7b7a4e6aeb88dceb3dc9cb7447af4e038d38a7e9568b446f80ffc084ea3f7f42833682f584a90cf937ec9bbee751cfaf3e97c4f1a6cf61563da8b83a355d31374ffc7c972fa3b72f04291c14f568cfcd46393e0cf39e4b8e2fb27a0c4c8f04b9dee5250b721a5ec90de1eefe30e730b1dae673b3b91691d41ff0891425cd41b807f79d1f8e0d4cac84de9e9ceeb8c18ac0e2982026e3607aaa395d8960694f32868b06d22ccb2346eaaefc1ff74a7b76df7e72992201e2cb4f593b8ecaf5b9ee833781dc375a3ec801193d6d316fb72413efa4998ff61d62967b9b256fd181bc5bafccc02fea628636c6c42661c0293fb2157f33e54453457c6079919cf5817bca8c69f8516e355549aa2ecddce82b4a2bf7e05bdb8347e3aff5e96d82e082c1a1627b4fc2157978b44386de762d603095051dc8b08792aca31ab449bf0a460e8f1ff741982eaf779c46c8ea9cda986132d17edf0852326ca34b338c3643f90db611868856a3a12aa9959f8a089b48ebdf440de245375790f512f47a222c6418152e0e7b60fa8178e8501be4e84076aeb2b9fe4c2a6c011d063ff550748424d937d7f1aaf2c31b6654730ef7037e0293c05e46944b3b42735e8965ff38169f5eb8709953b7db1c660e40e243db0903448ec5a5e20e2436dca5529a76c90a235a3c5c1c81493c6424e5c76a2a41b540bd720cea9f14a5cb59f28250818c151cdd3a4785875fdd9beb81a6376a41ad219b9dd02271bf26ca07fe4593b67f4df419782bc32239a7ea33b674c698e382bc68d1a6c85683506096dce9c4bdbbac2086d25eaba4a1480b8ac83a34d99db4518147c5c063e94836a6d28b3904c3f9790d0b6cc8562a6adb581e3616250605462232dc5de6d184201a2445ea05e780c33de3e07467c756a20d024480bd30c58b7dcf1ab14d160aad2803de1a6a0fe58c380c4a69c02ab0298de6d58c52909691f2f8370e76475057ebdf6283400db23244b652f006bf3c0f3b722c453dae3c92e632e15c1f90100ad35357bda54caa7092dbdf1c9227525026a8aae86bbbc36d687c5156de8a6b757e79be41e846f6010527e5be8096cf1af20ec07adeb42eac1db99d222068ccd23efe22c7d02aa924bd445fc1231cf070e49d937082a082284e0cb351ee2ea6e9144144e45567e061914a5a3a81a10ac03cc2c8b627becf19ebaf84e90c50594e9d0b3ae01953cb9b8bf49ceff18a844d06e3079decd2561159bfe08a9f7f1000d169ee6f512970f21f027c6bc98497f3a2351179a825f2b0d12fadee0a3cea3f0c69da2fc5da54db7563c241cc096cdb46efa8098291de5ffb4fabb850d0f2d1f6f3cc19a96853880c87d15dc840f8eb0faadaddd9ba13a4f3236cf0ca8865e27ed5b293c550fe917bc59aa09124001ee88172616f207db1ca793f6056beac14718128ea6409b12bab1e752d67894a6cf354b79872fd4746a3458252082d7c9b259466ac2be367ddc1ff2a897232fe68d373daffa9b5ecd31db824e73a746c97a94ce8cbd5b160cc44a18138769cdb54f78f6175b1551889d05c247dc3f07bde014584d1f7f671e34829a0e3208af4612f145f2369618cb103a0c5c7cc6d745fc9a04991397d91b13e96ac79c276e39a0199512cd27dd2b0483ada7a08227d9137b8c19168124e780926170542639e26065f9237642cfb5aa59e03bca5bdba8a3a5432f6d31e9b2faa8d72b02d770134170f658addbae4a276e955072deb2901f47f2583df2e26743f91c2ecea5f6e8c9e0d20989945315168db45560ccb0bc5b07061227ac273ef25f949136712206f551198effe4f21ac2a5e95b97792fe0e8dce339a91a74bf52156ab3fe67f8819b1513334e457d73b5c625aecd1c05fb104de8ec872b04eaa14e908cfb88237f70b261fd8aca136913282b044528cbc49eb430d1d1e0b7b2c7d053ef69b1299145b679e26fbc8296fb096a7566d476ca5c4f36a35327bae25f6f7e0ee67b62c42811a0159a14de64194457a0f3995adda0d5a60366f0a79b34076d59ea1cfd658d05820fb9a5a03beb32516c6a91d4f03c5a9c59c80b6cca6273d0a404241b89d6daf96c2b22dfe9cf81772431158cd3cd4a2c0583fae36e68a2f9de5b7c1ae73c4a20ac7f59b4fc556ec1105d48bcfce5c76a5f8aff3ddfa9213c2edb7e7a8073699af26c265009386079f3793c40d763202819180fcff2e17c21bdde1097d4b07334814d1e997fb075027787bee6a2ad7e192ff1df7ebfee8718de1e187f6ec5a02ba044e8573b5d5b126321fc966c8f8aff3c53805648c57926c9aacfa9bdb97272ad997b9438257d5f18970c53c1e63cb4ac8ec790dfffb941513a82a65b714fe75136cbeb929e2b4e3c79ea0f639ee15c7277a88a4df009ac38a28f1bdbbbb40a3917407fa6c6d3d82f6f576e2e7631fd78cd1cd13524ba1c0e6087d589763e035004b1162499ad26455cd84b4ffa365cdeda1c75bbb2cbd365a15403798d8f95d178926a247a19a3935ad173cf1b694d33821ed8c726c3cc5f5362c065cf5efead6744f1ece0df8335d2144307edd0bc8642c44cef02457b456911cdde65b4f48d8aa4e6a8226057d953e0838875bc6943fb52983a20f8173bd2182300aeb16437100423592e1920f57b9cc75a85176c77cfe8742469a746b7dd26aa15dbf69561160491ed92b7697c58df59fd15dfed0c67de51a3b446b094149337c1f084f402214329a3f82589619e7d1f932c99e96c8e6d15af5cea897026f4c5e9ba8885d71e423a82381acaa1ceb751fc13b4a249533a8f17e3a028047a99f9a852868aa913039e394127ff0aee66253d60bfbd501701d13ed19ae3997eee8318bece5dd2e8e432ebc73f6a76dbb02cfc2c79a805a26824fc07c3ae50340c082877d30914334dc174558eccb22882b14f0049aabc03a842c6eb0308dcd288fde4acb6a122f6c7c7e231b4dee2725dbc9e9335ea4f729f6b7d39197de5f75591b9ac6fd26334e42f52ae0f44dccd0bdbae9c580a53e1a885821ac7eaa796a289d8c8fd96085ce50ea456801078f69880f6692ec0b84c5a1c12beff67b74668381322a8fd99ed1edf7bca3548c52bfdb0fd5ddeb0b33f8427929c6e680ecbde9de88f2a73763446841a7bbe84b23e96d2b407cd71428dac3e61e4fa68c4d55df9afb309301522b1fcf96bd513ee7bf8aa0235f199bded26d7d1f99971eb56773bebd88c59a9233a303b227c5b02986d14852d6904607b8a3410216e7565729cee508fe7d8445776d2c443cd320a054123964aac91f4bd31691b4fdd4cb7c8e69b1d327b2b19f11573063a96265597f77b6b1141c081f16ba1ad5e9cecfe2079b3bc17c8965f23eb7403f7e034b8b34a389f3e7d8e7b7c6c1869de6dbd1c57c085305590049ced8600049722a2a886938454248ee22996bc13cf4d42789a9924a374acd4d1add906ad987f1a77ada30f5800c8490afd21701014244b86ebc4b5ecc992f8c2edd3d46533f8775167e85b0163dd661e6bceed26e44a04703328d3054b1263ec58a1ade7c94404760a4468658e517443f82aab3c1efdc633ccac5b262073d19238fd1a245232a58533f7ce099c19e66b695e0929403622971f9973488052407d52b23562caf7c4c8c4d1ab681673bfedc4f40f0821ee9c613ceb01e97e40312d734221b63c9f14d07cccd31c7b55a8498cf823ac868a9da4ddfd5af8740f97080c78e0ce6763860b0bbd839f28c87a442e09292465e1271bac0a90690522525ed8ce38bebc4bb825053ce3289c00f9a1f6c377f64e5f60115cb066360b177808ecc73d74670905fb379f91ceb767ceb5d41b523c792a1c6c4b35db5af4296551f851282801c70357e492b1f96b927e483ea8dc92a7de06d911d2f1eef7555dcfcb2c96fff2049bdcf8d7bc860b7350928da48bf779fb3e2afd516723542c9bda4326992ed884e23fe5bec21bf8ea3c0cd4d417388330a54e7efd90dcd204694d97e19ee060989305e9f393cebaa31f9be92ceba19af9c662a4ec6415d79372e150504a4ff8ac7778597e7b6ca384bca8043f543d252c87caa0c01af3974176ba6f0365fc93ec6d5e7fccd1e97f42f8f55650cb8014aed99982be7d4728203b4730175493c1d946166cf6ffd5a500470544049ed2fe3e4218b4257851458526177b98a4160b1accf5b1098ac4d7be91a2efd06d3e1d5ce1164f22f4b111534b18a1b71387e3221a4a3d7546ee8b54dde06bf0f22c96235cacbb7305abd1af58947c601302685a8d631c6b2fbe7f1abc40b385c7c70f05c6be6d2ac3a8fe8fc980246375f267d79ef906fcc02aa21c8dc8b7c3f9fc7a0a4acbbafadd9b9598fefcc9390e071cf44a4936fe39b5430282b9fce0e67bf8c00d862a28a2e848fe7b3b585d1a86409e6d67e00734055681b01b1a6af258179118792a7321954098ab276d2f4ec51ffb982dc1b50590690bb50d1f60fddd26b26e4c29b5b9cfe4efefbe957c5995f2c17ac472e66b1e6ca94e1d5b88c3fd5e2e8d7d5f4b003f62e3c554d619e98518727a0ad9b89c42bb2676c0f575817b83c0ae08e8e52da0a61838fde90a8cdef89cc729bd94f0c73f0024e43cf1e42974a51fa8ac761999daa94ade4ff0d54de247a126c62a878b9f53085eca19242254cc10dc4be532661e68b890401bca326b28bf8256e0314ce61479839119c77014250f9c6cb18332765ce7876d57947227e6e2ed578171cd17b438f2ec388dfa79829b5c3f0c2dc5ce746789f3b0a3c5a8a85e140e38caa441fcb6c4df5f2c116af6d1d391e870a143faf99e252d436eb4cfc3bf09ef9c1d77fa3441c366403881c0a081d153cdb1ab6721efbf9c857cd7bb5b3da127b26eb3cb078873d2312596ccbfb594e0afc0f33ffc6b2f0778582098f8af4b86fd5d4cc9da3707408bb7d1a141727fedf551117d440f27c5bc62987984b6be581059fb52260db90b89e41347a8e5306c244d7e4fed4b5ea847829055339df8efb9386bc474e1f713f8ce35bc4d22113cdf62e42918b953c876f04b32a52a07959407476cc37226859817cdbc9fab1d21642524c2b20fdce0c597994dde51d48ac0a3ebf956fac4447885c44b493876b6dfb0621a724bef90784e9417a2035d7b7e7b13588d3871a25b9973d97fc0aca0966e1c9ac4f9979d4c5c4b9f70af1f7bd3f9b17b9d853c2b7e076fd666cc2b2ccd3a3dcd7ffae15e8ee29b720d8d0e40fb685266d4d74e1183152dfbfbf812f94f8001a876a4fcdd385dc8901b499f712574009a51adf1d210615b37bd7649cd54257ae3f63c3c5fc2380b1698665691b58122d5289c0313c3a44ce3984a293020b13263dc2ab649dcd6c95bedcf66317f2254807e3025f4bb751e46d27ea45f51119cf21a10bd49894b4322e00a06b94d9bcefdddb9974632f97da2c8cbc9ca551737501f8be7a07355ce3d44cd23700fc4f6c5309cfab2bd60b48b7ee1ad613df001880b025245e0d9a0d81d118a61e123606711c4a19f9eff2afebe18817af133fe1469e5f44613a393952c8d2700d392f21b7591c3340621318c342bca5961310dbc167c661f938997798c452fe18a9a4ef73779f5a471d71a847fb6ab209834b975fc6932f700bccae1c806447dd0cc9b54cfd343cc15afe334b266d5e720d8debb329fd8fdbb9809c6f041ab0de40be78ff67af9f9919f3a8dc2a960f8e934f0cc0afdfb5de26ba62edd2595b28fe364aba00f3f4468ca9d43d05fe2eeb3c49483644fde73e05ecf47d8710117bf6af718d8bfc6cd72a5f9635badd7e1bfc2685dcfd7d21b40d14ce5347442d0b23db8a51a908c042cc320575481f21be76a9d76f06c4ded4c9e46e22378485215e993592f00309fa4cfedd00378d6b0f275bd55a146dd25f2784ad359a293257fe6ad207f674eaadb98a619c48dc3879f38a93491e318cd2c681a455620f9f890c8edde9ed474c3d58f59ffca5d135ba6a9a6816098941f1eeae8093616dcb99e1587833f788a2682f7a1f62eae3442a97189548531b3b627f535beb73b937650ff94ce030c9380f4df6b96c94c56c2149330ae7852bc5a193c99d9b824b5ecc3327e193de610a7b224849e5c6f7850c26ab6845c97002673266636ccf26f3203d0146bb470232e546e9a7a6a45d5a67ddc8b93e757b739120231cf28eb62c323a141e39c6798ec623e170f5dbc7eefd2d518a24746c9c73c2e0a4783631209eff1a5f7bdfeccaa70ff49f450238ee0f392becfa4d7854288c5ba72d98dd7f3db005b5b21410bf15b16ad241bd32a70f09205bbb81e74ddd2ab02725fc19f471b14e268f7431953f5889662c47466829db6dd559f341c3b3be1eb39d0d82d5b8100e4e4bb7b722c4d300eb65bb2a3660a816af2ea5376a018179668253e09098287b5770402f30704b6fd76cb75f68fdae6fdea11fbf87ffc8e871213cdcd665f53a95775dce284f22d7d5c5b3a89944cce0cb88dd5323a23d9a2dbce43f0af8bea5c70a05f8393727ffccee3ab8f2c256980f3ba576589f6d33293bbdb47c480d6e3f85fd34ab2264ce23d719526f5dd444aafdd394ef88ec0e173d7df1637b33858544a22b1b58b9423065bdcb7061e61d7a1e38ca75e4fa864aa40b96706a71022f75553643c535a42038479c5ae44ab0b674580c7f90ef0c1aff84f916684bd0fc56df868e9ae5efe89affd60c24f7c1a92f2963c5fa6fc3b875796546aabb09bf8bcb37f6fc2179d444576b4074e95172ca25961da10ab3fdf7d4c0323aaa170e43b291f480d143d1a0a1d68a7f1c4bc16b83f3dedc757ad7ead1cfe57f386772c6f6872b6c11f1989835c8069b403d827d0f3778e248fe9a86c919350d6a3cc37114b8508261bb9c1cf58840fcddc0732b51ade249386e1ba16a7443b9c19fcdea9494b3fd738821123c3ec7e5dbd2e891589de7214df96d25556e36d0b43dd0916bac3ed0dfd4a7b856e865b8dc93422b926b4cec75a7471c28d529b6b603924d0e198a454f4766a8bd76085fb2bb365804b3e15caf6a7e0e357432cc362d96c1425548fc2c970ab720ffba54ca539422c52f841d962a88f1258d592884e6f64fd791a3010","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
