<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19d9e53021ba515d398a899d082d44152b01fb9b1148711e05c958d0fdf01a69448409fdb03c4e354ead3e64f5f7fee1b0d98c7adb474196d7252a913e8cd622b86f8dc60745312d5f07e169e566fbebece7597f8e7ebbaf3307485c84211771db0f68963d536d4f7845a8e37a321ec20a14d7fc2d0df36a3013199b4e2a3020844a7cbc3a3b954fb5dd947aa675ce69c103f36760774bdcb82becda88630f2f29953c30bff5e5ef18dd46d605852833c6d6e4c34a5dad3ead4a0036636dae2d0989289e5bf718aa26495682a329e211e033c03c215386289c28b0e03aa2ce32649b25d5ef86200aaa0987c4630c510c0ae953406f60de96969acd18fe427e64bc0eb3632b871127fb38b7098642a74507ec86c3881884c9a3f38443464d110a3a586d2d5047c9da71f625539db6d9ca99bfb981b3d9bdc58c8783af1517e13ce2903ff51b00409a8f3b98c4885af651c92d32658a9cdd174da9964c16dd8bcb5fb82d3b0019f9322b5d6c8fa1b1cc3b4891388d30fb63ac878315a3fa513f656897666e6b5f2fd106c6107abaa070cf5776c1e6f70e1599d1459ef5499f1094ffc703b992598188c839a59ce37d2fcffec474aafeba3bc0658b0c3aa471766d44d889a0939ecbdc657f3183a24f8c006307bb208a91c50bff63f8b85a8f1abe65301e8a38cdb70f3b339cea26820d836c79d5dba1194f0988ce619e7821c79b64780f2170a2710c436f9115f300a6b8f0325bfe164d7316635760f1a27fb511965898f0613bce5fd1d85f2225510214f1fcbea3350f22a8e599afce8d679cbbb80231e44a4247e240f6a26c9d72a3d45591117a77512c218c3070f1838681cd3f6046ca9745a2b31506de2fbd223c3a32cd7ca8c1419da7b992eb1c17f2d9d9c1ec8eb74a85508dcbcab0ec77e2d2092c1e8a76733ef6a700a34cec941bef12cace5551072f905c9b982d8ec415b408df7a4b1a02e6c6f30d48597fcf53321a69ded11be6f904f3b89b8394a59dd350437ab8a45080c016e7799ab9f85c7038dfacd21ed8ef3057fd7024f932c45bcf297c484daacfaebea282f42e87d1cf8f9517624b56f0619dfe7c836f9b9be58a3413ab007bc59e852b6ff2e4b1408b48f9a8c393d76193f91a513d7ac88a96027ea47e270d14916c923d93d6ff96cc045276ee1ac0f097671147ee5db99253c23edaaa9930caf32702ea4535d444ec207311dafc485604fc160da68750ae07257c6dabcdc050342c4fc6eec2a729811c514f2aa8e3f46056377bd0d729d930e5ff813f84b32e83afff4bd05876e77befb9efbd2a656cb59c846622eea903d13195f3ef95ab9f56ed9a5c6b7c3b86c7f70a31f2177c61d31868ee9288a78c3c112f7d0546463e6d9c424a05df2d7bb54c0125ad969886de3c38468bd0918d2abd12a92bfa1f6d6dee06edc525af42cc3ca2eb3ca5014480a41544cbee080e8f348447d18c35cd6c739d8e446ae7cbb8a706c957821238d53c1816d12f10759f6a967444aa130655cc1545cfe79abbcd47cbf0fd1798e36f272be26c0c188e45570c23eab37b6b7854ea84a9ac61b4720fe04b4adbc1a95afaaca242e31f6a68e1ea44ba386fdcbea2e4d3f1d0c232ca5a43cfce3cad619f8f0d68967e0d96b12d7132a54ec0cbc28105174e74897d29d345530b7a20927367c616e91965f2af7395befff2cadc3b98325f9299c7a257a8a033feb82248491f1322482ed1538105b3b854ba3ce2a68fcbcef83ec014da7a09f6e9ad9f67697779dc0240427e449b52e73415eebf225fffb4135e5506f63096ac5a475353ae810be226b6fbe0026f5b64562b1d695e8abb810e690ddf60b373409b418f4c8b5cac341b621f1c8dedd1415bf977bb4cdf63134c83a734eff35316108687f8d18a2d035dd604e743f17e9888d0b07042c4f26738a01c269917d8356c8c6e81e4beef3dd518c6470153a9b1f83d0195f3493566ed311d50813a4adc39bc74d34ffd933185ce0ddb76a92f9b98bd58c2d8aedc6c62d1d4bcd65ecd09fccff08b2b27ea79b49f2a2dc1786c9cd03456657fb906c330f9aad344221f85fa778b8429a0b7ad5f7f44c841c6589a698811637baab72b09f593a35e62cb05a11ef67485f5f7a5a9394c7805b509b7f6a7775c7939495ca8c297f0635c0a4339317009291a96ec579b6403f719fe8885f973167ececa51ea14c4487ccf666460e9ee0126584bf0042c3a0d4857383037f3024198d20ebe5c30db6b35d580dcac644ab67dfe14b1a1fac614db1dcbb5abb1d3c66e500bc731544c3f3e6187a1854b2dccdb3b87a76cb34e85ad5e2b92a8844c2dddfd15f94130f3eee001b12f1c3bc4aa51d2b8427d8db9964bc8ec5e15e7698bd60e110bf17ceb09955e6e19f7716c88780665b2f2a5c1334d457aad35d7efb572d45b5c7057f3c927dc504011e94f261631ad3397e445dc7ef7c348a82450251631068641c8217f0ea6f38b0850e198e52e22334280e656b5c36454f6276d5e449f83d9e5b7ba551ef76b9754dd0a3891727d8bdb9912134a66787b26b953d64d036618272744b6bf964b2093bef6da70cd08925bf0dd2a57b31956cc4e4cc0fb149c8202b0a964edc88381457263ce868254411846f7f614fe59441d717410a7587408d03bf526d5f89e57b7253dc94a21c7ab8c5952327d71e931b61b663ebf8e6b0ec89373a05f06f34e8c86791d70075f7bf22824f77192067b6793f8e22abe63670c0cd9fa5b918d3dfb22ffc185e0eaaeebaa1acd1695cce3d0bd9b4c2cd933909836051f0148905c0c93e878a6849b1eee603fa5fa662d573631310062671d543cf6ff3f3377bcfffc49f31aa601058b2cb29dbaecb384c20c7b7682b6d0e8aeb144cea70b29a08a19c9856882dc73fa4ee087173b173b734b3dc1ddfa662571d433864cd67aa6ce2cacd0c184c9de821852c07058bcc2127cd645d23a25e88753748ccc8d96a5c2b6983225de8094d435323798f01f627376e233ed1a2d884d2e9cd31479b68942d1b21e6faf2660755feb271fa1dbeff1058d879626cc20a8b7bb43633c3060d6bd3c75ca6e8a404036cc21b24e88d7a55cc0664d33073574621acec52309e030772c5f99512140baa97cc3ae4249db97fcdac8f91cc2bed469bc26e319631ba2d93352c5ebb0e045be640a4b0df8c47dd37eff200d8dc1f828fa1e74ff1ac3e4c9d9b45b3b4c5e76c95f00d55ad6d20b13a30c63f2c2aaab4108ca062f1854ed06d5954fdeb24cb8783c46a7d7386d4e097fc57853e05f2bf1428b65203e27e008a63ef4f656e362562a26b3c07cad35c7680abf3084fb6294aa5f0b071eec8e8109dcff33e99f0285970c5572a1e81db86fd06daafa0c19e2decead80f3d83f83872ec8628b29d5f105f62e417093e512dd8c5402ec419248c5b261331ba2e545ad7983b4b1a94e8c8aa74a201cbe8d765be12a3a8da1aa6c0f8c0b819c4e2e67112f875f641f1d91c02c2790c95ab57805fb64a43ccf8f14e6ee6dcefc6bc48f379fc9da90d8e93f600e798f476dc5397c4e4fa9988362fa48de23a7b6705152d0a5e3679550252116f49014b1179239476228398a1649cd7124933e12a112c280dcd2f2f8ae83a69d4512d5ef2abdbe6552c7e24f9f118dd3e1afee4f734bfe8ad4000c558bf55e493b4fa366d5e18c6a34b9d08937a6762d62a14203e8cd8299d6553218ac8de7a13a2c21feade7466e5c8c2787abe9e20d875bb29827891d1219f07f5f93a7d43a315ffe0500a6127ad2988dc0c8978e6ce77aae121f89eb4b7d44b3818d70859751504c30cf1a2b6334337482ee2b0b2b1930e49edba8687321396b43318ea50410caf813feae7f9a7dab840e3dac92aebd897e7b1317d9ae675146ca75aff5ad7906746c3dccf1cdbf950dc49eef79a12cd3a13defc15e8fd8be91addd18af2d8399623af44ba8cf7943124f4851b6e83a34a3db5da83a401baa09ded8903ca59b93c63cce350b9c257f8aff4d1a45cbcab12393b76d5bc40b59190382c18148bf3c647070ed43c0ee8a3f8b3f76475c8317d93c63f6d928d25ec74e265095e2eb066331ffca58eb8ef88d831727f7e5964acd57d0a37f61b96a94f1f8c0f247b643121a94ff067292bdfebd1d69c0a3e9553a6421875742a38a32bdc38dc0678d7bb47d7184fa868338e254bfd9af653b51d8c77b0124361f6baffd79cbd38fa7ff2225ecf27855085fbfc67ae0cbf848c98dd59b860271aa200f319fbb37bc467eafb7f00585f7777bb1dfd0e12158c1fdba399d93134e6e68e7e28fd2a80dba77eb96ea999cf66f434f428d5c0141f0b6f39512d403e50f43601a1b44117df49ec0e144c7a0379aa6bc305619115fba1124b4ec6a32869173b15976ebf55e0a9a7ba9653e7c2990e79524f159481a1f3036278c544d6fb198a2abf8d57145ed9427bc2021e6971bd3b0107ef33ab7e4609108adf364f6ed16b2908b010ec7ffc411e7c067b1cf229dc9fdd3f8efdc69688ebad488d031cf90887fcce05888b85ea12d879770a4d288048402299d4f8aed4861a10340f9d1a07ae281d9c6dc186bf3662a69f6b91651e97b4c6df81a545b579f542e83d583301d52e0b9a94bb4cccdf0fa86198ff700eab44e19320faa87ba1ea1f3ee894d4ab685b5e2af1bd0f373750f7393fd9319b06a4fb7f5a1e86019cff95c0ac17ba6bfda12134572764115501a533ce8ad88d52ac3ec8eb7fb2e9170f1747be15095ba5b3cde4b4afa0779e7658ee15a3c30226c183b311e4830f99fed2d930eb3681618fea6a30e8ecd63a6f6e7f95529ff6dd3f4fad9675c3e60f5c587ad2e877e3a0e0281a60d1efc7f6cf3d771f871e4be82035c4d2db2cc543b5f0d17b8c176bbfa4aa04cf10c6cc3e2746d62fd530ab31ed57135c4bdcf31d00af1c6a1fbbe166e3b28c48d2bd6d2f5a0f1c75343ff4ec3fafceef89a59213509df0b364bc9e9ce8a1e6b7918861c6af57254020583f8b7e7e75438526b4d102ec7389802130a5898ad2d7d1734b8431d5d24e2f5c721ffbe374a5e8593856721fbb5021083686501ee6a11daaf335dc21734de84c20defbb75d0a7ccecab6a01b26ce02c4b4deb72baf6b2256fe39a87853bbefaedaa2fc5eeeebb4fbbda478d101a179ff2a211b992044aee0c6f142a9044f19d2c07db7b3816e93141d5a18edf681609d589685cb6378ddaa15c260a92aacd82415d24e44a6d5871325a47cc78602b0bd6ea9d31a88cf8675d5964c56b1ac4ea69efc9579955b3fe2acc6eac04531512e8a59675a71ab58840d3d76d6ca207271ed45fcd81d28cd863ff21b5b7e2820e76882a9ac7fef4e8e82c5213ec0ca3dd500ce02f5494b322d882ff8cff918a5dfbebfea5879d17c58bf3bfaf5d2ca74a91b66b6ab9bceb447cfa7ffb244f79b13c2540bd21769d9974ddfb50ea9250e278a88c9f6d5b8892c7edda4da94fe3b38031a7225c4620fbe00fa4515c0b651ae5387db963bf565da115dc308a34b8ec1cccd2633e3e47c100629e5b2d3bc29c077c94c00df9cd44a7ba1a12f3533593e31e228cd03ffa2861b16e001a72f0ac0c11f3b90bdd9f65d441452118c64f7f54741cc8d70bac9005d0520db9e1b00ee330f73fb3ff559e8687ad29747f2d6a20c6009161c265e3f04ab7662629283729c35afa50ac6632a2bd227b5372a8e6a393ce44416174aab4f6128941c0d2abb880fa1b608eb817c3a6bf450347d9f5fd70e7f30469d72ca1c7bb7975988360649aa9d4accc42df3a3e0a0b39896114ccd70ec9b9baa2a278f2f16e9190832e6516c8f3064c39aeaa252f0611ee03056133f6a7276a054e32f3f208ef9f6b40d7ce8b2206e256425a50ce2d233708a0b93145343ddc59aae449f9c8c9404c0dc577f9bd6ec175deb1b56b5835143062197c16518754fcff610bdf1e7e412061752227bce558b339f37fa2de5bb0c127ca637b0bdfacf1e8675f11b7b58d2340098cac740333824d7b2d10ec9290f8ee50dc0a4280c4e18cf9447f1771ad6b1a8483d4ab9a3c0b97f9a25a8598b19629360b6d089a8573526e9c4d1387bc201ecea3697c4afc70b5fd688a4725cfa2f53955a96f857b8ddf293fab49875ed6b4a8c8776a269f9f9d984372cd9b758c1944a7436190a610d4968db941c5a10e96cb056a58a9d36e25a20e52594e301b4bdee7284adbd51d0db0b87b7dcd0ba22b1afd7592f249d5bb61b88e1ddbb7aa441b6de393f535fbb05fe2272a92e48c972aefbb1ec33bdc4270457c421dd89e4c626ce2e2db4d36ce5300dc8e0fc3b732c1f8c205150fb5214bf2b3b5cd6e2e25f04defa602a5bf50f1484b17bf67921ae0a6c4507d4e1d4fb2b07699f0efd7ac6ef4d830751900674336a177faee9a6575618578ae9b24a38a1f8218fd75fd9669194aed334136bda0231629d1091934a2dc24a0829a19f209139068108ab02d5d15b548b233c17951dce217ce304b61d72a5ac279796dbe82f62bad975ec9ef84c11e55c49bdd99efbec0390a2cbc8d2ec9b0e4aecde99ce94e84523afcfe0a352278d64f21413a8f0bc489bdfe6ec5611929d3037ef359401a6dbecf8212e37637c7506990405a5cd16322fbd1d4b8f08b8abdac1e268e66b46d783f3e026f354d1c2a2edb5b998c7bd75ba761f82255de23ac47d91868a5cb2b4c778d8e0b51535e0b31648d657f645e79909e10e20e4df15e452c0a90373ef95fa9a65df33d4480584c62409ebfc4b4ad3851bf811cd47587877f5d2bf3de7f62b6cd32c26a566d5f58cd83420db2cd12be435b2fc6a6a15a67b421b1ea51b30f7be7f1916fff47ed6a06d46a5802c40108818af5043f6785bab60e900c9829f4ea6dae0fa7497b76d8fd6cd3d8b5bc87c701c58769208e4512e72cb32079441ca789c4c532e69292537d74b893201e40a732fd8846377925f873b5a5343c2797a2f77a15cf46463e453aea118d18734f1a39f096010c58fb0f146fb103803a07f80647e74a710cccfbc2ed8b72e5e1240e0e999a29c059f03a708d6e66c8bc536f9c826d60e40163aa52acbbb47936071fa6e01a8dbbb72ef108baee7de87a86d753d4d71815f2e24b89fe7f3e159655ef31b71fda81b4c17fcd393d683073074a50de3132d7d134f74cd711b2cc147f7dcab9c09ddf61ec20f4d0e1c7d856b0c6c563dcfbb2c7ad75415db5ffbb0cb840fec9a384c8ebfe9c84bff207ae902a614697dcba29f770db3ecc1406af326af33c1929bf0941c52fc5b23f9c4eb59903dbc78f0708d5ef1ecd418fd100e4c85904d73c3cd5f0f140845e01b5b597f07f921b88411f4de89b34c8273c02f098533fb19e2af153d9bd54b5fd5d714066bb9f76732de696ca4cf0602463a590298f3e141fb9a59a8588679505e86d174abc57faff8e885948b2cd3a077eca82ae90aca0a00d56929f43cdc1c74262956acb34ec7b72bd9b40bc2476d782aa1e932bb6ddbe2fa05b9b76d6740f8ac2014d7045591b9e83201f84af727624c78819c94105502474fa5447313486afec2e2f95b2402db788458c17c2c7e8d5eb891946bf59729520157d3e0b9e34a80a446f39fb420e16ace0fb50f541389b327189faff604dfda10c71c8fdef7e2fd3f7c7ac3c7c9511a309b67edb05a2f5076b0d537878b1baec63c187f1a598e84f0c04a0618d2df5184952583a10f13e5ba5948830c06af4ff7dc34b0ee313484bc8fb95045ae9537034a5d999d36ea28e19c83e89fa19d3312b62c9c4aff9c0ce878175a16f90f2a854ae04fa598bbd86c2ec1dfc127f2c4b8bea439594e8628b293ae1b43fee959660ff77a7440c99ef3b99f20485185511e614de73644d35aaa9f6e1aab3bb43f2eaab1604265452cbc4ddd1271d8f973e77301a37d93e798ee49a112595dc87e1463ad885ac5e014ccee57f0ca79db21d7999170d5b7984639f4e45eb75afc8c71092187b2cce69f16ab1b2379df3e85326ec2c06e33a3b0fdbc8b19700eafc5c4353fbb7d55d5d0413216613a7b19fcda801821d53dfcfc70ca05cecbd4759aa1ded4eff6f8364680c1df311849f14e07830c6487256af862cc40c32706c81673a61d682df476ffa29b97bf1289e682a92edc318da46f26b634440641ebfbba28664dc684dd269f64e6d9de0a910397ffde2a2990049fad929ee98e23620c891d0415099864f02a53891f6e009ec1efd6280c28a06c0ece9d41f68ab9b9c443a4d8697082b8ca7f2b2ca833c7f1b8fdc484441a48eac0726f3c0f38db3b4248924ec800d50c7bfefe82e22ee99a80a0b47a50be429a6a9f2ca7249e0d09be5359d334daf57df6f74f4d7294b889f3c003ac01b74793cd28012649de7ed361afc65125db274387edb6b684aa94964218c852438672a78faadcaa91b9316d2fa74cc847b7602bd8dc0eadc887a196bb395376430dc4f920a76f61d041da6a9ef5d9b265ecae97c0c97f388aaeb3ee6f42fb8ae90758719f5070033db8b6600e665981ff82dcd5910a12bfc15c4fa134cd11e530c11af7da2e027feace9ce5f943c452946383089b7eada42dd6299631c1dab0a35c4e0ac4b45614941fbe490ff31ba4851fc211147bae21732c1860cfe93a4c019e4f2d8b21cdcead473bb1d94dfc04de586bbf012217c4ac0898487c43304faf23d0e47e77c1a832151f4d4413982f0846d52e118d1861541bcd172f269055e28248240df5e825e2178d2dc58a6816a7b4a245442d5df65db4198d3d97aea0a26c02078f79b3f68a9267bd282da22720848d48ae7a2adadccf5b2b3552a78d8f734cf77f3a1af0b0f2996088a44cc0c49c73f552f79a415c955f89e835a207e76da434f6f19c43773b80f63fa7a6f0033359b30b9633001bc150f8c7d04138ff7413e98cfb30a9c3c5681630faf2c050c342e188b79790d5b48e17778aa3202b45d5addabc69e853a0ce0444be012b7ae02d80b0ee3f3e2c30b957fb5b7acbf4afb114691b5972b7e8afb569d73feae2fc0d56f519933569af9803b7cb65c14c4a4d2a0e559634994654632737e5227a4b616b7649c752cd949196524d8293d1718b2081d01df01ccd68f8538372acdba662b995ddeda847068346099bdb7cadfe1d7d248d710f27321c38cf4bf6b78f3c129171310e4e022d81f361184741d60f630be24f6b60bcc990f1246d1ea8f782cc6abb2dc5aba568bfd54a8d4558da8fad8bf69666021115f05f953b172baf3f40fa4f1a17889296537d8bb7e5a2b0c1bacb820dcadbc1de66846a7e42dec517b613c977835345257d0842fa441284d7b339a773fe851e5ba7d3e8ae33f3219b2fa7dd4cc7eae1bdd25d8edad703556a97d56812979be663f47169a5a7e90b38691fac2ee3cc0445306633bbea1d7d61432b4a8a4ead49e1c756898ed544c7d827ed03a8f2391fa074db59abdd98db346de5b71974de432b3bf974e64a4d7e1101b0c572a62a75cadfd02ab00ee36f92e494047a4b7c5b0bb49ce954aa5d60645aeec37802f48d82a46dc76a472840e452f3bb384a8d283406b7e0f5f9abacb7d03c575b564a98e9bdbca7fded27196622ff1565f6151857db92201de0bf9cfa8a3a4bde7eee2fb626dd275b1e2b0b01a855cca929a4ccb2eb46fa494eaa2148e0f00740406539da77b8390b93a7463187e8cf94538a820cec88c3da554b6dfd194ffcc1110233dd8de2a0541a15400944e8b435126e8d0fea0c547057450df3c8bdce98a55ea334b539fab8547c17cac4b11687b9825a033658184e7a3c1af131c595888e1c005a9d6dc943e092a8bbbdbaf4da0dc10c256f5dc3a0dc592a84bdeb6cebf1a2cca8e4f73b137885ab27d3a195945485fd7f71bfa55fd7d8ba97f6490cd1fd087cf4a99487a0cfbdeae3f89524c2bc48b0171d14073553dd1c165b0c1182acb01ff4278c5d21e03492e96093fb574fad2411dabb5b7e9c9a3f835042a0cd66f3c7ae80382cbf0ff015fa4eb525e314989da7d61af352abbadbd9d918a51b9cce367174d608cea8adb671cd5c84a9423edec8888bceff0fcf77129c57ce4964a3f29fcd58f583c2716e0756d67a2c1afc183859315fab08a9f0510ad8a8be48899c844e2230850291eca28033b6035327d6430cb26e17b06fce04aae17a23df6ab5cd6fa11722640b3e93e9c2f4feb7fa77f652c7a64b26b049e6735b2d20359f003118734455e249f87e8e938fa90d3b716d4f6b5e6d196725aa66b5af478f5c8784088105e285da1cd59c01914dfa876b8f598c3c7eede54ff6d1f260c3eedf4972729ddb55a62daf6f306db03e174ca9716973d66b6d11500490f6d61297efd331f0c0c7cf9a54a03e83845e22e078aa5c97ca47782084d89ae985cf90d09fb32043ca3cb1da291b888aa50904749404c90ca05e2e1e8cb2f009d3d85bb140e58ace37c43c004481599f63d601cf0871a15c02a2c44e639efe1fdd719ef8ce8dda980eb9ff423c1c42b14665b79be570e4a39dbec8761f53bbbbe655b3505c87d27bf908eede9ec58c6ac6e9e577412bedb1baa77adbeb57d831ef8b42ab9264ba5c0af3986dc58a2360874d2dca6cf8c3aa15bdfeefe52dfb439f32c7461d9d67765bc7593e3cc7c08f2765095327a9c54ac27c680ad8e1b6807d3000e492625bafa5dae050a857fad60c3de440dade51a6978241ca75b2cc27c24226d715d9a88304e30605e6426886e050ba61c592f85e7c63a872de37ae7b911a35aaa6aaa1838f8104562f34ad9952c671a16c355eeee55d94071bf13dd8dc93b557f69cc15a70c48bc1b936327d49da27b8aa745bdeb0447397c909881727cc63d85528639c8ba832c21c8a7bf242a93f5b75ccda98eca0f2946953de10b7689a7930b8fb58cc326306ef2c5e08a0864aa3823204e4467a411011de040d5c30ff7ff3b06e8058b0d59618d3d5aa7218ab5bc18bde258423b05a07c0a278f80efe7054536c9f7375d9a3676fb84613301964637e15c310fe3c174f8f74f9fa8bc72cf1730032fca2d94e2a6283f6ee1e3fc239bbd74ea548c9f69fad42a149f13dd39ddc1dcf66e2a45be96313db4c410c35b55909c97ec82bde5544489d2c6fce33a4af951ff2a61b02fb77ca92bed9eded8239b73b33f13a81e548daa7cf2a65d7a7fd36ab29789119dee095dc0f0df7d990c3cc3329af8068c55c1af7e1c17a3eb99f5b155aafba2134963dd789b5285a5ad2e7aef5575c3c2db674d38d4f41990e2d29e6dfe9ff2e640f9f32a10ffbc0ca97c1171d3613b15c3286cfe3f96fc19e3d6452b66ed3f539dd6d5d09c88fe9c842960bf901769b9511b8b2c06a0cc613f285f664d16ce19c63f392d987344af2deb3399d15c9a7177e234fd9510c88802e22ab16b3dd3d73084bc16ac70631e178a679ed82e5bd5ea43abe2032319e0c9f2f7fd9eed0a4c985661d3ecdbbf89bcdb0654caae1be77363516d5bf7a407c355dd5c222a7064014a5fd04cbf2cd2c836c79feb8a9f8367e076a677c307e74b651fd265b4db0587c68ce24f17839dfad77ada6c301b35986eb0816408672fa2fe3f0bc3289e40a65f8b08eee8217999d3ff5664d8d59a0ab401168115cac80154bb079f678aa0c91009f0d617a2bb4bf74e65719e6d5d073cb5cd5d0c05d9560be767e03f640970867e3326410098b1d10b7edad041eadfdc05c291765e2ce4368fb5a1a18bc3dd2d1f268ab8b176c7d2602440122e1c77f22ca1dc57917630d8bd12d2c57031a91075805f9c3f5ff68ef860b61d19dee204f5e4c7adef58f83b4bd5c082996377b464ba6983abdabe05d78569a21752ffc46665b83616794311dad4f741d3d61596c6e706f34bab07c5c0fc504295e7c20b5374da4450d395a86f04db6c93e272b308105f05e636ea6405a15aaea959cf5364487f9168350ec20593bec146971e2a571736afb9eff8b9b8f326cd14bf481a0af2cd74ffd84c1a31a1999e8706f76c7310c0dc07d80f9148a66148563f845e603800c0c0e0bbf674fd7ac88bffece83e0915745aae3ee2e4674f9cd2f9146b0fbacf9076026ec4aa6863945e9b96e3d44ed96b34eaf634f2be2fd496e24bf0212eca9877b190529b021ccf6b51780ca7941eb9513a7a543ec4667579bef8fe2f880188c385f2e1dbf72cfa833d09887c705f2388282c00b1b5e64387e9e96236032fd0a97c61cb3c7f14e5671eac4b69387f1d339e78c326b16ff5b96b9ba774e68087407b57aaa1af15ae267f4eed7d06f939d3466b1f4c21c54fe7dfbc77891627e3c66efb5999ca61a8793fecdb81739bc1f87476667a4b0ac8d1f660a0c4e80af865714bb2bfd92b6b381a4e5748265254d9ce33edf2c7afd8e7ebe1f55f84df57b310be5327dd319a5b5950d6b0b22b5cd27fd2dd6de851ee134a1e0b0530f1315d3c74049492c7969b37e558463b0ee87d16078ea7fb50c79852f3cbd58f01f5570d11943a4b77f0b95d07f5e04a6ffdbab926667bc0ca6045a41d79138c816050a765ac7566951bdc07954974322ee9d4604aa2bfd12c99a789c2009c96236a524e17c65b1a9bb9dc81d245af7fe6ab3de94b9c0bab7e9b07f3d26780fa5c1fdef13597e469b531475beb71668756fee51dc7a18d2cafcc23030c5dcb42d9f159e25524e07636c54ec317547ea972f2704715560a51f071c42d4fb5a0f73363ec11eee83514467e6d80bb0cc1e08b3eace821dcf353cd3bf9a6c6e1bdd4879d4317ad8324954e30054bcb2e714f7f46ef537b2ca20a3a9fd2595d6a9c09349240b66678ba5d9200496fd215439024298e4e7db22c637da24f29b543db931fd30167eb4d5f9a8f85d653b91c2d1bef08c8930790e556970b881885de5de85b492b23a9b3e833c1f070feaa0de3d82fe52ac8d6960c306fc0289de696f9562f3ac475f55c61d6207244893597da64372dec89","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
