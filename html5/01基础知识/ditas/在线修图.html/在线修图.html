<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9819ceeebb946fddb50e09dff5cc741130f39ebe444d841d0c499abd90fa62c821978ad6e8853455dfa8e589bfd1cbd202513116f13fc0ba9f9450b65804817f4b14ae3e37304d5cb2a7232d167e60c4445ca65138e0edb9cd6b05d9b6cf965d124754e4a2b8c24218e16d4c933026ae33b4cb45e1dc1e3a10247082d4671f3373c7e2d5d6b77f8a3d4a4ea194ef196ee18a5dc7c073017a29a533e8d959b0f59ef317a3505360a077cd5028dd41e894873681e9d824cbf041feb8da2209fdd7ff8b3c1cf22b8c8dc255df4d9c142501abff44e6d60982bb174e4ce6f89ec0ad287b8aab8a26159c00cc360db23c9886448a32256f64625e9c0eafc6f88f458ad9224c70e706dfd0d996d673e5e9f7bb375a86058bdddf7b4d674ca23010227b3b910ad1e22a8d15039356f26b4e88a38c53245bf5330561daf86f0f234c06c84de2c21c26955d6425fcb5a3c844f9764f97aee7fbc518f45030e9a01872798501799b5f80411ce323464606bab14419554c7c069186c6ccc1e01ee10bed7e6f36775e7243068843df303c0af2ac7d8e8d8fbefd436c081aac5c8454291eaf84eacddade42f5bd0e6cb96674219e3e47a901ee420a4f082a415a07348665397df4aedd411b84c2306920ab133763aaff8393b4dd18dd109aab868cbcfdf19eb204fb40c9ced19cf5e6542ba20c621ce2da70baf52fc94cf9ef8d7f4072368a088a9b63364cd04ebe6fbc768d9c7f26897360886e3322ab7bc954555d1fd918729a20190afb13205759e1a2805bc053922b2259f381e65ac66e65be1a74c0aa0bf45440a33abce8d58d983f25a49c63834502355262c4da30ede3d02c6cd5bb2e78f250298b6b9245c3595e5bd9f13da02587ab608bfce71b50fff45076d46846aaa181ddd822d4e34e2dcecce041f5dc2533334f44520fc744e25b79a20dd80721b1baaa05c5007924c9e0df338d078309893fb85531c0cc94e9af41b4b3abe3b45b98363eed503cfd6358cba6c17b7846e502c43b4c28c865fc4cd696111213894f84cab9b9223490e3c61d020a9a50365b6ba2e7cfc0fde418a09001c01fa1ad349a781e5d532ed7d3b61ae29f3b0c465ac220f56525b5901716258825a188ddeefdff770bafb96241fc5130fd0a2bef91e4cadcef6fe28ea1d6cebff0396c651dcf5f5b3bb63ef23a1ca89795c07eea5f4f8f828aa8e2e6e5c86f4c85b9cac4c22190439055de76c669da9ec00d1019e405baee967cf7dc5259d31a2fa23b28175505ebf0aca2b7244d2189fda26299413224380110a3607a9a785767893abadb9e042b4723f632ca2b5ff1c0b3548ad994d1a82f9dc7598dc14e5b4edfe75426d356b53c355e9ea7494fc6c78f025c508ff1eeab958f29357368f774881e19ffc8afee4d8ad65ebfe9e4b80a85a37460aab8b703710a617e9a9d20640542bf0524d3af67c19769fcc3b52216adac52ead6e8d62705ae904fd8fbfd0f2b75e49d9c67f08f8a5ad3c190d7b260809c0832dca66159e1728592ee6f9f1bf1d9deb126ac9eb1f8c936930344eabdc59470bd5c3dde7e3cce2196bd2018cd0d25832562fff27dbf62dfe79d48c994a5386d5fcb6ba8f48d6f39827f8acde66b1fcd842b064a218f1713cf880812fbdb673b7a1d2f3eb38abda24f8648ac05563d9bbfb89cae89c075dc500949f18af3ca23b0ce109c36e2fabd474e3359ec484c69646615bfd926d7d2fdce68fe505b1012fe81a56e59e7129aa12fc7c0bbf54d4007d320b312e08e70e60753029b4a25f13a48e23bf4b92dceaa8d3262fefc945f5d87c194fcf60bf135ac6443489c39359cec8777c436e2b57c38fd9716391de95bd236f4e7dc8570fcd43d6101d37097445beed1c7785cfabf5bffa23eee38b91a3c50b943707f6e52138f792b05853ca885fea075b55c76768a904b9ae1a91ffc1cdf8f52c05f1d019344a123bc7c7967b34e259635694d929955d3e7f2220711b982ad9c9508c765d2f555c1076bbdee82b9c7304995b032d8fa853b01335c6ea06018dacd26887d5dcd24237cda1e4f3913a2b9cae3eaff996f9f924a5ff24753c98a4ab915cad261ed8c8dc9c609ddcff050d482410c2cb15e71d44ba12ddc7d1d05f349b0aac30365f0f0a12c7fb22784625a9140e9368bb5f43d934470566e8477e3d76db0cbddb77f42143423eba1d9f610268371361226abefa796bb7d963b6f1d4bce9e621f84708dd39ba423a71ccc1ca5b431f5ed144a53da40fd19013e8f48d7d5cafc857ca3fb381d722e0b7e774fb933aa696afce6d77ac047ab2e836c61ccb32151864f6af8f482949848564438b52b7074a9b88c2208b38bcda83ce5f5e8ee81319361d41d85b99eb646180869dc9c9b0785f14b6075283f54bd1a22e40bec1d353e72dad539ad172b458805e08db5638630dd72b66e26f42c7902c414452665192161a977ebb5a662e3c4315517f84cdf273e4ea4aad4087e6ac010e9d76869fc3a16565409f72abf09a349830d8a7ad2c63bbae22e6c5c4a25fef33a19b2b405b6bb8002a23cdf4121a4b7327cf13b9180af97df6f543705e267a31d982b33c2e2f43b9ab8ad47ed3a0fd3cdb88bcff8000f09786d246851d137b04bbb8c826127c90d73a4edb8614e33850309061c88bc85f7060afb7773b46aba6046bee0e7dbf41c0221fff5ef58f8c8f43489de8430c3e1c577d35ef613287f09531bb85717a5b0fca3ee5ab5760cb2e81833994903145657cb80f921d172989aaee480743fcadba61e58400d2394de8191a1f15e2d3690c2fa87e2edb29b5e3f0818f7221aea3c93854b9430ffe3ca0643115c2f77760cf26b35eafe38dff47b79e4f51c41c170af25a12b4d2a9e4df2dccdcfda0afcb190fb792ce37066ace98cc3dd864752ad1704cd67ac6b313559d5908e3cfedfbb50b12ff40a6fd6360b86ecc8bc9796e35db21a3563aba0f3b9fd58e039ee350f3a47d8c7a4f80e5bc6cb2bf25e612ff324bfd79d3252c35f6224df8e306b74fece6e1d818eb57f42359f9cb5b002c89e6755aee69203de5c4eaf9c7b47d1cac2cd1b20ee9bbf4a7b89c76f4d7e6df19438d7c346ac39880d061a4aa520d7bdbf7bd1abd267aab0555a2009b340348b195e97702c10dce9a8fde16ff83eb4916311cab502cb25e3b02b0a60af5c23893bd9df068a68b42b0baae9444234aa2a2ac6d5bab482959787b9a76b21e80ae989cb79ef98d6e73313dc60cc2e275213f8450f920b9ed628f47605313d871e1de3d8f45b8b1a6615c49c4a04cd710a535e5aa50b81065d5b4fa9c5f222766447aafa76ef760482e8b3e8caa686a819764727bd5a4d2114e88f14db77ddaca467be3c2160ecef7215c509ac7c9a93ee269811f9d453963472145e20bb1b24dc76951983637869d61308d720587c032f92e97eba1b0bd613dee052128db3cad24aae163d3372ce7446b8abbca84f1eaa8cf3485bec8a3f3125e04cd665ec9b862b08971ff2bcd796a0d28d6cb3c33146cadc8257af905a1b58d17579a52cf4f400de8cea4f5aeb77bb0c9e7ac105808c6bf238de0ae09d536e1f817c84cf99913cee923f5f80095fc38ad8967f48c434506eb0a7a600c3d7621a42127b37fba7811e8455a7ba2ce1b1b3509db41e0fe9f01d20c4f8d088b2f43417e0e9766b795e63d56e32d9b3753e34d8e1ba49b1da0573b473bc115397a5cc62b813ee48187b92b9f66de1486272acd1372458eb4785a0400cee137c770fee91acd08858c0133ad09b966833d817b1391e0a0e875135f45d4a78a06b8cc4e216272f9b8e6045a3de19e0ac325ce7967173db3982c4f37c07fdd0cc4cd2be01181fa82f80d562e2f27238742cc86e86cbf30949e7271ca930b08d072458a54b4b998130a13abaf8f68aef17c289638688c24e3bf71f8a2046bd469d587a07eaf14e71b1f97aa6c6d9c51b3c9f51aeb69dbee307ed921e889fa5a59de7cf6471e38454543561b4410a57881ca5f0f101bb28015550f0e37966fea0b8b2fc86311464cdd19c3c7a07e44accefea597476e2c8e391ba54a63caa6e13be6b50ca1fa53da9a6daae8951f8bda4df404a75712bedf8f507a9b78b2d2dafce6e5f92d5200ac4b05d352bb1406b947d81b73e2919b4e6b64aae58acf33f02bf5c0e7c0b74b5e59e24ca514dd1bf394ef546632b6eaa29acda20a4fda0c8966fa6fe8330f30fc4e40afde4c1d3a21c4752bdaf0926656cc6af457ee7d26d163eb21cb230979e401b4ec75048a8fa19b533a5c0609188482df9cdb10d3a8fdbe86cfc912595541d23a4d58d514fea363b054d596494e0f48b5aa9c4e415aff4e370016f7a67816a472d7c4ae60e16d1a8266c8758e058624fef41b914ef25944d874e8f89ed5a00ca2fdecdfecaf02639cf7c14e84ce876cc64fab8f58f07061a0966955a5bb8376d4801694166c92b08d38558d4a60838a2d1c22be5a479023b19c3c39cd179c51719269b8f907a4fe673ca2b53fc4d59d83942d0c8f497aaabc072e1623f2924ff969acf6265bac6c27c76650923596cba832e24519b693d2a7d781542cafd06cc00cbd1844150d37aa931988aac4a343f26a78cfd687343a827b9e969af0b116f1d1de87f406fae04ec29bd3d47039d8f37b7f14dc7437a79ebd4d9654632bd10a027c0ba8b77bcf5b5cd6d5d6e3f66b63c54a61401dba6652839ab4611e8156bb7fe4bae457e9b1f9d9a2d17e7d7d11df9a2a1a30ae666b2fa98dcbc868288090c9ef7a4dd5567a6f21e2558e0127ffb46d74364345ab0f880a376bfd5b3efdb38bfcdceca835a7c4b303203305fc4d5d153982e4840a9ee6d65469182dc49335280f691966a271c17a1db6a61c6125f0b0c15b8db515832e3e95d27e8499ba96863a82a3566ab5b29ff85e79977022a0f34adeceddcf213d2654ce5f9c17c62b15cdce7eea1d364974841ebc674a67baba917a092cd380eadc3a865b99bff469d1bb4c5bfcb7643fa8d1f5944a277f5bb30fdad8ae17e4b1e65285070c6768263bdbe196872f3efa4f861eca3fa2b6b02a4fa4bc196c06046fb7dd16a57bce4f03cf71c7fbf6e60c228cfea4811686aac499a12f72473995aa02ab940e30e0f9d6ad6eacc6b777e5a1b1e3848bfe4b5c6e03ff546a5b18042785e3f124b44c223208e71107857bda248ca51bca663e9a7f0b1cd94854a3fd0cc3e25d128c1313ecad4d9408ddbbbc3b771aceaa0304e926446c8a88a541408ad2c3ac6ace9f8a6f0f29d4c1f2c7f2ce875b1e47996e6aa7b0fce3f6a815464dd9da8daa0e24c9d1678e8e256caffe17fc713f4d7372958e126f6986bf1d6affe6246d608917a71d15b102922e553d9c251d46715eb1edc020b6efd79110238dedde65ef3e899a9808372fcbe79d2fddd24fd7f69640aaa3fc77a8c27420b2682d86703063297ec11d9a8bb0ad2b4effc57895c8e3781176e40a79cfa8bd68a513e37f233512adb9ae1218fa76c65e2aba2e0951fdb99fe97a9e4f367495ee8ad8f4ddd6e52e5947f8456982ca03c00ab35f79e3a3f8c2e3219bc72026eda14b3b4298de88085ea727d77f690c6ae13f58c812c8451bd74134d996f0fe5eef8119daba71b9b2823c565ef05a6bb386e46f31ccfe18d5cb8f73fe732f98f581573503ff9aded7c9b49c5037f2ead47ce86f162a141fd53c536328068cf8feb555ba3ee2dd86c8d09f162643209cce03d8ba6250f38f140776b803b1f5bdb484dfda7a9e24a5ea23cbb4e0b7c211c1271f9ada2e90ff6cddf72a40cb1ce630b688ca9e63ce641f3f75e0b6e9ef4c0d4a19bcb2dff2e0cbc10e69e9697889a5bfbba035328fd4e58e2590386d8e7f52ebed22fa7239a2da6c489f1f6dc08481546090875dc3254b253c810edab2a23acd8ecbc819bf2a042c43b379fb77a2dd6ff3c63ce3632434029ec1925fc80c172e17a755d3148f018cc4cc071f1e9c59584d0fa9c3e6e1bf18c2fc2c6cfef3c84102879dc675627143e13fab54aeaa9ba5425281009e611f09f8fbd5831fd023e82eabf5318191da305760e16888698dd780661696daf40746072054ab34c355b47c3f7332b9c3cebe5ac69b8e9b656448df8fb88b59ddb4d2f9037657b74c911cd102d3ddd65c23b18d8e38f70d8844028cd73344d441b9fe3cbcd229231bcee423beb06c2ca2647c3f3a21e5af6c4f281f90038ccf6c732e1187573e19dc1baadbcb532f67d432b1dff481f81c785d6f46b2590ee7c929e221a4cf6e0100353826a883a5a6918e62719fc28da8ee3c6c478950a32f51ea15dc08e91a3020e2f0d63f7fdafc172049686ce02d10b3cea8699fcaeb61b6f8c014d667068474bee84f5fd2fbd96fc1bd4b21170abe60b0c686ddfdbf20c375702fdc14191ba38431478c31c14350b472adf035652a6227fa1adc71b2dc1c165054dbea3b2bd58ae561fe8a61a284dba4f7490be4ea7f04648558ab3117df9f0e380167649d7bba30c68f4746cd7ddde42026d6cc9341296318bf7260cfb59d96b3e00dca1ba08e4b5bfb00bf9ff93ad2ce1ee9b168f0422b58e838332b5acd452d2454c4a32c095c0c468c02f782107b06360a15f9e8d47092874dd420653408813c40218366de7d48d5ec66b1c8de66f5ff9cac965af52a9bc68a6ab208877862f4fe9eeb1f45f1b5c47a2c6aba8d1b133ee5b09a048064077c93709c19fba7f174a00a680fcbe63f4a6f9f8f32cf87230830d2768c7ac0e517cd3dbfb4e2d83345e9c0a903f89f21b6eee9b5fcecdbad41d39d3943121934869ac9676dd72c5f2534f5ae58978eec6f3f45c31fa4129b5c55eef70488a07836d7067dcf8552e58d4438621c81f3014d82c4b6fedeb06f8fa1b0bea5981dd13bfd0e5ad3a1b27af172b1af805ff2d789984f26bfdcf98e860729cadd46d8035ba609fed729d6784f67297d033d745cd845f063c54f8de3b7bb7cc2a03ddb2999f8193181e118f264f9c0592291452442c52444af90d11f0fbd2175f762b12ecfe7f88d4a50f9902a4132459088afa5a3aadcb1279306b04bacee2e86f8a234366353804f5bbb02b33eec08d4a9b452c0619ec9638b3029585c9583427976f2cff7df6dc351993ff97a2960509d9ddff7dcff2004b4083f509438f6bad407c59bdf53c4e9acfac650e12d5c2b60559fc0dd0ba3907efe3b17198ee69486d1b92214a523ec6a6a2ad888f42fb71db21774be8cbf730e289ec2c432ebeb4f7ff07a43ad0d41547f8598aa385cf9304328ecdea99afedd2801ed81a599ee2e7affee43ecf7075dd1e54c95d1bc613e92d4dd07e350e8a1bdbd1510a135ec6763aacd51c5925f7b786ccba786d37a08a6b6d2d88456ff4f24df5b5f40bea93dd9f15420c8fc97ced1a139590e4f1b6fd7d77069f9780cb9910fbded60ce80338f092ea0600a376ca37ee54ff3ff7870c309a6c5f7a7364379911ba1525089fe23d6585da40e7fcb0485cfc18675e5ea4897cb0f9357d955c423a0cf784a0754304de33a0fd1b4333eb8587e0b35dcb4b7fc20668f679c7af3ff87f50e69fc1eb33acf101e953d9af6f8a1ade26b4f7fe5f71e2c4a823ae5b0df1e3293a059fb17beb4a751898866227e6eda1f7661a5645683cbe96bb413d9cd0d8f800020465066ab41d80b5dd65448b353ff31a494300dcf26e5bfb3af37b66d615d1def12a472841dd830e12aed60656601272af49af1e119a1bc75be771b7c1f8e24a2e1087bdd6e720ff022492a06b5bbe5fe02396eda02d258a7f908b69de6d89b26ae2b34b84670e8038423dc2499bed7147401852b4dd4e45f4e181e7ee20adccba7dec8fe2bf26b77fe494335ad0351ea6a42684105b4d6849c45238824ef0dfd0f3c22da704aa2846f1c9a27a78dd3936ca8471802f9a2d7c525ffc0ed9d9a8a7c8835e1e493eb44557c730e172cf6aa5d470b2c273fe248906745a6014c36378b3f60d7c351c5f84428d80108a28367078f798e8a91899a23177ebef5f441ccfe76dcd3dbad6defa190508b905cfb567d0bd02eac59b6ee76fd18effe09484d1f8f9ed4edfc83b371606704ac185da9b13aaefca1586faa7e294b3647245cb9a52f05b1fb5ae53592917fbed61e9c4fb8456faf2c50241b150077bdcbb456ed2fdec2110a0e1ed955404907288ebef51ff410683c817d744285e6d4d93513e6c8903d9ee1f7f7888a3d4becd4e8f4a907faae459b8323d16bd7c5b5cf3411d858333d6ba67393dc0f49a2467147b78898dc669a55abc05a0243ea7a03e77e709d9e2472d2f5771f8514f0e7ffaf9ab05389bb733109f905da7e25a03c6d19b3ddedea9b10d79a79f3a884db761224304888b83dde1b02727c276e90f66511ad42c2be9e3cf899a4bcf5c3391c5bcd2d79a705a314d816d4cdb142f6f21e405e7f265491f621266c2b9a8b9bfb894ea6729860822ecd65fd521426a3fcbf798aaede9284f0cbdcbafa2901f2b27af3086151a4963116e661c38bbec85c065a4a5493284a476d958120910b4fbde54157c2f86fd5e9693ffd41920ba1e51d584a9e6841e470388635b397cc6e63fd17f8d351f1405fe46dfb627dcd26e5f036ff0394d10a36783b1f971020d23cdbc72bc2a35c1fb7a91873072b0c27dc13b25616a690b2bb9b3130c2fd745f8de218d4b55be212f7e19c67a612ef46545b4b7ba80bca59a2ceeeda881b87e023176ab1ea88d429362908c8075cbaddf572069f38a4839788d2f315ce0d796ce25c78505a2b40b1c87ca3e6e16fbf553f44cb9d29c2af8e9b91eb1907314db4cd1709098e88e4b33e91e496715838381c4d6573c1b3fb13be2a402f7e1acf415c263a93fa927973daf240b38cb1e488cdb844519c38eb6524790091cda5cee69e01ebc29f8e977d0c6ee5a4109408cf3ea841024eac716e109480a373cd429c4ac0c537c06e7efd10d0e85f8e5513303c4a4ae8523c93a830eb76b4dc3080610654754487dcc45838e87268b574e3b50d1b1b7140bbe95a194f98a350b0f142b8f1da7f408c95ce44512c4ca05f93d44338387e038c48e62cba770fd262a1f1364077fa091a99db409662401f3517b36b09f878580752b13d8cf33f1cb558b899e728a69a8787310d12c3f56c9ce82bd5462eeb43ca583ce0c53db3f045473ded0d62c8e1c405db959bce7942d2234d0b67bb232fc9c1fe6556524994556e3556e2154dc2f38d2afae291e4af0a6fac7fd3bee7190c0e7963ac2097146d3a78606ef42369626f7e099f0bb63cb6cf98da5943160420ed13708ca2a3879418accc70f7f1852e49a1e4a8eef1f66d3f18fb45cd805e70328fe7045cb74316f306d55fa6bab692404bc5a7549f1fbf7736cfb15a554ffbc5e11a48242d59343c0d52324c457c4123fbae5386652e52a52b145fda2ff6e506bcf7b5093358b7cd93b73ec8d59a965b50bcf65bbd138c2776361c698999efa3610b1b50fdf5bf8249488564a5ed9ec38511274686498448d671912c201648e817fee46634215997f8a07c2f3cfa0848c667d1f16feb689b9654e4da5d0d7d1656786fd5c52091ca4edcc75cdc00f5bf4fe2d1ce4358d8d3a3622ad1a02db395f0f42fb86997a8ffb06c6ee839673fa513920364594e3efdf6db042366b1519a000c5ffffd00cd84b7e28d603b29d15a19a9434f1a03109f16e34fdd95d3536bf0158d0a711f817c02d93a1e976f226c1ff7d83d254428c0727e8acb5c3e9accc772d821a2a5c4a52898b0905672b68d187961b84d1524e8d04d2baf6a869cbbf48e1317da5b9f0363ebcc7bc169571cc7c47727cd1eaa0c8894ce545a75469369b44ce12a43bc739a0d2c41c32baf9077238b15017eb363fd60f9a54bbcb295dc6ac33985e3a6938e1994f21e3db67fc82bf6e05d241a02635d6ce392bb8c39dbbcbf4b7c22a8d309e2b020399226e9fcdd254d302e63263b7282322e660a93f9a10e389925aaa6f0568e5c71255bd2e2261ca562a5f5e6c08c3d30e5eec370db9833851eb95a4f9486aee70ae6f0925ad4088985d11f70253e04ff7558280667fd13a383e02cc1ab860b8371e8e02b2be2f983104b8a6aab3b0459e87919a23a303564c7e2340f4e2eb7267a6f0ab5a8f239d319347fce30ca0e200708108a461e8b32a1391e05dc7721a3659c1d0dbc4c89ad6bd7d738daaec134fdb55f5951289d710fa793f70d05c6a87735942aa9e54b85c9b66ff01c31da4c7130717362a38f2fd440d3c4ef061a73adacd1b28f66ab23d08a9ead3f6ec1b3bce44bb55ceda6ebbf206dca1d01cd797ab278b8f761649fb07bf606704122bcc196d084d2e1e74c0b08aa82234dca02f2910bad230b1831d9a1182568390db3fa125b007238697d9fdd02ef8c9b45afa5a718f61100ecd8d361d0f4cd5353eb600ee64780840ab8235cfed579401ddc5f24b44c71649a80389705e3511823095cd39031b15338c6fc28d68306b754e2d86d24ea708569cd3d1f48ebce997a33977c5721d5eb5279cbb11081d21687599201f5741dd038165f2c19c4b22d645c8d41064534739873c2481ccdb732607c726b8977f8b8914c1b15d95f0f9d0dd317e8b100a6a1ef12b776b1cb140065628f9546d1f9a904a0772881116cf3eaa00bcf15b67b3d64e9e4cb6c51019d8c0dc9d1892c05d114351c30adf5c7082d88196bb171f6cadf002df63dfd3508c8c55f8030f2d54b831ed614b9e6fc2c490118d56d3e301e3565ad54f5db5a809e8fc6e5376e588ed4882731635225d3cfa82370697ad0de6f3c0697b8754427fa102f2f167c5b423d7dbb096b1406ee27d12e801091131037a222637dd6392a47899b060fb9c6c08d982db087d21f8bf9e7e6bdeb0b36db50a6ecec18af6eba6a702e9a3f164a93f3af62b18c61411093d15ae58ce7721bc807d195546db812899df821d433de3687d9d8180e94318e7217564e912c4eeecdb2d10ea9184dab2032807384a8bc17854a7ac28816e203aa6a29d23f21272de5a635f3194159d66ab380a6e4ef16efbaf536e547fbb02b015f43a0e7ccf92a70d182f4387d414f15abac3100fc9e27df929f771bf25a66fd1dc02e9cb95bf2d9145bc5c31fb3efdde2ec889c5135c680c19004fdac6fdc495387edac617badf9aef35c56c12990068c76ba3a5fd35ed051d87b97c9a64a9243ad75bb59e654206ff4aecca5baa242502d0757f1d109398b073797ae9f0ca087f26404a1285693b11f292595da01f08a04690ed4dcf1ac9152457e7935f3dfff7b9d583cb8ede4a3f5bfa224f1a74aeb23f6ad6a32990e6a943dfd922e0635822f9a8ef46b647d04475ddc11cc4494693b0b171937eb7f08e21a6dc26d1889b9077e1757315f58a4fa3d40968730afbf56353052e1e3f69b22d0d1cc346ddc9a5a5e24829fd3cd53db9a90179eac82e504c5ef36e4d6e6b034a9a2239788b2b5963879db4b8b4a6164c6cd963c2a160105dac673f0f660515e6db950be52ad5dcc1c3b68142efe225faf9a46a13c69e1aa106ff0f9b63e1e6f136cb7ece16ab2fdee5b0bdb5096f8f0cae015996e9d95f05daa416e4194f32aad4839b3da67dd85a4720c58743f6c4101fccc76a5b7a5ea080e143c28576df4fc9ac5dea0f6a807364b0c651a144a3d497507d64eff3e1be6419eb5ceb6d347f8fef5bb377259a0539b6aa032846d81d6c2f5b93fa54742eebe152bf22ea347901f6202786fda2ce88bc06ab1206faebe61c3bb048df9d89c58f987e1769c2ed70cd8fb05bcd868ccdd7f9c9ad0e7bbaf2d8ac1abc7ac3b9fde2fada5a215a9011d437b4eb1f57fb31f9e836ccc2f0fc922ad12680ddd99088206778e1e7716f652ccd832e18f425a35e401a6fb28e4903283eced427933fe8f902d885dbd74856ab23b51948be41c3c985bf229386d7fe7ffec3a60760738572b3403fd4d925ea5fa0816b7d673507a327e1d85120eddfd248c01c2db06db4ef0a362bbeefd6762c9f4e643ffbcebd0993ec6eb6b9d89176230247c3f0a822f6e9b6bd4bb0b7a24a41c26543e50f630e997bc9e58681ed8a3f6e822917c2a45a5736b9f97eea48ee68fb1548ec88de802315724eed0283b009ae297915d5cb47236d6bfb650ba5c8354b14a510fd216757bedb558145abf9cd161036eabb77044697cc865ea424b0e163d1ccc0b6dda63f3cd8704519f15d0b552737eb9ebf46f13ecd5959a6cf50dcf093a08cd33fbfc458cc133ca74f1d88bb35e207a6c30bd5f2b24020043401d2e7accb9d49cfaca783319c4a002baae72a057a0e423176cfea5c1513041b99f8eefb018eb5dc91c7c70e18a9bda841a07aa709f0290455a2055a8897ea293c5dae98f96866a6c049248154c9eaa114bc48328af4102c11ab70110a00e55c81c2dfac2925e3e605dbf3c834bba2792d73080341f88e840fbd375aeb6b3e245916a109f9d05ae3ea3188f0a6c15d8b3da685f94b3969cc79f5a3def4146dda0d63e4a6b1dd8755b400259014851b91502eb66fd61baaff3b9ee801f7bb13e4f94c39304ce15d63b0578bad97e0be3616b107c39c2ab406a99b95f88eaf59924e5df902aef116081ff247d9b54d375a9869839e61f7f6e963f6389fccf9e8b7cc8e0d15af496e3243799ea58128be72a0fb294a6f0eb6c593be29cfb0f590f92b22c72be2c18bba6a27d4e716b7b9351cb1396e7b362c711e6e27048ae4831a774871c3b5487df294a11730ecd6e0ebe44f214e80226f717427537be28d17edcb6f666a0f74bcee4a7d7da87cd09be9186a542c0b666517f440ae0aa006ebf49333bbe3bc3c8752b7cc970f48c471cc0fae35cc45242ebb7fee26d774ddbd627d82c8899b814fc512f12215a1188cc6af04c9ab62a6b7348341f2a82ba5be6988c6122d526334e033a940b453f0221f0b792c3a3295a9cb00426cbeeda3e02ba517dba5c7c0b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
