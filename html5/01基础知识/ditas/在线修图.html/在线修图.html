<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb75568183b73079e992813bac4b2bc7a71fb0a49708783d0a2e88c95832c4192967c9b38e3f96798ede678b8c7ad802f50af09d3c75ec09feef0bb2863448f5d7beb9fab42bfe913ddfb050f277c6951c83bfa211f112b581eb2ee3d33b9946dbc2adcd48d7dc13b5be2c3ca97a183ed267ea033970f4d0734c0ee0783b601bcde38b50764ff16035411b08dc5637bc7ad32a7d35175cc2af54d2cfd57ea0ab21c6be939f15472c052b656e45cff87237e930ab42ee7e54bae549c0dad8c25909ed238909b652fbf1950ffd17afc1039c3f577182fc76fd6050b5e65fcca47522fc3dc79f72d544906dc8fa0940582a5ab09cef20e863c5f5784847c38f327dc1abd8487f2fa04957421d0bdcdee109a9b32fa5d178218a09937e4882b68455c6e67b6e3d6d0d529a7f56ee6c34c8fbf550721d41e4628f90fde5432da286d4b774e4fab0e948558383108fc00e18fc0a20f8bab30f357dec4d2b7cdbef7631007ba65382e30aa8504ed78607e31412613d61589f80591c8f72de8ed7753a97b7652341b6cdad4a878e6bd6f39d3d0706cb83cb81312982e9dd06c0de10dad536223b2888e8da76717c9e90fa448a100757d92c161154283a3130e268fffcdab1d6b1fc03d8562099f8e50cd43b8303cae7956e0b1b77384ab4c170465e738858afe339353bddafad422a2b03b555faac5e20a5e84ceab5c84df7c1e68f1f6a749a0f32f56fae58a5724d77246ae3063bb356ee79a29156a4adca353ab134e65159ffcd97671a6daff59c8990369604e9e23fcee705094192fdb87a50dde69185f0805b4a403d5e20e852513c93451b251d8583233091cc35722b2a8e8df6b84e748f1d5a7522bac835c072b6325c9d4bc67d10a3bf7ace8553454cfbf7905db12b3f344e954dd6c45c40c406564e9853bd49bcf0aa6dd3d2f5bb500267815224c9806f11460fb7bc186419a94c6d1da7e56553ca66a6ea584ebdb547c23abf4d7c65cd62d273c158d26837d15b41d72c0f517c8732b5bd67e1e7a28b9fac9258bb6f74ff73f9dbc0fc7ed819f6b1dbec05ca07f8154ffe32e36e6de6f4022b3b7f67743a846d37b199d45f0901e6ecfefc8d9729d569916bb103c5a83414551e79b3527a0a4241598de2dcee984e117e8273a32b089929e1c6e7752b3b3764a9ecc0170ba53675c9260ec520254058ea2c8686be735e24ddc1943fb3dfcecaf43a25284e15198ab5f7291adda40b35d245aca2ff2af31a1575e781bee20fceee14ef37e209c5dcf3d8e3f73bd793c40dbb0e49d80deb2998c6b2e6b8c447b8e8811608ed65f09b2983e15f69c2ec107252f5a7893337469ed28205f00e2588fd3d62217d82cb13a4468495ff430800af2de742bbc46ba5a3e0e5d7282a17aaa43770b809f1c23700cf16c4bf5f8fd264f98abb3462eb51ff9bb2e028344e4dd8f0729de5ebac24727ba7ce120390901c95bab9d29fb69261cc3482231fd69fb219cf18eb1da00542707d17dbcab196349f35e98d50713fe842e2efb7c7e0aad6c1c81ae8a6b9c33312984cb649e0f20b93726d782d0d588dbe4a98a22b862ccd3e5c247265493ff14a0e7f0e4266dc420af32c1d2c86e34d486bf23fa63252c10fb321a023f16abd48ec15eaa24d3f7a745748c2c6918b5e41e927a37e7064f964f43da4db4ed727dacd88f5a033d2e21f177923fe1e88738813e2ca4bcdc6edab8abd833e4b8970fb822bb16a3513122b4b2b35870bc809300d1cf69c152c81a4ebffa194505508fbf1c3555d8ad1a97333ed8100be8d648fa1dbac205ba68e8613d59d443976ce9b8fcdd08bb30aea900443fb117b4d34bd7abb4cbe266f2a5a250a71f4e087ee56b153f3d4f44c0bc4a133647fba7ba40362781ef4c3a56c4c23a7a93425b2e4ae77188703d671de1f532a8f145afc55fee0874b8d01a06721d0c5df60fe75e7b19d6dbdc65839edadc22dcf86977cd74a5065fa289c5cf18b397f5ea8266252ed71fd42a8611105d5f2a6e907af8f95b9de7a1a346e6776a574e137692d3caae886fc5ac7d4684d0c5c9aee042c6f7410f6cb6c38c4010386aa9dc2395a1234968c1d43b238b7af584430490baaf5000ab8811baa18f7e683bd49a11ec50358afe5c26ce6b040a17c4e5a285f271b1994be69fb4b95b626f463f18fd1c7b0883871388ed76668b9492d579dde47ee4d156656340e41ab97ce96e0ef30030832cc744d8014b9871a09a1fe4a45cb0e42f762e60e218aafbc41631eb91045dfaf752b57240ddf1d2cef046a3b2ac6c7a7f0bbd3827dd610f4626dabe9db5ac66ea6b4299375d6418740693082cea14d16395f6942be3a6545df664cd46e464d5eb919b202f823dc9a49a3c2ceaafe1c125252958dc77fe0f6cd789cfd23c8d5f5ef551f4cc401de0c35c82019ba6329b738e11e6111e04258ca38cc945f047053039b2b40006374bc69180437f8b9c4bf34789beb301f030a19a8c3b05ece425768b72e13d1aa78bff5ac09241e90a3e3b72cc9de50def26955ad992870ab8cef692ea7511606d205c57830209cea42cde84dcf0fb672c9c3d518a57b45af3bb7a385da768e193b1cffb48b6291eb19edca9f032f08513ed6292fe9f29436736ef85b9c58dae5d2e307a3564597ce5a8ba3ffc6fd6d8baee7f6a61dd62d07d637ac0b1f693e92e194c1d6ea3aa81765f45e60d8528424b296fb15f9bc3e4dcdfc9e8b360c3e4599443ad7380f513012fc21b389e51d6c0f4e61eb9eea1a89dcdf3461a7bc3512baf2a04c40d486f5f8310dbd85d9afb9ae430663439fac8afd11ee86448f12d4e56705c1720d9178a25d95a79bbd89c36b2e83fdb7abbc3301594944ad6ef3e85533fabe43d9624e3a255adff5f99cd6b4510dd46d886e707a5a7f9a145afa73e0df533f8268071eb5eb54d99da477c98b58cf809225699436a38462211688e226ba3614ecf00e6a8dfbb421d788e8d4e5ced6adebb86750a43304589383a5fa2f846da879e86524d5c706091e6b3fe3a7ceeb3a4b549185d2affabc8bc433fe4114c20ac21f3972c83778777378cc3883e06820d3f53b7aedd2d1b7cd86c39bf407a3c59914a5e9df939767f4198442f18331f56ac9a00cefd099e23d8aa0dab8bcf4c0b6ad6b1665c83452dc5b315896785b05917e71bebe7f7501efee8d50b2528ffaabe1f32cefe64c90be7d7b43ccefb2e3e3be4c74bcb6d166fc439e8935a1ad2abfd646909da335fa67d168027a0974091e23b5c753efff14b3962b2f07ed3bc71274f9f7f8e2b5b2d62fee959930be238c82b5f3692aba72a15bc70e3584010bc7763c6f187a3268db290d8bbe03915df8a6b4455d9270a95a0078659ff45077233e5f44a12465f131632eca7d2d95e13931aeee3a5ae9702b3de0152cf79aaafc083a4562a5d82926209c0f14d87615890b3ad0e633b37783dfb027c950465627c2e062adc4d8090f4debb33cdc1775d0ed4370c0d64c015883072d4c93b44a1e0f67c7e2652c84855c755ebd2af30bd65e8fecf74052133521994750fc5af4e9152dc6f3f151baa91efd38b560ea426959b00b8e52676ff1b245463fddd22812ed4a56292ba59ee6c864237f3c058c4338de9bc93945b5ab4dffddc49eb496318aa9f4348878b6a3869d7a7aabdee954c92d04a4ea8dc0b09ec2e3322d5a388c3be95d4e35622574654159d6fd8e25a45ba028933248db8b90e20e9ee6796e731b24fbdbb4a676b56401bc2ba70682f4221f16f1e28d6120ddd5bfc25e2430514028d18c467360ffd9ea6aab8f133d8fa072d0946ef135a59de43fd944d0dfe9279a15e003b312bc82ef2d19f8d4b1bead8045dd6aa5f2fc057b4e2544bb496ea1f69683c9674c81495cb12a6157370d9d71cd63ca379dd1c9a6d025120c395426c12298653ae09a38c17bcebbb07c29d8971a62c2a769dc6adc5d78204444e51ff5cad4276b410558b3af8e14abf7db43eb8f4bdf7ad383ed26fb8eb4b4202935afe0eb7fc4400a9c2853ac99d6121a8a2efcce3e65fdf3b1c60dec2d7c710e8d6111da4cc92464e67ffd841341da872fc542e748fbface7de20b7175e1b481a2f49147ab5268aa9a345349dd53257ad3926439fb7b7672b72707bad1c8d7f77683a0eb05dab83fadf5891520c4bb94758dec9784fd7aee665c2333e5f14baeaa902e1ea1c5b87f4e849f92369dc96af77b722519d1b31efd7c70ccc5aec481e8ece0d28d1f0b1f3bf47ab0ef556aea9015ccccc549b7b805ad132a12c284e41355402e55edeb924900ece39f122b0fa3a48f8d5ed0040ec6483f17cb45a9e19bddd961164f0f87105d6e3940412c2dc1066670fc10b3d41c359e92ae285292ef0db9cd967c36b51be2ef822cdfef4e881728a370feb95a4f143a7125372e8cf2894058b1aea974e395e89f9c7bb4ea672241b0b27ac60f51d7dfeecb6563a956dddb2a0d5a79725bfccba9811a38d597d48d76a30d57cbd5e9907fc20003e1399d1ad62f789283335c716d93cdbe50b1dbe5dd5eedf5b51d4bd958aac12f877eda93afc467ab8a03660e8453a3b7062ae79b8b26b0f2eaa377cce185d5644134a81d1d0895e3fd60d4f977c9b6ead2480d706a27a823f2033d066bfa8d89571d899ea19d90067c67aec94b112b7801d82fac83305ffa2d2685314cb8becef3addb4ac2d2484e0c8671e48212da87d9f1af38094e856ea91cb16edff70d06f2db091b5125036daaf21930235979b0f00e3fbfcb6dd5621f48e61aaa649ff54439f78320960c6fb7d7e6ed1969cd43174a28ee350ec4b1661ea2bbda50099932e1de7d9fa640471c72e6d420082f13987bd9c44f3eee7e2562d3a939bbf1a5235c1e77005aecdf0a8cf9ecfe4bd0743e47e41090c24cd9927bd0b31df25eec41762e3b293e87715d6052e426528732bab03af4b25916468488297f5953c8c85d6795e4609472b466238fe8dc70f2a7d74823713706507fa705ebd613d22ab27e935b0305c512521a5d7924fdf73d858ee5f3d099c93d61b96f2134d1684c946f199f74c240586e50f6a6be929a80e7e3424927a2f60ae5c12408e0f548ba9936311678bf3b670a1a48b7912e13446784dc6f1501a559f2032f62c95bb48834aa1b9817ab177d33c8efa3822d8e3e20ffcdb27339f88e936a20250abb1e53563ae5e2596d2ea91439253353ccf3d05536eda217edd563805eca2003f54d63d8622c0c3fe811d0c69f9ff361d88739dc7ac24b21cfe90764f9f569d25b83ee7c28f7931d36786600a4ffeb42849a6d1bac4a5a8b52eacaf4ede81678d7c9d4431a88597adf1af472ff85d97f557424f89e1c745b100d8352853bd2b35d099df811c75372a3a30008f8b7e7696e9514a43ae5a89b0f897b8540f364139a650c783318138da742f6acc437c5933d3d4dc42490c1c479ca8e1e867426210ffc8694e04a5a2433f8e6f770c34c9838075ab70845a27f368392609770d4c2f780d91b4b959cc60151421d6039c3ee6c16ad7ee30979c1438162e6719cb8f6b94dd354d6847f31d6bac071c889e302d4412a725ee4f55f4a4bad232b3f781ace2a07c49521739e8726fc4a672d313e8d26445935a4a395bc6a51fcd391f6e85278a574374f52b87fddc472b4f8fcb6543f1ad437a3f3d75cc843657f3c4e4e00ea9b575284f8e7708b9ba238725092de17b0bd0bce8128bd073456f3367bc872e12c60755c79fb6490b4732b2e818e2202a0c955430eeb599d25bf2b23b96b0330cbccf4ca78e8ce2757e5fa8f5cddbb55932f769a35266bbbf9b4b34046ed3137eba3a530ac658964c4e4d74b3df6bfa04cab14fe0a4b90fa009d64faf71e6826662ab1206c100187922373ef6a43f00f593e0282a69fa36e8272de33648ca52a0e14589114d663fcac98b10448557a1299d75ff1334d631ec20b1e22cfedca910989372252ecf87d36c087cc903a022fbd6f4c050f67256e05f31fe09311069b526d9c3c237a9d4c6aefbd7e239f373aba285a6ab3a10062250acd4f39508f5d5697077f460e3200025b15caaa251d0200f868adc0f6cf7c1f3a00f9522ece49ef18e9d5f46a305c376cf3d04981bcac837e60d3178ca4f6eee48dc39a644d6ee370e7801d47ceafea4e66ebc8815ea5699e528d3dc194d6d156fd17afe700af1f73b6dae92e738eacaa81714fce061609dc5b51359b5304b807a2bbc105a2f071d500d1a132c8e0fab6d22b9f745043d0c78142594a07a8d2af6df641af5857138b0bdefe3db35ba1dd3295f99b4bb7efcac070b43a37bee35a49bacf8d94cfb90474bfeeb142133fd37d79cfbea11c12aab42e0e636ea9ff6be6f9584e1ba11018efd31128b347dfe3a3e7e046547aa64869555eab95a597e09caaa9d66b9ba49b4f54bd156d9b7c539c59a8d2888fcffa8f98f5a83da9066bfada785ae8f173d47798efed45f9f9c7e4eb44558c864faea08800ed8773682cc32a63d032eb218a48fed5e8c99e47cfa5cb1605cb22153ab3e88ff955af4c4e395e9afb51680503c195f5de9a380cb3cbfb5860a27f84158bec3b64cece97488138a5d40de0c223ce691bc255be0ec93a19bf0abe8bdb5eab498b8ba46d120f06f5694344ae44b7771395c02312701158f39841a14b828a4117680f1f6f8bfb9fd1f3670e9d6c8b055163d82aa850f341f1ebb0a070c5d860510d3b1c6562098deb4893c0eeb17e36c7160c61c0b2bb4f918d100ffe3b7a0be7296c1055d72a00eba19d74039016d2da51d1c84a281664dafc8084be457cc15eb26f3c188b59b01e2965cf13ff8a05adca0e2d10fa290a4dfccd438e782faf733bee00c4ca4205963c2972cb57e85a26db63a60e8e4fc70aefadde342b60d30042e1446b270e3a2fa55a91a0096fd303abf9bdf1b75f4aded9e4a9c5f57654f56c647a4a20d97cd62423d81d350941193a056f768ea211809722e9635270bfb4cc829a0fe9ab6221ee6aaceab63356979b07327920f270ee7e44b8ed3e03692e64a0d7c07c53c87fa710127026b4ea2cf131f6b646e5509f0de7ae77895700773b7bb16e300fbf16ae38ba4ed6f82cba64113efa59a5911f8d4a5844ea310907e477a5a9f204f22e9abe7768a0e32667502d2bd7092cebc79ab19b38d2e956e4a5469e5e9016f2b50b1969ceda3ac83acdca491d29d91d1a230413818a8c6ef87999b5f3bc20bcf3229ef1854c5ab47c9a6a45e4b2d8ce99b505d0d448077deab35666910100b0dc00be5aa583f9212d46a8bd0a590ebd7d5eddf7137035d7f0526e892ae4c3739c3b2df138f5945d232a170513f3aacf1950c8a653f322b8fdd085a7c64bd686cd14a5ffad927b035186792547105af06f298b8aece5dd29fd3b204f1205c35d471770f24e0a788d82f4c6485bbaa7b4285b75cb90ca7fe8a9d09c4e1017c5ed48802dccb97a149667e20e67c481e2e89b469ba2663895d948b3b6ad08d42e50252c1099976b830bb0e001b91340fa9a53811e7c3c84e86b7987472114ad16e6558a848bea50e2f6bf8c2d19276c1981b1fd6c17aff19204bc21aa5dfcf919252f2c0024577c3d3a6a7394331ecda0528c4271ce783c58a0769f61f55fe930f0ffed352fbd300629769cbc2c27e53a44a23c5a2dd4274c936eb668791ce1fb93ad727cf90220b8700cb7cd0966713372d2401d96ab8825c15acc5820981ed9248076054dc04b4db8ca1174c60500fae2ef64c5dd101708c76fb667ff282226cd27f37d63274ab61c8f7bf724564daf56fb2d3f9133d0879519f1a87728940bee212db51650bcdf78709cb1a98dfcf99c610b27b543f1ea1e4085c8a100523ad6a3bac8a0e044200c82a7776466041d0ba4890c19db0f6510e60eb305b4fbfbb7d12d63718bfd0315637fd75c222be4c89f745453812b59ac32117b454d42bb216f6001bd1fb0990673e255fce731d515ec0f0070bcb9d2fe94e4dc1ff69ebf1d52cef8d3624883efd465cc83ffdc92fc39b692f65b95254f343d7a13199fd1e2ae15dabf10d0bd8971bfe7cf535fc22fd463bf1bf9afb80758be1aac7d9991d7384af7287fcf04285b53ac4032ae541f5a703bbb017df30585b5ed9a5d8e46ebe2f977621acfd66014f772a38bb2a901088a627b0c93bf3fae420f4103e71f921c2ac4167f144deb483bc58b447c1b3491ca4e1ec8e56079304dd39a8df348867213b8ab3db150bfd476341464712b2b951728133b753a33eb347b21b63e211738af151b7c829a65588adb005f40e84280793847b4352c9e00dedec2d2b9f81068ce6ee303b8db0a83ccf47849e0b261440a384adb0a3ba54a4aed9c61583c4cbe5f614fc1d891fa0b86fd4a515a777efb9ebbc9da3fdc7c6d0883f6c18283eca61c67e1a75710ea215b5bc5a3ff58f157eb3d07e8f9177df16f72b4921a5fa455e77c4f5ed85e58d719846d395fea30095269a8e333e179b45db7e6bc5d90f3912204ccb7622b3ba280fc35d0d68e71597114897f145f81e2a66e5a50f3d1ca4a91ff6ef2b3d86a99110c203460982b206be0360af99ef7e18b50a270195bc6f672e6383ab0a372f5832411335c92b3bad7faa737dd5156446678f2161d51abb82fbaa1b40f1427c44b104f5449530f57296f1a9d87c8c82306699a3c6ef50655801972b45691a15087e80f2a9fa7ba723392a0f9db8b67c515b3bf0800ac4c5532be467cfbf7d84e342d4fbe37336e98977c97761d2d9ea4a31d528074397ae8b8f5bdaf05831adfa921a1999755586207fb01fb21af8aa7dca0d864a323772056943b25262550aff5a27dac1d2035822724556e2abfd2d769a36f0c6761bcc7623f14de8576c4871c0f433c0db18190097a28209df4ba544c8ce974d0ceb76355ed20f8b5342720c5d3b8d489a2ca30694bdea6053088e0a6f1a724593aac580864a65451d99b3e6a20eb6221ce31599c0369b8d407b2a5be89ea1e5dd223674cd27916a672effcad3cced8539bc90047550af1efac63b1bd49b13dc60c057c900eace3ed767c38e1beb1ea50a45debfbe0b94ac6603b227aaa4240220fcaa3ca5ffdb111d26af7c83eaa8ea8cbbb370bfcc344cba059f4a6490854b0b9fad1465bfa618e9ec6b8bd284d3fa5fc6984b2b0b71d4c69844bafc3c6b6cc9a0d4bfb1153d426ca78e3b170bfe7aa7d30cc5ccd61a48602a3bd9b1bb95eb3db784a947ccc69fdba71c3e2790d62f1bca0ad5bdce67c89e683dba8228912096783eaf5ff78031e2d84ead992b9f82c52d79bb111c3c934c6ac198691ab795d4ab9537dbd0278d84e1b67699dcf6e7d62352250fccc3e7af6cb5832e4db6d660530ae52ef4be9072f9a479eb35b94378011c21405e3638f42eca9bc141dc60bb9574e6d54284bea6981982ef50dc1f541db3b3a2eb8c89bae281665450d851d73d3d5073305791fbcfec99b8c0e078e517c99317a3df39f16c6a13d7eef4869858a7c12162c1aefe793292b392c73b990547e54a0eddbff4626e1a958dfad296fd71b6e80c535c0e2a7e0ad467af18e2697d2c9736cce999b88dc41e2cc194682bd7d0c5662b92bfb710cd71f2077086f3c02a6105cbd24817eccaae3bdc75f0b7195b66438cd94afd40e0e5ad7149fac872e492b9054d9b5951297e2f5b8a568c38f697d234e05aeea7036cb6f2a812e8e2cc905d16431ae5fff064d6e7932751830bef4144b6d18aa7a384d75014428872859ea99f80796c17482d5917f24355118d33f0710a9b866c35e53271d73d70e455b9b6c0265a02c8551a8095bfe411f1e52f6b378f95132648c36ee3c63b8ab3cd49855fcb01e9561e60d62e69a789e0d0e3473ecb5a178e6d3190afd36b3c18446b68f11b703baca4d9d1e9666a0957a22a8cc937c51779cd36daca5bcf1c4c37c7d9c7659d653083efcec908acc4ba6f60411892f0a6b137dbf4e98af731f75c48da25c066c50921caf60068b11e61b4d6e470860aa3b77adf64e6d91ac1a63a4291e07b038084e22d1ffe0e1c00938794f2ade76e4bd4abfbd1b8797a9568a1a5e81985f4ed725e1c5f085652644c0e0601a76b816d18648a08d78f231a2538345606b7ecccdc03eeff9dc62b7978fb8f12a30302c7148e14f54b9574085b2551ef5bd4b9ae7138c5c1d3527f9816a8fadd83b6de62892abd3bb9aea1f56056b7b8db9f1da8cb0cf5ab888a65e45fd41ccc064ae713eff5eda99e98a6f7fe68dcf7e3b740a7e5d39426958663c1205e058a4fb7c11a259ae03fc9b8b45af3c26644ca66d78869c74e99aac8f3e69b338f8fd308ed0889b64095bd517a40f5db14611026b06a158690006f3aec7aa7d6d0e469664973a78d7ab7cab7d8a03fa4ebfb1f3f5b359106453d505d64630743baccb9ff7d73eaca356a5470789be657b1a35fa3c4166856cb90352396c46be57d7714c283e22c0ceeab0a52307ab1497e56ac392024bf487f47830c349d27f779c00b6e4c000d46f3273bede7cc037c54be5b5c3efe794d2b4c96fbe400b74cd2a7e6bdda2610cc470e22a8f520d8249c7065a0a6eb437d4d36fee6c3e8da320d84950906e7fb3f428919afd268bcc3b8c4ae7fbb87b1d291f721a386e897fe134e51b53d2eacc32db8f838884d3e6999d7be514b074ea53f88e63ae18ed3cd6907fe186f241f82f6d58df487910a3adbc82dc36dd206fe14d2f5e4b2e670c041ac050a741c5febe6b88801cf0ddafed9fb391d29c36657f1b240689f3982cdace943da5db80fbc7416dc1bb2b1d536a1ea0301436cc04557714f0594132f712a0faf509fb3aea69ef3d33d28baac67e534bf47b0620fb3853a2453c7ccd16e4455b39db7495bdca77db30d58a53ae369198398f2c6156f9f066f34a252f9df36651c2d063222fd61dd611390eee48ead15faf76161d9af10d76b70ae1d30e2e4222124e65ac3144b6bf410492bbe384676d57b9f68de063581f1277eb5233d06838a5b488ac5e2bb121628c2f35e00d92e9c1957d6bfa9c0f03ac73d5a32549b8850ebe399b80f1ec7220f8ecf542326848ff5ad09f2cd05a28080e4d225cc7f918d38ac217ad939396fa833c1d3044f462656234a6db99b52a0628d1b2596eb34a655ea3e7d1d49238b1a5c8ccf4c9c29af26bfefdf67b7b33456518b4014b99819e316334ab0f32619bf2582f3a2c86b7ab72947714e1ed9db0092f6b2eaf1d5b86d39ade0164fce79910b676496c10595dae479e949194a3f60a2c9b7be4c64e4c237d992c191d1caf878cf3a97e63c15cd69b430bc9c3a3d6d5961f47814f89afb78a81fd76ff789271c30763f5c2314a16b2ba519ffc50a445317b2a0080f71d9aa584cb446d937c78c3bbd2ee6c4f03972a4578d42c75d4a358e0d66abb4fd097c38282d885884d0885b66ebbe99f61ee8794b5e06f2655204396a0772f723c35376d109fc77009c109763472537498cb80d999db64156faa656f9d68c51da2cd1d9bbb41c1c15503b6c390f0cfdc57db739e907103911c2597f7fd15f764ba6a039da6ba3978cddb4f49dd7a1b988eb138a5662ef540413b4103224add52906ef55d1c42a699e3d763fb144339aa2b53169d54d9d16f71d2b267d122f2667fbeaa3a9ab12570e89f896ec55e6fd0171832bf4a35d37f256d81d5b0f1e3c963155ff0262a3ecee3d64b6bf3671c836a681a9fa5678bdbe580032d1b9c53592ea74b50a217a0d8cc781858ea00bab3df44eecf0cc66dd34d22298a741b58554f00bae30c9fb83af0710ba51eddac2eb874744964017e3e8a66b04fb69016ea24d483584538adba7b5b84218296095e132cf477b2404d559643dbc2a36ccd06801fe501a54c742a4fb5eac53b6995daef9a2bc4f76b56d8ac819742ba7e67c8cc2f5a7f322500489d1c1ffd8118b2556b34eb15b7ba06b1bf5987f666bc933fb4f6ea18ad52f1672bd296c99fa984480bb03ed84d4a95d3175df0e4e0ec5e451d6dfca20ac368ce6cb94a05ee3b1d7074e19a1f49e28f1727a9c16d14dca38a4bfdc542c23b762bb9331a6bc2540737b4b284680f143d56db5e69c581967d3bcc917c14357435288c84eca95e538f115abe69f1723fcbd02fcfb3c48570da5fbe30e4d88c7e20daa68fdad8748c449acb1d86e90dccaba1401dd9de7d187e0b310a299ff58b94e3c3a6e2c7adfeed8dc17cae935644e2a1489dbf9496646f039ed77aa9002783cf7ca7b4c6c8608b07838f154d576fd5bd92902b5e9f5a76aa1e9e30635833a72c0c6f7b31154a51048087d8695904182c8f9778bfb42c6179b29e6827c19513fa5b9722ad0aecba7c36f7215325ae4668cafb9e2883e91d78c8bbae37ef2c71c2cd6202c4eaa75d946bd6c3e6abe3548f521425db7ab0139c90f9f53f1309c9cf9db4ec84c61564ffcf8b4a06f2bcf0f5cc1bde548fcb1dc51bc81f265ebc1200b3276433f9884e5f89fe811c8407340485ba8ec3d7f0569ce2f0ccc42b24950e33a9d822bbeec159b9372ae3e1f0e95199b3151c84e3e76f6bf8661a291addb31b84c95d711dc5099d25515a5f20548316c380155c4e114260200e36493e33b2a400cee8355fe573e6f3676f48b32cd5add675ab21217ee9d268b8937a0ecc758335170e7e1abf392113b8dded85c3e624b6e11f2aadd78461f1cff7f43464617e0c3fd41abce831970f736f81fed1bfa1e8ab267508a16120f14e87491cc9ff3cc24a89c122cf331edfb7fca1e01f39fc612e5f32289975f44cf97d82a5b7fb5f334d610834b3eed0fa0087d3829cb78dc2527fb169c38aa9c4f9c94dfb0fa984a5f7b396d7085f934deecad49904022ee827265ba72dfe1da7d45097721bfeade4ea799ccf56f377b011dc0281fb09ebcfb57303130293a307f1037a73951c5275fc1ea00030bb06c3152ee6d275eedde9526ee798b3e61bbe01ef25246282fc36bfb8e32853f8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
