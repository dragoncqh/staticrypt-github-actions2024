<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c8f16dbd8856ad90cd1d85d9e2341541b449e508e5682461804d287b3fc480c3825b8812c852e1a8cdb154807565924a5b37549ffae655efea66d8a97e2a9ceb10e9a507de0eb5f8e928a64cff69448cf1ba19a78e85f4c93a2509d16b085305b26488550627a5fcd92c860963a387892ed7d97439d02516f6f429d0899669712cbe47d4e0d35b67f05f2a498c43cae08455fa8e19aeb4585e58ad0a5b7ba5bafd099a5104a107c376515131cb677ffa6fd8de81a5938fac8f26819d57b70a71aac73624c56797764b3dbe48d3f93df76f148e071596d21b16a790b7e2340af57cda3c54e998b9ceff379809f447fd2e75812eb6d17364627d675e6f37fa2483ca4c2ce99f744172fe848ff398011e5ac74ea90a9e9198658077a95f775425b1c97dc7bb2b4b81f64032b6c367216b66eacb809f32af5779233335022eb893edc42ffbb1de2b091efd2beac3c2e1556fb1e0d38b7550eb6e1ddb1fc44d56793f603d9164150c05affa3b49fa6c1932bb35da723aeec5f23cac14105dabdca190bb76bae8edeb646863fe7f83970353366d5743d415826c44062d014a53c45d76dfe0171e3f85f431b71db11926b7671e25822989f487b9b7bdb9d0485c7d812f2abf34efad2dc8fd6155823a640a255b7669eadc1e4d783790f1126dc71700a7521e9126ae4b423c2a41bd7b4fa36527a6a279bfdaad317cf0b02112b90a73ec79e7614fc20af258420d231f6bbd2c8a6d7bc0fb9a592882805b034dbaf3b688fdd01c0eab7662d795b7bd4e23d46065f9c0ecc8fb054861d7e33a30f37b9f8842cb2687601610dd4618bf7659431285552dddcc15632a20ceeb5a24770171f2a78f59de5e2db446693ea14c888b0c2d5a8c1daa115c7b1f462fa327b76b428f3f0b532b97088c3fd0de80b499d615ce019890249ef443df498d00e47e406b8ea14f268e846ddc8822a0b3952eeda5bc04c36e7aba4ccaf88f45e92ab08102b9bcd58e95baf75cd70bfed1bef0c4ebe6d39d74d3264609173d697ae0bba66477cf7907eee5371a96027750e9da7bfbc31a3f63e33ae267d1f55bd3f0f7fb491e446cf5e85f6a0b347ce9838575a8b53a971cf51973775b53b01c4415a052a91668c5e01066438e5505fd1ed23824c648d9e103932e74b7ad8800f1209f0c1f281278f318193db17e5b487c77fc0dd1969921a3e45477111f41854041aedcd67c8e8fe6d480b30cb7318bf6c9023be7341b2f943cc5e2e673fd823e8203d80b669a4d74bb59633bd22ff7edcecaa7cf817e1946af82de6302e205566fd399baf168e23f277b919bd40d6e233a1803029b238f9faeb033e57313a293fb386ab19ca5a0a3a26c1c451740dbc10216b852e8f6b994a18f389de1ed9cc0c86c8f2a7f6ae7f95bfdf811e7699c7fdc9c728b03ccfc3686dce25acd4aac0b9c399005279b8dadcb7f529ee43e52f894c910fddf23a4b20dc22603338a139257150a0728f8e8e5828282306b123fb54720aa682a9445e819ae0d0508c4165fe23dded9e3301915a2200847833b8515c7ee168c550085b0eee0e87ca9c4e729f0290a9be0c3575b5e0a75144bfd9b70d2047c2327dd35f2c29c6c11518047fe450aca119522a64bec7e5cb0ae503e41c5aa8a9c9b20bf6ac65cdaf3b539b6722b5b6b9ee4938c0c3e172aeee8641bc0b9d0bb42f77412c9ecf895851aef9110558e5d987f9f82912a45f4170a65a8e66a222894260046361b1948e2d8e71942142efb86a373486673bb1d24bb0bc8285569bf9e16cfeb3738f7345ca2cac5c4ea7008354d8454bd7e6f33e0b8f21f102f57a1ce7384d6ecad5a110b687cd701392a4629e0358365f34af47b5f123aacd49cd84ba47b63514e209a19b011aa69d5180b1fedc3a6d209ca7a44cb876869d50f8c3a156c80b60b867853a192b37e90c9d23803418dbd03fd6e0a78551577689aad42ccee5016efb74b0466d5cc58c6d869c25bbba33675fc2cc29794b099a6d074006624780a5dab53221fc383fc8e3b1661444eafd9b6e760a24040b203965b08bf7ccb071761e38384e43610b4601c151796e4bf78fd057cd92d8270bef4e199a0f277184d1d547c8e2c7693511fe6225955501bafa5b464faf2ce3fa74e6c289ae1468efa95cf80d73fce35878a7a8d68fd6bf8f39cc7aa68be48f8a9ec05697efa767f5805ceb6b570b656ffaa726a6ad64c05d3e28b1848a814096d5c6aed04ec72128f3db0c02c00bfaac316c9992b8cd16b419616d2e1056089b3865ef7afaa5dc8673f3fd6eb07e22bf725bbc23d9c1f97657fcb553e8b6c78f550ba53dad78524a446d9e52e1a48e169efaabad9448b3b7d47ec7159981cb782010002a50c57edc1f9b2fcf57572b2482ac35544fe6653175a1363a0eda57a5c206385d1fac09d442bd9986d4e16dfba3c4921c61113f2c05ceb30f477c65ed2a905895944e1229a12e5a72f5afe1844fdf363043be1b79d405b65405292b2ae68ed6d2c1c31e264eaa1df6060cfcc6d920c0a8032bd47bf32be20b264bb5868adcc554f796bf6f3c087f9cc6403c6091c05f072fe05741ae09ca0238a915c67c9c80f895e26a60c2675f301bf16998397b11faa3d9818000e706f031edc54ab9fcf42b4997fb9a7e3eac52794a0ca2bb84b5c54686718c58761de8239690453163c1ab62bc2c24b0e36b8980544d1dd4c4efc01715caa5df2dd4121d6ab19ef165328f7c2d9766a6f0c8c101a1e5b8442e4029a54a1fcaf181bc9c764dce626755628519641aef3013554cbc3eb41617f820771f476a8b383d0264b19a7c98eca0f1094d123763422364597a43011f692dc711153c831bb2d4c2e0cc9dfb15892fb510fc8cb0cdc8ef5e40e18a63639686fd0d16f683fe38c7280b874abfc87e96330f2ef9fd75430afa24ea6b10c03c50a165db18776f70af3ec75cc61c2a4b8f3fb6ddecf6c86791da536613c5eb4a33bf8ca02efc645b5cc570cfe06c4d3334340d242757230aa015b6040fffc99da2787871e1be076e9d786b60a795f6c16c96d63d397b5196a41fb249ff5d28156540fd4b599bd216b292210bd75715f7a4469a792f9a9c2c67595095f76e99e7b1ba171eda49d995c640bb52a1fe86441e95d5b250f014208811a7f188eac5f9705bc3715715fe582a22bc45e7469cb35e1f0619fba179b3fb68222e4bddd5f65d20dfaa573d910ce8f10df18e239503774a7f307e292c963b19ca0028bcb812a0fa1a77a1d594eba29265ceca367114c0fb2023a53b42a75b08a8b875535ac87602b2e81e13379ce8a3b14fe1b0fa4896bc4d110e6045d6e3247a34a682282d5f99e0d2695fff52236ec17232d48f02ddd35d10be9418f2e179515b618ad2593836098168e62e14f3ccbe66f709dd903da5293cfafde8e2da96dd2ac30bc0076530f4a50a66e7f05cd6658e007d40be83df2bca349177ce72c06e7da138839316c89bf12d28a24fd4578d66cfcbee839bed50e9b760827919009873b4ca403df20ac1e38c47946191797cf91cfdc133812815d93fc8fb277e36b0057473769224fb064991b1c056bfac75681b55591d6e46f7c61e089cf3fdc53958602f0cc1b219e90ea25c18dc931e1fb0ed17d81bf044d0d5cafcefae445f620b282c52fb06bba58c59969d30b5141eceedb42910e911d86a8f676e1cc8632e7719d5c166de184fc052f00337d7979587169a4e3f7ced0043fa62f6631404db916a182f75979ae9430705b21fd0c591ddcacec4583e1b9388b6fee1c742cc6b4c446cc9b8cc0f14eb38e5763a5dbfa5d10e3cf23c3351fbbd85fab4d1f82a9a02705c7925aecba007e2e2ad933bb69c1445237ec20c12f733af0a92d4cbb9977d4be4b50acc95b8dcd9164a2656000214b27e7e5d2febcd2f7991443898fee731668ff2cff560f5bf6df4953167703367aefcf6dcdb3522c4c5a47a7d24f0bc01106eab71239844f5d2afee1aad8608689e26b7bca43a495eee34a660c09858bd8ea29201ce0144d1c454f90a265847135210ba4435238489da40413e6a8ec7454731e43a92bdcb450f2929472804a83d238dbba7c7728917147508175c9fda170849496e82ddc3825d0f67e6131980ba6d200ed3e99ae46cf790be9b7c6923705a772210d3222b3740e3f41757c25ff088a5a19e760b4f90523da2b3a9123f3cc3d6b8faa5b37c662df92e7eda651252671aeeb5bebee66eecb691438ba489134721cb29258df60becdc91d9dac31f7ad2026732566039d99fdcb0a182232cd48d0c47e9c642aa50bf32f143cbdb43c7a4916ffa400a106dcbf81cf6aaa1b048694acf615e05f1727175ca1e85aa7a8dce9ffeee02d2473f7a17031b521234239893bebc28f46fee73f4c25824a8190ef8e22a5646f7f066bcfba93ce26aac8028a6ad8a989803c5589477818504b5793864de0971d11969b36e8345763c7015ce9184510e15beca87ebc9da3ae868ae4be6d0da269e52dc88bfbf34d88498cb7225c203d0e978a9bd1b50845437a7d2e56087a63a4f764904c1d2671a9472532c2cb3d8c11a535d99e5b1c95258c27be446ce9faa3c57d503c426a7b9ed548e21ba08d75fa6e0072bbcdf12398a8b91fe6a877f8106ad3cf534bfaa99511d3ad5b9c1c4ec7b6d8535b343a8d691aad54dae88e1d725e772b6e68878dc8fbc5eb67494c8170cbe2368ee713fe162998e7d2e51bec56875002e97c76abc5008748cd1f73d8c6ca9f902b1696b43872083859f92794202e569135da2feb015504a9f5d50c7c8218bcc6e578082fcfc6f891e2527cb05f8fa69b6a8e46915411d6f70663d3aa5974b149f0576bc1b360be58ffda35ea41965574026a72d4e28ca1520291915c69c41ab46b0962f962f8576b219cb06f03f3e834cd22270bcd66628c674a118c1a37a5322c64b6d935b8d37815e046f6d02059552e5d48c26b71f8900a61cfe855c6ff0c1a9fd7c6c1acc92168d964bd79150fe46a633dd1216680302b296e74f74899109dfa8a68e77dca39aa16d858a71a88459b720cf9cdb8560a75d3aaff330eb525fc3eaaea67c1bc4526cea3b54ab0302f1bbdad9c2f7b0e0c0938c0cc130761c94f25575bac16640a09ea131a359a9d0901aa4b6865d5f8a9aebccc0a5739d68fb48ad05307cea68d12e235c24615ac32361cfef4799b2500ac94ea1c6a1791f6af378227c653545feb1bb98e8fc1b5286752e614bb1b35082470c39ac289bc0d981805e4d5c2321568e0f5957b17904fc455445c401a2042b1b2e05ca652880e9835eb99b0e6bccd8016260d74982c46ff617436c89bbec15751c0c1be9ac6b38a3d078ecd93c320eb5ece6ebcf8c02524b773d379c02636c6083e45707dc48f8ef92d8277d6695d887f3c5901d363a1319f9fb4760acd2100f61b64bf1494403da694981a31b8160e4e775f6192334a8e525e05094934a82db14e19337e94eda7c8de567e4c0bb6b0990f000d8d07045f7003bbfc9b2d7443247690f4c05df694352326c9942055540e078228f82e444680e702551609fd74af0eacf0ef4f06167ed9fa5d9ed07856dd82f097b7a0fdf2be26266d1b7c037c9e54cad42cc07585f0ee6a707aa4aab6122297dfa6f1033931fdbcd799b54a20db127845a745b87e220f8e2e6597b6e919b51bbdfa726789a70a845c89220bfbd0d4f1645cf904038fceaf0c9232d19122a3ee4b2867cf879f7a4338b0f4bc9519b7fef0a1d1421cb3337c846b59ebc320f450a55ee064a66ae24bad9150cc838b9fe29e93a065017182eb0c7f66e112f941c0119620ee8c826e9c1189f12346afbcfaaa410158f6f22cea751bd8976e2d55fb2aef08d894f0010370227cf336c6e843f5d8e26586af5af25c4bb9b2912ff4437d6258cf29e29a4c0c992f4728c6b8cee63d30e666e9f4a2676ab89a58bbcb2195b7e6fa942bf0d3c5141f6d121270158d63873034fbf855dbb03c940e343b4c7159739b311db3b00ec5c82e41c456d00a9653a3b0c574e17f0d7604fd035931565c6499c8d8888e85121f5b570f1ef125a7ba713bccf01ddf6508024c47818b18632dc9d51cd5746c4f774905684d1a6926b4d86e29a70ba3542dc025f87dccc6c726bdfb249b713020516387881ef684aa94c51607fbda9d92e8dad424484ec793b6fa7772e8b5af5aaefee35ea1602fb0a26d04b030b76f7b4fc82c9f4e6ce054e66e58758a461058fe2349933366fcd545e723ce38e32a7fd5158ee457f34f93356251f70ce9e2c57a878ff02cc5dc1dccc1d85e8a2c41e589e1fe3704feadd16e2cedaa7cf2c3d6a5e3844f8b2b5608d933fb8881c6cb1d0599646dc1e141db801f96f628b5d5edb76a781d48027b3b65992939aaa259a7cbff8e61e1b7638056296284ab9675c3a60a06bebeb92a4d8a207c13e73ce3370b1beec1e23531fa6f02596b9e70d21a8ee88d455802bd223729da9cf52755e64506d82728ccbf101f8354660d284f9298917bbc4f5cba7f29af8443256c39825e60c2e71056c96e6dd688cd8299365acc9f1e38fef5ef4525863639c09d9febde879f2733fe2c212fa3c22fa9e3f727789cc8adbd19d4d84fa12c7ada09bd84bb8f5bc22b8ce008484977cbac8c00142fd1566dcc82a8e5503c8b803675e23e0b99d168e4a40b3eeed4edd91a5b48176fc5bb2b4045228fe924565da211ca8f65d1f31a0250205d9f1ada9738423a6c1410bc1a9190964e8c92b3f5ca903c531ca8e4b4228bac04e97a725d6358321d722c33f10b7430bc62be56359db9ceccb5125275fda48eac9fea90608c4475f2cbb050de678c346143065d79dbb2007c56998729c0ed39cbe17d43934b076d8e845886597a95090097452ad9f328940f485ae4c42a035498793b75d3e8a86de71e931910d781cae2162d83c26138a0a5a5555d84c85480ba046c36175ea38674adb9abb64f81b5213ae401bd8913eed3acf39197189f8e091ec7b397bac25270bc9000daf8df6a9cb270bb554b0b77617a55c509893e1a22012d91ea7af46bb2a313ed79f52c9bc7c7f12b45832ab14e516900ed982260611236f48951997cc110c9d6a48a4c36dd390ed4e7b0e53adf9d18632bacec1b58bf10130fe27ef8ba47eb7f0785fa2170b99abc3f2cbaf2a6af7f04e85a951947ca548aa172097c1d4d63eb5e3788a68e272b419574e1d995bf7d2a793a877931a13a792b47fe864ce99937900dc09f20cb60145a628e0cf24647e558cf4a62c6973d911d6964111b06c9169296fa9a4c029f5299effc0e902685fd2630d675802f20b284a0d5f2daeda00b2f09cd28c2d2b005b6d3526d9743af5285d3a1449a4d2aa24772e28c6fa2bde820f30a60270621b8034133f6c0fc3c0af8d3ec1ec8fc8eb5e28b2c0da4d5c8f3b5e456c009d513d6fc5bbe7ce3a73026e4bd94d6b4310fef8f214b60a8997f03dd9236474dba0cbd5ae3d3d3d595f472c1078a20c31c09b31c19d2c2b28f4d7ade577376cd7109dd70fb2d84a190ea6de256080208b98b86dd9026b08834285b496f3b7eaaeb6a0dc869db0ccfa20162999479b0e543146bdea7a66459ffc390a31a3d7343aa5e7a3f783a1b5cd7bf5366882fbb72f57a4cb02e35e272e0121e5a99c888aa9e3f01ce1393dc6a7ebe6ac833f2767f6d28f7df5f34343c8d0b1e08653a615d809790aa35fc432d1ea51bf879d796c2c0d22f5a3407c49a78d9928d3ba2f1fcd3f4aa5779d5acfc141ff82b424d02bbd911b317bfd294d19869a4a871aadc499e21bee6f650f0d1874741820c1fad03c3ff6b332ba812cf08c6fe5ec43df9d534f9502cadac45077ab41943a5fa22064feeeee2c0bb103fc032ba255388c27ea9700093191e278be117be3a0318eab59bf160c8c83da2149f55e8ca59adf2077f5e904dcf67cad1eee9da18ccf1b4fee1143ae4320be045d0e2fd4e3a6300d1623c8f1b0b88c1b1905bceb22f507a93b0e88940f4033120685acb347d018fd8f3b225bef30cc196ae8e9db69805efa056df1f212fc2b41eb5126e7ae7ef0320314d36313dbacf0032e7423ec001c715a0022e19356d68cd79bb3fc5a12de90bf33fe63c864bfd9336ae9d01673d4fc9e52a70bd3864a8163762fa1d4201581b868ae00ee0e92443925b70593871e5bd37670c0585172c4ad19798bc261005b180f0a7a206e7644184e6d353aae6bd275f42b34b984d50aaa0f3b1a29732faa63f2249af3ef8c3c32a1311729621135a40bd4825eb978ce83e9412c8c79f97353ea5f7f5134b7ab720be902a79276fc649b50dbb765d85c598ca9bc1d2010c460c93249d787b9726e5ea5d990fc6f44d8b8fc8ee0961aaa15ecfc57b3ded597a7a9bace73a6f4be276ef71045d4d2046728873370dda67fe45ff373f97d1de010fcdab725bbdb815309e1a31d520b77f344fdbf83a475f914d65eb414bf15f7da440bbc4dbf6104576f25f85c6b408b4c4c1eb6e50acd836b071769730fb85dd888bb82171ad5443ae5ae69664c4b48f6b9344618c78250701865fa50d070c9b06d26a71b5f5f718c44eca96a34f9bbe582e5a342807b38c4548741442d9ffc14e52ebd61bdf31fb030057be7f974f5303366a579654dd6b7a27b0520aa7b634cf5e1308d011977c7757d2100ea7e34dc9e5ca1224494480fa995aa6c1a06fdecb00868ec10c6b80c0f4a16b25aeeeb7bb2a5969c4e373dc6a5aa09cf6834f5e8f607e1cca598901d004ecdb46e0450713970e4639b20f2525224bd9aed2eb3de062d0dae5e92e2df8fd5828c0798b61eab34362d3e03fd234076bf81aeb8da1395f547cee79d0825b580ac20999c8b154cf59de7da275f35007ab96f0c5f41ac45276f079412fa2f28ad72f545e6bdfe81b5538d711f437f7fb3aee4d228ae0cd3be5f1604358678162ae044f31b180e7a74d99629ca008d16d83b79f0f8a4964dffe482f6fd5d945e3bd969837f8de2489e4b3025a7ea0575ee7007794737f6c2239821474c9bc0a236d93f4510314fa87f90fc644de366e50198c48edd16a59c6f04ce29eb8753ec0e2b2e434704a057efcb262f1ceb0faaa47d5fe20c4860c0b485300c486362fb179dc33e264553e34d1d665fdabb479fedc4169ef820e8658aa2abd1ea3b5a097cd24d4c22f33be262b10b425726f7154cf0c4119c74e7f35ffccfe8be7ff8e20d4f42eeb47a437394546c4500f90a0a466e64af237b9887001ef55017351aecbbb638bec00184102d5a78af312f17575e8867b3ee56433babcd8e693e8f93bf469bb8feee8976d07e1bea158076ba7d6b03f2f9bfa3128ab27e4ee3a81d6c65359a92cf684539d86415171afd010c2f46d7c6ab0acabe9b111c9c5e3827959cb5c622d0056951873414fff0db1d45503df5cc256c54eaa00cbd672292818c8a0c89c2708800658cf78eedc3e97d955756360020e2a940905bcc6a746bf7f100e264b1170b3bf1b9009fccd40489c0f8644a704ec891dc1340eaa32f06dc836acb08132514856c4cef1bffbb2efd858414bd06df78902dc969715138c275acad8d5d8a6bb4d12544b6ac71ec7a44b4887f1ccc74e2260aaccc9d9efd4def9d8753dbdc6a957f326be0e9abae3ee91c48050f05a58aa2b2ad3901e0251a3867033fc84a561ce5376ee8aeaae7a631c4a45ca61d2c49d190db53d9875dccb1495a54145a1978a5739164053d10a360a8ebc033a681ea873670d39a74c304f7c85ed88f6cc9e699b31cc13a288534fade768b50bc2c0be885fab019180595d906cc98d46d6d8815ae7f552d9ee18dcaaf59e22ce0a10435fe2cce8b6a8663bd3e69d63b84ebcf50697760dceebefcce344d9bdb61eeed7ee1c6a1ef07851e1dc7f0b396b0eb68aecbeb9eb9ba166ee1f0cf4d757c1eed2694393bbc4bafad0f928f37d3db9b4e9ba576a4016be2fabfa7c4fc74a2adc161f89df333e1d847a18478dd16dd976bdc57275b56eea48ba0d5402dc02e50da2d2a519faff9c3684c56a0f6559ad08f624065c51bd7a812c04b939917fbfda26ea348ad897280b1543c10cc4e13eec362a0b0ac9f64085f5efbcf35f9eb8e1a17f3a80145d76962121e64a49f057c441dd556b2fc8abf00d7898d5ff7f88deaa59329e98307e731f789f231961464d2b77e1f10021bb8454bd8f140a26704e81b7d01c8d2834efd78f2fc1d3d442223959fd7cb7c7a97ed2980e33c0b9da9def0cece1ea30bf322d9225d1da8d50c3f67e384540dd35fe832bfe83f86100bb927d61a476b5e80d46fe258b24c45cc59328190d0a0e78d557438c5be1cbea2a4d6687729ac29f7de9545000f6f6e20d4380b89db76e0027bdefa13c7ced1a9f5ef66762ff10264f99eaf1166b0fd469d908e3ce601bd316a6673ca385262f3308c80e877c5bb395919eefa610313ad5aa81253f2fbaf8cc134090aaa20ae23a8df7148aadfbf07457148da91d76eea0f474cfdc42b5a79342292a038c082a5cdd05fa889ca97ff0bf91879395ab9c0bb711ecfca8fb8941ecb2f513dd73bb02bbdc70cb4d6e7e7632ba250883eb39124a7c5971f2f2c57897b1f32fa9df7f042434bb5076e1cbb68ed6f090254c694f7ba2522c3666c6e00ba163a29112fc0b8e67f8c5cb05151dd8ea79915623225b98ae0d1b80964b3adc5cab9a60a341addda45c93735e8ffc956755b15453e3bac18488252081e2c69de9e5732458c4f4c3d58dfd67d955bcafa92f16a36b9018e5afc2d92de59db397b37cc52d3cfca4375eac379c679c579eceb34dc5af2e767f3520e2ae13dc9ce5d587963f5753b921a8051a95d8044259780ebbb572e8f2b0c25388e83a78972b9446ed70f14c043abe204f42811afdb78e2e4204fda7cbe55bf090811131d7b2df3cd8dc3d97ddd22ad0c3e941e4ef2600f84b7454cf8b8ef3d635ea972fc7216ebba736ab4a0f88ad6fe177d252c0cfdd341879404b81c3b726319b0b00fd417566def66c15139d9aaf3b67dff35093270250fecdc3fbbe98500ceb71f954a59dfb97cc06ae921a95d21ac09237a17335f2e61d08a5d9311fa265d663573fb94f9a0ae320036ad192eb699c47c85ada5db6c544887473527158dd7a8d04df0e961f48ba4f4d99a3365b0cddba77e1cd5965880e237c8201c0e4c96f5e9b7901f5de090acd563f91e094143c7e328bd23f47eb0099ca6841ab664c4c51da90a12c9dc5ca64c787868bd83e030e9b91386de6f57d23abab58076787b9e95ff4c0d12ee8366f879e41dcb487f157f21eee85b5e3ac2cb9fbd34e259b3335e3c2e0a739e18d5223fbd6c0d2cda43134ab12e672bcaf232a72c0558bf57c93c0607fca89c45e280457c16ed5d50a6e3128461e9a3318f2d13ac53257270778751cc43c8c739902019b411b1b5cf534bb4ecaf57c5b2095901196ea8214595f2a56c3b667338121ccd6d1515c007a0ee9b6eff5829e21a2ec420e8e12e002fe4615b5701ce9fd6f7b383f286060886c561e3fa0f57b8f33881fc72e5e87da453e47b0c889cc18332bb56c27582e90b62926f86ef2a067a4995e38dea0623bf945cc36d82fb04600511528fb590ab0275663fd6af7e7da6bc98d1698c5ff1a1e9c9c34478dfcc68b9dac6fb9378a13e3f755dca089b1400ca2290f17b0db0f40fd7b4b5ada9743021a072cb2d704a2c4490d3a6a66384c123d7fadef2167990707a669f9e41e27a7b8dbda5ecc242ae4b0858298c46a321d5feef57665fd224674f209db8597c5b854e9327409e4df740de3c2a612f7660e3593c06bda5093182b435590a6bf591ab83a1886344480940a99acad41da77c364e0e1355bff6c99f5aa4f7aa8d059e4cdd264eb3905c43ef00b5ac0bc1551e952d0358ce2bc0363c30b0121260d1db271c2c2be45ccaca1d116c50cba984f895a624d22d5c776d82c8bd3429691c005196a644611911ba0611c587d9d24a36fbe0be7e50c70a7d76ea8d624cae43470388f0e885f33cdcdd4435a899ec2d69c427b7544b204ee7b5ff36938baba1fd0056d00e4e68014e9eb47c64d828563ad4970797d5d6546e4d7f10f0ebb882837f6c40db12d007195e880f06d950e2bb664a2818b06084a939c8fe4c300f6e4b6fa2a16ecf18708f0478dd710960ff38405e5ed58356eeb54bdc19aca91cfa1f49988008229556dd365b310965c8526371eaf76714656fc4d3efa1bf518c80ea855b8627b3dad758b07e71471d9399ac4e4860dc12bfe340a1176c609efb8d5a94d463dff5423e932c1acc914518d0344e38b7477d34cfd62a1c89ee466b6a6f1c9c09884a75d49cbbfd2bd9e05f6d28853f3be31e9782a7593e71de41dd05caa0d4e5eb751f2cee3953a52d91295a881b9eaaea870b676e95e5fe528c841ef0d2081c5d533c2a234ed4b5fa5b07e8d93aa2b4035bf21fd211360635bf85eaeef0881625ce6427bcb1772657b8199953d2cb5fe61065a1c61aeb6762851042cc74190cf2410028882ea94a2c33184eddb886028d4d1346cf815cfd1176cf74afd0f7b2aa44a4e6d095eb034288cb2da542b34b3a48454b5ac237c077ff5d608f1d235993400745dfc4d32f9bbb75de666b5c2b343b0a10c3fb7b3e8c350d59b29065b4d110efd9ae9acafaebb5aa8d82f220974c9b94de39006b0c275cfda9da17e872ac8c87d80dcdd82f911d4bb01af8d5c63f70bda354ffd1843d3f933acb6ba01140bb8d11d546b3b66d5c9187a7434ec911ae05d3e5053bf0da56ade3912cf23192c01a90bda0468e3b581836a7afb65a894ac4b8a67977e814c0b1a6fad02deb64f151546e3cdcda197e40087f1c45fdb1cc9b7f052c4027ba70ad976cc1effffc101dbd83067afb0f67beeec617c69294bba3cdd4dfd975090e03be9801dde2e7c6bbfcc4d161fe9bc498843d84feee27561aecff28cfbe07f7caaf47b2846b13ee827ac66f175124693fe513b7be5ec93d86eb505b1e08f3284e007cf0497fc4191d1fc0c202f18f591583c6ea8de0d9e7f6145cd5c15f6f6d780c144620bfbb25bb31aadebe93adef751dd3e86ca9ebaba5b0bfe2dff00020597f63e6c38345f05ac24bc5f0ba7b40e1f15cd10d6bdbf4de2bb4ba97898d3ab988990a6dd6cbef69f709e1cff984172b985fa90e8ba64d0c1a439ca01c599cc85d2d8195d76e62d4416d68864e523826a2d7ae7434b124f4fe41a868f93bc94216b41043540cfeee7628fc966d986797d8e9e6315264e363cf25525cf9051b9726b78dc7731a615dab89a3732aa7014ccd232be0d8dc6489c2abac6f587034d1118f1c3f861262657ce3f6d8c894f90168b219c00895397407ae89d4e3d7287a838187b77c6cb59bd71dc79b3533db0cb04192d652c8d880e006ba4b12079a7bc5fc36be36d2a832fcc6a4826bedf57b9402471c052a987904effd38fb8216d040a90cab67469391b2b1a5c9b9f0a1bdd558fff79cfe92faf529b5df24be0640f7112c47eb52a97f6ef4e081693bcaae1ade5be06e0c4e800efee999a380dc47bc5aa8778b1e3bdaeb3fd3877834f590433c6a1a0866d4d4abdd833bcaeaf3475255f211e3d8b019b7f036d69e1ae8582ff9da28957013f6b84fb6492d5d705feaa7c3413c4e00edb17d0b1e280ffca08bfa35308499609a2561d7ccafa1fbc769f95e54bb534eb7ed34ee41a4fd3944cfd21cde1a314fae5d07ab920569f6dba43563c65964c2ca3c2c58837ea75f1f359b6a7b8c964e460909b54546e20409c75cf262b7a76ac2d4f4445c8a63fe60610320173ea9d3f278e600029dc7dd8e6b5dd4437511ad4a096e272a865d5417f28581eaa6ccb95da0d3528afdbbd8c363b57fd14fe4e46319a5c10593fad2b8060ace10e3fbcaa43af8c33f79013b627a4da74264b3038d523ed601572513f125251565230e982cfbbe451bb2bcc0e2dfe25b3e7af3cb882b67e6dff8f4d9dcf5af0aeb4176b2ca10e2adb1722db5dcd0af0840a26dd24b29b4805921305e29bfb605fc54413177572a87eb95decb34daa755a22a586bc6941a84c4ee88b11b48157655e92611063192ea1363b668a09f5e13a94b3e76aca08d61aba855a035cc3b8f4980dd9ec850f4e8fd109145db20e06e82cc46ebb45381993902703a017f88ce8b7effcd6c89b1688d981b67107f3e2630b44d153560a56dd8f12cf635f4113673e08fa34519fbbffa081c755bd9bcb5c2175ab92d943c763a1fcc4e530884c6d91e85a629c710b5efaf8ce48e2988f16983bd7152a5d36fc8e2b175aab09e94e151ea5f321296864bace2865caee78a5c9598cb75d6a6d42a0910c4fc82a61086b9da9e908e7bf6a4243e0a80f39ce5df60f4fd817e9c6646b46a6b50f3214356930e706be8363d896507d5683d954f9c3ad86453634b4248294b93a70409581e6306ca3eaa8d205d8d4bf1db435f64ce355a140b39679b87cabaad250736269f99581b457a600acfb07e1a38289b1d161840d6c6a295f180a57b2ba22b17af0f8726d86301ab7d3735e285b7ec0229961a061dd5e4488525bd171101e2aaddc5262d5471d023dc081873cd872e9d78eb4b01073357a7da53c325fb9c02b602006755405f602bd7d74409320be2c3436af0a4fa5266ddb379710a14bd5bdc07d0817a895e3e9a2881149c1afd8d3578bd0f6bbbfc57e6c7194b95c0ec00269dda8e6899f65e741301de6703602a93631df72652e5049381a23dd24eb5012b3fdee7220517c412decc125481fb24a9765f3ef17be2b2a421ecf05d9f74167e0f514e254e4f3129c5b04354d1bd5f02f5146c00b1708cd1c90b9f60fff3d858dd9abe4957f8af7d926592054f89b54de0bb644d061df2af6ef058dfd33d906c20d9e15fbfbe83d24c01cd027097c6bfda3a6fe1dc0ab65d25e49eeeb06534789736d35c6a2a88cbe9174a70023324cd9d6ffcd7957638d66cb4fbb912b97c30a626ece5970e3e1b12209e0de91b9ee2d1c89c4cea6f2e974ebbe5b9aa4ff817499a9ccb2bffd7d7271eb69f7340a0903a2e0968bdb8938d2be9e1c1298ba3b0b87dfb64e9cc102c0961650280dbe63508eeca6b9e571c2fbe6ba9d796ffa9bef06c9cd3c125d8e2990692100a3af3aebc1ed174bcc235ab11deb7161968ac83a6d970f7f426721bedb001c452e4799c28ea42ad4a6907174ee4c98643db604f9b213430e556b36fd04a26b5bdd71ffe9fff9d888804715767893fcc356e53a007c073ca71ffef60b3b2ccae63f0064dc9de2d900956c8374fcf5b22104c4645b50ef8512abe51e1ab2f18d09d7a4d437bac9e19f106945702877818e41794a7742e6582bff3df32a800225e7f25d02c78b22134c8ff561b1a2a4f232ab23d5eace06973a1674a72e7b7a8b3efeb29c382b7ac5ada9cb3dd6fcd2b9fb1111e7462edd55103c12daa6b3ff20eed813a4987e748b2445af66be971292a5f8da49bccdb7c2466047c58bf211960e2b0acd08635b83e1c3ac6d14201e0eed093b081888253166d68b253f1f9583d2b3c06b04fb42db81d73e390039512134593d27f315cdf37af9553b69a69f63edd315cabdd0b1d3e68aade0206fc343dde624a78bb561fdbb33552903d3dfab354eff1ff23fcf1a57aa775a325ec720a5df39f8d554df1984d15ddb0b5daa0d7e3f85abc3bdf14cb038fcd407d7f3cdb2d2fbbafcea928bbdb319805b1fc6c9ba10c9490df37aa234bc9de3c42681a1e874714a43dd3340dd72cb624ad1856d09b59b3e0b24c0e1b5fa39fadd79dbfd6e0ceb651b8ecba68df2155df38620ca45b0b2c958f5e2b80490fec1189f6a2ffeee5e3d8b53257ca5bb102ca1254b099082174be04f106e62b2fca83304c8349cb62790ca0ce606726b5546cdad0eb439e351b7c530b1c11fabae22d9fe2a166d0b8787b6d680f7654f559369393192ab22b4c4f5a1339ce688a4e6f8da07f360dfada102d9c2807ee313a32a66816dbff421d75c126092972c2bea549844819f840a7b26c333af1d80b914372b7a4319c994ca9b9a3e83759b73c1f2d74c77dfde87de18b8861bbc17314e0f40b5229a18dc33d6cf3de764a9e5076408db11511e8e7c2a9a35e5555b2be2816d00656d14175ca8ca603308ce72482f63afad1e6e859e694875d5bc83f6bcf83f116330ecbbde3fb6975d015b50b3e560cb429ea73b21f2937941687126f213fd4beea5689efe901bdcebcad79d6efc275fee7d8c419230688237aef06c5880c7557cf24c9ec978a53c1dd69ebaacc79b4bc60432613c610effe17b00e77d1548a333f59b0e4fcb09888c386c581b6cd9731f0779838ac9b1ec928d518e3f21028268ec42ab072ac68898174d3a722ddc93b13152f7eaea5dca85bc682bc2877a009aba990d8dc9bf0c741d160a5d5fa3491dcef5fcc8bccbf7c13400f83477a575f3c477db2216f24f76201bedc7b887ebad1ea838feb6712c936346a578b1e4e0ce9cf24024d013254691be66a6b8bc14c4260c46617423635a454bdbb4850e4aa383922e8bf358ecc5d482768ff4c8ac5914982de855a14d2c95e0c112383d8e0e7aecce52042a48b45fa0eacd6145364ec01f5b14ad65d7efef0d509b820586443c67b717c8d90edf31c320aea3888a1d9cf111f2677c21b6f7fc8cb00930423e1d0a23b50ca72f05f1e5560747c240481ce3bb807febaa628119d693642c2ce72bbc9c7e0bca8245ea2611adff6354fc94dda19becfdd58477976c74d0bdacfe7af080635f75dfdcf3307cd1f19635a53aa29304b3b1908f0dc47a42c1e3a6ca690785e63e18fa6e413ad4e027aaca703abc77fbb5cdcac6e9d6ea7c44c93e7371d1c99757d80fcb24f7357871ffcbfa9228de1feb71c55dcc851110fb7857654f24fe3c88bebbba4201352d72173bef7342aa97b5599aaf25d938605b20ae80ec7bb60b72dac228a355fcf86a92db920692ce7439f8dca4bec3a496df3350f8b5e1f39b686b57a3e7ff001558bc3af68b3e47386f8bffc45f9699d70a9f3c508a45d68a653239ddb891f418499e068a357017ec7902790c75c47133116b3221b1b8d9b5c40a70ebb45f0ab90430188dcfda67a1f53ca9cb55431e6b235edcf55a067bb39ef50588456bbcbdbcc8b3f5113367cd9d3247a0b643dc07243b9681246f89a30de5a92dbf88b92f9e674d7eae23312e076ef48249bafe5f60de2ccad15917b13b35800eec8633af1542308e3d49432082caba26075f1129e5900542742ad0745b3d37bed19db1568df1ebc4523648cabd065db9bec399d20113f1d3601c1999afb96655981e57d724092f961d53b18b759c3036c0aa4972696ef49925a3a21e78367001ac1cd19a0c6275f0b2c98168fe8f84e02087a01e9393a545a02776e7eccda43ac4e83ab91367dfd6fd64c0963114a7a2dfdddf6f22f5c8ab47f2218e2f3c34236a843bdb934f2cdc76ccc89518799d66e51a1c47e5764bd80262c7b7d5d11664e4eb3dee33c5002f10a9e2089f05d3e3922f5e2aa132a2d2cff30aac44ffc2220499e8af7a2b135d70435c4d9457d995ace199d5ccc56f78b963ba43646aec65a856e925327b285a27981d831396c97b7ae51086cc79c44ac730350701585990fc187e55f4973258e7885555044be3a52c229a9757ced0684775bc446ba67fa3b9ada23b4e160c88fe0d05db2d28830814d57200fdc188abb10f402bec6a207bd358e65d611491e094e73fa639949e8e23d25a95f87291e71027f6d47a0f28a1a6f6cda27ba565a940b6c6e44be52569f6f59e030deae0580bd0b1ee46aabb08bd4c283e533f205daa4ba0886095dee9213c5ddd644a1d56e10d38296f90ef13087f2f0e56fdb567ff5b20d668344e2b6fa2a65b7434b16820e7c7dc69c55bcac35b1d4a86944b3d31675dce649b204ace32aa3d2bf7d908c1e350f3a86dba6843a5531c0de7ae2db8bc15929cfb00e62f04278d9a34a204d8a6e3d4589ad3146d3d65e3eb213ab59b7fdb2bcf22c56a2d88b380e675fc1318268372548080546703a68a3f73a2e76ab13d555ae70368bd5d618b8cd69bdd04d7c20495b0d000cf1aae2b0d2917463cd1e240f5ee01e95ac90fa80cc84dedc95da983ad55360aade8c1024df5d68b50845770fecbc381e66b54f81b77d2b076d1938f7bec1a7e71ccd1c4d9050fe7b2a91b4022d1ceb2fbdddf24b08f69ba77dacbced7268e0a604873838187319538dbbfe760d0cc3c5f68260b7a42c2d37bbe8fdf353a759d015fcb766e8e2c5b82fbc9b1057a75645221589111cb8c289cd32e7ff8a45729eaf3c2bf81392faae2c26092490aa25353844db351cbc1710e299bc8047c7036b92ce66c1f4a480f12a5d43f962379a7a19b1f97e00ecc3f53cf3e39601a59de17d56eeb16edfc120d226bd32d8230f35184130b6f680db6d8a4cb381e4ef7a9516af0875c0d4cdc40a5c44bae36ef6393b916b009f49bd58039b19894a84ad93b70fee14c76a69a8027a8a17a697360fd667a15b37f2686edf6595e5988364f4e138f5e42084d244f16bf1f36ffd0dcefef6581d5e9acc314414217b95b74cb9ab665fd233331c713470cf82f4d52ebbd8c7a140e81799de99664ee0ea045db7366af9d2895e9dbba18a905efc722d564223f8f048e71ff679bfa413a850c9828f4af72f72824511ba51d1c5c1b4ae44b2dbb7024caa93f63774a44ce0ef56515ea95a1c42994015757b9945ed33f0565d314d68cbd70ec01474b244b1adfd75d717842e3b97dc23c6e8f5adbaf1f793384cd181ec82accbe904560432d4f80ad387beee14b32fb831c237265288b9c5f7f920aa7d331d2c35c26fa96ea11a95566dd4e8225bfc5355773c7f8c4ee13030db2ba8a33cb7670951b67d4dd169ec851dbecb5b3d4dd4524b4253b5ad7ce6a1826f0e407f8e7de117468963a0dfb193e90ec009b58f31feba99bae4903fb2065c28e8aaf9f3318d06ddceaafd417abc0ada393bcb076785a83f520655fcf0aee6f78d4b5f9e90f2aea2b15c70562f067fc63e14cb195ab41a6124c96b686ca507cbfadef155b479f1b77a45ea50cb457c84eef192f1df53051ce8ab6796d957589fa55e16f363f26bd106d3d08bfa88a07acc3582fe891e78ac30d3bc4465114c555cd0fdf063a97fdb1ce77cbfc832502d6bb3d40297de03cfecb9ad3052b54c690b683c4c03a1548c9609705eafb5b84b86c6c334c904d47e57eb9621c996cb2796e8add2bc9dc2ef46f8334de6edd0656c828aa95048ecb36a1ed1785477b5c16e3e065f91dca0d3a75696877227780f17855af6d742bfff779a93c8326da380ab6177683dbb690fe2b0e7000327673963ecc45af84d8a1705030786b7f0429a131639297cd7d40458b317ddc908976df30e70626dc5ed814c2d5570232a90448a385e896f414684a02b9d60c84ea54302f15089d7b7958a9bf96b4a95bd85e16a017decab75e54c45fe8b3d3ba930d6197e6d3bdac5a46bdc0694c7e4774d9304ebc70c0958f94dab3c840bd7205c3e012fcd3283d726536803b2e5b70474ec806d9a6427979446cd98605f8b7c590d357b5d4754d8b9d6d1e82b288c5f4e63b2edd2c8dba6a932555ef66794ee1c580145fd162593345babe356d40691c2723f29e68efc34efb4fc1b010f9fbd0d0955443aa03baf2621fe565e609c1a860c53fbc2ab24f13b844f915c3e5eaff2a94e447dae97aadc3262b671c2a0ccad3a28a785c2dfd9d720b66c54471dac32875d25f64e18823b2a1bbbeed452797e238424fc2ca0df93cf65125bb7a273623c81766c1ea37989cdb3bbf4e0e4d9ba2b33333f1a87fce8be166d31999872e3fb9c790421c43a074aa8c4f50c06bfb9e13a8182df7680bd9cf191dc9217f30e6eb38e9ece4f3cfc53dfddd20cc067bd71db6368d3a9a7e5b7c7138912e4cbfdef6711c3caed3787b6271be61ebe8528e9666ddead092c13af7b657ff1084c32702456852153f192909f4f400a41341593c4156775378ada82e2c012b0781cc5123327f925e5d0251c6eb43cc31839bd9d24f63d9a6166c4daf2e204870c8a2140fc668f2cab1bd4e436602b0c05da3106a90d97d5d1e58c98588d443b008a0129bce629e10788c8bfc601dc1f7f64f8244c701cba680514c61b715235ab060bf550cca2e9fc501f8b20a5bd885fb8dd01cb939426f2f204f6c280637c648baa43196f75bbe9878ae31b89b1947419e9763e46b04d934a93e146833fefc413e9997a26858668dfe3b76dc76f445105a602ac264cd454cb3637323a5248bd638ccd07d3d300fa8fd038bdb26d8484312df5a7bd2e70801774233b7cf9d903b96810ac1a521065930448984c1a372718688f7a64ed2c2155a681d2853f97e2f34efcf021e3f69b890a164b45c0b94771a4262c6ed68d69fa9306fa0b83f63eb0bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
