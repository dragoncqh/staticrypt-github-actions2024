<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6391974bd92f89fc948cff6683bbb0a88f23cec1d87bb2e33abbe57e3d1bce2f39ffd8d2426c002995927c4b451475cf16f8673b051e5e2074d5791afa228c8ec22debd73f859617e92468a74ace4cafc4f3ff4f4105a881f441dd895c3d421dc5021e76995716ea1b02582887a000dfd6fc17b69a610d574f5cfebb7969bb5ab98722169e652fa14125d73fcc7184cb7becb28a3c0c2af92119450602591a56694f95368672a8eea355f6c944d0b687ca16ffb4245efa08c1f056a5010d65c3fd363a5330ff6a389136fef99b03cdf6395a3a4ae99a4344468d921bbe449209988402bb5600da0662b2d801199e9b448337911f493e1a17137b5ca819e336151a6d0fce1f1206882d9a6fd9ec2537ca22e2a8f8249eddb06053b945020e930c4d15bfbf3ad493a5c9117720b361bd0a0813f323bb0fb262c8160abd883a9c4c154af0406e7823c73de76cad7508475e852682048e95d6e08b9f965501683684e3d390a9a275991c50784644d0ac7d555871d00e12b1ead5cf545c4f7161617f215717ea22760377be1c443a436661c11e2bcc612ef0b2aa40c21c7fe31600ad63db222f83e6ce6c9b26d8816ea03523c64c06e19d6ea8009c6ba6c0e385fdc22c3f554dd2bbc51c26d9b89b9ff66d92a811c07205866ad6bf0337138147e287be1ea9c265955bca62a811b6d978068cfc07878870438c4a30b031db068acf8a3dd6d604c5a5aa216e1c5a32bbdf80fee751e0bd9df82af09b560849d3dd9e1b90937e9885cc374cd2d5490b3edd977388be398b9496ae9ae1dd1f60e3dc82e6a670134da51466f87a3920ca1aaa7990cea42967221ec500895333d73e0cb94769a6f97466d54368e9aa645161b878a8f400840f7feeed63134b708f30e3788d858e5b23d822709f44e3372d7d8788a1dcfa9a433e7290a89cc27d2835bef6b43c3647105d900447294227b0aaa8935190fd4388fe4486c89c9f9be29a9415f40dbd8ab6e55259adca054b429aaf15c7e84c1eed8d9279e0f9c76fa5d077753cfbc09d19837f7f1a07c50d8fdcdf01d0e3ea44655c507e96f68533f8f45ddc8b71bb6c35f81f36dbd9c125d5d71fe89ded3c1226a900f3fa3c0fac7f6fe6ac47e96b2296b36341962b999c11beb06c50ea48b3f9b61c76054f7ee839817b36416d782d190873a4bce88fe19643939131cdd5c5c9a84ab168cb8ce19b43876b098347f93aabf21e2cb0dfcfb575a24acc1247b4f30f3ada4546e8665580ab431ca02c4e834d3feceffc22ce7f4fece9431f8cd7ae41d99aa3c1582293b45a5a5988c9562cb99d55818616ab38efab09a2e291e3ffcda8e83f9b11678ceceb24528acab4f03fcd2fe29e251c1b292dc8394f757f9c8662921bf8546d899b8da13ab14ad3729925fe5e4faed0d47c7559a88b54d6062f3af444762b1ba979e3f3a80728db30550ad13f6d4affe8307cd2fa53939cbf9a2be146ad607c0e111801f1899efbe8457c9e6ceb7f220563d720683cf470b8c63727f58dafc3e2a356afcbcca35b3c727850ed6eda3b6a60385a5f2fb437922545946c8d9eeb49c890789b86b6eb568101f328781631f950a625b1a830319c806c686d76bfb05ea8dd5365857f462f7fd8608e1fa64ba6c5ef30ec2d2b23c7b7bbc7c16eac1eadf27036caca9bb34bc8a328ac19c82fb840ccfe2a677d9cdcc072ddad459e2bc1e6740df561d7070d8e83b184d492e809dec773fdf5a941892720ad26902d02d99a743d4d3000a297fb158da36ccc7d4b79f268088f12e65c9666d099dbb753459182963f839fe88ba2238c72a40ddc7def79157fc63edb6dde4826d8d690cbfc81dcd39b04c8018d6424ee94c7f42719bcee392b8572f296374e338727f2eae2b3573de367f5ff742a07b416cfd2bd705c44b37b208fd24048fe868aad7c019f85bbbafdb92292681ff9f9e3955c600eaea7c8d9fa02e80d4491a4cdf392992213c9507d3871da5335768d84cbc352595e3e03251eedf17e39545752a7f232287be1ba8abea628033cc6bc54d4ad5602b1f376160da034b0723811d0254acf81c6747e05fdfe0168c523ea1b9c610167c69b990ba91bac974eba9a4a6146f5648c9cc33f2966dc7cde8f16281463e3f63ce500e441137433ceb835f89baa6d30d6b99495c7ffb99f1c081db90375f5fbf74b48f3519e3aa302b54fcca0abdecd432feee1c1d55eaccf9df6c8b72981025b60a084aeb73081d6e9fe6371a0593d4b74f048f64b5d3d1ca80ed45c55876a219f1b4dbf5ede051539a80ea282b7f3ab7f2dabb3eceffffa50b7a90c1d810bb2eafcc8024acb63835fbfa2a006d9d329427a0b1e9237e42a6996050721a5ea8bd56a23e2b4db7f185aed4a07db50ee4dbff37488a5a23c0b60668097454eab5590d2011d3e37812e4ee9581bac0c9d71d0f2a936694131f7270d710869469768a0033ef02b0c19c83dbd787df0b6a195432058676dcb64707cc497e6661b7876b6e68d8801663d0eeb099b6646793033ed67bde780953ee3ac5d903fa080094f398195be7bb74b0dd5dadb63951cca8cc15398a7a6212e1164570c8d9530ee1679d8c90138b2b00ee8ff7624161b64d50ad7a6bf540bb64f6a2da56550a24ac4c1fe7ea259fa4141b3ece2b3252710e747b27356bb887f26bc7743f274d318ee0a41237974001e32d1d334709cab00fa1be5d4c51f2a8794489f66eb096aa479347b455990bf0823d5208ba4bcf48d6f0d02750901d610ede857c90c40d18b049b64ce40b73135c9c6bb547cd64e74a75e16a8d4b7c7fee742e5f937c5d938c4a3fb1f4d70ea6e1a43906d138ed423115a0e2f446db4e407b51386be7197dd60d78f2a25c458adacaf5e8a67c8e6b37f7860bce492960fd4e3830728cadf14cb1fc1d4cf90d9dc8678236c5593db0a60b487369d14a4929cabda1febf82d30e3a5876ad26b40e552243667235de23847096d24763551e8d4004a5ad1946373a3df4c72799912dceb151d7b110a3ef972b9c8fc9502c369f29691cd627d78e4cdf072b6b8536069f5c2e0af87650b5baf7d8a8aeef5263a564d0eec00716e6e559c405acf93ed53e9460ab50126aa42cedd8de3553e732905b0184db2136167947fea6b347a4c88833947ab11ae9f749f991832c4e1b68dccfe275e7b7f61d2d7117152e4cecadf21dce2e8898d470a180fa955cfa02644f30b493d2dd832214145856125b9c61672372b74a7381e06fb830c8610967d7e5d98a4bd649d90471b5ae5fc3bb68be7ffea8964c8d8aa6c165e11b06cb86f5ae70cfb81f72ac4ec5c4047b8191e386a3be500b8552b85ed179b574cc62ff1b9884be3e12c339050bdab0c96f1864c382403127e7d690978dceea7c0fc00fca6736126add5b600feb651fc8a8a584138c201fb3def1428a4a306d24fd3ea80e077ca82be5d7742969b80fe444b11af2e742be6e897137470abe793593833096a40a40de96539d8cec58fda546a59aef5403d1d9eb4f20edd94686fd99fd11032635fba3922b2535a89e52a7d0e48894c846135671c30ff1b5a5f9aba8dd52351b7113052bfb2a1606af9f89abefa6fd44a66049a67bf533669b24281fc58de012f0d3d76feaabbf676f7daaec1058a89f1077bae4da408efd32263f43d9058249ad03d92f5bf35445d137359405b0a2b51415aec87465add298dd960396cd7a0e06e11082e5a9e8e0c0ab6e91df6f10fe3ab7bbf0985ec55230a1fc954aef3cc06ddf6df2c2c69ed5474bd53f12cd8a30c7841c92c994f38ed5a6edc5aa81e9b8680248d59085eee0bd328688cd9a74576aff4add7ead441bb7370ba33ac1d70df36bccdb0c8620cf8ddfeea627ac6181fcac3317800ed21dea750f85243551a63e39cf521f221e2b2f92d88a886699583d3ff6aff06da643f3bfd269a8a09963edd6bc13505f837c81955a2cd0a83c292a8dbe997688fbcbde60c5f60996b78712d0effea1078bd82fc4842f8ca6fc3af2130e13a3ddb1bb01131ed852e99ab8952b969f8ce6479e536998d9e3cf8c87582e9ee78ca7884cb4f5fb2feffc64fb82509dcae90bd9c7fb7b0cf33e84e8f03b660e1f9d63caf6c767d8a802d2d2f8502aa412f7702d7c58abdf0aeebbcdd9713f83b429485031ab827bc0812891e00567e99aa21dcf920683d57fec3d12fd9373d2d7fe5b3f8eb3aa585d63212dba7c3966f63901709e3230b4f3df261c8ab4dc12bbe5a3665d1e3527346a1152ad3c16dee00bb579c8b9b65958934cb855194fe84a1bc963051fe384b7d7d33be59b8c9b33f8247194789d2a7bbbe8e7cc7ddebec44cf4bd1ae65e66a6624dfa388f3f1f656034a89459efcc07c00281f560be0ad29c477ca55d97b2dd3476f757939e1b8aef39c91c75661725eff57b4567e15c23489d44cb58e54fdf619681a4ce0fe43b398ff79fedc16f9a5c995b3e688220e4bff8b91c21f25441af9d9e238f04f271a16f7454d3cbf20dcf800e10de4afe5a72d8d328f89a0a6bd332e4f02c8432ec13aede730717d01b3fe427c930ba4c7432e994b492eb3e49428366f749c34c0d9579512e559044590ca97b9f1f7822cb979ec08a6473089d3bf71cd8ba23c18ef5b58f8996eba717a0b8f4805f03ee252395309dcb2985b7bd6e231e77dd663caa8bc219d73ce7d1940e365aba9b8c55b545a4f2c0a28254019540f378be85c8677948838cda9e31b627fd7de657325ef1e6cdf985468b228499360353ae51281651789c72fa00b6e7ddc2bb6a7954ccf61bad47a79432dca1c91bbd63ed70273999e811c03ed231ccacb486e2691b32df7b79d29a66f84bf3b0450f8779bddd7305b0140d86413ebdafad02b55c67ef5db3ad7d3ab49496af54e887b8532320ada1680c79821b2cc6968cf469a69106ddcbb6b367831f55418ff804f2732234e706351691b98869459ee489d9e29e713ce5e000f3d6a257e38cccd1d7415091a0a76e5e86da87da8d35d2c3efb49a3bb58d2080776af0dd3c457dca425d9a6a5d36a158c467249d6f1426df301db3dbf8cbaf1de5e5e87100810230615202bc99f18776b4705ece4841ea8e3c6d61d3a0df3da1e1a6f1f7304ccc55304900d683d1f9ae5742f020af4a283fdeba11df95c3bc039f66aa74edd586540d3bfdc4b63d06066b2378ed3e088decd05a74d2a899e3871a5386af152b946bf5c297add939a90dc2c4391ced778b74ae41c2b7115625843daa7f655b860db38df7935b5a08321bde777a4a10e9d97fcc01ccfa35655e4f2d21d9a96a899fea710bcd6b713c70b20c6598583fcc08a4dc3a82f8be1017d0890f9dd5508baa3960baadb940cfe2af46f2b416d308c9cc6b82eb026357abd9000ae293a9e7bf355e8d280f92d3e16c546befa94969fc1e0d2974495dc9ebcaf4b11a4746dea14643bc056d8c63862371ae0415a5b7825a07153693d2a74ba00236e0c5a4129ce0f476bdbeaf24c7f0398d616a3263de0397f68b4dde535f40a1da5a1b9de6d1a70a105f6f158b5614b4eacaea5311532e657ef4e18334def573bb0d1daecb0c49fb5e0063e5dded77747d6a44baae7ee7d43d2e0d359803e97b6e71f2e747e25a63d9df6884441e4cefceebee1b6ef198579241b0899fc407a663f4df487bc893a909704f3840baed4d74c19671dad5284948285273d906b68aa77987213364831ca24ca8824b6960d79d896212d256ced2d4fb9d2664a1e8e098bbe16fddb5afcd4d7527999790bb074c0a6bfc7ff92284c39a464da452bccf2afeda336323501aa943ec8313e445189f74b15582dc9011e38d37aa392910f32e63b4c804b64a37ba8fb25d0c0663322ee4ae59a4761077c099ead88cbc67ffd1e53997b274c98ab2f216a2f405bbdd1dcd77f21774bd8ba94924484b2e8dc53104f812a8438d6def1b4112e31d1bf02797529c375d040301606b4fff2a52237f6c6b1c14a82417f3e802e259de692e6b5db0fca97d18633c9ba5c886ae308286458b598a01ce925a43fc1f4192af35acd15c1cbcb0ad6f9b60e7959cf8b86ab2f92fcbae4d3cc1b2b3589e4084579fd19648bfa38b82a1790b801bd6a87fce359594059230ae80c25d701ab1dae0fead2813ac898523b8f2f3f821b6413172bbb88019bba1016083f158653040eb971d9d9d3da7c738c57ea464f959c0f242289f8d66b6c5ca2b8065bf7a8f4c85fe25ffcbecde2d62b3119a0e99fe2327e620a89353db7af625ffe1b92d9bc22bf3cbfccf0acb7a46b4a6e925ad2f92d518c59596867633a428b44d905cf47b801b7263938ceb88ae682240bdf4cf5c84967928bca297c5b6a9fb5a3c20d757c078a34202217638dad40d1a8583e7118e0f1a28532f76b4fa2758434ce9bd5354a39e624c957adad7a656fd514ccb5f25283fb64ec576d5f315da180451c8d215a6b1c5b44cd5a5699b6f72b899c7d67f0674c3081f66c771f135fec22a17c58c5cc2ccd1e069cf986e1488cacd2a6772e6118c6b45fbd9f5f5b8a27c0c0a49a8206f9055c45046c163fdd4346b79ced435d04455fd5ec8bff1c328e3014cb8e3de218a2bd1009798701bcf2899896973d811ee6ed6f69fb9abc16d2844a2a86d3ee58707d6c0f6187ad7998cfecb62b14117efe0dbeaf99fd2ec915470eb3543114a900c8c597a0ffaaa7b5b24fd900587d6b3ab357b058fc04910b700f68864037cbbeaff77522deab0ebe5e4436d3fba615bfb8b430b5840784c90668fa7eba13e8a170557a4a938b958e10ea1eb352fc07a1b57109cf907cb3d9072514dfba1a5c612fc171556bfc13bcb6513a7b85f578743190eedc78af473dc5676ab8b6fa8a7b113bb681465263054afc8b02ef2e7dd156529306461098d12a280edbbb9e472608499c31adfd71e6817e1ab70e761d384d4ea4fdb4b8be78caa564fcec5c9f20bc8e541d0ec4b35cffd15a0bf83408b2a02215dd73619d1c8a009f4ba354599b1ce533f92d30998eac9724e5a831df459eec3969f96705095da094ce1164037004bcea92caa23ff1dba3c9f78ea970a6bd87cc6ac3a5cbe7883802f3aeff81d7d1a195a04cc96ae64c38f20007955cfd5586f575ae4d8faebafc40d7a481a24e84f5dd884b832aaa814648ab6e0deb4bc68f17caaf1c37445605b9a64e19cc6f7498279d345e7a2f7fed6dd19c3ec01c8dd413ea12052c39d042782045b6fbd7780cacda10a6221b2d9187dbe4a44cfa1033acd67e6e0b874b480ac15649a682847d870118457f3463fbb295d84a987c266fec2b24f13cadb0011b3423e2e3249b676e3bf7c98fcdc4efa9a5410ad83e22d41ae28944577b3917d47aa784791f1017c31ee63e5af7e32aac1715d3ef5bd6b885cf805bf450440d1981cd6f3cc618135e004c49d23671f6b0079d8f7e20c0d4a4963423e9621f8a7a8829673899e09cc90809420674206b967a1b6cb2b590580c6a744811e6d19081e05b799390c6c63eb8c90151c72a973cc1868f42618cb9cf06a4eeb2e634362412aeefd6fdd07d69c59b7f4c053a81c7b4469087e690a97fad2e29880b4d85fabed2d785269e46e3a4546643cbbf97d8591e8d27de3d831868d55149239daacff0c88a43f026f56a817dbbf4600a7d6e78f377a4476f79b2efefe095ef57233782f91912fd0c36203d2650c20a861794f7103133fdd2631155573e1a80b5272893b8a5e85c6ee281c0a52fc2a4cf1adc7d977467fbb05dd2090f77382ff0b8113610196627d81e47b4b7d7744848c7076c0a57683e2afb392574b9812a7d0904a6a99c94e8199df03362109815e92bd4b051f6bd664c915dde355baeaab5361e0b054ce4489ff5c074d09f055ed49d1396db9afc869ff6c1d9f3f66b2956a43119b8f150c60bdb072f944020a99b6cd8198d39959da6f958975bf6514f2dc25931212d2f75cef00b105990e21357e3c8704c3450785c2bcaf156a8fff4bc3692b190be8b64883ce8469a5f24df621f32c0cfb1696e17b07a48b4870d3898b9cb784e18a39692df3509950ea97690ca2c4ec100dcb5247fce970aabd1fa935412d5b6db93542db8b14847ecda5d133910f2ed2ee361d4a357931431245d8af3e9c258502d57bc4d7c087b18bc73c42e098f75492f49f9fd04ec2be78b1c75c7a4a6642c352c5945a04c3984b160a3a4939e224453dfbb6bbbb0cb5faf8ecac615ded34601c27104cc69886a32f9bc2dd2606325fdc8f4b4fd6941bf7ba63aaab75d666502b65ed5971d6d85efd3279133866983481196cc0cf3e41e6535109bb8daed3616fe4c782fb965ce6aeaf484ddcc6783c87d2169a8b35ec1e288a6719d60b082394103dfca743629e7ba1b8a94f8c7aa5612865b4106f351d42fc7a5351f2794fd15b11cfbc33a1a0f1e036ff8d5e76abf8353adde10385cb103956e4d34c24dc20ada639f557190858fb0ac0808c73ba625","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
