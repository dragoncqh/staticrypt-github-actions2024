<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a1aae6cf47c7de35be300dcd02af49222deadefd5cc68529d6095c40db5a9a289c545ed0bb8d943c5d23e595db4044464128cb0bd3c1c62aa4742a5b21144512c571e1ee952f9251d57bf004be8a41a98858ddaba2302a4c0d83b8eaf5b7289cde91aeb023c632c8c96c58a9a837aba0519634675031f9362b4be3c497f6c741cbeac5a68a5a2f9e6c72d0f68da79d9ce62db0d2851fc29198b86e32bf4e7abd0505fd005b027a8e0e077b9fa629f62f9fc38eb48a525ab5bb80a371c01952d88b94798b8cbbf16cc445a7d5262812d9eedd82b08bead0e7bde0b3409c68d51277265e0ef6c492254911ef310d5c7461f4c6a48649b3193413bc9450f45329d83cfb30bd155e7cdf8fc65207b9ca0b23de5054e93e4e22805df1a41302c8fbab5c12909ce681da8085a8292a4cb0143bdccedab0d02af3ea249274f68b80d95737b7cc6a87374bc080efbd0b3de0ffa2c14903fae099adf26eef9f501a1bb849517c67f9c1617d067f69222ffa6cbd76d8f3609f05ed625b4d10301430431f0c162e50a710689417cb1f87d72a70ceadea1432b2da3e3318b475f9ca86265334441e045e5e0f2f152b86ec1f5e4a894cd1abad18dd7889f4baa676d73242d5ad98b630eb3da6e3491c6f45b8a9d3854ff507a7f5bffc84fa65dc070745774b0e4a6e953fe6c065b110fd8443e7c8c29e0c51d84de4240d53bf28c3cdfb6117b785d2553a13db564f107a8e40741fb6fa1ea8ed88e600077ea80550bed09c39a38da0dff1eabbe6ef0230a73c7e066c52de5663498284c7faeb1193eac2806fd14d3a88302d72381beb6eaa1845f51ed0b5f389340da91ad4fc18ac0f0b0f3802ceb9ac11c31c03b6d825f27522d7543af4fe714990d35a3117f038e6061a53b6e131b31ff02885e7a1a5a091e1c084565223081d7d420a07ef3cbd10aa0ca801c6810d46a60eed6cf773bf9eee9898dad4c0c15a5c7606c5d59c88a0ecee4dbf575fd3078b7eb90cd2260dafd8d5b08db911d34ad6123c4d6d76c675a3414ed782d525fc4b98bb0ed8512086bc86c9dd9007a9515adc6d4b83c1d1ae918460d369954fe7abe194c9e144cfda726519257fbbb59f8d10c48220d84bf2e5915f54798cdcb35428fc5d72ea591d8ce82721c005077508c27757a985bcbae43f624769fa9b06ee078c7874f3a04a0e80636ecb4f992620654c34265f7661c53d5111f3a43e3722086a665776480933b89fff6c55a4624b814102dc3ea0bc7ab0c0d6171cb0b78c436ae8305cef860c6d5a25adb24ad07630f29f21e9b448c402e4acd2e0941b2c9b14a8c57ccd61182e924a6ba0c8a6fa1a047113e362d98079b1cc200710e932e48d70f362f6d8edf5dd4ad754e3c808f0979f5c08d3c7fe21cc87e522622b275944e6321f12be42441c7b1f481560f17c70956cceb8f31d30d5a80a1687dcf119243e6953e2bc413cdde1c5d0d1a6fda6136b254061bd742fe24a464403bb8fe8898918147193442acf86c813412af8a22fe2db52d28dd40122c76e079440d1b66f844d4cc5e505ed0fd4161892dc634cae51bc981d2be1d2ec4329c6a3c20e2341fada155d9f71bae9c663f5c5b8b3d69e3bddbf0aa2bb008ab5d876ac225228ff13e7a75a5d7d0e641bf6fa7294f430c33622f12e2ec694d77e65496062bb4da62efa4a93e71bd87491b6de384360dc4e2b4597b157f8abd9bc333df369f25f480be31abc5f93d53fcbb563d4aa30d7f6d5f1dd222363c1a45b9da818bb89782f01134d3908173cbf08a8879e495008ab137c7b15db273fd1038faead590037affb1fc8474b0d450778c39ff03ead1120eb616b2ea638565d7d03bbe4f56541e7f10bf3156c57f180f508762f9338c5b0da67fe38321267306fe809faa7040a44e1c05346950a46ba9f2a5584a30b3a967eb6231ef948cf93986ec22c8f6424899ee453a7fd209a9b3f0c8572f424d64f60b778c1bb125d42a6a73f94a157ca4ec7f38d6cb8b7cd8d8afcccbf676e51e73871bed57a5a83889d5e59f167b856a1d1cfdfeb80a67640cb873b87e293bdb2a43ea5036a85731bf19b3913d089ebfbeb83f91e65251b4fc84a29bca6f6d1748b8ef2160bbb29d8fe13009ece0867e705693343158bbce534086adc43431580b21bcb7897bec91d6d66eced73ccfc309734bebff18f62a8702cf6d051844f37e83b8ecd265cc7f78e92b3861628397719aef6181c7265bad62a64d13f7e19a05d964ed146e173207bbb596a1d39c2e820029f85dd7db490172c874eba040d1778ea2fdb53f2d13129238de11b7745eef250551d4b6d50cd5677f03d8d4c150134dcf1b63e1ae979f2135ad1d6cc0612d8fc7f6dc4989e8e5577bc479ef3e9f07667b15e0b317c9389476d312c3c4c8f6dba444e544b77336c0b77f853f7c3db2d656887520b5d97878e8b25d72b8fbcd45d5fa7b29da7da882df497bfe08e2349271562df5a4267d9742bb055ac579eaf890f017fd388eedce0cb36a70595456edcfadd0914783e30d2c322844549ee44b4af7462e60e2bf60e3479f9026dd57b509d33bf17e886c828d7a311a6555c5d8ff264642c73b6359e4c31b4198edd9c7380718acdb360696e192bd2896b2d68a6a18fd1ba34152f125da9e3c9f9560bc14135891a01c50c7492ad86d179f86cf40188a1b8b37e9b69534cec13148dba7982e8186f385fdc18bd3cec2e1b9892580e2211759848a99d1f5c22f24c51e7e046e5e199d5d9330bdd15477fc0864c8c8043a47c3680385f91e010bf7a2507d31116819a8aa5c2c1c1a6dc448aae5ef404efc7247eb2da5a14458f61f87209fcf3c8b17113b062c37209c9666970310d39462cb55fae815c3bf8e9b10d7fab9bfe920caa3a4a474ae322a4cfb6ca24ec9003b6417db1a8be5a6fc1db74c2dfcfe63221b889ab005d4e9c0aeeb729868120cc526a650280365c2eaf6781126fadf81b74a16d93b89aa6bda51491169f62f6acc60f1f7dde0a4dc1bebc30b26c05ce4a013c7f45525aa8099ab4b3a85a5c222c92be312eba8cad2ec40646bd7d1ec2c89d84d55cf5c535cf54585304c29991a5c83526a6bcb1c93c4093f9dc386de31a14305c7c15ce5ab2a765124d0b334aadd5755ee079fa3635707f8a16cb636e3d10da5d0f37174fd778af1f2f7a4159074b2919e9c40dffcbf88c375007da55eae0ecdb8aa05c022149146d87bc6b706af5af03c49f3f115765abc10e2a582e0ff796841bd4d3e1887cffb9f0f664ac96605c56e1d07f3ff7b18c17b7b839d52d3b6e729be95722eca09859d23823909c60d2fe1507413a10298956d62f3dd84d90be39c0d40dec39118aaecc7b333eb80e1e40ce11c2876758d4cd97c5988579d23702b72edfa34dc3f4798f33daa49864829d335e67a87d06588e5866747731fe34f91676a015a0dfe07da6aac34094ae87f1b97373ac1fae3ce8344b076d84dd9592301db1c687c162fbbd25b44d47af52312d27356c8182a31297b148d7a4e81894f74ddb9172952dfc65b3a12bfff70c7520f953c91d8e6f2f10619d2cdd45d61a841c11d0fc513865db79858489da9b30e71f1561652b8f95b79480daef935de292b9fe02c67c3e55d476ad0cb4cc40e9ec3beee5cf625b18c33ecf6453869a33f630e00cf1955719a3ac53df806d17f91d840cf29cc7ad5354b2bc7500b30d9b6470f453fe07a0f158de1cb37a25585315e0a0eea63a9935fb83ae6ec7caf6cccc8036661a33aa83f15b251612b73257fa93c1aee494a84351c1696355b45755a80f1edf2f14bce746847eb6b68f24ec59cef8e23b08365d5a27eb523d1991b5754382fd31fcfb82ecf6c5c723dca272dac6c5613a363786efd4f173c37a8813749e6f0e1f62f418db8e55ff138eca099ea6b540d1917ef9f8c7a2cf5c3aaee2922027b8da125508b3620b3ba2c8983cde51bc12e27dca17eb29df7064ab0b5555d56c0906efdc6dcf9c965489f95d54dd1c55f977a43e67ca5ce39a55211ea143caa0a188f23a9f4c18941a567109b24c8d33b4395554570bc166acfb1440092c0eab4b66238f22e2bf4b8e9136016e96c384e73f3f8738e2326b25257284f9bc50a8965e4ba79a9d47bb854296c93eafb6b135bdb2cb7ce0f7692e175511f2565c5209ae3eac9ad811756954ed5ac23371c075ceefcef13e484b3de380788371c8dd2f3f1c220ec3e68c11c1a058c6b4085feff9eb4926841442bd88da07a109c7263590b1127285e2e6720750e268d83755c743ae1e3adc9008ae34a144ea03d569380cf34050c79376259a38f198f639892a27e067810ea41c07011a2592a015cd1fc8f22dab849bcca1b6feb5a6a146c433e67adf40c6a2e85255e7631df56fa6ad9ca328bce544bf873060089dde6621218ebb8df8988dc990f15a0a6bbb7ec4a62343db5e03bf6048075d83641552f3264f7f71d6bce59cb92e3ef14c4964c254c91713dca7eafa355809a8ef92a96497f1e05d4954bf208c31b83b690dd0f9113f2481cf25240c4c702b8af78a918321db18be6c107bbb224a3ef7ddeac99f76dc27c5e91937c6233feaf76d3cd3ed2cfd509b5e1efac0f825cdebe9d4a4f72fe276bedd5eec33aa8e608ddd81bac5f7d4ce62555c40b1e433b3fa8f7e8aecda1d7faec024564971d35f622c6e1e44a129f1d020edd91d2bd912e8d99ce36e0e622623c4fba7ebc1cd03b2acc6208ff134e904edcb1d4cf687dfab7512de16287bb945a5bdb8f11a7481322cbf2f700168c4fb0ae68337c32a9c202d4fadb56e7da0c2c492b6ba37c7e4d47a07bd6ec4ccb97c03b9f7fa43127d353366695a3a4d266b57eaf6894fb70f51ba41188c44a37072342e0cb76921ad37f33ba314f623f60d20966a135cff3e4cc1db7413a8545689b1f47bce3ca303b18ebb569d830dee395d52183d7f6ba0d07fc437b9b200a1cb6ef30d4bed0cfbe0fa96ce0fdcd4126eeba982e1146e1f6b46f3fffad2e762a9498045f54363929c48a88de67f30fbbc54a20582c97e0857e890f1dd0b9a8558629b49152926b4c686b7c1fdac477df61d7a7a7ecf95d47d17b48bf7adb0d199fcb1248a649bc6dbce0732fc852495e6922abcc5c3b0ff45ed2840ff844a3bbdb58d214794193d9c3817d0b9db2b69be2c533f42b2914b39867f3074375ea050c8f58a410631de9f49d1b97872275c5904070f402b51686b892ea7aa7ed3f9e15fbb444014c4969fd19853d87bb7bdd778a068401c48ab8cac53b8157c071006f67d79d3e67c929901d0e2cd8d813b7cb2895fa8273523552402697053795b704cde405044d68e8fefd043ca286251fd360955b697f6cc958f584f9049c9512263fa2eb439c8eb141fa9de7caf3a05c26f90ec791fac58c1ca7354ba301dcabb8d0a5077e486ed97b18b4463cd7e6549ff008bfb4a6764e8541b4814df9cfe5a795859de2ed57e00eb7003c66a3433229e4eb9f62b760a72976d60e2a670f6aabb9083af2f7a15a8ce54f9ab2a7d16980a26b5555cc718079e5884ced8662d0221ba41558ceedc47d97ec5a41fcdedcc4980e3a733e337c4003d8b5786182584306c5a2d1e809231eb7d7850e0fe7b1a8c55fc345a437d9052dc20e6d4ed18dfee1d36274999510f034b79c493cfa4b004854e7c59dc1f352e8c14a8b9fe0e19f9b3799b628af6ab36b315355be1220d00dc1d2b54aad24af9ea108252c88d4eed7bca3cb3522622ded3de5744cc0038816ab625d6b9a819888f57a03c227118ca86e94748858a48c615a22246d2a2562ca25096346a133196320f73bff76d217966899c0fcf48c2bf8c7656e5a307553f21a7f7471b1a493022c19df4cad900ca259ee4c2801457e32f3c5028f1be681e0c0b85d9c2857b25e5b2df08eed561d6c06e11f894fb9b9d28b5996bb65ce070570d048a8f95d3146364f1e3e3a5ba1c72808568084e431ce542421a7feeef100d42a4670fd5613af406701d0a1624e8d509bdcda925a06e52891bf8d7600d8ea51ca47074c9f6f7ce75d2540b86e7ba960323cf0d8766afa937c3da88735813b34215130df3060c0e7be83fa0cfc85e819494c26de5b06095de92a10bf354526e4b3b6b27fb2f9c75002940775a534b186e26537a551adb13a8019d4adb7466cc8100bb488c36a75dddbe762fdbdb80970e839d5a5d2ff6e07d6424011f8041bf3a1fed10591ec4eb828219cd5c67eef8eff8ace6341456a8a3a608176d31e9e498989893693ce99d0389b091d6c108a04812fd0fbed38998ab6c822e111ac580f581624324e9f453df38e08e74576321f374f6de0f20b9960b711d5a07c2af5762bb733247df2a5bcbc48f324fe545fc47609ba8259692871944e00610cf965cd4e697f589b4cf9920e7d25139682abe2233d0442d2c81d9e21be9d7ffd3907800a8a0b34ab28085af8ac87111b31337d78c4697a14d14571bed993d7a85a18cffaa1fe2eebeec55e573927649159df72d2dd87692d9ee328e8af22685ffb10652dacd12c81eb6640a295ceba63737d267523204253558484b21741c81296cc0bb4e0a71420780683188345e6f9c714c1ee19159fcdc1d7b959a4f26a71df08927d4358c6258cf69fa49304767f4f28ca6d22f5ca39e58be6ffa46566ff95658bb98370fb80e35bada37cbf9fbeb5f530632923d67afe515ee0e45d9834dad2e4714e79de019f6451fd931d979bba02cdaa17b7156f27ef2447698ec6a1eccd2bf8bb09dfad76d01eb902aba8c4a18e3fe21a09d3121923a34ffef46ffe8d05121929378cc7d728eadabd337b8bdc197b3a90521f2b6bd595d96a1554e634de0cf430e1e5cf642309d39c3be378297b4c03169980f1276d2e530c106728ceacfce6729ec472fa5110f7bba5b7af150b9302cda3165bfcc284b982da151a41b024644407ffab293f518c032b511ed1ac67567aee93a65eb6e27ee32f222c3216bd32a33efb9415aa1465176ff622cdaa12e24758c3c0d19a3d28041fa0138009e9de3f740d6820b9b89965b5039be0b86ba0ee843a27204025cdbdbede52d6d36dd0f58e7fc729b65874618b0951bcaa7b86df8e79e587017f15fb491ac08d4da3a1d135d41068c9e42e09f9bfcfb8f18896c7862a74dc169e5cb3ec0fb4f0ac80efaaa7e863a4273ad155b8567f84084386b8d9f62d162043670a87b9c36f48b76201ef3418fe685c21d5eb430218dcc60f32c4938a975b2249507f00dbf6c5d75cecaa97c2748457caf32db729aa72ab8c5e8a0e57723b27728971637a00faec90161349b60beaa925c5e1d013e71e839333dbd8411aba81432e0ff2c04e9b583162cab0519169c450946b25a4b939ce1183efdc18f1a0705ec3c6d7a34e54389720d7e322dae9abab6d690b732a7727e2f795c0b15b199ee66f03824efb1e5d8d0d1a38422b0c1ccd75a0070b43149eb8d10fe9f02fbda8c6e451a3dcd64eb88e4bb4c64a81f79839ac9dc992f5dfba1a13a4dbdfcdd5540991a4adae0181c8a68b2462c58f1df0cb1394fd3660ede01abfa2a8aed73299f50c7d692959fd92100697fe23e6b61218e27cf8f7f5239d4dd079c9f7c0f23fcb8aa3614efa75308398c2ae8d5fef1d79cd4ed584a836f52f1388c487180d7a5d220ad9ef3e46a2d3d66d9d00bc5e2453d47a6399695b444e5bd6f5a6aa31ec6a126193b3b9a944c01576b869ee02ae818dd0e45a819dec2a6846d5f93f7901b7fc2b7a7e90782e7f1e22a7eab047eba87d3c494bcac94655c7c0d9ac1e77a149496fb1226035822f8bfa8b9be286218f26e6286a218e044e94f1bdc9dcf10a47ad5e15fb05c3f58a1b8343ad4974afda659f6e9e20b99e80df33a9f737d0b2cd09840fe228357ac27547b2b1cd4554918ae4b6ad41ba781e21886b086ae28fc05742b266f322ef10edd64ae1e7682ebf862047ce406ae7545f7485b4eca803a483a0cecbe5bc6c3db57f93dc23e6552cbf8f0386e01991569235603140de0b2a2a616b7759f8dfdbbbdf630c364327867abbc02d3c9715806749c6a86d64c54ad8a87aa7eba196b283e896fc59bd4adc84904f510767c939f692157c0db4f40911efd4ff1fc0c2f961746cd29ba8f91611c1d80a1335d9ae84b5cd49224e1dcb044bddbc7d153a2bff81f86278e4d77429151ce063a31ac60cb6c0b3d16d32715e97affdae254ade12f9bc4e5401ba613c2754102f9f8a56d9a2cc0c4d7b135874b32c868e5f52e77054bd202a57c24d63d39c58c2e6086c97198e708051b6ecafc506cc6748658daa830e44c7e924f5030f1ef230ff6c55d06ff05b97eb427336d898deb8f0be6de6678c932a166af9f4dedc88cf21b0628368f61a9e345ee2deae87bee542e26386c9c6df8fc53e526e3049c31f53f1cf39aa0a013c124ad5744b09f4c6afa09b0a226aba00f38f34bd59f86a2c0685de1a669cc270fba5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
