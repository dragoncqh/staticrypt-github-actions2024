<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b2c6dbab0a1011e6169fc3019d441ecb111068cc1171310a6379c780ee4df2f16eb4946d944f9b70a8670905713b205fbe3b561d8d3ab75b20dcead83c68bfd2eaa5387dcca2e2e9c61a44c75ad4bb81f62728bf68716db94206274ff5693368ae5a00ccc48eb5c971c28367413379a4d7cdc68c4adfe902e0a853620e4b02be90221dde7b2ebeb9353eda59427cb62d40b20da184ea48c7e9be4e632cca72f7048e36a0610149d78c40ef6591e3fcb68bec8ab824df7285ed2ccf4bf9487d52d7d08848156878a52d278fb5954fcef2652768c5531764ed43513dc81c4e88512fac66fdf133bbf6c95ae662d5ccb4e06c251f1a092c47b34c47bf43f1fea437e42cdec5af1fe525a92fc09df8237b71c9659c326ff28c13788d0a61f99ff3e5d9744910645699c8086dad88400b765cb4ad0369103405f56bfb2dc9519be9c40419db2d497140c31d4c0523a3b8577cd8c892d73c0d42babcf7491d7734cdf1add54f08e6a11879c6b7eb354a242a43de514d98801a842bbce78685b253dfc2a72908b205c89b15ecebe7c5a08e8c3b753ee5c0bde20db8c8ad4234c100a14d6786177c9110153a6fba9aa9d4356e3c6f7472f9ad529665f22cb63ffae1f9a35c3b2454853ef9e82593c09d85e8bd21a7f4acfad9d03eb45125aa40a355cce5c630628f4121401f52dfcf1a6e6dead38ca09c21e646807872a52b88a9875cbd5dfda58c8f33279dfa77038a29b2bb887286068b25c86622883050997d9e36f8d72195a8b81df233f9fc6254cb509bc7cfb2bd485b0fcf1577d8479af56f38f0bd3d794003ff3e946e9272123c20ffd6f56c98a528a1f2ee326b479b36d2de421de6f8aaf860dac1e533c2d5f5639e130d230d0802543d2ee3155fb13ef41de36c93bc6431c16ba0ef85638ca2c901f7055214447668de11fea3d9bddd7b18100a63a563ff0090f5466443b0a0e693aae82985fc8fff5e55ba034c47612d972b6d6ecf627d9adb1e0c76bad180474363f49b668058c37bfe3d12244bd82912e4d373df5352f0b6016bb31659ff1bf979f99385126260f74c4d061696fa7c45070a3f644ec9fa7542a8897fdd41b982127e94a26eec699e1c8bded62932ea8617ae4b7e2fa7ce487b9ac8c6dc39215ef1473d15db1c6fe82a64b46fb061dc22666447d3bd34ba8a4deb02a6d86dfdf1a6745a2474945da3087c56932a1e66cea9af3b022a5709134997133545c1ba63247598bc32a8ce9bad67b19f1471bd42176fd3ac7fd7f8b82513afdbf9638bbc83c3d0db96966d585cac733a955a93f122eb6ee16dce78309b63d0361810d020e48a46402153f755899ed4847ac753c57c3696356e502cc6c276b807d8f2061378ecc7a848eb1defe25fae97e3c8ca7353131f26192e1c38c02206567d416f35bf72c5c45c96d333563b11bf369155e3e60e78ee11cc39daa2c716e5dce48d7c883af198304da683787659a395ecb6ec873f469177960d3fbe9e1efe6bedbbd4b26f2ddcb22a78963f1784cdac0bb923825d633557985c799894c52583812e48ec207bbd1bea870783ba807bb21db2d167943e0f545fae2590c40059253b96c4b6811e9e88a0d3b6b4bf86ec37c7d6dbb4aed0067bf1ccf1fa324cebf065189587fa94f17946dbe5654ec9726787ed499f770d90f0b58ce8a7aa88ef0d97c6fdf281fbf2085eefc8c633ab71a0b600bed09eceefafc1af818682d5adfbaef43c2565b499d63eb92aa86519a1b5063aa054a3c8a2f8752565e68c4c8b6a8eb41f4c7eb6d3f98283dbf9dc55107a248537e5cbaa2ce647342413542185f5fc979c946dbd9a6854aa8955911cce40261e1104a019913b9516824253c20423512d16cf308494514deedef256663ccb00f697720318b549f907e3a8e51cab3d53a43bd5c97ea85ad241e8631ebb24fd58ef2a8cb5d00a1239221fe0cbad021fa2944eced510f571d096ab6b851f3c0f7a5843e6c411390c8e970905412bb20fbd0ab627f7b287c0494ae3d7744851ef601bbfbbf9dbc9cc070f132f6a485d61f66f95ae0de14707a6a5fb20a7aa0d0191a1bbbf6717971c2a8ed18bf58cfda1bd80a690fcbe040e675729f3aba87033c12a6b9607697816dbea55e365bb11b25bb80736a35f86fbf6af94ba1622bc26733319f187218bddea9ff0a149cdeae584e1c3ae76500ecdcbdf44c02c8f53a9ea215bb48b6b599bdd1e63011214a985aa810706ce1468d73a3dba8a276cd96c2c2491e115aba92951213531011045ad9d95811ac45923797b440086221f17f76d34e8e1197f813c3bc84abe99d4b5f822c89207f68270782990c34802325aeaf2b78915351d536cbaa7011f4589a96a7cada7d696c5f8e8f1f2a2efe8388c6934e0e7de4aafed43f46f58d4b61b0cd95cdc32c02a58d370247d7f3d73b6ceec5af1a87444e7e1bd09a08b52875c4c0a1e14938b1c77aed526d78de3f7268716e8478e87f97504876d8deeb7e0b8e280594f10e6af104d91a287ae8eb2b5e45947309a6116a45637116282679211550d890b18a3aee52d2fd23f144b642a638bf45cdcb1fdea2484c2faac77d69d6577e3a21b507de247a0dc6c7b4391e463c1a83855d67185e2484b030c2b9cb2f3010c498727ca71b86921d207c17ec6324c7a1fc18a05c59b50c21d0b9792cbc4ce956a692b801d62d5887b0b54a95fa1c053d5fdaf2119fa7f35f63461c57b3cc3f508665ace7722f91b80fc35ccb9c716c1e6cd258ca113bc426a42cc0ac191eff43229725ba991575fad373a4bf79660bc6ebcf7c3b9f90585e4a08e51d9ced38741a2e2331946b24907d29598d62fd4b341c3e839ca94f050347f46f5cda8e65f99be2ab600fdf79211137d91532ebf06cb3ad566dcfef968dfb3371b665f256637e65798ee832020cd28ed7e6ac01e05213fb94ce4e5735097a3b8e5e5292b4e7c5044fa4d06d610d9d0f57f46dd276aac9c797ec0a875ececa27692c59944761b15d73e2e01d894fc9e247e523e33bc41537342417ae2b739ca5a56fe67481f31a455ab2c4e6fb1456ec34876a83c16af88331695e8ab380d32a3130384eb38cc3a139ba0843004566bf40ed9ec44a3d1c4f7f4e8504a58b9a1789981fca8dbbb82d1eb80903e89ed0f4541a7648ae648703cfeb0624c3d3bcef1e1d8f3d5a4632c4d722aa2e77d5c0fb4b37dc38d63bb72bc924c0978e16e651943f3f58ac5dbfb30fd7e8246ad4ab06e33ffe2d2726093069f095565be4869463f9b2e8fd457d6b6d7f642ab9bce78b8e926de886264062de24acb67a7281a3adf120f302061a263a327228f52e6aa4528235dddfc1a87fe3f932a3f5ac004c484c92153a157ea1b36204c70492a66e8e831da6359cf6af5656b6b1437ee094ebff9e577f818a2ef2c6160300bd4300587e55d1b2954c64c45d49526044eeb2ee5486fc5aaa72e9c8c49cf6f1de6d967268d7ab30d3de57350194204995c1632c5993a960c8840f65b5c6c11d36d8af28421734cef91b7391af26cf0e5d0ea638045db0b1ef880e168ef1ff9e063c730b99f126e2a5d72ad42c7c4022aea29be3dc4986265cd408002b8201904f9ea6a0baf529fdac766760bc49d699c7a10a1a6680a1c01dc85bb3c2faf60c655a6e3c7e01f3f9e57f06808796a16288ff4af5eb951510d5fe3364be6f6087b0d5ef24a408acee940223258443c298a025fb03f40a02e04e6654dd9e5d007b4f943fcec808edab690da2d56c14c9fbeddc771d26ce667f33ddca21c8e2bd236529c339ffa0573a8a520e5b110a082ab69e80c1ea767a199ab30bc80d0724e8f05610795e3cdd6613d36409da8d7a89be1a7a75ca1640b488f4933b4c9a925b266ac8377278de30576f6d83c13c665cd01bde13dca045b9a75b3bd88d179c442fb32ec24491b24c3119c7bbc0ca5d100a52566079b4a28af5bcfb5b1daf2bfc15029a89001bf32ca4f70175d3c3690864f26670e14e2dd2004d258885590557a61c6d7c078f7e7e22bd786a99a04ff3b15212b2628261a09f6013a065c79e7a66a2beff96fc0ab120f9a3afbb2c5719b613dc261812cbc9f2af131e867256e18c1105575877e6807d54dab7e99753e45c2e2e1ee1b711f695b6309673da3806cb8f403fc38770c100f5d4367c5045ddae3f4dbf810c0d101120b6772d700b9d6191ccb76b08298fd9523280c5500e95dac62612ea2232b270f3c3480dd8154d9aa0fae106c76711eaa2af4847653f564d96cbbc13eab607cf3353f1efae6b91194c9f1c67187c65bcf5f8a714cd17978146b7ed71b3281b8db33ff259889fbf87f706424f2e453dd3ca3e312d7998ac95d4557201f3f604f680f7b56ffe139c8e804925ceb15e166f4d37d00ec4431501e72fdb34d425ffbb23ad358312491cea433742ef54aef8c984d7c19ca155af285526588c35bce1f72a5f22a54eaffdc14a4aa6b8c3bce7489f5eff32a952a2479612272f2e7de55174f848fa8b1ffdc6539227a4f5a62c23606044fc2545a7b04a3de6895b0e8a04c866cf093b8da858f35b9dc6174430ddf21b7b4d9292a8accb16f8ac9cc230d63013988ed377005f2715f404fe6eaede686506ab3485f5b5e48a497b9d601931bbad887ae077b009e1c08432007b2db13c059cddc52bcc9db4ed53f6f5b2dacbffa35d0fd4c2a1cf83f0f0c882b29f5eb0823c6d170cd3c22d639b0465782585b446d5bb929871b3780b338ac7193b9a76c52b63c8907dcf2bab6ff7109776f3e6ec138230e1e4004590a9017814c51f0822ebb19f9939a74bd8d307daf399f9e64b39d16f4fdb8ef4102532f3c4985105144659b3176d3e15ebf4dba208263b5b05e007d33bdd50f4084df190739b53b2dfdda88c5d24a0205654e2eb7f61598e24f54b26b64003869a31ac6e34a06e09f74138246599783355501db49d7c5df2b25ce28b65b853fa06b43071e16385affa00f5355a3c6c0301b51afabdc4b0b7f2961a680ce3d99363bf2ef76e35d97044615d6e1982ba312cad6f3e9f141375961007b65ff835f0a01ef5f9e14cc6055af47bf963b783deb8de371685ba7d69942ef1ca4b9cea5f4db57d2ff203c960b6a45a5a188abace85aa8ba855b57c3a1d6009ceb9897b45e43945ab89ab5e06e9c91acfb999f969987993f80c7399601de2c25ea9ef13c795fc7f4f385f9e97f91af17db48590a0a3c75f030b6d820dbd98e928e1ea24b7aeec6c424df088f6722057ecc320149f290e5c97a0b90912bf878679fb7352e76f9e108366e4cf630c43cd2f8bf4cdc43b48ada743424c53f3d40e10aa058a6c47e86d6b409f5ba58dd875567afa8011fb0008fe56534c4f55b9a59a46a3ddaeedfe2345052fb45aaa74cd8782b1c50ca10f9424bbaf5bf6f45863d35e918c12e53cf024a647c8cf6e4c363cf63f837d7ab31e918da35214b61d1331783d3cb1d73babc7623494962b459c2c4daa35431808939d981caa93d8f44ad9aad26d3a283511e2e46c5a97b8feb71a75b7b9317b0ae709b64f86a490023c406d4947d2be727753996286a196d17ca36d02a2eb2c2398e0fdff4ce82b2d35115a6510acc2e9951163f203cc65c4b0c47c75692a3fcef19e00f40a8295538bd8ad074f6337ef084273f3ef5d451d58f860120ddb9ee70ab2602898a6f003dfb6cc145ab6217e1e11663af2b7e6ce76dc208f3e9b6a2e223e6409a6261fc7db6e594a26ee4295303bb05c7d8901ddb4f93d8e980a24d8f71416daa07549c43a0d8764c26c54cc8f158f48f552f8ee747ebe05d47f6178dd94b62f2d127bc5dfc132eb42f9c69003b49f142b1213755c6115b113df6381458bbb9a9b2b23075f7cefd6f7fe350be4c0f141f4ce5c0521a4382c05e3ec0142292c9a4f8b729b2265fd412eaea2bee4913e25ea59fe6eb60633b874ac68e839130e212b08377e8176c8599ef3089e3f902e87dd9d230caeb5fd34140aee2ca45d9ba27f624f149b5f271777597f53cf146d158769f66c96422e698d407b0b72c54dfa2f729d7374a10a84659c7fc784637bfd7604146ed3879937df9d067f916761c54aa1ae67d591b4de5ff142fc0cd6a3108121986afeefd335c98eea55224aa3e0f7d875c94986c77e607652cc794153292d9a258414af1d400876b56185e60d3e0f9fbb2096d143069a122a05aab7a62de5d177337cca754f60d2a835593c8b082116c3988fa15dba1ae59f30cbb3b17c87221e8f09fbcb9febfb693ea1aaee0f8af5adb3de688322ecc7bf635d94a9a38a0f0e610eeec3d90822260fef9504c7dd462147d39bb840c73ceec765806a5e106e5b738236717c7a7b03ecc2457eb39adc840285dfabf8ea157107fbe3bb084e82135ba9151a3eb9d1256dd999240d5e6bc391b10da7bbb400c7e8d05cfbd81a4e79f957c62384f82852f88c6ad77481f20a55b13496d4257309579731f90b389d699f4a4880ea2fea3e61acaf247f486e9430e9c600db5d182b6f8143dd3e9aa3d3b11d3b307e2c534f30f6766f6c69641d50fe0c88d096ac940a2502ec63c2d33940c83044d123178bb9caaa9cbd129dbcc62c45a16c3e0f063e009b9e1e5d0f65b3d142bfb129f4a5281fe50f7afe264ed44664c141079c58c5e1cf5487b1414aac4dea6c261f01993f4ca1161759f8b512ea2aa7162af802bb0c42d82137c69cf203d66f6c02678c015980031edcf8a19e0b29254920efaa743157a0474acb28163f07d304448812527c1d8c9094ba747590b7370e48f7d62e082818440d74f6b702a2e3a0e4c3b4fa8ba62b003f8953f52c3674e5259276ef31b165ef5e45a2003476528a0444c62ca0154ec3beb99bac2eef45a54b73b48802cf3bc06d3b3b53c87c22ff731b2f38ecd97e9de9b06bcdafa873ea76acdf0fca80fba39e41159dee341f7623be1655822428a27d22047ab429d257775c471b7858e8c54a35fd452d9a70d41ea26049af5d35a1263140f5b007614ee1621bf81dc8ade0ee4faec2dad7fc209950527ef5e2e71e49d262cb2ef01b15271079cfd8b9eb3f41abb4cac9ab2739fa5f8514b3b8c208b5bd278fcb2fa5f74b9e49a69cf4bb32734c7025b711b9286e59c1f639eaee0b1f6d205f16c0282f2e579c6e797e4b4fa7051f459af4ff18c372e6ca714ac4fc837db193135f1e5bf2c470e3bd33233f93dc19eb1630f659dd305d03b1012f08bd5ee62569a1b98b33be8a847a651061051c5582805a2b0481c7781d4e40e7b9e3905e6835f3c5e94e574ae284e098d2815782af826ef35b20a0cd3fcf1ecf179458e6e1ae271cda98e3ce9cf822704b070e055f8eb959518dd7e55e246af54c6af4b8a8874ab049f854f8486c717e8ce67991eba9e7cc01ab353a1eda2c6077de0429e7c8db64581a0cbc587f4af8e8a88c797cdfe003c1476c38d41580d4e013ac1e4b2e76532f3084ef21f6667056397de5b0871371e1a963ed4d4605476048368dc535d03112057960df799e63842d56a9a4ee570e03690061458fc2ce2fd4ff5e76eac1cf9b47075a65677992eb3845bd630f4353f6bdaa52a3725de967b79f16c3420458807d1610c086942c051525e518aed654ede11e99c8f3571066e399411ae9175c86aeb73bcaecad577866e7844463e63cac5b89d44c1984ed08560128eb566e33806f84cda75b38593087ff6b8afb1a64e997d6ad2cccf7674fb61f3508c62ebbe513488c528db07f8fb6e22d4f5a6b88477d035ac2e9cad287510b84b7061bb4a9dd5983eccd2d991cefd38555c67247ef27a451dbc397ff1ef10c9085ef2244d893dfec57e2fade07dac53fcf4ecc2cbccb65b140c9fd65bf0bdbb86c820477b9056923fa3139be816f17ae08e07aa51f124bd79d367c586a52ba13a3b5cf39ba67b7f1a425e0310d23533b9f5d929df883ca2b984b23fa85c6b4e7cbf1cc65daa3da360add9abf9ecf2f216f861f0533ca94f93072a1cb35fe2ba4570d4ea18985b97bfa4525815e7a08f78a429139a52e37465601b88288a4b1d623b41dd99ee815234e45e198973bbb83723f7c69ca1c4d3814aeb69c511722e2e1e38bb60a774d8656fa3bbcc837ea3fbc52215ef98c67c4382e1493af6350573a06b1121244310af3fb620e11a4357527485764f87ac102be442951e78545df5824856fcea81b09c262fa89fc65ebf69912635d9526933a802f6657422c40b3da992cecab2f30e5aea0f6b695548882c1ef2f1c16cf169b525932bfaf2d75dc0f97da7ac076d40037a0c7a4881270b17c38e907d08660a60e2543975817205c50ad48161b873fde42e9cb4a67b9df2fea6f6663a40f93d49d0249e15cb9ac5e501f48f29b9806c4c68c22a6811e2e4c9f962b6a2438805b6d22552497bcd5eb4fcbc29ae5003f70194bd3141fde7d215f5980789c7c35e49d26d93141d773497cbedf1fd8f65d659c2099d0b0fc42e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
