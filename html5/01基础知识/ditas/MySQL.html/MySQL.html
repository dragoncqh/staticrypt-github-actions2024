<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f67e6dbcf71433b8852b076627b4d474a91c33233c2fe67f60227eda40fa31725081e7b763f6e5d2d54a1ba930dd3e5cad277c66b1e0b3cd62d2240cc6e7f2dd041beb74f0daa056b3ab9581ede8bcd0417d3471ba35335cf24469cd112bcbc0ec1742aba0254f53a1313f9f01ad87685d0afe6b43f8a143e4b168e485a23b32356ae0195532330a84924fd0ceae5da29842faed92a2d9201948ff722d3d062438a48d94287b9e5d2c25c821800728c0748d59cceec14995886229eb53e6d025bf5efcfbf92d04819006bd783a00308f64f849d84aa8f47fbc9148853c06f944fb336d5c2dca003f41c3c5818cc1bc7b6525a155fa2d29c2e6a1cb34fc3bd3f48e18b494b682d3bfa0176e37e121200d3466374f0babff2eb218fdb224ea1c49902d57ee4c2ca540be7ef03d3b26db302a52fe59d7495d52a35c5a696dd63a2ae51034dd8b77bb8d79ba7f822fa6b0ed2aa82b4f024ba3c665b7fa53ddbc2825875381fadf57f965e96e3fe9ee5b36fc832130cfeda92a0c46f88ea61052e54e7056a37f82c55223eecb42ec253d1eab64dbdb8d622d1783f1c674ee27b82989e087f7382e6747babe8755b11d8bc0cfe1dad1514a7ebe86ba7a8c97b59c2e91a450910af3f0165850a1ccfc1f69aa95b50a0370f69dd6d84156efd8ca82c564bb5a220341c82f56e707bb56e7652f53c0f74d4dc00a9300dc5b7380bc789e2be88f0970ffb0bd84d0c409827daf623928017e301351683b71e05483152a20962e985be1c3ecc0977b606a1928c1420fe9087c649690ae4affe9b5e6229d16550880565d0a01fb38fa39b0f5cb65c2985a748f42a1a88abaa3f2697436525964b724d5848b24d050c6e7dc27fc820802e6ac967d93a7a77f5fed34b70746ce352c5679fa317da788de20d9297a0105f86f332e85eabd74b92531465c8e263e2e788b0f41ea76be5468b2a72ff15ed20d85ff73425c24283ea5a655a1ad87bfe939b0f25e7ae672b29289350c72f677f0d2844aaa2066fdf1c31b5106831010e1406325be7c18c1d95b98718dce77dc76ef6da0ff40062fa6dd18b4ea40b1d18135b5135c3c93d4ee25a6f5bf0709d331e44d460ff0d24810ca622a17c2e7c08f4503f6f11f730405839e31fbfff9e5e10a8a2af69447877df2e1c2531487876c30d52f035356a2c733e53547d5c7415b6b53f6b62c57a1eabe2a3dd300aeb4274a40a0c0dcef8afa0a3885b1cd6b68c553065a9d65c36eeaff9008ecf777da8a4719619d00c33033cede2cd91c4101271371f2358e5c0ef31e15b69b86513106ce9d51499daab45e281d93f65cdc8afdc9a7899f589d79d2c257211320b3c2418a2d7bb124755e53cf4ca5167fef0c31349829d4c303a733230b2c0eb4f5bf82a6a7e2103137ab623f09c9b27f229ac1c58a14b76bbe9018bc53a9ffeeb57a73af1f0b9e1d221f634921a973cf2c78b207310549f3cf72307167e607d0f7d154d237a88efa5ed6ecad6064f3efda0b0e3e69b2810be4befb9586062605459bc76f7350d8dfcc445e026d5b8c8ede0fc568541a40c832bdb4f599d8bf8bdc924d4c9f5f4d892189a941bf758e88f3d582540ddca73882ff3bf1863effbce7b8dad92a37df12043d5b51b8f8e6471442f88558cac71c86f2eb597095d4ffe4264a6a4509bf46ce835861bc9206183acaa26ba59bf854043ba940e0ff3b60993669dfed428d65835c62d0b7d84f81ac31a7f1fa3256ac7a5170b9f2504f1d63dabff878d55d6f1f287e19848bdad704c312f36da497ad7812696aeefb46e439a42ce16ec3d1bdc7297fb9037c9a8ce0a5979fd8e3244ac136a106100e80be6e8f45ebc0793ca81ebb4498ef136a51138f5452cac2e97052013d7267f67e402310340f2a803a237faae9b565e83947f321549602c2fce97aa5c4ce71bbdee51e52f67e38c7135a18b1d92849d331c2524398bb3eca45342efdabf4fd859d9280a82a68b92919a5cf49192a5868df9158a3e65be5b054136f26da5c598e0ac5f634cee3a1dfe7d292dd27547f21f621bb1cc38fae71f99d319fd52d9bb98e55646da56089434c9db5b3eca85d98c6d160a1dc37b541b2026c535f82a1c12eb92e357c327c008c144b9dd3cc2fd3ac3f66aacb7d58acf3488e5d78102c706f6fce10c13f652944baa476b4f68ffe88053fa0cc7b9591266150c8196e4ef93da7a07c919e4c3063c17ac5ad2987c474cefd8fdc6a17dc006cb0b4fb7ab6ce0f1edb9985d96dc0f8dcc56e8d644cfd6d13f3074f32c1129c621abe968434af2737886d78e6b5ebfc163af0975a4a3aae7206d4d5e4a0b800381482a47955b69fbab54a08b3155062f1c5b00122347239d03066350c184fcac0c24b71b35d0fb19a6b129d4adfff99aaccdaba59744daed3a3b1eece114d1b295577c5f706c12c8c44517491e532858a2e24500d3681666678ef6459ecadc8c082d1c96b953a78a2b499913e9828bc53017857d990ba7cf829aab055e402da3200a17b7ef828d1e1be735f1244fbd9941b9a9f2a962ae83f6799506710a171147aef13453d59a8551100a6316c93b065ee64ac3d5be390be77e13120cba8c9d5db86aa590719e19b3d81b41bca3334522d09b03beb744f7208df565c6093ad1de747d32d840994cd814467b434863f113d6d0376c72953501189fd3e06dd25a9059ef7ef2c6d828a852c27858638acf88d7b1bd76cff01ea64eaa330e77f740fea3d17fd6dd6617c2f9b4282bebe1b016707ed16990aaf6e71c4c26444ab9d7368cc1a4cf07be1bf691ce85b26f45ba3ac939f98cacba317fb9395f4edeca48f4ad1600dae435e46ca8659c9369c8adb1e197c91663cd6cb43f3188ce5690f251a4872c5538d95e1690e530fd3f303cf6e1e5d8eb89a2e0af319f028177be70fa590f2f7fbf414568d0a24713629dace1c9f27f6e179b29676742fbd8189a9541b0b5e967663a94209ca0b1b7700d2bffaa45e09175fe5666d6294468acb610145252535e8abd73186683a22b749ba354100003cc71d8fbd2eb77db37149c01d727492aa0ba6632992f8f630eef338d9d58a192247618b7c3238b4d410bb7479c060f3ff10e5b2668b16867578992ccf28db0139f1b04e06f3f547b12304c4a2eb56c3a1471ad1e5cb1af9c6616592f3fe942c2951720afeba5fbf26a3e0c9a070ce35e34ac19463bfe82f988dd26b8b3a5681d183e0f24b2fbfbbb7dd496c62588a1b77cc01af8184873b8c13147fa44ad8aecfa89394426e9042268162023d247a0f24e53cf18982c5d4bfc3faad80b402a33d8f22af0371ca882951e1b7f2cd90123624dbd5a055486c91a300dbdb5f69f74e655f1450745d6bda4e0f8255edcf83e03bfdbe128d129f546fcde3864cd406c974a94d7742f119640e9f2948d3eb9eaaa7505c6e2d4b1072dc7719426e8f300cb1efd1d46513b4bef6c66d216fe5b687711b6d192ed732f5c6dcbb23c42a35a09f1ab7b1f2ba2158a0b692c2cb905e680ab425f91da13b63068f3f76e13714b6b268b15e9370124edd63083a6a40fc69ccd41f23752c414547b8b34c19ba075e15e3caa30400481e1df86ca80e8b1654c54e02ab1ec224d88ff0f37397b9987fbd990e37612c8e86576e4d245367141effed75190b407098d9cfcd8e646f070db727a347bc5b2a1a838817fdcbf38e3f81ab9af145d17ab4745ab819db38ff0fe1ac671277c67c926e2b77972eade3aaa18fc97f03d7fc9e4087dae735841d119f5b0a406e6287cdae1ea22ba05ee8a61cbab5ad86f5556b2835d333b69f8aba2014d392ce8aa8323329d665445e144c0d33f233cee6a855a0414b4035c9938bac16681952db2eeb234857adb2a9758be817ebb4362113b684885b54b50e9f8e4d55ec139fdf0799c369bb640eb1ad88ffd497630a90294cbee1702833d3fa4213ea1bf80454fb09a6db9cee9fffe5728460e31770dc32d008421c7a829174bed8869853063ae8b03915c4b190eeff8cbc8ed1e9d62f0919ffb1387e5fad183a436336138c01084b3094e1c6ead916e2c4e0ea38ec6184d7972c160cbf00e9473caf1699fb37c287a1760abe404ab3f16491bece564e3cdc6082d5d55ea784c5a138a1c3c374d9dc161029bb6f47970115d8a7fd1ed68f9e5f1a8a0fbf29542128c6df7120831c5086f2ee77f76c12686cccf57151cfcf7cad76600aaeb1061d7481fef5d2806f1630db64f43a9dcc517b9fef2795ca12c5739a8159950ab137cedb14e846b2861faa3f4d77284bc7c7701c98f815fe59f5462387064f0cf407db91777170cf3b954d442f5540132d071bb15665aaee76332ebb1886e834a77f12173edc6111f0511cd151062f1d7841764ff6b5e0cde6d6d0744d2de38879b517ca2fe56aed23964c5f9749ba12c3bb162396fdf3a8f21cedc3fd219a7a04ebc4e043d7ff4bc40344eda2c8ffc2a7cd6ef0bfa4cdde17a145a969589176c368a2cea763dfb5f5612642b622c0c6277ff133e96f96677c48510dc35a00f785ccbc6ed95f177e5665671432532cb506450843218a36bde4822ce731ae357c6c2ce5335940155cfe00c6828a28a1e06fb2b001305ad3f6afadd43560d2775fabc3097be19243ec6488057fd8987046dd8610880f597125dba0e72813d9be87256850b77544c0665d4ecf2da106676f4f90e86add82c0ce2c44fe4ef930c0dadeb3cb53e063beb469530c9be018cd5ac8e60f1b04ba6db2cfee58a2cc297decc046d8ab2692d476fea0fa4d16a7ef23c7d57fcdb9577bf9dc31bead605e81fea9315e08172691b15d0b8b1be3e5faf4b0c56d58429502d8246ec879b994caea79c1a951d51b4e50ea4596fa45dcfc8a0f3e355bdc25b27230e13bd86d01895c23155ab94dacec4c2fed2e37f08beac280c4f36e5a794f6160a59d229f25efea0504f8c8d66262265b9a469845a96d56d7c6bc3616852e2ed25481ce95337c766959b59fb9e86a1994e6008b517a885f75f6155ad081be767a62cdc970acb29ea0fc61672f48d4716e131377883d2ca0787076d576ed5785bf89e06ea73ea86f3e60bcfff1f94469057f0da37252c31c9ba3076b2f1224c57783495f45dd6b1891decc8d31c37bb554eefb20f99c77d720f69913f6cd29a8d271913388d2247d9b31905a2c6524e8bc8f66e49a2a76f043da726fba242095f75ff956448332f1eae3d0f1bb8fb5a88e575e2d6001752b67ffcc42c2a0bc6a5603b5445e5bb2323d69935a7bde656de1932ccea07c94a5521089300124521fbcc0fbdbb1b70c12798d5b697cd8ca8750ce22a6f78b6bdf517da22d39c9de42166a20286297284f364898077becb37250f41c655ede1db95844b0842022d6088308b03db52fc4b3bc46796d185c45448131837fc844a1a6f8609f157a371c3b65143150340ef5339cb24179e934d7889a08dd4a2722c364beb521229be2e6412c9c867b65a2f818ae886f7424c55ede0b414802fd6b913efbb17d7ac29aabd37dc33f05a79f4b99d37a7dfc543327868b0128caac1e1c3e7bca764ee6c3edfa889f56ae665f513190e9d31b8fc4a29419a01eed045f4b7605997800daa6b575dcc18337de98ba08d268c9f758a0fc7297c770cda4a58880fb92a52f6dfa33e2dc5bde2af9d1182a1a001594077ebc7b2391ce334dfb9404ed12f605ed729567f2666be2bb061f8fa684ce7f28316dce3d3ecc77db9391139f0c31a8550b083af69b15a01cb790f5bfa3e98f069cd68656d084afa8dab4b80056c1de4c9142d9cd8429d7fffd27e148a3939d361daf2038260eb4a4cdb8255b89ff3f35e58a21ea0a1a76728d17a351c3b6788e021b9f0a61a13f1ce0ff199b481b3bfa9f66296d637c3c55954b2e91b60007e03e897b741462d34143812274642ffe180508afe38f4884aead3118139813ff74c4dfd9a7e766ec76249c3a39d8525f163a2368b8e3fb8c56852b16ade639df057184face52202b13d40543daa1ab5923e38ecaf0ff533c11bd9b884ab03b9eb507029b6909648321b8a9e77ad47ba289a8160e29461fcdef1406e027cb667dc2bc71f96cce44edbf4666f5950a26d6734412e031b4d62ab6ffaf29a9f60cb11d25ca3ff1fc21b3c1af9d9caa4a9a0c3ce66168530f48084ca961655229a29875279abdc599c71e178e3405f01ed8f4177fd767e33cb39be26a13c4651e221d1079aadc38d3c1cfd5a63f2a8f1a6e0f42b35487068555dfd145ce7e1b4023a6e50ca329f0a3ec5eb2e8d7f63f831e2113bc1c38451b8c1c5433f9ba26a103c8325d54efb4c3dd0d2edec8afb7d4d2f47fab990bebde1bebb5a692408077479bc06c2e9c24b3f59e0648e01239fb20dd7bf8eb7fe81d063c42e70ae2cae609f03f2ddd186d0ee1c63d34c9cc1ef6504ea0c74c7b1b2e7c8796abf266ae30de2fd06707c20edca4d95b5c4402de5ab9daa54c56d29b9325053a9da178409128f809a85186e1e03693e5349eac379fcf95fca68d4d495571ff5f394ef18b14dc6f2cbbd2acc44e7e2a255a1148d35165c9bd65d1512ed65f65ac82474205b184bd1436f60b4a4b037624129977976186e4e307f33b15f2368be985b64d73947efaf7718e003fbf1b41e0ec4b79c31d46a7ce25ba54608a643a6227fd451d124b0e988657d2121447682aa4ea86326651b5afcb49623e0dca2cd1181f55012bf0272e9f2a35f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
