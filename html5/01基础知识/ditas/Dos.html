<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d81175fcd311ef31376218bb369bd543a5c633890b10afb252ad92e5988ef8dee0e9fd12f6a07ca69e804eb6db1225c596d03c5d7b278ad212f7e8a6f9757c16ccfe9a8e404ed1fda07ba96ef55f7445dcf482ac55190a463c966c25efaa3f2dd791a67e973980f12c495c995caf578c24a4f4dffe21dbac491e4911aea09b49bedafa6e4b47c2f726766495727db40798ad823881f0c1ba7a83f98e7138e4d7fecba658917f5d174e260d22fbb42c48c545361bd418b698fc4990f47d90e5721317f06990f7f905adbbd83d36dcbc31f044df26496b2ee289aab66e0df1136c86cb5241debda6840009985e472e2031dea9313a9b11d20218428201d30fcc4dcf83e33252911281f5b3988c4f2ad0002dc6b804ffe73fcd608bcb3274c332b5bd836d5b7f8e583517c126a2fa6b7332fc2ce1a84278a4b2761b383d07c044ee2b4ec4a1debc999c741963bdcd398a870cefa0574da10a4726967cd4d843f3f0ca39fc2936f3aa3287cc98a130c9eb8e3b413288690c43cfaef92fba2ba715cc41465363ed6280af7e4e685a84356ee39f6d530608d6b133e6d53baf826d2fd3527f4ab08e172084a8d33889dd91a97d3ae3c8ca1cd433712f68866b94fbf07f5fd64d5b754ee911e6f53afd39d9cac1e6b51c648e2c5b9aafdb976439d3e421ae3c51c276e0f586e82978ba1cf53dd7fb58141783a94420734b54a53abb2247415749a5051d709d23fd50be2b43510212a5f1f005a2ba8b2f2794923ae36b4022c7d538e48efad1b93c3c8250292dccb5afbb1d97817113ccbf4d76a9a5175c2be23c3f051fc67145953debc5ab0a3cc3089a03722dca4561fd77668bfa131d7ff63c68ca8be2bf9ae9067ec399120e57c970007404185d63599717cbfb8c2a340701d8d4cd3adfc7abd5c2abefdbac8a6efbcf7cb1980ec45e654ddcf579847c4766c0f65596ff5c4ccea28e7f4595c5a13ac1f30edd0fe753581f52dd33e85ee6ccdbea78ce3d457cefee4ce48e4b7fd0bdb6da71428be651bcf159354649f000478cfa8948f924f99ab19aae70840852426847a6d8ba86dfc8d40d408f83e7732bce83d865032ea15e3f93a1cd9be73b3bae5ad27752657a996d2865db756e053b4c74fae8f3cda7bd3f46ad31b5c25f41faacfe8321a65074770ed4cec2ebb775496f03f13199e2bad354cc0177ff60e8b039f240bb7f5d59247db9ff0a805eb902455a586c10323fd7d7e12be1c24c3933f87f80efac5f9026f2b11ed7c0a62e24c43fd43f209f3767df900be96631c6cf9e1c31f1043bb639998b42c710a6dc176865b691a7c9056cef9fb92d02d9876323ace3dea9599d9ff4dd5aaeb79c6cc1fb9399fc4742efb2597f4154d9bec72dbe1dba7a463c7379c9a795812759661944975ae3a83379de104a1449ae9e95d942fa313f32cddcec5bac5edacb5fcd23dd22993608312c5ea52faad2575b8bc878b49c9ae6493557b8d35a99c1b6f318fae7d2f46878613b84807f54981e7e4e330320000e05545c07752bbcdb8cec6d4fa48203139347b59bac0bf9bae9927196bb4a693d50869bc7c2ca414a6e6f6772d6e87731ce2b4e38bf97c032d400add3984a1752602155fe0a147efe62a878ea5aba7b26fc9bfec3e776e61e34d88db1b64bd5781c84b760fdd4f4b5659b841d6fb772759238fd038c4dacdab50227ad0f07fa5871a15daec37508647bed0441aa43687f4e11709c2c4821a34f1d1908f588e6e625e212ab46774d6954b5ce2a55d5b9f335d6e573ed0eaf83afdbe356e08c70a8c2a52d1db00b085c3d6b1e15799bcdbe358a52b3eb7c2e0d939a4134375ec371d544d137278787147d84c031e130e677f5f5fbb3b30d7106f07f4fb5c2cb798c7e3213ab3753b75cb46e65138ac8e585d4a4f7f141e4a2f7f3cd650361bf19c43bf2f07e058a1df36a7355f6fcabc34b9fe815490c44640651978b31dfbb2ff3a937de15eafd06f9686971559f11489c3459e7aa346a2241fed8b3e4996d8f399fe94084b852949db922801c2d383a61acb2d6b68ca29bcfeba5f128c2b5bf908d9262279ddc883a3adc5961b037a938b5f1628757ee761e786d8d00c9486fe74e4ad6d6df7ca346b32b7fd090f4f25b6c85d4569335e3ca1c8f944b083c288677fefa5cb0ac1955d6e333fdcbe0f621631aba7999f62eb8aedd0009e95ab15a91dc4b41dc01c01a13f4c9fef23882af1f8d7559ed77aa21dd240cb5c5dd62383a06357ad24a3e0623feb4d561fd36f3d90f3ef737fd8b715bc074df480e2e746eeaf7764f3581ed36dd0fd6951708b45770e20fac2e47d94bf91bcf374b58224f25492669ee88ed4ae3a2ea53e64104fa5af307ae727e42f4ab31c1608009bd27ec3d3cd283683f7bf642eeb86002d838291e2cba36695ef3ee4e9d7a90c4eb7b462e09c7d102c69a84f564a56a45317c0f8991355fc7ca3e1ff39a97a8d93267aecf083896e1345845a3a4a1f5937a02dbdb346e061b2e5749923ffe7d1671f1d5b60ae118a3b8ffd92710210d64c9a0abc23af106a6436aa5b6571309de471789f95f9cad09e9a52bb0519b5d5e381f745209e64a112bfdca76f0551ffb3f89c575e0088f6e157a165fe7789ae0541cfafe55a5a3d7f54696bcb1923f7fb5184814a3226affd8bce4e0e5acf0e63ec8557af3213bf748f9b86100df8fd59a660509dbb0c4d075905ebae88b31900b7fedf56f744c76f837c8e2a5a61ef792fd2c428479e678c818b21eb97a4c3d341f7e67c31c3f10f0e0fb99fd5213def1cdfe17788a99b81ffa23b710cd1de7abde47617aff682b0b80ea3e26c4119a0a4f2f3d68c8e72b106ca5eeab4376355086956f8f10ee34e77a7c6f27e91e78c9f63f353e39c0aa8be400f5091d11ff1d5a34375249e99ab5d968627bced3243154815138584caf3ad59f0b3ce7e9ff046f0cedc8d2f575dcba23374db9a6213882113f92382a0ebd21c3e41cac309863d1f96335b7f336259375b57cab50200957aafdcf3495cb5d1b23d589b2b4b738a28c82a1f437d1b6a8f3e4d5fded32e8bfaf71a7223dad2c77e91f5b85af947f11b4632e61e70d27b551ee050bc8629447565731d2b5ef818e4a6d66d514ed0e0423b81e36ecb8ae6159d4dec70fc06f14cefd2dc54cd1bad4834678cec68139e175861d2e908aea64daec019ea377b3e70737c208cb9e06e70d6d63ff658b1e77b91864fc1dfdcaa2ee00f4551d1eb16c73ef8e2dd9df3761dfa5712af84aeef7a9fbb3487fd4f2684b30ee48f555b217f23a36e2bea256a0fbb7c0f33e7abf991958bc5b3bbeeea03183215c98655a58f764cb49c41635b357976f5d38ae2a2e8022b38b2509bc97ce7b44b6a563d26ae21a2fb1a09e51f9e974c1ddba2fbb2e2ba21d38208b03bda01c4a25a926ad27908993a9825f8d229ad4057cff9ea2cb33d08a8011a202cff5a0c194cd90e99da2c393ab54b0e162e1a49dd35f6e7af260dcca7e9521ace4015301be3eb0e4153db60897069907787d40797204cfbaf63a7666dc45372e5cc639efd9d4ecbb130cdd5494fa6b9f884f86a17533621376db3eaab98c74790126c889ccde028ec090279845bfb9667e994540a33d4d738550d5d8f253c7ab5ae3312271738ce22665de4c62cd0bf3b13cc2830afd857eeda2808008f84e5a07ae852501493a46c998f37b742f460ffed890900ce17fb7314f5e6de03200d8784dcf48f5d7c3345c8a5dff50dfcb506bef85e61479d9c0ad04b17d4765a09762fa61031cc4e68edc4c8bacd192ee153fcd566642553cc86b1a541388143bab8b3d9c80e5b0133bcac3f8819b980eea932533072b5c5aa2864b94a863dd2b802a2d9ca8859cd842de3db2ca7f895cd5945627e0f4e8875cef75a8793e9fe70dd51e8aa3f849ad397c30c5937e0e4bd083fe20e50db91aa4454745c5715d4658e57f5b92b3691f8aa7ebbb70f5db65d452c69442e16a48eb6a3ae36a2d62cc177ebccdbdcd9a8e4dda8b247622076a27056d2628be3e035427ddacf018aa2ea9d966c5733eb9aded1e90d1818ba8a09e35f853da54fc9173cfa2017bce90f30429fbdea19a2344ff766e13c5c0969b72c18a8477b26b062d840ecfee62b69ce4d58bf34cfcca0c1c85d138d0bc09b00a7e77ecb77b39e85b6d20498b7fe330b61c28bda6d9fc565f593c876750cf835ec28920788f028281f33857af7daa1a41a181f66e9b48dc0f66694181f1558066260182298c810880ad53ff7e4653dd9f0295fd068c9662685d6d692650a7433e2a5d1083c233b8eecb81805b02dfcdfb1533629bbe850dfd1a2a4d621a2a94cc0d42ab7edc3fe38f04573800975e7766649b8d67599590d30314f6edbe2ec2950d309bff8dd964debfa2ae360576edb87268a878a01e4b27c6696205eb3c37bc49cbe5bee03f1596de758be7cf38e45773481c54fc5b4a7aef632599f0823bc53b6184392d2f0d7931962885970322837b5267978cf8c2e1b6caa845ad87d71ad4b73e25af5500eac4910d8cbd24b0f59f842ace8494eb4d354552cceeacaf7b9d9e569ea4438365921a2f0dcc60daf7e3ae22a275a0a37a97625c7eaaaf26faf93f6e2ea10b6be287b29f3a743bc4b60eef84b86f3e614a849beaf6d748a7615ce70e93024ea4c8331133f55b2ae9bdcbfd8641326fefc8f959e81e347921c6b6feb8043f1cff42dc9d33d3ff98d9723b62cb8f722e6e06632dcbc7bc3609f451c35f9eb51439064e99ce8a3056295e7b0a3874faac70cfc6dc7a2cd9768f554798ea18e930eccb9011a26c50495707d41011f2795ab790cff41c869ca611e74a19ffbebc857fb59533c80c6b1cc1c66ddcccb36ca432e821d006e388e08681dfd654776d71824f75b88ffb125f483070a7fb68f0bdc93ad1ea508887c8267631897e309f9699d8157c77f4632c948d16b9c09475c7ab07be2cc2b83057cc668567fa31f2964054a921a47061ef6607d0f711b35a099e949c2b8f764d47840b508dde4e20576cd00f8eb3595d24d6470929ed89eb71809f7f239755289e5ac950bb80a9bbafb708e344dbea3224247128a07889d757955963432654be9ef9ed357871be55f6927a8a4bb812d5112b79f3e6d67beaaecb719f360108f369415b407838a19f611ac2efe979783233a6474fdaa3eaed17fc3a0b9abb17fa57e6e19ca6b9071f2ca1ddabe55d65f42ed2104d96469d9f95c5d11c61479c57991fa76497ae7c6ac7e2271cb044cbec64ba16b11cb6b47d71e88e6dedd7ecd0bc28c43e41bf4c5b84f19431e0ece22695d0ea1a9d3f6538840c58415b92ce8f5af0efb3d8b799cf7a50bdd92c58b9fa847afb4fe86dfeb2440093371b0bc63d3ac35ee39360d103b633b5c835983412639162bcd95d9ec98ea1df188057c7f211a22aa839254817c2f4afed669b6042c20a2d0620223d20d3beade4128e1a07d0b75d932383717af7500bc1a58dd49b151bab5d30505c9f79b6cc22eef2874c1ba72d0e85e7c69a30f974263a1e2fa2f0ec471ca144f7f2284e670619144722c8d889f6a32eda56a5e7f527e6680d3c6db3676136b43f0f99f9189cc1cdf24a17d5f295c9e2b4b47af2ba32b3c087fe105e3509b0904b0eef0350135c1acad6e6e435f816bd0e4bb38f560cb5a082f31101492665c788a43c8e193bc23a7c87b154726775bfbaf0a2444b312a84252a2a58103ad656bc6539858cd4310a141b4a17334cb38ecb570dfcef3c775a68b8d278060e4cb0c37ba471d78479556f78aa2a91ac54bbd5bdd33c14f4b800dc026918c12ed1b2d2d7ddf5271f4e6faa29abaa7eb89df4e7c58e2168c762d600e8ea91a12e185d1ffc4d2b8484a488c64ed9150f5980d15ef55426c3bd4507bbca455a96e174daf34045568f3b2082f919651648f856ba14d063b97491603d34797fabadf470bf83cdfc76103c7ca72a4220863194e0431c8890c71e542f9b90859320b29b016e1324808a34dea71a5c6d801ade66db068a182e8fd88792359b3b5df7816cc17f5e34e11938aadc82d7cf746659f68b905e43c8d1f30448e921408c92e057333ce77ad9e5b50506f0374164ddf90c63a64e8d4364ee73c77ff3cdf838f8fe8a1d8f611c76f95ef6e56f936c215c4340b97011c374e055267938094db9098b5e4afa20dc933a4e15724daa3e9485d19e50fc85e11244cb85634b29cfc8a3505f2df87b74e3a679813d7c5edcb116252923cde45575cabd75e6be93359ac5e00bd57083a9ea23a554bec6439cb1f6cfac353c12bb4ba37986f17f3da25958801ef48f33f04f42e1e544854578a6424b377e307edb7f063f6754002f7952350d536bad9b776bfa7e13ec25e009ab26c542a27619f87e43b6d66789450b9dad3877abad24ee9c31e55a8ee2fed1a7d368728c5c9e96e53f73e55feff08073c7fa93897f2c483e8173a69b774bf18b3df9eb07065d64f9dbe729d1b982ab70b241bfc05a49f894ae0bdc061f0254138ffafb397c1c9855105679454aa77366a3b4fa672503f296d7b57eb23c078b9e48c90276d197511c9bcd4706cd44e2583222d5805a82b82e9115a061e44c8eb1d622a5fb5c592bfc3ed465074e4477e33545b9725eb146bf3e18355e241e783f96b4d2b06ae840976bda4a43920876ecb1f26f169e38a6cb74c813d979ab1571c8b8d723c294694b1e996081097adde0deec7d9efaac93d194689de30d53b3637442195e3d81753628ae09fad909bb646299b48fe04332cc1476f5a2bc596a0ba2295225d886d2658fbabd6a4c422da5272d62483b6f8ffe8c73b469455d82100f3e7cc9844ef16d3f2307a957977057e79b18fd152f1a2035a058cab09aa2dac93110c24cb3228c1967ba56b5be1124d1a551a9610335cc8717842184911958ea1bfe9fb0ac7c7305a66e97447108d64a2c088d33c9aa870e05c4499b5ccf79196087b3b91cdf1fdee68159378f62b612abd5027a3e4cad725b6015566fcee10b3f87f5ab860118d31e73efe3128e53a58c9f721b218422ecc8394d73009b347669e35e935fabe3ac2b27f191ca911a481b0140ff3e280a4558a1e5d7da54fa861c6e9ac98bd458e1743561a0e9cc8994e279ff645f09cf1e7c1a751f36fa05c9988a6cbab6327eb4f13c4828cce2dbaf6be89ec3a0ca3d57c1f144ceda210f04a460ddc69ea8923878433c5cfbd912e196b3aa4d8d60679b55db69cf753fbc2fe8340d374d9cb04be88c6ba75acaf6cec2591b945c00da590c36bb73e5632b1aab52bd8d0cf6f2ddc0ad39eff2fa522ea2d3d8626fafcedcca9541ff21cb48c81b62487156395b27f5f6e4f0c59e38bfc0a2f76c5fd59f6505b4ddf3d3595aa2af55117cfd81421420bac4ab689949aab01bf9657889e81c3ff3f8e13a226ec8c445e2ed8396ba7f63b3a8b30afa005f9f9af81ba420e509f42f9dcf025381a77a69f8952b05e4b5b5bc58584a0152f92e9ace896fadee9a2de21171f43b9a08d7d15b8e1ce0fba33c3e59cdf426c6d5557a949018f09126da2ad090bf856adb94f9f74e0a3bf2c9be74f627b4a433e5e659a35c44298e54402b1760513f578d9cd69b318ee93a5d541eddc6bb478cb39f0ce597bb5951157b8fef64ba4a592ccfc4fd41528506a02d84b2581731770798f44ffddab7be70bb08e4bea4eaf3fb1e6c5e3ced7cbb5d0199a1a0636bec0137e0d99a284021cddbe9aa016ffdc33ba864c95841933b2c02cbf5ac81a2227a1531034b89666bd57614bf26088ae43474d7e24ea285d2c95aa53120606157f4c0921b022c34a146635d8d0a909c30d5db07e350ffffdd4f92a1efebaf170af69aa9ef25496fcf2f23629ad87519fe4f6950b0d3892fd58762e94961d0e4c418be93df720d16635315c04ac8763439730cc2a6c6e4490c67e1757fbffd48511e306714fe438e74e378fbb4aeace21b7cc4f7c33add4458b66e6c28f8f727050fc99b4cd0fc36fbb662101edb71b4af9bb1da207f534bfc30679a8c4c43797cca58e60e5bde9958af630557990064c639cab821fe6d582e34fffb0b67b692d09fb2dc492156a27c05d2fb0faf6334fe60dc24ae3bc7fa0483781dbe96282d489e6f9a0f8d700701bef9653bf902235fcc2603475ef7bfd2c2afd8bf1f08bd97a59bbc9e7c573c71d1a9031c96aed722d53a190d8047f094d30c705f681a1fa16500c6c54ddee9443b9cd66e6deddbccd104bdf6df398c61bc82ae61cba3de955b09d379082ef372fb7df7c9c3e81be72dfb6c4b3ed5b292804c199661755d6e6705a7dac6b7aab39ce09a7202995ad1453952146a7bde3bb3c7d2e414d1714249a31ddbece71605ec8e90f37e3965d8836afd3912addf96890bf9a0e60b4f1440caec97c0942d2777298609ddc94956d288597e43f8b243966545d59f3bf9a47cb7d8b76df60ed55d0f4370a389fd5fac8d3601278ca9fd0438d1d68625fadabf6ee9458b036cedca13ba777f4000ad8cb1860bfb3632d6540ff04adc2f29e37a25db9f6411439f32b344d1a83f9aadf7570ca1ebb6860412e094102e17d611d8634f6a5dffc96b8b0735803a4d5d7bb015d437e816a922023313719282449b9299de20227e6b1ff0b56caf2f6faaa94c1b4727282eb10c68078bbaf801f461dc7d7c0b300af71f5cf4ae1a50b704edf3a3d568f297d2dd1ce9fecd7d5e21e4d54ea1775a4d04eb177b3bf45f95f66bec95e17b3dcffe715ab34cdaeaf82aca8f3b5f25cf24394b4558c4d9381b1264aa7dd8a62485dccec03746088f5a1321bb655ff8397c21fd24c5a11d859012eb74421eaa1580e945b230697fa713edf9964dc860096a0021a95144337c11ac43d0908af7f2701bae7b5bf7c2e5668aa3cc9a04298840478e8480de99860817f97b6beadefd8579800a4a7d5461e77ccfc66b772fd812303cdf48f0394e31a803016876ef62f59b3d1ce235713a268bc85399ce7960f6a7d535c35cf5aedae289ddafb37de5a1eb4d1f5b973427dcffaf8de4ce8a4b7b0dc4451efbbc6e07d5b8f376dc6e69602f7eec181df4ab35992ac4fcf9f259f633f581dddc6be2b1542d46ea1d617a7cb84c11ab9f0ca622234d2151e54f4f991087bcbf12885476e2fcb291e6b3f8438c61317297f83dcd1df3800dfacc9581b96b44042b4c932fac9c377863a5c1e8df2a1daf0301c14f0b1d70c22e2f9d2402f9d6f6c3b4ec273977f3c278b253d738a9dde62bad6cac76a9a3f59dcf2861e4f7b9ec8975694fd1e4bcf8187092d83e8733e9bc0bfd5046294185f50b114da3e3ca1e866c8adcb53004a750b99a718a0d9f9a57fe67865de41a6a1c0caefee2abf9862e77f56bfb7c366f296927921e55c16a89f980628fa41458f91ca78296b792580951d7768b7e4a0397d7cc710c927ff8141c3e89df553997b7d7e8a5d2e0986e31c6c1400dbae8f087cb4047cdbfcd3060f9c521b136ce2aac49a6f4d3ec5517b41c481c4501dd5d4884505a96093b4330c2f737c3957f9b2cf1ef61ab63deb038c52de1e28b8ce60c066eebe7e8b788aab133990a43036bbf94a5a22860b8e7bbf3665435d970db5a334876d29dbe51cef2c9dc9e518166893be92b00e266942a2dfca122486cb1946a6dfffb2baa332f103cd82116c80a32a6289fd034e038738976b21cb00a596c46ededfb327aa2e0fe3b7f98e57ec93dcc79f602422699725a7b010d17c1aa1f52f8cd2b15a34869ce5b76916616ca9c1bc93d022760b1cef8aa0e7fe969ea965c4a6ae102998257c4043db9f223b41793316c5885cc8f9eb69b16aecd0f36afcd2b53f2c590a72151835180cccd43b1edd643f5887708671d35dea8e52078cc851a5a4a0af7a39094485ec243d759359a9f7f84dbd7ca809b34e37a5120061d9f23e9f9b9c19a96fb8745298f11a98028e86030094bbef7c946c697c921726aa48b63b18eba46e98806b753851029320aecc7ae23c0709585690f6f8f765df20a4fac3d45146cbb59e5e7f33a028ac4073e9de51fb29a7106a9f67379bdf914b5332a8bbb650ac0d11c3a49748a1c92f588ed3b13ef57b972f60f1a241e88525ad4b72af3a6e6d22384032c387fabbf3c16c6699f349e202d5e332a27291b68a6a983b3bc1545b3ec71382c178a90c1293f56ab8ea5cfda56e8fd9b2f224fadeebc39fc3c6fca90410c4fdb343fd2283fcf9c551ff8fdd865a5237cd0d13e62e1b8ada74162092893d17b7ff77a7f213b236bbfe72255eec6991a7d5ab57018c9ecc5a13f30b7d28aac05e888a1a813e7e567355b7d85ddd3aac88f9dadfbef7f44f677a6a53ba32109aab1e3d1eb1157d716e2b8bfe3acc5440c3e3ea69be1a940370cd42b45559a0179fe0c80b2634c77db98667aaa3f210b9267c840fef89f463ae8bd9f709a87ace7f952dd3b61f54ea7b2c91ad484e86d93adba9b70edc71395d078c7349f817a4f07ba4d0e9b52332fdcc430a7d66f5f5c29321c7fef5e8edd667eccc2d340834457ecfcdee1ea143c8409fcd79882402b8bed584bf9bfd02fd3b5f89758e80d00ab30f9e31b5888dd479953c3f3f48558d58e010c4422dd0d572edba9b7950a51f2a4441e73497b64a89747fb52ce31b2d0230a05764dcd266cf4151fb29639c5455102c9bd992780742998e25b5078021a3f6e81c6cd2c0b5cf777cd91c1eff25eddad9106dc0cf163e208b32ab3e40459e68347acd218a3c4e7d84ff339352928750545a7fa556fba3b212b8bd320b60fa46338e9a874888043de05f8c3f0815fdcd49050ee67cfa68ae0357628ba2aa752127e2ffe5466fd9b2ae5fdb2a8124c34bfdf459d853c316fa3bd890fce5214b0e1b432ea88e31853d00768e2cb1097cc7aaf346e1c9a0d3343527f2d8f3aa7aeadac33fe668d20c7cf0d7ff9788d798b3544a3bb9d1ad2db113a8739190570951e119cada75437abd92085d7b317095fc1c0a113b1052541c4f949eccc4f51c561e93f7cc3f52411aae01d642182102259835751bfaa7dede1120fb0d88caf9bd47ce423dc68852e798751cf31c4e7cdffe16d4cb6388af2f3111400f6adcaeca3f8b4ec19b929ca69fb5db93a87ae1ee44a471f8a0424f834856f74be6158cee7d76db1b2c9a32b0c511015588d0e988922076ba7aa1d23fbed8002abd391d2655a7f22550adf528c7e191f86a220a3523073b7cfa6ce047922fe2ea7d03c0511e76e055b229a64d6d697bc2e336720f3bf24e6dd870df0973ced3708218d892b18fe1f0b07ab0d33011530a36162bd29212a6d9b1059b56f96c5ca01d32c8927a770ee637f14aea64f3a1dbc32a3f3664fb2db585df14b33a206aaf907a1189481f4ca30b285e886970d8e90af7dba951db7c8aad2930b9cc79b615d63c0f6dd75b4a83fb4cc3e8f0e60ef883d01af2444ba45d62b055515d844b134cadd55103579269869794ded73bafd13812f06b02ea6b443759e7f3d3535a15a2ac7586766bfa03c3551f804408d998a2538573ce7214eb2c6796cc07f3196f84c1b1be1df8a14512ea642dc22bf4e864f3a3bd5752621b57b73f686c51a9a12aefe3b0bec7ccf0f1a364c18e573cdff5d59f1697844aa009f5cec49e871f3879a75fdd15c9c4a94b5b9298548dc723c63ec7d7deeca7e825ee2f083adab0c4bb80d44678d394f01498ac7e472b8dce20a41972eadee9782bdb1765f285af6a888b3d74a4bca089f8e62363e47e6a3c8f137822c4eb6bd203f56a0363bde73cbdef45c0da28acfd4bad4e41d1029e07c5691e389414799b891716215e0cf98787ae17fa586b3ce003b03ea06d01db54a8b9b9cb1d05f159b699ba2ccaf9148a80f6a79621f4abbfd6969c24468a55fa53786f16f5a43f2de40007a0248238bfaf3519cb99cfab275da91a2916a181963a6ec2ad45e3a4378d9b03772cdc44ffc7e1f92e5bf64e497a58e4ecef5b0ec76c06f1e9e61fcc8a409aded3f4cde3b2a8f0acf0c8b7d6e4da4b93f73e9d3d598c17378ee557da4e96f0ddc1d7ec75783cd1ee06d45d69370d7c808426d87b9ca63fbd5220d37ba6e8854e2b2400124410d6349b6c0e099e2951f71c391dbcddfeb5a7b37108ea1b53b8fb30a37f375fb032e9982642eaa03d016c46508e91ae5c1d23b1cc2c26fd4af6b3f4bf2c7218029ac34892cb7a7f6963391731b333ce25c1810611110c54272c3592a1306dc6e1ecaa2896adf6e46e5255e1f71e6ee45e6c597db1322ace400e411cab9c0d38d0cf5d7be92fa6083b75276921cdce635aa3379f188fc8239985a2021ce41033c83afd73deaabbf55a860199909eff2b72242bb06350800fd8c1479cb44c4fbd6b4bad402951f8558eb40ebf62eb6ff54af63a2183afeb57f3065f374ec024567e54164500620ec11c6ea840b99a153ace312531ca52e542f5fe8b9cb72748d73f25f9d5eff9f8503c37007ec0db2b0b3e8c7f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
