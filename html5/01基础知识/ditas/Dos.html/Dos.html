<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3eb923fd0f91b8159e073010db6e43a13506b615049e62bd2b4a43ff519a0acbffe7874ddcbd558733271de33067b84e728752609c82be80ae5fbde3bcd96c728aba966b970e35a2e73b46c8918cf0896469c9d2871fd35040c13819d3a9194cd9f34964ea31126227e592c6b5295bd393fe52192a45b69e98978b17d873c3ebea3026b3e854ce095c44d891b81cb3512abfa585a08d9433509e7ecef238586d94e3914a1e5a6daff872c2969bc6cae0b7daf2684b9d657c27379703036ee6ff5993b8d107cfbc30d492c155ee9536ae7a1c25c79cac5dcce4c6b902ce065d31525c65efca22412731002bf1e284ed0423e14356a016a815190591e453bf58372117a552a246fbbbfa5da7fa8b2d2666f98298b7dc5b910a2a092191ea012cc118e57c3af256b54dfc95f166c9536472db87b75a775cb2e6fe2745c5d2d6e3cca62b9160c36c116eb1fce2345e5ef393a0c8af841b7ad6fbcbd4aa2fe6c8986eb9220aca30bb82a795816c604ffad19a529691f6d7560996b4de541dc8043dafd5a09d042874ab07240718cc5b7b6e3d6e684f79177f5e6898c0c5a6e23a7f4c5e31cf8824228717509bd69bb0d37c289e48f69335f3f15cc0a970398edb00298a8a6fcbc714b80a8b2526fa8222a10bd7164276dec6d888aa32922304a6718477bc04de87bb89e29a52db698a91208e553dd32259249bdd62e6ea0dbbc73f02cb62eee92f0400510ab6b01c0dfd17857b10cdffe84dafc28ec076e3d7bd80163023e6fd90e44722a43f299d2e81de8bb61eabb89030d1c9d7e410fa08c6119a6e10c94698aa65d90f683fe36853909c4a94168c1689ca30ab92312c336bf319fd20f9d3c76c59b71aabace3e5aea8330ebedd2b8f57330a6a1135ebec1e071cc6e3813fe8907d261bea891eb389d3a9a590a560efe8c9cdc8bf4034fd68e206d87b09e9027d399b09536f1ff7d07e3809d828eb95f9dd326a57461072891661d8808ac0dfeeb8dd595c129b455c7375250af18d35579c828234dc49a1da9fb12b4129c05f367ada493d803fa764b6a94ece74a72bd9677287f15e87250705e15351a3b52c3fe157c75c90bca1cc9d9c74de4ee4364dd087d1e0c3fd76c1441746f64ff228686949bae709c8b319a2ef5e77c9f4cce5271247965b5ba5b8ead8f01257b31d91589388b9b6222e987f5700a8c461ad617f464c605dd7f5896964b1ee4bd946336936edfc94d3df0fcc9586581250d96da44dee5f2af90d60557614289547a8fd528b4fcc9b44237190e48b988d96d079a9f4b9e5b543e5bbb74ac99b6a1fcfa2d8603816178c5084dc260228b5d0d3b35a892ac11bbba331ba3b6d1f6698f4294202d2cf4f2da5aaf3a5a0e67a16ee159b7c4d8078ead252d0b616323d1dfaf11f75086e2989657e223c5ae7b91ffe141e19d6c0a8e0b6cdc96a569e2bbcb3b4f1a80f9f29b48ae9d7accd3cb1a17b4471139438c49e919ef35d9e6db31a8ccfafd53f34311da0832229e227a17d3a2c86ce11a8a2a0baef7a8a7c65d8135530aacb9af0df6b7047df0c8fe2f86e6cd5305e8557b3c563347658ed720d56fe8c776d8601410252a227f6ea95da16cd56c0fefcd4274d98db1a1310d4553144d817379570dbef749a430f231342b121ad167dd86678882351b9a71f8f2a853ec07901cc617a6e1780131ce9a85a6654b11911349cab1abc5b899c4bdcccdb31f110ff8aaa28d4ad29000adc0599c944976a0127c6c7a59d286e425c033fcb0bb5934a335e943ae56908b01357ee0c22e00224754f4172314f3031aeef475c24c5d54d75a358fe8106466d65b0e952e6051d8f7a560e428760d0be190ba6147f4812420963337a0f705c3f7b74719474e4001c3953905d35df2809b0188fd654845010f6cab5b42e21892679e8e117f633bc25ab091c3bb1dee09a7e8a6c6656f14a1001cacb66f2c4565e241e0650a3ff4b57fbaa23d741484d6c9b2040d51e209940840bfaac2d3cd8c9751f87bea73e790b4eb732c1d402aa50def5828312fa3611b0c903ec3b1504786c08ff5347eb1d81a914c2beeccefc2c2871df1bd9a369dd681bed8bdc67a371d392aa960745b20d59f7d52ed30fc349b79c7ba2597e3f027684bef7aebf9b8e94ae57308beb420de7b2137d326c90dead6214b0c8151051df9fa5a8d06e26c61194db06cc6aaf1f238247ce06e9eb5a8aeeba4273765dfc43e50503e0c821356ecbb39a83e24db538da1ae30fc036ada1a57607ad4b79709711f076ec18e8d853dc0becd9ce2046415f67517645ca98aec07c18641cb6ae77fa7ee14e0115f37b44578fe03f73db0ba0fdaf5a9bc2cdabacb93804a170730c02bc9d15260878a6774a183ec77f2357cb1d021b3320dde7daec0e2b91077877f9ffaf9d01a31cef06a838553e8d846313f6999f48adc441e10dcc72e839b3f956848f26979576fe7c32ce970233a3319b553f0a6c7dcd7eacec7c693f6988f17859cb44cd1f30c8571c285553b448796804b4ea6f485d935a967e2f7863572f19105dbdbe05c9f505cce3734b5ed14e81fc6d6815227e0e6b98df0d6b8ce4cb875852f15258fd25751e681570847e5eb8a4ba3dd878ff89599aec485837beb2aad9d8497b7fb47a6cce319d0b94f25deed683063743dc0cf99ac749b76fc104fb3e3662a0556eb5b11e608db4686a2eddd364847d222160bebcae6b68f7dc3a3c5fdddbf0fa2cf62593bb9675ae54ce80faa86fa7c99e2d0291f5a77b94d60e284025bdfffb0bf9142e885ca0b719dcf0d898a2f84b070429756cb9a4600d08d6001ddc01bdd74febdb33095c83e062dd904459ab92af6f0435b8263bada0e6558863ace3ceda753d0522789cd1428b815cdbb79a1e8b4b7a20b429563e1cc5029e9289b501cbf037e043a98e3f849952e9d28ab2395da7ff69ff468e3ca26bcc15019d67d912d3572aac57801d26aefff4d18c446b5423f8f63e234fe3cc8cb44778776eeff262843689b1a79a9c05a797f5047ebda957e41d274d2d0d78e329f36d7f2a7852bfcab99607e03f412fdab1bfaa11b280568bd26f4a9946bc491ff740fb34ac8591578d5dd21d685d32499b42cd1f06b976069c120ca4ddec3405dc3f1598233792fc09a8ca74c4875210a3511072ac1b7f9dd813de1e3df25ddeb3619bbcee70e5dbaede3dc36b43744dc74b6014de2883be110c02c2ebb8d8bb1abde2e667d7c2caa4a2a629b1493a36390d71dcaa160824ea25476142955ee3c4c9a6ae691714626c25b99e2d4820974f50593a1f97e0528938225cb4c1360b7ff404fc2c7a79804de3fc836d31798b16613808667ca0f59f27b19d119b0df3738f45cb16049151818a8b57fc572facecd5709cfc71da1d8e698b61af3f728ca8ac68a5207b93b3a4bf98b6707f0cd23db17b24156e29255c6b0cb1d76f738ab0b25fc0403db3c84c738cfc0cbc2ee7635fdbf01ecc41ab492b4a781133dc0615b87363edc7bef35ce146006151d72cbb4fdb8bce4018645b2f9840dfed2f8cc3674589708c12dae318e0958041ea9e09bebae3fcb98384030b09cf70960c41a7ff49798f202e60b451e1ddc5941ab70f82bf01b4bf6af839716ec4f7d4b443ed4c14e1ca76e44d4dc21c160a6a2edf05398fd45f2af45613d895965c77125b6abea952196cc7e50b211e017708babd9405a971e9cbda753ae463dc595b4a13e9fa5bbec5933dcb1a142c363f47755352bec2e0731c9e3795a9f20e139189e18d982fd4eaa75ce7a6e5ec19a4dfc4dcf2e74f77c6bbff347be62d89a6d34e98219097320532a2a9a31528cb2e232ee208e1b766ea04ab3d23402e2d3eadecad7945ded1fefcf7dda00b7fa2a978a453aea950cbbd6875b43f31ac1cb2f828470eb9ab0d628f10e804cd1ebf572f1c55cb049b5badcf95078688ab6b51b0844aab3490e7832afaeba07247d6e05e08f028215fd26344e5f570e65660b58d150c30b3d6145efb89684f21e1ed077ab8a7cfdbfebd55280d99f3da24d425b65fd81c3da284303c0e9a99c840b222caf676b768e2a869105c25a487521f2483ca0da92eb516b66fac54d237f8b787bbe38fe11e55f8e0d4176e0ef153112455e5725b5eea03eee4ebf360ba82b5dac914268f40c995c824b693ac17b706f05e760484bbf30b750fd36e13771b87e8c4cd633923c8ca9475d071560a55cda371640b935cfaf47ee6ddd40a741e64bf88aa11e51a6499a38025663694810a15c1c7ecb0ffee0ecf6959f72c38abcbd9cd27e967e8357761d56e5cc6f3504174ebbe9b5ef298ab484a05fbc43be3d76c81cd2dec744a0403c3051264f551a02a91803f9add2ec6e5e728452b6bad0886e83c786db859de1341a75177ef06fdef28b7d50ad0246b4b7af574c7abbed80a5b249f6f06d7b9b1828781b94858b11ce544c4469d760d7c0ebf80672498b66c5b4c70b15b73bfb4e807342160b27309ba831dcdbbb9dce0d1fb638f3ba67889f37f87eb5ece463b76909adb66b9d1e70c3bd5fd69c11145ee04172f48288547fa3bd5c8422362dba3514e5fc5fabfe7648be9252d03cda13d3c3dda7870a89792d6b10aa50dd474d252ba1eccb39f9fe6246f24bb9e7f899e9c760f8c29a2e8393e8a10f24011a420882c192c345ff737610c06719a9fbe8a4931d16eee93b3bcbb70134f8cd7a15d975ff294cd88040304688cd208de675b3b9b6479b0197c74c35eb830b8ab4ba9dac1fa9f390eb41bbb0190b806187f611a67b31f9ee662d1dea52a8349e13ac1e058432dbdafcd5f37785f0478254ffcdf7a5b12e5fc18a8fdbafb88a7b12762a567c3c09e971c0c2a6a0bf3f3f22120540a4d38538be232d829d56b2fc722b829282d77178faee4dad2292b831329286e4e5eb13518f232c3b273d963b3926a4d37fe985a2792654e1474dacc5d2ff8ad8717f4b38563a0a78e59e6b7a7f80aab5ddf7f0aae1593f577b849eca97fd4f2333b1b7cf8bc0562986225d630be0409da3f6f41044e9ebf458537a7c49b627db4eb1ce85991890fc8d8717c52a4271c3a4f7c95f4949dfb7d3a8e0ab1fd5036f013be17f7b87685b944b2a18a704b8c701f5866074ef25fbc7ad33be027410bc898355a6f839dddf51b6fbbcf6d8452b5d4d24cbd6566c04c76004dc494b889f6f92da304156ced44d8bbbb3b5bb80d93e67c9a3d96b114ebd409badd8ad915646c4b68185a1040dd23ece0b31c615b192e9604d05f0b63d55d6d44c1f72b9b4225dab1ce908b0631e2dd34f3b851bb40684ffda2f5318a11fd82e3b8659d068317ad340e2581e8c0192f1d5647fcbc29ba5a2029703818fbd3d3ef5d64e5fbaee499b3f5846b7e1e4c0922f6a176fc3c3259fde4db04406eda6ae99b7d405696643554e6c9a0996dbb2b26e6f3947d12de735cdd5730ce5d34302cd20a6eb9c11577d7212e3ac127e2cffc75345df53f0643a5346019a9166e302e6fb938993cf9e38b1427fb9de4a93c58e75e304c9810a94861fce274abffd36cff64fe01131e1f44822966c758d620ebe67f5e18397d0b85a64dfffb889a39a6ff1ee6331f00f3dec244cce834b71e5db40241c50e43045fd26581ce155f0587704564ce59013d0e2c2a9996fb674ccbb7e1a6dd606651c1a332e4e97435e82dbbd6d0b32a0cbd4286b30d3ee8727b4224fec1673c3040b404f259b29af6a429ef86e278c5f0a116a81dac88242368f8c99dcefd0b796f4d6b7a985e6acd7c4806ac3137be7414c0423172919a407f991615581bb32ce7bfe6240b7b32f91b19deed1d96d687888a71001519aa1482d09229c3a906cd8c0d020d6c148d035fb9ce14171cf60c0a019f2dda49e521cc31008ab26ecbfbd97ebd919798b67b2ab7c5d88d70ef4fdf7aa85394f2144607ca2bc3297e19788a3a70e73956b1edbcf9c80024dc836e8d9ab029decec3b3adc4fdbde133ba360995abe77431004230a44d53aeb5642f5634fb2bf5782e25e0bb3fe42d03e59c6fcc84dfb0e1f4807113c55ddb751e13d0fbc2cdb1d5d5ab4058bdc57720942fee3f84a73a994b70b840776cbe0d22aba35830b67e08523d63b396e2a5d6dbf8112014a29b3523bbe7d48d96b363801be0765e57d37d3f4b6ddbe80ca05b330d161348d966ef53c8b1de4431c1b2796ee7742f1b48a1a46131e93eb359a65347acf96ecb09e36762419dd2d29a64d6d0e72a172c8a5c7747776491290ee71bef918c990e06aaba0f2b65b1165d6ef803abc556d820dc3a7a42e15485fea089ef2c47770a9859b7af60167a2b57b7ad1c759f312d73565d0c4ee306e0747c76db344433a4a2875cba552aae3f10238c531eb102ec6714e04a69f227512a993b9af86e183d83e6ef114166655785db747e547c191134f58b3f8e9016ee295a415e7aa3ba781a2df4bb5532e384f15b0c4a15740a61b8719953c7ede2ec2709e0030109a4532b1c029b59797da06a41dd738b62fadac42c82afb1ab993309d08c0e6ff9091a54680bdcc5fd82cac8f63a97dd2a7606c0389a290ed2c188bab97abacfcd137a4ed5e52a2ecfbadbd7b4046fa7fdc22d9569343d6619a756582b4f0f8e7c8aad1dda4f5706d5f72023b2dedafc6a83529421dd3f4d925a9f5c5aa8e9ca22b2129f3fa15638a7f333c438c9a697bd5e0658082b17c3906d9209d2e22a68fde03a421683a6638a0e6781618d7e9d13bb0f8cc0babd95f4183bce1278c029bb2c67570e22e00064ec997f1918ad2a2b846753b01a88eae6de9e3692916955e3f086773e6a7cb32da5afbb124cd96e90cbdfe2bda6d2a0140002b6d6308a778233eb20d0013525fd7c2601da78a30c61b3df222f7fc4827da9730bdf3959a9080eb4263df4e6a468c6790ca83d6887b7edf82b5158373abaa80e2407358f429bf426b6237b274afe3274862a89027552db26376ca33ec75fe2e9831997d4600929ce0fa0231b9eded08a3dff12367b5fb4d6832383dc64ea683e5c68dafbd26631fbfc72a76ffec61ac0b91f92208dcec81ab22fd28faaef6e22c45c3c7f0d182e848eaeebff1ef3218d2a59cc564e82b01919922ecdd771a46e9fb11ae970e32fd8de6a311d0e10f068b59daa1f636f4ef9b5dabb56aa6e27f520540bb5a98bddb4a8d338c2cea623020b142343fb92afcef771bd5f85fdb047a67d584e82b7579edfcc8f0168e518344399a26d933ac66c7e55ba2c0d226cf368723704bea0a9ca4128cf56355365ece8638b88bd230917b7acb579ab0bfd6505d09cfed01f497f6076de9728bf7aeb71c21276def908d6118313482c34cfa275152519a56b3e46ddd44e00538dbd7fff188feecdfd3a2abb0492c883a25a49b40f773448e475e30b6e79b652bb726320d3bc7d37b5d6d6a1b3b6d89dbdd0f6cb8566fd30834d2e5164007c61557ba6cdad794bb7f7a9b3765bd8273d5f3c54e153296c811982e3cec3220f3f148ec1316b77fc023b2610e8834b7dcc9f2ca52169cbd2a230926049a0ef00f70371558366bbc311feff9e486f1f5a9c85e2cf846144f049638cd8f3fdfc8b21f0bf5d7e52c07a47e7558134634f1543aa4898ba3bfd8569aa906ca0b92f56c0ccd257152d7ee071191a82e3c50d5a99610fa219864d7cd5a072a6d54f08074182e0840ef837c9f8ed6013a2426a14ea860a69dc4e7589a775c9a4698c9fd416c9ae1f2f90631aaff5290e561f8cae8cf90c259fd6785e4ff27235474cbbaf95088a7f566fbc1374cd3f429f42bd2ac17881edb939e62dd7685662a8cb32d938bc5737cd5a8503a6ec745579d6d91f5bb7dd2af3b2e42e1e48e1c1f02534dd2f92f966a1f65f6f9b428b03f8a8a9d92b9b975300e2f1d50f452be05f78bd196475ee3996a11d981cabfbeb9ef9cd77080dfc4ef762acb281e7e8720c456523003f258b104db2b3fc25e97810a8ef208ad9d0d31b3eb3237270dd4e3f56168598b2d3b743cc2bea94e2efd130714a851f4add29aa736b849fa2d217d03501c66ff359a33d73b7cea2cbbb21669d5c6b6677a5b06f8b1e729a387a48f4db0813a354264182f8d5c390fd20167526ffa3d46d9de79c51542dd830846f0848aaef05bba8b381e1b6bec7f9e22728915aeef9c5c9f9ebf892539204979afda14154232fde335c9e11d8f71c3ae5eed6580b958a12c725b63cb59f6b806921e761a0d32b05a7b7491d77202bbd26ab70e66fa9d921e61d520e9ff537b80905e0174ab5b436a415296322dd82c99c6e6dcab1124849b3ee009b7fdafd8b5bd1b71e543550fd489e9fe45a1a981804ffd948263eec5df3f885dbcbdfc7ded367cf390361e3e5501c898c5223d49593e7a0e06748332512e03764c83551587dcd94ed16f7865c6bed06ba0bc941de500ca05f798f4015393089af447f87bad9e01cacd1cc3d3af15b34de55f7ce464279bd655b0f5a2420796902e1c321907eeb8fc87fabf236427168c34b1894b6408cf656559582613e79bb91d977651b502c84fa329859935e1c05cb498220707a22e04380b09c01be70770c7dddbf0061dda2e2a80122e619a8f3011d6a02741aa00336265b035d59ec790efc78218889d81d1de04d5b043abe2a420454f91c113dd6f03ce93792ff9e56f66df7f27fe9ed3b0684a3335adcfb71f4fe1030bc7281e5fd92919014173cad21c482a0a458b491efae1a1c051365f40857fd84d9af9398bfa9bd925e0a15985d2b012fdfcbc83470d04e1d826892032c62781a11e73764bb44e048345167a739d594892a93b78fd0c03b86455f4cc63d3b24259daa8b4749ebe645ac33a66d7b0eaedb0c3e7e6a594df36b46933b55172b3fc49230a630fab25089c4c92f863e88b5f52e33c08741a3747cdb30a047bce70d5502021349eb7171fe0a41f2f591d7409fd6eb7cd7912f0f49cfb566aa3f7ef5140dcdf057a114ae86e14eb8bde0ff83fb3b09399ce2960ba617aa6800da7215cdf864fac755db1466021cf7af92ed45d19f08653f2d7fb637eb49217f02b551c7e216758a4b137a8748d79879a010008e70f596e48be422d94af6785216c596121d2f020d9ea6d290ec7c1025fca5af38cb29e35f0946db03e205ef83e2c19f317fb3251f22b64954bd466ed05f3fa5740d5c3f6e72de5b0a0506c360724b84a88c13d43d3e764163dc6d6eb714b734c141e0e36ac6dfc912725a748728ad5da0cfba3491de756c4bee0a87bdc04f45e8f2987b7fe1d19f9afd0ee4fcb1b824083d88228841a584773c86585a796241fa2a2e62615515368e5efecaef85ba83ce7d99632f4c9f5cb71ebbf524543e89cb28a2780ca521df742291250835964b4df65172529d05621324bb6abfa102980f446e4b448b896af167179c6090ee35daf5bb6eddd2bdc06b3a7f0a231e4dda7e4fd34db7a03804811ddd059031f096acfff2fde354e6555b1cc2e2d19e664dc5a9e8ba80a0233d54f9944a25c212034d7ec55a86f39e7c9faf42750c23cf7d6696b1999e8bd3567bda17140d52f8b0370aaf41af237ec237b53e53f774c58b6e74ae9577eeab1b8ad439a4173f77f26366a3ca7ca12bcbcc883f5047175187e378db13ceeda36b4bcecf297dc51fa86a57bf68acfa222816f8a170ee6c3b61e9b377a93b745baf5a2a61236c1ea4bba3f48907d9e60cca6ce06764d1841cd0ed6fc950408f8ec274dfbce81f24de41579da147e39bced17524dc3d21d318d0b163ac2255d7cdd2722c94f98210deae15cb8b618334650fc7f768486c403ea37a5fb79f754f4737a71636d98553c627270837c1ef1e26ced8b8a1f40df0bbd42783072c99a8b9126c00b1cfaebd8c102a465ffd30e8a3df94718d3045d040281e755d2d22b5bd234a991846e25c5800042cc11881d613c04d5bc163df894c3409953c0e76b29b4b6da0f794e5b278ddfcd6ac5344ef14997f5d91f69836e4aab2b8668150b0db45603ced6f5b7436a52af47a0c64473100e5c735a9c9dd6103235771002e88f68804899de30243e7b932f98e06b126d3507e87417cb1316b439373ecb940bf86e8c5f5588b9bf15db40b100a9b6f2429a03ba9b596d9ce5b9e94da4aef2e6bc47888ea27d06ffb90b7089fdf416369d1e621d7d0615f1c162a7a4e98fe08ab6d546d8b836a832b5c280d2bc61b40e6668517ccfcf3e54dedb83cd13e957fc36e72b6c178a09ebc53469b5ea0d5197544a5384482e5a655f70e6d5be957d3d0d447f1a6e29119078e111b768e12b600b0a3dd6be42f213a5d834bf788bb8a663c7396a56fe2d363f594b1823f21bfe8d38285efa8d8f2c8252859ce8494802bea9fa2c0d9d577d58ad56c8184670edb2613ce98616190a8fefc999782aacea4b5bd0cdf51a934efa49fefbc6cbb0cf0cd92936211ceeb9d6a59520ede81e3bdfcb8d1863b86a518d059884f15c043185b4567c1d34f0cf23755d16022fc8754096a04a90ad25d5d25d88267999cf6f978d661bd985cebca5023b6b0ecdedc223d485bf0d4dc4775a2a60e48e7d7511f07778e9306b1063ac99b63750df2af3879a4715d5300cceedbd67eabfdc2083b264e0fcd401f2902fec7a862984c73d33a6fcd2aedfe5c0e47b9b8af19d51f38cff4d4273afd86c9d37c93e36ed22f07c1aa83c817cf57be0076a52f2fec4a93d4d18e6ee3f47118ac722218017ee1a9dd76a37309ee0121daca87c2957950668bd901f87223a0edf5e72e0de1e0a3bfd10995d0f93ae8db9167c8668e7e0cd35041bd1f002e0b702df79cbae3f6a1966a5e9d2b17c189698c3829c3a7a0b4786b810e3f601eaa76e589c4436d9339744018f2e9489f24b09590cca8421a8262b7a3d930df46f4c4defaf96d96df5fbb8e0b7e7ae965dee0c180c5af3e07e551cb912b6e44e4103293da55c58bce7d4959206ad553a1539e861e86f52a02636ba9db850c66616e143782e909197748980eae7bbb9517a91301d8321d8a7fdd3ca20dc6a97e3675b54ad09daf67ffdde72edf9b8ed5a64c887a204df4579045980995ef16650a8c97fc60cca462d8401ff6187330acb4bd8ce9100ac6f85af84c1505bc0f7f7a51cb4f87c4992e71c87553adc558bb2b05a9d137bc37bc453880a408810303aeb9a9d88ea909eafff9c2671960a6ea40ec4115de01398fb3e6359bd0db971f23b500fe4e0cdf5c1b06029c510821efa4242d4e528dd1f6ffbd27d441869d1d7f1b8bd9f4049564b3ae348d2083ed341643d83837b31acc9ee94bee0f58e60ee1539c7a6b839e63d3e654093ea6f69e34ad2160d6151b21672622899d5bfe059bac536b22f6771a83381a76c6ede26a8064542f0ae37b1a552a501aee06a3fc2abb68279c544f92845dc631c090093c5e6ae00dbd2f4959b5b4c4ce00a12ab953f8ca1359170e249ff488aee634d80a88a4d075baed9090e5ca4ce91e0b78bff8ec72d8f91248182ac2b65a59670bc051975d7a581fa095f3d01cdb5e7557dfce5bda1b56907ef299e59a2c4beaf9db4c4aff5941717b690c6a2bf9b4d9202325f11374b80c09ff679135739194b0560a09a9225875fe2ef55f9036a5a8a01291030a2a9d7191d82fe7565a0f7f0a03d29ab373e4139ff6b1e114e256e604af1e2320f7b1f909cbf04e9d5fca4ea9c7663997a726d62d2461ab3d0c268b1cbe7d26e8420fdcc033464308b11d410c77044688b57b75d85529dfb8a238da28e99eddc8bd1ef2e6c687458e580be4ffbf18a66bff4add1d600a05d16c149938f018ad57e5e4bcb1df0071d296689e7074ec08b05b8bb13b02472147eed201f978e69a38fcba8e335e7a1dfe98bfd856005328cc3264c33a720d917392d0c75e023410cb92784a531587db513ca549f4e76e827a2ca2bac85c61325bd17929ca571fac0e4b9a8e8a3200943491011ac8ed0295cbe1045b3ee8dc7035a9d43677304dbbd1868c8882974f4fa4f884d6b2c148e178b4c93e2155dfc5e6f9086f3ebedeb18537ecc62b8dcc8488807aa632c148f9b7d0fd82bdee753fa2a401d7ecf5c70773eafbe88412cda7c32c00c963507f70e98f06f29ee1cc4169e77121a45f874d4c7e2a5989f3b91237446cd7757a475189f3a39faadc08c43bc5f87e6b9972580d690020c76a1ab9b58d0dade930b398278d6ed81d90d4348789db9124a7e3329c48bd2928eb96a8d0258c17bf6f31bc09c31228b0c8c15452ae58b7b0885b2ba40881bf7d3d555f8b927d7e73f5798bbcd6f20650b087e5d65f705dd5504ca1a5bc801a1559e996db923adaf720c3dd08f7af38053d8abe99c3d55b712cac2356c5ddb2fd9901ce70c930b740594cc45b354cc1319bc8529c2fbe6f9f8177f001b27eef9cdf419aaa81f18e13e9fa294bb6ffdc9200d37481320f85ac3b02868bfaddf71e1fc36cfccf865af42f37997104e4e1db8dd72fd4ece075df063d7dcc8643bc62d2e63b7105c25d57ad20","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
