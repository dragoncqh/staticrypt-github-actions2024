<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df4b8422a1b5f6a195045223776c79cf2017f4c0a1cd2bedeb192afe44adbfb34ef179171e5b32ff600020bb23d15ba4dfa489531f7ac917b372bbe32a14192921929b4edbd16fd4ea4f73dbba1df780871dd9f222cd8ac58e583e938d13330d2fb7fae99cfeceafffef7f4c3cfa7b1fa839a9908a6430079212174e90d5a33814fbcf4d31fe9276a9b995673066d00fd4aa6a00d0f1e6d468433142e4c694b253cdee0a9b4b40055eae16ab39288497aeaa3ded885c8cf28c6b17b3cd61894d79a4cc187643ac6cb4f31fb06132e28fb099c17f18da291a5905c2ee9ab66a0f9551aad51caf209276dbcb9149390b08ee54806dbbe10da9955d3f1ef19a29bd458015d168f88b393b90d73fe3d54a7aa63520bd4443e0438847ee324e47e4c394ce7ceecded527a85e21976e18811d424698d5c9f2ae5e123f7cc011cc5e0c4ef4728e705376e76bbb8ac8a9dc6fed069c5ac440527812a84c3b7aebd3fbc02231e305a88cf93f492b67eef8798e8119dfd35d2ce8beeb924ce7146877fa66ee6385f04341998aacaaefb50227b6891a0cb21895bc348f9aa4dbe4dc003b0fcf584ea367362a92f092ec865e0cdf788df6689529fcf8b47b45fda37aa8d98abe4744320b958105bc73cb09d106df1fe6310a76c958a3abd69a4fe3884eba9b3fed65a4c6203fb2fdbfbe15e57903bc5d769004db9761a4deb9d13c4cadc089c64d9bebc7a21c96070195454018dcb6a69b39d3242578778b6f09ae1e437ca5e5b9afc95650dfc16e62ef7f7a1e9d2ff27001b656cd1c61bcdce4845e48e23529c13803f99f4d0e026d38d614f9d4919dc091394e43558b867c54138404804a6cad4deb17c25f7b2fee23e9c4f12f54d322f2a45342453c7cd5a9ec398befcdfbf709aa3e320eca9966e8e810bd699d4f959c54d1c55c44c44647bc753a85bc56888460dd1e0d074448394a70ffa6e1d6117e4db52c339e41f1d4b6524c1cd82163721f327f6b0113626c57c8a951e88d0c5bae1115c14610e9e18e75820aac5506b845013bc1c36be0ab03d3987fd6a23cdf7491d8d30f98acb291271e9e04c3c4f922cd3612efe7186228f0f9e8d6455e95e1713a39b553ca73f2f6c44d16a169e5683adb287a8f28bf22ab64478f54538aa3483304674c85141e69c6c1202e4f3251837a99d289a1d90a6bc4fba649d707207e26c7cedd39953ce1917838886bb32c1b344a7f9af827e9da2ce8952941206fe3bd48b2186b592475b83a3f6f0628731ede0b3fc2eadf19aee5c409d9ba25e5ffcd42ee6260cbd0fdb2c72853f85e191464e2809420aa930dd75fd9faef686821d37bad99487e5c5b025f0a959126886f167447d099d1a770f07284f3d316bfe31a8c8a9f898aace781796a5997b7a978f2941f39c7381d254341d4c53287d0bcc2dc8ba3d99cdb0f1e13ed453f3355f0d8d72eb729b9741132c6d3c2eef68cf4c0576ff43302b182b46d71e8d973237d4af24361cf3b67a9b8bd940bdf87382c0728efe351e232006a2b882ceb9fbfb6d19f4a1a326801ecf224a0f2f27a20bec3be114aeb30aedf0e86f020f22a7fa488ac7a81631bd0d41b8bf5e8e660f5b4b7aa1cfd66d568bbe0864337687e4f05628143fa5d61a0b6189fbdb5add38614f7abce53e3c737f5f5b952f1bd72b0fe5d437efb54d7aaa3a6764effeb8018e67abd95611ab9410c60edd36bce2734f4edcb7f4f3fc141f439e88e1871db8843514907a8bc1698e5e5648556b2902eb995dd0cf02cf3da3e31446ecd8aa5f962b4d9f4ae2ac02035c15e48ba6213c9c557fe15eb9a9f0ff99ed858c77b4b989e45f052d4241c89804215db7bb0baaea6bf92b87dba46d3adac121e5bd0afd239db961faf7b427ed767eb7714480284dddb4e2878460ed8dd00bdc9c5df29a9232645917378bb6de487f9b6e166226dacf74c9ac25022d263ebec3065ac306898e6f3a74736f8c8b55d29db91f745b8fa9a3d284f9a419e450fad874c4856708841a7bee4e0146fb8c20eac53f75cc87cb2cab09ff90ca5818fda894c4c8859debc7488b19f17b252e32227d103c49aeb7fe54c8f9bb82c0f88a68be2baa90d411ae008c3b85091a121c63fca1bf4a47a719a709de5d56f128830918fee42b948197d834141f986de617881344c02b102df9bd48a8b6f4d5afd4a10c1cab87cd37d2e8e47ed0ab23268d02fc2de28ac44034d8ea3edf1bdcc1fa97db25f5603fc368b03c04ba8337c52a1eef59c61f66cc1e7e4c33765075e861a1bbd4a762bbc80174831280244fa6b0b721ac89cee3a1661a5b86b9dc36a31b7101f5bbcd729c88870357abef1b0800a08e337e6e02c3aee69051145818cd662d7bb4ddd5bc7e3852d9aefd87aa687be84ad6d5d2f695672bae3cf0536b312b3dd26a470cc7bd33bbb21d6a2521a0617a554ead83f5feff42ea838d703a48d4dfeee77c047677d03beb6145b99467cc11d5b662c0dce4707f5ec744edbbdf6f4452bac6086ea9f372e046d046d495a41140281daf879ef2ca7f6a2a3bb69b592902545c48d2f1fe8fac6b04bfe4e9424788da0973435d8ebb09f3dff5f922cb1fe32edc15ef0d3ba68548dc98f5795c404b044404c738e2b5aecaeef075a3cebc7da732c1e07a06907e43c864c7ebdda117166768b840efd98e6c401e80d51c04188259bc43ac7aaaa19b895a6cbdc3ebbd1c8a8ee843676de816c0d9a1bacc76747d3088ed9bd85e801a6bf90b7a08fe0c9cedf3fa31e7f2cdb4e1df25e860f24863924c426e0e41eee614456b62db5301ac2666a3ddbbbcb22e7d915c4de9b76c38bd30909e17a0e6bc69c467919488969a753f6f9ddd813331c3d23f10c568d7092445f5daa55b1e629cc54a5203277f4e644959b59122664f7239fc4c316b26f0d6b347b1f2891d0285c68eabb0ef6915372fb7d268103117b98fb797166d8424c69df9cbbb552c8c449541d4ce9dafbbe40be199a38a790ef3e4d16735b4093bbc0134ff9242f1b65f76297f1ef95c11aa3149863c99caca1fdc54c828b26b118d10fa95e2623a15fd422518758b85241be91073a8f1f286973503ee30c404f13a7ae86eb160d8e641e4add51f87c370d0bc378319218e6114f19d996c2cac5a1ad4217b31e0bb01fa2d63afb57f62bbf5e00d9dd54e87e62a16a6e70ab289a3bf10e844f5658b45b3d98ff6cb5e00ec67cef8ebc475ef35087a6042533b2ed8e099ee6e2b5f9bc7fdb22590ee03cd84eb61b10b052eb9d247f56ed4d3d1f27c3d7f86387373177616af0b4a6257db9f767b4e757430c8a036fc35e0a977a835742a513a6ae99f999cd4e464616a50f3201d496856f8d20fb68bde5dc678980e3ad125e78e517c621980130f94908d76356044283a5a2f15a8bea1a878651d9eb33a610d140645f9625e3cc7ee0a2baa4c15c410cc08020d1536faeeb98e40310820603c08cd27117f96b11ea37b46ee1aa297ad3c8adf5fb34887fe3f03b38e8073ca1d7fcc9e24290f7d82400eda4880af183dde92b62ad94617d1cd471220f87cac50901e5683e0f48e5b9f927718b1ec8dcd5ca9354492f950249889c3d5987dc0aaa287d3a687caadd2cee46e79549e4978c6154d38c2a7e167356eb6331a2b1df00637e32ef0937ff08f145963f1bb575bee399e8ac384faf1392f38176e4a4eca28fce1522602445da92c375eca51f04ce2d87de842c99c68b63245f7d46084acf418a8cbbfecc1faa481ef0a26169fb1b4f151efe13bb6a451bc5804c4511176752a1dedd729d4a348702767cf163041b1c35434ae5c94b04880129ef2ff0d7c4d1de16908a524f187ddff93149a9e6326b33f68606a4f4b67305490524e1081772d0d63e25e6122f2cefe8d2d7ce561cff9ad0e3baef01c00d67e1e4c965e30ed44f49a8a54ac1f029b50e3c607dd5fd736ff0f74181f3cfc13fd403093a821b589242121cd88e5d3e4fab9266b7f07f3ff48368120568c436d40b553391e62a51a6796e0e04e97a722241c011b56b013ad80a1b6fb4718a81ac35b6f2965a259ea3afce8b1fcb771d28fb002b44dd717058f887332a1f26b740e5069d084e59a55095be155b9787c853b6aa1a9153fed9a190dcfcfa1267aee27d1d56147ea06202483c7a8dc5b0967b0b8686d4d0d636d9a9103ced88f0618cb25705e1180e7b5328e8e88e71c88ab73e97d979d4d6c2c84e99810fd624752d6659713c5a7dbc2f17188124baaeb393b22d1fee3734022598b46be8bd7e3c28d1ddabc16b95703aadc9bbc4baa85ce1baf94312f87851c72317faf06637c44732b142ccc952a14af7028cd49980741201465d6c02e8fd42df530d5846f55854bd10c6a019a107c0054b3b4ce97da421ea946272fe5aab18d92124bed60d7fd93dc6b7ed38de6cf750466e960d3eee7584c7d3a880307d2ab1600b46864178e5f6957a24ac4ec449a718ef8198af8d9f9a4346b9d8da032f7fbe79109cc291cc51456b8d18685c37ef7af24cb4060860013f9b2fa57b76bd960b141605828525efe04b61dd46bfbbb84da7bf3cf6c4482340cdfdc1277fa529fe87509ddab5db2d33962d67754eb275bee6083f0b0c6208c780e31f2b4e00dabd063c33635121530ccf13180ad659aa1f54084c4877e48f7486a254097efc0f9cd7954dbd2631b4f59724028ef64c28a7c690dc2605194ebe055b377223235cd8b914bb3d86a45eae3e06367de271588b178417a2a3cde137db3b7d3171c0c036700f0a5be0935e39cfbaa4e22e9ea632dab34b0d206647b92fe53e65e45737fbcdb2d2d46eb9c137101c41be0897289de4f6892ca55ebd43774b00bf293e30e84d3938c96c779f1b135a6dfd4c6083879972ea19a895bbc0611123c40739f93e9297d9a3b66cd0dcbb106ba57893bd8b1600c217e8e66ae95e570d69c8a17eac4b3627ec090397379fe6561aa38aaa23c9e62c163e44c3a0783258e9c44dc5ecd094090151f41db4ee014dc7e75e17f30bef805ed0d5a72eee6adcca42061e280012ea3eaba99af20652043aec3d6283b02551bb1b92e9725edb48048168599b974e0b6fb440d3c4f6b17bcb0d48cb92985dc979af057621c90237048ff35935b1164fb2326cd6df529a4c4157571341e238090d7f01c66b25c4e91541c9be60a24a916c53853058d49d96523b6182852aaf15d64dc0d04788e48af882b8dbfddec7ffba04fb67e1f8b5e947b84a2dde543f7c2080628287e70f4945b387a6f0c3e9965fd7069d3e8e3961f07a8dfab100acbe49b0a9986560931389023861a84f592aadedfa57162c55d843695cb16697ee05e9d529ef0a43cdbde13200f6c25335b0ae4a943ac04fab925da91ea9b734395f632bdd8b0610cb72db0cbe2846c77a33a2a3bd2d03286d15adfc8bce0d39b1bbbdbfee88f6ec59bb1871a0766d5556bfcf6bc4e27301e9091c1696f081158c60267b7cd30bd0a46dc7f45916dd5f7d24fd692f26ff7259db3ac11e9a8f8a7bbe90105605a064e5b514a31daa4bc04e2039aaf2ccf1eda1a6b4360516781c8b75f21d2a92a60b48de82a6ee81969c4fcbfc3d9e3c5e6b316bb1cfb5b24ef971f6ec0142b49853a91ade76b5f6f7fe652ce5213b51ebf26d66e5c5f976ece4790166478e014eaef81e6ea585d594f110362ad3e708594a7b72c480530b121ad4436c75a1b3528874aa0e5f6a82cca42eb2d382ed15f6b30cb087755ceccd24f13d39c354143590ed2216a8e47c5d0cc00bacbf6a6a55a354e151297931609642e3258478aa7e42b2f6408fdb2108a5d96aaf287468cbead167b275bcaca159fa138e95def84b8dcbc565018fa18726def8a7467e541d15601fb061dc337b0e33c2bd7bdc33c6101c247fb92cb880bb04f29d70df65ff5eb68832574b2d0fb2b38eab7f21c91ddaa7e427ddec75f09e1fb9b8f14319e79441f9fd8676cd9a4436e7c4778f108830fed25d8efdb6d8686cab567c16e28b4cd853dcaec00e1b900946bc1d67c43a7c8dbf5e808d680aa301b41893efee98f2fac43091250e1c4d48e519c10bac0c747492a56cd5f35953dff14e7dcd5b3d3b1640a282a21f82c1ee3bffb864a57375b9e20edfc7791bc6d4899c179d293e6e571cdb93cb116f857a224d9f3059b9fe29fe92dfc5f7cae7d554ca36e4e5ad1d0d7a6e23930bd715c7f477cca2650c74c614ca2bdb2ecac4878ad71ccb4f49db76fc7c0673c4fddcc2f888b64be433b13510ef40454eb5aa6e620bac9fa00c5837a1c2d18bfe6959bb7932e2de468d02d45707d2eaa0d94e3c36d4fbdefc6f89db36c0aed6b0746e6e59138cdc27485058253b3469afd24c93001b6ca7a05c74d3a9e45c6d688df5c98887f0723004cc0b09b13f32a8592da703cf7aaf8344b381d2c63a3423168c1cce35b3b169e5556aff597acad9f14295a897267ff4ff188de9921d31cf2b97649899210daed660503e200ca81bc238ecd06d998c1e07701d883e78fb7a8f3cfdce93424585fed21569239b4b4e609a4b7be77920bd3c15fe0ea44279054324c9d1224786e2d4878eef9ae4e851ed20eafe00109e7ee2c7e9269556fe7cc1cf777c1290fe0256b4bc811d12dabc9d2da6f4971de079fad24be3243ab4cf52a26aee4fea58ac7a072fbf312151bff5fbee1a5048c0abb3cf003136d1f42b41f799bb17f3e57697fa85b2755c9f6be4728d915da0a26d8c0f2e094214aae5ed02ddf058cf780d5343e1d89f85a5450a2808fe58265598c648d93766d43eb86f0352d489f10647ede0ecd6c4cec8dbf9a2f72a72e05d974e12b5197aa209806c5661f761e5aaae139b2a7523793146da1571f3d190e51536ecf1165266a737c4f5554c662900bb14cd2e30b902b96552b719ea0aca23c625c2dc4b054888c603c358b514c16ed6f57bc3e077d16d3222e388291c40f71ab6e2039691bc276ee9fad4330e99258a5dd6f8a4c0db17305b2bbb2b7d8f8e33aac941c1578e265fe17c7ab868f8db37da49e21ddd9d4f6875b8215871f94ebc9a7602ca8f54f155eba70b22c2668204cd2f1fae413bc5cc2131ae214ee8d6dcce7f2fef2b93273c7f9f70a0a6837854c7576cf53781bb0439becadb4c95175377375c01b747951c19fd6b0c2fc1ad1341cebcc844807481de4f432d566d491e2846657b6431d4fd8cfaad341eedd06ba0f5fca64bb9dea2c5c031c421b3d60e47cd8f79d9a7906d62ba0bb3452f304ce5849c13300e78b899898ef7b7b02da3e767239f1e85089f38c187a7801941ff6caecf172b9b2c4637a5c56cb15e7ebedf5a8fe84e5f46f96639c752c9ecb4672a65092e5329ca63cfeb6a2a824b9e9e58c44d7b5e0ba328434c07b33512f4f02d005fccc684e044f9d1938489b2c3febfa489a32f05632f334f70db6b575a00e7e5ed624a2b7f76168040461f42afdbee432d73d59f8825d1c0168f4a574eb7b219b975a1c5abc24c26e465b718f4d5adeb95d488d0e226026506b56f99e562efd53ff397b9f8facc9b2ee3a7785b1929af0cb8b8eb19894b8fc019815b03a94aef68254460954ac7c37a458e31cca957b7f9bbb0111936e409150f7b881d116c1d3d260971bf71544ac08ebf68f39ea99ae5b25c07b3bdea620876105c50636cf293c687805d7fe6196d31e6165c32d347adb9466eae983879d1e3d879ba0fc858010ed7e926b25f3b91047c085297d47bb174c5e766c5d45a67b7b16dfede7821194ff817273b6d0e87f57b9befa05e705dee74dc42cee698127ad6c6b3362bba8c26bf575158f7da83651d87e62e497601822e20d2300b7d41e39dbea4962ed6a4575fe553a37157ba93948ac07312a8affeb2d359c89a75c6403a7aa6042942caa733c529e7f673768e732712388376aa2eede8da0bdbcebd3ee3d2c6407ff755b6bdabb00ab14e55d4056a358dd2c20cee8103017d3c18c01f741bbba8e41feb25e4579525f3476d572ef045c1e987c4051e0cfea79bbd912962d4ac96ef5b28c5fadba303d42a1e89fc45390fe53f177d610bb72f9f99dc67390fddbfa2a54bf71447fd8e790cf4221743ccbb375784af830af01ef89e2d593d56a7048661987cdc9682e94cfc545b253cc8675f5c0f93551f572b273e2782a91558caae71acf81ca51930ab2ed4a6189d56c1cd6c880cf1212918fdd17c7182362296ba31f9a19b85b23554a27e14d66dc454d23cae4b54516af2a26bd17ebb87be7ca219cfa0c898e19f16275a26a64f1054fdac613ba1a542d320a931d1d68d4b5efb2e28441c4ca6325e6a9369b30e32c33b7a852ebc364e6e253cdf782a976cb52b512ce883140e0bdd7b3a221ddfad5964bad91d112e82a7f343de56f14c36ca3b89b10eec48ea8839340e69e43950c4ca8e59fbc3cf433e12b10bda02b291350e1e1060d2f0c27521dd3d5cdff4208c6d9e9fb537de2fad2f9810812bfb2c0a3ee0a1be12ff990ed6731f92249781cb3e04c278a18ff0ef77187913209e1b9440be6e5b29f412d87c8d7db2a0506d94d824ea1d1380050a13baf98be24bbd5308afbe3def87cb2a1f7f8d3f975da9ea344199838fdc93f402db30de17a668cbdfa7de05f9ae85558b372269869c5a0b520128e78ff34aa0b6085d1878c948331d8ec2531016f4e506610b2c7d4db8a65d987608aef3e1c897b30af9b79620ebf3cc2f07faa04ed5b46019d2ed5dd46be2ead961431938b7460f0228c01f66c67d2bd14947cef5ab7b1eab35aa445033a36dd2ed82e53c1063464f4f63b30af6c2b3de81d1a4916e5c6251361c0bab63c7d76acac897d4670270000e63a553b3d05c6e072521bf0acb63dedc0da9ec4384b7c1bf2b78b5e12184b1aaa44e614943c7a91861976e1c0678b055615eca4aa0f1feffaf491740b560ee05da27af2f03f398d02c13e3dfa2b1329587343adcbee4712244e20f093a407f0755ca82bcd7ea985dcef6ae5243706e82830b9efe14c5a3fc3e66d5888aaa370226dfbdf0a6a2c0388c50ab4862e7426fe9bc0233d5e03355ccdbc248033d436de420afd83d211c260de03f7f8ac7bb881da3a528573a31252c17a5d1f32daf1247aad0153405c5f44f9c701a401a186e5af3496a6e435104fa1a21218669a03d02c1fb3ae71f66ad11f12dae2605a36bc2ea3c485c88af9a0bba9de088ce0387330eca586b0f997ad9f62bbf8957461bd6d0ad32f79bf1de1314f42ce4a0f4071bdbb5b77973fd68655cd8e514252c7aac0e8421ea22ea9b90b3f492292a53a999701272d7e5007ac7f41774238b4b8815050b59f55d59a42c9df4d45f5353795643676e84be5399da1b7d10d7609caeabbbb09361849c19b17a073b23c0d57067130e08edce03eba009b8872c3f63456f10dadc12f631d4cfa319a0518c01f7382ed1d662344335ab89f095c5e658c8d84a0b731a00f5e6a5a1fb3e524ea1105acfbc69ae8b4853722834f3e361df4694bacf7580f63dda9ad86ee963903d1cf571ea009623c40356aa812d2e453e5e7ccb5374baeba056c30acefcb0f46e3c9773a53ca0c3d6f7f23fcdd35159540c8e004167401ecf818b8d293ba8c0530cd8c8ef297bbd5dec5b96b8817a4f74fad2fa9487eda7615efbd55dc945483a09341fc240f8924199ba7c9e27fcf670b88ecbe35a2d596d09f09011e20f2c6105fb1aaadb8a28e46f59cc8d5baf672f01e02c0eb24386936cc0b8e37f68a6a14e34b6461e5b68e83257f83dab7169d690b24742b7296d75cae4a211508214adee629b72a4225ae9902db5a21eda85de7cfe799e5790110c3eb0587dbfa03d31d0babebfe6d2c205c6ef9e80ac961cfcf951ee21b7fc3c31f361ef9bf72b3db14848db81717c41da0cbf4881567e3e9b688ddd5093baab72018eda6c466909ced52236c08a15277e3c05c925dadaa9152bfd4eed3743498fea5542ecc10075b3c6199e2fff322e75063c2c5f248ab0bc3e29b35d9a5d501a31d72f9ba848d410e1865a3dfa5ea1de43e46941755f93e057e9207320e5b8a1c61aed3730bbf7ab9b6ff6dab5f6540213e6052061a268fb7c4b78b25433ac6977d851be42fa366aec624117f0a3b31748f369172d6767852720f27e7be1398bf833be464601a5291a093371d5098945f80ca734f46593090bf72efc1f5df117ea287aa8436a98ec166c8e04aebe1b101287f762cea4cfda55fc12f6a5bc8fb65a8107caf5bfd89821faf4f3d8475c8ef770e9693aa2c58c830d1e6fa99a34a7397c67b83fbcc944b7ad3f72a07be52c676c553e4ebbda38f6a0c06e2d6ef6d347d21984511e7cc4c3eb6bf8de6b63ca27e2b0ad81c5609c44458bbaa3e1a5b29d3132fcadf952b172e191925fcb66ca112bb8118db0e1fced710fb5d617dcfd360671f38c30ba1a283dbb648d76d33e2b66c46760890055fbca1fd01d8ffb2f3c0af84825ee5c7d1b3aeace1c1715aa8ef89eb02e13834451c13e2d091ff82a85c2a93e44db55357b5ee3fa3f8dbc22cd3ab119d61ab868d46aa237f9436bd689260a9ce179c153babec472a5557518eed2b3f51051aee53913643614380b6c51b17cdc913e8fec619ea4103c302e98db335f4a3c546cc0877cb0703553bf31e060cf4aa428ce574061507b02d01cee9e3ef8fd4839d47f9f356de77b0238da9c467b2c58c068c30c6549f1b672226fc3a0d5f8aa98434f18bc379542c15690e197e9c19f52be70897fc305cfc4ae40c7f718e97a6171f7bce89c578fd2a6a8bfaba26cf457fa83c236607e6277295f869fcfad25adaa724fe272eba1983355ef240a8120f6ee142a7b13ff6db5bf2f5217d396ea7ecbbda5473cad830bc41cfbecca58c156c798ad7c725a6e675dbc7e98fb6326ec9f2014589ab37813734f058b8c7153714cd1fe99b59b663886cca72a4b48bb8ff0210bf4b816cafc844095e8f910638a24893496eded6b355f55c66f664a8864f67c9d084461fdbf7b6b3f785207566a51acf0f4f40b52b4c57faddb4f5f8b6f623fa9173e97c4f271ba94ec9be3c5d06aa515aefe92d6d653537777ad0f734627cab4cad79c1e28567e8185ed7f8a0cba955227288e9a87bb61fc77d08fe7d225cec011648e799e9d1efcdb89a3991c8f6ff320e60c42c8311c7ed70e6a2eb73b42e6a5a730d07f5c0fe670480e143c6e4bcf70b58d6962445a12e56f46910b56350f788862372f79e9e788d36ccab8c2bd560e575bd6a3fd2464af1547953174fc0fc6dc01044185bffed2aebceae14ef8e07871dd0de2ad25e19c2f8d57b7e0dddc0dd44441a0d3a4e2aea62fb38631283d9c82b5749362c7bd3d165470c5c9dd3a66a8be6695fc8b49fdb7661b14a92d854698f358a1f229101f146c0802b69d2f8308444f9b3b9b1a21940f0405e6ce068cf205197c89ce43af237315c7e0d23393114739f1699d13da25b6ff2dee678af9fa33b40f12afb6f8d502e63cd1adca1cb8e1a5833d9e7dae65031e71dc07c686ebce39841b0a6d16412cd8690008ca8a028f7134280c8c94558c6c5af1aa1225f43bb51bb326d38edf814c2978787544fbb7178cae5520538a97c76083a9daf00bbfedaffd4c2e9d11b0051c2d91ddf9150d1bd7021462bac12ca85a425b082e51131eb2178b89ea8721196e4d6a0a20718d6b85b36d6f455e16a491123fc3132399ca3ee149b28ea66920062618d9e0028de69cc43b68990dfa2162159d74435ee5eb7547af8a4e1e74376ea9d13eff881ac6a10c34fdac33557ff870ffdfa5fea3ae906a19372f37c169e338258ef57384df5c3919d5468f40fbea1fb46038663618038a48d4895bdda730923912106d1626df8271f04b88e7d86cf8c5b73c9605bbb256bfaa9dec2362f864ae2ce8886fd0497940510f33e425d077d967d52f68d0b5dc13bb7e62884981052ce4d6371b6a68107cc6e4f5311c441d7c752d6113116b61bf13c0089cab654e381412cdf623d7201e173aba8f53f0742b968042bcd60b0c47b4364c7c717ca9ac0a5a92a943d8894145e40e977190e8270a0f1c06ebde7a84865e0565406ff52656c9211c20c0aa1cd982f23215a06469c93a4145e60b90cfd6a81068d7269a70b3784f2c575dfe2f0fb4b2ee475aeb110894e7b3862540bb767f0695cbe7d5e8a230fc70c0465044efdc22ead03d0e6ffda0f6cfbf99f7f1fed225bcdc9a31d28ca9351a929c98fb663352885778bacfaf981f5f17856ee932859cbb5b5d63bf6f1ff7758885835c46015d1050592dfc309f8efc661265adfb2fbc61e49f69f7097fcec4f1dac56252388e1eb2e44755cb74997784892e0dc5bdc2ddcd6c3f08ea46f0e5f9801439217f9403996d67654649c747c6951d62e67c77526ee9be1839ab24a1c3091594d5365b4411b37dd2237bf12c58a902073586737dec39cac21d94c01520f70900418e0f69e8da3cfd32db9df03677a65cd2e878201e245c7bcbf136cce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
