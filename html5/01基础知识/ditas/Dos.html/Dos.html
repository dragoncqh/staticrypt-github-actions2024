<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee241885ca8e640bb66bce09f08023e96ef4100ba05dc211aac69e9857b26b58618e3bcc01a0e178743dcb15b40c3b9024b9eb2c03167f03d2280e812f55e3eb1fa54b9522b5be566deeaa8769ce9da784cbc3722ccc609a6e7d3db28be2ba60710022714fb9738fe231abeac36b48d10c6e9485191e4a0bbf9b0a1608a3ac172f21012e864455cd1c9a3d8cd31388982f67d091fa9cd6582eb7dc78576c14178f3afc0848d977953885b8d503e4250f4e33cb371ad19f08e0ac6cf965f7db848e807d46cc237c541c882b8c6acbe47e5c6670a212098a43b4ebf38b7f3746ef842454c3d62f2d915c8d12c6ad27f07c58bc0894ac8c9ae4211129003d312762f9fa664ebaca00c9644271f12901ed0bcc707aefa336ce916b25b67029a47ae8605fa09d155923aa2283960756d413a31d01b4cb8066381a8c7609b481ca58096ee7160680ab72e76d42ced8098dd01d4cbcbb5d9cd8a6641c42331a6a361e6e0b4152052e759925558e5cb74422b8436bdbc60d137dedd0f388a3cf19934a04ce640e8ccdbca43c7090203abbe70db74a2c9a7ca0830ad6c6acb54fc6e3d839c93275c7c5bbd6b9951dcc714964b6567cd0e36e3e6f4855a44c52165f0b360ef52918e3957bce57ec02081cc6a3e3245712aab6528010541c288dcb183b1a0b8f8db8ac7b556929dd100bfba835d752898d40813580e893a85b81c49863e5c6374c35d00074150733eb813553a877580147f1d99d7331e652f4c3c600dd7baa5bb18b909f9df45cd5609de9d577eb915ea79d44640232ff663bbc3fcf5f2f63f2492d3efd55257b2c1330ccc4029d99f969c72670bbc040f6caa9b21ab531ebdb65d882bfd98a713222dd4e96ccd309b8ff1572be77f81cb5126a109aba333b984f8d5c650f440ff99c707c6b2262b657fc16e65029fdcf79c3b2f6987cec9920f672ded7b9789713597c4bee25225d72f6896a8cb8c8f4e22f49e25be82bfeb8f9d22d89616ca33c884055bd3431b837426bdaf5f632bbbadc60afb95f2ffece978a4338ac9ecebea088b896084a52031e698e281e06892af8d9eb90abb507d77dcbafefcc361f0bc5961a92bcb2fa2012b4c86e40927c56fe5b1c4ef5ae94fbbb257f83d717718d1b6e833319c261fe596031b7fb77b4381192cdcfe5fd38ee68a3da060acbade1e8ecfb25217c78b98bbb64c20ec7699aa63773cb588bf2ac6e06e91ccc915755209c8dab31ed7120ba31168283d5ba0e40455a9f34dca69b73f8c9316977450010ee29a440f5a8a3b09acf2c78b99c4ef7cfe7d2b7358f7de573f25954ba9d39405193f28c85014f7d4739b9cdd2dcaffb9839897a44f5fd564183f82ba63d020be8549c3b6cf09d840d61c529eb9936c36826ac9092696f7ee9466bda399076981844f959e9828424648fcfcf58f63b625d9579121d572d4b7c31d7685e9e18136efb01487f66b378e583e8ea961d04c4d2a811c3e7c3d751c360a59870f1da39181b7e900deb466c68de4ee83f41fdecf6b44080c34768e2ec88f9bdbddf6bb3e00dfbcb8ff8a5349cb4d83871efa8a57897b94fb25a61c94529aac403e9cfbd61d0edf1b2debaef4698d2aacbc13544827c510b2ba49236db4273b7b03e310e43eb614f2d7fec11cb4f9829409d247848ccaf7279eb94361ad02e83dcfd49dab628f332237a0584728094286b0e1e29b24d97d7c3e37e893322a4b382a04e419e8b1440ce66cc66c18f05ff8a9ea9fca7d93b6ad2b7a26761950b8ebb5dcccac6d3af4709ff380e694abb03d65ca290d293fe44c1d08f07489dbe0514e64bbd34e16deb820341734d822d9eaa81034b4fd4bdabbdbfb71942bd867f190930b5bae7cf1c2c11de56e82364b8aaecda2c83ead32abf4abc790a01f7748ac53e32be96a9aea79ee925ff88eb00c83eb19712573b2aa88f645ff2a61c70d8bd32d999a0327d044465b7ce07814160ba80ff35d01c661c85c20122af7732f0a6be02c20bab351470900ee5e29e12678783fc8f3d8349cde4af018e78efbab902bd1530d6c581a7c3bf04bd0271033056ae1dea9ac2c0a302f2f49c518eb5d9b31dcacca1cfc7192a178aa16a222310382645a070ba482d80911ee53a7c499510f39003c2acdb4a19875d895ee7651ac8b40d3928015e2851f991bd19f3efe813112e7095dbe8ff1844ead49be9b0a5771456e7b6b9d52a8ba9d188381465de379dc4a7d2ead7b9df680afc53717ba751642fa5c76da970363b2a46f4c4c3a7ef156dfadb0081b4ebf9a172000337e85f69380d9a81e4878907de4120f4d7473d16c5a668ae959a5d88156c914fe1a59907a9d0f8466d5117deea978cbce28f0e5ac35c4ac4df19217290d1cde6e1addc7c2c553b15bfc9eb079dfad4d1371e708df0316dcdaf558dcb345dba5f29ee4e36bd890e624bb80075a7c0941a48b5a05bbd6e1b750dbaffa9b92c3fa7c76dda1423d4fd1443e36ad66c277c12fff97306c46ba25ff04b04ae1d9c7ac4f097c9619272ac2688f36fee93baf5c8c5dd9c43ad8beeb97f997548c7d9ad74478e2f4116337832358e62cb259f88b37294cd4e9f938e4b61eddb41072dc861ef128ee4a3096ef00244a4b522e698f7c0c246f08156d96caa33423557340899e22068e06a2c7058aef421de86b40260eaae0334100b4d40eb766d51778d66a3abcb8e820d9b5ada2f642b8ef9feae4b10b2d1af22a01e8b79d0030abc555d74f7374731d939348121e380acf932dee7d5525d12cf60c68a5ce87cd64f2eaaa4561444d4b5db970fe97e924c2f3704f7647a9e750aa03dca1312ba69b26efaf41081a70e6db05f8753ecc94f94e27757bd8ec4e22eab365b8c17fe196215129140b5570f08194f2a2bad6e2652684cf4a01052b32aa123eca56ec05bf4f8991ee1983e8e6e7d4a7043c013ac3a047bbed6d004338889b84bebbadb9c67f29af7952d9aa3bbc568593203ad05125bc05c2c4c7dfb260ce8ad733167cec59b3df84502a1ca14da463923784402a55fa8118e1da633e5279d123d0089662b0db4b3e4ce4e0976ab112516e626f392ce93a12eac31dd86be3414ab13c95a6c94be4d03c960c0736775872501cc5ce75a834da35c9710257c25eab7c195d2fdda5dffb98759a2ede6ed6b21fd53f200e18399be843e8b263354f6949f66cc0085bf42ea570eb93741dd4ddfb49209446a4bb36f32b4337f9c61116e3524d5c9617ef3b2fc7084780a3729895e49af345dc2ae28d4049ca49709f5266ee24490f84a2cb918f4b646243eae9690a1027b285212e7d87ab65b257fb664966ffdc2adaeff9d5af5ca39750024bd0043ce1b37515f184a3521118569ffc9d0c51de589e0e6bd9cfbdb812e2f8f5c2bc7d6da66fca7f9867465a154cffe0e2733f9249b288656458371215b170b41c70942b992689e3e1253545d6d1b84cf40e4baafa9921ee2408d8c569ef352c6228836da618c0c2036fb1b3f3c90dc35ba3f6753c1be0f2ef1266a03a8bf229f7eba78fbcb794297623aaccaeca7e79bef7765bc11eff3b8f56e8cfc9f313a7f41e197cd2b2719c602a59d038723a7ed21dca019ae235a43c965961bd1802128b05348ea24d1f2d12dd70fb07c7fb11c6f3104352c9563465d582a8ebc0766b3bb0cf8b934dbd7681b47ef3903d6b0587f3674800d29eac91ed51d1be11a29f1bb04008c0b4a825b66afec955eaa9b6fa3d8c54849184537712885c00cbe1a635bcf9ebd688742299edc138f3ceeb6d82691655dc760c2f036349db77f03cad2b3d733e74c18468dd7b613227e57a88f23c76d2634c5a6c69cbc984d3381adbff80538d1288116408f5b9e1734f3a9e95fd5baf0064d7cdfb3b0df6fde00da3654291e0a6b40ec55f4efe1b2b5e8083e525a4d502f983e56522140b3b5bd32a57b6176f878cfbd89addea75e28f634d5c36119c5cd1056903282802d63af74be60638f058a4ab42e39d16908897147669611eccc031c69a654c6eba8659f364fe3ebcbf653412161f5f7e16c93a96e0e9920a4dbc5c2d0622f47a7be8e290914d0d94986f63ab2859fe113a911f5296c2fe390a27721f14c6c741fcbe8c10a669a081f31aab31c1bbbf7cf08dc794ac98bb8e69f6b9927866e5ef517c0fb7df1a7b8503aef69eb241e7b586762c0cd90753a6694e4d2d00ea3b2fc2b46192141cde0210adec247b3815c90d42759cb78c9dcd8c6aae80f7213d960e97417e10738ac27672698a10bd7724f01278ebbf10934d84ef21f018fa99508d5b84572149ba6dfed9bed69fd3db920e2aeb2d6412be6a79f5350690b7f55d86ead30fb6c24563e96bb1b00cae43645f47ff99553c463857a18d4011c6bfe1c4c18672bb61e3bf1dfd0e4a3d15259093b892b5259dc2778193d72bd4f214d7febcad13b27d6567e084934ca99ef089f2d12c60e2538f08dd4ee369bf1d31c89ee9d56513f36ffea0e46879acf173bf28e2823e3f4b27a090c6503644873dfd87557956486b00331f6a5d5b787572309a255aaadcea7623b059ae832770db71bf9021e71f0dd78b347497e0dd70ff6e4a9ccb7b7a20e791487ba8275c6551d1fa441c1666a5daf938d35ccdb9420a2edef74d0a4337066944ddf1d667250ddedec4201ffea8dc850d562cac30a074e403bae927eeee119ac770dcc1b3e0fcff45ff1ba1327d4c3a4b82cbda980bc33252ea9548c5bdeb1fcfa0fa5ec2c51991a9b31be863609b6c7e9524c317f2509aff0886eee6035e455ae4b7550931c86041ce98dec60ca9a9bf00cd8864d67324c3d980e2c53f43e29e73579d1070227a8b11e7fdf5f99004ec4097153b677c5a81c3d44d7a981f2f7ebd8421bc19b6ac6f5532506e89eb02fc840e7426e69ff0b33d391150fece2d7ddba10ce3d277e4574fd9ddf2469031947aca50efd7d0ced01e81458f56e10a7ad2454ebef499f95271013eb23a84fc25b6a5c55816c424d262ae36d2515306627bdedfed86ae63a851bfddcdf6b608163da60fec6dc6f571f8c98e940c3a0b57a4e6a5a98a799eb5b37ff786504813c633e11eeabf0b6fcb04b297a46c3e5e9693b1d4c8efd9cb7d1e2f7eb4d7acc5be172a8ae346ab67d59fe6320ac9e0bdad721542a37dd5f0dc1b8b1259ce259dc763bd61f38ae12762bd9686b56f1887c19be14f56abe13e6908b64702695a4240ec4b46acfb8ced99d04f8dd7c65e366a2f28faa196b4ddb7a5674641ef50d15fce7bf512bc15500ad8358568afef32e27d7f286c987e411fa54c43d513e6699f5db469c3d1022537be488c14d3c48b46e7b89097aaa4749ccd1afa7469aef1ad90dd5b47a905f5cd50a9c9c9da6f2508482414314e079d68cffe8c62792cc046f2ecfd099d560de60540a963ae8e3b0d42818601408e019d71a1e92be5814925a030e8f76aac139c4660998624764026fe379f034a1dcffdedc3641b3a802293899b242acef6b669542fda32c1a45344e3724a9c6e1007ae4f746d16502b7ed1adc3a43627e4d27e8881076d2fe16591c1f8673545a311322f965bb872abb2c5808875c1de165db390c7f2e4dc9295f9d2331816160c63dae99660e5d755993277337e1ca27f2f89fadd4cf9d7aac8298043d7bc406209f20c513c50892094eb6ae7edd58d4769f07698201c4eb874e6ffa2e50b78b479824c94e7463f2747f14fa122c658d3294adc78a9ba232a11ce166cdac2623577f50f37874d8781af1d89ec1d7999ffa1b059930e7d09794fb67ff5a3bb85926ed416a10113c2303323854ca24be1204256024f2f8c48dadb86a1226bcc5836a1101d5e317bc8f2d7ef77d37539c23057f03973d0627921cc3f8870ca77271003944f2d542ffa900e44e8172d3b200fb6fca2fe4548f7a7f39d830d54cdb5e273e8f08c9a365d122bcad90419e3565d2ff93d5165c6dc1d94775342af21c30c219628e0d4d56cd7446d989474df0cec554859907f60b4d7a81a4b7fdf9a6a0c2a859f31fce06892e85434b5b417d55c7fc829550240a79ac17e0b1a926b732c16115442edf81e66741d5f179a64781196f9d947875cb9954f138f3ca2bd7e3caefb5975126ce3abd689c878587b0e4bbb4b6288544d42ff45f69a862fa0e1262552d59345c320b454d1b9f83fe6769a81e8f7724a9396cbb88cdcc9b51c66254f39324ebf7c0832ecb7efc07ad07450c29ac64c142290a3936e284f3dea4abcc4ffbb5ed2f506f73101c5292f34205034e09ecae5e31e3a5b17df0b988bc4c33c3f39412ad8ff09854214b00eef3ed1ffe44bd1003281e1107f646e6df77bdc84591b512c6833a9d4e82dd63c4c5f689c24eadd45523402d4a2db818b8504480da71548cba17d06187186446f6b29c301a846ab14c88897f5bec079fc31ec0e7d2fa03692be1417581f5623b3a225bad6eaee322ae3c075ffaec58061ff3de9f0028e9897139f469a72ee12f7d24762ea74b1b4ec2acf93b079671bc842bd4929960779ee28f072c1fc642f382e7e7b64bc95a24ecdfe9db4d5517e687ec8c29a0589349745846e88e43301176f8fc5eb38dd3df724520320d94230698d020ad088a63f3cbc187270d2948d4267d20bde2db9d6e46b07ecd0b90c2dd824326f7c89daca322f7a85862e31465aff3f25b29a4968a8b0e141f8567000ca6fad9f804e607b09b7beb8940a682a40e65c65d68693a0ebb1c07a5c3f531a9a6da3260665060cfbfbdb0543926772c1b65e368c012c8535c8428e4b804d1d4fbb009b93091a72883154626750ed590ade8ef04879ced820ed5cc5ecef9949bae380fb79fd416e389e40226f1e6bba549a8d356e7fd65e28150f96a823c7f6f759431948636189a3c30c504d4283815bb03379b3713376da9e7aabc4c3a2f3bb01adfbb7f165cd0b4eb6e725cd9a842058cc1f68e5fba69daa3bb2b7b2dfc930fc06aa9e47a0169d2e19d19fa8129422556aa1d656e8b35d67dfc5c7abf209bd8a0caa5d8f870de138e8863bae94fa151773c783db940618b5c0af409e7ea7a4dcf17df32e773b76b1a7db02dceeabdd02a16ddef435d4cc3f9ca471c8c6f135de7ad9611bea794135a92ab3a97014b906ebc43650f6a2fce5b79221eea8b7e99cf4dcfaa3ac44ecd029e2f4eb64affedd06d41d302e288a2eab6922b3444c83e8e6bc38620b3087efbdbabaa2eca0cec913c5f328381c8db3546396c80ff2b3253271c504e6d21e8e1c6093f93b1916215df658dd9506e81ac1e03678bb9a5a59dcb9023fdd140f54aa7b07c0b2e044f61cfa9ca05cb27d0171cda8e45a47b3ac5af3250058ee73eaa0890df08284c4f9edec2f0ef3ed2897b9a93d232c89a7a0578dd664dfc6f4e4671a387912f99ef9fbdd1aab7094dbb5a2caed76f1fdfb8055e8a562248227738e439873440a0c00dce725f7268e1b4c237a5bacb4e8514497a3a9ac24c5224b56753f620894b6e03a71777aab114f86dcdcf7212d47d278d7d63753a2b019d42b11c53a24b09102e235ec5540ded30e81ef8d1e034de2765174ee89f92a359d862d614e2e0558dd6977f21111c51dad38985a20aa2d2cb0dce67c67fde1f53fd79828906110448b26729285cc2139b1fbf7ec84a7abe1d21a26cee80e62ae0ba9b12fd75fbe9c2ee580f088403c837e5681e6d4c846ba61ccf0911c8d6aeff5f5ed43ab8eaa3443de85a5512889b4f2876d291cd8849de9ae218cb7f28b844e3e264d97b63d49cba59ebe8d77578ac172c1d689107b75b942ef020c929257fbdae0f0e2e8d3d5c08c1c60b1181f382fa2845d9b393189669a7323f8e5fbdf950fbfd10ba91b66f0e8d5245801bd2f2c96d6bd7135a8f27e346d14f3d31e88d5395f61e4c9b7a418c7e1f8176e8c7cd9bc59e4db5402c875f0426530ea5b0069e956e6f0f46251205cd12a926f256bcea140713166d7a7698ee5a8b93b7ec87dc2eb060748581945640bd7eab00216a634324d82cbe54a69a22d210451326ca13a9cfa03e23f68934cf0df041ec15a97e08db67f85e7214b51c4ba67e7782d94e6b1b12a03e964664a85c470d294e5a459dc757492ddea8cdd2c07f778b449157c132d3e99f707999d8f068df313f1c11f19133272a6df668150130ccff821c619244f529a450445efc4165c32914c37ef950e803dfdf234d1265fa860d1cc8c470564ab1cd6b0a0333d3955890a4ee6cfa431a08182d6a19c1dc877916e458fe3a0cfd02fd701b24b8e5d8717b44e458acaa615b452ab7c2245158bc8e4544710b35e44a91a6c819638536639261c28529baa1db6171d30d25dbdc32a84a90dfd7108e6f20a55389a8510cf7c0c2fb4e18a41acc9efc463debd7a1cec1894beaf52cf531eaad5077d156fa15ab75400f90647681dedc4c9e981abf6b33e852dde3862ac7b1347d1cfe0bdbb24b0762700f101492c4ca28f41f53ef42ad8df641016915840eabfaea1c030603bd39f3839abd8bad43c953e08cb1e98d125d861b27737b6c379f5e0d0eba6a4e5f8cea6b306d17491ddd0bb07f98de5faa6d48a918fb6c8c9dddc137fc9a069f8e8aaeedc06fdc58fc506774607c3cc75e68398aa81bcb82be37d7d3c64e052d3d521bd27fab3025e63892fe10f42437434d3b42374e6709480f88ff65e89fb0755ebd7a64354d6b32e093ce58372497eb05a75442988aa226f8bd9b82e43ddaf501f41a16d65e1c28632b8eaa42b69a84de5c06fceb8ffc8ce91dd084e2f3e4b6e6a92ee89d0fd950387ce25367e0c7bf6e7c4b6570c07e82414d9c41bb35ea6cfb572c58645d0c6401ee7fa1f849b7dbdeae5166f75bec1e230fa0ac2f435217c35972fa674a4ed4dc3d0ed6e690ba759641033596485bfa499b60dd34dcb0c19b19b27a11c0e9ee1733793ca8cd605f226e4785cddd2287c95af9df09216b56a26d22e1a3b778c2198019f9ee9d031341242864c1b7c9ba91a76751694ded7cacb1869e0ac621ff981b2a2b5ecf60c6f4d7f3d449d9a24615a0ee8ff98b1c4b53196529976d65139ed1065aee99b142f5342344d2eb9981529e0cd989c04e7a6e522afe38a60ae72cc473fcd6e33f7d63198424d17a2b3925f245eb8f512108039e336736fb4f5cb7c2a59f40e50458417aa8e36f0a4c9591b7667813e9d7bb5d7e84fb2a97a93701141616057939bf82141378265e517188c705ce917ce61c19f0b97736d4981dd059a87eba17e55e7fed7e8b84bd40441964298304a8c597534975ade6c574f089807f5cfc60aef969ba1545d8bbd6433a7cc2e24d5204efabdbecee0ed4f131ae4937c092286977f8ecdc933e99adddaf6de28de247842ad364910e25dc528edfbd667d25a24e3d5684200f31b11df0f9eb152c9ab46b4c16cd321b3f3cd77cb0eb831a41f45c753338c53f5a256e1b9db6c6fcea6c9b341b554b2c495314c7011193cc4355a68a55760b87293148f3897ceb8bdad40b04caff33f2a02a53c43f292bd70fbbb4e1b2cd1f6dff8d491c3ca9df5d20134c17bb6527eb14e0badd482edcb4ab3c0371b64ce3d6a1107e565adae28126be3458a5f73185d7e1bc4fdbb596d1bc4307075317c5069df7c75ce5a47bce04e00aea2419293f5e9cc3b740edc3165f352d2f285dd58cb34f23f1b33d680794966df904b2381f2aa36c89651ccba2ae5e8d203bcb9274fb289aa94b367dda899d8b3e24c92092526268e9ce8852607042f3146630a5e8472ce4f0aff85d931a8b87f7c57373c59cef1472e2628fb4f7b581690c1035de069dcca4fef4e8bc59e98d9e72091a64d6c15ee0055c75f99d31c7abeba02a01c03d99d7958fffbbc29d81f1076cb242d18e78c57692a2f5958a79989abdee1e73c3b50dedde6f06c79cc273caa4aae2c7a0bfd2e8159d1d5df5cd7a9b772d402b2d794593b392d4b3d5a8ee3eb3d1aa33f71ba76aadb36f365c0cb868d245507a7fb3e6f0351cb5cd502d4e20555304d7ff396d6b55842fd6ec51ad853456f677f47cc77a6bfa213520455a2ee80a17c84dcbf22042dba99126b96b12b3f4d77feb29542c4e72a9db6dfa0cb8974fa607f40fe15d2eeebda07634e5cf1d9e7ad17c3f31f5db70b312f4acc2c1be89323f9b7b8f0d25f75e58d494ad31a9848d0e63a61c04aaf60215f99c24efd9d113a514ddd8c82a18356f8ebb2846642fe0d6a067a74549545079826ef33e155270898b57f899fb3095df85fc40610d72da12af845a53bf40430c54ff9efcae7de1006f303a0e916041e22b52676b73ec7bd04bd1d0fa1a5caedf9ed2995ea8088d56a581351a0cffb078795a3580f26412d57ba2c67b2eb762f3859d06f3ad6607c7b6cbc92675b486402d9e19d9386b15f727019ed325ee02fcb8ef1ea7d1009b7dbce51f1bb7dcdb0042d66f7159977036183c5775b836a2c8eb958237bf4db6330a5752137769cb52f685b664757c97a1bc3fbec00870228056cafaaf68a58981f2891389a79026c2881068bfc34f74351360e95d2130afc2a66d2d6726d73c71e96da172cf1b9f8297691b820ad52a21ade29e8a4eb82e6bfc98c3441709a913b26a73f4f6dbfac2fbd37bd67476b0cf71970a9d0e32fb235b5ed0920e116f27c817eae9dca8127b0d0c36260748252e5e428d3139de3d7077443b4efba8f56432a5d57bbf663f27b1af94248252b28d2dad62db8d7e3eebb0f1a33469a54d1e5494d027c9450a635ad73228f28793319c0cf63c5b3e340413c96971c6088a76d91b5a3618237e93fc1bc62173c1944497c00fe7e67920586d365a53c4f66a5cd3393305cdc09ddf685f76f5ad0e056f0d1eef5173ff7c1f5af0ab5a6375562f926a69e1553a2b6fbdb0863ec5fb13fcff2dfa943bbc74d168420ec916b270a43634ec6813711d65924eef40a6e211dab30c4c723eefd3aad8b136dfe7f875ead4eb177fdecfbb285abdba9cd4a2c4c93d17c1a89cf8fa36a9b56f969274698694578b55d14f41d7c6f8a662e5260d155b96b1c7c4640351251de337d49ca60523ba114669cdf5485d99fa38c169963d82cf44acf932471b2bd77a62e27d0c3d1e525eb8ad0edb81b0d20f8978febaa0043b0dbcd5f4f97dbe69da2232fdd5d60317b0708d40a50add003ab4ec85f8bb63658c5c8535e1cf731e1d39c32780c26bbbcc55daacf14229ee6a2767a1c25c7614e2bb537eea3e64afdea0369ae2d8f7e8a58743cd13ddce65a61564192aea4ad08b2f87c04f9b0d30a759c5b4135e3f71df121d96490980d4037fb4b5bf52d8a04d1ffb34d90aa334d727dedf8d36b5c591c3599a575e23443f853fa12d995fb2c06a6795d3039c7920aabd7b0cf2af10c075851cdeba9144a36062748e8a0d6bc06dd0f4221849fb473a05593e3e0dd898c635d473990e5d59b2001799e60afa6d18c7013694476b10cdf67f5960c1947795a8c02d6e85ac90a72889602d73ebc47a38852596e0e2b84c880eb53b244e0fb2a8fc935f5ee9b18cf52c7271d2b4a9ff0fb5996b859dfdf62389a0a11e5095742d297c9afcb8a68c72bd49d49c227f0f019bd5a4071c059f352964bb90a4548815d77162d73d8264d72cbc732c3ffc010f196e96220a774dc9f90d66ec2b700f4220d8623f94283b1ef6831cd7e4b0c62cd65d19124a0e3495152bf7331c550f70e27a877cca2c44e4c2c9e369971cd8cc877596fd4ca762f0b03aeea452d6ea9b75c7a0c399f2b3f3263bcb21ab51c22ee1b0c8f9bb8e51a6ae5fa455e00b556f5587e6cfc3f74e1d849acc79fb856c06d1c8656321b90e9d8ba455d249c43f3c2482c3036333060a34a9f54f62594c3f50760199f98be78076243bd4f80527e0082cb4ba03f641b30bcef4c3f73f518956b9d8a042ffe57a39ea194e9da3bc28b5ff9b8deaf4c5bdfa974cf776a7fc481c6c9298e20a7987f869c7488f9fb3aaac04156321660977c8e591cbc5c473824f80162ae77efad93ae1d14af06a59a9f21389bec41e5ced011a85a5d84d8ab514ab5a7973b226c1cb402422b6f955b3c87221ae99f8efe89c954a770c2aa48d575ee2551bd3b5db258fa2edc284434ce30aadf862bb33817931e98346e906da82aaf495208a6aaef9ebf028d93f4ff2039dc34b3d0d13043e8d90c0620ead720754c6a365aea9ac94e8cf78e7daefc945a5cba10e7ea9cb190250a7515eb386070fbfa71abb94f4ceebcfe40172021594131e8921ef5a96e0b84143903bda6c2255f7014d7e8c2d1550f35908b41e86851593f948d7bbe3376926a48aa418ccd043f8f177460f79ac1921c770c4be5ed92f9c7416ae4c30c87e7d35f27d3236caa00e3ff77ca0b625d46f7f6ecf785b6035d931c450c5144b25f0e2f66d5db3a739c6c6098c55708c380ddd5d7abb5d4cb53c56f11ad952af31ebb487ed8f8a86e52852b53a7a0155486e1402f2648fc5aeed798fb2ff5f79b5d536b6ddb5d490e981c1bacea30f3f5184","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
