<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cfc33ea92df400d6f197caf634bfbf40a730542607b97f84abf4f4dbd831a680e02c2d8277788561cf609e43e2ef67383afb0066c4591f86dae118bfbcdb7621b526fa099cc48deeac0e093cf229017cce1d4ad1fe303e9b8a26c52d7e1dfcd61eadf71736c438976c82c2cdbd04b9bd63efc653e3d146242be2ca3b6e8529f8ac5baac2a0da77ae629462ebcad0d2fdd35a9c0da52cd7e0ff462464f9c04321de48628397fda34f1efa8fc194544cad14758b57616f39d08ff3c0c9cfe70e82b49a5ab75afb59539b27fbd3d62789e2dc01764514f378763117b6ed66715e131132916dcdd14af6126d99620faac9e385bc2f0a2eb0e5e7d98a389d590de30ab8201a729c35b9f6aa07a5e006aee0b57f55189eb559a532696b85df5988d9345f41fad81ac583f3ccce2da46ec5232674969815267627bbc00c72b0a70d102a7c6d0bb63efbf336d6b5c4b8f475110c0d8bc6cc849742e0f283d1086f9ed54c6388ee18d40610d99bddcd36eb4bf423df6649a92f0947892b95cfc66e72176edf839b02e2b683945748ee22e06f09a8895c82f6d64de6e6815613dea16ea9de33e7c59689b076bf80a3dd868394fbe7ee88a17ca7e4e55116f0dcfa4606c76f17091d00c33ca3722322e72e2acb179c3cd9a7dfe171db8ca4e0bc5f22dce03a5eb43fd2287cbcc1a0a4e0a4bf6124c9a06e4a0ac7084d61f8465eab96eef2ea55a15a690a42d8b0003fb3e42f39f3f5332e4a595c996e2a3d06d3ae92a4d85b15cdc26860d70a3771c47063c606d750cbfa3201fbe82e40c7f21d88a3f3a2b247c471fc28ad4e2d50126c6f2dce3bd07444dca75658f03b08bb6eb47d3f67cfb4891a7aab99abda1dad72624c8cafb69120ddcc42579e3ec663dd6d21527116ce7060417a24bb2b67770191640345029602da79981a759e7c359269cfb4b21881cb76dfe6d8512dfa5938608246855e6c6c326edb064a6418d77e8bf233594aac26be915c2aae4ac6ca445f440b26cf7b2d2cac983b92f06d650f6cb7556e59959749b898e4f83d926bc2db1ffd59e1c38042cbd797285e530d192848773ffc327ce222d355e7840e5e4482c6b47e4ea0d9c78b6c5a0962405eb50d793791a8bcb23036184bca7fa28813da4a7ebd019408faa49b1a5ac91c13b4bc6af9cd276667472bcbf32453e017ab1cdb91a58025acde903f7bcd2b341ff0c9c69c95714b9e57e842e98c5c48f05c4c10efaf192dbaad1212529b7560f4b25752da7be8f7ebbf8a2d680beea636cf500bd52e6e509d850554aa8633836802be06da754bbca399420f0b609a43b23f63138dbbbd6a00aff9b2211365f70a99b45ce477dd2ea3ac3d74b329eb8424b9296e73430c52d81d270fdbc1a36340fa061c58164dcf26e27f9cac92deb61008576a04b17e302abd16f0d13e7dccf004f4da25f7673a9f0937d6f51731785238178535ab27933dcdd5c485d567b0f8b5ab946fbde5d57af559bcbd89d5bcbcea9fd16ccd8650872b9a380137283aaa0e9ca3a23d1a434e544c3e1988eba3d55a84f66a8fd4b645bf9de7ae01009cade7bc0ab8186f74abc7d0ba127571ed247d6f39bff76603da9db1009ca7abbec879fd72345352ce6460087e7577ef78a39038afc6b48df9de0f8dc88ba917cc4b90198c30005af32a5f79c3cdac71168f9556dcfd23518220925aa12bad88e7baeb554989f25587030fb25572ccab4d44c8ca4fce5e46520448e748392afb2d1fdc63a2c72227ae016f20c0a6621cba66dadc8db1719808b1cb36562e8cdcace5d5ce65a443e9098b9477951203bd8fe8fabb3edb2b0612369439c59cab3e27b9b8ef97d1561aba972959eedbe2af049d8ff6d8da3515eaa81f8e26ad121bd886e6d67938fd7d7d62c8a4f6f627bd53e2c86761e52784b5fc1acf28c8eb735820eb579148d6ac6b7cab07dcac2efa689fcba878e6fb79b6c4af964ba64983a5bd7923e5dd5751d57aa45c31b46df7a04f7e4b31db2406452e8434d1bc8664ed60ad94393525d3f2e5c695ab8364774ba45dfb9f203885a20c4369a3bc17bd5d86b40bf3f87a4fc1c921533cbb179871a673f356d76ebb284db775aafef63bbd67689608d220097ef7969f9425916f73151d0fe85b64ffbea09392cbd44db7af894d98437bf60835c056d4ec3ed18d9bfcc46cdd5dbd14856348ebf4a03f3caa1b25d12656d0bb6b0dd8b4d21f8f659214407dd5a3e8f7e2859cf85343fe46999f69f9b7a5259281150617e58358f8d216c03d826bdfe6c56863db6a5eb5e6e667496232a7c46d67f5a5f1ae81631b8d5ad3aa6c9d74fa3d49c4f43deb1b891ec2afb3cf9d6849904ff14211f0d8c49bafd963ea882b2dae9a50b6236b232886283949079af40a2e8210fbd31397deb35e82d999c75623dffe3790f9b5304e246991cdb10b6d531ddc202f13fbc782453cbcc94da0714e5dc858b31dc23d5cea2cc5219eded06f7f7e51591ab75641e229d49ff682772b9b14c32e263d7b271d3baec8b0802841ef204226b5b743bf96f0e067c0f001070f600465014e9968a4750078aa2c19a8adcb9bff5919ceb2f0846f67d759b7dddb01742756316bc1de27158ae03808534e14579ce36574aa3e09c1ffe0c8ec4004765e7007391ffb1f590884d56cd84a00acc1c1df5d4104ef6977a4b3de30e62908b524ab93e37fee722ea555dcd4c96d6ac97cf11893be0f165d8ed2b2f6d2f7d3edb6b0a14e7a400738e038bf99662ef3105f07752870cf7542fa621bb4aeca46148536e0237e9059253bfa741499ee076bebc27966055ddd26c0184ab3bd697b3e6dac0f184d476fd9aed18112f9c103de3fb26b2dbb008f771c40d8c91ec033edaaea65a002f0dd36ea4f5048f83c9d284a6c5faf25fbecfefb7de12bd7d8bc6849263e063b33eeda7e39c5bfd2e085ec3ca63e06fe0d5d86ce667ee482b10bce6e928c443796339e429fe9af09b41f3ab39d129173a28cbb94e1c4f76630376121ec890daf93c4fac5ecd3291f6db116c048ba1c6cd38b63caeea620f6cce0c698fb20da335b9a03d6bc98469bdc50a62ae81bb0c7b06c32784ae7f68a3ef53306537f46fa3242fc1c53d7337954d96f4b0921a70289cf081d4a9f5da4cf26fdf79a1057f8b88b6316001926fe077e6d4a590b34f40998008bb5cc02ce17f3ed5ed166134f7a65441f8dfa70e199d06932d7d70eb86e7d57a3ddd56a81426bea6d9c94ea991137436a6068177a32758396c872f569b71c2886aedd314b983cb67a374aad29235f3d504b29283930dc76fbfb68b5b1b1e1f5673a7ce75e4c3a343bafdd3ad44c603abbaae62890ba100bbfbd94948a995b80c578d837dfc7bdc973897e9cfaebb950209b7c0304ba415ab23b8cb9dc7a22bedab03a5b9585b440b1a438df1cff89c90560c0309081c2b2776aadfd4ac6066ff9b3233729b6c465ed6e53eadf11733f91aacebe9a870b84612ec77a8f549541289dd68a21059c7cf6b210d22293566675db309121a5b55b1fb787238b3516d7b980ae7572935389063b8ecebbd78dc42314fe1f64a415ad5963faae9814bf1b5b030d69e8aa954b78e32cc07fc815cd83ba0309b839c15ca65c56b3f4c796f6faafeb8c3766fe959f35c0096176ff7bcd5b9fdee8c16d64bdaf02a98b84942c064f663d32a44eb00c4bca1f35320f8c88afd38a6d89a0bf021ba2462fb708b15129712a5f9c83c8915dd8764834f36626e31019406da011b5c1e4d0a3bf53bed9092ffea9b400834dc60c85fe167eea404f60abef614b31f2a46d3fa43d22a405f3fd7da42b1091be9abac59fa655743058b1574e83ec92fc65c689c3101d9ae2170e15434770906b3d19341c7b38928e511631d402e9ce8cc6563f32a1398c59224b8bb9b9d21844169a29648096d3a63fc78082eefa6b4c408a32c29f3393ab95bf13d9f80670e09dbc52692a234bb918f9548c267e3bdffa5ba7cbe58ccfea4210d7eb48f2d39b00b63924f39dfbda52fa4a13a534141cc7494686458aa5ed211aa4f3d80d6831542b3ea1954f89b506979363ab6b77fa84d26e392f7b91c72fee00d29a885c1d1499ba6ca19767d96c59f9cc2682bc28d4ca34abaca4217e85a738eb62dad4f52582536b4be0123bd68a338c83ecb7fdcbd22a967639cc46bf07fd979e6cca114c0934dab80504f587ec97a6451667241d4ac838496201d7ea6d0f16d8a3307716b367b8699f54da9cbe1e67c52b5fb16a3ec5d7f7b23603c1562cdb13b763384606b31f620098afe841ec826ea6180f28745022f89ee569b028661d1d464d7b837e71c9a350970b4d39ead0d8ceefa23913f92bfda33ea10918736ed11ae38767d052a2e1de78ae56ea139706c4d81599bd0b76aee957eab96e10d55e81f53113b9b54686638edb49502418599385b366fdfa41c04518dd727a2aaea596c8bfb3ee8b518b12ddaa51ef92b293b8ea0208b5cc64c8add755734858c1455962ce952e250134c2f393c77ea2c0f302b59b0a115c8612d36635cbc6caab5c93be868b82f2d81063fde8c94c1124487fd283daa7072df46e34cd99df2b1d048143bb2ed8e1e936f0ec2e7bcaa1f9afb694639546742db5ed208a8b4dcc20dc6da3fd7b0bbaa2e579ea13bfab441cc659c2f69199e47864c222b4743209fd730b85c8ed4dbfa2b8d25108f1cff40c697605e1ebc98c7fa062b7aa3f6811d0ef749f9271f3001ecd718a3400edbbd191ef67e1e68bae951bad1f0c372aaff1135e2e65baa06bb0be62d09ab9b2814b96ba91aae371820d4a8172939a8ba550803b5f17f09ea2f64299a031746ce8e9a423af39ab1c0c9c5d978e1c339fd9939af6306d7e53626406eb92c6f1f7fd8cb984dae5cf6fe9f9f93ee5584eff417b5efa7263fb36692f7d1f0807ee93106e1137e1ef77502b9341c52dc2604750e15f30b553e0c2b4f0c09d3bb9f93bbe6616ff3f41e5ac46966399f4c98e68a8b1f8f2a0c1b16b19e4e7d0d77e9526142136b07a848b1ddc9b2116e5fcd204c6d868bbf240183fd55ad5fca41853de36302bb70c60813a11b2c0e1cb0aee356a3072ccdfa1f333ddd3788c62bf5cc3cd27c864476d4afc3ee7a5e321a072c86757734ee831be79563333221cf11ab6335943ea3c8f53a611663a2164665dc4116fd102777b0b32085e363fc919ba9575fdd8ffe2057b97d1165c467335338d3569b70d91cfccfddd8d2b994e7d23becf615f720b86f004e2b604f81a9a21be1ee9edf8476967454838eba494a1e9017b196a22f07650559fdee24c496cffe74d46cb8a7db294ce91ed4e2521fbcaabdb9df8f9b048f12cbaf67f6eca5709b2f7c0df7d0e49d723c4424726be1874d3bc0ddcea38f3b4a253688e47e59ecae12281e51d937dd37ff282466302703711fd43fca33e7c1bfc873a359ba6ae2072c2d9f433cf0ab80016e16e8672923f4607573c905d2fc22523cf82036fbb8175b7471fec07b799ede9c83872593ff5e67f96faacc8bb52d575ae6f467a5847e20a6287486cf0d6cd2e2ae72dad293d659a87ff2fdbdac9dcdd4d4a5076b56ba72ecc303929a52ce10ca6cdf7e1e0273aa35249c91b2a44834783a7ef3c6b6a40ead977efca4444aef27eca986c9388beb6a5cbe5c93e7757adb91256af871b62422161cbddfd96874f5f0089f68522dba408dd6e311c07f3e377c18e36005bd161e51a53d78dd0292db567b3daf96b6eeff53ccd76d4b6b8b445ddfe8d2ede2c94eeddba4fa807384904adad2950cfacecf37fbaf60e36358a72373058c0c4ef9ed308f04abe4b37cb08c95385fb7bdef34d008a516c34d3f74c2b637f589c83af81916e46a77acf3426030a9e92c7825f47dd1105ec43c03adea17798df9f2a1954ffac0393e59b124bf1f0552a670e0eedc308423f1a9610a98e4626d71d268095f6b52e3841dee8867ecd60e4672fb9468d726c46a5c141a71547421d60cc107e9e1b02842a840411bd4d467cfffcb9e1d65cf98e9b7dee2967c425a05700e508a19db1ed9347160625c8c14b60fc964e4087573a8f17c6aa214d5dc3b447a8cec814936f4325c020ec7652e4d552db816f4f49dc9652ad31c0872e7e3dc04b1d08ed3d0239582df48cd8e4f4435782ce2df2c6dcd34ab387f803a41691ce4487d665c57309286b8e7a45ffdf0d1c52683fea292c9010b657874a855f2f4f8c950b930596e2e92f2054d52a1a96c0d9f19134e867145cac13d1f0cdbd4e58f3413d8a90b1b7159eb3a0db3de8f938d249f42e7beff2fe31de48436683603f4bc44750374f34a2d2b1215346f29627ccd072f1092e0288a7aefd3fdb04f3e24c69fd617e059c38acd095826b7f5e7e483b46382810c7a9dced9bb7f72c906387a9846918f5f6a13c6048c15cb96e5b2fab312677fff1256b7d582307b415ded038324be5f761c0b374a13b477b478ef18ce791a82b1d7532ef330a01aaa6703d503dabaed3b54f07370bcd09b30807668378a5ff4f7917db12db272d4690603e6be8a3c759eda0d641736756c8a3089404106f9a99ed3fab93b6b58b05c1ea56e4512f7ba829cdcf44742e7719127ff509d49d22b6f32b341ced20b9ff9cd8ff55b2cb580b9960a7e3768bfc4f6af12c967fca329283a8f9ac07ec88d3280a532eb40516b9aa2745a4d6592dd9dda543c627407e718240a8cdd316a263b2e900a8eafe96b72aac980ed5b4051e4d7fba5e8def9cbcf6b68f34c099b9cf328574e7167c39c9782c83fc846ee7fcdbf6de911a21b3c8ed414cb34bb5d510587698e1a9909c0a0bddcf14e541fde2376e19c6bf2b39ba21f1b678fe70f3105ed0ac5168541eddfa038b15faab159bc7561bb93be1bfd0435300277eb8b090548459fb3ba5853605d0e99385016786aaa53de1a81f2a266ca97fa22705b8898201586f3e2e88c010146173cb0adf5358671c9550f7e72b8ed90bd9a1cf79e0d9e9c8b292b87f83e841c4ad2235b64edf2e39d06d2e39c2146bb394e7a994aa4e5730b789928a5b81a2310eac65141910dda11c1fa437cdf3a37e4c175f2c64cc49e6e6d3d2a0c1ae2208149fc0c6a2f78414d02565cddc00470fadbc0d36093da93d9056f387cbf960e188fc9bfb10c56158724843b11e554b3f6adb48049605dc311a225cf6e5988f267d134acf90d7447b14ad632e04aea83342fa0e48c2f73354760e58b371257209c7ba59d16eaf6a8f116acca2091ae0717f62af33576a708ed81f29f61377f6c5719ba229b69474992f0a53537d0308d2392db10a0be3ff42f315da5cb6fa71f431e511be77506530b6e3e0391b9edeec90169e3260c7d3567d55a89686f4f1d7d5a496eb9b697aae4556af58f12c58a6d40ac4de3fdcb9355625757f7e152254bc79f22a3d4a3756c16fd5bc6c15acd7b3c5530c4c140fefee1950b6009606a571fc8d51209ecb546af3a058b06c494ee1660a512c3206d6957a3e7bd3fe9c6bc33a939f35bd9cd9c9be74e1ff7ad9788ff77cc2c8aa448a9fd0702c38321f1642364f25c80b35cb2304c0534c7ebb8f87ea0ea8772910a4e725f6fe28d93d9fb2e29852fd2749e693a7ee4a43d8307bbc20b1249fea17f8a8f04f55c7c5f3423420fa60cd7455243f4577db34b8404c311292c563bbfede4a234ececa163f491c4546b0cd84e4ad9bca3c873cb4444b2aebc308014d4273a76db3061717e461186f9f6e69de86a8e56808389e379aef2339d2101f371d4e9589a725b616f7bd86c1c816062dc1b3273de5eeb1723e0ab14e57a1278c83bac93e40c76be2d253ccfaa1cd9c03b72b1d69fd0e92839d16da014a4a3065dbaf19ec8683633ba7870f1ece147c60e49cb265aaa7a0091f4801462d414d98eef86efdd8c6c1312c6246cf1fb0af4df04f81996b41cae1ee7712324d9db69801b764e86b76b8be545fb2e3501059c9601d4177ac5096065324931d12f166d6b3b60cb152822d4aa8f58a07531a3fa061d81bd4568d6ec478d056bae5e0411123218aef649566d808ad4322a2152fb4fecd88f6459f62bba32f5fc177648a5cd29c257bb6a729a42866a3e3d0004d53cf3b8cfe80f921133da02c7c01b18bf1c17740732fee451f8556eb407b6ede17b6c4c6635486456a661fdd8428585973d0a37c174643904b692b5cb21bb2d208d104566ce789248eac388cf80743337a476590761810014a84d7fff3dfc3c7a1825405bcd7f0269bcbf234c5e9f7088f4ae39c3c94a22c5499b1c69d592f6c5f14ff8c8de4ada442dd38c3222b4ce00aac62cf14f307b9cc9a06079a4ec73748cc73577cc56aa75edfd635cfaf42dd8da181765fe6b0bbd8c51fc50a3b249b2c4c73f9e06e174189ae682610b8f9ee4178d67ca1e079f1feca3df65e2d0b83c0b43409c3e758bb24a45651d807ec578c6408ce129329990d6e4499e893957f8d45e46571d842003d1873ff9985f3327034b21fe7ec40b371dd7db2903176eb8b86a8dcdb1b08e0924468806260f349c27e72998f4c9a26894c29cadfd3576b17deb5c7b321ed48c50e737c1fce4d8361a0c95e824fdc04d1a18c274a6b8a8e999db6a2fc6e47be980bac2b9c9d20fa6faecfeff17feb48f5ff6e24a2aba8105d8606ae4422ace40f16aa5471bbcd6f350b35360010f5eecd1ba9781ba5be3ebe9e69341f37c6cd7f704a8a766328224b2c75e1fa3994d94ee6b400e596d8ad2291829f962ae44b89032cd0a8e1fa431ac306b33beb9f5536f8f5c867f3937316626af02cde4ad5b8774436bbb1b9d500887e947d545e12aeb8da7dd169fe6a4db9dece26d589215eddc36952d072f57c8f96112447c2b01683a42c2b00b5ab4d9a9ae55e7c31eb794c7a5b80afd1111d4932c252b766cf32d2bc50b20e004b28f7cf4c468449db26499f47334d2527df0043dc73f01609e279067159da35202f63992b3a9fd4c08b3aec5e020b4fb4c09bc73b7a6caaab02f9f5439d1d048d63c797f9ea4e015e88f9853a6798c5db964ffbbc698449fa56ed43a1976157aaad599805e7babf23ec348ff7707339f76675701485f93632c53057a05e261e694c7358fe7e6bc50b77dd6ba3d5f77fc5f41abe90fe37e68bb017760611e33e94667004ae039d038a8e0a47a4356612e106c43a8aeaf10fad87a7b8b04ead01c4307e5d631f047c02d9dc7c9793be8068c5ea58bb93c210adef4a947ea38543f0b647b289e493288b7fafd0d4d572612f16f79148f380f63645daadefd1d76845fb4f865508a12b9d77ac57f397da5e7859b7408b696d2d0fd1a074e569c4ccd808a220067ef4011106b82d6026b57d9fda17bf88a459546c3843c734b16bd2694fb9f759aff2aca023f49551330e2bb5ac4136de51261a718a0af52524afe294e6743fb1a1609e1528725ba1fce2c80fc997e94db026055605c825b9ad79821a6619438f377ff79562f2842808987fd13872a4bb22da470693386b15969d0e89ca6f3ee8d265d31e1887eac4c8cec7b8f62dca3c420dac82d7503589527c0e7ec921ce35012a33af931dc3c390fa63f106daa14a56e7ae0f3d60b7877a5d1428e81fa7683a1bf560bf54e275752726c97f6ff977ec0964e88ad7fe6f511712f5e89a4adde569ec538318e652728b32ee60212334a45b887dcb8b45b0d21fbe213adc75539ff023dd54d2f1254025bd93afadbe4252463c55b8c644f5ac061b599bbcdc609fa7f79e7894a2316af0f4085029e2b51e4e9a872e7e9974c0660c99db2fb33db2b0bf5eef6a295c1d772aaac44324a99a8b3f21c9399c5ec076d67baee2f74803b0fc141b2c2cbe4d0210b15866017a435096747b38281a6bc27f31d684e54885af902becda81f588e17cc15cf58e2af0b6550cccdc41756dfe726fe9ea1112535ffda9ea914c33f5cce10234b8a66850c453a2a71fb7d5dc62382e7505f0c2b2fb0f55fe3e66162922d8e58c6530b9ccc7f5fda186b4fe19336b59f6e20ba75938f0189900204224b9571795b71affa65759bc2f21ee9f7f12a221ba3c1622139300845c936b2224fc981527711114e4810395d77e2e4a6fa8142c48ff7bcd890c0c2e7cfcc0159cb1f585139f5d10240bb198906bbea1f450aa45d2dfb1f8d060db17c2c08e4855bc6c648db5fb770fa93870ae9ad3d8add2c6c082e1d62e95b43f85a057dd13f297904e7b1c672ef55493e7f0170e3d630fd9136cc88fb7e3c7fe740c5f66b39879915114f7f2d01916d5e79dbb5d867efa9ee14ade9a706a702d8b8232328338003374e392b6ed526730759a459a2e36935b69daa550127169e44624f453fc4352b6c04c82e0efc7c0f44b22e262465439eeeecaf21ea0dd30a39ebb9750ff782ed5159015ea5e648072b6588fb006272ec0d7332a0d1d2811a6b3195a0f4325c28b4094860caf164631e15ae1743f58ae1a2d85396ed21fef3442011b9f179fe6dcaf2b6d7a00b01e9129db2d0519f05e456825763d157795dc81ee872995d566435bda08c38c39af2460baa4995b4ae8dc559308ecda1740289ff12e752054544506392192f951d34b53e07c3e0580f8808729daf8f280f858cd6506f7ec05637a018321c560778cd53d4079ff8ff3a920da62b30a6a4f556191f50f59ab8461a830a25cd1a15d9ef2c413fc792388aec73c3359fe5f7524069f47bfc9fdff4e7ef2f0d937a8af75a2cedf690ed666af968c0ece1dba5e684ce677f443144c59be96746cb1f616af89f09fed2b81bfe10faa4eb037090b13016d2ffbe819fa2cf5f376cb5251bb6f076a528c7b245fe719271232f96c79e02fc98d452a48c006e006c378bcf95544befbd82fdbaeb7fffcb33f7f4757e2c5e48f39ef55bdb0d781e8d38dac489e14f4ea30b25165a6323190aaf6f20ba8871e95e4620302a5df00573d22e0bcbc8b55262ad138a957f3dc2b90c4e3834b9403f5c1ed851aff44440d91bf935aac2fc6848f440e524094504c0d414e336c73c856697a909ec66b79b1323f451167d3ac12ca033b0ce8cb3320e8852018414c043730c770e0eae819f656b60700b7f61e06534c3c0b06450d5bb660510079f214e0b04c99cb9eb7d2394c2722fff7a30c395aa7afd49e053c6e92893d3546aadf058da646206dd2f9bb5b3b4043531fb8caab713c784169d099d43993247cbcfce3056e7ffdf34c7064d7873617922dd14740c246359819293bc2885422ab03a65e99a9b58ee0949520dc8d8582c73bce7d7d872b9956a2d820c9370122e826fca33f73d9d182e1c2ee47405552cd622208f5db7aefbcd618bf44aa00278a66ba3e4080686439f107b2f547b2ad2845f38392ccf7db6597f2c406ff3c7879a4a9fd6970ea3e593521f8acbbc21e52be1be994e841f4046150ccf217568a3f9a690668ea55fb2092a76ce333226463d65dbeabfd2b3a175a56390b4b1fde482c31ee1b2c20928eeef9eab2066d9a975fb20bb9aeba77a819164e5241ec208d50284885fb787f9d182d8236ae5af1908ab4b99b0e09a59d0dd2b3835c1b1d5995297b1843ce89aeb110277d0ffe9dbfda63c5a7f00a5dee5c1fffcf285d58875509b6abb72c20645411628ed5d751ca46421e417f6b90e8df50770c34746cef87181712cc8c77c76acfdf6db407cdac477f53a4de40c752c4f8151b5beadc50d2eb11e09d557efcc2168745043b06266a42a9bece60b610cf4daf1f8be81e7ce99f069b2d59a757ca4c5d95464ba555acb2f45fdb2cf14f07a2a144c763124ce89af32007dd590c5a2249a5a239f82a000f526acc2b510bd0e6b02222e549457579b4e6a41f16e57103eb8255548125bd972e88fd85b17c08a71d966f8d685e93c242b2015f38bbb4379d25b26c580c9015f8978c9ad82ae4f2719b8c34e26e5cffdfcebb3ad8859aac2ab2614df71831511f760e9ff57d2420450f7fbca00219287ec29968a18796384e5d90bcdbee4ea196fee4c8ecdad0938101e114154dd7ab857bc9a9328788006e31e858a11e0fa5ecd9cf1a56da8d5b3aacd2dbc98d1ef786427e169b02b3042230474a8b33fa453d3ff0568efa503c44166c3abe4879fd092e33ad43e77a83509ac09f4b3b3f309c26a6cc72df1b718b3018d8caaed8212a7a62566c3a1ff00aec4721bce8686d37bd81f3c45bf4058f268c124d7ad04e7445eeab94366eebde03ea02da2b54d77014fa50612cf2a509d955d8a3307cdc5dcd9dac34fce907c1b8e0e6fe33ff10fdaf682f398a6a6f1138d47dd3a3abea4b2efd808a304780d72c78880d09ae69d6543926732a0190775978ee9c60fc11014e269a082b311c48eef0d9f78359b7398dd64f304bff66c80e564d1cd90223bc90df333eb2ae1094af11d4df5749f8c05fe23e22f0b7b8c55c5541101c1b30c16891b282fd837f86dec3fa4c971e151469dfbee507b10add2a2857da32ac817bfdc524b9f720bd3f24cf5226","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
