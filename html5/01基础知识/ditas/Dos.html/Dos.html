<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14a28e6045d607dcf798296dd5d8d2187dd51a64493433b1100a1f999223c297a75b59d37186a3a62d546784f51976c7e11c64decb13c9a03368f9265d35a6e1b3b00980b5212ae9d2fc0dd07bc280f4483788f3d21aebf1d63cd6618fda48fffcaf37509323e0c91d6431cb230725df3676605e853b623a880cd8d5b68946777372b20c2ec71dadd4dc8b729ca45be5de881f40cbc17432e726c9493a5b5c62c0f00009367aa64b50e6dfd1d089b524d88793f692e0d0c5628426e68144e5ae4e55066a680b7c3678c4f8c6b6988bd52cc97f49312b95358531140553dbfa67502827568b693039c79cd8e2f50b61adbeebe1cfb626fb94ba4d4c6fa57c59852f14e4f934fe07203d091ff3317e13f01a4323864ff01119bd976004b13c36a60b175d674bf1b517a54dd1eb72335ca0c0cac949c085c6beac3f0b089437150156c9554fa64c8e500531727fc8ad05ab9d7ca886d99c41fd7c34925a5bd6c43cd2163e4b07e32a972b183a58188cdf1e1c7ceabdb4cfb6b6033f85923e72bec9d0c786d4a8149ff326ea5f5c5fdfe996fa9633c1d015607e12c7c23ecc7d98a669103b6cdfcbeb39154357a8bee1502f0c789797170db4fe7be34f33c39ddd7ee8cc1603f5ca35e57878acd5db8b4af1753df668213d8e24b04ed37524367246c87def796b70c48c7fbf26913db5965a756a1fb00750a848cbff404d077de133de73a0789b718110e578e024a1cc73b5f21670ee7b2898ba8c1f42c00ead0a477efb195120ba185e26d2b469acb85198dccff114f5eab60ca61b9ff118fb91ee5c9b7675c2e3a234eb0678a64197ddc2a8ef83d732f291a08482cb10d103897b2cbda76309e6426b83b7d781f4d661a364d48277472fd951b3b971ac7845ce46f9fbe906c78962d5878da77d0d6445487d5675a2b53c511ff333ebc9674eec66d8d49163381ef2398a879ee5943ad9cb8720bd50ec23cf425cdf10dc78e0c7b141cd5b1b2dbce810f5cfb8bbca6376539cecd744985c8a2b1e60a06538f278721dfea1343a8aeb9e8af3f7b5ca1e28954b92ab8822c296d1a8c971839bcc02afb3bd328693b0c27f7b22a079ac1eec6d1dc118f598f620b501ec70fc72859378a28f06b8888bc3a7ea9536e9e1dab4ee31166c36aa01daea33164915034845215c230000dea2cbb9d20b4a711b5dcf2cb5bb2b210f6c29c212237167cf595b728cc1743071494a2749a933eeda12a8eacfc69b5cf209ad8fc099e008c33500b661bd3ec1322ccd0cb19739ecc93bd5c3fcf24ee9e21951bc2e75aa5a3831c13260750abe5d97cfb973050900c0a5482f4ba2633b2214f77c962f927babaefae01d23c452349f45b202b4aeca2e39a8be5bd137370cd56013505e980c89d3fa9977b0c65fea19960813b56f69f52716bed7d38a13bf8c45e0080043b8839f7f64f0437f599ebf3bd0da6a274673b1a03b5d6f4c72ce50412f6cad433b28a42aa3ed74247473e7a6a82eb48ed8a5e01cce35ca27110595c6d234eb720ed65b36646dcfb02271d424df37f2af3f174f0e6619af76d629fe994aba60cdbf3c25f364707b144846648325b8233d21231d3818935055eec7b8dafc0a06bc5e0053bb3820393f4f774f1cbdbd20d679b26b525f6f8f1f2a6d9e79abe69732835e40b657252fca5af47f593919d0dc24df22c02dafee8b5d9e243496ead247850fdf47dbac263115c14d276b7829a1b26bb880347022f7999eddfdc4fb37004a5a19fe168a2282518403f85bd61bf139217b312bdf96bbac5a7c58dc3a893344e55437d416e6708d3310866c968e54fdee224d5f0d9ae404daa62b410b6e54f525b9effe260b5809a9e605bb2a7c55b2278648d4012f4a2b4b862f05f94d3f50e3801c1ef8af0196a4f3ed5d8641d969345eece73c26c802abf0b88d8e07c05f7b854b7f1788acb172901d29e0883689ea1cbb950b06df6d84ef26337b2abb491c691baa53085d48596ac4d272203a75db02433a65661a836a30e590f3333a3f25b443d132d6aecd6af84717cdb60a6bc846b6b501bd6f1e5272c1a7ec7d7f0cda7c93e19b21bac3c0db6aef46a543b2bc59f3ada650fac9ff9eac3802ca920aa78ad57a4154dfe83ca32438dbda4970e71b0368ad6c27a58b2f0ecaf049e5fec4d04a07bf8c4939c347917c2bd867cea21b338f25db447999912940ef4388a05ae63a4041659b140745e4aa78948c2b1c325fc00f35c9db9625dada8ff973abe95d91aaaee6ba53bfce8dcdcc5f2449ce69d9171668d7814e4decbb2b462ca48f9be3ca1614daabb024d957a31b0997ef7edd802386ceac92483516f985b08e3411ff865379a77418dca87216be50dcc0eefd5cf24a5173b3097a139ee17779c67cdfd377ffcbdbe9f2c32ae9120b97a1cfe7b546d6e63c97f97815ad82bc05f43a3408f21fb55b0ede7ad7de52535c28120fd608007630f642d8c4bb17f7240de07717185d9449e3dc3d8b0a84667a6cecd60f40291a67edd3d9ec646f513ddfc94882b529c45e04a65048e2b1d36a826647f75c5482fab0e7e7c30279fbee345b86fa08e5f920ce5c7705b2129332a51989a5426d3a6a31e8544e8cc440edf656d7e89c9d120324b453f93e8ed284f3a1a34202a48cff4f188d82912f7343b9e0af3c708e3d6c3eba4b7bf789fba6e3bdf3308486c6baa49c7158ba118582256f986ff54ceb0c99b2f141a6bfe20b8b18e9e55be6285e2e403241167c14d796190bc3bc400ef7a2cd76d677515dedd478ff029fe3bce5961a354d9d9290eb34971655a7f347bdeff6d5ed130f308c1b4e31a27ed1c8fbbd8af77c3a729ae6f36589f2db1a45277636b654b9065774f387fb3b24f45a6e9e5702f7d3de77942cbcddf2f070efa0b99970663a38830b3750e5b2a7c0a81f336d683cfeb493d2782c1d1168dbaee4778409426f574d6ed855c7c2fd887eff467763575b79e654fafb09140a1ae577b0861f5a25d26ec999e05d606198279f7e5821af22cf11e2be9d2c09bed27657775f79bcdd32b7d088bf387b6d4c29fc09b55a90b611e20af7a09c4a2c3741acf1e918ef1506e90dc45f247a297854cfd84b12998a039de619bbc62f6bb08c5ea1f5bbe6f765c48057aa552c39095b1e39de788fb816ba596a74754bd2a0dea3317c009c0b3c76d1c52152e9eb26b42af66d1448081c2851232807572cc23a22902550267b4f9f1e0b745cc717a6d57e2cfb19c559e70520f425f04aac9a69bffcef897b89422d7b4313f23775323f5b21a8eaf86edf7c0611bead2be199211e428756257f401b8fd2f5a483eee59fc8642749d06d13f018bfa762345e017e5ffd034c41360ed6e7afcc410d5c419ed38c2f7250ea9858a179e96799f64c78f94822ecfc643a6056f14afd46ce022b57b7a38638c5134e506c315b7675b8e8bd844afcabec7b488c23e88f01cd348129c435a865a584bdd15035f07554802c9b84635f1f72e61d593fb3cd8d739762695169041914bef5a44098eda60968c19a194435417836a982953a87912d1584743536e98b65fee6eaeb4557c0ae4bccba4edf6b78d2cabb5222f2d18411a9aed4144555bbb45dde044a4df0f755bc8da1f9c5103fadbd5c6849a1bb0c3a74e3878677001676a1ce5b8e1206cd2552e44b6b3289e1eb0f228a949d2acbff173b55786022c53dfef47f40b24e4cbba8402b3128ede6788fa35d04665efcba2cc3366d395cce4e6a5f06aac5405232fba8d139182b24b18a488129c809db6d1be4d1f29e04f4c2a036d7115a48b46f4e8eba14c049e58162e3b8905eb67a0c5f1a5d78a7914055825762f02fce99e8ff2249ed5e0a7eec5a227f3363c8a051507fc47375df94352fe4353190a7a0a358c48fadb02822f29055c97f62a7722f8d1f00665a72223c53ee9a5d51bdfd34fa67903891491cf9c96ecfe2b3ada58a54b78101e7bb4de30f70bdc5529146390dc2f73539af94fe5c06f33d04276d2aa60b13b50f088d6188aadaca2f323c05173d3b41f22c95cc2c555c1b6cec71f6f6d31d02c407d79db6b0714ff4f7e5ecd5829a106434d5ed212e95ebd71b487dd48e5a0bbf24fa7d03f20906d2a81aeb0707c9d7015f5a85d93719f60bb44266dbf827feece3e505c2b1df097215734168e99e5b4f03f1d01f152434e017bb3012747737441e155d955e1e30bdabafb71711a497c174dffd82ebd398629cb52deb4a5c3143ccd76d7b5d8b842c1045b29dc498ed91809949cfd2e141dad307c434172b241be64866e4f7621391eff9c3d5f520ad53d3f5af0f2cc068e248db9a41a7d812b1e76710264c85bd1d5cbd77f12267d5f73315ecd5831f219ff814e4daf80676717249bb5accebb114a06e1c7cda1a9aa9d419a506805e3d868e04bcdf33d5461211633f9b951c03cb6c9e37de1d9099883d8e2a74a35de30e120e9bb639411cb44abdb4ab9b107ee22ee23bacdf72f34ce893c77a3bf9a84c9dadc53640b141a983eaab29a48f153c58f061a8fb638c67ed1236a1b9cfcf7d8f4d1c4537bc1e4cd58cb1a8095cf5d9adbe8f164b5157eae6517d26a0b2d7428c4548301318b977d59c6a8d29e66924b1228e0940c6ea382e5064380d675c0282804eee8a6ed52cb319dd5b78267282d9d5e9a3a93d55a976a65f98391ba03d306382b0ea5eacd9a929f5f876592253df5ef0b291ee83c0b2de59f742bb4a7b0b976ad6b7404dc3f33b740e42408b51b3a5fbee283dc50c205d49ab314ff0b36347e7ed1321f7f8269827f8435310a05ba0bbb6b4acd2730977d5b9519698512f4bfd4a8889309a200e3e35be925125c0a1c7544dcdbe602304bf47b297d3bf686cca6feedf20a474f8c84597feb44c039e6359371e01a3b84a9371773140f9f712226b4a7575de27ef4a992928a2555f3ea4105419d32826084840445e5464edcdceeecd70cf5e91948f1da80b8114c9b7bbc1925afd7c783d8707c0f74433bb04574d9eb237d289e6d3075461d4ed435b5c00895c5d741bbda7a70cd28052e1c21cfc00bc9e10029e2113a28cf6653e557ebb7b4e0bebc1688ab851e65d809d29f6452e699f9a1248ad389253ee578b6cd32e5aa66e378ec0a170d3d28776d57d1481ad962f84f0c08fa579c396cb701be191ad820c362853f55c0e8e48e840a812ed162c5eb85fcf8b49a1d953a1a32998bc9146ba0ab46c2057b7af39447e075c6f03b971ef95d8f1868ee0529f4fb0b240d5cfadc1046f46b8b3b13d21b258dc9da5388e7cb8e5b2f070ed3c6cfa47df1689fe0f11f6c4d012c5faa0765e674ee2c0460024fdb3cbb1d2b389eeedafdcfe8b204a1136e2ed210e725940f0cf10077f094f1bdb5f0b98fed09bd77f040acbccd56d9c8df7b8bff829b6ec949a486ca68213e76baea78553e72a38322231166e68a4f453fabbe138545b41bcdebf3520087072777ff84aa9fc7b70dae8e4ebff0ea4117580b72627568f0dcff649a6abd825abde69722902c1d9b968bc3c39ecd422b1ee4b691244488db360ab7f06aa4e88ec3cb080e4dd572a26b629e6c20bd6d7371e68e118b35e3f63cfdd110e3587001c15bdba994d86bb2e13d1697a2e200b9a3bb13b2457fbd16f00694f51ba93e38dc3696935e00217d863934380bcbf0ce29fc1a31e7db4ac044b14ddf93027ae80b76674fb2385ea60e55fb841f0887cce90a0ffd2a3405ac648c7d68e6e52ea01ba56f1aeddf3f4a48f3f0436e1f2bfb310199a76b4d741a066ba1b2c4d99c54a60c046c23fb4009fbbab8c753300a508a116dadcdb80a1e5c2d89c7b4a7a632e8af1d04bdd16c90da8a327b290af942ec490248feeee0dfc6379599eb02456f7e55f38a163201cf8a13a328820b0d0c693a348efec1e72e791bd6eb4a1e155642c440da05d03895f78034920c2e2b9423cc02d9472ca8642834dae76eb900ca17774f7bf297e2aa0e312cc93cb2e7048dcecfdbdf00fe7efa51bd96c55e6870211a21c79506e7ae712c92395ace2e65be64f30a7bcb548f9f5d94854fb3340754e4de7a3d8c706fa42b8be9c3879ff5496634c51c07305ea4c1c2a1851bf31702002e7de339616efac746c357503ce95c5b3bd6172affc165be7b903f6ea8c898cced66c39d5e144341aea031efb553508f6aee65d15135d7f3e74ec8c40493592601205a109f64e1245485b708a7f3e34c8a43c01c2bbdb838dab915018d5c936f2dc9c4311cba048cde0eb83e2b55a9004b532839967b788525c5c9c5f5bd2eb7b7201935b3c061d3ad2f152af52abf3d44a5f681dd0c84d2700b7db303998c465d82b54c15caea5ea83c6685390e2a96b338b9c6cb98e53cfe1e4829e16541c50450e9e8b17a5ee1900bfabd3846732a8abc7bc6cc458f276c9bf7501adc37019bea1d70f14fb79d9881e27bf8d33743f4ef6b2e7f246ddbc388a4740dd7ee9e67f10551bf5333e71015528a5e77a11bc0b4405d27274e9b68caa184d34e2b162747e4cd0c6771976fab6a5290cb9519fc986751be2a4fe406b65ad47f0a1ec356996747bb00d5546536fa031cfb6fb806fd8c36e066bf5953503754a26529edac314482edb101c2848c48ce3659f0539345afe4d38be336296f748a3fe52ca930c2dd5a433b7a7685bab18199fa40c14d53beb8098134556909489bd552891318b28276535dc988efde18af462fdc0e1639113e6f41f8249f149db8c0171751a682752fba6717d037a77aeceb333ae7c4ccb91a0abbcd0256d0f0080c9ef9e09ed5bf106e5dc40336b9612d422716c0d7008b1c41584e446daabcb1c3973fa922660f348fe5168e75e8554ca69e0543d7e0343ce3415c2d36cd46fcc3ed6225e25b49ed1cd14d3ae10b994dc3734be966d229ff44e255dcd5badc71a24d657c22b10be7c853dd255fcf83ba76f45c8e620728b805784830873a3f30153efaed5df51b593045713263dad47f62258c972e8103c0c5b8ccee259a38e8bd9497181d32e6bebcc00d51d919131aeade84b05cc45489d0f55c1d12e34793c8684ca36a68f83a9f013d46f3625c6dba84e5a67c882d12ded251b08e634e1f56419df75705922b38ea5da24bd7358a9ef0d927efe1820649381b8b748bde0f75d3f008a6de9de5421187458039c9a8a9074bd83d4c0ddb685bd4085a7e2dbb44008a1c5e0f75c9d0a24b70694316da2f9f2a428d8698db42e38c411dfcd3ae1417aaf4dab97807563db0d2889bd87f0a63c29e93217f2989b02c1802b75227deb4a262e4a54d74a3c9f99bf76682a7036c829a9bbfaf39440ef839bf58c60aac99b2c0b0ef850fca2a77d457343af84a916eac71c3a18db8775b8d73287a681e0985ea273d4a1267ed70f353b4bdf5c559ec8d3d1ce35eca23684781bae09b3a5075a9c224ad28e8d7cfa10a0e90a1af6e21de0d2098b3b4eede84bef66c41d9a8f17cce076e2095928c09b7b9ae46769ab80e8bf28cc2dc95bc961044c7230c6bbcb905ebed8b6ed5e780b30c39962604f9485c9c5a7435112f9d85cdd79c417b92efe9759d4d783b96eadaf6d014d86ea609ddcd7d272f4de2c2479114a4217c93c9ed3b24df0df24971783c5803ae4f7174d6c4a498bee093e8e6c263ea1b2c2816079df6fc12e20900e69b655ca183ee5fd6dbe7e786e73a8da8c23dc43411a82062a7588bd6470235f321c2768f213c5d9c75807355fba36c3e0a4e5f7ad474f6708c7c772bdc868a4bb38a3829059bf64d032fe7d6a1bd69d29eec11a2dba88f6401b230b57a303af7d371794836cf2f938208d57c4e764db909314011a682e5cc1f1242e033ed07d5e0b8c896772e4a9f34ba44ceb77f353e6a8a95b60dd0ddd6290dbc5867b8d42e9758a043834eafd3ad98127acdf82e69740abd913e4931ebda4251f15c34f20806baae49742f6a36f6234081b6ea3d7939551acf9c02226c4f5e6b12447d3033d5f82611c8fa834fdaf56f142cf6cb02b55e10860aee690c51232811f21476f6bb64b43faf364375ea0012e81ed8259a13b234a7d19a3dc94a3dfbac4677b11ebf6d31f654f008a5cb59e2b483f2b0f08731880dbd0075f5145d1d038cd41acf45345299e35802c63916faa1c465674743e82ed11b75d2da1790620aaa6983a3774ebbc9408d180cb9e8eea116713023edcdd2078c77bdf001a8ea54ab20f66f73d2c8e8491fd22d4ce1542a67c3fcffdc7f311f2b603cec92904c875f67db8153158b6f7aa5a9dd544d77a292a8ca97926eb916f5f29c1d790f699305004bbfc9f12e3022b97592d24dbd68deec379b1ed5431ad418fb00830a71a3dcab6cf24d88942c9d4beb46077f55bac560939b508c9dad0183fb39706505d6304533c3327ebcdcee9b80873d025453b5a2c6876ddf26b384820ea4c00738451b5a3db36d1c927f108fe971294b92accde9aba72156a259dd833899a726553caf25a27c645f8aa3d1149176a6d65c19ff67ca5f4db6537cde04c8dbcfb396f09976c55a226a12dfeda0b68455af3625ca3195bc811538e5f3bc92ba3374816d1c6e106ec496cdd4173442df7fc7fce476ab3b258a77ead87b6460ecf1241c0b8b80e8a4ab74b3a3a9bcdfcdda31eef21c7224c92defa20204bc504559a5936ccc6685664aafd8d62d4be5cf5a76cfe0b29e5ff9ef9070b4aeead066bee4bacac07b2bfed0609ff64d3a7bb3eeb1acebc3ee5cca3dbe7d5bd688e8ac78ef08c90f444d5b1d6fd9e5b200f33fd38e934b198fba27cc8e91650eea5a7943187b8bf3ae8daee87005950b3ac57f095f892bada70b3cb244534ab64e694baaf0ea230f28e9f573e7d236e61a83fe0869bb5bc71008d417e22e351041f27d67ea1fb0a2827ebe74de4aa4bd84a47b6a1414e09d9923c2074516aa5f89bcfcf094b06ccb458be2347775ff2efee163ad6fbac9db311ac334ffa08595ac8c2457c45f9aa7b8ef165014476e2549b29e226f37bbf703fe362483d09fa0404f54be2a45a15e425852ed8ed0e9a343537df2d5b049e81d97ee8ba7e34c66a3ce48ad1d7e8670eef27fc0e79c82252eb6a3d1c6bdb92fba74ebba6ac5a4d535248366a9c99a0e67573db8b4c2108983d7cb85ce4231e9eb430c62b81052cad39592c006bf7d640993d77bd16e3e9e7dbc7fa6c377dc531356704d5d5b1ddf467811de8a4a792ee8f020af15e17312d28f0f5abccc64a7c7b44c33b488d84d6e60ecb8a2861fca2e8f596324e3822903d70a784a0abe2e55f19dd819e7c3f200cd06fcafb85c2beb67f664c14ca2a03ab051d4c4f212f3406ec9400e8fae9037f0baf31ff473e89bbb2762eef44319fe1579a12d80baf73a4cbc919e731fe1f753db6d9ab81437c4edc4d0c4a45ba46f1e0d43098e0d030e42f646cdcd92b00d5b45afca8fd71d5f5bba7a74463c2ef3215776ee40fe5688595de3040bcb25f14a4510136b0a6ad094a1716d86bd5d971d2df031e0e674f4d64d338d9b0ac411d32a1f25cfdb69ac593af94a8fe30bb2f450635a5a8d049a50d390b5f57fba5130c889f6f8a9c32883b1269a63262276de7aafd58e7c4e5e920b072deeb1c599e687bf3907745c302641128f21ee00bd4ee6d75326bfe50fa579792c10c5d75320c35bb1240ea5caf0310f5658cc92e664586f2dd788457f4266d968e61a46ba3bccb834fa94828f140a96c8c06a353ebee14a0b348144c463b964f97c250b5916f597232f6c84f4f1208744af2c20ab1a7f0808a3ad97c8bd2163769dd6bdad916ed160e504a0e0ee1514eefd101c820fcbe97a2500497275cb0f8fc82f42528504cd856d833f667811a58e2a2dfe3a43b5aaa86150b368571f36c7180e5ecd701ec0a8e34ff47608be133fee988e4cc89ab003e802be295529b5d91b8f9b94bd555b21d91bb4e7c66bb25c89ca29d36d3dc43cadf23be051f46e6ec66dbafbf394fcf778d86b3969df55cb999203e09d016da5ab32354909eba8f3fc8d113f90c365a8735ccc72c7719f414f733200f31fd3fb0ba429e88e211a439a56b98321c52385c5810303b4d913e09a82751e597e82d030c06ffc0935ab421be5e6e100dfa01f8f38a051641a7daaf3f5c6de775306261b9b713167f0e3240eb45c802c970707726f74d847b22d3e009053778cc56e2bbdfc4835a27152a0cac8c1c601ea59613a7f33323bfc6a01419255bbccd7c5ae5ca94b19a7e93d5322dca2b64b89f518ec01e671beb26d2bd40a43be95308a3eb166b59f70077a04c9c01b7c2b00edfad1f4c5d185fa7845b1dd84421f486a9fa93d1eaf5dbfb31dda64107fa094d7f39b820fd55bf548ca79feabce9029352ba09cebdb854a671fda4b056413690a5cf474bbe5e44a2f6f656a3232cba6394dc38bc938b0847fc6ed08cc3dd28a869185321d48f1e58e1f6355fa733423d89e7f16675a819787c6c69808b2664ec1d24695b885e95bc4a5b0621f056b1611c272b74ad88caf83fa9955f870e3cb7b8e55fcca64a39d053f24f62335d90e6013bf18f2cd7c2cbe91f7e2a5989eab4c464df6d6807de9c5b4d1e23da585f25086a64bef631d6972fed5add23067b0b753edf6ba0fdfab5eea009dff48c1db9fa7c82716519e88a2cec3a5c856c7c7acdda2ad54e2f962ae666b30aa68f6eb16a7b05bc7326073baa26640134e72a56314c27c68b130f451e7eb1cefdfc4576346c21e7b785ca52d1289d754a1165fd291b50b4057b894b2acaa771df4a5560ca0b47d5f4748eb498f7a654cfe310d6203914b50ff3afc5a654d2b6e714a3ac3531a9dcd0721762c3692a8c253c6fd0db848934d3d5f0fcc6c67cc6986695f9037a08b946c7532113be189222f8eae7b8e8774e631bdbf627740ed918e9fffb7f76c658d15425660319ae1945b17fd533ca9f7bd5ababdf7246c7ed56ea832e204da0d02f9c79b820e302b593b900324ce8b448ac8eb15566367b02b7091e82f7f9e34e977d3bfdd75fdc17eb979f16d404447e789a25155db4d575907d565e74b3fa7191fb07ac50a5cdcc5ee40a6cad97314edd95aa976da4dd4b564c1057e881815097297210e1f4c84b38f4455870182ce4926413a48eb9312eef92852ea2d8b2eec82739270ccf5e05df9f82151dd940379d3462bb8fe138ca23775253565ea1890c7c2c949970fabd4fa1a1f2384ff22ffcac6042f5d12306a5b1a8baf3b102df4edbbf6741a14d91cbc62d704d1ca28dbca8351496552061ec5192fb1179b1a29717374d55fbe68f3c4db6bd11bf0f7438ba484071068d0838ef36850f08f73a51a6adde1d91bbb895dbc153780faf9f63635982b998b0c7876ac5d3db3cd1dc990e6a32bce0ffb0f16dc3bc1bc5f376a7883b242c54fe5000d378b0d44fc431a93497ba6a71eb3fa113f8125d01149fc2d4dd30dbf6ff506fb18dbc4521b115229faf0632209d16b3422ee3b065d2e27fa2b1e9ede07e09ef453eb6a9a71d32b3ee9cae298ba7f353adde9284b16a45f24098fd96eb0a00132c8be28a72bf053899b93c20263faea1b12259326f07601b0d7b51e4d6f9d36935cdf172eb3b8b0ab56a8a0dbb5d10512b901a6c2fb8c9dc2562cb9f17a28a5cfa98db233d20d29726d75ac500b56edd07895c034ff3a348db792fa3065f78e6f7a7f1539c677726210df9e2bf9c1818da0ad32afca504cc4ec73056f985150845468a15ce658a9232e3a6d14baefb2a0e9f9de5e600bde7fd9adf6b75059dc5ebe7744747600b2c23dc39f06024ff46d7244aadbc04c44280d23ce9cf37254557befcce52531ee2952e7acf61541b983c3e61c37a8020fc982cf0175337f89c35d9a0487b23f16e76972d25cdf76b8b16f31a8cc73a3d35925d9de2be0af001ed3deda6e070f041051fc757095b3682a96b5ede47606e54bbd0e4eb08d7564cf0a9d5640d5e5d107a2fc36c0a9d1467c472795b994c15e5dbdcf9c578624d62e1060bcb690ec91b7405160800bdeb06d77a2c48b70f67e2a8595ae9cd081b922c969d7409fdd6f0b12bb37466c0ae593b2e05a20f7b5905331326930a388f8fb25155379d703c27d9d4f6ec5681f97e23941667b49dd49209562812141348acea932c02ff01e0c5c4e71f4b436500786cd0fd23ca315d3c56c5d1837d2d7a3667e83b97e707035dd98b91dc650f6299c695922a57a5fabf1c9e10edc54669575c61a595746843016d180c971923e240624bd5317178722341c786a924b99234c8478b8cc30bfb09badb273db164864590b3677f7463bcff79d033f9ab7976f0df1e1c2c6073aa6f6a4c3bf4e5ee89bcfdb2832617e8fb0e6ab599266ad1005d5a8a76a3ebd7b1b103285c46341869176fbda302aa2bdd296f6d2317a67a57d04d90d798ef449ef890bd19b236e7534df3a1bcb2b56ca2d02bfdf35a86c42a33d56c460219b82145178529c0839fef289d0e6e51a92072f1ac31cea78af069829f83a9382af6531856ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
