<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6461d062ab9e2e960a1995c9ab86e62895d46ff8c15dd43b5aa842c60a8b816706750a720a6436b520c806d67a74cf1cb93886f9263d3e8c1a8fe79a91a141d053b9f38bf5aafb25c24c5f18cc3ffc8e3b7900253c22d24f2cbc17a1ef60ea8429067ff8a7c3d969abe17f986e386f57cfaa1d92a855f92929e0a76b6a96faa30d15493d8a401085391f95637b2999dc236095fe05bc20cba89408e41927722f6567790a015a53292cde641bac731a5636f3a630c2d5fc610341655fe822e841d1588f76c93d6b6bef5f0bade2306df54773f186d700e7851d27ca78c2d652d7c4be23e07487cb1b8c72369511711248c1ca420afdb52115f275524f7905e630fd2863e3755c6651f3a01ab83819179202343a8d66a5095eb792b1c1d341e17a7b78d55bc7c9acf3780912cbdfdfb6870cfe3faba421a4b1b35f0a56ead71ef55c865015986f8182a5718e29ed534befdc429634202086cdf4ea0e9b7cad62642b359dcaec005d4c9e3ea290e52c62ec1946967ccfe930f7de3853311b0b7ad01a58a5c1c3a6e3b6b870635a04c23868b19105b6f2132c9949659d8a41b525b280915797711126a4ded0b3159fa630bc3a8b25639d0d7aa59a37e74fdcbe9f5a94a7a88b4f8807be9ed8b7288f9dc51b70210341965ff64848af5f47ebafe9f79d0a5b9a9e7d0c15424bc1d09081bb1c32dd2b8fd40b858c2b5e425812cec6cb3e54b46a8becaad358d9831b246ee503280ce0dc7065fb31cebd86d24f0fce6b945eec23af73c20b615f45785fb1ea09c0f5d744256fc3fe3c876ee0564a535bc79f2ab107162a60e35ead85372fde3eb96ca0df338941f14ead9c0cf2977c1f385c606985eca9f85f4887ec451a35ee3b8bca0c3f478082bb56646e6375875a6f719d4fc21c75151688c1230e58dfd57e34443a34eca521113af0201812f60393c2e6c26679cce2aeb2d4a595fa3a2a71a7f4694cb613b333eb5349e97ea1ce95baa20a3e6e3b89f045828673254c60f11be14d13a85710f21554b4b6a7b096ffbacf356f2f77ad4440188c4904dfe30c5691729890e51cabf39fe3e4f6fd2510f954748c7cbde0ff0ad750924eee75c46c3328ba97eb81816a6dd81a88ea9f32f52d6f2e3f94986c2ee16d81aea9ccac6e250d9b71da91c7a11767755c0aaa3481b27628ea5dda3895819ffc0668cb0950deb5c1a72ddd3d6d248b0a2c215671c20bbcf29f18f732402547db80ae6609fdcd7838a60659dbb398fae537482b1c857ae3e1af4a1dc9e7e9910658298e55615caa52aff6e09e58756452e965fff83a2d7a928dea81ac5301675897b906405a214cda0b3036ece705dfce06f7c75c715037f1c2d89877dadddacdfd45429ca67c45cc074a1209293232cfdef6b05c04e151b4fecdae4eaa81b3d4e555010b97207e125e71728c6569f1bed24ed2c50f602204d056a1d1c2638cd9dd3ba315a2b8b232320291a17ae13a428ea4377450d8136af3ee2605778bcc8e944e72940508c4aa731da6c470d8fb6c78364d35f9255abe8a9d84dfbe34a288bc5a8ab070cd4ac21818eb8e4ecf3f21fffd0e8a6d20a879a4bfedbcc50b97d5b8dbd3d173ae3a55663ecb2b5fbee6bebedb5a9223a8b5140611e22a42b962925aee2eb4e03d14a40b9753401ad7420bd31b98622772b1b0112997d9c2f8cb30784649eff77dc6b738f1b6f363ab666073514ba91a409bff72f48947eb4636b95d9e94b8764970a20a06b61c222735db868795494c38ebcce507ecfadbb0c817838a4c57de046fed8e7efce0feaef39dd6b45b8f18953b19ebf8c596e1de34ab3cb3f01ef616af9caad0e99140d0d24c9fce08a6c967218dade5b068c67034ae05de9eab0ad65aea3ba6adf7f07e26385aceb600a444a3b08d75030f6241a3d59508225724788acb519b507f8408bd9a8e70f23f53da21d11e23041f124486f113e332930f554d3e89d4c74e0e39d1dc2d5b71a1624964d9bbfff15a23f913d3ce2405015b73cf170e305dc8cf79950d42e0446d62fcfbac7b00095da1a2eb86b1b9441eb0f852a9a79174ef4698faab6097158a3602dd9f0c9541056c8f09dd6147a354a1c402d6e69ac41f56f13ed5887408be82005e836496aca7cdcb82ef03fd135b2d8857c9ef9a9f43cf7094fea5ebae0a9b2ea364eb64ce476114df3a350c7a7afc4c60f5e581978fd0b8cff75b776c3ccfd0b5077b63df7b2479c7c9b4ff4c32ef2ad814e283a6a94f30d9794a2e3cb26c5d154e342198c8dddfbcca3d5d2cee9c4f8e3a13bd1f6b94e5512845522839842939ab66537130e67d36efd915e8cc9f9d8f648914e4ea6ac03c2a6df621419436251bc0083dc2c2ef025eda39ead5d9beac1b702d1ea03b1a3ef512d67e85854f07ed5630a96fbf25d6334cb717d32dd0df0f3d7c261dca89ab34d5a4405ed99179408283ff88c5c8cad2d7bc86f2371098898f46eef358efb5fcaf9e68339b439c2ffdf2d3984fdb7ecc1504327f6ab210b5aff38d65cbcf26935b8e524a4ccd9b0b6036e2f93abe1cd9037add5f101cc5ed9c7768f9b4e9ef7816ec4f8c1396fb9abb028613b331fc22bd6b25587efc19113a5395bed99df1e68b178e639bed61ddf2f82f234c172123e978fbad0a52d16e7961886d2103492ea3a7c7129bc4a28342c75021b68e830ea9a814f96a2e47fbb49a2b3c05d055cf4008115f90954b6f990443fc622648978a1753d1fd9340c3a3b0e2d3484eb30bfeee26343a9c41456627e423547d916d57cd946739129cc053b2b58dad050fb667dc12ab4cd707ae7aec1e824c4a83e1c7fc923b03fa3ada1110d7f2a788782a1c973e42624e6fa913c5ba8667287583a255b3f5ed0b170ccd062bf72581c153c201e4ea3cb417955adc4b67995a42e0932ef413a72998cabafe0516395e0eaf6709668194cd142d60aaf2125d42826f0f182c40735a705829b836c6a860b3f6d96145a344fae6e119df5467201c04a3b494c470329bf2f7ba3e43a5269e27c4ab8f7241aea7717ac4cf645feb4faaf615926030d7db12cff54fe0441b4d8fe4d222cd539e707eb421154986fe79d9afa0b42e86e337197bf0cab6ba4a57633cc4e68f296f80c733331e354817809306097e77bca4572d888a23342ad13cd04a43c6380a61992ee713781d0b49c376bc28a364bff37767b7fcb545e449c90e8607a01a6884a5e8ba13d109efeeefb2a9097bd9fd4cecdd5a9fdb9fdc1d01a0002eea4076c5e2f83b4adaa96244f7874c8e67e579b3d1d98152802f210fd5a18f37094dd1bb2237d89a36f677d164987d0f2fefadda088e096665825269554555b2c7e1d2be9aac0862de0de718aba74a4af1f4a6b879c3c880b03ba855c6adebaf03371e56979c731a10c317688e701b9d37fa074f0b3c072577bff5e1f451907c55e376a5a23516ce04229a8d661fbbfeb29e0dc936c5ab5c79750ece512ec4f16f64b0081f6ba4af8d4e6eb47154d75e44a24fe5e7857e1604831090c94de33ce360448c7d1df005cbb219b93545a2fd8a62569eb809eda2e853b77cef779572ae6b557f83063c63f05ee90835ff1af96db8868de56ab48c403d886d5851c9d09b58db9daa5a65dc8b7ce08fad3cadaa4ec4b9f2615724be23ec4449398d27c3ba28a02e3e83e65006cdd7be62387ca902e0316c3672b70f3f73849dd7c6546883c3f547427677345b4335eb57b2a0bbf5a144869781f3b84461a68a67aeb46a2527b5cceb1ba47a2cefa21b04285033bb5d432348373489d1a65d73982d8de5082d7f2dfee9ae94fd423fcbaa4106e9d217ed2b8771c9a3ecf970b91a1865cf417f67dbe8913aebfc6131d45aeb9e7b62d5afe6b7bf9df97c347ae27994a44aac1015b8059cf6c85d0424d9add16b186407470f3e3daf7ac4137e931e872edbb0ac4be3a7a4624db7e02a692974afd20c59a5b12ffdff2307d0ee74792474f41fb7cb5390c16f0d2cd1d4c1e332c075c4b0581d843a7a90b6705aa7a39904e8a6c9f8b3581498cf7782aa0e587f5cedf50675f14a7a56439e39eb54301e32f65857d9a6101465953bd31f96e3c49669184a5e25d4f3a62ba591d26f032697613213421ce22ceefb057bafadb987f9bb8902fbc1ae2b2946ec2c18478df86de6a7fc512caadb3f2e23e690bcaf0a93bdcd4b9957a6a76ac6f1265d572c64f80e525471034e441f77120eb416b37e9afcca024c1a449676a84fc952006fe369d30e4f65064b8b32c8e7a4866bd4e201f180687da572f328b81308a9a4783e6e84b7e256e372636a8b6036055b466389dae544816315b5a879ba7b53ea162f43a097c68df03d53c087fcf9a8ac0c5af11fd5d86fef7c931eae8db20acdd5622e9101fb170a48cccbdf4ac2f57b1bce25cfd75fa3b2ba4c6aa2e534dcecce050975f7ae3f787153b5c79664d825a3bc8169e4329ecf232c7de83814edd16e096c15c33892f3dc50390de583970b0d904f198a7a29542fe0fc12751213f6537d38b34cd14023a542f48548d4e89ec265e1525e04b705ffe3eedf456dd4cee05eff5438f3246f0e4c32096b937c4517ff8bb87c92defabbb5ac1d5310e28d3bbe198fcb7ff8c87317969341e351ea9ef6c71c0adf45c279b329e8582c44ea4c0ff6946928bf87651a2760cbc99aabbc0fc05d94a904b7f35bf71bec9a4a0778d0f2d3f76357f8b6b911dc7ea2fc4a3be093affc7071322c7a49a65d5b6941eb2d5ab9b0775270c7eef8a49b824aefd01cf563f11895cae4d8fcb9e44b63fa376c59fcc98b3f87e7f053aad1f5fcbeff3b2e97b14f3a4bba0d141bb6091582f382225bef9257f81b7ef1adb4114b916c9f8f29fc56097105537a559bd76dea464a847fe5aff13f3d0ebee85572411c7118729ae0e744fc423b40ce380c920387587cce474f879c536bc4687dfb3367e01e8a4a126726e46270fe2c64ac92e5a83f8836de865371d0e99196b1ebb6034a93e37f45020cbcd05d7f1acd8cadec69c67f4dc24a02f298dc6e86a4400d06e7e0793d63e001a47374e0bae31ea3253e27181adf7ae3dae9ece427114449054eee7897ae8cfa05a4e55023389668fe5c66a8126fd0deda3347df7d42684e4b9df209f5010864125b7c8b1c49c26e97b96fa77a766ec95d4dcb3bb84f0b48ac3de9ce014aa333668c1a87d26f60343ab7e2b5029d89ff1bb79c39f9e0aa6758dc7f11389888d2227464cbc321f2f70fe99ce33cd75b1a61cebd9e6f05ec3f67a1e514805d7e6c67618013e5f6815d6d4573ff0bdeb27fde8e3ded5a8e67b6d4a79ee099e474698b6be5b12b6c84a35318f30dec4cb5231f0d4015ba5a5dd75e57f543724f466d70ca33327cbf28feb71f960835830fa4f36524675fb2203f4fd0622b921bf9aa8062f9c3824b91d294158210ae149082e58f99321ea64ae9b73c7085f1516fb7e52cf3274a4e834c2eba2f735c1d5ffa321cf7db0346029e6ae3860381ca7782fbd3f9356cd61caa6a49c8ed15ec42087d6588b9a44fb1879ace6de26c4afc4dd68e2b36386ac3abf7d6bbdac74a707436029660aa27083a28fc31da503c391306baf2e48f1d15fab241e8db52e7d7e5416f7bcd789007f6fbb20e32da97f3bc6f3ad0746bcc9efa6eb16d35eabb504f83ad8403734ad64251157925763909f836c4d0ceb0824f6a6e624671a1f3016c418b43febe9a50b2e0d05189b72233116f599c87e0a79557643935dd97395d25ba1c14e181dc4c099b1707a4ab55f31ab312854a2b25851dc332fb719f836eb4797a58341174c3c88bcb5b7dd51376fefeb380fa8172f60b25116a846760eccd557983c9c2eed22ce1fd4cfcbf637b91ebe335a151f969f10a8a8f49cae20652cfdd8e19f88c138893bcdf647e38283ab9c5e48b6ab1de705684042d27fb39a0dfccd9b897c06a2db5044cb6476a04eb107c6651d8c6085ce6af503749996b8e739be3f738254d019b624bcbe8f79375e8bb59392190158137ebe0f3c3d05d81ae0e989a5af74a5b682082a889deb0b6d0d2445f3930b92f39634e0bd14a18c8c71ad22f53e0fe9b1c4d601b4c0bbf4c752b26cde1d71059213320661fefa2c72314260cb16e8d5300f4bb97b75d31af617bea9cf939f70504821a4c6e9e76eead7a02f654f2c2b4bc585c59d8a65989765a5ff828b58c4bacd7c7a32a2f8f7d84e3708ae9bbd5805da5bbe6d11f3749f8d62ae8290aa0f8ba8eba71cd89180a6960780a3d4e51e5a09c1fab35fbd74c3572262dfafc957129f7d72573d91db3c37235cb8ebe47bdc13aadb59a1dcb7f4e6ada57192f98f37877bd3fe2f8c937cfea5b47cd8fa80801d0ea8c35c7c816108a1837d8d76b09df4038ce20e278203df1d59321856633ad2cb7ab2cfc4c64cc788bbe19d0d661dad10d03867e3bc6d5538c37de3602a47ac24aefcc1682092366990252a49d95eafb5a1a862772f639b25c3709c96cd3859b004b69555cc8340b6fa569dc815433bbe9156d7ebbf690eca9a516d93396f69fc6cb2c84b9d5642e5ca81c6d99276925459ca12992193668047e4ac9d5cba7628e3cd9642dcda8da551981e7bad5724f7dab5279a4bf4248b6302abbdf39381a9d5828a6c5ea6dbd6d7043eeda3023c237984468e823d458dc1a4a51adb6d4893e69e442b97a5aae4eff52aeda751278feb44afbc8940caa95efd64e1789e148a63254ed4970e4b4715a3ea1ac34f7f4648a39a1f787fef0a457fb11f08d0cbc008ace3986c9d96504eeff7e3cb763c843df51ef3aecf14b02aac8ec5bba4906e1b24ec53c4ebc3896ae3529c44ef108b9760d26aaca72db505702916002eb470049777690b13cf36239b42bd949588594e69f55985f144e2d5edfc7756148bf2c0d7729842852b20a6e028ddf2fe280e2e6d3319a21f53126cac968457c52dd712e1a9707ccd8a6f7e8653fc74356e78b358f17fce4544e1422d808d69875a1e2a3ee78787c3da310a7b907f337a2364a3206fb44fb2c6e978498f4b809e8645d113ff33b9f02bdea9d9f26ec4766e91639866f27855f97bd4e926dc30d3e95749642a66d57231ba44b9ce5cea6367bb8750f2f9b26cb7152628cc7b90d01547da5d513633b5307d2cf33ed5651cc4e0a260564d70cc5d9b8ff3b39866b9d3f18027a6050a62f507797ecdb89e00cceecfae41dae7dd1b7ba8e74213dce9b5d8a97e9f2ae8334e023c01cc0f29d430fd11d5f776396fad200a5a05520fbe39b2ea040eec47199e73470940a45789b780eec3cfca0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
