<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>算法</title><link rel="stylesheet" type="text/css" href="../../commonltr.css"></head><body id="算法-34028949"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">算法</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p">一，概述</p>
<p class="p">算法(Algorithm)是指完成一个任务所需要的具体步骤和方法。也就是说给定初始状态或输入数据，经过计算机程序的有限次运算，能够得出所要求或期望的终止状态或输出数据。</p>
<p class="p">算法常常含有重复的步骤和一些比较或逻辑判断。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p>
<p class="p">二，算法的历史</p>
<p class="p">“算法”的中文名称出自周髀算经；而英文名称 Algorithm 来自于在数学上提出了算法的9世纪波斯数学家比阿勒·霍瓦里松的名字al-Khwarizmi。原为”algorism”，意思是阿拉伯数字的运算法则，在18世纪演变为”algorithm”。</p>
<p class="p">第一次编写算法是世界上第一位程序员Ada Byron于1842年为巴贝奇分析机编写求解伯努利方程的程序。20世纪的英国数学家图灵提出图灵机抽象模型，解决了算法定义的难题。</p>
<p class="p">三，算法的特征</p>
<p class="p">1， 输入：一个算法必须有零个或多个输入量。</p>
<p class="p">2， 输出：一个算法应有一个或多个输出量，输出量是算法计算的结果。</p>
<p class="p">3， 确定性：算法的描述必须无歧义，以保证算法的执行结果是确定的。</p>
<p class="p">4， 有穷性：算法必须在有限步骤内实现。注：此处“有限”不同于数学概念的“有限”，天文数字般的有限对于实际问题并无意义。</p>
<p class="p">5， 有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。</p>
<p class="p">四，算法的复杂度</p>
<p class="p">1，算法的时间复杂度：算法的时间复杂度是指算法需要消耗的时间资源。</p>
<p class="p">一般来说，计算机算法是问题规模n&nbsp;的函数f(n)，算法的时间复杂度也因此记做:T(n)=O(f(n))</p>
<p class="p">因此，问题的规模n&nbsp;越大，算法执行的时间的增长率与f(n)&nbsp;的增长率正相关，称作渐进时间复杂度（Asymptotic
Time Complexity）。</p>
<p class="p">2, 算法的空间复杂度:算法的<a class="xref" href="http://www.deepcast.net/wiki/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="external noopener"><strong class="ph b">空间复杂度</strong></a>是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的<a class="xref" href="http://www.deepcast.net/wiki/%E6%B8%90%E8%BF%91%E6%80%A7" target="_blank" rel="external noopener"><strong class="ph b">渐近性</strong></a>来表示。同时间复杂度相比，空间复杂度的分析要简单得多。</p>
<p class="p">3, 非确定性多项式时间(NP):</p>
<p class="p">五，算法的分类</p>
<p class="p">* 基本算法</p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/%E6%9E%9A%E4%B8%BE" target="_blank" rel="external noopener">枚举</a><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E6%90%9C%E7%B4%A2" target="_blank" rel="external noopener"><strong class="ph b">搜索</strong></a></p>
<p class="p"><strong class="ph b">*</strong><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="external noopener">深度优先搜索</a><strong class="ph b">&nbsp;</strong>*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="external noopener"><strong class="ph b">广度优先搜索</strong></a></p>
<p class="p"><strong class="ph b">*</strong><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2" target="_blank" rel="external noopener">启发式搜索</a><strong class="ph b">&nbsp;</strong>*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95" target="_blank" rel="external noopener"><strong class="ph b">遗传算法</strong></a></p>
<p class="p">*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="external noopener"><strong class="ph b">数据结构</strong></a>的算法</p>
<p class="p">*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E6%95%B0%E8%AE%BA%E4%B8%8E%E4%BB%A3%E6%95%B0%E7%AE%97%E6%B3%95" target="_blank" rel="external noopener"><strong class="ph b">数论与代数算法</strong></a></p>
<p class="p">*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95" target="_blank" rel="external noopener"><strong class="ph b">计算几何</strong></a>的算法</p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/%E5%87%B8%E5%8C%85" target="_blank" rel="external noopener"><strong class="ph b">凸包</strong></a><strong class="ph b">算法 *</strong><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E5%9B%BE%E8%AE%BA" target="_blank" rel="external noopener"><strong class="ph b">图论</strong></a><strong class="ph b">的算法</strong><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="external noopener">哈夫曼编码</a></p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" target="_blank" rel="external noopener">树的遍历</a><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" target="_blank" rel="external noopener"><strong class="ph b">最短路径</strong></a>算法</p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91" target="_blank" rel="external noopener">最小生成树</a><strong class="ph b">算法</strong><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE" target="_blank" rel="external noopener"><strong class="ph b">最小树形图</strong></a></p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81" target="_blank" rel="external noopener"><strong class="ph b">网络流</strong></a><strong class="ph b">算法</strong><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95" target="_blank" rel="external noopener">匹配算法</a></p>
<p class="p">*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="external noopener"><strong class="ph b">动态规划</strong></a></p>
<p class="p">* 其它</p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90" target="_blank" rel="external noopener">数值分析</a><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95" target="_blank" rel="external noopener"><strong class="ph b">加密算法</strong></a></p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/%E6%8E%92%E5%BA%8F" target="_blank" rel="external noopener">排序</a><strong class="ph b">算法</strong><strong class="ph b">&nbsp;</strong><a class="xref" href="http://www.deepcast.net/wiki/%E6%A3%80%E7%B4%A2" target="_blank" rel="external noopener"><strong class="ph b">检索</strong></a>算法</p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95" target="_blank" rel="external noopener"><strong class="ph b">随机化算法</strong></a><strong class="ph b">&nbsp;</strong>关于并行算法，请参阅<a class="xref" href="http://www.deepcast.net/wiki/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97" target="_blank" rel="external noopener"><strong class="ph b">并行计算</strong></a>一文。</p>
<p class="p">六，算法设计和分析的基本方法</p>
<p class="p">*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="external noopener"><strong class="ph b">分治法</strong></a></p>
<p class="p">*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="external noopener"><strong class="ph b">动态规划</strong></a></p>
<p class="p">*&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95" target="_blank" rel="external noopener"><strong class="ph b">贪心法</strong></a>（亦作<a class="xref" href="http://www.deepcast.net/wiki/%E9%A5%95%E9%A4%AE%E6%B3%95" target="_blank" rel="external noopener"><strong class="ph b">饕餮法</strong></a>）</p>
<p class="p">七，算法的实现</p>
<p class="p">算法不单单可以用计算机程序来实现，也可以在<a class="xref" href="http://www.deepcast.net/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" target="_blank" rel="external noopener"><strong class="ph b">人工神经网络</strong></a>、<a class="xref" href="http://www.deepcast.net/wiki/%E7%94%B5%E8%B7%AF" target="_blank" rel="external noopener"><strong class="ph b">电路</strong></a>或者<a class="xref" href="http://www.deepcast.net/wiki/%E6%9C%BA%E6%A2%B0" target="_blank" rel="external noopener"><strong class="ph b">机械</strong></a>设备上实现。</p>
<p class="p">例子一：这是算法的一个简单的例子。</p>
<p class="p">我们有一串随机<a class="xref" href="http://www.deepcast.net/wiki/%E6%95%B0%E5%88%97" target="_blank" rel="external noopener"><strong class="ph b">数列</strong></a>。我们的目的是找到这个数列中最大的数。如果将数列中的每一个数字看成是一颗豆子的大小,可以将下面的算法形象地称为“捡豆子”：</p>
<p class="p"># 首先将第一颗豆子放入口袋中。</p>
<p class="p"># 从第二颗豆子开始检查，直到最后一颗豆子。如果正在检查的豆子比口袋中的还大，则将它捡起放入口袋中，同时丢掉原先口袋中的豆子。</p>
<p class="p"># 最后口袋中的豆子就是所有的豆子中最大的一颗。</p>
<p class="p">下面是一个形式算法，用近似于<a class="xref" href="http://www.deepcast.net/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80" target="_blank" rel="external noopener"><strong class="ph b">编程语言</strong></a>的<a class="xref" href="http://www.deepcast.net/wiki/%E4%BC%AA%E4%BB%A3%E7%A0%81" target="_blank" rel="external noopener"><strong class="ph b">伪代码</strong></a>表示</p>
<p class="p"> 给定：一个数列“list"，以及数列的长度"length(list)"    largest = list[1]   for
counter = 2 to length(list):     if list[counter] &gt; largest:     
 largest = list[counter]   print largest</p>
<p class="p">符号说明:</p>
<p class="p">*&lt;i&gt;=&lt;/i&gt; 用于表示赋值。即：右边的值被赋予给左边的变量。</p>
<p class="p">*&lt;i&gt;List[counter]&lt;/i&gt;用于表示数列中的第&lt;i&gt;counter&lt;/i&gt;项。例如：如果&lt;i&gt;counter&lt;/i&gt;的值是5，那幺&lt;i&gt;List[counter]&lt;/i&gt;表示数列中的第5项。</p>
<p class="p">*&lt;i&gt;⇐&lt;/i&gt; 用于表示“小于或等于”。</p>
<p class="p">例子二</p>
<p class="p">求两个自然数的最大公约数</p>
<p class="p">设两个变量 M 和 N</p>
<p class="p">#如果 M &lt; N，则交换 M 和 N</p>
<p class="p">#M 被 N 除，得到余数 R</p>
<p class="p">#判断 R＝0，正确则 N 即为“最大公约数”，否则下一步</p>
<p class="p">#将 N 赋值给 M，将 R 赋值给 N，重做第一步。</p>
<p class="p">用“<a class="xref" href="http://www.deepcast.net/wiki/basic" target="_blank" rel="external noopener"><strong class="ph b">BASIC</strong></a>&nbsp;代码”表示－－</p>
<p class="p"> If M &lt; N Then Swap M,N   Do While R &lt;&gt; 0       R = M Mod
N       M = N       N = R   Loop   Print N</p>
<p class="p">形式化算法</p>
<p class="p">算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务，如计算职工的薪水或打印学生的成绩单。</p>
<p class="p">一般地，当算法在处理信息时，会从<a class="xref" href="http://www.deepcast.net/wiki/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87" target="_blank" rel="external noopener"><strong class="ph b">输入设备</strong></a>或数据的存储地址读取数据，把结果写入<a class="xref" href="http://www.deepcast.net/wiki/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87" target="_blank" rel="external noopener"><strong class="ph b">输出设备</strong></a>或某个存储地址供以后再调用。</p>
<p class="p">参见</p>
<p class="p"><a class="xref" href="http://www.tektalk.org/2011/06/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7%EF%BC%9A%E7%AE%97%E6%B3%95/" target="_blank" rel="external noopener">性能优化的方法和技巧：算法|</a></p>
<p class="p"><a class="xref" href="http://www.matrix67.com/blog/archives/2552" target="_blank" rel="external noopener">假如P=NP，世界将会怎样？|</a></p>
<p class="p"><a class="xref" href="http://it.solidot.org/article.pl?sid=08/12/27/022240&amp;from=rss" target="_blank" rel="external noopener">密码算法语言Cryptol公开发布</a></p>
<p class="p">量子线性方程算法：Aram Harrow和同事刚刚在预印本网站发表了一篇论文：<a class="xref" href="http://arxiv.org/abs/0811.3171" target="_blank" rel="external noopener"><strong class="ph b">解决线性方程系统的量子算法</strong></a>（<a class="xref" href="http://arxiv.org/pdf/0811.3171v1" target="_blank" rel="external noopener"><strong class="ph b">PDF</strong></a>）。以下引用<a class="xref" href="http://gezhi.org/blog/1333" target="_blank" rel="external noopener"><strong class="ph b">格致的介绍</strong></a>：我们现有的量子算法，比如Shor算法，Grover算法大都只能对经典算法作出多项式性的改进，新算法把最好的经典算法效率作出了指数性的提高，把求解稀疏矩阵方程的复杂度由O(n)降低到log(n）。更加重要的是，这是第一个解决了科学和工程中最常见的问题的量子算法。像Shor算法那样破解密码毕竟用途有限。在实际的工程和科研中，我们遇到最多的问题就是解线性方程组，且我们遇到的大部分线性方程组都是稀疏的，维度也非常高。新量子算法将能非常迅速的解决常见的线性方程组。唯一的问题是我们需要一台真正的量子计算机，<a class="xref" href="http://web.mit.edu/~cua/www/quanta/" target="_blank" rel="external noopener"><strong class="ph b">MTI</strong></a>，<a class="xref" href="http://www.stanford.edu/group/yamamotogroup/" target="_blank" rel="external noopener"><strong class="ph b">斯坦福</strong></a>，<a class="xref" href="http://www.iontrap.umd.edu/" target="_blank" rel="external noopener"><strong class="ph b">马里兰</strong></a>，现在瞧你们的了。&nbsp;<a class="xref" href="http://www.esat.kuleuven.be/education/ir2000/options/da/iroptiondna/knipsels/10algorithms.htm" target="_blank" rel="external noopener"><strong class="ph b">20世纪十大算法</strong></a></p>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80.html">软件工程基础</a></div></div></nav></article></main></body></html>