<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2502dfd3f7b2596fccede7fdd43047e22d9fc0a1fb524cefd4d25afdd062b3cdae171e163fab61c229efbdd23fffee97485b12540a464c7e29ddad12c1b9839ddb6fb8533faeefa57f15b8750f7851416c78a9d05a78299ac934b3d4457fd59d15bf45e612e425408ec2b4696f0169dee099a9d4f3243e8280c47179cc2046a4e240f370a3c410a5586d508432bcccdef66fb24f6814696bdc19c8679f417825d250763f1452c40c40eab40338988acc2b3b94d4c5aff25857682946c03c453d7a4e53b57b24086f6f51348c40cb2986280587e42262e6d3c997195b538166a24412388588122ce63f4c377569312261ed6fae54071102124831df9dcac0a8058d728f2e90c221b5bcc80d35534f6da689620f6fa518c22fe7e4c2d82bbe85163f8b238aa97d8432cc745818f4b8047f93224d5f427e2891ee5b7f647b9509bcc6ff54b8895856961858e96e11e17f9179167a4d5866fdd88fee1373a1cd7dce1dfd84623b429cb014597e2f0ab50d60bdae057ebf1e18ca27673648a05109fde98dbf8c161cb41a48d3e26f116f09e88b0bb13aecfae5d88dedb0c1499fcee1540aae9d5a58b6c3988a0283347d2878fc38c5777f56c52ce3b40da59a9f300a1a7aa2775ae24f9b401625ab2b288b13c797fd22965838d81cb33e5c0a852858b15e01487b13b1414cb2a299b2b279ae69a08e234be14df3d257665abda7d3254f987489c1cb171988cd0647ba743959f5f9a4bd457c93f7469d35b15e5df3a925140d79d636a2f9b3393ad67959d32b9a1ea21393ec7e350df4bcc98b5ca91b5030fad116ec70d936aa61db0ce27ace185bcbe331ebfbf9b8a70949d6af563b10c4e21d1e4cf6941af7f90e03905e2ff8f093621f2155bafa77b3b1b2a6cfb3510e635bb95474e810bacdb7791c69f0020f34fa252031a948e7209c899e68973d5c18a5a5878b224804ec822cc8cbace858757bdf47f3431426c489f9e649378ec7523e70d70044803dd92f0116b21f135cd29b847e2f71f5c3417589b0c5fd71ca360c1b59677b4047fe52c9724ccae936d41f931b14d3796372eec6186fe2735e4de9a88c1e012d6257e50453877b4a23b67c6033b70d112159c6460ea919506d741d54c03d891573adfdf87197a6dc7f22ecacb9c4293d69611cf1611a543a042d2a1d8e6899eaab44764883b7363b2457f5398b25dbc81ced88dc4ac03b95f4dbfaf8352341f4825969dbb9954d53573809b85a227bc16fea7338912e54f48b65f92ed0e9b6e326e73eec4c2ad8f7802a0a78b16d419ac31651e3cb6a8d5a504ee5e26c85fd97d5f58045dc79f52573bafc31ca63aae4a770bede17a880c42e9cba9e85d39c928e462de66fbe9a2d3ded8d5192ff05edcaf0c8993437212eea18f55fa0036cc62773e53340eccb768df6ec19c93af6b275a3a17fcbbfc954d73d4a1bf2d37fec46d60ae6188649ae9bb4245067c09b72924c40a305aacd94636d9abc3c9c7300ea8167888270b210f8f422047615fdeebd320e7634cf2743afa929e7e87f74d522a3e892818cf5faccfecf5d9ad810810ab380a70d192b731c164fd9226337f1d8753678ce86d09b3cbb2ddc2dafb85ec9fcd22c99a5c1d8c27912b55952838951b2a675cad771358b5874b03109bb77932ec0cd73c1f34ce67b0b6645f8a278d31ea14da5dd0e6322e2bdef12718a217809d2db6cd8b82d1b6b89cfeccc2dd727df01b00a18c60199004029140eef7bdbabef5c4248599fb2597d25927108649b38ecc25d55f257a096695082cc175e419c80565f12c1971fad3beb3b298f939dea7a7d97b85cc8eec824aed17def42f01f1c530b298c1e65f78d7d5d69bc5c0a6f0f158e69d9805af809711a800f8de5e23f42fca40c8d9a1842859071bb366e290b0a79ed638556d32b9952375bf6a44fd5ff2f69e401a4d22b362191b447c3a5f79c8c6201f9ea2af1bda20d5b5a241dafda8da590dcab7d9bd0ff8f7297c7084e73546458b2a46d9b20066190592306a584500d145be538d76c74a7851f2efb47e9e6e25c2118c25ac22e6470e84ef220de357e1d7aee8e2e97f69f5de655cf8d4ffa54ef00ca5dc59cf3496cf1249da51c67cc1f3063bb74919dd657aa842d1a91d8254016e01df43407f4be075cd4e9aecc6cbdf59c5c85b7582e9c31c92a47057c99fcd277e7f28d24bcdbcc9534b8f93af50ce4d81fcea5aae57c38c4cc7bc35c5013d4bbda12e4e1b87324eaf0969aadab9ed6bd7f2f1a4c0c623d246da72ec6875e09ab8b321c44171b9290ed51447644cf3a03b5a6ca7406bd4973c24a55bdd8600ab3d5139e49f8ee3e0197161ab1253d4e7d178944eb3bf940c9861eaa648a82026ee51990b07d07f319028b64b1d43c8ec1559e4c32daada5579be93e3d40a50874b4f933793780dca31fddb30643a9b7aa64e23a61d9e393be3d4d8ab4330dfcad57b4a1bc6f289c3f388cd82b5f38914f0ec0346edc672f4c194ee11c02e1f491094fd1cdfc7e2db072f0ae3b93085b5c259cfc7d12cdd1f7118ef2063afe91557f0b2be538af262f947f5c6b56655ee883be479d1f376f9f8677f46596de21e130ca92d9532828d3f2b63401fb71d045546d860036baa838907601130c885019bf4fb427052a609937aac9b3c63d137d189c14320593a7dde8df68d3984de1bc79a471b00b9f656b0614e8a6c8269029d2defa0222c1c66ed5f1c51c475ccd6b6c86ebde6466a527951412c0f467703a47b9e11c96d16e7aba46c4c617dda1232073963aa6ddae452c81dcd5be61231ca1bf31042ac5b151abb268d697a1f04953900665cb819103053787b668ac419378b40af0c0a3af1ced6b96002c2d8eb020131db6ccb6f8b1674a04fb4d5bef19bbbeef39ef2cf98824898980873e1ef62a753fc34c4f06aa23aea479216c8097d970353cd4682d350d59df4f1e96ce7930f4d7639130cbf7c6b5a15d58b397cd44fb033f279766cea8ba1e845961164331bfd7434ee067f0ebc204b013e01b5cc92dd892df94c629ebf2887aa47252f82b2112a9dfac706492aa5de740f65d30da86ced6595dcee1a8ed9231e90381ea168b70659f008013666e1d5dfa34eaa5e7a53ac34a3c1ee35f212513bc218835daf5ae664fa78a387392d5fd38be96f642aaf6573df363c73e65b4958b4a9d42669f7740669266d098fb2471462c2b9efc19773d6261224e39519dce95673968886a11c337205d2a0303ca6602ef6b1d0d2d18c81c664da450a8b9c1737fc38aedfb509d0c06b30ba04cc38281f07cfff73cd04a0ae10f1870bec37db2a8730960962c124882522c9da56fd08d1960ff9d9c6cc802a38edf4fbc4486e47a84b4f1f418eda0f2929308eaeba1219f52c6752ec03a597b39cc7976a37a936d2f4736e6e9d99a47a58218a02116d7402c0eb31efbb688b7632781e098e7d0ae8010b0e96bb19fc22a64e3f2d971621519ec8b9c8709bb1e79e334fad629dd012aa66a81d23b62239f986c36093cbb74b49a5daa21b35c1163d04b705d04060e05db71fe8834e66be8628959be15701c0256be93e7413e828e72344f634fc9ed7924406d72a1d67348f8660fc9edc35ff3151b5e1f724f1172f9f1ff01e398d445f8551ef207b07de2774ee9ef948cf2101002eab018485f4796a7bcdf75c13d2e7b1aa58083ddec1fc4154a0857105d364e7bbdb5074ca2df74e5c4ba3d73afde974d5603c88a6c3d2964de39e20061d404ef1ddf694626ebf213b5db618de015cecffad2454968b294669b3e6cb6b1a70150b6a89809d8f579bd91d007bd7bad4c02ac1fcc075d92f5549b036025f71434c56cf78b200e463ad9cb86e82708c2c9e513e107f5f162d9e214cd6bdb64c6fb892a95b16a28afb686dba5050def50e239f9ebe745b61b55d959840366c07297d4c85f9db0608759f573f1b014d5c8b95ae810e6bc0edddc570270598c1d6f8df997fea47b81d2363cac78c870fec82697b5a35355c8078d225720298358271a309a14db9335d1cf6fdbe452b26f48970816b963313ae61499a94c0328951bff2d10c9b63ec9cbbd7d94a51b2c330f3464e09699e300720e01cfc6fbafbf4a10aad0258885b8572d772402fae8e4a76118dabcc42a0efa25557ac7eac587963d396b1fc310c746a267f488e7345a133e5ee6708886525bdc52ae1b6a38c7d5e2b6adddf44e6664dd9e00600639cb80e2c82505966f2b77c63ecda005654e00107d74970dafa86aa11706af2e1c7f5d11cce24f3bf497c366a4343e53ce0e412e4f907674fec4db65c87f92ceed759d3d032374889b8abdbdccd68e6bed43dbb638a469e74772742a8d56a4ce7d47a9aaad080dfe2aaca48ff298fafacd772d961cad026f4cb7d1b1a93e59df475c8ecdee3ade11811ad2711085ba1e82663b57d4f1041dd87f6194e6d3e755c7b2a867373e9739ccbf4641ebef2fa5675fff87166b5d84165188be36c2dddac67616c03d0bac850a84862c87e38f054914376d3b60e7293d15eb9eaac3b07780748792dafbd0db4a531713021435649da7b5adbbfa43e38d64c2a5bd801a1904347457953c1758f32ad9cf88f3e9fe041da466b48cd3cea1a0f46fe094ce9400325a285d15b4d29e935ccd7a4517dfc73cb6f1f594d9aa08eb4f69bb459aefbaef6d412ee9e387fb5f5c05a1ebbe6a46f91aac5fb1bc818d4d35fe46daa48e84ad5dbf373132b179dc7c3631789b9516d2b01e2aae36a1fd3fe53498a0752330129b2d33c2595fc763e17e156dbbd0ff198e8675f12a9d7b67125029a45483be40c17690217afc034c0ceed945a80ee1510048f5f7eabc71f6c14afa15204255160b88bc01b1bee0a05511f3ebd7d9335c379cded8accb6a6124186ecf5ccea7345f1e21a1191890475a7dde8768a86ba5dd6a6fc0bcd12d6c934adb4868eee8c8aaadf2043c4e9198feb6e04adb92362fe26c1c0cb45767f214fe87ef9545e965a2c90be47840696aff6c4db54c6d36f10596c1534fdc1b8f848f4d5d3e8a81e9f2364a19a73bef160eecbd583ce4326492c541519cab0defa019d7ba0859f17d81018f033da6666520d889f41294bddc2ba7ac312f936057ab0c147f95f92e22de02f46339c64a1e2110b864ad249df1e4072431f6c45a6957878aafe20daa8b316022a32af9c09385087f430a6984e7c40b762605ef704d6fcbda6d5030ca3d01e9eb75eb098ab3ef6ae95fef475bf590b860725c424ec505816768c92ebb80b74981697867a028f6e31878af36dca2c4d65771a6b105093a47ab913fea7c458b470eb23b62e03d94691f39298dcbb055e036b841bf93345dbf9408064a8e92cea819c1f6479cda7f996f9ac086668d6e3db3f18fc98a7d3be41d1287b7760b1b5f66d796765d9818f50541fa0490d7dfac814a924dee0f1d8f6dbf636f888b6eeae21c4d26b39bc2abd6cf7bdb3fd60940d7c63b3fc1b28df0e9cc2ddf97a97fe665eec0e1a18728bf23c575c00e1560d3d69ef526a80e1feba2d8fdabb39f002fa5bba45e21500274fd6c4961c3a1e809624f1b316e3533463fc8c0ecca7d2651315b05448c33d8b49de3fb9ba9542f4c8ed37ea7e23b8bf64c958993d784e1f7368e90c5e8135b852ca38577f6113e3f800ed060bacc982df1ab489b0d41ad8762cc527a71a7be0d093ae665587dcd8a0e30dd2bb43789cbf65510dde5b3afd6f744bde320e2c362adbc960ea520fdbd8a5caa82c89fcf667cac848e3732df692df44763cface307e112bda691d20e1534ee26e85a31c012fcb5bf978d1bae9442214e5292552d8261e92785dc8fe08bb8eabd7fde50c1b4d443a99205853e66292cbfb10123c5a6769517a550cbfa8331852f80768ccedf669754f795f75898965e0aea7a64612e38bf7d49a6e82f7962ef516d5e713ee553b2c01b6dfd73b792c9e784eb7a4fff3cf4fb7b38ffd84ea0f8e5d919b3fa466e06b9a314ed6370c7e904ad7e1f2e11580b177653104a648a9a23377af2f11368cb15b381a6cb5d0b28a8e6b578b25e099cecf2a914b17aa6e4c4d6ddf9abe8d845bf97bc27e0d79ccdcb87e79ad81e23a3f32a1b7c01a0fdb70f3d54105599906a6b12d1345099ccb44e4f04234f66c94f4945921c05e03c9debfe34bb906393e942ea81858b785b296c78be7c221f97d5bdfdd7bfc25a924e5caf1df75433382f047dd5afe92732a9b20c29fbff7b605afa261e3c2b53b316f8e460a7361df16b387fb1d8bca906d99dafd81e5f75496566206264ced69b0ec681d3aa1453df07b83ce821f4241b8b3de6164d4e1592689224b0d1855a3dd8b866c7e2b0620bea173334cb1f7659de041d6bc9c4e431e7371d2620bd0bcce4d2263d576e09f031339c3f6f4db69df041e9755905392658518e531038d37ddfcceecda2c8e737657fdd1dc17add927a849bcb4680f7cd698895d4c95d98253a96ca418061acab12b4aa5b99294bc55fc63f75088f518a3de08b73d1e9fb58a38a12704efc4ca0af03c21931f78f8fe9946637010c27b605fdd97c091bba85cb2fadcf93028d8a7244670989c8dc457f316794d53cd173e00f4ae48f61e05acbb0e67a343249032133331a2d35c438aaa8a26917c0303ea54cbd787f829116f17de9c945861a9114b85bc142f2e10d599431ee9d3d8bb04841964d72c12ff5304476c05ea8dbe53b4cd4d8bc567c173161245d47552ec14287942b0d51729b889b3f41af661793084485b8d699ef5d6cf0d253bbb21793d79f1e7f63d53dd0c54de10f694b164ce5c67df6c44fb980d1ec9054228e54f725f3e42a7304af336db37cdd554c91af9ed2764029fd258e9bf0e51eed48ffe30a895977cab51afe91eb768980a6481b7cc316e526fd8b92ed411b3ac5d9682005793a389a0305542440ed813e5faeead0cc7564e5aec5a5b10d04eeb77b007b15cefe4dffa4b288592ffa39ec5f17bc9538cbb8d58b085150f87fad416c292d7f0a3398b8adc6d1c20ae6bc8a11de0461a6d74f699b9feab36331127beeec2249d61fd0b7cacd7da8abf5d63517c9b00e5d297d0ce8268b8b25f7e067300f4bcd6c81f3672dea198e88855ef39ad3497f76ea610a9db38309fe37835985b3621a5a8c4a5476a7f1b45792d515eccba0377d2a99caab6a264124e4ecc6d1768e2a4854bc560b441677287d9d7cdbb55dbb24235e400df7aad7e0342d347478338a18e3a208a115d25f0a8c9d6d2de648c3000106cfaf28695265076b06236e5a5db7242853dc9ac03ca89df7f38a733eac6f4feaec1b8253ccec5995ec88461bb8b01797d8cc9d9aa3c3f14a9c00367d461588f9c70e0845cac1cb8f9b52d5699134f0f640897c1e2be0eb4207417f093fabbcde87603d4586b4679a6f467300e44a5c2fb13bfeb27fa295795798a67234396f0b9b1b15e5e268695a867654f58e3dc9693f67aaa03cc1cc4034146faf57bfeb1ea423f0b92bbf454bbb4cf7f88899ad17a2970efe85d2c0f0520f2c741353f32b2709fc071286f7469f286071b5e3bc04df10b5194ed618b09e52927484272e38a9adb890fe60dc7e91c4b4e74260fc1f8885af9c08fa579537efa3a90535ef1976646bf635afd01fd6f6374ac18f396f0a6b59221a9de119990a29258d3259b44a33b51d224eadd63261d01e600c3b84d7159156f472f0f12fa8561b47b264b4f5c0b099d89a071ca7f568495eded6c3b2be9d07024326e452aa80d7568c720353ac8282e72b895b2643e7ace37c7a681e27d55f87fc9ee0d790c9aa2e68819cc089e06aaeb9259372bcebcb78ecb84b485ca68e8778fb0ee57de3c4d17aa5db1a769d2ca316e53b4c48a6ec3e88bb138bda8be189601b25fc0eefdfa0923718ed4e58f25e76e5487b79dee471367f93d0ff62df8f64b103d4d2038784ff2e9e5653beb0cdb43ab024aa54d91f995ffb91144337a735fe16642e81d748289aed59ddf5b21fdd7581c81367636946d281fbc7f477051ae40a1f9dac04989b83b72aefa4fc77f74ab0a22569491d3ebec678db641487cdb2fd20cf79379c20cb4beca99e1ec13c6989f2492deecbbe35551ce9ea123b58de25a50ddd7c8ca1edd47912299287c462de7870cea726be994d7eb2867323a7996bb61676dcb465250c32bdd975d52ab0f2b68c77dec17c08574d0e55baaa2225b2c3390b872b9785207153c8e2014f79bc07c2a603e0faeb28661d29d19f8db48cf9058e78a65a68347ebd70bd29988180d2d0d43384c44921b6d80f53f921902b08adab8b8e311cf4ea3f2c3a794305af674139f15177c5ea75ec2e18cb23bf89b870cb1a00abde8b820e59129b0aee7741530912ccda7d6ffc1f05021bb6bcde418963799a3de6485c3497473c460b9434934ad12102f798f23aa558e0a6fc3b47c2aa51dab8f9fee6252dcdc4e9f3cfa2b4990d924c485ee7ad75a3919b67658a1dd0df898d4b437d3f196840469e6ce45652f461aca6476aabffde981254da1eef914d60ac758ebf282d008317074007b353462a07722aaf659b127e3998782f8c945d46bc5ad001c5668f8aa80d9d8e64ab0d68eb2a43da88dd2d5c1b468bb2a00ee37faf7964ab3548773b7b6320949439c65a3acb424c51bc13479f41d00362a483f3b84b881fc93066c980fb2734a2c3b24c9296f8a769f45655ac8ef8473effdafce0740ab77109976020a0e4c7daa50d6d3bc7d52fd8892abd7d025a752b0ed1ad63681891fc22fcccd834736cf1ce4b20f286dccd06683d38d03d9a17589b52639424b8ed5e008afa9beeb654579e3d00832d68e948af3c564e85102f7c1cde62166a9a08405e2b2af0d6751d84dde485762bc27b78a851b848a0990d5aad344a1562c2eacaa5f198f2a120f0e0c3879a888d2ede5715760b1d7606e5056444af94fd8fa8501206325a0488001f9e60be5551f22c81dcdaa75af1e4d7dc6b18e77b0d577810529eda8f7bf073e9eaa83938ca75224e6a023c6fe772d94febadb1ea3bb2279484de66f8a41282c8243d7bd7eae0f2e9be4ea3708c20926b3116d600d54d21eb215509c5b0302519182aa55f6d81212bd0bc3f32778d66376d0a0260f69a0d7ffbe40088b46576ddd6646b80e7b18d692cb8f8e25c729070fe9d4fd9cadde918b04b187871f8897f7569670c3d8227f36dd674a1ef0d98eff8d83e040bc22e569fee41dd8559ec0d5a6294dc5d4418cd60d1b7b6790fe8151d75ad4a61fb20e1069f4a0b0dc9e2e185b2da5e6581b95b72c8560fbf2cc32205a9a04e43e5e6e940e37a983806d1fbb92e243ba3f34cb41914257b622c52f33f65642a2bf663aca18a97abe5c2b774e5b9bbc19337dace4a404a2d7abd891cb2a7592ef960f78f5cdf9a756437f5afc4a4346fa8f23483bde90258e95722b5a1049cb9f4bc61f76e6d4befb86dc73adfaa75241a5da543769f451e26b0e18838dd9c9e62d67b1a31c6be3e0669027c617c5cde854c5b0acd59fc9ff190eaeb1517d77efc820db1e5cdb195aa3796ca4a889ed85b9131e62379aefad07f3cfc5869d80fc2775abe9273ad6495c6a29004883e4b69d3bb10a6603139aa7dd2379a157548f3150ce960c5486a5a737dc38a62a8dab08741e570bdd65c3ad87b7cfee9f72563283d1d32d4af57b761f03a8aff07bf1676f3d3cab5a8c8fa253b25566c41e80aaf79d8c6e755e2a21d1bd3ea9618a4298fdbac7094e4114b6acfa59e3bfaf1a4162044d0c7bb03ae38c9b4fc4178855cdd73ecace31922b3d69c73332879e067d32d600a576327767c95b2582f1f7c8aec0627c2a8b1ef2e5c7f8fffacf62605ff40c810d3e1955fe623280bd044897208322331462ccae81ec2da05d08f25f6bb7d44c04d6d7b4acdf96ea6568f77b3cf4e4323726a84bfa264a89601ec5625b9ebba970577e1e8aa415f3960367895b2ed5b942dda05287e9050b7090c730b8aec3b20c7c6b8bbcce388c0fb18feb35b02df9ce7acb7ba8cebe432118b75b6adf266a0d7dd59bfcc3a71666a4a2e25e7ed9426c6e86283831ef034903e046ecf2bcd6b1df67acab3af71b4b0c22ea50223c49ea25d6a6b8a4e9d15504944f9309e28106df5a9b888ea58ff203b7c404cbdfe403708eb0b52fd3ef30726cfba66be365313e0b4ab2e854d4418cfda15ffa81d03f0345b5df2d3aeda4bba428af5a5065b7b3de634aa07bda7e3c6775e4e3eca581a50910905bb8995509f6b50a4e472b8af3d2f6cacd19aac3863c5e15b434cffc8eb7e0d3d42191d4e9d882d5292a945f5b5c654ea2d85967019378f9592c2b0e949edc58e08d1906fcd2fc2f8b96db407b706c6f45f139caae439558a52c703b550cb69f0bd048b8bdc101ad0d72a28bc415c0a8acda784f8561e0be6da2f67567828de9b5ea0131d4231c9bb59353a098aace38a4d2420455e6bdc36a6c1e31cffd7f12f8c87b254d5904113749d5bbebc54871cb7fe1a2a46e133a00c11e69863afef7f9d6b4c2d2686072feaf5b2c983af99d828c3a80e6b67cfea806884f015f649777d514ae0e30a0681793bc1ffa8b118ec6835e802cf3906bba68c0ba073da8d3ab94a2b78907403c7440e62bab0eac8bfff2fde2ffd77491b5300cd52168dbd00335db40fc25e172ae5dcc6cd591d5d924961d631f24deb4443a3fc079f581d429cc76114b885fc42bca47cc40e3228ff4584064a200c1b4d489ec3b3f9609b9732df1d24f4d6d583f14c89ec547711e05a9a7764726ae1981545b35dd1ac5629e4952fd11ee8a47523088f2835a8feff708fa9ac935fc0503265d411a435fbb95a065f724e0818af0d9fb58b2a84910cf8c5b0d67a26bf349e71d352ed1242b85e575b8d7f4a6cbad10149ca8460f77f333db86aeafaffbea022b959263b711140ffd8064b0ed5228f1386b3215df27a67c417533594f224bb5873e75b0d8794cb26f03bcdaed6a70c42e17d9acb5ab92f41d2d4f9566ccba8145d4a3d0428940ed1ce3d7ad40bd9dfc0d125a0319fbc6e136fc248f578edce0dddfd8a1378644e29800b592bbc6601d83dc17600aea105d610e6048f621d1c0f57e48268e4a48fe78953a3e342db2608c8bbf4743375a8e1d6fbd1b9fe62871e5fe340f8e90924dd2ab09ae1baaaa9c048060d027f541e70e6102456d7b3a90e9005a4dc42772ff91d61cd42abe468f4d4efe883e2582230ba5dcd767379f26b9258e2bcff03cbce8f18ecf9150d22162695fd932a91051c30a50af6016ebb8428a1a26b0a840af21cdc8970a3ef70d8c7a60f1dd19f31981f77dee27037bceaa3b035bba6f5d8b5aa20e58de6f16eeb3c940f384639e56983c4c19c9f4d517bc358b927b9094973169660e9bb93204bf9ed4ac2f4e233248105839a9732582f3a2e47771325da50732e2e8bda94852208660624f55c5b298fa05a571048ba45ffce0b0d2ed8425e103d9e10250c7577767a7783416b8f1d6b872cb67c23f047bca63db86d9dad4a025e1984f9c953d2b1815a84361cca3254fa78a0205826e0acdaa47cbcd655dacea00a4f3c0e84fd33696c80fd1d642237e39ace1f9f1e0c8c0d493e407f02e9c1e3e64b047da9ba88e7536d8fe16247adfbce516acf98ac77ff1731cbdcc28352d52e2e166a600347393b2c47c543c362231856e743c19602a3a4680e27c58439d1ae696bfa90276fc4ade629df01d5f050006187798087c644661bd081574e731de538cac8c02bc325d7752650b6967fd1f4b5644f227851e60c26dc83b4396802aed43b1da8cdde118bd9788cd2bfc0c70f630bcb9215d9dae2767ead81fa37047f6a7803cd2b169dcc23f2846a507dc500e0872c8489b39bdf479a94abbc3053c0f030811f010cc64d31e02a2c5cf7ba7c58bd7ae2384c1ed069044be7d2712a56175a29c7348113d1abb67e17458321df0a76ef39fc616f4fa2fe1877569f93c6e5a06cce3a7aa46196915cf35e9fc3a27ff78afdf25d1f140504eb7df398546fc0c61dd1d3c3b00f67b264e0982a69ad6daec45ff948785712dbc7be6ac8673663fc9231a774b9349904aa5e59fb249414fa2118849264c4456af36384c83a847c50e4fb03f6a32425cb3567899f1414b98ff146ecff03b84b955f871c41c2847cf0df0d1a7d134f5d2baf14c08c73631fdb1734c8dbc1ef575a98b7df92dceb2f121584121841a4a57a128db34e168e798e78149bf05a92c8a3b8183af159c3381306c3adf0723d53182ab5563feabf3940163f9304240181b22c17c7256decaa9fe30422e56cbc1f4aecbefd40a1a6e04d953d908b3bc64294409a1f67058092f66db3841ee2b327c5fba5eeacb6412501cb8115a27329f8f9cbda80d2aacdc44cfeb814968f4baa56b10ca81ccdebf2e78f698d2296fe7f607fdce9fedca7e2b0f613f8039445abd3aca63770c5ddfbdadc4b1e088a70b0663a0e687357651d49e1ed5e8660d2b23fed41c242d2dd98979b6697d82e063ec1f550c9b097d3c5abf5533c9f0ef198922722330c6c9bb1ea94f470746cf0d89a69596fd23930f35485ae12edc1c805b4c582366544a1c2ba73f2109bfb67f1485b3e7bc99df17e566df07dbd9ed8f06008be467e244d26d6f08962092a28153acfe7399b2e4527cb6770168ced47a57aced1ad3e0a812bdceb58dc210cfa1abb0baaf049b0651420e180e76016c69d4125783642f1ec4ba5a6fef6e6699fc776752845e36913e85faeb9b438b2b7b0e3c5e8976a45374671725aec8ec5cbdba7f6ee92b76baa92f78576d17c606e679c023a7f3fce5566ba951343218f4164acb250d58540c24f0a9f75509e254a302ae910934ebbde9a29b69f7502ca55963e3f8a910b241a1c3722eb4ed731a902d7587831ade0655d0c3fca2c0bb90ec45b0aaa479e45f96fb830131d06407af7777b2cf1b4480ee2b2755fabd381818d57bbd4f92ebb23afe65346c0053a841a73d108bab56cef9c45957c7d2fca4cb6b360fd55c069f4915494f56fd932b942249c1ae8918c3726cd8e7fb9e3ea43bb1772b497efe0da7a332a0aabe3d9f308a0931256f5bcfae0fab8bf5375f52ed316b4e2c756314910c9374aed792b4e3e6d0fde1d4f11ec90d61ee58721afdd7f295baa297541772951d1fb228e2baa345b013343b7a104dd64208f6bc43aac27aa70d357d82ddd695df70fb2690650fba9c29a664e1c44d647e2ca35f7b7c7565325162637c86582caed9195eec83797ce6382a836961bc0b8a97beb9b8938d5302b54f8cafecb07e0ebde9872788f611eea25517fdb23804c4085900e9a802656771db1cb51983f2f0ed293af407ab8e7c12266ced33c27c92e7b9b10804dd6808a01fda3a52840d5cd16f2908411a04d369ef2cdd27b59e802d6694185c953c189d7a03e9b11ce6f682e8d56232c406d78bc848b148e20c08ed4a76f5104d334567da003782cf0e76e12c20c052c0b4d3b84cc0c097d8d1dad2eaae6ad4545df537955f6be61dcadd510fc5a65fba5c57f54270973f686d3bfa207ef385be67559b90e6e25f21d3db6a16f36d7f240db578032096a13719ded652a065e7e8a19391dc94856fbb0a470dadbcdb0bde5d3d1949908a407724ffd4817421aa86cefa13296da9d24447f3960b9350b5ebfcac7c83ccf7ce6652b493d13e72cc2f9d5643b730562af1324f8424611ccde3c10b3891c0cf2747c1da0478d94bf72dd9589c162223b2bdf13d0db8e54767a7c94888fd3093b821d080093e90b75ee6594d86d463f82ecb3bc1a9b7125455e39adba45f2de10f35150b79c6907f87289b3064b35473ab9c6f60537130fa65d7443d7a22bded96cb2e77b08c25ea7406c15d8b943e18c6b80b62695a81f19f0aaa93f74fccec7b00114cc0bfcad0db3614a172a375d2726c20f8e28c9ad48649097900c79356406e466f9c46447169633ffcc0cb88cd3bdfb70d6dceb3659efed08f107c56c884d7dccdea5c7156a87edd7bf50065f903b361387f6b89563d6f49cfe75e18ba9cb0597d210bbb708d397d70031dcf43cbcc910b280b093e6d7c6fdf2139b0967d26b43baea48f554c22833d049395049d93afd6d8de1b8ca4c00f4aa23b883a63f7100fa8c612b8d899ecc841a95358454abda30b76c1c4fa76b5f5279917a16779eb9cef774ffa91106862e1a0cdf45eb1dab56abf3a9356157124a1d3e0f41607526c14d1fb5be3bd573af2f934913e7ead61461c09adc1c51ada9b7614f3f5e9ef114f0d51704b4446c5adfa68eaa21de5775015f53a72ce53f3d48a4d15fc26adcd8ddd2cec98c15b3fd642cf2ac110b039ca91eb41051f740dcfd5e21c6a66fb88131c97253fcdaa0241a07672917eb9b24b7b06900f0caa07eab483fa516516208d9b25d19122998c945924ac0d66c35b91d31fd8c1231db6453a9dc5efc6ad78bc77df04716be93cec4c00ed1cbe06caea3633ec82e00d0051da9fd52cf1e107f7f767ee3b7efe73a13816a4c139c5d0e6126c275e0b2a58e93d5047a6dcc3383cbcb3034a464bcb85eb065aee667890fc495f799af6436db50d8f2a0f05fa040085f5d7400c7edf71bd73963d87216469fd978469cb9afe1d08fa0fd37a7da5165d8257054babe8c8d40bf0230c9bbaf1ada6b4cd809849d5b8df3771018ebf2b7ad5f917ab3475a7e0bb11520be14247a2a9ad04a20e34931d53c9b36d142c7a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
