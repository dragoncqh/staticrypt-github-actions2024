<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ce74d0402591da8c39f5ce63002d23bb186d78bf7052d18e6250d93e7fcab86af3911c82a43189b28ecc8e41764741a2e0471932d508f413fc4782510d1024bd53ea1865a8bb43e6d96e44530351bf09a038bfb71b8cff9229eeb374890a445a5210f851ba4306eb73ef41a228296ce9789a5159924351f6bf8ce88093d9108886dd4de14d7e69f30c42d86e175ae602350eab1b0058956c3c17131756f8974fd8f544e37a40a7495d13f15f2957ff8b4c91671e43c00bb0db31471238a57eab3836806f3f487ae84fdefa0535cca69d13446ddc6ec14ef4c7717379344db6e55941cf3b4653216fea26f36306ebe707a1ccdfa6c13d7047b58dfce6b12bc5aa01276b4337231dc88319f646ac8a4a7a8c7c717878155174317488355b7b3f8f37ee08895c77cf694d4758532585fa83f610261caa6ceb47d4dcae17c2e478d375cd9ee72fdedc0c2f800bafd39cc11189f137f83b8a38085afcc0fb3842011db83a85bf2e670302eb947feac8bc0e13acd5efe335a56ed78f382c368882d9186ed3fa64fc19d86ec618193e51e8bd88f554e70724b76703f35d424f661ed8bcdf30d6ecc23780ab95ddbf17a31399afb832b57fe2812f97e1a5ce821f8080525a4188e450cddcbf9c9ac6446783ff8fb0f420082abc556ff8ff73c73012f35408dbdfaa4d067a1c8577186941954a8bfb8facfbe081f2d2ab16a6e022051fc616ba642fb9368cedf781dec42f28cd8c740a05a87c93ee0c3310df14167d43cd3c14607fdc18ea7e35fe568a11b8e64122a9be36aa73561404663fd26585612bc5402776b6cd159f41953f851bf9bd1c80f12a547b1c568cf0f853aa5c91f5ae703eb24b93f5d4025ca5a8f3ff69e2887dda48d53707f9f70a645154863e4a8b56aa08513a4e0baf7b7251e8797184454c4d1b6dbfd66380263a3e4dbf436b607e834c76bfdbcb05e931ab612332e4a737c87c42eaa74099eb5d4c4131db1b8f2c282fd84011e15ee29a12da13760ccd9f269053ff2a7017137db0493398074702492461ff11603668b9863c7e026c7c4592b1f1c1d612789891c912aff7836c8fb6a00bda3d83d17178ac10cdbb29833899cefe04ae5a9b77dc3600dc7ca522506ecfd4ad0b097702f06ac63fdee2d61edc00693a2f41cbf52351e5fcde7432abe66a6e47a1cfa14f3324fed67b041ec2fa5f4f434c4e43e7fafa1ccf75a128281f986be58d4ff015e210a7efe682f17f220f06e44bb645cac492bf48d718655510e5726f72ea4744983e96c77e9e6b7a07748b1f09792e023bf58d6c0506560e1bace009adf090e69f6dd2415c4ec8b35d911470639d4d253d7c0067597ffa0a07e896c57eab884d2a97e3195d96b956369f250c154cd58ed0704202e93a90d3bef0afb9305ea1c543d167e2e054f2cf0771236828b3d24aa28e6225d38f65455268a0486627822dbd5abb244750ab9cca0784a1d8e1550100000f9a6ff738ff92caa3e65a7ddfab441c3b35b933618c3e141497fd6a54c0c355d51c37aa084c990a93d32821b17d3fa0c54497440a476d43fb70c70ed1e1ffaae45d725e096cdfbfe78d988e9b6c71e076344184bd7caa16f64c09165677c92e0bb7b2ae0c066deda966d7bf8a0b35df138ff4bf2e93aa63dc04e163699efb4fc867dd61684e89303f285c691b0f239325c321890e1614de36a5c884986ef3d2efb1dd123eb25c7e0dd1a7930613402100ba1d58aeb72fbfdc89f837834668a3e83cdf3e19f76ed4b796bf74b556a4d583b17740f7d56b37d99af354ecade083695d5fa5bf12fb96135179df20d41dc0242827a323dc0e2c0bb388c62adb840301b85b2897537f4ea654963a75c2ff55b938b85c966055a11dc81ff0d302d40fd2ee5731f3fbf31c0d19899fd4b41404490bcbbd8ed0fddf132a580174f9884c581fb373ab4154a89d76cc2cd3b6e3e6884e3bb899396f401ef377f356fe60de69d3a5c6cf61756fb78fbdbabec4b8eddef5c1af04ac5d7fdd3c4a9853ab5ef8cc0837804477e672dce7539f83d856765299090637c741e10b565252bafaa955925168c38e7eba679e77b7684c10d76daf15de9cf99fd1fcf638b6a8b6558147c001e50a81a93ea6f24c8e86862011fc4ea108147fa75f3dbeb1b463dcb9883beafd99a464106f78632d1f7a10ef02a21dc4ea9e29f537ae342a11d1599fe5e05223b3788eeec40f65eedb521b91c24bfa38c87178d012cb24df466c546cff2e3d11e0e18956010b898a5fbe544f16815109ac3ab2ef783aa09eb6f7ba9d64d4854bd68ec02825d5bf2c6897111ff90079ad58b0675f782aec4da12c9856c88761b0183fbad82b2bbd02199716cc0e2f6b31e27b3032673653b0b555d7a420d95b4d6e06d458552d4512906c19e2061f8b5ab333d8c8ad6d50473917336c8eb946d1b5fe201a131b7e65ff0416d53acadf2d17ce10c6e212c116d639236f3135578ab7fb65b623caa546d25162af04a28e8d76556945d81afcdb7a9c4ac821c0735706b744aafa0726a113f23e48124e2f4dbb12518ac8703ae9ed313ab23403a4510b4b0ba438595fc31d0b3f357d6eb28bdbd7a554639edc8ab0505d0ad364e1c5db4d6c8e4844f1a6a14d43728b40b7b85baae1d0dce28ba68607ef56086546bf3241749a8fc75023c745d93d177e5200ca6c7aa30da5587e5cd4f5cf5e4a7dfe012ea9e1812a1b65e89a96d341fd107461de869893821c59f2b5a72501fba97df80d46c2b4fad8a51dfaed127211b99758e073ce39508aef689c66609a69ad43be7c73d1323dba1d41d0e4261f86985089692891e950c05f2be48603a8e6acead5fd6a5e4b08ef3e28219968e4ce2eb49f8fc1f439df667fa8e7989b625bd1ef38f439087d9b72855cca4b5ca73bb55a65dbe72ed9cf2e672d2ee174d501d62d951678e4c1f3f1d7ff413203bbb9e45a31cf3cc0b0d55c7b9bf166d614da84f9e80eb2ffede2ec755ca093c2649e02b2d51d8d4147665f1aeec619557d3fa0e6bcca1391bb9c5b39f741c080a5e78d4712518fa8cef1555fe2d567bc216a42617fef3c8b8e2ff4ff54be8b33c7bd128ccc51a6405d1d8499b588d4ffa40793d8b6c8b37e6a73c6151e6a742c323751b51968edadf432f6853be6e41293bfb3a25c142564aca612939a1191e17101706cb3da0c36949e106c566d38ebce5c1d7567d741a70e34f0ee20e203b527e1d34d4234451720f8a79ee885e85551d1e2686e3137e55895991ba881a0df0f500f7634793b2e91876ef9c3f9b7dfcb72124281ab155d8c2505ae2ae109001eacd7b39e89234d40bda5f9b5b53f12c077269c6ff49a108a40a75b3ada907d8fb19471b7e38362f05399df44c77b44d9c2b54c6e53eb55ac555bd0b2a5dd1d3a6ae5827d93aa0f55bd80dfcb6559ded41abcc98a516fc564ec7a03545552da7644dc8a2ab721618fe973c48595d5ae87c9959a280ddcb77a17290e5b926ff26d5499989af0221badd522a91c5d3909f3d387333a3bcba807747670298d58b7c989193d8ab53c4175ddfd78e272f8045108c866c92837bd5dc79be79d08c265b9abe5bc017dc427ab302e8acd9af8e85d9e4f8e5813879f61c91fd78a22eab3260b49e446f2d808d70292136565b408c5b754bbec31c64681ffdc82ad3a351c63bfd2a87efedeaf8e1ad302ed80c1d7689c423f20768eb8af9c6d8d6ff8c6547b77f4cdbff5df05a66b3abbcba4c86c2f61c03d6f59a1e787ed877a51ae945f4d7e89cecefaceea349a8a5ee7f6006bcaf33166321070d2eb91bf1feb7ca8bd5b090a57f63c55ff7bc1866503cc640870fae0a9426d6b6226e421974b9c56d85df5e79fd82392ac5dd500b30be4b6e5002b118ab850208b3b37c67eba04e431a1d598fdfe42faafe5c17e9fb027e34be40207dc4bc8ae9998cabb3a371b40c9a3a981b82eece5206a609d23518ae2094f024882cba55cbdd87892992fb0f75c729f7db910e8cda501b45143d3bfb3b479e6b8fd4ba2d914dd5404c3103839b4854d480fecde27e77fa435065de8c0e0e30bb1984378eaaf77b7750c36e4364b50ee2d769db1c8f43297563079a18cb83d00e8d2c42fd6aa2fba0c511972b1dfe044d4008aaff701d7f7d554e3e7811eb09e38c728fe880f92f3e00791ac260d1de42a4896274e39a4cbb339b7ec4864abb04a9f97466a29c63da3b29caabf28b5177ab4f37a29031d0038c6ac76945223571629bdd5cbf13e404eca41187ef32f394405e01adeb774199e2d5d2fb1191b4787a2f120a34764d2c45cb24af5e577aacc1c36e6ee95872626fe406a5158e8cdc4490a9798585a809267a4ce4847538ed22fe5deb23c9576cf39812d68b67a241532ebc16412c6fd622f8eb95df5e5376a293312770d4ee4d96c02f5a945c575f801502d2a2403cf117b2bd6c7e41df54bb9938e36a8a3a6dde891577a8438245b951ca10e7832f9fc22b73117f3f79c994a86d0358e0ddc15b459cf8929cc47d449696e9d5d548d33eaccf245020588b7ce88bfb7af61b7888eca31f3e6701ab6a6d24f6f56f39e0a5dedee53da73cb263c8b8dc971aaed1f8f42b07838992c30ad73da5252815bdb3d9018670891973a82722c0dd3185cf53d10c7f40285af55aa34c870f5a21f41db4a1973f675fd6fe9c942377c02b22068424f549d6304b70a77811927493d2ef05666759dfdb4bd0eb827fa446a8ac696f8b063bcf380a424ac2dd699388fa08f210590c8444f8c43ab6830c141b3dcebe34df0a8290f5f65c0885201a6675c768dac90f9d8110b5bdeaa24320833dfc1bee90ea505ee832a8c7ef06b151775f19014340019905262f8f49e44e54a0e7551e44c69c148489157f10f17b6eaba9f3d61b5f8bf77d0b73f9fe0a91daccc21222f41ab35e6ec8904b42293931af5d90518eb128e9c31d2603f2dcff92e8f6d6c2f3734e4876c609f82c002d871111a00d7bf350e9af333ca7b7ef33246a112bb76c6964091cf8108766599c676a72e42c933292b5635ca03a5b907e42630f066419f1170068bb518b26c8d12b7a17c144e9960aa3fa4f56562db009faa33e74129529d67400269a5ce86afc62a8278a14ea852bee59a1689a75034dedcb9472566cfbec0c3fad807fa648849a41fdf4f59a3687dab94532404a7ddbcdc47decfed59abdf67ac24a26d04aff9068f32b48e8c8056d061d8f7a5609b6c9b59682ddab3e2e1ba3c0d0b392834e9961abd3a3a688e97a1016802a327652c6946c76adbe20b90b6a9b8aad0a4bc05912f2512389416c8588d471230c32c4f8539e6b505a61c768b017e7bd6e056a3128fee0f7d44239f7f00dc141e05d95abe497a241ed35ccf26f4f44eacd88f7fd42264773da531ebea387bbc01acb402b8027792289b448a2059f4fa1e90037042c03cd41f9dfe30c403d36e1ec0a34c3b54061e846fbea56092890c3fcd173ec35e12cc815a95fcce6293781fd731345372796f2f14e52adc15c78c72398385bfba5bca94d853102eb4eb3d5653aa238a1363570c91fc91abaa20e5f98cc20587d82e67c277111593b71fa6fb8fcfaf1b357d0a2293f635db2190c7b667bfa74b35083514ea567e711371f59b1c8f100ec44288ff4210a21ea1cdca34f51f164c9b4a6ff8ff119fb0a8ccc8487b51fe94e3dafde9631f88a2734959e04656855a5e1414abe01c0c0651d0facd38b20695000b9cc6a0206a91e19e75713b8cb829265eda6b38c97ce7686bacc4c96aec11197ed2d22090012cb0fdf7fb8002360dc9be0c69c49a61bd71cc63e0797c88471b86bfad687e0ebce2ac7027f8be9e997ee33ad8c00318f653e2c0ed8f1de10751d091d67f2e6d3d6c33941b08cb0e7dc92c5838a47f8aea7b41a91fce235f84813f273a7dbd57c5deb26f7c760bc6674b1891046f58499c6d982566065e522cd935f72656cdc4064a4fa5b97a54a3838227d8cd4f344651a8a60a7b217e72abcf2fb2640077055808f4aabcca99f850e0c96727ed4b2075e4cf3d34683e7a6723c5f759b101399b7724ef8732b1b2685e22057b8bc499ca4f8c76d444b74ab836bd68aafe86f60de3e62b4ceee5b756f752c8a7b1b75862bfe1ae8fc8794fd676fb75c49f637ab6c6bb62644f5df40326c878dbc13e076cbc9a0c2d81057a471ff1ccc2e8e3157f72a272041301cc819c048c1858ab9c97f5d4f9a56c26a0709eebf825c0932d45e4f301a30362e4effa1f8bd5ad9eea274d3786aa815803efe70e049ae29a448dad78f59587e0c57d9b0afc9cc52aeca86e781ad94cd030160b4c787ec7cc1e1a89ab669b0cadb63ead8fe83d128a7f851c666143420cada9d65cc260335422972e70785b4cac88689190f544d406ef3644b9a4260a640d5326728049bbbfeb5a08b5b94813d0e1af5b91c94fb59cd2fb3922043aec11adee89ce7a195faaa1cbaff164e3121d745fac5e71789dc331944aa56ab91bc70ccb47f593ac8a8fc0270d0ba3ec977cf8d2a03aa42529f224f025ce01d329bbe5a432ba9225f530ee275cf926f75ca121baa5cf872f50165cfbda4a3dd70adc1bb22bec84647861c92275351833c98a1db0cc5570a74806367ad00c5bf9d7ce243c97c102042d2945b27289705a2b67b52c20946f91c4f7613ae8f6c16fb462b7574ae5b3c41e0534633f18c9fae7b3d25a3b732746728c345f7818b62f4dd7fc0b235e9ed4874bb29b803c4c5d1619b8861926c42b95244279756b52974871a47fbc71799e4ed05c027c335a033d87e90fd2ae2c6f5d33b5024615f0d853a59e486c3c58f785a48f1109ca35d6582c06efd19bbdbc7f5a0ba027ced5591147a69859aa06e5d809d1ab658512c42d583cd04124cebe69c92de2d6ae64c5b3f7bb23cf3d708785831ca47d0825dffeea7cf8665f80a5bc3a0894874fa20a5b49f485773b55080b1a820032165c413b2460c919f147dbf4e0807f7b797fc67953c027bdda148b0be49039aee00d3413879f7131585197aeab8c5e3066eb530854ee4c7c465b2143fda6e3eca5254ada8d8b559f9222781ff8f2efb5bbe6e949ca0e679e7a7e1a42556abcc426dfd4c248bfd797c7eb7a728ddf61b0b447573ba1980fb3dd8e1b5007503a41c61b43fb978d805d052d8499d5f607b541a21a50f50dd6d1c90c19d1097830e2cb318dbf680397cec95fd15a64f66285878c8298945bc6f7e891f927ba9444842472d559abccf62c16491fdf0a29fc6270155428de67e291bbea92761fef1cef3c35e7dc05e8734017912ff687adcabc424031ab88a1634c2ae654ac8cab2457105914a6cf6ff0158ab2a57e4db0bfc649648230cd483e327a9d9c23c237ddc2bcf45470415ac96edbc104c460646eb7fd54640f167f7608ce4a270f95f7531250a980bbb349485aea332095a8da939bb3567acf348509782f135bb77ce4ca306f9e295553608b6cc248beeec9eb470a7b32287c74e87f5e025aa63ef75a3ea506ec96e3c40cf42bd016c46fa48d384de3d8f89a5e41b2545a040741943f08d005a9c80a8707e2d5e680c0911f67395336409431b9f2467fae2fe2838c46b67d0fa78636df2324778f065f505de2f791e99163bf3d529098732c83dd98842830d9eda4ea9125163618abc3e305f7f34cb7b160b21c9fb18e03625c341280926fc8d85bf9e6fb9ef5c5c9cba09be540288e861fe209286f5b74df1e68e328a7272e94723363302c248310cfd2cb90aa804f0add660a6af5e344fe985f523781d57b1189264a1c177d37d234dddfb014487488ed6e1396f3aca4c17aefdbb237300de7c5347da6214b94e5238a5a1abd5279f3e7e97c9cecfe1d6dae67a0e1d5eb70fd82c87e8643a0d83b6f8a0c06fc10ed1c66fb82c750210b57fbf165cc6c26e17d108ff63f19ace5b16cb51aac45aae0dcb4e3e9685df221f40d81ee00420a1f388f7ba494ccf62c254aaf93f92d2fee3a1e89b1d4eaff8f96b85835c5872ce4a97f278a02ce7d68c7d732e56b07934ddd44ceeb8873f451f2732dc626ddcc3f19be99b599f842123f9f07f2c1df5d1944148977c906b54c4ebbbd92c24da7d96cf57ecfe683d3a4d9998ff5395ca199a203d1a93b49e547fd22af2aba0133affad32a249338f45c00539c2b5d95871b76af088e9311167fd488a93d985c7ae6b01fcd1ee1562603c646dbf4c604f31382efdf978f2ef2d0f18babff9fe30898db938f733e2537f8fdc6b8a5a240c8061e499544c1689f6cda458ad4f9365abea658ed07b03c9a4d8d88194d6a2edf0126415937492436cd77d4f6e197489868a39209d0ef4e4147cc80e3d2387969118c221cd83ac32a5d50f9944719f68a54eeb52e347ccb94b3a1b14a56d6f4761db046047260bb858eb2c3885b383aac646686acd1aa8b09b9dfc20e3ced8cf1b4f771bfec6ded17d6a01fc1aca4c480c480ab7a924fcd57adef582180dec7e463b683f3a3acef0b1c20959190a894b132f7c0e194d27402d5f3b0d3d121e1dfd4816f1c7c728c53afcf0e13b4bb3bfc100453477fbdbac6bb37e4d9557b1f963e71e0c81947cea63fd3bb8b635465985b78916528f5ba0cd3a80442cad856fe99a9ce3453392232e996a8af4b81030cebf9867a15ea577bb19b98ccb87a5acee2170c9d8a90506b30e48e69a47a2c2527188f6fe7a231d4fb9094f29e0dbee6abccb76bbf715d2bc9746ebb5719f602625b3e8c642f5707e91e0b766bb8d5c8dc4050f656b5e751c670064b9d7a3b9f170b11ade6e99e26b1ecf435221e2a50b6bf792ede5dc5a7e3123589d0d3e9473bdf6794feeec661d0d89a6388b2008570961d8cf4c1be77f84334b82b6b26c0b1989af03d01133fd0cda677f0848963345aee51313befa420dfbaac711e5ce9d9809deb42efebd42186bcfb2ac6afaa5d606dc092f1a5d2011c75574cfb25a591dd3bdcbae1915fc07f5de16e797e0db195a8be2afce6481d8aa0af88501e443da1fc5fa4020897e50b016566dd0deb2457ec096720b9ebcb60b7057ab57b2ebd4a48a21affc8ae8ac8d76bc87223b3c55d8f51281bf18c6b40c5c836c201f246478ae78b2c40189567b522fca05025e1662e4923ce97a1b87f35fd0dc7377cbbf3a67202d9fa4b7a5396c31aea40c85a456dc46f1d96db565da3d3c25efbc359e84d23598fd9b61c9a6fdfe5ff1510963ce5167c4ba2e336fb8c301e8c2ae90c6e82ea386c30992b5a9f43b49566afdcfd67402f8d929e21004eed00f9c09fb7fe92332305527173e261fe24c030aacfc6d893d89a38184c92e8f57b78583ec4138ab8703cb6c4e0cc2308bf4ee77dfc0f44e1b0e60f399523edcaa2d08b3323b1c4d9f8da4447da2db2f8ab779fcde52692bc9297998a96194384c0563409b8fda9c618ddbea42dbc2bf9024fc31ed554592ab66ad717d0fc9343f2a3864e8a7935408bd69beb9c50a2e99630a6717ac8064ab17deed8ec817e2bac95c108efd13c931d271de6a8eb83510fe3ba6f988429ea0fd84d18f78a27fd4c96ecb0418f17ba6766bf67a158b1a9a1046fba0ca4883fa797ed9f9d672cc3eaa1cb6f3eacde2a8b055dea5f0787c013f98157dfa9d4ffbbd05a49872a22e21d339a5507b201fd84bd68142c52a12aaf1cbc01399fd2446019529b763fad8d948c6d5599cfa17f400789376276323f58c92cff0f6bbdf47d03882344db98902dcfc8103da6606ebfa32a3a76616e790f012dad3a1a59b8c2ef50f769eb56d078fc1394965eeaadea3975cdcbe27c24c6a4b308002ce891dacda5ffb7b8ed14fe408c4e16996981ef11fd3b36de1f1ae36dc9c6468ab425d7b68964ad1e66a9c38a1a873a71d0b2d01e9816d2d9d47fc04144a7050ee95a6a33a0f56ac1696ccf1ee642cd575df1f959fc1f5ee5b5759f8847626b5a6edf0f04b99bd9615404a9d0c9674461614e7ad567c7583985d69f87afefbdd8aa8d3fd278a30c466c55dbc99fc0bb595886796ed89b114f3da1b0a0f08e0b2cc265df77e09d8c3e85202440e816bcb87f6748e377c53d3e055bee819a85e13b450069fa89ef9ce36124ec833d975ea9e84d8ef8d60a615f77735dff19c6cc497ae34121ebf49e53fa4ec81262e4caeb626cc75d74358bfb131f8312a4268bc45adc86c4066881477be073e13dfd5f7a337daffd2f63c276e53d52f8196193ec635d7bb349af36014def2c14e4775eec4f8c1baf8ca96e063b0b9aeb023e21df33afca394bbbf64e594dde2b8e075b49d9a86ece1ff6dd3d9b1741f495387ddcc771d6f0ffbcc3f0b884b25b3fcfbadcb08bab587ba488b67143053454de0c4a7aab96361bb2ac0dd5869de02186afa4f2e9f0e6865daeb319e59a9034b123220daf90445ff6816caf40a1163c412ddab3473a64c4440d14130b35f591a71a1b0e12430ad7b578a8432367d99b140e1cbba0a7e407675d805ea046c0b2cd4b42ca70ccf671517df1a7685ec1cd6adc0927a460082813fc6d84fb15cac88a071facf8c031c8c9afa34fc54bfa94de01ba1dc014f3725d4aeb084f7f5693e9f028ff6edd0e83ac63e6af2845f069f922f776abbdf85f74a460df0e141a8bbda218fbb99ce4011cf10df65b7aaab8a06a0f3b1d8930f1a95b38f5b2a28c8364c519db8312731f886418c1fc898a76f6b7077c11401a1f0710ff84468d0be6e9ecf4aced6805b71660190a4a5bc23fa6b91c676de32ec1a83d72139797cf19fa2f9ed216d1ccb6f74fb92ec2dbb91d95789402b52b64dfc843a4ddefb16375a2c9cb5c4dab25ddb95326b9e10d52d993637c8ca3985e1b1c14016811eb4bb9db38e13c97cedf39b38a77440662153955351845f5eb4e310663181587ceee6ce1d5b31cffbe7f83482a9ad3cb42f1a13890e94a303ba321a5ea7afcddca96fb790bd8f7a6c3c3d00a81cc66db2f42c3d1661c82cc2c49f6393352a52edf62699bdc74f4b8225676a480e3b5a94956264ca0ddb88801518d288ac34ae3acf7ae93813d531631a197cec0815539e5c56220a1eca79e0f8cadce566f0b2c11130d9181f73495b63062bad354a1bda95e36da86152f4300d91dd0d1ce970e579342b9503f569b512f2ad2d620e2b1677d6b42af0dbe793b725212fe277987b00cb612758714485859d0d31f839fb8b4023b7e2e197f7765c2ca219487c057ece230a7cd02f6abe331414cb08e2f46fe37c3ae3b0b454b73a8c44a64b15dad0c15685ca2742a36ed850e053235d14e69deb5026d339aacf2adfd879d24a5103bcec4acf715a1f27b1ba2b7d3c93bdac01df6d48c97203f091b336053103ed8184acc4ab3132f2220fb82a7b0b8e5411e0affeabb46b7f13a615b9fef7dfe57c7db44d307001371efb141262e8b5990244a9258d38383c1006cb3b242bb58712576a202f09fc74976837dd23b167030b8ea7c5878cf8878c5c2bc74817023d1c1855a61b7024dddc859f2005a9b4c92e514fc5765b87700dc61c895139bc5c28a378677688c7f5392d219fa419e1d086b26217360ae43216d0657e09a45a22ccd344a620a789e48e34e447bd9fad6119120f3d838ea129ba6f83e32aac2d4dd477c17c8e8d224fba09b89b967a5233026b96692e14c7ae1f9c450c5e27e53ac2aad59d1b88b4dd2c3aacfaec664dde9c93e82ec0a042f5b46bc766b79484ff0e5cc50e38d89fe0f51e6120a11758d2d7b07887bcdf6136eb98c12d59e6f212d936cd80a0a708d4a0cfc3ea4ecb2f076534c6bf2a0090968587e2f8ee95a6e181139f44a5b4b8a73344794c098a7913ca98cf2b058e1bee63bcea16d74b76056a9aaf0288042ed4920cdca6564f6305aed6315beb4b2b6472f3706e181602f0fbf917dace6abeba5e668275e0571524f6478ef58ea13ac53f5d1b3a8c1332d96fd37dc523c58142c88ab3ea8c213f2e27116812fa8aab8308ff53c4589ae4e9cde2a64743e58451134494133ab245e0b4a4505718d91e51db8e4a26491058b1a9d9eb0e6d5ce01d6b150027fb0e0e20e057c03cf3e860db0d5fbccb51440b2eecfb6d6745d98ac7946c78f48dce1aeb18c66cbb09a4f1532612e4cad5cf2d2ffdf0b0ec7e2425c002d2f70b3b674cc4e1a959234ae33e961ee68bc29028a5e103cfcd741d0c7cd36e79954b2e6ebb6e014cad635ff0ac71d784fd75430fa684f077cb09e917f0486eda5aef72d4d7e84e89209f5a7bea4f2ff7bb421edbe0e0a4a2ce939a0c893b3bd44e84b61680e9a1a155e740cf96b6c2401a4852dd686faa0c19ad6aa6e0d9392125ebbc16a19e7fb8e2bdee7b428849c937bbdb5b8f67bb775bc0b40a7c11fc64092298068c98c7c9351c728c6b55df341706b643fa2fdd9f958440f24abfebd4f98a767eab7deaafe5340278b50deaa4f87ba1f2bfc35a1fc67b683a197bfdbf214259b6a5eebc9f4e769d6834181541ee92f38c940b90301436aca8a473cc292ecd076941638f8e0c501be9f8f70422a4e5da54b554eb7eab3ad3ad3e34560010da0415aeb054a01c3300b235096cbb97084dd49d02e266422997c75c3b97c291190a68eb5d805f1d0bcd07f1f99606f8e66aab9866ff9a45b5010014b02ae2c9008d54223feee2e487eb6357a3423d99bdbef481213bbf89ca59ce834de615add999a79808bc873fd2d1e007f5a55714c9fdf40d14c3e381703f59bad880e4469b20f0fc5556de2df5af007418b1b4c5732d4b97bdf290ab92206cc6acc7df5aa8658cbfb2abfa90293c5bbb7bd98e08d4767b2724c9903fb61cb9b5c8730010d5dcb67aacb7a5015063519262cc8abfc7fb079cc3e265fe04df52b05ef8fd881e49e45b091aa3793db8ee14a55a6ec01a9f39028be6d53b53f3ee9d23fa5748b5227cae839141d7574755826e7a052931b3891bc30b43357ec0e3a325b192b6772a26e0c77b3b4a930a5d28c65823e388cdb56390b1441d6b5e6fbd3987e4f7315226d9a13ef286c0b040fa70581848a402ac181b6be2cb2657ba81940a00558ffeeed474ec665670a649a0da4e5cbf60e8e0f1316fd62185c069a31a4f4d076d22801dd3ea2b8f55e7a5d2822dcf3d699deb2037b84d7faef11ce48f90ba9ad2f0e357ffb666209c2372200476463450eb81d832285e4d3fb9b1390afcdc964c3264fd19fe11e0268e484979153daa13f86c7d80b3e54efeea688ce7b707ea681e28b57e71d0a358b04e7e238025f233cc2f8952c20e0bdcb00b0181c3040edb9b23c5fc9224c36b8e75e9ffbb221ef56b0369e91bc6427680b49bee6688cb9bfd8b4cb93f856bf2e1637c7fcbdd0a4e65e9cddf4911642ae009d5b6f15d9ebe3b2fcee4d410b67672e77d338be87ca96c633e02fe535b752817cfbb5f87fc68f86a86d710af55a40cd9259895ad20c638a5f42a4d8879b90b452bcc2ec03b4d7e4ee71760385f98df8d5984eed47b89fe67649ecf4f836e6b285c75fba2e0149ddec36a4f8d17fb66ca9397b3dfb99dd9da115da091a5d82fd1485f48782e93b2b78875cf34df6f3d9cac0f077125025b56f22957088a48bd32f8be72b27bcde54571d23f19aeb45cd8ab2ce53b73b972479ebbe61eac237243dd5bc4bdf12c0b44eb28eabada0b82e1a45fa6d0005e9d2faf6ab11b455169da91887d5c9115de75011125ff08a8e9a265ad8db55898d8b3417ca7d901a5ab78cb05b1e241ae2165efb644b37488c37f609d227a49476696c99d29ac0277bb6a3c1a33833f2fbbc0f8bc13033baafab8531adb35f6e4e633d4a0b78c851242b6045c4b6a268185430296f4629554feb6649b08af631cc33043c8fc266545c8bbd4c51be10ef767b4e550076b5a2cd716c75321bd2442e205e977fc375b6feae575023567001bbfa4cad04e67c34ff7458c38c284c08d8bfe1413c242d9796574d112834e154816053fc125d10c2994bed73492f31822106d3ba17f827e67e8ba058148c676448090babf9d2b4387be071ff45adbab5cecba638d7f271610c3e50304638e753e3d324fa0adcfebb93db388a5f3b25f3a442758ac792c0d3ed4f806a698599ec8299a62a61d97ba76f55137d4b63059ea24463ed25e54478e615a9fa4fa80be5cae8e700c59a90d3c4359bb79b66ebe30db2f68e299f006fd53ecabbae70cf5d81abe7b8b742d1fb2390d014e542acb1b45039445ed0d4bb4025dd4ff461d2119342261739924e3977a8d24284671c31df368fd36df7a12f8395675496b544665bbea093a01701e5a528a28a7453d5f3a4163bf47b03c0905f51b100671770f80ca9a9e2be27eeb0c392e98f70f08a9dc360e4b630eda77ffe884f1f01c2cc1c47b6f53007c655bb7d0ca138725643fc54bd8815c006b3c462251fa6186416b7da83c7778a0f80372194edfd9dbce2768009959d6e7e51c55a906649a27efc1042d121c54274079494f6c0d112c351a397d2a05066e64dc045c7146288aac7a1f50135229e4704a22933b3990f9fee648b7753e5f7161c3d6234dded67e3535cd48ebb9e61a56fa28fe0df4b6dd5ce3732ecb1baef8736024e369055967771d15de238634964b40afdbbe6edab220fe327339611ba569a73b631b86684dc7ee6ae9801e20fbbbaf55a2e2a15c630738e63de92c6d333c397d669c63587bb11dc63276274b6937aabeaed0a2c852dee0d722a355fcf129e428962363d0e73e12ee59ff05933de55cdf41183ba3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
