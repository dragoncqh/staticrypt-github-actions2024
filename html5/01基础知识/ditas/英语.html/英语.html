<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b6b809da2725449b0a6c4ccd3a62041ecaec6f01d27d796ff2d40c58b6b5c8a44cae06de42b66764ca528d8264dfcc6fdbd610f5427e14f96fbef50a615476656c4be32cf37679356772c635460bcc0330d2a83763dda6aa1986cebafaa5547a1b2cc0f99cf45fb6603458d0e262dfbcf00e90a136493be160f9471a120e726b98b85886df266829162245ec639261138da153d3aa0e7f447ad7819b5905aa347ceb4ea6fb1baf0ebfd73533eed18bb0b5adc6a9be97a6b3b30e1a7d57dedf9526d1b8897f8f5283aee4639b436bf6dcf331a026d144b2458dd7bd40bd3e96262563b3ab32ebc1958842ff33b479589d21b19d731c3e6c2830b6bc5aca38699af005c8129652970f3fcc4986668262cfe0709f1cc6cc5cd0eb3f68f10c46a978fa9927990bd03c61a67648b3ec9fd9113dfbb8624974af617c6eb464d6655ac94150029c4b4e9d101605ee54fa1a758b02fdcf4829e504a1c6a3fc7afe5c287f812e0f924febdeefbcee986a33c4356baee7bef809115efc8969938e1ed0cbc6a4413ec0b21dd04cbe24c9e536bcc680876d182dabf0b1cb423ecf05a7e016fd0f01c1b5447f7c694e97c813b4bc09d54bb39e3d429631bc949b749245c796a439ae729c81e77c220ccc25e8ae81b7ede8689b5763615e9791bec73c22e3024262c3783b41818d797d1a466afd1b8f1e6b675b127cc997fb3c5f3a21e76520d2986ffed417eeef7c50dbe85df79e56bf59de4174da569b71b4cc60a80617733f7086f7cdfbe757087f090c49b039ea0e7b13314f1c2da0309f6958b796c6b5d3e7a80aee5f237e513dd77a1911c03a2d7a8c2976fb17fe788f9d095d5b607fca94faaa5cfb74b96eb413d0f2a39019ed9d7a02c1af5c49e7a62971f53736db9efeac8ad01f4a227f18b43d04a620834d505c22b62c8ee819e8b322a8a1a09eb558f1f64cfaa02c7134cd5ea6587c53ece4dea8f201378756d726eff2fc50b45b6908ffc89778175e9dd9d40e47159a8b045024b82bcd70c145cb3a2e978389c50611c346ddca27a0c78c702270ae227d16894630fb539028bc990e487ee3e374e31072537fbadc81427dd41c4376736e329cdadec96453a35a3feba178755e6bf24643623339c4fb9c28f181abee27e7c6ab76e53949416186255215c6c26b2c54c37cfead67a63c6991aba8d8119b1d4f2cdf657f99523c957999270c28114f570ccc2528c940631277cd5fc34584aac78826344a0ae19f2cf873dda4283f2ad6caa9a6a49f8260c8e5aec4da3e2900ceb9d77af76942e15d1f8e57f80da89d29f80ee3ef23d2b89039c70f9c40fb6cc5504f00ff270325a8bec2fdc24b75478ac366f4b4555bafeb84431591e9b9c9657b2faee0645b53525c20b453fd54b27abb46f53cfd3862c8b449326176c6cae04a37eb04253caad909077c28d1149e3cab9a9b14b2c25b8076d29a79b12a14e4feb18212e13f932889cebc5d15e7ea7f78981ede2c9ce9ab647f637e09175a5c8600baefc16e3154340af74e391eaffc46ca42f3ad52ca10b733c6d7df729243805387ee2daba383c9cd010fa16ba7f6dde404512e9a58db103cf00501e2a139c34f200cc0117764494ed1e89d121d408c199534ed4622ebc3d3f8b549e3ff41b96afb31e5ff667642ecccff8e1129ec52123a42c05a08ad7399a3d77ef8ec0d47859d5ca13a9c7b43295c812b7437a015aefd0eb841268193241e49659fca3a4037f40ad48c6e9a1532bc1f77fb63e2db99cb31bc844b2ee8a1c5d5cced87197f5f8e6c014cec4ec7a9912fb5dfc7324bfa6e3970691b436d577335376684cf951c4f5f824a5db933e3194c1922a77b121adbc5f2eefeefdde98b97726dd830a8a80889da27eb6dbeed2d7e9a34ea86dd007aa16606ba46d09d1a7cd2407e7b5b03d10cf78c04ab551c78be85a5d6185d797cbf92f215a3b234c6a92e1c85feb392cd547e163f369b3a9dce6a6270c547d3efd1731cac97ed8de70559e43b7c2c54a4e33dd8acdb836a8580a252b84860dc8cb195bed90852e5043793b4237cb59a048525aebd0ec334d7693b4942f518ee6d4d7e1743112f4da874103fd3230da05d07e10d5f19aa3c413e6218517291a51fbfff2a0c20c8532c20e5c4ed16623d6ccb8a1554a6a89bc27a708a8e763f8f64a08837d0f75b4bba6535c2d68cc522bbfe1a2fb26795b63668f8c8c14d2160a1c54765dfb9d9cb3eef587adbaf999e490aaabc23626e325fa4db98da15c9b5af7d4a3aa84da4681748673205b4dfc1e288417052f98cb5dffc5ed3762aa3dfe0104a029217987a73d81afd1502952eb16b9ff676c496aab042c0299617fb1e350f07a5e18fa8e3b42da8d7327534dade5e0ac7ae3626538b581eb56c98bc813056a45762552e5fb1a72391b02f18d4355c9d01526e9c24961f1cd58cf4dbd303dc4228e30f9378c47dd58ef85ed18da798ec9846e37a166f9156f6a5baaf1cd7597ecb60a2c3890d2fd6d0a2224d557e13d0e001bd419b2fe87e05d41e16c6ee310cdd9a11cc057564bc88a2fa8845210d684812cb1873bcc7120fdf23fcd1b7c5db9efd7b1ad46af89fc7b2d165df979bd57562a5bab05be06c30c5659d9ed1a6d60d96866b0a7ca423d27295c00a078de423d2e7413fc97f803c81cd3db50a5d92491d4c947f88eab47adace069d35e3735986ecf6942b8d7e5dae96c909b6ccb9cc9d92c3f733cb43ae4dff91081c937d2a90704526f371ad066d047132b33889b11867f9e5dcd5a5c9d02a050f032179526f1980f9bb8d571bc2d43333a3f4d2536837420cc9cdbe8fc8534ab8601c793924097f648b574aa6c3a136990ba4c3c38d0c3bac597f3e32bf51529ef43269a32bc434b4bb4b10ad6a028b0fbc26b958746575d6edf2e62c4fede5bf8291aaa6331d9a29a8fa9a001dd8ce333bc3bc7107eae3e1ad9b4bbe40491708d71c7a006d7eebef06e673a0757d3a767d15fcc5d0d6b6e368707ca50fc92644a820edf81aad7ff10b73a03d1d1d2fa642f55c6db63e1d24c985efc6f13e58d688b7b75542c9e5cb4240d725295f2fe8ab4213ea1a98920be726cbc30661e136783984dc9d861b8e4b1599960a27b633634a1e3d93e4695e30ed8801c7520aff88649e44cca967c44196ab604e7a0b1298afb41fd63c7a44ece728172dfc34267dac0efe4ab726d0f14d3a40ecc139c7ba0f7d20cdc12c2b96794abc5f257a8d0f93a48081c30d84f2b9ba1c09460f58eaa36e246304faba1918dc448d0ddabe7a6646b1ee106fa8447d2fb8d2cd6147df94d789f723a736941b664f8d4d4d7ca8249a0f5e9c67fe1e78e30e74c3d7050792ff2781700f5d8f3108d72dc8d0f17c0c78fdc0e4768653cdeca4abd1b3dc74ac209b208ce21202800f8f3804b2519aa20d5978153073b473ff0eccceccf8fd96d33e62de6f543b63550e72b650baa8fc3bffb2ca77bd3dccc2ef9c11bb3a4bb29bea59c34b9bd15c7548b0872a61bd9f276c4ebb426ae1f9ed339ad4d51116015620202f972bbfe24c56c537a2a0d6f0013c74eec41c4b62823fc5942063833c5ac2606f7b523bd870263729064bdcd98475b22a927b18013b341cd362e09a5f9a48b7b7b6de32348ba0b5e13c944a5acbd2c2b98bd3482ff4a7ffe186d51fe20bbf4663d84c9b528735ad95affef428545a4f3cf61c94411e7723a294f407b3cd1051fe5c3f46a616c670e98bfe9bff77359579c76b672155ceef2ab75b6d57d3f2b5c58a43686f24e94fd410015343811f07560045aaf98d2ef286e08881b34f7634897183472e939a6929b2eba96e835c00103dafd9ab24818085c6add1514ac6717bb0da3ffc1288ff7c251426434e1b8a438ea06ac1343d94dc2ef76a6aef945e9b084297c8db6985be8209e5df7fcde226f70784f89314166eb3a0433487dd0737cc5d68184f024478a60038a68111dfc0205360a419ade67904ba57e8dea6bef6909e88c715fb0c34e7b924ac676fff32a595e08f995fe00283e68f8d5b70b6d2bed76fbd012c84e34730cb9ec541180b3a0cf71c7fce85d161bea7dbd14c918af689ca1e74ac7b31f4b68e0318c74d25bab3ef8299e9d3b5e92d45a2bec76984dcabc3082afcec5eeb073aa69759539fc1e78fc44cb13fdb64c8cfe06114d466cc869030fafc079d13153feffda04f635cbb54daf4a75f7ee17c607f95afc3c1df114e75a178ab1d22828b361bc1c13ec1c3fbfba6eeff49e2785355f2c0a1e88640d6ecdc4a5828ae315bd18918774fb3aaa997146c4134cc01ec678838171ea664a4d8a58b6cb4abf2bbf3a40fe0ef6ecf89d51db97cd63f80d337c4d51e116989f2d7fcd131a6f7626cab3a53e68de701aff397453de5185511a1314aabf7ca4ab76aed2429f650f4d2ce21e77f7672aa4a2f43422f75fd92ace5756fa15d8a3d697354bfe3779cab69448832e1da4df5e19da3b9aa7b9fd14faded4f5a5fdbc893b9ff2f7fcdd84bafc6df780af35689a9f8bd2f272516e92bca3dc15b86e9d05c6f42d335df4f4f85a239066e32d6eb2aa03fd4973351c521a0f770f77f86914363cd702619e301be5b3d02302474734c6af22a393958d703fbe50a2911429cb0968681cf266e90c9a6ac709b44d5de35b8d8d47d1a292f33f7dd077bee19bed9679758bae6359e98b20a2c4238d421baef4b56e581f5d664bb6c66df23649ad91d82c7d82f121bdbd872c3b6e06cc5aafad007e6aca0f0733ff1720439f848c12f58dd139f4b992ff243f46aacbc95e200f1d1f528e2ecd2f9adf4d51a16e7399b1fae73453a5d836841c0491ee3319732fbdd7cbbc88addf35f6e9a0bc3b3757c26626faf18d2ac4e5d15374e64454743868f536e9cafbb77c03cb074cfa81c509595deac784fe455fdfef8abf6c913909e8b3b0672eafd361d91c7e5e4c760012a14bd990ee03e44f1a13922cbfc7ed7781279d78c515d3836d73230e4744cba7ea8afdbc7acfb1fc8508f6a9be7908ea2f63e49785a04b66e737e2d6ec37cb05087425c5aba734a379d474dac73a5d3482209af549d809607e8e987f93fcf31362b43fef6158b9b24c8e73082806cfd605207a6936d3a4511baeb55173c30b4cf12dcb39c40b88b4b418f20b430cc62069f3e75973db0d1f6efa6de3709bcb8ec2ddfb1a1d550995510a8b7cd91c11c8bd614d4fd746c59966900608d8205a7223e3f1bc205163fbc0cad9225449fc6070c35afd51f991dba70e9fa4a6467f88f6fbb49a7628f433778aadb373f6f51534da39263506b31ceaea7d967e074ce266c3237b6f5d0cc138fd3d69467e35bd35c7376bd5023275dc9dbdb949a23c009f84d25e3505f109fcce22d489164f7789e947cc64f1cd5a32dcd17ef28463c20b129ea8c43e0b9ae4bb8af83fe37d254469f9f9844512017da923b904cc95bd2f19dbb3b11990f08c26a1f5dae22b7e0b91836f9e6bd82fa2016709b7d695d1f6ef77b17b2b20e4cb5a4584dd96311b52d611b2c37575507e959ad41d6ab31d7d76b9b208da359514973cf3c0eeb1e7c73ab2a088b0f65808305bd8fea4cad15a88e77febd5b6c2e0d2dde0ab21c376a739e5173515984be138fb55ca585758ad031b3b476d56ccea756f92f3f18581d4e2ba4fdf0f2cfdaeb40f44b61c4f928cfd76ea5e0f582fe97d8b30ce2473fdad9a0b917498809a115d011f9f92d6af0f44a3e432b514a5a6b986b0c02b219ddb8a6ed93053e44592568b4062d26c4629fbffac37343405e84988cd86258d077e217155b697609675b4fb85e236d6b7c70f03f7b5f74cc7fe394f182210b7272e6927eb40cad4f73bc5ad606e4dc10a28696400798152d78727286696f0095c7b8eaca1fce07a96aacaf5d518ea526b29d9f3b89b1da214f300453206e764e0a0622c9b1cfef2d9c6124c061742bb7872c8651797777acad64f4887c1c0ea1a7c3c9f5907b1c83d7ccb6e0977aab0b9c48be8ba69786a4e1b16a27fda3f8af40ddb0bc9017e7e5df59ce911e5c1d6d0f0c7893bd5b64532da726243100390d55f2e36235c934ad92e2f920195e8ea2620c5b2cb5c0d26d378db28dff567d05009cb779533aaaf436ef4be9418f4c3a14cd1f591188556b8943a10b29e6f02a3c128de5cb50e084125b46885c2003db0a7e89e2be2d3916deea92f1d9ab1f7cfb131b522a9d2c3ae905e2fad21bc8c3d3f16d648b0451b7156fb779349c97b1f135a4d2207d39087fa4b7d2d71c61aa4030a5f6420bc031f4e2caf3c429719c159cc475ca07b2e3904867305b81dfe6ac94b9439f39333fb26842f339a48261a73bf3a0f5a6cafa40625e39fa68ab2a9aceebcd5fbd2dbd4142b8fa897bf56ff6a573646ef276dede9c302091f6d29425aa842f26f1871bef6d2187c09cf1aea2eb267efd716255c9e2f1d59bdc982cc4a06a06757e3c4a6cc399b2224d88bcc6ec38cfbd4ad189132d8288b0922f8bf8c0690e679417385d2fbbe7dd4b85110e3ef329368d0c4c96241f35804c7f2bbc440bf4b246f6513093d1c66f65ab5de35bd0efac8e0a7b876858cee5af9468189b17167e6f79aaf7222f621346b95d828cf5eedb6721029385234b289493a7bb0333e71621642e8a9ad2b28abe7c6232786055c3c842ffab6d9cd35b423cc44cecfc01fc70047ddfd618b18db2ca8b2ca747bea377273c5bd3a4eef8e8d279da486aab4c9bdcbae86965072c7164fb0f973954f0bdce0553ff63a6e0d6f6295dbb232f244416fc781579e8670f64576c1a93ce49dcc33c744ff95b9f3c405f89f5463d6de8b8c07dd8507393ae02f10c0f306090873c1614d1bea78277dcb72b1a8709e8eb6effe9bbf8ccbbade91171603b98db61c65603bca377d3af64b87a0025df4e797a18c40b8286fd315c209c7e247158ab8ccc8018971b852c4dfb01432d8825f7d175bee3ca5e3e1f24ede61d1fefb28122bef7ccfe401eba5cde000d67afac34c179aa14191618accf8e2bb8ad2b150309624d5e2d2797eb64c5c79dd8dc0c4b5be52f20b76b70e9188bdb5592ffef4ad58e778fe0ff3a8132c36b1f9e2c6cbfcddbb267be1379d704b1da5573397a793012505ce42466614a0dc3519b5bdb4cef20787e81f3fab0b12002ab9d6442de80cfaa4df67e78368088a2d32dc733bcaa8e709638dbf04237662b39ead561bfff35bfacb4a07e529f72ddb6b81e3c731b12d3a1ccccdcc0fa4e6f411b3d81f1d51931f919f5d063261cc768322835b38ba7a446c4a9300da29e5bf9e2bf1f6561df0995d92fc1bec81dd6de6657b17289650a89858dd9bcab14618dee3c232893c18cf1280cd65e6909f3cf9d4475dd04a4f662ceef38974c1026d8b095c7b06e82f99f7c00dac06dc0415f664ca1f6bb74c3057efddfecfedc5d2749df1edf5053562c867ff6b38bb588c0b8127c6d00cba8802c8ac03e6017124a2cf04422657623c1e5955cee8c2bbb0394d55f8e7efc0fdb0646f117c29d796fe6bbaac981751c0beec5dbd3e116238b4b4293b62f6ff50cb517554a5b13d911e1cb144dcd451247888ec3d0ddb3cbbe77c587c264b23e622bdbd99d2f5c6fda5181e88105ab6388447b6cc0df370d7d106a96a83817d65996ce7017ef3dfb5bb7cdb88c358d55522bbad5d34b50386924f19b984140a331debd23b771baffec33d6046a930663c3f7ab1ac56b210e713025fb9ae3fa212cff331f127daa027783568a7b3548e7e20a521c78ce4b4a8a704cfee0b6a6a9167f8d9b0bd0fa43c66f76bd3a36225fa8fa134bcdd7a48a85b0d43b940d444377ee10e35939c58e1bcd48602b14d9751d0678e8c4574d707bb9ceeda74420b511aa3eb1d196c8831b7a458ea87b01a6ee9d03f4faa48a46620dd35ea49c597250cc744967719b6d9d713848b5c267cecd3786208ff98ec7e95c5e1b699dc9a7f836c639208e5d2e2f0f34f33c25c8564865cb17e070b9a2e22b9259918666b7efa42ced3725ac93874dfddea92f710516a408ee55ae485153c2fee4a145027b045939db2bf75fbd813d8f752babc17d1b6e27f2930660411271bb61105d4ec32d60074e59ee2407af415ded618dfcaebd141bea4427879c7cc27e2b7b5f0caa691e954742ffb6f31febb828ffcb38863131f9a8d7438bfbf099bb5d76b870d5281fc3dd9dc7d40d6ac03f5c0a474a6e6380e33379c1ea2465325102ed37950e7070541c46d7708862adf9d305cc062c5e47da826b1fce0187e96adf4a726de23a3c6e8d11ecd4a6bd381b2ebd18d835b3947d99737915d74b42942a480819ac6230fb9e4b6617291627bc8deb8b60af3ab6cb32b68c72bfdc7840818817976da0251ce88e44e136c398638e3ebdb287bd7444bdb3324bf2e70464ff1284d8b39ac7b05b38bd24b1341a2a699303d17a7008be88d3c80844dcb83fa2dad59fbf2f6b8aec835cb357895e36d116ad2fc851940df0319c949790a224362b3b53dda2759ec6ced95a5f3fd6c8d54580a6eebcd3fd6f5e425f3d80b0ecdf6163f6435bb365d1e8b873de844015c8cd85459960c7472582d8dd9f74ba31f64bb085592e07410b4129a5187cd061429137d1ac5bc2105af7a50c1c3f511255c45cf5f4babc823f9577d58e8df582dd25105681bad9f6bb8a7eb58fbda9a226ae145db9064c2b65b24e8a317782847e434134705a2bc42e105c6877c320ef329a622c8dc718fa691d5622dc123028fa65243bcba29d6196b1db9817ad7c3255da2d5e8999e5d18e3c9ea99a4ddd7eb3e9f0ec7fffe0779a88b6f59b105b8a854dd0b0d26c4866b0a6e69051f4ae3c637dcb7124a5e26eaf6c2b37b1ce61a6db45b6ce7e4487157e6a209a191dfe5db8c5692a7f02ca75d708e24867e999dfba0b08379fcab70acd03699007ae283ceda259979d5a79327bcb356499aeed97b879dd10e33ba575f171faa8d9494329f0685867d53319b2de69578a119f10d6459cecaa223a2beb139cc24ae1f38e40869f553ded46051ed953fb54cf1775abfd0a4860db85c02c51fceebcb412a5d243ce19b7539b814f837ed84610508198387f899abc67f5b791dadc2a2a8a3f1e474933fbf0228f25e369e8ad9195fbc55ed05d10644272529e7ae52057e77554278cf06079384a5ef9c37f5e28a0094e3dcfabd473c1be0c821ffc04089d8036526fa5fd4414ee04a8cba46783e15459d0f7275dc2695e77f7fb89f2c059210025d825c382694f1f7595b603b1a45220d30aeadbd5f30514cddc790741f11a8eed5ad56e59460dc95fcf9f2f14f1697aaf48b11d96ace8093f8481d5b9958410ef36d0969045ea6f064b41451de9a19744a206afb98549ae7762030ac2053e9c610436107814e5be0dba90b0a9d26b240bae5072e739e239a99f581c6c4500380ab0cbe6642a2e4760179ce9cc380066e8c2ae4465f30ad045f2051301ba848b620ed427a3b8db02f4c623f551fedcc0631a2f0b4685657299ce656e50cee5d212b7b3512c2983a8f2dcb6eb6ab36849da127904c280a8ffb4257fc705085f943824376c05f21fc869e4929441f1e1bb410cf7e3a742159740b2209119bc5d3121b00fc04d1e0d6523a3299335f7f78ee0298ccae284358c5f5e89eb4cc46b3d26f39e38c5f12e9e013234115b3c7fcee5495e024848671bd1bef3991e0f7d99ac90f6d96a9fac25852e661a17bc11e0cb9458614bd0fd15f858dba033519eb821da20c480c8c4e244065a59653fe61bc867b83710b3607b1753b99e8964c8c405fe23848ae2b6bcc9dc9af155c2182c49cb1b96be9b1e0d5cfc31fe8f216634a1b724f1d590f8454489e60653742c3199c0dd75358f6fecbcc97affe3f44fe5cdca46946e7c1dd00e90b07c25a09ae731cebdecf5fd6baf9047c748794edff1086304f94059b7b48daa2d179520bb241c59d4328d035d37253530aa21e4440cfa490c96e7996fdb497607a8559a4af985276a1641bc2772949b33972de26543b77a0962c48484bad3b1be6f0b6c80b4076380754c533764394dbb279157e84640bd16847d0ba95b4d2f92358a8285e321e67189c829cab248d9ec4ec6f7b45520626a9d079f8688524d3db5f7c81b2df3a2fc94a32f2a1ee82b8f2720190d8ecc664f633f6dcd448fe220ca5063fbe88df48ea2a93c447899f92975cc27bce4d30bbe727299d4b62d1966655b4023c1c650cd4ae6c7b27d7543e670b962bdf815f738eeca945c50e605f5f4062bb64b793f25b693f90cfda52d4efee9c301e520d4d7b2803e99a1d9e0d68a9969909a0dc299c2cce52034d6458b2ac68b2f430bae7eebf67d142a9a77529808f3752e7154a3964a27277ac7dc437c7330f4af546e5bbd35e9008a91184a7aca0ebef5554051cd3f0d289438202d873941fd8e7b6ba97f4257edb809055b4fdc20a53c778e9d12bb1db11d07aadb2e98fb4a01ebc47a38de92b611992de4a371e548f5a66464b5364e189c48f421387afd40ef5206820f868c74d64182182b34b8a4fae4ba7f7bb0a06fcfce1bc8e22ece9b74fc4b0cfafc43113698b2e841d1b62eacfa4c1a5e1870ef9918ef62f91036327c7d5d4a1e921bc8dad1843e09bad04d6a0f86a8033bfba7c3cfb2738b7a9288da42ec9fb2cf7076d1f146f0b477d66084adbb77bb269cfcadbe81e700b05589d88a01091748a0911f2a4f716df4128db9a4fb1dab787e0321560409f3c59bacce620a245d9ce8c751ef8b91996e3343e6b4a0458ca310712858857ed1a121528d8f4a2dd179f986447f9f0ac86b3d10ddb77f5498cb2cfd5a52eb807f74401b09651857ce98e7b281fbf16d33723791cc1a5861a8d780e8b0263551d701a0be74294b04457f839af59eb10387d9153c7a92e317dba58079a6ba851eb72e571d7f600eaf97cce0cdc80e22d92bb39c544f2a50c546ba1f90acff7eb609215b21ad73d3b748d0bd8215d210e3b23e30bef2edbd7b1f6230b27af86dffbfd7799d9c14b5ff4118b896d95c8fb4264ba803482f2305d9d7eb8b6db3dc6c8386e95e94f4950057916194ec82c3ccf3949c79e57ad9ed7cc8bc395d30e61bba7fc17ef6015fc0ca6575c70e9f12e622edae9b7aa173d8fb7f9afff587f3ce3e009fed796f52334f406f24ef7616c1ef505d8f8bc4cbcd7c96876602073c647bdf064ab36f50c82083ac5dbdfbb15c15721dd2489aeb289862b70190fbe1adf2755c84ebeb61d51bc75828305775532bc64dd6cf539e80894eb8cf4d697c43a460bca39dcabc9358475f293c6d0cd798cb419ab885547350e9083b95a2362d4eb86a45562e93b7dbd42ea07949dbccd990f4c4bb0640b69302d10677a5c79a305b75bf54436b82cb6247a62fcd29c1367037797c1bbb058b7963e5c11375408de65888f27bfe6d196ef42217464fdfef530c27e5e3609b8ccc0c93ecf233041f0692236e9708e7e578429d6c1352e41b1b31c85d673e84eabe71691367fb1f849f0a384c97876ab12a8348f53b7fda3e01a9b45bb2d6c545fd916a79fac18cb214e6617129c846e45842ada14b4380edd6e31e99d59f96a75163f6dd4d8ed9312d258c4fbd2482b4ce5e2b5800b0f143cb07f677a6c15f5cd62d12cdbda09293bfdb2db114074e4f62b98122bbb68973565870fbf1b41ff444b899a70b351aa3c79e0e6decf88a5fd508d490c9191ea6dfcff8baa8c78e7e2b8d8775536d614697ed17adb905cdc62edc2337440feafc17e9300237b7209d739469fb9bc3ae5d4d44d6d2b715ab1499d48b9e5303d26d8a454fb750fe1e4ac3aee5cea06c2c59414ba922ea932ab9fd2904d201a11a2c240ae13ae36abb2e8f3fac59ea0ba84504af9fb0e1f180cb7d7784d077d941900508f21bf05896dbb5934925eb8a8450b468be718be99275f24fa5f00a1acd6a2f3ddd52b0275092f98089e6035a61f4fc7ca4d720f6add189adc5adac72243c4118da4e76c96e2f90c6e4627906a1c4e973a16c66515d078c5565c975060d1f13f0f21c526c59a000f308ea20f52a2328c5d6fd1b31f7723e333b89e4b9c0b40950e27ba0b17450492f3c2d0df5c6ef69ee22f8e13b49d8f801289a2a60c657b45fe8c2bbba3c1c4415dd84ac23d1401e78394600e2449838879eb6c6647f2bd27a6e13b58c551acd1270df084869b1373b4b3c1d77a88fac535ff1e91d26afcc946accd3362feee036709f938ddbe2fc576e2a6b4d2969eedf29ff2dfc9367034a06ab1316122eef7a99b852d9c317de2abc48e55d535d6e17ae7e3b18b65af6d8fe31c2b164e2ab0f61bdaa06ca7958c8dd1d422fef21ae093dddd1dee36b201a5ef89ab67bfd0d99b3cd8be1d070fdba4aa999fc195d8e51ca8fb19e4a51fb5b5a62882f692a4773dba0ac7dd54e941f1c84ad8593c52bb9028455987be1427860101fa0c87012db5cd01414f2f7a4c0cfad32e736a87944619f7bd345c22f5c4d40f33bbdfa8f0c1db5d2ae9a4932a45df146679ed9bacd7e58bf183b41e30634bb7ccb0d1a0baf48e0114c6855aaaef0b76d26cb9b8a687a4fa4d242656e16225983904307058345dd53c9e5362ebcb190d64438a9f32a4b538950dbcaea1eee10be3474816667a1633210408162bc453cab5e54885c9278d36487057cb303752443d7647176c0201dac99fbd6d9f604192496b8d96cfec064af7a56a58f337644a60784e1ceb75818f15c49d72ddef81e609ec5c0c08d6e10e8550a0a10bd02e719fb24384b9f6c7a2593810d68996b46c8c6bc31207a86387bda38dd42972dff59116b250f25b9afba0c296bc31952b2fc9236ade72c2a1d35610edef2a90faf3875c17196c324cf7600dba5e2c96b9abf2d81327dbe837b8998e5e4bf98b5296958ad6ad7001b062765a4f7599cc80d7508be5444ca2184d5f02bdad2fd2c29183210a1f2024678ad74e7e4ec29cc798414e1fc2f9d7a4e8dae926480a0c277fa2dcd0ee2a0c065e80956d17790d8cf9b03f6808443ee4d4cfea01f7be916bf4fb6f49a2effc0b53ada9f4a9ed992736b55dc2a7dc290d4243b07719d2434c902c081579610f53dfceaeb54b0e3b9b4f3d9305a67883aaf3a553ccc811332a254e36c4d96cf317af356a3e5211113014ebe28e30861fbc1bc8bc645d89e84715b3adbae9cf33e45d22ee67248be4787c2dfd18a21a5296eedf02ba4751114528473ae5b3567f32865d913bd7a8ad456457c697de7fe0bdf2dc78620e3d0dcb8e100af1b03093e10ec49ba3cd64f01ec782c2083d29bbd5a4cb403dd44f0b8deeda377d8494a40ac801c27a61e2c80515da12ae7392317b142a53caa05047b88c3f1e804d3182105039b5de42e1c5fef08cb28608ef7fb5a7e341ed3e817be56664eed5f63b74694a9f9c0aa98c394fe5d80668384a2bf5ad04846d7bacedfe743fdcae36785fe6a61d047b648aba8876c55a5703fd8e37a66fcd85d6e09023c5496f342d60fe33e5fa649388c92a400b739ace77ccd75f4e2d075ba5ea2fd3184e244904bd1855098fe7698578298c39509654fc200708710faa9a199d063693abc0df8f5baaf0c2d99c0793be799e7aece27ecb9d47fb5abc9433ce4b7a26b2f90312bad249892e82ffcf8096715cdbe052651f7a7fb9c678abab1c6afec5cb3614c3e46995dae155e766e5a54b29abea4efec1597a2221b16e4e36574f9218ea8f3b89370058bc864918120597715049b64942eb068aabf8bcd440996725fb243d61ad160ceb86c178b445b49594d2a04c066a95f84890618d9a578dd50ae1a9316de3bcb91937adb7d307658c3356dca11386cbb72282d983e4edbcf27eaa0a44cd98f68eec9bd014d11c902253534930aea3b098a2aab6b371ecb93eb9f2c0e5ff2150a9dbdcdfa9e5ad3562c5e4c97121dfdca315ccc9507abf069ae2e197868b73d3237096e7f4db122ac19beadf749c1117cbd59441fd4d0156cf768d0b0122100e0aa9e20567b885bbd6b5f6f337270b2d558f1731d024e55cfdefacd12c0c1b8387b048cb50f96d1d748c16bb0ac3ecdddd4cb55cad3750bbb4fa242e29a0cd1c1abd6ec2fcd71698fdd41a64b61a3e97a023404b4775c3e72996913003c20c10bbb95f9ea6cb4a1782f654687085b8578c4ae7338b952d3cc95f1aadef2a9b15bd162dc8a2807d4358c4edf2e62058e189c94462cefa24caed879b52e56b87077423c7644b5c823e8000633305198f1e944287055a2a6acff70933bb0a4b1fe24b09ea324d569e778cbd659a5797659b768ad59c6f84f375bd7cb312be0fbbe4816b02f3bf5c7a9c1f005ca19146948585f08aef50662d6254b84d86cb999cbd6f286534a188c9825b81b022e4a68f877cded6c7da11fb6a33bfa9360cbc85222c138d86d24fab8c7c820b54365cbc4e05d63c3cf75115b169cd1e6bf2c73426e7fd81f18b9f8c8ec494c8df5156526212d56942ae1d6f82ae6c2ca0b0dcad7f1f8f60ec0fbb434ed81c9048afde9819448864070a28f33a5296e1019b978ffc7d576ce736e7ef739319bcb1133a3a5914c2034513fe7c7f5beb9e2bf9225779721ace8618a7c482ade06a137573543fd997217fac0861a9c581546c87628fcef715912a2dea1e36f8b1f8ae4e9d3cfdaed9a39666d3933a061564ace729f12cd9208e81e9f459f507e92b5d7067b28787ef37228c897cfc0b3f3867912f1e43f7949a36465a9ca264","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
