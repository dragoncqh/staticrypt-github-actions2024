<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66a10c4bea16e0a56d92d01047f661fd3ce0377864ff3ded68a6b806829321ae0fe6bbf534b524937039b309d4895f144c51ff01c8dcbe6ff0bce5e6d3314c981c197d6cc653b276f49c000e41010e489b50cba9bf23a0e71571682e4028e33c333e77f287f15ddff4d1e72856d5485747a2d95886aaa649e863b628af55536e6625e5f2a154bed9a4430b8fff14cfcb1efb092e711dd53029d542dbad260ad32982f38376453867e9033a2e9579b76ec476099dd67bb79236e312c5c9713c0e6d3fdf11ad04865609adf458252993d9a1f24b2cf9e757c66b1aba6bb68a21d88239cd60dbd33536f84140803a04aa733cdb8b6d21aeed87d5f4ba3b9d15f222d3e10a652483b6bd022d8f51ce66b61942a048f60632e390f56db7dfc655ea463f4a19f7054c89594070092fb322cfd9e81cfa459bd27edb352994435fc1ff9b0892bf32133aef1142ecfd1455a0fed4a8b9ae0f70cab38a59311641868b99c03a5c16b7d7c5d517a363c823f948b99098f14358ad25193807d6f3d58f7dcaff4226bc29c7df0bc264fbe4db1cf7063b9ba14832f7c9359524aea99baa666370b2d1ba84b4e40721f4742fb1cd25fa4a52f7e7e2296ca68a2854e66a92c8c7cd881c86c4b1c229543a99215581d2591cfc0beb5189847c413b9483a7270635a9843f8bf13921447564a5e0b75ec84add3a91a3d5979f3219c8e8fe9ab08b5736a2c3775b9df687c828456d0b5981485e6f68246b52112019d23b832d7113fb8d31120bb4034ddb7fb04d8f542dea1bd6d96ab570699e49a7d7a33219f796e5795b64a7882db15b75157f686febc9b3363251e0f1b4a71dbf365a31d02b2c1c0683887b667590d7753ca54ca61f8cff6fe14d620fb67329fc77f0fb6f671a62e44b36eb3f7f6cbf7531df8da1bab86643da844642d36e93a3cd0791ae1e9e82d51f3d0acdb8383bfa85d7f825fffe4da509c04ad52a38fb28fb2a123c9f5b0f13849c83846b0699cb791c433f93f4b73d6412ff6462a25208712b4ba34722002b86d50f3b9dcceb6b1a8b1bac975a6c9a2a04a9bfa7c3ec60449a4a3813498b6d2b5869ca0d9a667cb5921a27e26be3b51f43ba532542a203de31f1a55e851333725c01d5b860b50f150791b9a1bd9a8f0e0a483f01e5a3be15c66d37c5fb45dd5ac3ed2a17807ad9a16179c6284a88e09a9b9a3f2cc024eb30df4851e127eeb367c8566d3f7f4be1d49919503fb686439b16c299c8004bde6b0286dd0b9389fee9c94e0c8120a8ac48953319399efc3484aff4f46647ca0e9e980ab92f46237d0d86e6024f8094187f1dfa2244cd5039f5bb8869d6d6f852b38d7fc7101198252702657bab401ad1755a2d3f823aa7feb6a4349b624ec2b3ae348cd7f58c2e4f9449534854cc348f82f6e5fe57cc8ec637220298f622eaf84e74bfad9284274c6fe64cbac160683ccb8653542f94f7d098614efdb3f157812273c79c25ac03970c4946515057a1dc68781cc3550b0e01bcb37639cb22fce1fa264912d327c2134a41fe4ea4226a8241c6c20489d776c6899fe625b649d126c1a416ef197135a480effa62b7745471267e9fc71c385232b9289c82929ceaf776085c363ee81bba043f24186f12396a3b2eb25ebbffff5cc778d3a32521928af3e3872350554a2d536c9423e41f3cae2034400f241a5a13ca5dcfb83aa881e8f9be6a384c931d910ad7aa1f84ffcd651693f08b94bf62feb9acb0ff97a7e15ecef3c2670e4587df258766e350e350ba31bf771266a7a3a5f4e6f08301a5768510fad6b1c642e58c0a430663e9d998c2eef40712ee17596b46c60289de2d17c208c62c0ed3ff59470fed97dc0b90b769cf6e74faa979fab2284b3b1fe727afe964cff57d7a0d624ecbf5e5bd32c46e0be5b2812a2d26c3d7a5cb5d8a5882c598f0cfaa0b2f64e48351a71279c6bf2398b1370a21cf8e28b835ebc32ea94a6bc83a8343e8583a9f0fbab3fa32a952aec30aa7be015e98331df8a88cc1efe218d161462f7fba7c43ec015c50737ddc408683cee964f3ada125c8ff0b1db3000b6ab00658df641df466f60177b29ba182173d5ab3d69655bea13c1cff73876fdf7d8996a4a2acbbbbe0924cf897e892f84101eefcae8cdaf1d630e60336c358ea68dbf35cd1142c8478fa3d60054ef92b465898cd9cac19f661ae277bb4cc65ba3fd67357d6ad85102e8a75f8ac4e9f34e04909345c2bb4ea4f86842b416dae25c8ddd82deaf1a4bcbd59a9b2667104a4cd71dbd298ab18e8938894377315d4eaa17593f0b3fa12d8e80200bd9969327ece2a41690251d23c69b37e303f88ff74cc8d5bd397346cd2b2e160a1fa3fc515fcf8ecd2953e358d325e180f93011de9cb27323786123488288ee5d3eba3935967cc064d763b35848048e1d5d3c9f5766ce831d2c2dcf980f6cad60f72a5228b4ce4437e9a945af07cd2e491480b8764a538a9c688a3a4123b8fdb4c8fae9a73b61ae283b92da2526c1a6e3ddd883a6d2d41b8e6551d11292702062d710c45ae3feb60229de9368158fd9296307570e71dcfcdf258dce633d126adb683f98eb497c76b2442e32cf2feb81a2546310ea703c2e018c742a566b0407e9453450b629ebcb592329f255b3e90cb584498ce098e8b77821287ef588737971e43a0e6dfb83a58ac0c3cd723b771369460261cb1defcd25ed145f972b3f793882d4cb5242a7e9c8d76fb2230664b448f6c8a17fa155f5b78cb31105918e87ac613a10b4da4d93327091e081ed7a822b528d751ff76b81ca06f46e458725777bfb190fe362af8eeae21ad78f27d52cbb791346930123279efd08bd384710fd5e4cda82ca05e3f8ce60e176618f8a3b585ccf233c10d383fc812765f21e83c66ea035ff7500f9df561cc0d20fc2fb0e64bdf92ee0c26e97a05d9de506ad9fb2c98064d7b303e813ec7a293e1c806d3ee0a6c5e1d37927664269b6ca385f810462347b89735ffb1e67bab2dace3943e05d806489b8f01e7988d6efb2b2eb8d38f6ed805c8cc3423e55a326dc1a6dd76c0eba6e049fcd6b297700cde30531f7b9213b417f3ef0981ae1f587428cc4a9c04602c09ff6dab96d52241cb7309fef86b3d5b946350fe07273991d7bc861e95e65ea7f57a1d43b4772ca5330feb9af5347fa76a3e8a4d9885aba55e5b6a5035214b191ca182532508cf7993fa0d983398a84feec5d04d98a89a272d9b4c4fd7e0099080fecd3cbcf8c28aa2870c901a119150a3ca2d26d6bfb100d86ecf9a026aeeebe5e5cd1134dba1b9bb99c576d562b816d4f2c59cea7a1b977a8a2f0a300dcf729ee6e47aea980f1df8c9798102e8acf062cf3c328dc7bae6980aef20a9769e64f18717c7b5f5fda404ebfb6fbcefc36c189e683636fbcc46c4a04ff093c33558d1440dbbfde3f3302654976927d0eb7f3219f6e8be921472fbf2dedc132d3467f2a8ddc84937b0fbdb375bf18f7a398331300cca7ca6a688481c4716e8a721a49b8cd44292763d697085131cbc76898b2d1d9ef8a64e5205d394c4d90d23ff7f9e37d5dd59f7a7241ddae3c465cd1d2d0c566a90627a275ffcbabb0a9de577f9a7ea090d8c5231c98a4ad490d6cf1d9af99fd617cad217290289996c12a60f23d6b7eaf5ec72cb58417abcdc8ced08c46b7e5f3302fa8bbabd3a22798ea0b4ef3df7222de3eabb9718079f9460baa84debdeeb7a6d7b3178c213ee90d1c55763b2f824e4a85901a4e7e47890eae7ff1c803ff05401ec299ecf7f3bf9474b92d8e68d1a72e391b034867316e0bae1e04bc1954a5225e27904280ee27f7cb03fa62e55748851354b5300570d8f2a25a27d85202df68fe2fbb229ab0135602cf47d802d3457441b974fb02294be74900bcf9d1b5cb3fbf589566247ac57e6a5a488d5396bf42b617db6f237eab0a0cd1f54d8a504b0a6d2d7e25d9c8dc55e48904614a2d1d8c9300bf310677248b289e7d2beecc9f94790629ddf21c5d30e988c026f0ee0694c2a909b9f9bf2b8314238eb1c3f9373109399ee729cd44f8bf7a7ae53aa7a5515f2e1054210dc37aa0d3f7b8ec1820ebe3067f5600b636ea63815d07a4adc8fc89f6ad1679ec53f9bfbceb2087082543673c0bbae716ff9d96aaddfc58f47f2ffb14467067f06eb83ce427883d6a64adc6471937b8acfe0163a1e07d4a99dfa590850fe3ffa351df9043d8350c8fa9515b78c6600d38550730d58fdf69e87d53628700e670271c7f1f928f295b260342e34457ffbc6f55776d0461c4f9d0813468e8eefaa4fd9033ada5a8076386cfc5404670889e56d023edeb685653a39464b962298f271e0b1b7bfe0d362a2e0dcb22f9a7fb33feae1b9b70f9502db861ffbad79d4728d139bf731303905d2e15322d660b4ef7acbfae31f137b48beba91107e410cdc75b64ef5c18007b8ee8320e30e92f3f891191e6bd7e533ad9c886cae60614a248b52ab022931aeef627d02ccc2886c3817b9d5f8d71671d6fa8f58f9c6aee4b08c4c8d23612f8184a03fbfd83eec2ee324e634df57557d16e6e2551ef8b0f802870e8d419a8aa27fe4669996b39bd3090996a0d1f5dad5e3f5049a8bd612875748b7dee01260c5d31f41fa1b8b6fd0cf2af0fdb7bf7a71f7f5fa5721a8ad8af3113ff191729d803f55c5fb8fd3217a9c8770a3d821956565ab8186f26528dc64245f5502ec6fe539dd1a6de599dc53495d7ba276d6487391473ebe6d0231279d8fde3d26981093ae5110db501882726b3bbe41c0afa1b13f2deb5abd3ebf613516c1314067ee02d6e8124914406dbb5eacc40b5216fc26a36588609a252bf531ec844984bc17f48828ea9d5bd31a2a77fd00483a39f88872b04b0f438a6b406f6a3c424823206004809dbd38a0414392ed4d32b75f2efdb663dc4a81de4959a39a14b29fc0fc059306775173a8fcc99ddd39aecf3c9411c374df4425940d3df164da7a5ab0ec0e9cca2a6e96cd3913c4c71aababc969dc4bafa511dde674b55004ac13ade761c855fd7d922f361f6039102f7d94138ea5a5e0f26c45012de1eae35613c6af6382f089fa92d5682fc544e02325a51d0735381b78abef9a7cefa2bd0d6af6a455761b6240790c58c4f52b6a6f9d8d241f0774c7464ed4d4c16155b8cbe606be08bc251561242026e213664fa499dde66b010ff5f56dd2ccbe530c422f2e0d46dcaa4d2c3b51fc67aa68b32c06af3494e48546c48cd7317d8dbf2c17d4ef3cdc4831483e2fa340a43038da7d891ad6908c61a593290e791da74b03ca2e5bb6234dd771556f6d2f765d4527ffd602caa874b10819f01904f7dd11e076fcdfb7bcd927d06ddc9383696c8f749404fa1b13523c42992f55a2d276a1717592d269a3b1649a25860ba2b862a517b05d8c4881570ae50990e06abd79ae1412a914dc10d57946be5192b6ae270418e989a7078d7a2f08f556c56d08df9cf387fba15f96f758fe44a653c04128f1ab949e3fa389ee116aaaab349260d488c7b092d950263b89822b88912863e870b0ea01340085af60c901a9f7c600ac5cbebf09fb8da656e104bc5a1e0b3b77189fb261802477d83c0bd68e99de1eeb8428f49f96530c2b785f50b5a3b33a451a8af93913d2648a4928e19053e7e80fd84bda2665707753af913085417a6d13eef440ef3f8b2178acc05120e5b5e5cd999d5c9d281a10b2be133deda7186134f838500aea409d367dbb8501f45b074aefa6d7a00a36b46e060c9a30d04e905ddb9d25f75dd4ecdaf82f64ed02d63a681c64d9fb1333dbef98265b6a39bf8be87b2d5314089a4f2f5d80a7b5763cc80b81339e640c92c2e1fa03b48bcf97de084332a0557de3fe3d21420677f5d8db52d1636229fa6c5a7530edbc54c081605a1f1c129d4aa89e564af515e90da9ed669933abab54f292ee623dafe271b82704c92e8b74a726b8ac44556cfe7f90144828fe94b235ce14aaf6a48fc278ea092c1b362d6924e401640dc22dd734b85b0bdf5c89978fa686f383a5cd77d1acdd1007b651dcdb8badf79818db232f5b88096663239bb0b503461ae8759190e3b583112a5a69d498e075e5759b37961e00f5e381334b124f600b1fff1c24d8ae9c132e7968cc27cb5e5969acd519d51504c790fa7c1495acc6dcf40a08922753b25f5f9e537092a7c3cbf56628f4795b1b32568153f8c5b651a437d6dc04f84934893b9c77ff1b5b14003c2f4bd32b52cacd277a4cd05591b46c6a4d4d69cf453d2fb72f59432857191d16c7ec44338c161cae42212fabe56d3b26b5157ca9763cd3f30e5e4f48ee5737ad37f2358e08a5adf343872987617d5d2235f5800e4e248a6a643e6efa2cf3dd773d2546f05045630b9fd00a29630e373fae01aabd2d0f5a55d4e3b3452056419d488dfea386a640ed64812349172de36fa90d70e4f6f5cbe091ddc6f5ab2ad505cfdbd310e4e6ebd8b3b3beba265f5d3195ecd77c6d2a788f4eb951f2cb95e508e5650a449f45298ee50fccd0fd6904b65624e0aba4602503ffd0d127c8fc8452914a9520a1934f253df6f48af765b7e2b9b0b6254594a553eea8efc8ccf1bdc4514332f823ea20b570be516aa1bbb4e6ea58f519d6f72de2269da46202616ace3c00c2457ce469e622fb6f22ad5ff1b2f453caef8a87f4adb4a392986b648c3ca2be96f38bdaba5db2b58135ed5edf1a6d9dabd216537bf563244ec90a46e3b1264e480b4e0d373611b173e0f2b801c8bb7d42f59a94608e1ae3d7adcd81f36a2d01a73f0dd25913804029af1debc90454769b04401a460d4121aa062ef3cd1abb36de006ccf9fd43a3c66cd4844d09247d6b3b4ba09b4a91f5fc43b53b631f75128dad8092cbb5928eec70cbbb0715095c9cfb7653ccdbda419050ee5746fb31c745ada2713fd98175b739ed4232bee314b5e4b05afec873dcfd0d5ccdbc28127ab98f5c2ce567591c6ca925481119fc97391347ff0bbde6745e862e320c199bbb482d4bf0e88748e1aaf5da7542556c4fbe57a3b1bdd6fc9cde8909b03cca2da23e69b584605ec70072ac647642087529af411381dd5b974d0a6b86795d4261db3934ac30a48e13ed9b5cae391813eeb72887f64059f45656fd98ad7252e8f1a0b4c1c4fb44bf6a70455c498ab9c5e49344a62ae24152fb70e740c0aaf6450c4ebbdf66fcb8bcf8fb8d1d43eb933ef415ac86772f32191ce56e6eedf2732484f392995b64e80f0c61d7bb367fdd1388bc5cc0c79f8827e6e6e158263c5354776f8f243b1a829ae1317c340cd52449d35da4d81d8eae519f43b038fc8a8ae6d03351b073183bb6bfb544c390b737ae90712a66ac1cfce87c78b9e48eda4df9da93c0801a1b674fd538145469d3a60532d9c9a036df0a365ddf49fc43afafe698da856ebd065fe610a486450813fe821c5c8f4f65b585fabd4bdec261ca38e0d6d7e08efd82b3af4e2f2dc03489eabec601dbd8552e35569c8edc47098c1412560d6f3e942c701315ccf7056430ec224938de2aa35219302a1f1ef21857619c2635d50db4af6e7767566c6ea0883fac47f1639a2b966873ca901e249e72edd983aee94bebced7b5b189b164d58c489de21618de0e6a60e9a53e7a425bf26b58f8e64394f6880fe50d76f86fad8781f48335115eef5aef5b03397990a37614e01a202ad60fe022fa33700744eb761b0307e7c6c3ad98426722f43398c071a7e4ffdae05251e736751d39724af4e38d9067a62d993d164b2f65bd00ae4e625cd810cddbbbc56835f37c8bf3deb4a90063f1980bf46f5600058b966ea9bd4c29f88139212beb10192347af271a38a20c02a0a3e2268afeba5419865b8f484565f611e6ee3312e48fe910ddeb53ae3375392cb8f6b9970bfa10718adddd37c0453b6a6dc9cd2c6e362b6d13fd8e9954e2c83aa7179899f6f70cee0caec2418b6b4ef0285f61b7a825c794608f4e6d4fa7fe17e5c522a67420e9a725f046e3085daff4b26d0b8c304f1704cbb10e81b58dfdd066a367a69dbe523aba7296526d5b520e8f780b055694786961e179a2e590a7a8bd0dd3469262bc89561a2f3231f79fc2921277849a9ff1178e2218d0eb8d473e5a5059dbb7e4ee65e7cf24ff100e64c1bebbf8b0df8b952a6a755c286d7656f55aced8f2a1b027e5c178b0042cdae810cf09b3c04baee93de616f5d4925a6e5931de1ff824ec71288b12881cbefd4df59059764ba70e9a009f5c0b8841d65480f07116ebdbd4618c3258f898f73fc3d77b4027156bf2bff2ef7dc393aa274b64abfdb83909de9a9ad01ab07a59700a0a45db934c1a8253ddd39684d143934b05421d7af884b005bcb826f2592037bbcebe53033acc35f859bd800f255a9d39ca672fd229cbd1ab01da96fc387ebd8ceb4f65e801acd4a275a4874ac655b2e49e41eb22edaa5eac7661b6622af229041c81f321acf6bcc8a987b5d197f2ef43e2edf6285e49b4b0027cd3c78a9be87eb5e60fe7d17377646db794ff8b568688818a71ecfa8b2e6e444bb8dd620022ae958010160ef2927ae609a41e911b68dc2135e8168dcb9bd76fc5d64206c3b45a35202d541ef2fc4d5271069c43b0b61bb4e145f57864fac012cd69d37a9b65c0ac7cfc9219d9dedca5adeb30574b911c3e8625c056916c06bec7d585793c0a9553f6e31e27adf0c268f46ba0efe9f6f7b04d341b0060a7aca9b7d7cc92d30db2ba8cd27ab09acaf0e59c715dd69f8b9d8a81e8785eff25bfd47d6e39c12c18c9931ef455d6da1825dc3a2e607ff1ceec7d49c99a09188afbd7ebe01f428398560683738122663438d33256532df784f744f936058d9269ae6a839751dc036c77f6cda665557f0a0831e1cc55f4a717055893dbd7a3aad22fcee40ef41f368099eaa7f2b8fd64bc006d52067b93cca3ec50748c52a779ec1c8442141c6df221373bb194505e6ed474cadda4ea398f6fb4b1fb5a96f08faf23c80a019a15cc26d412c34dd6852948a4677424b3ec0b9724c515d6fcf61bc2aed76132d46b3e96d5b5dee2ed8368604ff43349e3b34e365bbd8465c349b6c75244196aababac10e7b1f30dc5c4fe021d4e02b9fe433b61150b5ecdace3f2b9a9d9391684fa2fe740d9b0827d6cdd5fae7acca416c9f05a7043f1888792b050a1d6790cf87db009ffab44d4ecc834cfda23701df12ba5530d802d527c9a08e91c27e3595cd5ac01dbf682bf0b7a1372b884c337ff9c7fc7a67b97511de911c7cb6124285a0fc92a9afb259fd900c007eac3ba8be63931e1c2c1404b0d5b71b5478efc3fd1865f01231cd0ba24d3e52c2506beee668d856a3b6e272408c503966412b0ca101872b1fa2fd0424cd0a082a2593d4b1fe8cfecfe3038e180334f970c396c05f8a28469ea216b9f7d6bc3bbcd5e4b36e70f2bfc669e090f0ef1d85d7a6939cb751877730d4dfd2a1b1b7d3c10293f26b60cea9fb41021dff8b812ff4db5129a253cb3b1d4fce42d594d2c754936f8402ea89456786448818e43cc1fe49e28e40186e0257e836569b6291b1a897e36102c0e69122fa8011cd547b00f0ebc9799aab99bd409f39efb6294c14fc283f5672491ea2e00889a5508886119d4b61ac63246aaa3dd67771c0ea2ad9e4d35e477c64e847da3de279b65186158268eed2e66d79c081bf78890c27f59da9911801b1a5fcf8e866095724f7e9810d0232cd2cee789a385855d31a1a6e326a5e5e8254f8fbe00f904141e1d75081e4df6aa18b70f392042c3698554336f55e32c9a52b3c2e0f2000cbed5afb786718dc2e45672f1a74ba2be3c8108333ba4f87a949a2e2826844b9376b2612cf3b4c58c7557d49a64e769b6a2d581a0f4050c226a9bc09674e4a325c8f1efa795c2fab6e2dfdf8010545f775cf4422fedd0f09578fad64a533ab7f9c85a58993c79d382d64bf1b97b2956a3e2ac19a360ea54bcd8fd5e0b12e684d4ee1adcb536a040698acb9cc8fad566e2c24304083d4ba17302880a50d7c77f8fe7efebc48fce353edb8ac2f4de67a04a793d1db13bfd00f566e5724e9e51f3bf649bd5ef493f892f856d2b0713bf8ad882082112e6a0eab264e5e6459388d5d2396988296b32e50de2683de7665c57fd767bcb81eda3032808db26a126dae52a1d7670cb3a451caac10b220cb1603546c3d79ece9da332cfb2b3c45105c800b72478998caed57f7f3bd937e6bfc780a05a88c14e62a37a57bf5ae30a9d618cdae4cdc1178861a85b0b786f9986e76f46639a60b56113c629dd9b72298b34134b3494fafef25833f5796d8dc21488ec7edb40d5ff7bb19ac970ffc4134af53b39543d0bfebe0154112b7b93b801278c7e03d9b6e51b883e6ef90e474fa0c333c1e82bd00dabd88b9281bb0fe8454fefc1cc69a56f084f3300bc0d60e3ec1aadbba0e4e6bab7a3a5c74db503a5300871c8108cd9e354cc2874cea76f3c4f2688217025fc2a522171b3a414ab90c5b2b8b9286d0ee39129a33fe0e23390dac056de261f497952f1f6dbc7bf90192cb21d9b5ee74d1422d65223a32de4b865ba4d23eaf33d9245e6b957c118d3fa7341a1b56b74defb9a6d673dbf0d1e1c9c5c3386d135dacb9be218fa0f3cb96a8c51e9b927d957f92c8d3ffeee1975a4434660dbd6f39450b26cef5cb70bf3e12a863a7bbf6363dae8a5a28691bc8ab118ff8be80ec3138e976997ab57b9adc414abbe5dc91f9f8a3138faed4fd6eb95b6f53f5e4a552624ff96116c869c54dcafd54e4e4bead214350650307cb58a7ae486151448661452cd73d6eaf477a256f9ee76df7c23859b15b3fbc2cd2c391e98b63dafe60b9a8637fd5520aa48044735e77066ff412738f0df5bb8b6fe97eeff1ed79253c26b1d5bd87bbf07d3584f30dcf4e2d06f44453d9f3a1c5b38a21d1b3a9780d4e6114fe365e47baa1b1e907c30406418e729eb88e40be7208863c2e08bcb8685b1af43116f5782bddfb054fec2356940478f55a3e082142fe04d999e5bb840b11c536a955447ac5fb6384c14fb0f12a127fa67742dc7b4a2cf30e209888454934ae41bba2c951435899ee4ad63f8304ff0a69035051eebc13b0ad40edcb1951a7852a2b2767bf870dda05da94d38015015e5d8be6667b58f40e40c08f92907396a1636568819a34d4e0a0af966c404676a5988a67df19c0038387e13f2e79a61051b557a72234b4ad5d4205ee3b52b0b24d30224c6139be23ead64f6e609acbab781f0e7760aa481f3cf53b77d05be17a36cfa543cb07fd8f759d1a3e3ab3dcdd6198bf7fb35783ccaaaf0bf282ed988613824d66f1883ad9bfd85852848229895b67bfbcd388ab3968847501f988738077ab161d7f0e0ccf71ea6c224aa261a9d7293bfb3932c36ecfaf7e9388ef8b5cabe00beddf10207978b5ea882a80cc99042c0f7918df0492db2c712895df9b816ba9080479925132f870583db94c6797d6a974585ba1cada98063790ce9a91be96528b2cc6a18bdeb5b8d025e3c1fbf5b9719b9fa1d9639ddd3a3a0f7af8d7cf438d4dcc30321b99cf12077cf96026c2f8e55c68bf227a1a30f41d7603f55f255189ae064861d2bc181d4016c70b202a74eaa93f718d103acdb7c2b8451342db6362cef298bcd89f7ddb9e880b36a1364e956b0d9bcadf0ae6601c78e9202bb525cba0731148fc6974f770470343311c82dd397e102c5eb1d263623c937ac4d24005e8cb3980e7d5b563832b2233bc0069ce5d3be61476e431a384526a718c4094d0ce9252c2a25dd8a9f635c600089a373aec1fe250fb6a2c744dbc089546911183b3ba480c2ad9623d44a798344551331506c6cb4cc2d73ac75c295db30ca9acee01b3f8b652e670e0c503d493418f9749f7b98c4f9cd41c0ca3babe964a0441848eb7daa276d8281e3065cfeb1735985e4cffd9d3250bf02b41918bb8d8f3bd62a6fdfa5f0a0452b457549d4401f8ceca22566f1fa12d07e3612071150fe8fcc7af15699b87aaf6eb4cd27cb0c4bc9148b3286422c86e2bf2ca417aa87635fce968e314faf2d55327aab8130d2723cc9be19d8699004fce0ec58f26e372bbd9a0eba14aaf6795dad711c9ed4858ab30750ca49504e2b9fcd1e61fd021eb0b9c6b36f3655cd335c850e3eb1e9d0df68044df5c347f23487ccba42f8e22b981cba648c193789cefef9541986121ca44ce2ab695b49f8601b6fcf40c22ebb7a431b388a5955a16b36a69b853ba904e68513c9afff8f16b08997545da051d0e1c846cdb0ad73516c874bfb940c727a145f68ee97dd9c4fa9510a517050578b31b27672c6a7d31945be21b1b11d3fa8996eeeb1d67852ee5cb5f4fa2eb8963d53da6e8e74a019e0c52aa0f676f1cf882b91fe9bae9ec790c6bcd700ed2ded6f62ec03f8b0243c7d9e4f3a0635717706a43d5648907a9f2a6bc92926bcdd9a21af35a7f9c61f121b6f49c0fa30038c12bb3e4975eaebfaa507b4a544ab3bc8f8e252f6fb8a7a81bd6621df3af919af6ec1af564ff8b7bf2afdce7b4d6508bb89d0ba567fc0c1bedc7be8e83b33e084178af254b3ed99b13c18e007fd56459de38b2343c405492d2a3e0b691ef8f822fd0419517f350b5459ba78573ea8d8a2eca711d52cb582e93d9cfca700cdf6a40781c7d4934e3842062d189823bec2828dc0e32fe05eea74e03024db1e99d3f0b608d1eddf69dc1f60e096b50cf1e1b4f6ffb7986a2caae52d5d32f95e5bd06f4dba3b200b1f4d838032f5366aa5a8b8824513f7b53bbd07f1e2d468cf5471a38e071e5ec8315c14ccde492cd2b157cdb227909b4850d11b42797f33aaf7f8c590f831ce826d9c5d0196048eb7e08d35f752d8a9dd40b8208b08e0a27e626881eb4db21eeba0de691af8e98faf1afa8ad0167ecb9fbcce1ee4293ff2cf434da1edd7c81f627edd4c87e5f7d5cafd9cbbb78a69d8d5e163e8d92e38aba70f258120de2dde810436ef52f46c4c8a47135d8295a45420d84aadbb3f77327fa1ab8a3de45384fe19d0f49b84a31347fc01407495885b7a22d686ad79cd5cbecd232ae62ad50d1742dd01ba54d4291320ecd5fa579dc526e0baf0d3af4e2feab315b7dfa0187f961743ae40b97397bd3a7a2e68f4e479357df3b6b3f3ca85c0e05879ba885de370e931370ab45d2020a39216efee6840dcabfe8f7bc4ea309567ca12afe6ebb2bae52a8e55e075dc579f9cdca4d930dc6e67be7e2f9a8ecca18b32366545f53af1004ad622dd4b10c9c4692fc1cd079f54dae2372865e9af970702dbb710a7c7e7d03ff20518e3611f1027361a73d7480f5ce232ee20d90c451ce2be726324328abd66364cffe5ff2303706006060a80a7301e4c8819a3d424d1bd3cf043a850f3eff6ef21eeba81dc7fd9b042dcc044cb0f766bd8d1303008c216f246396ffdfa8864c08568a13c9e2150a51c908ad7360014952a2a3b0f8c050c8738b04ac99ee06546560cbb0e58be163380e9ee715875f5356a8214d54a019b99e4bf3b51975a4e480a8a9307ed994877920dbc25565565ed54e90e00da7804543c9c2c7b0b4e5ec211dd7800fc2885114efa0d8f72ee6cb6236831ffc9b464f14923abb13afbc91caef572a64105558cb71c7128f12d49739a438d26430f5c7e2a4523eddd9532268b1c5eabdeadc53595273112685073fff16e148dd7b9dbe343eff506fe96400671bf134d00e9bc5116bc66eda2dc67c6d26594f6cb0263698bbf439b76c97a1ae4d74bace35990d4a672cbf73c0d80f8e0953d67380d3e87106a8877ab6995d14b35e6fe5abc99fa6ce7dea93e0129a4b61fcfd7748d02ef4d49ebc7192696a6d666f447f2a86d4d87e3a5af49d22ecdd85841880a35a5b42b62805c79d0b17ba34951c89ce8379f82c334835d9b6fb132bb4c46ee49fdc7a56dd6c036926ef82571870e776dedb518880ef469f14596c3fddd0e93fcddde053179742c0d694b39f4aa0de9fb67698a2e2bd658f2f37e6fc0ef685888554b466b7f636b02a04de69a9547f83cce55fe743c0e03e2d9bae46c87bffd6786b312ed6811366ff01f95673fd57256410d5869c889e9ba4c9a6a0302547071728622491d6c818ab50d80bfac1f9c76a24ba41948df1c63e87143a643c3ce5b075a482b852c352fa1fb251b2c8aabd2b0522dd4a09b41a5335a00390cfca0510cf7ae9d9caa0f26f5352d8f9e615270346dc5ca982b9779a5e0deb7aba517ae9daeaee6cd51bd863eb3ec6a864abf0e04bad5ff7d579a925c51f4b2df5742c3e9eea802c363b9e6cf255af117cef5c09729e95a84630e8c7e7cb7d6a5ef899003f8ae69fdc407e2b0389d511044014fece3b3c9c62d5e44f7df4059f09238aea7863d35904ae77555f1686cfb4eb73ed0ada5c9c401525cb9c9d7bbdfc8e12f0a75e8ecb218359558e8e55cc7b2f72f342e1ce6bdb48cfa3943b440de313751c9493ee4cf31c2824bfa37539915cbe11f99d2589b03bbbb45dfbb2390ad002bdf8f9de4ab655fd9e547612ed44faeed199db1b54187c5b0e2b3ed15839f26dca4d2eb72adade94bff47748514d5faf44092d28fd5e44addff8f79db7c0bf638fed94a5c47081c7aa4410c57c1a9b5eeea9827d5260e6f4b2f59bc5016384a6da829d347132c41f9217dbaec95778880ce83b0340d08fbf532726d4dcddb7b59f6743f6b6b3750de54c0d3bdb002e5743d9d70da56d3d47d4add8610c6f62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
