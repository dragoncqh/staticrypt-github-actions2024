<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"004cabfef584142280078eca4d779156ca4a919a9afe34aa3fef3fdf6cfb2feaa4728a480dd64fca59bda5f404b4827a4cae2f73bac6d6f29705ae5fd1694a611ef0ba0aaa2f4f43b4b3c33a5160ff94356bea240476c487872d4e36511ebb61db8c97899ab19c224ab529331c086d715afb6b0ac2933502ea2935480fd6bf127f27bd7e17321bd260318468094dd953451437216c630456dd78de3447070dbb81a9cc3f6555be4d24dea9625abdfd2e6e1cfa34c388d868fe4f0a286ded7f8d2b4165a2608bc1bc5f26e5c83badafbf4427fb15eac63f28f5eeb2ece7cae5f1be8909189dd52999b2a3ab27b9ee5eedb49ba3363ba1bbcaba7fab0ee33cfe173eb15227a1e9c7d4947f54cf3ffb2f50f714544ed9caeef1f152347a3d61d01fbb2c05b77825f842ac2ec9fd2817d4e9a5d782d5a78ff2305a8a993819daa0a37c7128f81776e3d3f898ebbb276ac5f6825131a15170bb80f7290a14346a8d9e42bd35d1232e97e07a6251013703b207eed3c6cde6bf30c6a8ec1b5b9a9c9b18216257d10758e50fb1110f0e249f70e6d1a35ba6a2ddfae1d710be3f6a2d2b4badad9273825ab24a1217842b6864ec921b034e6c16ea23ed14cf632efc2155e8aa23a8e2cae91cad9810b9f3dc5018fe1583aea88bc0b7fc0d05c3138ac90eb5a6b87931c4e525c345176a4378858d35876a9e85103af839f612538c93951ce56df530686aba567fa962e6a30dad1bea44b2926789d167a336c07f79291e6eeea00aa43cd5a93458abfd461c7ea2312482c58e6787b709988dcbbc9817e27521828e355abc6f393288ba78d73767afb8aff16c57539d8c644d1dd7700ddc4141063fd698a99744566513810ded74f57eb54dc874f1ebc75fd7b5ccbee7ffcaadfe36af72dae44c88597b6e7e0c64406e4538c13f4f6a7669d0d551cdfa28f8e2d8390cdbd2141cdf85e2a002bb34de96c1d1239a705a24819d6b0ed385ea92509f2bedf278a10edd2303909ca16b9ec77cb89fdfbbac486b2df280c7bfef1ee191e07797a66cccecb678ceb77fa51adb5a5d2a03271a1738332636b94785e2607ff9216934a57ffcde20169ab083fdd9a5585aa18cb871a2e7da6a5e2b790b67b003c7f58b844a4f1bd73e2a629e060b344b3b79c8446aff2399db37daca67bbfffdff73b3ad3ffcb7f876451896cfd6614a5c10e54dfc82cfd66a863ce3304af62116246083b227f792e72893c803df18f91e0b4fdc0941fb9a5056d7ba280f583d444b460307db3451661aba2ef66028e98fec813dc970918ccb7d0a5fd7aa07169fcbe20306f621ca1805795aa5f2cd03a6e76b63de97b9c51f09600b809dab5d72a2912274f014b32d6a2093c21239dd5a7ee71bcf22adc40de706344cf15679e16e94360b04440b7556deb6054ee8ae94322ca20cb1de5a56c80a6344ad44192647d369a992c49474c22e1f731ced3df7c0ce906ed013b39f625a32469f7540a2cf858a67b89424666a5e6daa1146f0436d8d07cd4fb79f3d98c025d1f03933229b3164aba7e31ba3d5330abdde6c3aaeca09a3101b434b662fa7b02db5a45f7136314efc21a04299dc7db3c548010b588fe4c60566f887444f1920bb5806dcb6d2b1d3dd4409d3cf352d7d375027416d03a12aa6b41b72767dbb207a612c336f454ee7229bd358d6d26c2423e089dc031bd2028746034118ad111145a5ae43192c16d9d4d635df5dd941f0bce8a9095c5edaa5d3cf0c660c015e1741b028b721028a3d1c4a7933a945e9defb5ae21ced83fcc7456a4bd0295c724d4954e0b7535e8b74c5de156625d4d6008a161defce06ed4e009e12af958082ee368f2aed8cc5cb9937d52bf185227465e2625318cb4b25daff1dcb8aa8023fe3de0b862682d18233917321737732bdbeaaabb50d8aca737be1e7501e223efe69d778201910a8c989b5c8cd31066d4d271b286b9e89558942920935056b460ef768e632740b168d3f74003c40a91241305770dea625bad93a200a63de1d64a2d4b9156786798547330e7f6e3337cf92577738a8276e01b02003a5cb5dcf1986e159f1af1b762bb57d3869d7987fac964994596c2d19a2cb8a14e9aa8981b0c959a45b58c992f6571d0b99c683dcc43bdf705ce4b9103bc1378de9e97087e191c9d2f45a2364d1ebe5781062e4c4d9dbbf1c3b5ba4bda6bc0bb483f84872dc825de79f51e002ba288d774500dc2c7471c2aa7ac65ce41fbc971e6562ee881aad8d64545f6467d4ca77f5ed4f90d20617932f7d121e393cc214c796e1181bd0be63d15fc2557e52884ae16f0edcfd58a0a917758ce3ff9520f4e7db4a78d1502fb978cf73629df16e25fdcf600be482e058834a2a3c4a1ee8a79321a33ba5df8b8cbdb74f4cb9e66eb031f48c81c3d95a0a2c169bb64e119557c36dc7194757948f716178c04e80f1da98f0c9ef5c7cb3237c6a0ccafc1255212f98b7e25402830c3c74be895e2322892f808c60fd19d57e55ba0a4d41dc23073b29e73271999d29b32898c404f7451bf5e15cebcf269b66452f8fc05d59f951bfebfc0ebc5df8bb3a9c7882963154e2d9843edd2c14fabb4abf817982d2955aab65dc8d7f6cd3f146f558e0b8961218a69b2ad0f02637e62c9eadc4a7b5d49d0432d53ef5e0db17377b7ee25fc3e268728562e5e7ab254d2ba840d3f1f103fbab1285a51c658c1285673b41c3f7b25e6d803c7a6f8837a688a33af24d9712aae7a2b873ca968c593bf5550ca6a917505d0a9ad89dcff493b9afa9de0479189e654fa220a17cf0592a8cbd02c421bc658eb1041a180965e4057557ade5c2b3e419f9b0b3dcf1f2d8c7b15f79f7f236499673eab4bc0812fff5abb6ee516f2970f67c7bf8181e502b36f91af1aa1a2424efc70c2392b8235f6ec81f4521f50096e45b62cbea0d7579b7c2a89fb6447206bcbf2976e0225a71acbe0547addd916bcf8ed5d5eb9430c9d7e917f646e2d7cdae56845aa73ecb810740f837335520884342e44b0dd507e915015f9f35b89c0d6862f61bb24d034046821f703b2f14ac9246f8bb98b368d607e06a94792a2265a37f8a861338e946b0efeff713fd513ef355640f143a541199a19da6cacee18e608e78c4c777a28c00e8b5a5704ad21ba5c47cf0f9dd286bf130a308709fd0ee5fd9e531919705dbf1a6a739b7625f4127e41e28143a6bb883b3454402413e722acb2cdf7bd4025156571186f431db42b29545d37f0431553721b55b4a4179ce8e198027e8d44389baee1644b6a8993f4a2e070197c4a7151d3a72dc7940832c9f4c1dcc18e6417fc6f078a45134f1ee1f5493b1f67c89a207f693919d37f8366e248cdea4d83215e9a6ac1032fe5161115447fa9889cd6b70f2a6674aa15d494a390c66751cbd25437a4dd7c3189880e6a53239a61c3df358447fa75e729e9f34f41d652cc2c3653e814af9cc5ca061818099fcc09e9d57e4cfd62acc5dd7ae16408dd5a44a40f6e9199c26cb77cd89d07db84b26f5150c093ed8bcf16c249a02cf7d59d83b2f1d748209395b8da114dca677459d064216e3ce3a5403b23c9d5c855db7f42863ffc0ccc791457d889a5ff7f0e004d56a72730fc98c8c43d31865daaa0fe1eb00170b2d68e143323b6d63b4ad77877724dd9032f8f1f12f8a5b8614b65cdb106bba691b5d28b98f396793ac065ab958bf4a9bbcc480f242a430e9cde24a5d6f02a105b5bceff6726d1e0a90c99cdac600c4be94d83624d85550bc389d75faf9ffb949398d917d8d4ecd56a5aed70333266264539e894b8f6c82092e805b70b18543c7b5092949e7395bfb558e2fccdf942495cebf57318d00f3800b2724d4902006a69dde44d690ad420853e183327a7b7360e4a3fe6f67703f148ca4fb6da5503d966d66524cb6fe9ff88375c848fb6242cbd108bf6b7730833b26fbb9d090f85bc7a9b629ffc2505384e317347e290281bc2c3d62cdf2aa4846a0081ea8b474a68d34203df42e0f3902b9a286c0b2f0b9a7983ca1547e5b00839ad0ca0abd2a7391d8bc943f110707df81a9455de4cee7d601b9e39ffde4161ca6d47ba8502d2aa9ae90040233ff683842844b94013bdd891b2f9074dc11a80ac6d1bfe4f481c5ae513f22ed37c270737c7a7ceb8acc328d2a50a9f67d4471dedc0e59ed5385283f2242e152109d6ec06a247a0cb945dab8afbe5e579f49814cd40ec18c0ed0d0a78f35b0f35f3f49bdac3dfe748c2245539be0f41187cfe8e4cdc5e8f015e7e088d14b6de5ca5c0f8c8463d3300eec2f903950df2b2f1847d8071aa7138b61c730d3903da2ddeec3938bb47931df635a37b86f0455021a9974449b35e73357793d003a3e06ad41e8aa6c8da21e7654e61dedc9c3e9ff1cf15b08a4d19d8a16e71c27ca2f6435539576859f63dd69afa87734d2d4a46d1eee0983c1cb75d4585ec0f63be005c95c0de5d57e4a5b490db8022b99307049173933ebb67718261aa95f6eeab68b6e4b047b2278a347b5aebc0933ab2df0b0eead1f063ea5a930df292b1bbdba8cf695f283710a09f8d95899c4b32f74faa6517aefc4769f615e89950544bc14e0f356d2f1b3a2c4f0ee0998878f7bfb5a2c3b40d5cb2d009843cd8ab9e45c4a2c9804acb307533daba3bb3e97b42d42299f5167585d356494d9cc9ef05e6bf6229148390de771b9160981e6e3e0a680f191fd65278906ec5392e21fe7cf3bdd1edb20e8103144d8e0c99aa587eb2ef274c09242db5e2f694f0df8b3ddd52f21bfb135a119f67e0fcabcc2f5efbad6d37056b92db2f7fd8ac57d9bc21459ce1a32c87ac9f1f6e19bf59525663211a5ea65dbf299a834d731937fbef77127820de48a7e6c2da76f1e2811586b1b2cf24ed8299be04aacda7229bd795ba046f37502e6211645a3c485177f52eeae981b121d97bcb3ae7fb0bf76e6345da004a58f6730e773cdf4d49ec473db7498f5cdc50b8ee28852e0ecc30f13bcd483978c0db2b5298ff54b8dbe12289a29f57d9305d8e1f978b23563678df75f96c79b517eeace63da87b7ea2c44014f437fe73acbf31e8c1ddf9a854ccb18624f9085cdd69a1593b854d6a61de22405c69676b0750ad7fe64bc9ed5c618a6a3ba8fc92a5df6bb283069f04f1bd8afdd55bc9ce00c4b15213045ab99dcbf99539bf6ad8bd0ee02f3546b5655ef88bf718c4ca09bdbeeebf7da8368a97e15cb99fdb271d9258bab4f2184c22af5e1db8660d8578d4511179222f8ac72e8f240cd1787b387b8799813924dc322a8e2812d3e94a949b7882885c0a2230e9e0214b61793cd0fbb0c277186944aafc214492a86250a1f9f557b147f00d63fdc34602cd08e42b461509ec18b00ac9242634ae748e6b316312537e8c4f24edb5187a4778f7416dcac0bbcc19512d24f1a2a7b646eb0e4eee4bd08f77d65e4eb4ecb2196abd4d900d7b2f76dcb06b2c07f1a21f46c2df7cb0b374dbdf4c2f38f2237169f0f0110fd0fcd8121cd055c4c3bc33cf95242756c2532df9799c6f4f0491bfc004fc10de5389f7cc2aa33911ab7254a6a9a62b023cd0d9bfdebb5b8b8ed5577e27a19a66f303bac78bbbc38dc4daa648211b7a29661571745e0e55770d021aa90748fca0947472e73f3ea09b9df33990c75ef41c9225e7984aeeae9b46599bebbd8686bb672498770961fba76f607a6ca5418dbb6c08ca76e5fb690bf830d49cd30b6625b8cb7ab72e221ab9ed4980757a845e1107e2578f2ff4f225cfeb02719450268637b5e0e37133e97bf0f4902a84398fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
