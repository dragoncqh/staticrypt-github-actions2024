<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e88b65331b02ef5672ce94046ba85df31e30c9a7ba8d7e443ef590fcfbd32ac5911b4b4a936febadd24c588230464cae256fe4cac44ed06831ef2cd13d137c5ea205cb086d1bfdcbd51e439ffc80735053a0862941ce74f521fe394b971fe3df8c91e8bff08e0ecbc15c7318e83394ca94b6453ddae89d3ac6550bb7fd139f9d9cb3a233a331b380f0670a20ed857bc09ec76f41aef9855786199f5eb1d2c5d5bd793899c4e03fb5d07bf408ee80c9cb7bf7aaed3b9e2cb03110e6e5224e5dfbe1aa84b71431b5e84b6933ed99cd43c44ae0c586b6280056bc242cf425d37ffa7a5f28ebc23fcf90ecb1a29301dc89bf245cda18e5865e17c9bdc3724558fa3d65c20c8e5542ae67935fc9e371b48582dbd2007b765f532ee0e64165727582a474deb4c716cdfd502fbfaec7b5c00a00a3202cfc635571f4f14641dbd86289f31639639908d41a2fe5bdea4a72d63981d30d718166fdf1f8b3063d9b2e897ba67d060290aa91b7b89c7a27c9578d1ce018adde83a0a71d809934762d4be6d641b3cd64536f8f1b83104bf61d36e9d4c2cc69aa15fa5c7b4d3d33c4a39ea95cab733545955296ff019140984c1f99ae695bae1a1dfb9e0355f58e14214312832ff159e37887cee74318b35dfeefea44fd8559fdc6ec9f15baf531747be2d7326ddf48ca2a96db7ec87e92b2c5f875d3757db9de3724fb063326ad067f0e02834d9b4755e6e4c85b4e0ad46b428de3d635c53e18fa05aa9cfa176ad55ef9ca3824aa53e477ce3a91bf5c796099b89b03d75857028b06cc03b74855a30afc0e5bb6efb4773c1ccebcd2ca579ed9843e55554d292216ec006b1e702479f274ea782cae1e7b8bdf815c788435d53ae2b74bc02c71ba9125d8b96c0601923c8fad5295b1105b7df3896ec1647cf1018e64791c48916346ea415f1d72f4f30e5c2a26b3afea523d9c10f8ddc452fd15a446b93862fde3326997a678305d095e1bb9bfc98df7f116064159d1d77fe0acbdc1baa53f0f2c6436cb523d7bd003665809bf7fa4f823e5933abb2bb2b05fcde70aae31a18353bd6c4cdf50e5a8dab1b0af3ea36dc43b40501ad93c435548aa59b589afabacdda0359b2290ed965fa9272d6f9c374a4ec020a100b6bc971e3f8e7c9e97fa109317661f9d98e3c7d0a873004792098dcee8715d2020cbc2abb6df08d5f7900b190a6c044b52f7f33557228e158430413429ef7a73ee38780667ccff14306bff89eeb71c944bf432fdcbe79ca71736755f730ab051f66607e3f597bd0911a78dea92b2512ec041ca3cdcce016b323f05b5289793b0e1ee567c37e0f268dca05626a0c13c818a9ba22eeb3f7da93045e364143520baa9bb1258619b9c4aadb62ae8c1f76ba591eafe59ae58fc60c491f0d593e8130942168754b4cd9f43592c5c115a56d5da29c53d2d04fdb5973496ac38dd89ab9a7fb3054233e3dc3c5d3a6099bb65f448d6178857e904f70f0c2a1f7f7492cec57bc9b144c09fc4fd151264d623d37783da9d06a187808c43e08920d76b03607e1a6b540cc8dade27a2e2e93dbb27702cc4e0f98e57a61bc437494cd976d78061576ca580f9a36dec7f882cff25289d88ad4bbb781d84b690b5e62b16b72eaaabc4ced3451ef2d1f32f70257a5a841b0a9697abab854f9fb2091be9bd7c96651372ddfecc92cc01bf639076df59eadf9511ba1d9852f89c46dfafea569d5ff79d825b7872bfeb22ba5f7a3d14dd7ec8f34f27b8f8818da9fbd6caf879d46aeda182e4e3931ebc21fbf981f1fbd01c65787236de30860bbc3e733b9caff9dc57fec9b4ae45cd040e9cacf7ca529a8efd8aeeb5c3d7a3ab8dc5d798b3ae387af65f9c4f6580e4638e8231f01c58dab28870b782ae3ebe7cc3462029848ce13764bd17edc11c34939486f7b28ef75f6cbda56e1b9a8d5e0daa8bcd9c30dc010f02ca13c811b5b2b3fa6ef0c83f4abd44bd027e0ba60052830578435aeb7809251a63aa1118902b54ad235d8bbdad62ac3c540b6bfa97171d7b14f032a200112a5c6f4974bbf9d915c7f83511f8c71884564c3d2c9617277bdf3a35a15e2b884c1769ef9f7fa71a757224681dd0ba3c36923308b3ac5f831b107e1083b404c1dad0885ecd6b93a8267364aa1083190771d2207c58a5f40d573fa648ce2b1bd2035fc8c02b10f87e751713d822aa0dde4b77ce459ccf141db8f9b8ec7cb15041683b8eb34b672f91b2cad2e0314c41ae592f81a85179eeb6b808dbf03b8559cdf23535c45410da8b6bbe2af96997a26785b5d2efbb187c66016866fb4a72fbde7fed5ca38940f381320ffa452cbcaca4bc682dc5a386b4c88fe32e96484670a385450ec3b6c828a5ddb686507b660efb1dc4b3e06547119f5bb50da8ab4ba799a63fecbb93b02153e73d84d55e6c94cfc1846f5926a592e15210987387be191253d16cf7987a88967f57ab16f419d862544c65204378eac98471b234eb692a0dac7cffb5f127c70782fa0f0e5c41c4c1da467e5985f5bf8db080b4f501b55be1b60c988ec899c6b3b5a1215abae3286a251aa4c0e3116475373d48519b0a0b36e6d4c240cd0eae225d3de43363f0d6b38d29c20b58c40395935c47671f7e6043f77d80e7ace9d516d1fa624ad44235a10a320e3d1d476152ec59aa3ea24413aecc37cfd3892dd47cb1cd98cb860c5be0d4d84f2b7f853cde6665309244e23d42d43aae6ba5fb096949eb78e38f6a93da58cdb02cdd93fe0f888228e4a24da7942526762417e32654226e8912b676a31bb7ab34a76da2565ac8ab66a25fad38e38ba2054c697cce91d40fc48b778efaa1ee6c804f791ae834103f8b6ae6fe475285d71fdfda11e39d03b35a8581937c5655e4547113d2b7de4fc06569c5b000ca3f3a00f2d022c2d328403d349430a729b8c25afcfc33334f5690a7a31b2e1d1f9676ab1a6c32ec31add24807d52d2eb43d806ec4ec60e351985a3df70353d17d9c16a606fc13a8b226b1608982a4a580aced48687b991684b60d92da52a622d07921805883f1c8903300c713ae1671721b8e5973191a34113b5d4c32b77d9e764097eda910fc34a3de3ccf23d491d4ff8ad3b4ca8f2e224abcaef80227dba6f9b771e68193e3b2f2c1dffa9389af07aa5d350a5cdae9380e0577a373f2712410927a06384041ed102395dea399177fd4e4dfe5d5e4e474937a0fe6b98faa67eec2fb2617d734ccbd5eeffeddf560c8605917242a21406358381211d995229c8795eb57d563d97dcdca0207c583e31864e645df4944b9599b55de0d2f1f53d0a4e28d308ec4f0363b1e2cfc442710313b601d2936f7f1323f446c4d88f5f70af0500d38e1bf1aebb576136c14b183a4788b4f03fe05ddee34cdab0362815cc7fac0d48471513b8bc438a08b1b9a00fc51147f9c420715fc7c4356bc64a79a91e022c988241cfe1cba05916f2ba64579d86819e620d6ae35fdf5578055441e2dbbbad47478db74c5a6a6bbfb63b4e4ccd78c89e075739a299a65fc711d88d42840ab8ced2c2ef912fa2fb1a7e1406ed21b8d8c6a9d4f99749d9392bd0d20b3be21194a3150c3f3ec40a9357df3f901fa0905f83adf353cde6ede4721f722043fc98233e9243f0e7e683e19d89a2735bee31a84f683935016c49ad9358c3049026fea569785b042665d29bf0f70416376b5dab91d06f6e48a6428d1f1c9c4510a7beec85c7a84d7eb77a72a6e783981279cbb12ce2affaf77a7523401d8b62fea58acf47b16cc50b708f76461f56c41b4ba17b00a8ff466fd96706ab36529a76d8772d11bb88aab3ec1d58f5533263e1a191405b4a623da3db02684ef76d88fab8dea8f9c6d34006c8df719bc72c3e22b7ad56b809e9de650c26b647309c0b243ea1d0374aeeb0e2d15b96633cbad8beb1f3e7a5d53f44ee9909ec5db502b0d6824c68d2f10918bf235b8e313117089ad36df3ecf040188aaec85ef92dbe2ccb39a54a4147433c478cd7b1dd640b4f72a05724ca974a92b6807d06ed03125527a610ee051c5fe9e49b2e7725f741363bc26d625c9130d588b26b270cfb4b3496e0c1328f5666dde3ae505e331916c9d827c2dae0f00987e9ca4a99ee04def3b39a238803924e9de45036bba0edb5f43bdf1bdf1557969aae37bcca71d0a71eeb453eb49d9306c3e74ed85966fd773ad26a0589a918c93adbc6fd3e345c961f05e2af05f654912fb49eb4e649006ab1f49c877ac9d285b34fccf1c0394da4df8904071719abe11a176b9b04b20356594778e8c0abb69c50158c102fdf2d58050ca184d7358f0d89354934ebfe074d780c1175570ddfe8ce6a557aa0342c80112b6f20ccb08375ebc63001e56d04dfb85966a0e03ce98f45612780cd9d4e9a0646636a50d29daa77df0a223733bd24a2e343a3dcf98542c604a1c17a8d7a2a0024c83cbab86f28fd61bfbbe1c938c2c578fc3fff7c21d757f26ed550d2f0c621ca23f84a1175a63a55b8caf65b15c5024fa224a5c51169fb314178447613df0f51c6ef29b75d41581b2a45b3bcd166070e76e5ea73623863a2d43617a31da2c04795b221d39e1325393bd577c050734dc54f5dbd1615f2b05ef839448e43c92d3e946f2d3389543803cb4b637e8d8765955c411ad3783dbfc5634077e21f09dd02b3746fd9b73bb879985a90a2b44c424f19c8bb1afbdd8c2bc58308dc1217c686c90983d6c0b5fa0f0fd72b11de395acd150be20dad2ac162734ce036da3dbf9600833dd0b5d90e9861ce138e33461e167965903796dbd59c0a53e5ac54635bc20db5dfadb1396d1746854c3adef690f431aa66f739da199adcc8dac821f9c05bc62a85cb642568298a21dbfb805d96d23e618d7a1acf90a77b559ca80a6e188030d920ebb98a382e716891e6bdb5e840d9336f036f7638f4d62af47568626926e68182827d846acfd86951dcb31fde44ec3eae5c7a632c4bccdb306a626f8f4fbdded3a3e59e14959a7527ed59783642d0d67b2397c325cca7edb282450b1fd0879b944badf822b9c8fa8ab31bab1f08d14ac67a74bc9808202606571b279eb596f05698ae86ebb42068298af896a32c8d0f0f7aa37289e7f74a82ce32a0d9b84939ce60d5c968675044fa9f41267073abfdaa600cffaa862ebda03f4a09e2379a21354168ba174e7afdab0ec069a4bbcf78281a0fd51573526985f969786d0b64b59ff7bbf1e3c30b1b9fce7471811eeb4027c95279113cb641eaa27c0d310d9dff956c03d06e4ec96dce12c4cd49251e39ccea3ee0335e4bdec0b8e0286c4e02de8cd16573e970824e0cc8fd5ba64136b832e2ec5d05417fb096f7e08e94d2327f2d20ea9d7f16a631f8bbe8e0ad5e3fd3659fea074888e8f68752c07c44db60c1ebc232c78bcf67a736444b0d7b8e03827f486b892dbe8c9555c4eeb0b138d310b72f9068fbdf1ff940892317e822e95e1b7c7566ae59e64bb8bfe156948abe59bc8539cf37618dd82385d4a157cd6d1c66b84edc3281f70770cc9af0c6e29f7c32a22be588bb019d617bc769d1a1557da5077045b917ed8a911ae5c27022329cb58e1949d88c7624c153707dfcf2d1ca592aa53fca5ad929d0f8e310315ad3b6e457738baff33c8dfa064abdf9c0cdd224fe96182a3e08d00ac43e87b64a961f0e21b0cceb48d2d495a09d9c8d39c833701749ebb2909f0e7dc25df8a244a523cfc103be7ffda3e71879db340725585c236badc4fc5e023c67189449fc475c85dc45f46074953f095f030bfeff85096d7b683ce91e0edbc1370a4d39971223aef88ffb7f9844ac7b551d7ff8357d51865f8f86647cc5b7df52fbfb999255b19b3bf5bc24579c6ff50841c857416295b901bceaf1dc885353dd21cab5839f2d9b91bec2c992352cad7bc98b230aaeaf6633579c60937413e5c2602a1215b5b619228d3a6697e80d6dacb900548a11fb7a6a430852bfda957ddddcd7ae7a986287b32031dca129a9aebdd42e39ba4688454ca26de0246eb442cc4eaabdb67023a64ce0ca2bfe92507cf223e527ac913ba7ebd782dcf4dce7d83a194b3c62979fdd9250a904557e6a209aa2fcbdb9a55708398f5557fe587b64efb19278275ed26ee82ec9066e8a494375cab6b2c976b02d5418a7bc3ebe3bfec81eb049fe38f97fc8af0fee196d8b3c8a87b97fe21ab0110897da285e287272f061f85d50c8c28048440a867b09d00635c48ab5e4c2276c0c5005fd0c590f6d3f0114b7454b9b6b5d07dcec6677fa4517a989cdf85271df9b595b8f37218acfe959bc83ea89e764580a95bdd3a084400929a33e59ddba8123eb6e08734bf6e1a2f03158d65e5cc14f4986be3da19aecfb1cf09408e7aa2fec6fcd8ed4df9cac3e3230af842e777683ce416490926dceafc7507a328f15ddbccae57550b4c40a54b6bc341411338146d9861d04af7c4ee1ee38ca187831cced1aa61a84269551ecdd57ac6b680e3d65ff34205f504489f231faf046109bc66c84d3947ab4422c15cd042f25898cf9ec025338c792b769119f43ddd9ade0718a11246b3309f75005c1631f8b705e934bb9cf996b4f1f24b89071d2a1a7dcaa20b025282d997b098e187f7fcbba0c9bbafbd5c9f9788a857077f7643a79d11130a144ed902bad7e2f96242010b7f63925b0dd143a17eaa94300e37b9a49f27b95a8a6efc8c5372fe3566ad4a5fa1048d626b71687a8bd45843201cb6cc67a4d721e5a676427a387198665c075a6f883a2c54eb1389e4d560e06a8335236a386ef612c628660baa8eb04eeb73b7b68a534b9a2e022568ce24c4cfb6dd94cf36ce0c4c8739c9c13ed914bbe6e57d1c4692263a67cb7fbc4f6713dca3a38b9b31f49ae5ccf42317152150d662415dd528c61dbb3e65651ca376cc2c8aa7225e3a669e64e5188de484968f246e35755c058ef339c9ce6cb8dbe07154822b291cd962d5ff98854f714caf8a39c5167ea8e8529deb2162c37552a7e411f878f649ef350cf41290b4c418f2fb3e32c4b6e7252da58a5f950836e84a15fbf402039730de941a34032d1f945ca001955a19ea144e685667f4edcae0c6554c3dbfb4e33ba7c54dab8516a850ab4a126f46a21efaee6573acf8bf442cd172e674e3b326b46dc478146526ec9021ac0216739e0049e664c95e46ed54bb274bf4567b8ce37c6f452722f39262469183b042dea2d26fcfb85603188c5ed95a0af67b97ea397b121d52d8b2ff98cf31b90cb51efe9cd330a739fa634f1c9c8fed2513ef181cfd3850d1a9e68a92aada6567468d7da80eb8425572de64b496b7483a7fd21dc2d1c49c8cdef8e36f722573ae5dd82bbd142ecf37e9960d296418156d35e064adc3c4636105a1300b0609ff46695cea6950bda6e0ac4ad13925dea10ed8b44c4ce9e199448e6a44e8963f2622bd6af75ac163383a2c93ba7c761f98234e52568461af1132fa575bd2f9e156c05580a5170c21b9dd0781f943a97c3c4c05825813a3c005c7899953e113f86c9edd9a9580c888573255173e980fcb0f90d7cbd32683f6cf3e040912fcd975b4ea6eb1a0580aea45a8f2940c7cb58c21e36f470688176e9752c7262fe177117deabb5f7785ead4b401e708012415b42ab8f18cbcf76dc83915cd3175f313e7a0e950cb32e8c7b4abbfb90f73bd4d9c74677a958bc210114b6f02af4266913492cf3d18e1270def9064cd371c86c8c5be66fe2dd2197d5b1f082fbf5f422947673936d396f8aa495092574f2879a1de8d09f71254b610ae55425c542e347838456c52b9435a54bddbf2a3d8f2f7b08b73a30b240d0a7fd91ce1f981c9a41809ec03124b3be01c74155b67959f0d9f8c648325b7400314ec0063341dd4c13a560df54909d8a13715a7353be309208bf3c301cfd1903f88a743ef2c4f843a25dd5d92a1c626b06a489e1e698aff55098462d84ae12ce8f7376a8111dcd76991b070b37084cb318fccd1f5587707d44bc959c35455364bb8c6d2d07f95059a4b4dff8141f89f225efee6a6c3434ad857994c2ea5aa799c74143f38aeca2a38a500a4521ec73018e5ed54d201306a8f0d933600bbbb56a360fff1f4f9f048060dd8675ed4d0515752af0aff3ee66b4c36f2b62932013bfdbc935d8c9ad8d49ce7fa7aec890447758c4e22d9cbc481cd8b445db9a30b4474181e5ee7cb6e0e6e1f0914e5eb0d087d37d3e1f470d8eea2e75ced3f4c625ada2b430973b244d88aa19abbce1ec51595984a19a7ed847b8b3c5459b41c2b19c551aa059681ad54735f4ccbf0ed86672ae81ee0f6e655a846c337bd738d5fb38ca410045ce77e3b261044f3fbdd5c2a9e869e5efc7b048bb8af50172ca91a682af14b6c9a95d84ac2f6872fa4254c02593177407cfb3c0cde9b3f9bd2162e5caf2ee848ba1d002f75debf61a00bf786617b119e31ef82db12990880ec95ae9ede30336b34b61f32981d89c009d6056e8634f57f8a7e2fe8252164c64b8fb7c9709e3b70c88948c668504e28ccd6be22a59554a2f770901f14e2b23a74cdd05653de75d41714c44c41d8c0ec064f3542bea562af31cd2e6eb0b3af4cc7baedccc95db08030943815230c5ad03b687f134f9d8c72a74e8c82afad5b9f493ee767e22733c6fe42156d6cb6b090fe858dd6baa5b211604de0923121e8a719c299a347b42858ddee1aa42da798e7aa293eaf7ac529c5e96117af4371db867b16acd8cec070cc3444a2023f9ece84b01f8ff72062ae80553f9d6e549d44a33eca88cca32e80d6b79c8de7949d5ae8f45ed76d84c63fde233a459604d9cd182ca5d0ebd969626ba7fd98d4cd6941ea04b09b90e938bb5fb27d5d63e9face1c00d64967afacf202661d9271fdfca3b380302c784508c3e8ada130c08711fb4e8700b64f64ebc77099ff6a992dd88b30a0a2076161b9df5877d59e05895279829b91f99ebc14f5523663111d617e6817927143f9b0a3b45436b1aa313c4018e8f7d51b43bd75dec00cb9f04a475a4efc23e458637c3bbd9c86c0719137bb9e20ac08f54bc7ae32b79fb2b0f3d213e04b075904b7f9b7067eaf918153ee1cd13c5c863d4d3f9f9efc73e712effad27e8fb9de049d3e29524578a032f1be18f41d3b2d57aacea279333c7620d8c23865a27027ccbd2bef6b784b8472892677383d8969ef9ffb0ed88e5fb2187252731a8754f0f2a13f9dfb653d6ca7bd771e527bbcc1753939df848168da31a7dcdf21dcce81674cd78937116a492bb0dbdae11d72ad6c4000b8ed41259d8044121b9d36e422343af702a8db3d5f1d4a0c0a02d9ecbaff2a7e8a4d52b6da90facd3cc814311fd720e99f67100844328111ef9ecee013b39f48723d87a9a879ae600b644b504ca28b635a058fd51b8e1e1bd91d071fd66873709cf724aeb7f66cdaff54ae6db1e6527d37ce4f1d69a5937d8e761647f945de3285ba7e7d87d0b73d823a5fcbd332ca539ce3f57254dc3261c20582ad32a6a0e735c393b7be3b18c724e79dcaa82a724651fa6e35f3fffda3696e4b6145c88daff19c27c496c4f3dd8e4029e216993bccccd12371c4a5bcbe9a5ca008799bf34542bb28ea87a1968aeea934ab7bf111a135dbee6e6bc54ab22a0327ff3654e11c3ede36359e15cc03c81ed5fdb43559f2c28ac840ee8f9b553987aaefba7083db9f1ebc3990061fb2ecf89daedddc5d5a85dd020c240eafd6183163a3d617626612d8e2b372cf48f6383b5c0a2865d19ee5639729daf75a538ab7a0089ffd0183e3c686377e00b4f1562c14fb289c411e187c9a2eb718e8be300f9620f13e3ed366b675d2e698879c5fdf2228345b74e5aa41d0b65c0808b0d5e53687f62da02079f2a6883d22828f78cd63daa0e3bf47cb1b9dedd68d715561d2c7c4620eb84dc8903534d875a7e992d9ca9b7a365f0785da359c4d7c701f10674dc8920efc38ea06c7e296bae6c7d7a642cce50451fd4ce703260dfd910f8f075cf7ae92c16e9d7cccfe75dbbbc903b5f2627d1d38be7531c3aefb4c3a72754b5d129f6885d994adaaa8edc40095bc123a5270ce69dec95382015926a56b0fff09475705ab6aabec79aa2b60f4f00da8206a958af2f5c70ba285523f521ff41177adc015f5129c01ef38f816ed20b51d9f1eb7277fa530a019c3caf992c521536313a4fc07dafe64cb84bee3c248b0767ed7328a6b618fd93ee39e3dd46f69b9f3900d4e3f0a957ca81b55743ecfec4930de23fb5ff4853895eb1e46814eea839769e5c5b1b818b32611679b539edd9a960e5024e41a2123c5c592481dfdcf38090b75e09160e4ceec81ca05eb01dc893d9fcb8fcb77eb5dd491a3139a509a368883602aeec13774970d7a1cb1d954672e75b65c3638d4560adb595ec39b3c369a0f0e7c834c14e4788fe02251778f884b9c3e34ca7b172bd0e028e2be792ec1373e2cbf2504b32bdf748d01bdd19dffbe831dacde9db35e4b51d1b20511539a20f5e1c2f6b75230060ceece59b4045d051244139e6a087ec62e0db884f8eeef4b5bb0ed5fe5a0a86b55eca828fcb9ee6ffce2303c830427602d32cd1e696d520c99321984f2b39f9b894c9d91c891438cf3362fe6ee58d8fa4829ddcfb5f917e89efad07821c9879bdc368f6f424854ce3b5e75b49accbc039d463b05bd9a52952b02f9efb75f98e0aff6f0bb68f2f30f79b8c1ee2e15856642e52e0ab8efae5c24ee1079945e486f7c6b24f4e567cb7fc5d8782368c2f6c9f19168c51c7d71aa12c47bfdff9263b66e5bf37beae160b2192ea2ef70ea6394922f27e5d3f5eee559104773a51a6ad7ea4bc5e240926312e9b4ad4721b828968fd31b6396ff85f9c08bef4bb419fc83b26ae9a89468fa391af11099d3e6b65f54bcaab526829e5a558714ebdff209fcbd112541d1b87c2aef964817cea116a21d57ff9e0f01afbbc9bb151c06056c15e8c419fbfbc928c29b9f2f62c10294fe36764e8716d6018976e88b74aba6550658cbe6c61cca82863d087478d45b2518ba6afadd1a339b6ae196c1366a41bf042a6b8797850e68b7fc719e287e2012988946607449d72504ae15578e8f95692013c1aad1396ce9ceb725d0fcd2850ec255454de6434ccd5905d78d1e119bfd3e8f0318e3d9abfc524ef67f5f14044d83364ba4772500c16b6fbf81b96d8f5b53bcf194e02071413bdbaf04ed6cd69df5bce275cea22bf3d32f49ece86bcf1ed5eae3bb8e9467d4c9260880b6230a4558f43267cecc8b8970f486ccee90d3c8be39b50f00f46bc4382c7087f9fd92ef2936abe75bcb5c12951c770515e0e5b1c50ae5b6c0955975f07f66ce9a72ee3621a6f0eb4636edb6d8368d31a0db683bd5add7dfd40e16466d9844e41f6042095d26437e14155c3a1e2c44daac1a02f087078b32a40d5511d3cd7d1895985ede84da2d26ba8a2caec8d22ba6111aacea0436423bd9298ede24aaf89f9444a5f359c75db66d4f0bcc1dedb57d35c0c1583432aa21d4d2fda92d8e263ac4b15e69ae55883d7425686a2f8708166693e16789a160941d774bdf37f3479bbfc76265b8fea7f73bf4c7704bf27f6b6d5a1791613883ba56942e8d3d75ea35d1b79b0891aa1e1649c864346c76a21d49653e50b24a4a2a9fbe61318a24da7a9736c6456bc64ba7403ba382764c04ef8e3dc3cad71075b3b36eb12b6e96601d6f18439556efe45232120cf2f9beb6f933cb15acb4bdac5db3a43268e375b0b9745f529bd44da9fa818e5c6594851dc0a2170d41e999a5b2fc182997c95184e5d41d4bc28f386206d3fccbda43a386b1c52763d4366268dc716a12d53ca5a3e9a0b8621863d06bb84edc190d176cbab1f811b7393db7af5b2db7078916673b13944bef8de2e56fae9c641ec6b1faaae28ade74983496a445aeffe5c1562a300a2b9ac45f62943f408301075de76f8023bcd9a2b6ff1257a3cc46a1caf40fd3647f02fd11a4d2a6519fa6e9385e56903a193a08a46d329c5c8748ecec335dad4f084fc96f711ae9ae152fbc4fa01bb6b34a5a05662d680269306092fa9c2a6ef83c87ac1b78670e235ef7035abffbc39609e1febb710f11751719b9e066050b4f3c2a77af374fbc97323b5a76dbfd4e0cd94866b0df9cd87f71e7401394eef798a11e86d50794a2ec8ae555bedd5801c1c655760ea2d35d98ee2dbef48a423a24ab7defae04e520b5faff1eb46f3e5b0b301e758d2fc81f16cb114dda7f3cc3f6470f612dac64a257c3423effbec2c80fe39154abb7c49f2f2eb491ff47c58e8be6a9c3e5fb1e41e719cf9d0f226acd1bd11abcf8069e776bacf470d704ab8a4ca4c727c6c1cd3a104411a8ba4a59cb595d8b1fc5b17483df8107cc7d6d3cebf3c0ec36ad9ca8a10415156e19af7ae2812ea7372c7fe39581755e497fe7d7697573dc60cd61c120e4cdf47dc6ef2e373b33b02d5a2af7bf2a6829c8973c9ba4d49dbd7e6097f25b83f0f4901f5ce67a838c7d3d7087d5d91c601e9fe36c53235446a25b855798eef6db09d54c14c090cfb2708082c77cb15ebc4a33de1e161ac9bb4342676b34c5e3132018920d83c88e533d3fd9b5dfc4fa9458fe1995edf9b593557c7f417ab0f81e186d21eba8fdbc7161d5bf45133b0a98c4f5dd7a5d7d3c5a1d61c6ae90197bc0fa38222c6631a52165cc7e2266e0ac6fd2263b3c4ca00724408ff1888cee029215a755bc65197c1e5307fe1ffc0faf6f939fd7f9a9124c8be2fb9f11c3968dddac41dc9b427fdc2311cae4ce754a7cb07349a5472336881030a8d1bea530865ee49096df6d7dda8dce6c5495e5481b6a1ce52fa0f5d51b3b87f3f9023310719a5777669267b18fb6768bb5d7059443181328732b410414d025456967e6f38eec223543bd529f39b68f3cfd742fcee19df650fa8e4a50ffd3ad03985e5b054516391f9a909e378f71925489e9b556715a415f8144454fcdc52c5b585f8aa29d2d04c432ee810ea46c6d3e3f1a6eacfa0c919bb68318100435386fffb796286afeef2846d948bd908f16aa77fec4201cdac21d67eb4c8ffe1f952330f4617d5f5b4962291ce8ca50c74bad45809c1ad6540ca4dbdcc810b2d4bf263fb28e7e93c6b1e4e68f5ffad79346756989043a96d0e665bfec6f76cab4e07733ac5ed5f97513a833687d71996d7b611569bc057b94d1e8c3cef9115c45c49326f4bb3d22d02e42bc85d1a98478cff1af643dd571c2046d8c87a4a92e87bf0cce81f3fab044b00350d3aee2fd4d0b3719b17bb2453e5f455ee5d1dc569ede6c2ac3a4f45d9f34f53a88d65124888a296ef3c7a1125ed711789c5c8046851d3e3bd444764a5cf14c21abbad66d93f82ee5035f5b2b98b5da6c96b9833b91248bcc9e0f81bb5ea0a6ae0a01a08df879d549bdecf7ed822483a6ec4fdafa885dc09b94fb395fa087650b38ac5d1f7fbcd02237b6e7a58db6926f2d289254e1fcc8a26dc079de358731247c4c5103bec6f5e3002771cd69f95902de49da0794730a5287f1335867227dcabc2b3ea539c214dc245122755e7a4e27a374923e46b7abe7fcb32b0630fbaaea1d1397161811122d76687d2fa833c3f38e220b526ba085fe71278b8baa3c751913cf9fb53d329b874d0f9fcce272ff8cdd71c1d011a8dd893bf5f3d049817e3d67b815064892514e3211098e0334e8807b703efa860db1468ff5b2438185682ab542abb5fa63f2b27cd1edcaae176b4c27da4062e57ead0d821bc186d45f76011dfe9bc84cd30b77f82a7fe44129bcc27344530a83a2434ae774adad79726fc06446e7acfe66c4b1d243ccf73fd1d8da36319ec5ed1bcf4e19283099c644508e5bf4c0accd263f1632c3471e45aa23f2ee081511f8b641bccc08df861abbbcddd1080b13691064a4320d79a01d21a6254c79cd2fcd2f7cbbd2943efb4db0e54317709fe01cb1db76fffeb79c692e86d8ec39576e3f2efb4864d9ff5151d4b66bf1ec887e1bc4b2efecab0fc29af8cd30a4ffd2f9746a13d42c33a34b2a1607265da95d49c730ec35e5e406a300ad78f095e3bbd38224147359efe43eed4d2b65f4c507032114b34da283c9da374e527d5942ecf72516b79109cfadb13d6b02aef6ea3197237aef941e7b0cbdc504bb192028c5bd66ffbb0e8970099b44ae5753c5da251bb2ed84c003eb6a77eab64b4fbd7aea6edf79c31eaf53ffdb6adbae4cc80a724fc473b498767d726b069e83521babbd45eb36878f824ba0b2c8ca58e2f74a6d896829de80471ae33e57622064f5cb3b82cb257abfd9c8761d69cedef98f1d79973a39cee69a5f93572607aebb8a1f3a9caaacf57f539150d08e06e102948ee87a5557e295878b796cfc884b4bdcf2e0d7310efbcc7d346fd31f8a3c19a73b0682040ab47ebe66dc0c644758dae476c6a96873ab0f5172fc58a65d04706416b58160d0bf1c60d6748790b07e8d038a922487d487c98e47cb0f76d7554587c75719ad78b8b2c09ff21e947bc7e7216edeceb744f3dc43b8e5b510a68a20d3598ec50b3b2a942db199d10ebc00b3d32910563b981448ab16fa896feb49d2e19dec4f4a5984b951945bbed81bdc856f58169662edb076555c87b0c6c2f6e917a6a4255fbc790443ce8fad7d6d91fde6da7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
