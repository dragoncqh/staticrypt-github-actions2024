<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84ea11aed939f3e0ff9b2e206762fbb15ab1e6769df39c9952ef50e5ce261d81773aa7beca855b878bb048c30968e949b314f5e189e1c15810bad59a005217e85821fba6774d04cae15ce4d87d2145724d84b94e95b01fea1618d46248fc31ae1d913f234ed52d06cf08cd8ea6bdb73f37904f55245fbb08dca19ff9559ae6aca5a3cb1206e06477a4223b339f0c8657811d72ddb8a9dca98852ef876ca35598f6be4cc640c03569f267eaf970ade6f04c5c184787fdd7e7b6e71bc95e5c9561d785b5a5a687c91974b2cf26b4f4fab2a92e14725f9c4c3655319b1e94231e4ff30ef3ba002a33d6a71bac032694a5687d3b30a3aa1b3a6ae6bae3b7c7227e04d6c7c60006d9997e749d51c2fd8447098c0b4f8974d1c7bcfb72c33c73df6028dab7efe2b597a0d0e982f069eb33153b5c4fb1ed8d7e827cafa72cc4eb396e50cddc46942c0bbfa10666c85cb3882668f124a7b8081d6924c3a5b1e78d42bd1df22e9427c2a50d8f62e8bf0d6d862b5919433781118e0b1dccb658289697f75b793e50cdb53846dd65ef91bcdbd6910e59e95e7b680812899e290450e6ff1f814d933254b7948cefac6780e889d9b9c546b56462254d431ec5bc053f2cfeedba020ddfa6bb78ab3059da5301e8529574eb255c2dc8c1a1d2b9a506abe31834391c8fb40d5495fe143d3e635729ab00eed28b9f04035c539a4a8486e587e54a2c89da8e37b6d71b47a6e162016ff6536f1e437838829b976781b9eaf881812972625ebd2df380b504906affafe5c9594ceb1cbdad4fef1e092b9c529ff5a62afacae31da796e5d3c88085313678090af5d9951e396ad2b45ceb41e43bf842e9afdefa9ef36c0a79300f379e83063898ee1570e5c4c0f00bb24249011f6dbd8e733e6e8a3299eb99299a29a6534274764f2ab84164d4aa73fd331cc6d59dc9e8000e73ccef020b76948e95c1ae70ee8f793bfdf699d91645907dd9de40332bfbbce323ce024aa3d948252ed5c2bee7d7af4ef86583d33fb7111d847c68e5da2509969cb9ee4f4dafbf9c5db384a5222f490a705ab0940d603ed3c4b6ae07d81fd1023d0a93988272fe21f045a2556031af0785c1c17235d9ac020e523308896cd16395ae1daa60358c8b4be0942280bce720bdc93e7f9b433e130b7ab3915523ff75fa3218a4e63ab3dd4e69e783b1bba23b64f6e2ac1f7373995d9a09e53ce7d0cbecaf738dab0caeda2ba182e420e992c8f31b6bb129cee0cfeae8c7d6ae8142cc2124bee476624f0aa009ac9fd3c5307f1748bd09ec862dc22db79cfbda332617f677d09437b7dbb5528e4eb9a5861ec07bdf4bb6dd58a33c0fa625a7078e81faf067ebcfe1b0976c3ebea93045860a297fafd5cd4a0c99680417fdeb8b5d345cad9f49e7c18ca090ea1d47e080bafddfc69ca113b7c03394289694327d20b22a9a8330568d3b0ba439774a5d1de6752762706f791b6e75a14d8536caeff6e17badacad16a7eadce9950efaa3c85175e608a141a509d62b3d6563571373ad5c23a7412995f450b3494d65618f5450fe6b8b7158ee571ddd3b1e77b3afffc4782177c985921619f74838f0fed22627b24518d412fdce673b42bbeaf2eab6c8c7c54243d2abb34354c9554113bbed7c1faefcee5ff09f7cfa139e70ff0d72a2957bee81664041b51e0c691b498a1a6f7d03f1d98937ca65803e592ae07d223967b2d32e85d43db44721c286e24bb9d0edab11bca830cd1e42199fc8998980578ff407eda8047ecbb3cbfb19a37f0c0d3579fe1e3c70afdae9bac042c53e441b5c62a808c12ddbe14e294b957d75e5d03b1366fe7f579dacac9cfb50b626c5d47d0fe9a0065ddd97019f8c32c52912b043f05d802aeeb5ae436f8923ff6ddf6aa2a9726692f33aac17e32423c19788240a43d9dea758afac744e4e8a080d0aca2098223fe2462d3b71799ec37c32f3f9c6ac67592eb5d696a8917d77d5e4eab48ba7aaf535dd2e76c449eab4a94f7af86c7c761e4ebd0ca6011ae2069716c8ac211ee934149b915a09ea1d1c2c667136f15d2446b8440f89bc26e05d349de32507861f0b5fcbac31725754f0c39e600fbb2ce3a6b319c5f5100f3a388ea4af64cfcc2b6145f22b27985be1b9dc095adc5da266122c2900bd8c89e6698f59f961b10eac23ee54cafc47d79fea068e211ab3c996600d0d21145a0dffe0ac0f62af0903bdbc8ae65bab9b3493f731f3a290f192e264b4ee54beec8967c0f96211ee3a20532a5396421c078291a008a68c1ff24b54b10727dd0ded5816259cf6a6721526ea58cf657b117cd78da56eb73e4b56478e810843a9199b54c89e0b43bfffbe1ccc62fdd6ed9a8dd112a9bb932d2adeb9f37bc780ebcf08ace3c91febdc2be2be50f81fffc86ad53eb7c9ef480153af91517acdf28a466a4b0f4c052014d6ff03782618eac3f2a4b008c264245d2dd6ec6892294f5125e95b36738dd4291f7fd6ff5db5e7e7b9d91f10e51dca0200bfcdac9c36bb57dffc731581bb3c46ed4a453572e279d3984f8e616b0e4ac1acae7e355582a558d355d5e9b7321a36a77ed43816e79fdc1c5f603f80e457a99706c77bc308e9395dedf53fde4b0b2f15241c17fadc9b475c4177ab3e4f02e4c1442191dd6d308162da337e9fcc66e0b73c6aab042f616a248ea2d2582ac3045aa31c8a4f63fbc50107778e6899b111d67e298ac26591c7e8e864e8c36b902505c857050ed1fb9b811b30d28ea2525c4c835cb0524469594aaca8bd4bb238ce7182e35eaf45287a6c41c857ef7fa21c596aa371aea799563275becffbdb0a8e5d0d5721892ef4042780425671f76054645b300b212ee8e604ba33868798d6d3f2bd943241d2a4392a006738219ab474e2db8d4cc5211bcccfee636a3f596abbab886526f8ffddcdc638b4d3c7a7b450f78dee339fe9e81a16d4b7490b4953e48e1d649a84b5d15e046d632f8017c59b73f3a9465ecb034d248c1d0ed43bb353f04d5a8aa47f60b135d9483e676f985f2b075eec8ab33640ddc7224dfd3b291e71ea4f3f131c3f652b12d839f6d31f13a9790ace9cd37aea2c88817e69e05513469f9867ad6ce16aa258693e1485df2c2695a4e51e4d2465f8f557240b72df8f7d3fc3b50502cf98f5770485beb1443dc9c964f4c3ad7893a7f474a73e710efc441cad23a1669ea9a469716cde9f6ac31e124f7692f82659239265cfaa9508574e170edb66eb3ce8a4de0c88d2b3f740ce388ad4572947f1c8b8419fe406e74f75527c853a2e0ab3ae98c6f2bd3fc9cc5191332f6a097994f860dd3b674644a6504b4fffacfcf1894121223f5fb8b9528279a163265c197ceb296ef63ac4f3ed6515c48f7c9bfa7c1c391d37f5a3873973a25278e711159b257cfe21d6cd4af7a91a5852936bd8ae307002c35e4fe38e2688d44de78c2a5fe82375f3e23f4e2394b238f6d5cbcdd9f412e6587a1be1dd3ca9aa857a1444f82ed215f55d879545c747c9fcc2069dab34a3435eb6699dacb451d0fc7502089643e8dcc7cf2b035b01e219ee507c9b5165313f788f2ec31e97a6f74b43240c07be349297355fd939d32cdc6db1f3961c05b84ba1576b9dbab8ab9ede611c0795a0184a8dee6f346327f736bbd703d7375042c9aa7242df2d0609efc25ab49fe2faac56671905546c43fc6efd5206b286d24d3f0ae24421f0c6036638dd1970b0f63248c07c86a4a4dc31fdc8e3af12214259ae6e70a10d04e1eb6863688ed819c2503f169ce7a9a1c8ac3b00cd95644a59199f2e5e184ee7050ad8f01c200c99ffc320afb1721ee2a1a1c3cf6a0beb952cf83774fd652cdb8a6f5d1eac066e8156d443bf46aaee95850db476526adb0654236b398f6b59829fe0d0153e81266afb49a5cd493e47c6ba42ca99bbf44fbb401b6efc10ee8c1bd4e037974b24feff2ddd7f137044fd8cf96929341f3079b79d78617937ba5bdbd209da17449b4926781e5fa19fa3837fa69f88f7c7c8b60a7df486fc1516b42ff1b08bb489c109260b1f1657eac48dbf3ff2f79d82c031ef0a3aa8866b0758f169dc759bbcfe3df26c70b343688e688be1641b42b9b50b981b5e493b09a5585802b41face623e510fd97b40e6f7301819e2bb3e92f87eb77ba774e29afe01477f56f0868e6fac0772f0c32fa9ca977c99b45ff20ef97450138f347f12182937a5a649ab013059e62e0ec43a16a9842f3c4eaf9753e372d5ca17f98d369a00ff598f9b74529a85c4d08fcd4b1c5ed248c49ad1fb2ec1ea4031ed7791e859ea06cba1ce1421e9c9b8f7b0e1d19515a78837b0f0086f430ffcb0cd2b983c2565788d120eeb0704cb767dbe71f14a7a96fda893b6c9d7bc6d1712bd20c8ece0d815112ad9b40ea980bb3db1d2a490b8c60e11ec8463fda9840e9bd5bf63e0430f9cfc0311e239210aa4155c7a77b83c26219c727c12a9260c7a6331338e53184fa6297f2f063cd34a8626b47da3d0411999d05fdab7baed6baf9586d2f94328ba200414e68ed9577cf7e361941b27cf1103a3d5707cfd36b4c89b3ca46b61054d0182ae6e977338faca025fac9518a209d9fa19d89fbcdf80a767a4b4b4663dfc1f6d1cf79cadf854fe782e7546d32afcd2af616b5049e6b11776473af1b00a27091c8cee5284f84dc7a5b509e39565d6428cdeecb99f0f9ac266884498475625fbabbdc66c93ad4661204685f5b72b6fd8cfb2724003b022083c561a1e8e8e9b2dfcafc187b7cf4115adabdab295cf92651a598a3c9cc73417783cc9e6f220a3b814c3779eed4af5e5b584ac1246673ae865faf70f4341cdebe36c7e1560d76cf9e7ea9027baa297d24a8235f60808f356578cd37dd77e298b259332ad9732e7beee7fed1573c2bc46dcbcdc295d8eaeeef6fe00eb1ed06e5ab5f7d4de58b7f4baa9568897e6c9ff5d9d248d872f31e242e74f12ac176fff897bfff7d9c6a6ec25485de681328c92deb2172d8a1e781a5aa91a36aa76642e6b4ab5ad58aaa468670e038e6d6cce9b96a23866ddf76a4192380a774cc812ecf5fda4a1110bf2633cbc305d91edf7c94d9cf16b3f042f53557377ff1d845d4690deaa67d6eb0a7af46579a5a62d80dce5fb4737e6554ba7ecdf95f6bb1ab2d8001aef09c9608ba192e18ab45c88c3b90c3195ebb34660333dd0d8cd44d66cbe7cd3ff374dd893edf7ea6d414a85ee6791ab4ca41511ec58327ccccab48a74623f3f88a27200a46aedd2648628e31ad0863e7894b12b745de65deebb30d31f8e6334df890bdd539d39650ded09bcf3bec84f1830c7e9e8c6b667f4438543269821289d2ef61e074f838e07cb006227dd16d95495ba206aeb5c262970a0044cac4bdd79b1c0b127c5fee270f05bf3e512138a2b4916436ecf47b23466b2e0924fc8bdc21f31d5e1d6a28e714c1f55402178ececa572aa7366db9b5b97576c7a34333e7b76c06b1da4ffea83c71927cef30c3758a2178e91e3fa989f63725a79201594f6690450e7ea0c99ec3b8c67d3921a77cb228298755fa628951d2c87a28ba4e7e12e48ff039051925eacc459ddd5f4899c9aa4f8fa4c891e29332d8f470718f1ca6ac19c7c82f2922cddc2f65864339a9708fc2ae1a27bb6a2a33e27e6b7936112297d04fff8f4cf3684f86e7c74d176ff1624c8f96f2ff18047ad27ccc09069b351c4fd2469e12547f505342c0196076d85d5d5dce6e5b5ea58479223dae08ecc71b60e8b030614735bc18c3d4d06113ab2708e0af5a0a83b78b8e6568a96653091b2e1ee05569ef30c060069644be967e7c450dadbf3ee0654a108c1005bea49edc62b9ac590b820531ee0dfb4102085c4d72d329b65bb8a82fe248a77842d0c1ab35c7296c97bf898b673ebfb6727eca4f42e7355801220a5e6bf0b867f6c771bd8d8e6e1e1f26da82ee476940579dd36e9f7a0b3ade47ef555255bd90f626866f50da33135c8b4c20642002f60329de14e9a24094a59af539e9f27fccc7a1cb7836e116373ebc56488011a02944041876930e885eb1a2161d491a06c0845d23ae57fff32dde0b7c20af08a6b64d8979dc97df84aa828280cff13cba55429af71df60d3d50a540cd41477ffd23e94abaf3ef86d6f18dfaa3a02319003f7fd52894afa85e4bd510af038822692e5d70541d2a50d717567a391d55f736877ef2ede96afeb8d485cb77c9945e63fcceb271c20f7b0d3b89c04383d9094539d4818f386f896ff13f150cde3f85d7325bd0e5f97e675df47a8f04aa21c33d41bab05ac7f640ab7277ad2544f4eb4615d41afedf5851eca12807fdab575c3cac4a76e5eb27709b7e54f1a2a582377891b41fe53bfe008d891d2845d37fe353e8cf7dd2e9cb3c793b7af636cd58db3824add07c7e2c3b87c62a669d2e37a4750cb61871169452263c028dd243c69b76a1bded852a953063a5f9231e452a40a32227e4f983e9030c0fc4f18cbedf5d97fdd86f868041d1f15f2c429aac565b691df8a2a49e6318a38dabd842a2659db8a9862ea61f5794cb14f829a38551a69427fb8b10d1a9c971ea5542f5da6bdf29c634aba28010e1d836ef0aaf0ecd327a13549084c62f0e06d35e249bbae8ea8b2c2d1ce0ee1a79c82282b5b1658d51bcd63ce48a64d662d57bd382d8998b3bbea043f7e9bc6b4e93636f00c499a2ab840d86a10e244acdfa69998e797b4d4b1e355c75f5ff2c73e5bd2cb4db9a758beba4304b5d1e5607addf38832a4c8115c1f5b31a5bee5f4efee01836666c2fc73137b18c352f629377fa741b7cace758e5e07d440909213fa1735a2f9dd5cab0100104cb7fa600127c7d2af2b4ceeb8c056883dca97571228e159f86bae9cf0cd402700f74a124d977a37d954f8b6ec1ad73389b9900ffc4cbf5d1f40afe235529727affd859f0501b0c181805cf88d8cb9de016f510ed826493cb5129d9735a71f7ab53c9f98f2756a32a9d21cb71a24248b0d0c44cea1496922535ddb629deadbbdc4d979ba67402885910c3bb5e0a1fa0bce6916d28a3f940835e243890cfe8c03a16b3841a5ff4173ecaaecee58fad6e7bbb5256769dc9c0cb1b7c877b53c6883db82da84c2ace8d60d2913e6dfa59168a93f4e2bc1de4cc6099f643787b230c9ea73fd44b8c94c3ba2156532fc311fbc76bfb9c1bae32fe3309d37716d175303dc9d228384896cf76a35ba51aa2c0b26d91b42d45818c74fe68824f820e0e011e2668964b85f2fe24615bedea1f772745a5efb14def008442571153350715f9f2c86e20c754ddefe12d8fa5e1593be34b8248df59cfe26c6a6127d90b55d08b23aa6bf90e152331188684d8bc314da312ce081ff59d1c43093f4393bd5cf17caa069e9fd0f0112c0c31e914bcf20a9de685d2b73669dd76a3051e3d0a3c43e5c31a37070eee2fbdf5bcf2e70915f0dac92746f0247a358e6b645594044404f418f5cb0af52875455cd24afb45e41f14c9b6cac185b1acda88cb16b0e1bf2921611730c47c573982945e7d3c449e9599df213775ced8eb6514080d699d45594171a490ad7ae0ecee12804eae30604aa782f6fc3d2c45e4ad453a44b8ded51d7be408cbd29ad7ba8738f94afb584183c000b1ede87b6a614478ee158981d07611c971c1e0f4d647b9818e74bda721ec1e09ff94ece8d0e605dc4757f933fe0646737548044fb058d36667dc7a0efb331695e8d34297d19e5d972ca8f8ef8a21b88bd19777acc12029cebe2019e44070f7945b1f61a32988252b12d2a8afbd45019fd5f0b8ce8185f1f7894ee02fffa624c87401d340afac88747f10da9dccc76df2e60d387dfefb81b01b63a9bf356146bdaf2f4881bfa143eaa7dedb04ca4cf24b5ca61bbf79f62c02875ceed546622420dcda58ccbb2ee9b975aad9346162b589c13d18bf1f061dd2f7999abb18214096c430264800836ca7def6f26f14170343f554b5a68e1bbeb87b701f352b19f0d7eceeaf604bca015f79fbb6a2c6257ca901b4299b0687db0e8bd4eb58a7a4b07d71c01cd15ed4eab1f4bed75bb77435838bea025dfead7c73ff31ea828f0cda06be2646777a1730d3a6a11fade88d8ef1ab470058ebe53159fc77c5e68e7984f4fce132b616841a5d0d763caf0e923339f7c11faea4ac497232a303f86db2991ff0550460b6bdba7a5e0164f981e1148207030f3e45b55778f2c2a57a7510c72b06c802befce931f41b227a7c038117885123f09982244e9bca6cec22eeeb971db5953caf90e9c0c563ff15a1fd279615ff0e0d23bd9d0a8794d9cbe2ea36f5219eed3b17a2aab27c5479c9e33b072c850937d7e88364f245822f16fa2a3ff4e051791f93dd84706ed8cc75294cc97bdee5aeb2b088ea12ec2d5de8d84716b42ce326a6be1ba6eb3f999c69351fee485f753c38a116180edc558f3d1101332ac0494f66c736fb093f38b83d17a4f83c2783e114337c809665e6422e3bc44266a2893903b24af5653b125ef3fe4314efe0f53a5c61c629433c40031d2e48cf1431a81a91e4d20fdb4e96ad35070ae806af7215e71c6fc2adba2a42043be0301b22ef16dfbb4ebba7790404928d71fcfb187483dc8b3125f783be10f5f52b17e67a98c1d7a19f31a045e1571684e7f119aae9d5ac9fa44a0583f8f5a258f7fd6f3819a0df963d78a79999b30c5bbc4bd1d1fcfee3a1e665bc5dd204bb4c464675d7f6106520afbf63bf63bc59bb6219ab1d8073c9aab50cd38d31f8ba64df89885a7312d36497df2fe603b0fbad454c687969f33f35691c48f359ea9deea2327371f4f4daff75d37fa307db970fd4b7b7f0bd7401f6ae3c0845aa28db4169ec7c401978863aaa88e58fd84bd33b66baf6fcb91db9fb90202e06a1e82a2b62b3af18632d0282cf9ed1daf7e753b856d308356cd95b7c627c9f47b915154a6b3b628ddd9160d82cac7cb0f8551dd38119ce4edf0539dc7d1397c54fa5188e4a5a7ecdd3ef2611d35c37f1c46d8160d6250b2bd7090f15e9d4cbddc2d0f8b2c2f39bb6bdd5060993c6faea9a2a8d5024a59109c6abdaa7d6177685d65942c0b0e827f46d1f34bb0f599d1113c85d04f1533d15697405305dc5fcc823279a7faf0be2cdf4e8f75a711f2a2634787aa0043d0cad8096e698ca1547e69c157f64ee846e4ebda61eb1028ace0f34bdb32f696eb0f3ec83dc709e3bcd280c2206b3c15bf93331b7fc5f9f236559ce477d165cbd3832c20dd794f548dded2ced25063ee172da8d1a729e7f39562d3ba33fb28a6ec4eaf8c5a07346f1abccd77840f85725339233328602d9bffc23c0b92dc21262ca62b627b07afab19ef2daf320571772c72991d1940259c9acf16c4d8597c5f2b7883e00a0209b817b141d50b4b7df0dec97db08590c6d240501cd02b23f3c8e12f5324a7a5eb63fd662551a303ef555242a18240c87bbdf4ad4105f7a9d179633becfe1f1a171894070f608e46553f9f653cacc176023f024158b29eeea4a8a5daa48da54434721b5583146b3879c34852b72140af3d202339823dd7f7bc25ff823c485598acd71653bcef47609697b576c4eda2625d2480ae54e4d0ae5f4869bd5c97e0e4dfe65e6236d6408fbf61243c2e425864c2b37fe17651f7f4985096bb0ee8d7ee1a701ab59c3288d34a10389f41d7768dd75b65e8208e72c86985229d20235564a9208457d516ba9a15172439786bbd4d3faa91747d4019d44ef39d2f8901472fcedfd1ac5c9834343187af60cbbc8ec1c58f245c63f4bd8c4b70a0b7df2f45cfcc08d2518a8621c67a2ec44b9988fda5244d7b8cb4648e7b5bbd257ad573ea5f9a4562268a0f557c0979bd145556b1a68615ae8e1d4daf9a37ce6724f925643e94a9cabd5003c57b6b15f93c7645fd3010c9cdb7de211eeb0fab3da9d496ba28c72e62aa42be6d51fc95c88e1375ca9c8933d37272791330dafc206adf4e330577de9f892fd3ae0028bfc37e8089bba7d07b0ae785566ec3d4f7bcb1ce2b3a6812c4d767b3fffead94c30bffaf8a238a0fb888ac0454820b605adb41d93025a72eb1afa608b7c3ea2362b0743091528222a5172cabfc434228d05bd2d228265d797061b0a7076df2e3f7dc1e8013458cedc9f888f762acd24c4c95385fbad7ec05896f2ccd61664725f7a7b25b268a544bb34af31c1aa849d1ae1be26d1c8ce6a5e7fe2761571ca1bbc47b5da0daa5a0b968e50d0419433bf7ea9c6f95e49bef617ae5812b7bfd1ec74ea21e4e9defeb7e2852acbf0ecbcec886f6fa8b30ae0bc0f56ba7691d0676cb50a548fb09dc5cdd4b6a001afbbb8b085dc4e324d09dc5277219c1f0da8f8524bc5fd0c01ca0156e09fa834b64be1400a4a19da0def26876a2818b288468581ce32beda7269bc7ba5c36fd262eb2e53db3ff694b7ed37cfdb8afbd4ba63b33bba2ce21a88b70a8849fc0347b8f53f77a58351830e1882c891d9b49c98858b73e4616ce5ff950f95e9eaaaf072c58001419066562997da06bbc2b9e84b39740b4bdb8f85c4111854c39f156dbaa54a0b988c1c8dec66917f5396d9dfaf3a071514c9c214ae78840ca354719535c46492847678a4f379fde3f03ce0192d7c1e27c2db301b63094dc48b339b47246a9010ea765d9b308859a6bbe8fd9ebe3bd9233a49733d97b36e39aa86f6ce5204fc9c9970954352a65c899e4ff30b59442225a55f0be44c21d1da108ea8eebfe7389ccb35d5fe1fb018dbe3d4fe7ed570dec0064d3a0b482efc8f8f299d3da9ebae89d018dc11a42d5c8c8fd8c5ab556ac1864f5c4229b3d6f7ba7d7bc3549fe22a59b770c21e1c2b95a2f6b2dee5fef7ac4d97a95671d1e4999146296f4bd23809b303c6744d59bb281304d19ee36e50bad58614caadcf006559c1b7b4e7c565925292088b67a1b6bcd900357907fb31c85e1ba89307480fc31587997f805803439cb47b333ba19e271150397772c3b302fbc24a648cdb4e016808efc94c79496206ce38ab65499a4a0bdec63d770f07539cba7d3572d9ecfe3ba66e68bb9a3d10b5b74f6477df6a6f85ed9d6051aad81441693307d185125028a1628d202822634d8cacf93250a00e0c276609401cc62a4ab92b7bc27973643f6b6b70c85f1583191526ad3fc2846fbc432e14ff945927492d6ee1c7388d4d70eff2b941233379a82b79f90a355ee1024f715f15856d7c9e50e615510e20cf544aecdac79938c48de1c28ee79b024ddc3ae9e59884f4b662c6212a0c3abe771bbc16fa68eaeb5b1a96967ab24ac4b1069c607d0871a2bc0193ff48aca2db5775ce7b5220b5cbb871154e20557212043adee4a5689be3712e3a1701451e8354bab129ce646f27bd09ed5fad538f7581a157a3bda678b10bafd71b40909ba4b9ab736d5484f8bd5def29e22ce5807bb4570b74a29378a083f67eb56eab9614791712aeb49c8bd3891873fdd75513d8e2020aa6d17ce0a0729cf211121d3e3d4fb498672ba0b9a191703a5c78c1b6b41be69dfe7c63ad55a90bb18a636835009ef86dfcac288e38fe4eda396cd7a2db5058528a78c1e861ffa951a2a9193232638db3109d01318e361f6a2fab9dec837f7e6f173a66c898e32e0d8241419ee0925e42f687d17cbd91a8c326957f59138af11da6b086ed27e802311ea020ede8d50b6df8ca75f8a72d79851ee9a6593c7dbf5b18d5093b6be2d05ddedda3825e5b096a68adf925da707b74c0443c1bd923a44bde33ce1124be2b05cdd33288eae9930d4d903c4b20d2e56f2bfc4e946baea8a70a81c647bcb4c998d50dbaf1ce7786134560228ef8c55840bc32fec360932a24175cdcad8b696e2fa1019143e8b99adc739397b0b8dbd7cc21896237b205848c0ebbe8f983d6b3ae60823fc5ed62316d07654e757768a7b710fab91ea3df24876415bc5690b4caa723912c71d93d44eb413091a8d1b94b665b082399e270b2c3a93726e93cbefd27536318cef1919dbb17d1e950fe3a6c2e582096e07358bbadba17ea1cbd4cedab48cad03b8d6e22e33aa1770c2de719bb379c9c0c9769abfc5f4310550b5b371ead896c598a93a9a9e659eec3c3ca942db6ebe5d48e07ac065ebbdff9ccbdd34ca901b09106ad81bca99057833e7ae9dca096ab57ecd026c456e86233b5dd1a708099a184e78f1d354abf49ec576b8ed438e4535073611ab25418bf1d2733a27bfc0bb336906b2b0f1df6a4b60851ac7db83f75dafb9eb228767df015af0bc8b84addacc3efdfd3d43bf877fb7868d0ba4893f85a9786a9e0e2e5e67d0a9138a1c1f22d4db9db19f6ca1a37dd47d272c90438f69ffedc4221d669630dd572c4b025d4af07135184d4a8f3457d6135ca7d8db1539b81a036e045cac80ed275c1864f60d4e69322900df30355f3a07c86b9ee99db9fee66686670850980f9bd7832df43867b33d46da3cc7aad75f4955790a44c1c380d43ba6a490216c8cac2aa9b89ed6abf05ba6d6d2897d229d216a96af866ce046ffa31f2aa78042f1738564ebc2151b7e41be2e1bd7a10ca99d212312147ea1d8803cbe423228e2b273fcde31ac6642970b839bfd9be519d9d63e896756ad3c578aaf3734689134caa391bf6097c08a24d08e9decd079b6a1ca61505b420fcc76c0843e7b416185fa1e77e2e036b519b639de913c3bfe389cbacc7f28c24764840924cf0f8093186b3566d22d8da4b215074258b0616e6d2f4e8f2936ec141650ef3934c810c955239fede348640ca71020d1bd08365c3226f66d841f086acd2f20073fe9669458bc4fda9b3b074690c17b7f1ad9cb681e73f5e1db76f83b2b71c4ceab458755eb5840ac447843d6f3014452108b25018fb4043104be0b58ccea0e85076f63d44958c64d4aa4e7a25ceffff5ca487b7bc38b079eaae737208df64e0394f778729b3144ee7239b9a50c6e6d3c39e5b761312c3a5d0d572c36d2a21f89f6a141ec83750b96597581e8694dc17fc1197c1386274014f00b6244c1a4cf73c9631011ec5be21c7d2de3e57409d6690ecf602c4102378e793bb354c56f473560cf7702430bad36584e5d07d1955f0363f14574c47b740944a84baae30612542ac4922f43ce2c6dde3115bc9f4a825de7d6d1bec97e7d115e956d5e1ad93dcfaaf0b53483f45070359dd5a7886b1e20722a601f99c8af4554249dfb84824f1ce7307fd97ff05cf867600bca72f3e4e5d47f1fca1b1e41bc39400b6ba2a15e1d7a35143f72aa2aaf8b1d22af1b3465fcff99bfd42ae9ef152e0c270e411eb4466d44bf1b170eb14ab480f493fddd378de4ddfbcb96c8341ddb192777bd24d5e7ae72d0e4b7c17318f6ab09398b6be4d0041e7109432b7cfe442d130ec84a72a6db98b385d6d8eff918e2457308fb480832497fce0ad1db79b4999503a925b273b72d6c9c42b05752f62b9866f85a311ededc29ae36b5d60b1ef19203cbfd58d6f005d3959808a69ffb380c57f42a6d3d67450060e57e87ac6dc8c7618d2e02243772140557e674702628bdb02a57f40da3ef6fe2514a2ec9c033458defea3de2f95db32ff9a655a0cdb7aff3bb52aa06e84ca97657c8953089dde1231f04ff50a0539248c8f33e04a2f5ccdedccd0511f0a788b20f75c83d72f013e485eef6de2135e57a2e70127f02702dcfc3d501307713a632d30c69bee65f69280bf6b8612ebc4a6f2cb6acd172f55b3f1aefc9f369d839a44fd1bf4a481337bb98981a7264c528b70a4fb91c724560dacd69a9317087ebee2d6ff8daddfd0e6ec4dbb6a96e05ead1e24b6ea17ad97570380f5e17fc8cf0b016d25dd86406d1e95a391423d4fb006272458cc6cc69cfba2b804c874a92ff9bfb0a637cfaabf0aaed0e7737760f8e94e961de90ea1f0d3f1f0d3a473da46c95799018043257a17699063ece2d0e317d1ccacd8a6be7d24234f217b269528688561551090022339135231db39204ef8ce4e523da6f1b4cf9ca2b888b1c03679aaf83cb5feaf1a4963a81f17c218fd7b24308fc8e73048e849775455d389c4e08d6993f3ca74ce4a66fe962bf310d5d78ef48a3db389b26896fa56823c7d9871643f294a50e6e3bbfb876fe74b450c0cb7687b0df2fa7d7680a5cefc945af7436724441e58463162edb5e80b5d804079b39d7046d56662ac3f6f753b5fc19d7b3e59fb579c757de621e2a89e2e12a64cb36cafc62ca9ec2e5e9f7c105a99edfe17ec4de792690005acf0c9e16f0956d090d572a823a0543d7c6a4213605a7f0017bbee8e416dbfa3019d8cb383c0db04019e56005febeb4fcfef488558d37712c7c032d05ede5910b0353d90a6af2f079834450c67fe5fca5340c448a1632f1a03785cc40929fa2165b15893fbb9cb9406d316fc1ad23e295472df442c42ade201260038c38b648c14a812cbe09300385d0b4883fdf03da8f6e92730053c14e441af70272ed5fd585e49eadd5e4b176e5216d79bbac913813511b1fbf69fbdac56c6be18db0946bca16c4e77ebf0e74836864b97b273e30897c8b208ab43ba03507c9ecbc37b63b731e783888aeb3ad2e523c69e1bd960146f75b5993f6d9b10a398ded7fc96f723bfa895992fd4c0b538479fd84a057b3038b694161c7ab5e0d57d0cd1d32fbbb34ec9e71d5e55cd860bda90","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
