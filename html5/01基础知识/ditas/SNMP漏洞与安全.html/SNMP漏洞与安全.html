<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"432a65e7e0b615e201f3d1839f1915413e50b753a81fb79dfdb8f11294ca20adde881094193806c3fef0ebf0348d463fd2ab0b965f9f887de9e37bb42b122dd5263cae5f3765f53a388a7b754a206a3c8c173fccc9ad3d1191147a76bdce24880ba9d61683e512214edb55ba61ac62c28f39d17b841dcdf9c7f04f40aa454bb8a18762a127cf3c8bb9b77fd80c410f1f74c366d336c24420728021965a8bff918d41c17b1164b4c87b4580bdb5210ed3334f5b78d9995be63ab884ea98a72db49ddae698b59897e491b4b314f5039a49d2bd40cc6c13c43c762eaeb91cbbaf22fcecbfbf757f5244571fcd8619b4d81f05da35d39fe0c46cc255c74136cf197f4f0c0d56059ca114140e5f3b095aed174cebc88a5ff11b4fbd8dce240bb2c2bb01bc3bbd9e6f0a479925b570d0d81513f75fabb5e29feb14086f3fee6f932798d61fce73d66e27b430afa994785407fd697e104cf05c92b2221a6dbe01b6ae812a2675e8cb5ca5f4cb0114f3a678d8741aa9170801d6650a0766836a090379f508a58cda6593457add2a0c70d229fb60eb1b7c7c7336f70ba90fc286b1caa7cff439280b79528150c04bc4fe7c212dfb66e747fe0077c90e9649c7a13ebbc71612d95181c0615ef48a8ce171b52cb7c53673d0a48011e7bd479c66a10a6f67f61d3f306a026eb6f9c0a9b3332153dedc1cb73834ae0ad4b3f717a4bdb7b2c1a31aee3693392cc67e5f0fd9651033653f78c2cf87e0ce77cc14798c4332dae58c4e4c0d0dacafbf77d0a55bce5909762b5819527b2b43adcc5f035757657e8af8bb3d94db3172233bbf8803bf30a44d6c290c8481fff8edb7d954c7c7d08cc473977c51f1a1e84d41608eeb97968d65aa0866982a0b6e862ae3ee6172302a143766ed793a2860c9e2e6a4dafe8628e5f11919a0dc4b57d32bf0974739aed9e70158bea324bf228a41c183d8c3e1dabd6a46c241d0194a91c09994e28ce7b0e8dee3e79b6ba93f326feadd41cc2b5d1314945f22c4325657cee6763a264102e3a199550f077eb65fd4197e5f62ac947259c84d94c314dc95eb95bc60b21ed2cb12dbdb7d02b304dd241540f7a04404f026ae855c5a44dd38687d875cc7fed3fd3e4b691a68487f1bb77988804c350c5dd3a6a1ab0770a45fbcd018629fa548d41f7a1eaabdef8fce00b7c0c069b092d15e19d4da574f9cdfadf551d71dd0c8f21abf4173ab09c5a61d107a2b81d505b95a29d3dbe514dd1ce22dbfe38f8d258811d1e271730da395eaf112411c0b5950fa26b26485fdb58806d3572c72db56bdf16611d484cd44ef081fa8d194c20c5b77aa473dc0127d919b1e1450dc9333335335508dd1fa0af47ae11469d44eddf8f67be76c5a9469fe0bfd16b467f20ff25f5fd6851fbe42a348c6190e91597cca84a2f41acde9ae927c31cb7495da2b52424f1cc7e62f1cb5821597fe212315ae55ebf471b16dd63ff848c9c626cc1bd07775cc91ce32ebe5829752c37ad6c2dc27f8684520ed5f2cad147678859742374e4ef12d49ee46c2d92e91a0954a0807e3a678a1515be748d8b2edf40b871eb1a75df86f8037996ff147b836072286d2075a222ba7ec009be7f2e72a232022d0699590e0d28e6983e8b3b6089dcfa2c31d2a46b293523785e3fa46ebc886e069dc7f4b686a37b7de60072f105c8ded5bfb832fcf4b567f11058c3498731453cf3aade097d1e049e7941f90a44a843831fe759cff3d99bb6e066653b925abe70be35401514d2902182f221a9987f750268f89bc5cb829fbfcbc228bae303ec0ab517c74d43192125bc4035666abacae9abc3acd8dd6b322344097f00c36dd078fe21d23e0a8e7a7d3d80d3cdaaff8f81c153f9471fdfd4c3f1c9f720b8fbff4c90e2150cc617129f67105a9428f6818a32c0334bb296120242be4661ce7bfabc5d6c73a736d96f70fed0adc9e8123d0b052eaab1f42b71815b5cb1ebffecb8193ca24c833eb5d2b74044bf31f9829a7b7f0b87b9a5ccfd24797084d145d8477cad22b3bd0b4573e0c29c0e3b3e64ba2d42c23f1493a2670997ef60cd698f7435d77121a385df3deda001d6cb1484eadb7b785f9e498b665e943958f96f6f6aea7ad5680aa2a2446c3f806b4baf2ac6520a00ac80d90fa3518e29086fb22905b1d457fd8caf1f51633239260e41d9f9b8defef0c6e20143337ed02d947939e685fb8d4cab98ce28d07ec8d5c011bffda477f540eeccf1c41f221b3f566f8d7b1a24007e13a08c4391f0be183f1de2bd18144a3c047fcbb882ff5ab8aae7b2fe8c207cef165161bab942a91bb82382edbf01662ffb1bdc08ba66de6275ddb5bf403afbc7b74c00dc68ad1cb3f09dbf10b1ee0098d0fefaa78f6b77f50a5f66879eda1332103bee265c2ce9696df7af490f3aa22499cef5367286d39dd7e231c5b51a394162db37d1ee9ba8d29da8953afd37e557770aaddb4cf98fdf35b130324dc5c450ce8848da03e09014e371aaa6f9dc70fae685c11faf05f2b5cfdc911fd4da513165e9f3633453b9615fd42ae75c01a9bd1bea9ae38c810a304798d02f3122f984300d56d2dc54012e43ec8386b9ec7e40a41d7f2be7fbd4d330829807237a4beead2a1dfb2951306822d467b90aaa62c4e724f33c6b0727bc96908233a7b32a19655b27139992c476ee8b07fb99639ec40cec540827e6b615671f89602ff21cc07cd3dc8dbd6a9f01620a8126bbad6f24ef371a9691d25eceeedcbbacb573004ce54482c673271730b36c05238274a86e9754a4f56dcd3cb7ed35432f69018e56f408718b8045a7ed154c2b543a790eca86d5a13e66808ac556c32d65dfe105970cf9812e4411c088a7c9c62f6d5a02c62e1ef8cd7f4af0d96120c5301605df07ba59eba4cb418c3bd385bfe2a79375ffcb727d86572bb4ad677c0f0c90f69f2a8d154932c27b6f083d84657fee4c77329591edb7d9319c951c7223b47b57cbf0fb9cfeab622aefd4e78830720d409d1495b26b450c9ac6bd40ee0599378c60c3d96244b69a07aaf6f2b84aa2009bc03e6cb1ac8604614e6172d672758e0ee83aafa06dbc7e4b6865d47706aa599191911e359238ce4b677a19f8f2291c1300cf5a2e02a0cbe0bd1f6253e6e761b233bb175998c80d98c9d99fe5db52eedb35783e4f99092642f1a50075913d5638775128e6cbd0dcfac2df25a4445c8a5216dad7c0df2a189f304936dbd17c30ee725c8e0483e5c672148852f1b50779d1a9f9fb89791b8c9790028fa966c3b33706e1e7e856da041ec065443cb153843f438afee2dccabe7a9b3bbde77ef31a42dcfc8fdd673cc22308e80f928ad5a8506b53d0737c4edd1e30eb62f0e2f927a2e6d9a15c472c7471c3cac9ff354d03efd38e8661dab0ae0c50974549c9b8a0fe23ac4ab33ad3baa263e2c4a677244f85e18c59f652b023271c8eac66cddb6e3a6768453a2d6683a81d85b2dcc5023d3e94027e08991d3a70fc21b6bbe35967a23dbdb29a719d6750b3f2e04bc5e397041973eee96bbc7aaef8cbf61ec05120b6e114ed52b05b9ddf385f4842ab56bcfd08df3286902d3d9fc2f797b51e31a3af00ace5dbe13cc3b69553f5190c4c7a40dd5bcbf230ba8a37c4fa5ba2d4bdd8991f5e17f9aa51477e0f3219538b2a8e8941f20c4d41b8c43903aead1848c7fd25c104cdc158f7493b86a29edd84a158988fd827cd1963247071c1cefe8cab04e46461dae66e4eafdbc1936049a778168bdf7bf7a02812040d7c68e072061339688e4bc228f1b90fef7a47159b1803107e9be640b80ae7bd910898772737491962b994e74e3e488697d44b6b0a937b8880f15c23eba690dd298c6f52426cdae173b03d4a3f2400eaa2c673952346474ebc4e7e6208a4f45c0b7eb273b1b9eb756d45bc380b275aaee512035cf4509d2960c49de90f556dc53b16caf88338e75da1c2be79076444a9b6313d4b03e450f26be2134df9abc71fea48490474c48a0b38d7bc04e54240493c8f05afe1144f6451184433de3206812aa412861256120d9375a0298c0313619ded90e42f15e5fea29c3d12c395816ec1a3c692df6854b4691353e285aa71c13c1acfa37aea38ac5908d6c5358f096cd3087c99504edc489cdb4a542457911d662105c8d5b456441402e365e15544de1c4da6d5feb4e807570a083c5efe4da401d09c17b6a04335f022be25dd9f470e4c9fcfaa6779978d58a998eae78f0c8002cc8b58729a878e15bf9861361ca4ae91e36fe048372f52125823644157cba24b5e2722aaeacab9a26b94baf720bd454fbabd159362194ff3be26c43961f3a6416c1f7f13fea3de27974de7c98034d51e03b93b4ba383ee9974acf998402f29aa72b5bc0f3449d9d275c11df6cfb36a8ffe53ef1e9d426e28b8c8b49bb67cd8f1d265c76820856ffd878b4e51c90c7c01daab7f41da7cd895f718c37ddf71a7bddf09f9ebbe55fffdd555aeb893a049213dadb6903f0974cb083af1c95e3a68bd25c8d59f82e29eee9f7c73e24421ab8790bddf7f00c43b72940256627129df83c699c414fa85caae01d7fed8320e7f77a99c57ea2a62a30badc20b286644df5f6a78b1019e967390d082af43e7f8b3a6cdbc22d9a617f23e23e30f28ae4482e9ed5df65aca1de7c43ee5fd8e3de53bfde442da352a89b0f0fdc875ab9d4bab5a6f68b4822de74ced5623de0f9d891a6365b008baf50ec146bd95806eacaeb8e9b54b5ccfcce5822e32e0af5a18e8d23b2e4a0fadec87de0d20549b41f598dc9c88537968c7829602814beb1f7b325719de6420cf5c61a5b673fdf50567003aebc93e08612a27f2af788876346ee1d2ea0b5d6e5dc309fd45da7426f6ad194b7f65b71e413b7f509baa420ca3f10ebe7f53ac79300cbb054805d9ff826586310ffcde2e83a9945cda1be417a0e85f2828b6e36bba4af60116aafd901af1229b74969378e96cc05d61a2a1f4ab4a0c94e526ee6088fb6190e66e8e44adb5e013bb5ea48be8f3a043c830f791270fc1e7a6353b8edaaf4db65efd35a59ac32c019ce4a606696d47bcaad92a4e51ae719bced0bc720ee2d0a50fc6e19b93ebcf6a3a8b5bcff5da42d6cb71c4b729e14f0ea6e0a5fb00bf7303419e86efe0f330586453084b0f2cf1ce86b426f1d68a76364f7cc141b12e265cc003386ccf12916b4691f8f76b71388914d37791601bebb493c0ad7c9fa537525f055412f0897c25f3cf35451d05f6168aa4be39f8b1bc0d71024ebd21e334d280a87315e9a815defde8830840f5ad237af063247ca0f77ab8db9fede4f597f35d48e73c9a70c32c686143dbfbbeee8e5e35b31e5423d3a72bd767c3f13dd78fea40c80dfe066fed2ba9a50116c33882c2a62f69f213aa1ab027d8e36ecb9fd91c0d9fffc98de1a616fcb42ebb89d0e2b2ec686a036787038616453d7ed3b62a9c8f2e22613d57abd1d8513d1249ec51b6daa948a0db2f50b9e3549cf95296b41bb07401cfca6697012aace57db38da30d8511af9617931bb6d7b0f63bd8f0e8dcd7acfda04dccc4bd83d0f97c4b28f7097f551e9238c9db41bb29d5eee156ebc8800b03d31cef90865b9aaa82569f9ac86162df7483c524f5ceab50773748daeeeda2ba9f3f1d9e709af0c22772f88bf3ba8648c30c6fe97f935e68c8ea706fef29a50b8cc274a1539529c0d967d2741c151ceb9deef9196e421e79bb63aaf6db9b204678b0ffcd32c02aa87ddcc009d2573c2d0d310e19b36cecfcffef63f6081c5b47230492b36306dce939ee64fe0e40d20727bb3516b555c55bce9cbe519bbd1e74270694c0a6f150955cda0bc7eb6dea27c6ec168498fd3ff66aa6c600bdb984f3eb8c7e354b669ed93d02a1080d21480afcea8dd6fced522050f68e293defe672a02d96ddc645a4ecb12423495f55c53071d1fec06860dc33aa86e7080ed8c6d77404114702bdc9f1a1c685002fe8ff5c04d41a7c063cd1adfd6cffe7df158209a5fa4206ad091d2bbafb8cb3e6e23ad43c1d22aee091bc4acc3069100a030f27fdd314d191930b509513ca9a7974bac4633070b500717cdb8479ae19f6ce48eccfba3e3363e4924a917ede366a29c98be0fc45403bdfec26b3354500b0b53014594f82e01469ed5f8f784bc98023d5f50c8bf74622870355609f6704ba2e4642a621f88cf13fd91b793295db6067cf2c2e2d20c7f390052082519dabf55b97b99e71c84bca647db1e3aed5156c904650f2156223ac0ca87b90596f450c9edee877ad4852048d6fd984b5d45470ac6220833841c5f624b3c32f6a860a6d11dc6d9dee77159e6b3e486927219f7d897e57251b1afdca6ce2de4be651872b8d63b152a112b578ce91f88e61105fd1ba10fbbf456b44772dc45d7703fd09138d9825a7ab507249f565c334a1e23d97f65bb85e4ef2560f466c3d6c28f7a20bd3a71a1889ee88385b0a9b176ec85387d5115dac58ee01f9e2972f71525870852e5829543fcf987e613acfa171f5438cd1144355876ba988467e66353fb5e5b5840f316ad1600a289b1761b1f9cddedfd2bc446325130a77562d1f21f0fbd5ce1047cab45752350c5b38b3211f26d529da2c675ac1c8fd837631b82fe59be23c2937cc9c05dc4eb5bdea85d9a7a9dd45231c6296a60901cf479fccc09a4f5e37878cc00a8ccc4953b5ee0c8075d5ccaddd037a749dcb2a32c82d29c0c167b0f2848c14a0f6e4ea9bb8f105cef7c4924bb6740af6ddce81b6ce44667ed3b41415f0b8ff1cd7b067d163e5f5b829b96081d2cdf4d16ec82483d34f55eb318f0dbe6f7a1cf341f5a844934039eab4daf13e93eea30e8db56446ebb4bf92b185d4a9d2876155f268c4ea3d1997c38ff4e18e900c23b3a2cfd21b57d7f566d80815844301b4bb1278d0ebfde61c218860c6ff22341a9be7b89ac8be116fad6c78643a7102f148f538628c0b235097f8ad5bd80e62d9bbcca00c531ebb30be7f0ffcaf521d28d6cb872440c0d78c2d3d5cbb58b787f746451c1f9970a8bc55f391b24381889c2cd227f2e2b7937d256341340ca571f09adc871b829125cebaa9250c25674e7389798a6f347e661df4e9498e362e539ec782eb34f940e92657af97ec6e04100e966a695cc30cf5909f11924709103b174487c14513b48f0a098af418caac4dbb06c7fdfc86ef676319d224cfc855a0e0def57b90f10cbc86231e1464ee19e18c37804bc4108332ce5cdc05c4cd33f7e3ef6388c8c9847ed4b535a7597a03970b8a3eef14cb1b1d092d7e3a7a75b8f2baf91a0f223ddb102021bd25d706f2a321d077eb7e6363bd2f153e9c849410a8f8c3451b3f7adc1074e0b48f19caffb59d9d3ee1f9c535a2d400d1ea9cb9c3b445faafe3fea4e9feee3dd0f1f1a39e58a1fdec099b694ee091d25e4b2042ac4fd0a751063ec245b84abc12a5e6794c938e16570212ea77d9bd06bc74a4c6b2c21c7137357becc35f3e89e5536cff88a46b0ad6e0fc1e5899d143b47f041ddd8681b34d91ba7b6893955282f605bed05f93a0d8a2ca656d52277b78022a6c7644084a8d1d993f59783db76ec100af1808f80a3838a7ea11c4f4635fa6a8cd1ca98c0bfe37dc36d8f491ecbf0ddd94e7fca056192f519cc5f152a18bfb780bd47b3662d4ed791f677c8992d7178c27feec7c2f8e201d7353ea7946c414dccf628986cd38e047f516a24ef59eb29604d48a2e5b9f9ae0742ddf5151f3028bd4e910ff06c489651126cd26d757a164ce8a493b256f37ab0b8da88bd19b59576db611076af22715ebdb4607ea778609be77eed318c38e5be77f5bd8d40a71a7d6eb7ea910878f83e9bf90dd751766ece5da92ae07ade1a2dae6b4143e6f75bc280e31caa1b22b08b1b27cb2c267c55f389171719978b7a284778933335fda91b82cccf912c6ecb09ddb97eda62f9cc1499e3281956649aedcb2fff9deabce2044595ea743d58e77410fc7314a42374d1343cc22d5b17de314d0bd451ae7fd1ba33c0e2a7a7366132f3a3fb3a0ca4de15f53cc2c876b3344016db0538f1c0db6ce5a0dab7f387fd7324f40d1e06f639c843dbe4271377335d9452188f266833c80976284d44715158043f18e889f618f462c7ab39181b1af07f663c1c942bb270bc9b2aecf3bc2bcbf5f2e90a0a8f8fe8da62323081690271c03590aacde707cfce07c11ff88dd92334f4de0756f7e9c59b45c470a188db366a84a0862fa497d7afb35f5aa38e6b0c8f422795c09ff23b535a72e8ae638e813b85cee900ecb6c06f2f1747396497df5be87fb4dc9da4153263c191e640b0d31311a4a058f06925cfc0bafb9d74e34c9afc6d5819fd5f6bbdb2b114faf4abf89a7c06face66524e3642b94ce6b331cecf40f706b60686909e7c7d778e641dad42c2269f4499fb574e572715f8b90a1b894a2a7de59ab0fa2f58f113f1e1a0b6109f23302cf5a0abad128ee36d80715c8e4eb36a74c27d8286509e144267a7fe2f4e993f0291965907284d3f877bfc8d569fe41bc4db132ebc30d57b55a340c26774350e70b562242665b97e9cb94a0c1dc865837f7562903998cb6b1203fe662c311b9494e9f0275ef6ae1648c216730c7398ad17a3fbd53eda6c3c13faebbc36addb9b1859d7e6a5ad8aa2d07b3ee6ec3740dbd6f9c35f50242b5c07d6fe5c6ebdb6452004245aa2fda9f981100e1ba8c8d93faec44e98897ff2d396864b934d9a955fab822090dc42e9a0b33befcc86833fb191874f5f04e84ebdadd72b35a4135b2d2b8c1a9aac3476d5b2b66f77f8bdf57388d7c30a1fe49df8c757536f2836312734c0e28ab97a404b67016a08f6662265a3d1a0663fee5bee89b96dac26de419ff171035a443518a0834b9ef31b6774069cd2982de92f04062385f7516fbf4d730f87630ce428a6e5afdf54ee7f83dfb58fa1f0a4ff50b4f7ba95e577b5704f508f02dade1fc57fbf7197141835c36e62d62d821f61d3b3a380c7df6f20021d9ad7ddca084f44a8d45e91e33a57164af77024a8cdc7c0af01781f6e419ae7b35c1a0a0fc6f218dbda17da71be03f179c8693009e30e13f84bbf0cc5d86c561db47c5de1e27ba04b7c92f37a672400b88f227b1ffcfdff93db467899f8778ec4ea8fe27e8ba81df56e1afb2e322ae28435130583639979ebb4c1f2587ed13a4e844a0167e3e7a7deec1548042839529cfc5753fcc0b4b0e21e998310081532493ebca674d77118cacf850e462644afd30ddf88dc0ec0c33b230501c0287fa01a8aeb440b46f21f90983b1c1d0ba6526e8e3495e51f485f42eec4ff1c17bdbde8d73f11809342f2c832340af930084038e2306fd8f6dbcff3713b9b856af039b1733ab34e375655ce58fedaa417ebefd50a41015dd0f7cdbfa75f0599a98794d3a2719853c6cf355d73d12a27ad3933a07b5d85aeda58d62167e4b4601bdb95da657766ef42e1b8834805235accef1722068c4d5cbc4199f29980621971c310a094f15b0dbfe4a6df8ed14ae10d3f1d6380d89978955fc60d4c71bb26db1e5075f84e50e4015e9f390fbc9190c18054ce5423c2e415ea1c23156d427981a85ccb64850975ee66b4b60913fe281f47601c439fdc73982be6cf8d8205f46092a8263f8d54cfab48d5ca2feeff73c9843f6ca2d03065670b312474ff2e86f09fa768930122197962cc640ad980b009b438e7e70144fd21480c7b489071d119f75c2c139e33a4146bc89c395bcea109067f56e1e8fd89f9f0f6334fbae8b58f95c092f0f8d1c6415829752f964b746dd03e79feffe0cbea06776ee0c9565a45f4a9858573999c5676e43028dcce24a034a8c16274badddd1c6911c43951415a4047e836d57a07a64e476d057cd8eac642579d3fef824fa3881ce87ed67c702a191e583398b149a67f8f58df48efdd3f9c6a920d194e1204fa25d0986b264565fea1f2351194c6945124935fa93afed2fbcb3ebb03e09cd1ee50f3739bc5a7fd0d6ea7b9d0a1024514fd2b1e41b024da3d564d0e997cf58e799bad6cfaf48e22879099f54c99638e2fb1ab1b33c6aa96f60813fa9ef4766d72407fb59c541a033c13dc0d5736679a237024193f806dbd2e9f0cae7befe16a6786d88afccaffc375339e76a22a98f53c5003910c4aa418854eb1b1f81faaed328f06c1928d4a4f0b04a1e335ff73b08575a2f08cacd475109ad47db42d13995afbf6d9300e749e2810022df167117733ad733a0861c89136e388067f93117c7f36ac92ac4355e706c84729bb84796032714c874d37c0b248d9716b837d31d3a21d8b63745c00c7e89ffe9c53e5669e9cb1b4e23ab01d0e3e456ac8b5fcf2c82c49acfcb0bf909594404fe7dd67839a82e4e31c81fdd97babc84d1d61871dab605695bbd4125ce6a546c85c18bcf16669336261d7b52bd499a02fd18975ef60ee2380b6cdea0abfdb5e505808d4e7c0d65068d95e688a532389fedc40f3dff3b026ea048555ecd424487c2ee1b51d5571ed646f8739e78d593ac28cad1d44bfbfa2f70cd1e43b73265e06b38394c4d6c5f7472fd233643b62f4608e8c4f047f56440f31e74a1a1f380c285226b8e14d9c6ced7f15106ae8b23007eb25d8515b9e73be1e4bc092f4ee82c7e67981234c979f45fa88489a30e6765ab52de8f9f3ddd3db60c8b4cac2ab6e1d7b25c41152708eb214214e216389ede7d488681a3978ce163cfaa5b3baec28e41e7cc08ffc5c7a9a4137a3baad5c8890398e5f8c6a507c7eb42595ad6785e4f806463d2485e1d28eca235458a50b575c1bd389cf9135a2829c6067ed69ec09ca248b58ba8a5c63269672e91669815140c144f32209841bae42ee1f96623d17b90abaee8ab1a6305bbfaa95de25a3b2c3993ec33640c646a6229425a7193f95906c4ff38935f250e1760b52862df9b1ed56012b4d97a0f5d0ec3c7b497ec7c75dd907a5d7af2922e14e4214398461f4eb19b5ed93dcd79b03a684b13b6aef67e9456b03320a38c85be5f8ed5832d8e96c456885dcb1d0ef2a79a07b1aee44de4948a1b31605a4b192293604a7c70c9dd02c4bc4701754e47f3dcbd4b057a84b2bfb6b7390ce64005f066356fa26d70c606f25f854cd1bb2c3e6902ef33136782b37cb5667d415b317b524a24d1ef96016428a76383b1630b3ff52d7c44036e087a9ddc5f90d55f4be010a01fc33e4638aefebfede67964f2a37fd0dab72c2e603de0e01e120b06a34b2e2f2e5f6de9750b1d2b43e751f1a34d46d3a0b95c942f1fb947cbebba56cb7567718abe999a9fcb9b6f5d19944b448b15c403515a3cefaa9b8c86209f797a7e0f669082e6e42bf4691e72703506b8d31ee0a37992a9c732b86e699cd718b7944b4c96be3e1703f40325611c390cdbe518a425a42a98dfb57e1b9db700b33bcf374e08c750870999ce31bd3ec4212f240332a7a48a9cda999ab1cd93cf2c9dd498006b5c97e756e3c7730f52e91c6a246bb2fcb45b5b668589ef5e03bf168e6e1d1d45bf6c60d9412dbd8786b6d2c96484e4bc1a1a96129155597937992cc3005a633042d44d7fe15c9cb489aee28b3be165b9f21c4c4e7474aefa72ee64d4cd336775d56ff92c822ad2abef56bbd6ae728fc15f48cfbdcfc6c5000a6e9eecc33e6b585b71b8a0ebaf5959584bd26e371af03be30e71d4c2eb29d3abc5b76c8ed4748c42e8ec7857b348724396e842647d77ef84bcdf068b4a3aec78b2e978e579552cbdb5055b1fd4e5615c84bace8553071e9985385c7b765f90cbf2edb59b643aca4e15b8d51527e6b9a777b74e111e5663d99a3b96d8a183ac11b06e142284d069ea153c85874fcff90d9e1b04f877c7b6334cc5531734bdf2e4529cb1f3fd8ec984a2643de2a4629b675ffb931d1cbe0dd5b271f4c34ee8c287a6babae1723b8043f25c06f2ad0af90cfba9ecfc7afebffa75fd9069b2177d8693e7b8751b797b7ee3b180e8247a7af6c3bfcd828eeaa126e44b75ed03dfcb365caae7be1aca9010e70d4904d5449aeca79e930bf87a269c44973ab9bf31dc5cad36a94900f387ac54151026e37a30dee9ebae0d106b179e82abe2790e109181eb68728317bfd5d0a503d792d9074b15573b3f5ed81d663cd60fa16365b19a27fd6feaa2cdc8db371b96820122fcee54e2ce2df9e482da9d5fdab923b2e3b99df51da773e1eaaa4b0b477cbb7c0b428751d06359e803a14e8e1a4455e7ec09870128e0696dcf06d90a265e56c52aad93559cf247bc32e8697f0df5ca03e6c39b685f2b9115436538ef5e632576afaf546af7e59e003779c10bfeb6389be70d004c1f247820007efef8f744ee48cae9509402060783651398adade98b7bae8f2946f101c8e5f76bdf0b12479b8a25ff0613ac3c664943e833dde4fe77a7f9a7f3423fdf891fd6279795ed12d535923229abe46d88fd01278da73a00852b483bfa696a6cd9d5408849aa112c0e99552108151b7dadb1fff6a4f55a6910c35cad2248d73ef869ed38958fb269917a354de9d5c8589cdd13f34d6bd496e95206704acfd9f1298aa6e7f41f3e31cef9427d01be8f80929326b9b947b0de020291c3069e29a147ab22bb9a1761c8765528208cee13388aaa7659dcc2cb419a3f231eeba2d9e2780ee40211f8d54e2883d6961c726ff453dfdfff7c244a8ab82a7abe7929e4186d4fa9ec2aa32f39b6585753677a4db4f2c95de5646616f6e3102d61f7dead89e9e1e5053bbe85c9af38320c0a2cb70519466093774e9d9e8586df94cbdd677fb2deb73b77c07f521243dd9843d177b7395bd6b1d76290ce647853dc396c06aecfa415bda64eda2fc723ba664dd05db0e56dda3f62f8902e6cab7e36852c7e1361fa496237159e4e9ad3964012debea5fe421945b35803023e7841c2c5f79fa1ddba983ee61eda29143545adda58f9e498138dd03476d22b996b5d6b3051a363a9f516b01dedcf9e346ed4780c687408e57187311170a734de5483c101b405961b0d61c29558e57531d1c99aad65a30c2b5e3e74efd404dfd792edbac7323ce63bbd0536930531cf45c00a00ff9465aaee9c3f23c438a8bee0fb327454d75a2bf7e1ed35301078d1a45d1daef16e398b7d8e444921ddb3c7c6bcbf78f9d8fc894d8a7c1b898e0bfe3a82063440e3dec7f6f993fc66c033733e5275432dcc1e8c9ecdd8601cec6fc4dd838732f44cf15ef9bfccb6fe6ba66f98d356d2f01ac21169e1fd2f7ee709cd62471048020c92889f5b738e1932dbdb839c3c88ab8547be8fecbb7a97f62c6caf1d8107f64c1776ab6abf30ce21de96183a25d854de5d5f7b28d34dcb50e0316c849904017456ef49d88a4909d93d5592376638c470652eba2e34647acaec7dff02cf914d079e04cc07d28bb855777e1a88faa3e96cc6835e8e40c17466cc8faaf1eeb20f17d97e90eaff3b5b2d08ca3ea5cef543b2918cae180b43b5f14baa29b462b3762519956839ab4f07fe4fa3b1b4a919ba890722f806fd66efdc571b2d47aebe7f72c69c140069e537f362a83565dead901e94302f68897a70a9ddb47f9df06f1431c7c91197cd56eb507bf7132ddea061f7596cdf713e05dbd3458cd5249e5202abb834af451a8fd7fff5e2a7f67b803e60f590bac09674e33de3f194d4e17b8ac9085b93fd9462e95a8e544a8ca16ad6812c6aff0ab051b1189309e29c65f758a6b66d3084766202040332c99e508e7dad8f42960cf7644f494d7bb372c63d1bc6c9bab92ea3290ff2e30e8e367c62ddd56e9f76687720727c43fea4159338f8f38bb8f75addbb8d9a38aa6442229f89d61c7d4f2f06cda3c0873d1f23805ef76e671676f7c5bfd41b4495f8e2d3068fd9e30c08f96dd46e6b88542888a1077d933502fe753de818c4aaa00655d25df42126d154f444de482678ee220fb5022c4a18391013902b29bd7266ebafeb84967efd9cad22987a52f0ad994aa1b5a8170b7b25a45fb548782dee84e3a61ba603aba2d60da6d0b5071766b56a614e78a5ba1d3e5d5e8103f1026e9e7f6854ac6d2736d63e75807189a43167a997562e909c45e716a3c6d2874475ee1c72eb5fc98ccd78d047e50333a4d711366e344d2be8009f995508e770ea67d2b19a5644830420528e15333feb1be4f8ae6f284fbee05b9b872e7e553a4e40e9005ff208938a73240f24e67c95a53baaea196fd7f9de30d93c57896a770a4710c7045dde52610fbda89b4c74e456c915ebaee8461861530d9c3f3ccc5f58d16610b8e2c69caa51925081a50c4f07dca6ab895e462797655895b1249e25a1cceaadc40e1af9b14a135c56f467e9767e0479688f947466be6df618ec01e953aff5cbac4279416ce44d4ac66a7ba9bb9caca0bf769339ce5d48ec6851fc910349cd1e9904f83583b116469d9121311db0850b3144dc3c8334622c2f69ba6b9a652bbd566d249d6572c19b0414138af0f025267bc7c454e91d70331d70d3cf6a84101d9addbb400679e9c824d76e39811c7b1b256ce6b4009fd7c7589617457ed580a1be05e3455e62d18dff243b02d7b65f8ceee051a4d57a21c61c1855f8de46dd4b063e81c7ef60a8c0c5efe52f65bc848062aa192006631d958a76e065266c1a9adb8bcdb147b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
