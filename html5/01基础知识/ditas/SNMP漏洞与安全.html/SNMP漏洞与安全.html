<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7eb73cc2a91e6600c78d84202113e81944ef9f04bf49b137d54ab4216b3252f3af0784ed976fe3c5080762476132657fcbd5ac2be2376b3d5688a674e595e98a5fad2b1321919094e2ae615dcb634e8085ba6df9fd270ff8c0e6a53e847eb824bd55c6e1260014464f24881f5d05725d0e565fc668ce746f8990c958eb3f07da14903b04697e9d98605084db905060142f378e2c79c306576d2cf156a755699ecf613984078481881fd5789d857e37393eea409a950768fd8ea665fc81b712ab30f62ab15e87419bdc97f4106141a55e0e0d78aa79f1835f99a10e1df753db0b9b82356de99f66820dd6b085735bc779b65907c5a7942f9655c7b15821a02cdca1837fb29e6945ba7310fde93675b360feca64b17779cf69f30bf4a759e1f98307f34f3bc5bde7b32f9415845d4dc0f0d0c2f337a5d4acea9fa15956e799f6573eb12a5a96630501f4dba881b925fb070657547f8c4b2ad0573a359c900143eaf807387dcf5c9a1021d29ee8408a906fab3f2956b585c52ab08ab537ee80188dc4e5934732585329c2e269bc9389df0ee5a0e121ad19600790f01a7e305d059f8c9e22e6cc1d0e076b2e88541532bf1e24380abd566c412730b4f08d1e28fe266a4da95bc6b2430883570a1849f12947e4099a95ae502c4e7b92251a381e73a472c1cc61ec73198fe7fca1356476d7d96823fc4225129486dfcfd9ee1b0fa2abb8f9c1e285fd0b7fc82218e666b9cc3585365770b7e219e1d3279596fdb077f4360d968108bf995db43db9a6361727e0e6f828bf3b273eb7b310a3b3ff11c262bcb5a3d9d84cfc5cedc3b539702461ec0386a99625fca2fd57768e28861157b1d38354602d0d48849ee3340ca113901d736aaab5e28ec14ba3dc211588827af35278b07678979a02b615b9c13d67937761fa63c285aabb3ac826e3844aee8acfc28f1b1b5e60324b96fe0c9c788dd534cfded93b2d5e5bba4e14f9adc0e478a658e6b57ec5bb7aae2940000809ee3741911e7524223b78066ae2689b052b9a6e6bc6cfddb181ad99872fdb04b37f8fd5ac8612fbea1f0ca0269d5328565cb256271156c80ae8a3a0d9ab4a529e2eb862c4c0c74359ec45c02d6f81782dfa9ac99088c5f5c30856ba066aea538ebf4ccce6a43dbc1f475178ae06372a373970a8c4d94fbb7d65344d6955ee0475ec3dbe86a40a38de632a744f4272d83c8c9bfa4b094b113571216561c87e133d3d596236c9188ffda23810c2296423f00d4f1ff8e461334556e9fb4775342c0effddc1100dfd834ae137169b83965e1af9f751dec6176026ae84a104bc99eec259dabd424523ca97c786487fda0cee143a773af8cb792e8ec193680f8974c792228768c0f50563b0b1be0efd18754412d1106a345ff9478f4973b31607ad5a44f2ddcc94f46aaeca1aad1b25ac367d2b9b616102c2c71bf8a9e9264d9d99bba4ea77dca69e7a81e1a133c0975f5877ed07fad063b4a634bb55a811cd7dfbf4cc4e061ff8787012a48d98bf48e96ea48b760330e16939c7c6adb30742117c7c1bdb7547f9464271c4e80153df695af7b420a4336e8d37db79610873d65470390635e6d29650bd6ac1c4de414fcf029cb3cf9b6b2359213f55ec14a0bc54deb2a599e92bf9ac49cef0b35fb18fff3b99c3ab040e469e7b9defc7b994dfb735dcedbaf6e9b28af7f6166580995f2a4b47e12c0e981a314c2c1f8596a882d00159f329b6032bde576091082688117e8e02652b9abb8adb482be8f8620b7c37c535f9bb70cb22227681a8d1d9e024fe88d6bde72912048df8f61187899e5a2bbe26be57092cf21d6fe89a4c065830303d53e9d74dfbc6c58523ebe7b1c4fd6bd7df83a0639c803ed14f489b30046a3e2c1c2a56653d0d64cfbcf7304cdac5eb2022533dc4779ca5455dbc66d2b90263d9fea21f970aa33184c018c0662e000dfffa0ad69a79881706504475f368f24c70fa204c96e67918f23a8d8f6299ec489080f2789528bc0a3cf9f44db0269323a48990ef6bcd0667f4336c9a36f8c533cdd0051f889bfd905dde189e6e97fe29fe59c4c19d0a9450667e12b9a3cc24e298a2412f0d3bd005229c6534ec8477e8c1ea2e97670e46c493eae334b6f019a7e4f348475bb3b3f637a50b1a8cf8419639d16ebc54e220846b4a9a15d6bd04eeace240b3549a915801965bea05b234ccf3f085e53f56a643ec9d6ec629caa7a6976d83722d1615294738b0ffb97bd2360c3df0d153483524bf6f2cd1ec630742f1cba7283e56e221236cbc41c1660569695991485b1dc8e79f8148fb958f496d6c9865758219c11f5ed93d9a8ed84ddcd533138e40ee09d4a115b93bc5e7938781557e6820c47425681a8295df894eaef1935abf1023fbe215e17035e456e90b510814f32a501c08377cb1f33fd18e3c50e3ed460ce3f52d412bee0546745bf2472339b98b596549c4f0748c800e1477f38a3104a6c842cb36279a58477e87088a9b978d605cb17eec5143e877dbc57f56835618138d8ccee4a83484bb42b23ad3a8c9ac87e0687d4614b98ef3913615c997650b4f26f04cff2346bd20652cd86672114da89e582e2da3fb26b3389ac0d08f907fdfa48b3d8155a80a99311581c035a13697038d32366fdd5e30233ba30a489a2957989ec8335f7a1399ce595335e523d1ab22caaf81d6b2360b31c44e3228971494f6f4962aa44e4d855b030e02842423128661441e3d7e5d6128600f42d0a4f4189704195ebc50ce0ad2069b49c58eeaad18c5dbb9048c6629d67ad3f2fae43d205bcef144255e9752edaa0c6486cc56e3b519aa3bed6cb4972ede9b917308e5f2902f0b6634b190d862007e03debc11d67a5cbf9d0cd98631350829d27f3fa8bb90e3b9460fea43ec62d4f837ba2e9dc8b71296beadb539efd1fddfc21d8c6f80627ca41716c5e723add709151a648d8d803f8cbf2021fcd515e489c8eef176dd5cd4e2260de3cc5565fe8f443fd6128894b722f73ee97198e23d1aa20b086fcdbc0ed9dc27a8da07ebc628d7c31dd6593020c6f1e8ca81285b3755294214471a0e51e29e549f611cf5054aacc9bd0d39b0867de114fd44885781f373fd179201b6f49ce1a5dafabd9a799dcb8ef39984161e2b8bb78a5ddcae552d0e6c8b1e9afeb05678e9bd8cbda76806fd37ede18af9a28d176226a1d6338251b11f2c877b6ddce32aac7f1c686fe558cb447c707be8195227c1eda8f67002e8d769bfba39e2c4757f44cc8e5776b9ca47380c2b93b539c6b53bf5c4b65630f070faa52b82dc1b5614b67e6d62ceca0b77219bcb93c4c6d6067fb8bb2b2ac7dbe9867079d9a6cf6793511318ae10223d605709e92a944ba89c08024406fefc6f46e57416876f62fa0431e920e046cdae9e42f62c767eceb076febd3cf1fddc603fcd1652fa9d2a5d555e81b952ac57fbb5bacf08d732bf714115182320690471d9587c3e764a91324c716e0648b7b6d1c9b2ebf8946f83833e66a4b594e051a1968f6436c32b2eb7d9923770c27e0c2514084e3117d850617537980cc900968583b369f607ee77a64840d034b50e437eb0d726b8e1d505d84b25ac2d244358f9b20c874522dc5921ba82281191757671fcff6475ca9f86dd1b7501d1d8400911202e4306c14df9655b7139641cc35129bd0393989a8b3700f2b97d4c85f51defb286a98c4e89902a303c6b26f4211c1056a3e6d2048a04de9a9e75dc4bc246e44be7ee22018f2ba8d87a655702873da9d5f0c637bcea3fa33a57ddc524dbc2f0a5e89a6897706317622d8c09f0a729adcce31ed1846393443a623a71ef14d9579fb293d9318441ab05816349e94dd04c03583380013775017e0328634740a31f4cdfdaf14bec0108f526631dea9e76fd6aee9764beb0415ab5d43e00a855976e7cde734e7c4b69542c9411f9971872e9b8c6bbcb3ac9de2a09d3caa261538085c21049d6ff98e98cfc3bdf4fd4af53ea263164881ee0e2199c127487adecfe07acf552111067d57dcd7ce602fe2d69c391069e34bce016aee6dfef37626312d105e46b25b7681d7a1828ccafa7fd1648d932e6bcb11245ceeb741e5f2a2d9bc4fc5c5cfc6e3b5abd743477508ec775e5fca9e6264e408cc1751844b82ab44a03a3074a0356f12aeb99407a1630863e5cd42c74de670a86816316370d7548a9c06a64d355b54d4f5f1d196133fdc4682add0da89c7c02cbe04f31fdcf8665fad81c210896acd8c1ada075fd8e2db36fea16bd6472d1e7eb3215ce3df9856eaf431347146af4ddaa1d0684028f4e722e8ac643874d51e95152f8fcda6fe636bf6ab5b04476af27a0c018bd5ea0d01177d3f583cf6ae395ee5fc5f6a4cf80767fea390429503089b027c8032b5d044a123eee85615785c0eeb0fb41113da40ddcb254b1f86cb02c7b4a6ea58c7031d6982db9f103f166b0fcbc8c590f76f116488c502fc8cbb0dc90eeb51eb89124834c1074c6fc26384bc8addb44ab4953cdfc72e52f3332ade75782dd2c404af7f00d178d0365435c6d0902e7ebb18c144c42fcf58860b6c6153d82049a28c192c2a1e1469e838993e59959edc8080aecf82b34f53c6e8ecf976a8d329d4a738fe4cf044e7fd50b1b90110058a9b878b05852a5f043ffb3842146478e0e6f9a5eeebe253340b9c221d6b4df35573ac7934b86b40a33e8aa7471290e03519088f889252762ad8e63ec5eade0592656750055abd641427741fe464ed19d947c15f94f96622d8d1091fcbebbd45e2a27e3f92496b0dd042edf846bda1dac90c3001a8d089af9d353740f5b8e7d5fc9cd1d82a634aa2551c4b9c0f8e2af2c6aa88a05c66bb58941f3c1edf3c3d4cffc652e96e3db8e38145bb4f08c99a42b1cbbc680fdf2ff558dbcb92ff749db9f52b1091d1fa351652dd8fcdad9fef37273c3762f7c48f7f09d8bb201bdd70784d0902f072555de1a2c5f4b59bb069ec2aa1d78d010306ccf880d9af8680e6c2b124e1c41cd99dfc874a2888e34c06ac78b7f76749848519a173a0927b3e9d7efc721e382f81ac1abc9e50fa71620b19a02c2fe8090f0e252d8fbc3756aba91bed7bf22aa3799091c9d040aa5175a12cf6abfd0b78feddefe615e42466a609d717b47fde178ef716f5fd6df78aeaa982c8bab857124a0f2166de696d060ff235ddb5c425615d3412471e5999181cd0660373812f9fa260872079c0512ffc0a089eecc59b40f9973a269b06e5cf5ec71246deba5a4f186d501b891077139836a98618a1be1756796cdb84ee48b5b08dd469e68effcbfb91ea53eb17c1364650f5c649467d80568a5c94c03c4a4b331949bf6669aea8a898f653006baa840bb220f0de698cf59953bb339a63bba34a49be1aa94ebc5a8b4f54b9823f703fb98a19f02ac3006896b883910daac3fb2bd56e52b95e3a0906f6f7ffc34ea3bf06348a3d3fb60041c5672a2c9cc445e7fb2eed1cdc76b2dfd46a7328da33357d4b84a0398a252b1d163b432cbd345427ac2819a5648e7b9f29c4dcf7ae90675ce16425a4997bd8eaecff9dd8bed0e20d34f22f926c5f771a5790d2146a3e788590cf45206af56d8ce323f4f7bc33b8a2d29a1d6628b218bbac793d6d15ee9b474f83df485166e2fc07716ec69ae99b2c4d85f639c13ff2fb61a2e1769363239fe5abce08c10e92febd133e86f06f6fe9433d06a8526f920c1095125c8242031323eefe93d6e204b8525a7903608d07b0ca8151acce463e76718478283fb2b4842fa40c2ea3aa44575102fe70766e88972f5253dd077e070c297d4adbb72ee711f2ecdd44ba3f4b66472409e569c7b118d8bf027af38b504e68285c9c7da26c19fa45169f9934dc082da36fb58c980c9477ca1dd35f633b1f318a352cd624898834fba70221de47d3e7192dc1cbdcc32d3bd80f5d157e5ef0e889d8ce4b8efa4db9234ad796ea312b2ac4d86b617f1d1a2ef21bdc2beb428df5dcca3d468a34bc919856e563e93c581d814f042f45d1cc46c5972c136294de22816ca7e873d19bfd73b851cf5fb32467a8cf511b42952328ade2c7138953105e93fae0592837589fbd8b8b519aee47235004e5df5edf9df20a13c6fc7f8a0db0772a538513da702c0c3a154a35dd45e9c70fcf9cbf1d9c7b7ba6e9bad934b832dcc7ea595aa32aede7478319f7c2f2c615e4a9332909eb9731c75faac28901163660e21f54c9097aee09b5be36eaa3fd39d2320bee0d3bd7ecf2359fcb397759462ec464e3905ca9df856a6b5ff86eff2483ab9b6e834bb9567f2a688b4caa92bac0165b1a4ed38f2951293be0fb8a36c0557fb895fccff517fe73f811ce5b564cc5f935547b237ec35fb1c1a6434955719aea9a4cb91d9c1735acf03b1aa57fac538991867d1961784f5ded3c2912a326a3a5c0c1569edbf710961d5b76f482b7c4933f1b158a17774a4a30c303915039df0a41faf5bc2526b378f911873bc0cb2e03b516bbf8837fb5e2693ff6ac6591214a8c611613dab7bbf2ec0db95fff8969221091f807ae43bad0cfce1b75b6810916eb2ff1a75aa3f74ed0c7de6193a400344d8f64024f51938d831f7a576341c79f7ba242b08b28878162f373d8cb564dac1108b17b024f313ddff1c49b179cf3ca0d8e132e95b695c1031623297f84c69728fdc6fbc4d985ec0e85ca90b2e87bdbf8e953f7dca9c638a1ea587d8d117e1b96c8b6537ca4f8e63b69d96add1a75c2a27f4bea48b16468da796ae0e8e4dc0c7c58b30cab255e71544bfc4c872f44697ec07613b8409c4f80d6caddc3378f5f1509262f0391b7984383099be5222576f0e9589295dc8eb4cfcf7c4bc3b80b2a13d5f3c67475dfe99fe1e05006ad0363a2520856b13b2b0e92ecc8532031f18b2943033e8ffb512a5dbefccb78495a8915f5ba5ff67f2cc69d162f12dddf0c25a9d0df350a0cc43ee477d2b0065864aa503ae4375b7182422d34a982fe73118baf9d395bafb28d7f610b2893aa585258168cfe16cff9af71674cb80658bc8bd8fa3a44d4df1c6455ca4afecd8ad8280f3775e28988e95d5f285e27830f37d05c550d1798881736fdd0e04c0d49ade79e20c78165a41196dfdef3f595f9a47db0b931f7476ab0a8e88f0179e2affb7bd3fa794e888d13c8895eb894265a0f4c0a16ff14aac2ba3e1844f76b883cc2df0746db66d0949a7a61b953ee099884c188ea08a771237926e406b95938e7e52d52479d16d15e805d8aa68dd1dc4f140077e4ebbfe0d9d7e80142801340634a4dfdb6314081eeac277d156bd510dbfe72e2602723decb41ab8881cfe7971936cfa43a3602000ed3a12af28c515e214a1a38a92237cd276086e4008a62ce1d85aae9c7c0543c10ec532845cb06e73fd6e72b5b800b969f85efa6c12c0e5d944f154bf06c060fcdaf57043f74fcdee61d3fd57d66d6feefc42e26adcc157ef2808607be42cc0a0f2afa4b514284c44c9817bfe4dd22f707af86bebb4743ade6f512a2484a08a4c884a64834ff9cca00713f7f73fee3a39b4f7aa05f6da9b700488a63e556d3e8d0f8a9ab586ac610e826854b7a2298b3f65541f463416bf118187b03fd55b49156182edde86ea3be630ec2e0304b89b9f9d1236dc19fbf57af555349a84efb0bdddce772d9631145d16da2da0af9e52d9fcc1ddbe33359e207d1e2fd1d1ac4522b297170f33f8cfd10397d92a5aa176f91a0c51983507d0075e6f9b71f6470f141757de8f0999633f6bb84111fb09febc1db2358628e85a49acae14b46f6d294d197309ff3b977b572a5204ed0105cfe715691743ca0edc7941098b1b4d980ac9773741efc925c4791561b9362d7b55405b95591bd94f7b07b3bf374419a2cfaa43388fd7d50820afb8a811e64af928bbe2f22b72e3e09e9bee4d7e89ee3b010d7fc02c271e1bf5f9e7091a4c29731040dbb7b1f19f0dc5954ea33d5004c44991f4a2d9d7d9eed1e05a44d92e90da77abc43bff177e43bf397940426cfcbf6d40cc9ef0d4b4133d64fafe62ab04a0b513931a0700406a2131034c2bab29855b26714bcbb8a6293c76e0c7a6d7909f70555aaf9f8392796af52be336dad473de1b82e175dac0f10f0ef8bde9d370000698d8abe943dd9f7c6e78572cbf0b5068536ca3aef1b2ef957d5804a6e876b7c6154fc765b10cf80323ff2c2dadd240f39fe790c35b13a4109a5abdf9831e111f3aff3bae6ba057a2aed05dd5a0ed1047ee93c9875accac3b6d20548ca9afb9bc76c80f60ceac5e972db75137cb4928cac453e6bbf47f5b0526142f53275ef195b7048e8c8f4e035c5469e7b1d484b2587f5d19c238be24b3250e484349878f27b7ed9ed7d170551018ff435b6bd584d55f48150afb5361908972ce9ae86b6ccfc87ed75b7b5b9a0f37637ca47a6a3e06126cde2863e15b74c17ac68d6c37512001cc6dbccefc4780a18c1eeb96706549fa300fb23e1109ff4cb9fab4f2b8c63e3f9165c257a7c1c63b42a0ee9ebe4f88771f657daf34b775ec6c9d00d354ab8276e7922c70e26a96df3276f3a24d34fa9dedaa21da1760fd37d55396a3a14a0cc4d9d8b07aab2f654928e05e02f74c0edb983fbcc6f2c8c4077e4201f82bb3c6fdfff999b3391aa36d83e8f121e4d9c466bdfb99de2acfb845b19ace3890cd302bc89b1ab65c55eda21407a890aa06361403e4d561693b021fb1255b7eaae19a58d46e529661481d97400099a2019f22b482354f61dbca5bb08041c5a6524ac20c59256d7696c0ef7fd8a4f518a92bf61ce026cf01c0a3cda09e39db56488519f30c9e63b98eaa670dbf3d80c9e4e0b9cfc7cb76630657dabd17d8d886220eed0789cde37f44d7d37312300369766d12c2fdb440dda9a7f9d72082025fe04aa1ec5e554b4da2ca09125d07c4004e7a98dc42710daff156d67cc5e1c6277027d24aa30baecf3d9a672392c4512ea68d0b30eece6f7ea039946e9f3682bb27c7dd28bc98a139b09c91bbccbfebdea143b5731701c8cf4d78b4d970e5d3a0473c2d992ef2e039c473b74484c622a83b39edc3fd3cc6daa5fd355b208cd79e29aedeeffcaa529b154eeb5850acf8966b3b1d49436da15d2f41b70ec8f7a3589098f98c5b4cfd4141915aae2603c1a855b6a1bd7db3c1ce4533c0c7b61bfd3013c5577a890b981a55c4ead808643a5cdd7f9aa4d340ae55d3ebd41ed392288f49370804b9e5c16d5b92548fdb33430ee04d293601c96973b368e5822e9f0879bffa35114a5f53bca79cf5befaa0b2e7a4ad0690a5edb94132f9a6e14e8e535681dafbb03f0763716d9325f812cdcb8a8552691dfb957651535587dc8db3e0d735a6d75b1d90581ea82c6921a01b9dc90829f25b31beff6617b4c827499cbcde65d204002fa64873dda433a0b7900285c35a6855b819679f52b23fc1a0c1bfe50614ef468390908edae071923d9263c18b819b244380af4bf898aa57632504335feba6feec81bc196022f151b4e405cf76d8ce70eaabd3affd2e021cfd0d5c0087803c758e83f38a2a6f3c3b27705f4b3613e93d541d4a59c025efdc81e5afdae213919d661ab35eaadfbb0509cae4ca5126c2e2f1ceef1a2a36bab0af4fca805b45bc07a76e115ad51adb621a171600ae15dfd25d64ba70e27f71e679de9cbfbf2118a1ddbf5203438316a54df7958aeeb73b017a2d27210e6fca17b7a0e2ebcdd873dac1e205d3ff45cabaeafcdd64690e700c5da5488604e846093f051098908e1b809ddbc779fa6944451fae005792783d960d3732a84fab4d560c0dc0e28ba3d471f59bb2ffa597069a325526659fed9df11bead6ec7c030093b5242133af4f90c24aa366eb90d0e645e894533b7ef674241ed0d5a0e5b72d240b0c7124353a152029d536c83bdadfe86069172c2f8b94662190b5b2f2b381a374f718064cbb4e87291199974b9a33e82b0a47e377a68244b33050fa59dd4953ccac07ea6cf78f3080c71d89aacb1b3bd27ba6fb560c46c3dbb0c2be1f5b9ed93df36fede90d0d98102de49ae3ee01baf06087695810159664dd775572302fb3ece8acf08d5ad2de6c9b209c5e0ddb986aa241d791bc4c961502ab6d7abad10a5333bc86e23ed08c62f4fd4cb52289d7032fbfe6074c7abc7c9a7603e25f0efc5d4a204de2b69ce1b9a746db19f8f3f0ebfec3af0d12fcc813ef2e99364cf6cad7ec5d37e36182ad71ca7b66924603f7e30158c53f5eefd640c4a2b9eda25ab8e6a4807e80049223ffb24efacffce938973de2a440de4d2e4f38bc92b0a015fc9133b23bc80586f96f56ab3a90911d600d17bba40f701f1ff53366a5e937940dec352b213b8e54681405bd85de98f6a27bebcab30f074327bb55c0496b95ba7096828d5a8fdc028e27f556a9d8176152181df5226c3c215f3a3c26e905d73b62e211a1971e3c85f05e490c8094a027b9c7c21cff4dc26a4cb7bb2d3e360522fddf56443ae72854f734df3f3cdf26ea6cae41993767254df71751b341c77acf4888df2d051846ef77d03787e05791cc25094e7453747edfc26ad9d7d8e0097be7db582c255bde53d7a19b6387affa1815d7451810a8a5d8a04a92aa6706cfe622bf0102c6d03d5816540e8fad8afc3d4c661c33f01f1d7d871b7d320dd5a4ceaae5bfc9ca519438ffbf5490e36f37ebd70f782e0645e80f5ef0df39a60278194316f869fefa8f3e7ac25d49443fc642adf99e1a6c07bd74cea6b3c8279deec43e00e805928be3ef35f1e36d2b08f448d56e0565572687724665b95f22059b331eb407163339786e6a42cefcbe43ce5d47cfde6d30247c84ee15d804eeb85f14431b59c6e548c1b7e70415bc0a20b3dd3cb33b311c4995aeb16d2b6e9cc74471c7c2c7cead703c64818e3c9fb4192900c6b9d046c838039b7e897fe1092cb4024b55938562639d4e556d8ce3b0b05d65dfe69910ea06918c4e7d7c7d73ea749791e2d6b220050bb06aa57c08657b66b7ff652e4125bf8d85ba59847945b1c2cd9ee048e25ea553365aaf865cc21725833f1ec1ce0dbb3b822281eb0533259a8c8bd27cc46976c4cadc8aa8642ca25f8f30f1b78964da8e9a5b520d26dec57c006f96bc5e503768ed71b10d36316f1f6baa2db6b1935361d866a41a03d36bd562c270d1285f77f7b3615cf15d5ad93d18de16f0aa4414ab1379e1b2d22731880136d9fcad057efd14e21a54872ad598d9432119c0409d1dbee5808fee67d2d199d4350efd1544dee55ae8789a0972f405d9568f4a1f3eadcea2194793ccc99ab398a2d7d6690e6c8fa11c926c327eccb06192ab21b57d7a76f95c560680614dd1d47172f91cc9d530e630ae1d0035846eb0adaebbd27f234c3f08ac31940df1e918a2913de139982fd522f108a18ca7285c3100a9f081e687217caded7190fec367ac12b91fa77539f17ae93e522e2aa314327d1837e758948f40266e710f2a394effa63aa365b8c854c9977cf79591b4df2848575a2c452b6ea38497209e3634e13d19c39289338f21fe6b12d5b8a892c2feae228ed8d8bd77da5cf904f8b39180108b71fa4303ba694cdff2c492073bc80c9bfaf2c114622b27a662f53f3e61049acb483530509d9a55c46e43e74d84fd850e16e76e9c3981cebb251ebbcfb8bee123a6027c249165e7adba4e09e34e459a3012539b5b273ea67303ce1ab3fadbb088879cf0c2c18755ea02e09165b53a5ba8e7b2896e63b857c9b236e3deb24901f696fe77c3ddc0654c733c0299a5432a568d8ad2ccc0bb6507bf40ce1fc8d0797ecfdc2fd2b185d1a0596020aee46d26c56c20be509bd147daac90544ed5b528b985bf688872203ec76333bdfb448de010d96d2d5892c323f6b45b7ef6020b56a18ff969a299cf9f8aa47842d075d2cc6a0faf282a9483a79551468cd9c882775c4b9914307f8689455551fc8e67ba79dc6172a559b82fb2533453c2a333abf2a0449ff9b69efc591fade24c1f20729c84505c5733a692a102330bf00a37bf0276fd5e0d8111dd45ebb225c3dea38e5533ee2d1ebad74a68e4ad7980aa6568091067d1239aeb11518717bb95b4f6dc9948ea24c32dd35747c73a051f0e396507d510ceb7dfb296f15f73ca4e9e534fa7f6a3662000f779ccd44329ff54ec0fce9871888cbe1fa703d56c95e783cd93625da9fdadfd9226e9b2965481305d686337312d274741c03fcf8687de340a019ea837bd929ffb6a89a56e876ce7d12bdd40f8303976edba15156ab6657f76aad3e1b7e2a455a80094512eedc54df06d6a8b917affc446fd68277ced89d40871eaafe6cb58e98f8650bb6bcf1938beab8fc81113126f9a0a32666fd1d52374932de2a8e4d2f1599c1cd015e5fd8c571a7c1c892001ae4f95a5b48d7b88c7be8748f230bb7369867190f7611e72a8c76706e3b03cd876ab33ab84c198b1bd52ec0c3a1e07070e83eae906cce48dd0124e0739330ad86d6654a6923733b9910483e071709b96b2b37bab276d15acffe9599125861fc90dac8537b1897bd3c0ecc98ada07671a4d3cecbb680b3d34596a38cadd1d5309d3d0344ab77e2a874f206cdb1fbaf8c4e416ab53fcdff49918ddcb9195fe8856fb1268a71e5681e277a3a4e1269341099d8a0662f42d38d52db17c50fc8576d8c3c5013c4aee51536d9aa10105482c231cc01fdbabccd7c1c72a0dbdc588d46e78551fcf7ad1208484f4887c64c072597c4b06a4259c77ec97d90314315eb807818019841e709a1c9ef1e461251a621bc5047956805fe76fe6dcd883e030e0f1d00e928914f82b9e4054290f8d64e54c974e1374c4607928bc0443acc852ce68dcf8a49a474f58334b217d0c01a7979ea1d759bce4bd1dce8f68be50ab8007636b4202ad9fc429514294315a320acee9360c7e096a1948ef84386a25e6b47fb6ce8c4a965cf349d4bcb15b1266b7d6f66e733e760d4a879063def712519775aeb8ff6e13168a4542fae3ea6c38944bdeafd92fef4a8643e5254f03f17907761539668892b6c24d407fd5eeeccbd34f86a3a031686b1707fd86a65f9d437c9e98507f70e869a6d440c3700ddfeba34dd1ea50b6ba9d50a2002b52b61cf5e93387b971382fce3431e1cea0fb1881a8d80e28a152bf9cd0776a8e395bef987aa8d38afa0437669cccce63724043930d3c9c34b076199e9dcd14a3f7bc5ba78cd12486e622addb5de2defaea8037f8f04e1bef60caa7daee53711f237ddb5ac622cf64ff794ae48391bfc0d154b00cebcdc6b3a934ea0c6e88935c38956d1167bd3e8d47b86f3fd32e24155cef1dc9d558ecc596d4f6379cae8c9d587eb52e4245da01570c733691b9f1e8a72b661e531a07c39936732cb7211b47116a5fcaec3c4e64141fd662c3254914d43aa13c0bc99db9dbbd3a6ad4ad3e76167854f4cbe90e0be2835d1538a3ac5d10238f66bd93abf5f26b589e88f9960c580adcd44f4769366d9ecfc6064395dcc7ea49199743b7fa680a598e66d1864c699b8df481443b7ab30dab248827cc063fdb8ad5e114d09609979771a46005027bc82a1c8bfa159162a801e95492878995654236523acb58540cba512c842972076fb5361ced729f840c53fb44ca2a555cb3b505fcca546cd6ac22052e70a7d06b6d65fd7c8db774a9c06e5c381d2371e3ee6e073c1dd997cc5f77fa133ccc190d639d51b7affffe982783f7436fe6c0af1e15bd497b1a656a8821fd591e363d5f6aab5c2fdbc0236d5166c7ad7310bbdefc6cd6a0441a58d5ed94ca37b4069a9c540dd6472b81621338dc15794926a94c619d10d580d9dd8d73f55e90ceea1c0933d4e0ce67bdcac844b76199b125c183d71696648a47aad9bc00d22dcbfb77bdc770025eb6ab935a216816647c1497f14a7b76af143df17058cbe284e66522fd72e62c964ca35fff977b5771d1cfc2f17a0218810f885862a2683d9b8863844606e14b28c84c29dc9d5ad5b5b19a5b8eb1cf5e7dfa15a32a2b4f2f0d49810429f4ad8cf0deefb6657ea31478aaa566a998e956a7d15d0e141367bfb18df7e92fe4889bfb3733c56e18fe975ae24eaef635b83dfb4038d69fdfe5f8e2a01298e792f1c2bc45f3921e139a1778e476731382aa8edfeab9c629975bc8b479f4f81cdcd0015cc3d487122cd73a39f74ca835fba6b4dd6a37e7381727cd819d4045eb2886bbe189baa45c2494ac3c37614dc3de9947fbe0668fb829f9917319ab76f505260ebdbd0ab56427052d54569c65ce395bf1bec47b0511109f45617e871118ba816af77c54bf6ccaff8f78b7273deeb7d31971d6c97814600a9caaab485ff0a96e6944b9d0900fece61f6a8c2d18df0bedeaddce1fdc3f5b6671a7af634c15e2154c026b961e93fc47a98ab322c3e577e81a405dfc85a0513121830178283a34840e72d8314da6d6a318850afee51e293ba16213cf00270e78a7a693ea9f1f3a4cd40840b0d2d0bf34c01000b90f1932f92a35a0f28b147187c553f731cf87db6557888c2128c114a215ea23a34ac1fb308bd95cd94442806a6fbc6f448692668d0e55d6a43554d17d74ee92a14d0ad42a25e7598aa6267f91b522908d3b69162b52e8535ab59bdd807f3b3d94932580b31a037f4248644c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
