<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c4c84e377c745a12e3c3071dda174de90b7946b621d2e76eb744d1895958eb49d42e47dae8c617efd478fe1bc8fea90b422ab9ad14c63be98909f40df18e370c6d11976dc5e9046b03fd604ba537ca1175544c8c011b76ebfc710cf805e7c94c2333561580a29d370a8eb908ac1819cadd547c96256ca32319b9f85cbaca56698e34e9e288d2cf9f81846255a87678224440dcbfbc6cf863e7cd39383107fab36367a6384684c5ea07f4d98dec600482b8d558f7029e2feca6d5ba5a48fd21d6380f0d8dc6e200f8d6d27575aa21a98bafe7790e30d3d3db25af3d9a44cbade16ae87082bddc68da22adca9220afcea0fde3b6178f992ba5eab0e3170aab8cb6cdffcd7153e281de854568d288a885adc55356c2aac64998e2ed5ca6cec4f878fd1cfd0f4aa77787011b13e6e44a9d84e664355c909e87913ad978485cd31d5cd0112a836d35637458e1e0e810169837015c94a8a76a8c35c3862acffe03a15473d8513be77b7a579849f91c260474fb9c925404e4cbd566530cfc9153bf0e515977f90298197e83d720d388bab8f76be313e02968c7bb16df59d28f515a7bbaeb93d051396b9469723d19481173e3346c48e542655ae999aa1bb13c1d8c093a039ab1d0cf115a4bb9a4316de02995bc579411b9311e5bec0b047f1d9615eb3227eedb63652263fe97d3a6401db609e08ab787be24064d41087a12817a1477da3e5583d11be1ba1358ca75dfdbebcfd504ec8af712e0a01d04bf076fb28f80a08050401683d486676d4600030c0ada859a7853a8be2ad56a793f60484a2cd8d7f3c3289c4b8540fcc49cfa9b204ee18f93b38e025ee8ed8968f5992539bfa00337b8e4d8642af3c634a8b36be3313f177065e2723ea7e05b42e4f2fb72c519fc826b4fe10cc2035af03aad2c90abc4ca41a41857b114e6fb5e817b404fbc41eaf3785fb3a281fb06638f067ce98273c289e30c89910bb8df5e05fe15d386f3436138d00737b7ba5dcdbe792c8692e3be231a54259d81ed37a2eccfd53e186da03b6b9509f10c5be035d5fe6581cced7052a438abb3e2f247188cf50056ddca4119233c4052178ae12f3725b79019b40f697afbe20ed8d35589cf490be30e6d1a1f6ed7614715325ee14c423274cb3dd999574b0666bbcf0f3dec5fe69a8bc44bb3d45bd94f05910b006ba3dbcca8d522e64c443f80717ff4e1f77b4eab32f11587007a7d8106e88d87d2f89d35fa6973d794ec835fa057baabae3818909b9d56b73a04f1a1620bbc0da010d57116fe9b432eb6915d560561bbba87cfe8d7f9ecc6bdc3cc61c6baada3511dd09ee2d7383f854098f409cd4837a97f328e2dc9ad5954b54a5eb11c91eb79c2435ae5d556d3a25b4d8a9cf516862269cd43eacfc04c48027d5ee4f266c8c518fa53574400e2e04ed712ae71bf2fd7441ee2917878fc1cefeefb8f81b49cb1eb980a8230f04bcbde37eb79eeb96f2fcf24e55f34d9e6caa4a00f2a545149a0bfcce68bcc2566f2c52597150e6ef26d76e918f3698c07bf7ff333b1a37214b10f89d0b07e659db57ff379954b70352c4ae7bea9c1043c5b679dbb1d84bff52fcf9290459e494656a731c039fc3a4222f15cf00b0fd42789e5999aec2e0eef9ee7040f56c7b1898a860c9a74254555a523ee87d4f3b42e0107c0e14fc7e6b95f8a11aa7409c0dbd8ad0d9b8ba36228470a35928e4a400083e7316efe68681f50244dd0ef151d2756956af87b1b59e0c82c0a953a540c5a84769534d8626b49d046753e845eed5909cde808b90cfee268e3904f8d4179f5565b239ff5fbe823a2edbe7159e68321ae46f2c07052a28bfd99b45dee4c1e0e330510d5abfa4db5278f1310adb0e7778b355bbdda0bfb1fa72f5e28b2fd87c11735bd2181e5d63c8bd7bcccea33d4f81a8fb397672730d82858dd02a15a6fe1ccbac578a27b61c8a7a5d08ba71bd16d9f3d3cb4dd809e961f2cd187bf9aef39bfb2b2d69e957fedcb8c93cd1cb10c6ec06d9341f0d64c57dde4b422ea3167a56c9194e20e77902dfe91a828f24d5823c2a4e7b0a1578578e36f6d3f7b9b208af60efe0a04e74cd7bb8e9a73a3ead1c8ad51235c52cc50427d06ba5d5b3ca639089931bbf2c0c065724422c8965d6cea4c7d014c8b5b548461a3cff8ad5c91969318bfbee2d4098658c50693fcd59ceddad080ed4168b1bc36e4789d636c445012eb55e713ad09d5220523ef51d106886217af557e9b5b412508dfe4a4034e68df5dca5d11e6236be75428004ea171769ff42685f77e2cbd4f44f17f7926f4adb14a11522aec3e44fcaaf7f0c5c55368bfabc04da546d6c95f55c14a4be6e601629b477d8f916329bb2b9fb0d3d9c9d01efd80c2feef731b9203af7a8324719795a85f121d4e0c9666816771e8d69c5bdaff76d9fbb3cabc2a9baa5f8fb01884be2ef834f399422bbc78c9774a311268730c55ca0044a0b8b16805b68c01cb09ee7ee1b622988e4266b70eca979aac85392689cca6c82d4a1415b3619e68820d16f90510e03df2c722d04105c12c95a6059f92f45f4b07ce8126dc5c059fe22906c38105db105af94cbc6a9a5116cedcb8448b0b6434474bf4dd30302898749e1415e6739749ed455d82f1f6d74ae0e74096db94a4debc907888eaf226694a30cf8018a5f2f16e0a0e9f312fa35c5f3fe35022c81304a6ff2af830aded421bac740d16e0692f194bd6410268181ad8faf00b726117640662e6d96d4426a3e5fb6603208f8fad4f0db2531c64e37ee46af561beddc095eff873e6c079d43f456b1d38916c7ed8841b17265615912d5fc93ea5a0f430e42f79fac0388222b1f35a5161bf525e21c662a073cfb3abd2aff05dcb173f5a97a7ecb628fb347612ab0d5b119ae736223d741df03a8bdc11f44901434eb667bb814a1293a6ce97d686c5bf1d5cb425a273d0a3943d4cf5af6780589499624e543cf42b912cb4eb6086d127d84d59cc899619a72fffb921bf1697b9edac0da23143abb5cd034f3b6a2b43f27dc4f99ba68a595f2a2679a258dae7a805cfc91875068e984a506cb3a15e827bab49befca9d9fe6104d2b03b9d2ec55c42e08109b1f8751f68cf6985e663fb38c18125a97741fcfc3635bc4f3a1f28eda7e1febe3cff6b06f7d29c740e44c5235e7cc5ed34cb17fa12dcabcc8702fbcd6a5c09d6dd46ace6f47c41a2dff5dfc35a6dd82743f7753e0e7d2a81c907e7ee1313771ebe24bca8bca1d191bec3f0146197645069a5a6bff921423b4822fc1b1ff3ff5e68afa6a89f055ff1d13a207f02ac321e149aac6d121d75d978703d1e7a94d901bf625b222b07a73ef2e78ec5284338cdc8fe28772f0832e24855e758512dbcd8ad8f6e8f5def2cdbf844f88a89aac0c2897448b75598d5fa729610a6d196f27410a5328665937a0031791f187db1efe245eae335132abc17915ec8ae87e8669c12d6a30e5d5a238a0e2375187bc62e43970601e126f4f9f1337de68bed1fa2dfc94561f312359b4b24d89604b6403aee727a6eb550d6d78db4e64e7aef1adc82a32aa13ab39099fea92e9c1c80e3cc89e33168c7a1a67028f099220cf2654bfb3790c317a7afe73c3dbde39a47da6acb2d3177d5f53688467424a0a1bf381922fc493082e2e99ae0c8a053af700397b6dc0806caafc94c2e9948d05f42a18fb542c98fbbe455f4f39859cc2adaee328db6ae4b8e1a2b61a167b26e8e36b75cfcbc51731c2f0a66154bf4a41d8ec663ff411062453f434ca85397b0ca10c30422e2d2d1540f725a27d8112827bdce320e0d01085e86bd0ad8e41da78180186a69fc70feea8f6d753178663680b9974bd170522c77dcc9a1058921d6ca9fbdc4b0357ef04a138396d5a7542f3f7fd1e45a6603274f649343ca0d90dce741dd995f90512a313e120645f9eee1ca1b0eb29fcdab3644fe69634d576c91e232348f6798e2167057f9299df044d9b6b22555c2224873c90ae778ec901a2e18ceb87681cd5e16ddd9406794563c7e84a2f1ad3931b5c66d04df4815e9b17b33ebef7f2a30f6694b14c0a82ac2a8413edecd0206a635c258590d16cf2f7b2abb385882dca9c48eba5f574879af4af623e21e70827538bb906bba1a62ecd625f4389d6385e06d13553067fd6357a79472721f52e67fffb1229f70f4f61c69b1e63f184ffa62d12fea882ff63d90ff56bf9e1b86648203edf55761e55a315d0a6213faaf56c44ea428d80808becdcbba95639894abb503dc9ed0ad6a20d105fca6518209212f496b0740f94b21d75a33b800e48f12fac77d36b973b6f2b4d32e045f323a6c0d54767e4a91a803445ff88f3fd6177f0f440385be493017af32309376d89c9cf585db85fc0b9ec8b78b22a7e5af967022ceea65f029ab8fb456076ba9b255f83b54ccd280332259889b220aa3cfa01bb8307e9369829a1d44fae8ca4a61d56ac1fea8367860201d76ea1900e1a162e00db8b628f35a2c683a05180d46aee5ed2ca362670a0354445d0e5d7c6a8b3949035d9de3c7ab758a4e18b921df551d30443e2e1c51dd9ad5cda69b7848006523f50250d08ce42952a1e06093a66d4c47475f9f08d70b7236d56f94be9c6ac722de9cc13f8995779bf612921528d945397fe35c5c96a340dc0556438494e834a2e10917b562d6f30012ac61a0c3a753efe91d567767b85f52d22351e6aa0ce7a823d2aeab5153dd1e4351e708db2a8abbd55d224d6e109dbbb40ef26bddefaf49a2416f699b30dd812cb29822e822fd28a81e2fba8a7076797eb44119b0ba6e27b510c5e002bcefb2ce56f396345ea8c6e40b86db0b55cf561363215a071ae09b559f0d5f72c730157a0999c8f1e4996142fbfe79b2ab615912f29648d76ee9a31b0eb6eee6304b871178d8186d2305a2529a8281c4fb16bc8c41ef2b50572017106ef237942252a2efc101583f7f5aec8379264e1b48a908ded408d11130a148d1cbb0f454749813db391a9ff83a01632ebd3ad480d17045e15ea6e7a8bd24f2cf89dbb1dbae4e6ad878b610df442350759f88ed5f9f7864f8015fc4d56e35b4b2edbdd146d0e8ee581c283d689da2ecb427850b96709092ba83043f0e52d98cd5afe59fd92890bf05cbf644ab8767575d523dfca19539b1b0a349a99ba50778e88a6f39b303366b2dbe26d6e84cdce16fda3b92938b331bd944b93e4edc4c58d9fb4036445e39d84da943482bcad5f396d62f6b78f9c2451f3bac84cc3d3c566e3bd25e5ba3837762a9545d1e46b12c456aff1f1444a4ed2734865ef3c6a6e4e59be8eac5d40c4a62ec97cb271d58c90e8008f481e68676ddda0919f5251168b9d2168f83211697bec7bdd25d71a27491ad761dd37d042e8a6ad4b0123f2b1e611d0449394279442af1d141a8c5317bf3fe6d5324b910032403523b59670f157ab075bc4c45a727fdc59e000aa84945f0e5da5ac32aa840255d1dbc39b5731bfe301b8e9addd4b7193bf7afe9bfac18d5e46bef94851819682ba5ec910eaa72225d4df1e23941121c2346e79728a584225a6fd71a5999d6e9298196f52087a2e0d0a4104510cb101c5b150bce2807e5795a7c64cc0f98e812f09c82fe781004cdc7804624291ec7352ab02ce9e8f661892a9fc02a8aa1f7b379e580db8149317f5544694c62a5b5af0bb3d8a8158bede55aad12d670c98f9942eb3015f4d76630187a6b0eae4902061ce8a688bcd4826c8f004c9493c8c9a4fca606dff3125d9de14ad2eb9ec4a17ec26ced9cfe45e4be5485885d9b88496b7d61af0d9fcc971712afaee4110361c8d5f4876afeffd0149da00762678d70b55333fe5f631283e9264c1c76044a39b4e45730e42a857fbd9f69246b19675b5860ba68becae5fad9ceb7785ae2175fc95c2b3c661fc6cb9ddb85f009eb761b082e8fa397878b9d128e73f1669947dd6d6295b285a98d54e881d1a5e3f9855abf2da3a4dc5d714919560fd112613a55326dd1dd27c43777d99ee1f428591b3ee32a586bc1a8bba97b6b6b5b15773bfc0135e96b66e8a0bf2c9e6eb99c97e239ce00f50099ba9b43b69cfb86a64b4be993e2c264e524017768d7c1774118a18f13d4ff4f689d2df9800a804d1134525ebb43e0ff9f8d43548a61c269d19eb8535a6b0db63b1f5b2d27d3a97b0cf3bb32c5c7d31548aa6d4ab11fb8b499249b0ecd3ebc9b25789d8cb7a2291f578648c45e69944174656b33e012c063e4dec0324a00b325610fc8922b92805b17fd895213fd106ec6c89e288a7d82503be4110d0c74ef38c8f0d69ee6bcea2a4e62972af5e901c6b2fd5ccaf94d49ef2ec2d8e911f03c0168d44004b0d0863cbeb621f8e0aeaa0b639c4920d1fb2679582edb4542f12cf791ea23925e99843a17434951c26e49a34b95b7e8403748559d5bf00d5b2024dda01b512e3337023865c0e1fe8d00d0946585d54dfcc104e5b148ab8c25aaa86e5e49747dad0de37fc929eb871c3e59c20c74a02151976d26afef0f75dae1f51570404cc0df25807e77fd169948ca27fe85dcc1bca7a1123b8eedb5af7bbb7e52cece08fc54b690690fc1eb89313c98ea2acaabb00dd9882fe206f5123bbc42d15aafcd76803fde8af92699f17f74958740716ae76bfa95f0ff9b76ef6b2b228d53c782dd29e354dc3ab8756a94ea5aa646d83c00564c46237726520c7381d76bc0a301849fafb2e06ece9485af5dc957173b354504e788bf215e12c23248df0e5d4e9feccad6a156293ef78e876170b23b0c5542648207e13b870e36fbbf5ae0f55db7541d975a449044e455b84314ed052142df3d1c8d5f608927330d972a69559ba1d4419fe9eb354f91b47cabb41b85864a1e7852e5fee343c98a935c773e5750c9e445d2a18659e460780b45fb53a29feeb2277efa9b135c6f16369fa261ae8a95af09e49f90de3585a2d45940e646e12152e1b7d78ce1247e75b7e5eebe44c0039ee48ba0f4d21d4ecc76c1a91f0e14d6ad944b2af333a4a2ef8faf85b73671a013c12fb9e22fd68053188db41f9fb197c2a8b76e65fd3a4946168a4a5a1512ea1cbcb79662d59f497b0d185ec801345c02d36fa8add70a6dd40a11b7e0b195364cd42dfd8b1cf459813863d43f3c76f17fc8fa90c9b5491fd0f5d4e5b8513143eff082948cb3ead9709eb52da8366b00653aa887433dd175743bef0b30397bc42d6f4b417b1df5f3690d19aec73d63ac08185030ebb5d10ae93d8cb20b6cc17bd82b2691d9348076ea32c7d033c4a89630d9dfc557f45cdf8944a8e4c99e5dc046a4b0882c7aa5d82e59defd486affe1ef9650c496cdd85c1f32309e37581c8124cf35fd2c2b2ebb123464ef5eead10c8e2d7c1b03bc71c339a23708329c00d00be9acb9c24497868958bbdc5cfbca29e77e9c643e71759de7adabfe526c94240018aa30f3741e0258bd44adafbbd3b5ec189872ecba9d6e5843fbc538a60673fd6dd5bdcc73ac9f053477f436f74b43c99c7a71e0ab556b898c7fa41b178b91127d66d7713bc90a46b31da6548ad11b786ba62cfd69545dbdbbad1f63d3b3a6c91ba72aa6d8d01e8148c19244b2081a55051eb314cd514416a35f80a00fc24a3b68caf24108105bf0c2c980bdf5bd149cd6fbbc7420be3a9b362c4e7a27215b442937877131746ae3c3b7c5d096b433c26c93250bdcbfae325a7ab083cd64ceaafd222f50371a50c7c78710486feeedbe42aee671445df3dbfbe0c3ca66697db659cbbb040c627a42c31f5cae5bcf8bdd552a6f92086359927723d86ac934db43bf077ede1b49f8aa81b8b264c1580b4f94f35d60410b8682def22ccf0e86e99525c23538f162a00199000a4ad3f5416b90fcd9b31cea3e06a9cd26e8068301b9030ff067fa63796a1697ed7c74403d2c10fb24488a5cd9daae916b9d37193b755113e985f333188a269b6519097933ac6277714f0ee3642c1a7909d33beacf96961ac86cd332e97bb6cbd642c5e9092b80edf59a85dd8baf680bc766caccf52811a99e5bbe9f39a9287365b9f910fb45144f9a7cdfe373cd216b40c57cf89b63323452c38ff289da6374d3556f90a0e263c3e2814d80946dfa646c78c4c2dd1fcae2974f3f106d8760ddc1087b385efd88afcc2930845ce0e09cf1bc10392975d586b0100a7aea6fce6a7d2d0b89ddd9813dc2ce08ed181a70c6ec2a6819698f4a989920e2cd2e43b1f0697d8014ed22e0ad508b6f105266adb63c1554850d50529867a00260c2e22dfba05f750d1ee20f5f91c8234aa3914ccaef1bcc9f7974d884d84d2b894b2045ed8feed680c0ab24ab32ab8c34bc1f0522e6207f685ba1cc54ffaf83e638094a7db24fde90cad0f6681816b2ff9c9d592453f7e9f842befecdc39ef02678e5c903ca6a05784be989b475b2f8b26f5fb16ff7319bb8241b70136149832dc846e439bf54f260f67e768f260ebf44d43b213bd99cdff3e9f6ce8efe6b4d4abfc6781ab0e0d1156704f7ef3de8b4df8bd714925ab34fdd8d06e2b8243005bcdb7f65003f853e4a58e135da6738619e0dfdfc5cf207cad1b90964be5392fd55ead3cff64d3f517b82926ef196853e11cc49aaa803cbab253319e553004dba1a8caa4004486d7a7d4da9e6faf9ef8302e575dfd09c12a1289ef60aa383c0fff2db43e6ef04c8d01bda9d6106020126d6d84a8a27aefcc49965bbcafc704fef86bfc76d57f4b04287cc0581ebda09b7fc6c5cf131073de829abfa0da15f077c278a0a2fe735254bbe8f9ff3715acc9e4dabf128a680454b81e175141e7f8ae8acedc2628a755d719e0344854aa4057cace1f37f2599c2832227dbdfd484826d626cb5a970eb2b283777b0b495e411bdac2b57f1090ce2d5b363c5508ab1fa32b3b61a3210305ee3897c4265cfb2a78877f99f03285ce0c6b4cd0abdaf260fd92be5f43c265d19822d2619658ee57fe77a85e212038e6aa35b1a40dd23e4fd068e4dbf1f469174a13ac0c0ffa10514dbe568df3702a7769a845464c2e7e4318cb18081d6d35dba979050e032dfd00690dec3bece7a636591d90e1203c19101f26b6673360a704ad0e4f60c4e84bc3a05d063388b6ac7b2e14902ab12c00a12f37ae5ad83f2dce456f1652f1d06c84eef81507776def9928e2508bcccd47e38a954097b208d9083e6ab37f92855b7a87f2a891a341a9cb73e1eaa47eeeb3225770fa463401f3cb61f53d4bc5ef4e7f162162599bd755e1f3fab6c4175c54b8986d653ace07dfa7332cc5938ae0518d04142ea8983c17e0e66b25ef35c7256c84f6cb1e59bb7f29d13d3b19c0d9fd836a261aa7a75d1fc021af7ca864111e5d7787360d826ce10be8b8ec608f79082732d546e621c12fac45c457b37e9677b395c6ee39a9ebdabe52b1bff1c83e69bde765dbf977de4d6d237d3c5c9b89bee4d7109cd9f778a050b661e32113d2a16058990b3725183d33da9720db4cc8ae164fa43f9a895bc119cf8b1f6dd3af745c8509211ccec3489e6f0b5a098f7ae2aeba4442bcaa495d87465810e38ebefcab40197856a69880178fe7b4d69ab8c969f1c3ba28630887bae3f9a18d2b30435fe4888f516bea316c9b3b91ed50b245279bb4c37a9acb800f4f8e02f4b476cba32ff11cd212ad301424c3d134a8a3893edf76f0326398dd8e8ac41618869cb60478a066db2e4c48682b4941008b6186c20b87a17960de3cb36abc9c6b8f1751d1d3beb3c544b31b04f9219bab70ad67cb05cda395be78bc62a00bef95e9781b6c45ebaea86e7ecbc2d29667d30ee77a9ae54cfc6dd2418423ee1bd26b5d9be8380585928bbc93078a51357b11dd4c2d90f0730b3c4acaed1eb32d901d31f3c33225885ee052c6a9f89aabae8df7cbf27730f0b1686f9979c48cca61b37716cf3929cbac70d16a5c7124e938a95a6c00bbf312ed9f4ec5fb3f8245e22ea68cf05497d11938d8f5261ea7ef76d38c4a2f66864f96f58e28426925ecf0a3709d33483045a1e0393fd47a7d280524758a7605670847187cec3659bff03bafdbe98226bd8f3fc45f41b60c973a635bae31eae1373de1fa63014a9e6f84ba66a642ad42e67eac4b0aaf76bcfa3db0d6930a5037e5a3fd66ea0f2ba45ff33c4ea9004bfd67d4376922afdc137ce2b13e31c20c557e5a39fb97255d987b24bf2a0853fafa864d53f93096bed7df587c3d6b83c33959b5c84c8cb971a02c8aca6589f89ffdb59d0cdd9af0653f9132deacc0e28756e756c6a313154a88831cdd5184fe36d256b2e338741e52dcdaa95a649317b76f374232eb5305b7ebbd61fa8f7e1b9ff3bcc52a94b72042bbaaafda3496f8bc41266d38cdbf2d8893a6327a907c746f09aa9d8f8adb6f630ebc299852930472c5ed3fcf5bbf6d508b1193a1bbf5b7025c14f12b43c36270c116e454265f406c18cfacbeef65cce21211574e9b0e4aec00407e899d860160c05a6c1d6dd782ddd422e41c5a47cdda2979658f1dcc102a8888883e24f4f9178aaf213ae2301a2a1f81400706b942142a86bf75935772991a218f97fc16c53fded08dd2720cd7c82f407dd8b43562ae82327dc014463dd61443d24a9cfec288a41793cf565d1a2d5936faa3d5e87e6cf26a80d95cad43b87d63b54c58871636a1d2c146799ad3061938a7a3297b83d0a38f66c8c6b94516b98766f11338845dc5e9e03b417b6bdf16e8312d40232fa395d015882f27f1c958a879693f1184b71b325d21c55603e5704ace20ff1169be22b2ceff682a0c00f8324d6dd42a689a9ec0eebc23f0846bad2223cf4a76aa74ca768d398151570ad651506ab2418fa317f798f5ce85551a7de7cdd6bbb3edda09177ccf15c1c3eddcb96ee4c027da47170afc91539fb18e72d58084b91b162490d6a27a2ffcaab365032713f533ebd052c799160c4429e4311d153a5d9f278741bd54f9cf285477839882300542b8f5820a508a3d72c17269cbde56f749b4831fe393647b135cbae238c73d61b7e2f45ce7e050d9c97a016b8e6884e6e08b652787f03912b29d24913620cb78ebca4cdf502f1f05b7be24a3a41bb17035365db78dee495e429b278a3e25bf03c2ad74233602cc7935a4bd8efeaa638af661291aedee802a1807ccb188749af5641871ea11a798e84ad5e3b6436d69a2c44ca9e0f7007b6f3f0b3e12f8497c4f5559545855bc0eb27af1fc1077a2f262196dbc612d655171c5a49a33120570e4c81f9d20f3b36ad7ec6b10baa8fc6dfbe7c949ecc96d92499ac13ee988d57f68da1358f4be68a116ed94e34db297fee5ef19ef8eb2e4f15cb3c4971d27271502d01c8b6234c9d8f923492db2437489e524a5b21e5266179d03b9c8df6e96dba8391be67c44e226216145b5595526f53a72727659be9912e828dc465652e309a2d816c8ef541af99e309b1cbd20ba312d7a9be0842798770ff067028554c4badf4aecb5f5e5ac3f5dc1362bba3f93b973762b880f5961c3af09a7164738da894c43cfff182e88cf68e70de5cd3acc9dafd76cfa8767ca94185016b7c5e8f881e6e6a19c12b52610fbbd76ed758e130f99f5d003330d0aba0b765b598996b39cad36e673edf1692679d8630392b1bb43cfa052e5ee6420765b0b7354de5d5b32e87db70255e755171973a848fea64a8e2fa24f599276598043b06c329e3ffffb0c56c14246b8919e8014c3c4c54be6573935d2b66c2d0da50e2d5ffce8c5bad7fccd978e3eb8ebeb29c71ab54eadb1dccd6a578c28ba718b67aa99e678bf38e9ae42cb309df79516021c804088a6a8eb8216a5544e9130568780c2857f56070318bd8a8723bb98d9a464daa84de3d4be818e2345bb741e617ceeae32feb9104553e9c2b3a2b44ae636bd0d64994270d674168311fabab73da72f962a0c64cca12d5a2553c1815922b64bdb77e0b231797ca544f5c664f5c2f18a84e71ca40485dc60d86feb1879773d1dba4cb43e7553cd9aa53066f38e12f7cb58ffeffd3798fd84513169f1c8014b4fd5902e2950859e79071936f1603ca613d96ca43256913200b477787171c75b0a39f8589c946bc8bb92363321e9969f2227dc7df29e51059d84728db7a64247d099e5b2b1124c3eac8d9fc9520bc16a6c3cd4a5f42d609df8ecd556f6ca4be6673782bfee9ff5db1bfc0daea747092c8c98ea8720b69772078402078f80d309957c29119c3764e5131a2a7b5bf694ae976c5b2ea47d678757012d58d3295b2c6da71be7d6a7e830d11967f58be5ab44eb3505f01401f45b64aad58212d658f5cf5bcf08f450a4ebbf2e35732a9725c8a9734dc4105e3b1b461451903ffae55c067a364a1fef9447f95ca7856ec4a099eb43a744b753bff32a382b1e013d78a18eb48fcb9a74a97c9264a1ed31f094603a0f9c2c8756220e6c585742c66f10e7b848a6fd718a89f433dd24465fb1dcf51f3c5a7af47c475878dfed2ab5d03f1c1bba31a8065de6ab4df0dacdbce3bc6244aa0e8faaa5182208098dbf1bc8ed2692c6966acc6d62be123d2fa1d0f5f7e0b2b660692d9a5a769da002871cb1dd8a5781fdd0671eab5e08e5da5a73dfeebaff94cea80234e98c1bec3ea5419279d9231f89763ed4920ebc2be9be45ef8f4122bd8b29cecf00bcc42beb30220436847e85d52cdcd767b9117f1cac772787d7faaa3f20ce4fa0c757bb6f10b48b3fd93ff3ba910f263438655a9c1fc9f06e35d222662af2264ac6134ee97de8e0c14a4ff7078c5edade6038c4a0ee15ac2c29986c7c4a52d0aa3f48cb71813f471dff2d52a052a21d43116ed48f39d13dd7c4704728acd9d7921ee2f15be7700c4179b666d1d867c3b40973391856501487c837743daf4968952c5d2c2372a6e779c02ef88f8ec9efec365012d3c5b34f163009109725e76b43a5885b5138557cf775e384bc2ea88b7e283f22e1e4bf93a06d24415a408cd1b43f4168f89f89d6d1c50f03746e2abc0d5f8cebcdbeace1252ae94bd84a9779d12344b9d8c202b6f0cf109f8c81aac0573fef07c01960f0072422d5808e99f02504b7f9d06d4557fab6b2603a8fc7bdc68d8b3f62494c0f8ea7a4f9af583ea90361b9ec9f67734dd5e0cee5e8e40ebafbe7499a54d7ccad09d82987601429bd3fbb380e3cd78419cdbd40377f77ac8846c1ae9b67a0b23edd49fe7f78ba337445f96920f4d6cab290f1bc9822ecb15a49710ecb4a1f91a2ed9478af74f4822c29bd471bdcb55bc429d75602d7dbd38c2a861c5bb4e4a30f6e74a95cdf1f4bc5d7d896da59bc724711d935889e328518fd790f696108bcb413b0345c0092605075a44b9164f9a5959336ba6dcaa32d8e1535d7eeceb6dc461ecab10affd096e175bd08566a5bb309a01c5960014bccee4397ad8f4b68f413e35117435290c2ff3df829c9f4cfd95f67b4f4a1794edcabd555f4d27092e53e2d49810a55c0104a17d9bfacca881c8c73058d92c84c33d01e44b7a8a6176e49a46064630e5eeed00cdb29efdf6e7d1d959adea45d766552ec246d603e4383958619e941573a2ea5f8ced48ea2e33b18102420ca124da38c9a83ad9a3299f84da8a3ad4b4d90e2d21693b24a67f9eb34ed623e0137fc19dd0553a90d873b33bdf0a1039c2d8a3c461ed46b9d948476a58811b9475df7dd846c1d1275fa19e6f1bbd1d0b1eb5ba1293b3682389e02a8d78da5bd40987adefc6307ba52f3248b71bb77c6af1f2bc5f8badfb7eb0d98c86622c28a7bfc32d5e4ab128ae8b54d767bb180fb67be0d1a4f38f4c298e926d19dae3afe37a27ed8653344f8628b5ccd6d1cfe5e90d4cd0068dfccab17d8014cec587133d96ce7c41ed92b96c8a36b3fa539cf33de9e355184bc53989e256dcc6761ae3f660770d2728d66a56f46019d9276f951130d87c2a3e7cdb56ec6806cf7f1bc8be7fb15393defbb02f0394db86c2fce2746ca5cb46c1a9b9b1a70f0885bda281cfcca2d12713b639c8d3a9b647f558547e7ec72d3c49f059b567535c6425af3ffa90cf3c235ac13726fe5aef4e6f0c1082471ac2debcb175ac262317dea51ccb3bee1ec85553c2ba85e3ec79de2d5eeaa23fd41298516459ba7a639d8da978e562824f1ddee3898b54d3154251267cbd7d5c6b2861a35de4c4310b346cc9b67cd6b07b7394eea6e6d456a3d2b3cc191724693bc00c9b0c44261c3c8066a53cdb23e1e6cb9f40c73f3a56936798665c285d4920de85273f672f5dfcfe208a7ab5f9f2d1a353ee283aab16cfde03086b0eccb9ce73cdcefb513ede5d1639629d6dbf3d8dd26e10a694055c3cd589fd20df5843377f53529ba87cfd44437a49a7cec8df6241fba74151878a5be69c4164873e92dacb4d8429181b002086e5198f603ed0972e0526293a01e3097e4897880baf54b277a36c6659ff2d3b94a54b94f416868a251bde38d395e23be8a6f205f9ed2a1058fb232a3cb68ec9ff340032b124334eafc5a746ca9b72c1cb642cf78e741dd265384cb3c2e2df370222ba52fa71124cdb2b73f28ea81cb9bc89eacc9b80336fc30cd189b096bf9a2e4d02267a681f078adcf7b062fbd3a96218b411a5818ac65bb42c7d58c3b427d433cd36ef076939ed58e231629b9da1419e897cc70df0809d97679e9ed31","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
