<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04512bf00b0f0c647bcf0f7fa7d823d2d22bd75bbf5ffb7a9a7010ac29bce25560ced77b47107c9e003bd1e658e907c91791340f4d9896841b0a4ff2d66f96cc6fcbb8b1ea021c9e2ea591e215708f7875c51ab07f7aa84fb07f8e12505ee397510389ce8aa88be1cd5468553b976a5212417a0a74ae656b6b7a153e10776f27bf8972ba15a0349a172f6c80904c8aa4a7762a223eb8177c9b7f4de19f592446df0b77f2238d6549d7bb713a196d12cc158adf8708eb5f2965358ff546fed43dee61f1badbeb109888c1545ae3e3a7bd214dade05315daa86722e47cc63b31e0f412d2b0d82fbc2fa5fdf9343934b35d9589370c842ec16a796ff5c5f4ee658bbc314a844f83f05ff53e4db34f864804001e81ce03b3c6f296c83788106a180bc6538aba1f52f009cfc4001b4ebb799842232b0ba4bb2fca79d986dc50a39a4d476b22b501c00004a685e6cfa49b30e3190921f24ac1f1ea824341a2a6fbde7affd500d948944212d1c822580b391ceb2f25c6264c1e1bddcd09e008f1acfe402c90ead450d023782e41ffe5fe2f893aca148e624ab2a340754e3e99912aa7cfb4acc1bcf371625c0b04e343a26e7097ceef33202b893cb2cef95ea55a3fa04dc307b238036f58cc5268077fecbef9bea7f5cc08f5d1fcff67e7bc0f646221db5cd3b0eda100ea11cc1cc8c1f4650973d214c5b2f05b571edce2e56f6de478b10e44bce221be7117b23488b836fa0eaf92ecc5552a4bd1d58a15987d83694ccfb9a56460d43c71b6321e74ef1804286b1429497e81c90e8f414d79a16f212d060418028e1ccea752306332c5ca2ad3e78b264d1839ab01b29495d0daf23bb17820386d19057e75e4798020e8db6899169ab2cae522164187666b79b3772c99213f59dc9c7b9ade052a32be1d760b49b7d133f005eff841b4d5068179c91df03c707dbe8013b785c33b095f06105b6087a42a3d94a40f7e8d7a2dc71ff564c3389e75c5777c7429a730fc2f4122d79c52cdfb5b1f6476f27f5dfe587c57f4912773b072276b3a4d41e18145ddf5d6080dab619559739838a4aa683e3d034a0f2a526340e921f1baf52452df627edc7fedde369c9f74c3ad1b33ca7800e8a4be9c4d8d04bd3c18cb4fec753fa20f446466a54ef51ad9ce2e95ce9c598f1741d765fac7f5b57202ac46e27cd2da18637b0d7bb175759190f9c15c1c4fe150bd6a31c7e1a7138b2f9e6014a65e40bd451426fb58a1300068225b2aecc7380f77fd073de5fc24e91db4f8dbd9f3975fa6cb4c47700da47f7f0ca58059b98027b8d29b4b897b365cd0e82beaeebeb091fc985680efce8568bf1287ed764a06ddf9a8510bd95a7256b8333cb6666ade577076793e2d1f72da7b719d32b3d113d0247111f51bb297b8329d2c854dd40eb1c22d23497dbe6c55f38341e06b701833217f73cd56e7be75ef5237c34a4d8c900b017b3322c75a90d430a791d49a7dcee17987292e0732a17789d311108eee3f2f5ade83d9a9f79e9a9e669768f4654d33633ceab6d3f3a4b490030a04c0b158ea3ee9eb815ff1958dfab0c3a99264440fd5887f2fb395bbb47aebdc68b57d4ac82c9f23e144327a4012af608b50dd3361b88b129f8f24b12c9d445a9f46468c440cb47e855c2641b99ac5f95803f8182fdbb609140bd6e4234ef2d4cc1810d19fb016c82a23489f7bc6a413e463fd2b7f11d1a1ed759ef91ca96bf176213e0e03800e55908e68e99d4808fe81db083bd6def8ec278fdd36a0bcfcefa461fde2997c81760308b53ae5b13f3dc082d96eca3d2d3c866cc42e0f48f606f35b90d362b895d319cc6032b43839b32239453ec24df3d135e9b025b3fd456552a14da858f0872667ac9308468f264fc90703ea8117b4e823d20d677fde144e3d35c1b03347b910f05a05147fb31a8e5c3a89aa28dc6eacbf5224c281a1b24c964839a95826ee802ea883861f6dbb50a1340f80dbacbae0be7c84c37eb53919958f09208f14787caf6f8df5b913f1ca1dc64393c887883572fc004566f20adffd1b73f4786d11f92dd20c2b5caa5a95c204bd816cd492032d7538ab979da2dd15a0a8292ef2cf52e52116098bb788dc80a1af1098f492c613cd6b9a15609d5d914153b5903984c573aadf97c6fb2dc201750ef78607eadfa7556d8327dec6464e35c852c8085e907d26c57ac795bf1b74fae38fecd0e7e9db397dd7086242bd4ae880ca645dcedf88750d1aeaf663431b00757563459b77f6d3a32ede3f4479a901fa29b22a8f95acfee46ea6cc0e162f8acb08acc25442513b15106ed552f46bcb172475f9ea94b72579b9577b650ebd81397d890e68fb45842dae71c7f95f51b98e389c3712b599ef8809d5378e6c869b617b615ee58b87136a79e9126e2681482e731926ea879071032133f7ba2359bd803db625327fb052e9a29e378537f33008fc3f24b389ae387236510481ff55f54e0851d15654d19986e861e653185789923d7ab50c00c230785be85bd7813a05a61019ef93796f6a5e35ea899d44b76cca2d9a45da75eed7c65d181936db55654f824ae032fe61dbc7343197677f58ea692627fd0299d3001899364a709dc278bd2e54bf510d2cdd7e8ae989efd47d88d8bd11de2a76a2571afcc3a233e41037b27ef9836e5186f95f48c798935d01a816fc96f3bc4a9ed208565c970fced4bde911baad79e404851b9a0397f73501967a050354b47b0fb275e2cb7b27f894d31c5ed3d2fd9ac6ed0bdb08424a5c8eba9268dc19987c4a75374aab5345e6af1e6c14e687d184215be794e53dee20fa8a079f8f80e493ff8cdb6cac8c78605b193316253e4fbfe96e5a856195a9d253a6bfc3ab13c3473d732a89c1c0111d0042aa6488a2ea9b6a7dd732c120b3a72589af080086149d25b34560c291f90fbbcf669c368b6f3bceb9aab0fde0d650078c46c1ff252fc95efffba3526d9a98738cb9bbe66880c0fc8f1f5c970b67bda52b9971f95dca967ea50a226b9292f722b370fabcc320bed81bb814dda864dbff0048b32d5b52b662929e834cf8c3e85c77a6d4bad3bf3926155810b13d75fa277235b89532d8cec6b75e05362b63898498bfcf1048ef7c07bd0116f2ec6495e66524f24c40946a9d781cea499f73903b2620fd0150806e14ad3338a7d0bdb6c934c49da7e7331d3476d0e2334222abc418d38cac5d2bbbecd5ed3a23be09698893acb5a534e25ed3325fbb18d374aa6c449bcfbcb934eb15ac8adf1116cb88050265e8ea64b822eae4fa7e9e2a5ab1644fc76aabd0a68eb30085eb2a3b0161f73035109d41133a1f18ce1bd64fd6934ac418ffeec41213726fc7a35096a1fa0c6f1bb837685fd8e59a4fba9e5f1665e1a8cdf0ef4394b1ae1c6d9287a787381e04b4dd870be12d92ebc8b084b12efe6428ffc8e0a63cac03e300366abca3261ba679ed83e27cce68b70d749625208d9f8e681ac8a61350ffa0bd654e538ce5ae539be196d9378b08bbbef1f23be0998bbe5847ad017b87396baf53cbe1e52a25a01e90ab4e23f97a10a61ebb651990a1cf2d9bf124e2107ec149742489c29acbefe9e652e1f385eae9f1754f3ba35cb7b22769afbc8881a6c0114dcf1dd2ca923d82c3d997c1730d37496b03a689df7d67c53e2688e65d4fa13ab018be1b296b7c795cf514edd3211239ff1a4c5d2c113ae58c638f4bddfcff55fff440fd1891071ccb6b8c577eaa4701af2d49c5bdeb588d97f438fa33645b4cf4784d827223512d5f041d1c070c31289e90aee45108c2e1afd9d6e0f87bf593c4bd036c17d22b7e708b89aaf43a22330c01c1654397a0bde179540b1f583281f585495eee6f732df59bbc29ae50b6b15d582ff861fe0288af0cc5796af8f56ad25c85aaa4aa45c483c2247474726e507c21e7fe483d864396751d392b8b4417b5476d17a506dc86819de22b7899ae80a93d080e4ab4f968047a4b0893bf64809eedc06ccfa5dcb40432ea519f68fe366270a39b142da04f7b0c82caf49a895b4979b0576b5e6a7bc7ff5737a9e244fdb4c5da34f275311d75c0c574191b674fa8459377c695deefc9d044f4c9e08c7dfcf04d06aa523a2f0ae19396739b70956518a3a6c60288be1606d59157499db353176b98db87a546fb4e41ba406675aabc0c577476584459e4c07fc16b4ae74ab48a01d0f5caf74edf35b33d82ef50ba24652291e0f80895ea3e4fbd1ba8c7d47a702c8aec2f7aabd3c008d492e765f33fd6f4238370506529c168229b5612e94bd3f4d2784314ac5d239471c6ebdeefe99869fc40b37caf793e0e1ca281a50377b2f799d432daa66530c9a25cf0fa263cbbedc2cb6e34f1ebcade7b61a8a4018384200f79a9b8a3d37dff9bd0b844e2505da78b431f6e2034db82a26c3aaefc09b808f1228603c3ecaa42cb2dcbc55e986d9480f1f063c31b04150d2b7083ef69b7b4ad4fa828a237889632e8d318f8a68c0f3740ab3c94f1ba6f7242e7c9a609a14d35dd09489ff93a12aa818ee8b8a87bdc7c1df7ee4e2ad9a9c6ff2a696525ab2b0aa075fe4070cddf1b4d4cbd94bd92a577b20a239d8ef5bbcab3d4b5cab621d1a35bdd91bef007993123bb7573737941288dac19a03020567271cdf4846c51ac967c34761931c7eae58d9c14c449615ff9950fd777a87956fd9a69c486d49c2220c9937a5615f44a88b7190ba947c52195eccdf11e9f5fc0fd7e2bea1c216dfd238622554b84399bf3ea1fb4bd1c879002bcef113a28f8e336b8cc4329879fb2c4d11628e7aaa17867b6f79ce38f67137e79624a3bdea9cfa9a8708a0f6602c0600e2fd7febf8333393d9ef8aa6312e99d499b6148a3bbfb5a8b3832e28f43a21c5ad452de6aa94b30d28583870446f31f5fb0d0fe22ca972be0c84d5e691f06e5f0acb90adcab9c297787f99807a40a6caea255f265e56cfb799783074ee273b34164a75920622181126e865e810620f2de95f4da33482d1bc995c141029477fcce1ffdb9443062abce74c260d489cffed9db3ec71192964b9190dadc41fb5b91e12e02e850e490d8bc373606d52fed5fa11252e9a5a00304c7667153367bcf23989ba8ab7b270e76058cc1843c72856d177829bf96c0fcef0bb71e27cbd84b3664e6268386ff7098609eaf52da9b38debfc736407df1719bcdc5424d6bf81f911773ce032c5115b2277030310050cc9bfad225e14c60c9f6531d40d0e6e3f96a36ac00530fd4f680ef27adf6a2b0739a525cf6978b7069eaae8ba4237fc9a9731cef183dda5c13d818777dedaa139f267ca300851f06cc12e73451acca345f77b3abaeba6c96fc662fbad60f88bccdeaa3b73c754d4c6b276cbc9d1371b03d8bb294d16da675a487c504858beefb33e5b24a80a24c8c3bf21e21440f57707c709165bc14c2d9bf9f97dd2d5646cf2c25ccfe7e31646b500803ea2ed593dd2b66e09ed58b5662308f764655cba1c6aea2f1806f0823812b8ae01a810290d70cdb40339fbb4fe8a4da2caf7cd7018f8feab07cf6a2ae538fed7affd225306f20c12f47dade0b95d7c339a165be9a5f2f9bc1c6200f914a37ee38d9bfc0b1cc0c9e33f739e5a8910a115ab7fb63dc3b8003834e3a2daa1939c178f1022ea4770e5126f84dc0551cbe96e2415ea2fafdae901e5b53c83f227dee59f08a6e6db6d0064c2b1a93729e1dc75dbfc29450081f22cb42ef96f9c0eacfb62c8683f603083669ecad9d64ba6cc3cb091583239b8302ac6626f6cb116c38af6e69937c6aa83cd63915c701eae64df22deb3462a0b04df29d84e8dd0787365f9fb0a9a49513606dd2c270f752e1a11b6fa97c006cc2b903273f9e4df16881f4d6bd1838ec3f58580723b97d63afb99c6d494cd989a9c26760f50e8776a70fe3e86991b12be86f93e57e3b013c489b852fa8d35f6fa173abb55cae60cf821b5ac9cf318be071cda38c277982e7483af542f85ce7c349b045f011d009f9f7838eac2371f5bc1242454b8a2a76f496c3084bb86f54651e27dde3985c639d3c5d302010ff4e9ff6c7eabe4df59789e38cbb450c54dff77b3c6ce5ef7068b0e89ab022b354c5899a1681acbab672b1567972a2de0c95746eb2918fc54c0d6398de5de863888750b7e5d6b1fb66e15bbcd41ee8f2b0eb03c1702996a3c86e691874cfefd0f48285c0967c32d317579a4fecef0f44d4093b2c9dae21dcfb143e65d53751804b0db3e5f75c30097dcd3d18240aa1c1dff953034e42bfc18d4eef56d31655a6c639ae40ef44464ff552183c76aa751f59d62ff3ed36d9a13db2992769106a3af9d97e68c0fc28d79b14f9915b72ef7ab41de6192c44d78ffa4aa525a3512f0b430e9cb3d6e53e3ec4db81f0d0a5580a1c7086e62e7eeccde2b3df7acd4331350c3c729bd5ac44e0434a585704b6727ac1a1394a71eb362193c187da1b76c97a50e50f0b18db5998f8cda6fe3c1f1f60ee84590cc7ccdb1afc0bd18117646b96859f3057e1e21e6e5ace7fe33522224f66194263f19a570b3b3911564d4496cb1cace985c8ca5888d4474daf1b61ce12548cae71e51ad80e906137e4bb6ef75a9e43bd39588b6ad9ffd1e2bbab2fe421fce14630a3b0b620808695896c7867eb42e6277b68a7f7c1ccc283cc4d67f72ee8539aeb8e184e745441266328bf2fceb669f05b7fbfb2cd2e8bf2edc47a0d8f26bdf8c07018fcaf3d67b504b6a98520754a194777f314178ea40e72c7bd020058b65e0d1004d9d8b74cbbc926a2f2c5cba0f75094402793e3a8ee318467171066a061a0eccde4a4993b519b34bbfb8a326b3f22e642c7a24e2abe4e0893cee819ad3fb80a55a6e232c48ec98b7d66397398301167b83a740c9cc745ed4f140e5aa60d11957502a36822a013282b3ec3eed30e3a3ce53918dc28aea5184db622e16de655d0bbb60186e9cd29dc86d32a215eca6c717e9bcb620ec394e68501fba9af01e4e33b674cf668f2979909cdc9e8252136406a58b5e44876466293df31cfd812d7a09e610ab88e2feeccc6d119470fac1aa6eb49afd4d38a3227402c3eb906cb6efb4b6bb8bb579c13114ea51f56a141e96311924e5f2bb5cf58de7bf812967879b5dd17629c2a050ef90b742ee48b5b2bdd8db38722a4ae527e7b83d3cbafc7b7a6d35ba1d0926408050c92111d9de35aaa55cb43ecc82056e141137fddd5920e6c88e78bf8f5fd33117be8422fe5840de4a642e642600e1100b25dffa6870b05d06d8398bbfb454b11fd7e638e4aeb75c41ed50e791c4b3a0544c1b3ce521663ed9eab842629068610fadb560ec990027e7cf1124823342bd0668da09d88f8be74bf5e74e920634a3d93c9466a3c98a2be29f730b728ad12981b131bc50bfc8fec111aedbf25bc1d3cdfec43684739736f1606a307ac92dc1d681ee1a5a17b3b84b2fc67e9b53e3d106a171f1dd3aae8b614f9b385cab7ffa0a96a07a8405d8171c0dc02882c29998b9d28789cb14ccc6ca9d9c3e7fcdfc6d1c42189df52babf10da2825c0f349a56fed25f8d0c7bd976a2a2e8d8d412ae80d1723e4fbd7aa217cb4b5ef122396e9852552aa6486b9434746e35437e6707ed7243a18ac7b3412d4a5859f4214ac150a03303ef80d8426c34bcabaa10837164d1e14c9990b980d771a15bf6e6b56b460d84ba48e4bbf7cb372e788c1e93440d7bc5e5e00ed040e8a45e535025ed793fc301ac01320b12149b88b851e9d296b83b61c395aa1d0b16e97a49ce954c9edc3d851182911598f579195e2f4f151f56eb015755448de2caf503e69603965cac60dc9587f4c8b8351957fd0c94029eab7fe45812d35f6e2c8a3089cc17781af35074a6dacda2271907a727166a2c41a5812b659da48b40b0e33e97f85b1ee0529de6cb8ad99f01e36eb89be808d0163f89ffe972c586770cfbedcc33332980d19c851acf5a06253d1d396fee2edaa5b2822573f34dde631192b4f1652d745ca8ac62f9495d8ecc31158b7491077ff48816fd5894754820d6856239a3e3640d4a9a8ba2c7b159dfe1bee2202b14a125c7651e999439a15adb8d959719648899bcc144ad592de5db86edc97aea16caa31b29aefc52a525f9018f5fdef9c72866c855426a7f1f1c8855a8b47a1d56a15b77ff315f313e9eb2a8e1c40f6557fe6a2b919f0209cffc66c11141bf2aafea2bef24708398afffa022b94519712cc507e4cc39b1afc147a0a1115b0e285003cf4d883c24eae886c13d64c50825424e5a784ff7f6dc772af7166b6e292e0a8989ab5f43bd8e881269a915491293c5f1ccae579253505e2672770d427d29bd16088366eaa3f56d773dc89d3106575a84946c6bfce6748460edb29088ef937c6ad5626373bb8ded80ab69ca89a5638cbe0eae876a1750b4a823b326fc6ac18777338ec2b03551cc809fd198f85d8758b8f72bc33ce0cac76faa7fd61fc390642292aa35df68a50b6ede5ae1789edcf4a2f27b6b16863a99a5de388ec46aa303a4eb61f3295bfb1c11bbfa69a0685516e9809bdbd038c952eed14d5a6c91a7cfaacf5703d3cb4c55a2697d500e28eec9267cfcb866c939c215a942ff8cbfc7580a57156a1f2bdfe38eab3283c3b68ecd444e06effeadfe9c200dc43ff6eab809cf459be9fc1bfc000c3e0125d9f2c1feec2c8d2957edcf210314e7e86c76b2daba8e8ac1e9c223c4ab01cceff1d9bba7dd6cabf13e7eebd34c0a9fcd584ceeef96a158bbbde3feb3bfcb0dacc8dc74d46fe97cabbb5a3d5a56f0fdde290aa0db9f7a6ae0b92814bb23e3295855a856c9a568f5d645daa6106e5f948007e800db336c8df2bd9db17f1a8f01f3846be291f380ab245a9e2a3f1567cff8440135460ac35927cb0ef52bf5dce13eb347b20733c2b4053f40ebaf6e0190c95c3b7877bb1c91901c054c98d154d41e893f19e5fc3121368dfcb875e8777bb059472050c1e37ef250e63266395996600513f086be4f73840550e20d2ec5f29422ee365d26e0caf30d0f2b1a19cca0436c6bb9530d1ac0bb48b8b0f35ec968b52e2ace9ed551b3a65361fe708c36d45039a85b709241a4f9b5d0ef54398a8ce0291e4f3df1695b6b1ceaa712b72d12848ae1b89a8a332b894f5314404a551b6c2a362a185ec55dbb67501cfa09ac26e5a941de44b3d4caddcd8a74d1218e4a48a7aa39611fff022f0e438759f536fe542d695debc32b7279da0f7f1fb13054d2277489398e4601df1b26ab494a66418db0bdd91abd653325b092a0d74f7373bf57b89641edcf82116347b1effe126e10e1d423431b48680bf93ce965ffdd3c24e3aeb9132c96249ba8e06f81274c90daaa19645b71b65ad1820a1f39ac7c0c0df4c829c1e09c9668acacee35c042c430f608a70d44ec31b547415593c73943a6e36d66690d3f3b7b03c9173d42d354b3e5ccd6e99192fcc8af5b9bfcaf3c14f55e6ecb2ef9f51c5b01cba324aee8c5b770529a7b354088384596b1153a40f65c479aeaf8f5959804d84c0d707ab08294edfad270d5a272bff951d747d4ec632272fea846c39a40a55ec6c0c9943ea8cd6e47da833fdedd89e89351dcd19d3914e0a697a27f2a72bc51757b3b6ae9896c6658b149ddc93e8f4297155522aea7da9a8fbfdb37b8c018d71230149c30e0a10254474acee8108ec93533f90c1c2f78e0235a8419ce8bf4e4ac07c17cc933a0018698b719e2a38b6cdcb4f7ec2f9a392056f5bacbeccd9295a2551c713eae6b6436f4e96b47dda5fcf96f8f4cb8f32066c1b80c6752b0950890522e5482b524544953500db26e864c164c58df1df65cf806836ccb196de5ff3424c58d33573fd083946bac05c24ffce677c1d62c580e80253ab8e9bbf7e2cc497a1d0e564949417b5bb0a653067fbf6f0a456bf17e8d405b2327c40353fe1b61ea6bc641ee3cf4c5039dc2f6d31911a9bc11f8dc8feea588db58e2c0c1c75abe44a349304dcc7b55023ba05a5fb657a06f50db78995d6934c8d582173084145a374680db2ad236ac866c06647937d5805d02666eb9871a8cc2c07ef2a90ec9f75f43695961129ff7af9a702df90b0241b2ee80afb0b1fff08aace25c5ba3e207a6efded81a3e0de55f63dc26e524fd3d9874a8fe496b69df6c2802f786928c0703cd5cb6b7b0e66e5bd0ba8832ee51e6fa5167579b8ad030273048e5882615184f51d185d70dd5e1437b7214c116a2e5ab42d467b530626d83c36a81070ba135cdad3d99483dadb2659ad3e952873d9d6dc8af99983e3e8d0ee2fbfd8bfa91ed2196edd82cfb7830ab3f7e5a607e5ce54ee559ddf3953fab64781f65aeec250f8eb5106bdef0309763b3360212728bf98958bf2999fb629af9d2dc224fdebf64e637fa5be0729a928ffb1bfe700e38b7ceda533c902db67ac30ece70da202c74f94dd0c8a03f1863cf205a1f9b0f5317a464e376715b5705043166a1f3ec877c93fb077705511423126c1439c46ee2838286993f45970fb50443b01380e2dcee23225c6395cad9f6bf1c261aeb476a5a8976278bd38b55991b7492617280b2e649f80846c7042e0a2240014f92144b9f1bcc0a0fd0e66818de4985b6e607539be714fc383358d7efc93ea34a05667f4ac7c3e0989e0168e24a8f9742f96bb7b0706e7c88b251f5af3fa7dde08e71f33fd2da99c46b9c8305cf66a4c294561d61b36f0c7d8139c47c5c37c37dddbce0f044eb4489610133e7fd7a9e760343612b375b0140b5d83f1d4bbead14c4f785069b049a36bd3118ef15767f93cb8d427cf9097d63ba19c4764e88e494e682157b561fca0c597bed1accc016006be4960ddd3e8139dcf2765d515f39dbf8c8c9cab1a6d04f15ad4fa97f05eea43974c7f36d4498662d71df2ba83aed38c4614c90b22e2ced82da6c7d5708fbf505f449c8ca68d15e93ed6779aade1680c2fab20929983bf3b8dc3119a22bbdf1f6169a550c0fbed1233a3b1fae4a8a890518f71d5b6bbad5d8c569e6f6d30cbe0144989245ee10394e13cdf5fcd83cbefc55955c9aab121032b2ca430f6e35aedd97b8c9de803b33a77dec40f9cdf5abf9c9c7f639fd908e5343ed36f0cd437fc32164720637dc23dfc17cf8c77c7223377e91ce3933fd2c1cf7336333c6eeb020d40819215c764c5b4230007f631cccb99783cd67a5c82f10b0953a05c7027d57b21cc6f98732ebd53d684c949cb70510bde77bf56d44141ab02ed407ee85f96a35d66bd2bf5aa981e3fc1bcd38f7c482fe9ea1e262b5ff9601c2c01a4a4ec9120eb1b81d550c675f97597ddaed8d58e0e643cd516341bbd0a0243728aecfe4d77f02d820a72cdf012a54cb7c8c7df4883804364485edde7a6ea9689dfccfa30a24ef7610676b2f9a3d68f3e36eacd30ab9ae7d10a902c3881e223d021209a21de5d3fb62bf35779631ba91490bc1c02cb77536a4d835781606dc54b25f14dbb692d51c222dd35dccc8d8c7c9580957ee4a002f70a27e254b6c53b2db098ceaa85932b5e912bd87f2ce6aae00fd191a42b7caa33e3d15e09fda2b20e7e59f7f545a5560aeb093218d7d4a439e7d29376e2b2ceb2a8d93763878775cf8bab6ac82188d51c8a1906acc3d54af536bb6e44d54717206384a9d2fe0fe4b55627549d171322cb92c717af745df4d065742af1417c2c41a68cf90474261942b86a980ee4f746898d0f8cc3ca46fa68465765ea4a0f0601ed38ac53a068ebb5db9420e5817941c6c2f08231c9cb85805525572314b3a5118f3c6c3bf00d0c377be3ef7433579a601def973267d776cb5e415fced3701c520ad764b963b6eda9e72617878ddf8c66c83e3f0669d47e4ed25e9077a462c32751e2c2e619d234eb88ae60a8d7109bb0d35d20e3420378e42a487e72652b113da337ce2ebaf914892fb748a4ec8e4fdcb56d0ef816bc0affd900c7f9e3e736afa31cdc75dcfdaafdcf3df011328e54f99f32fc2a600b61ba8e8d8b30f0b7355ea06779700269e6ad0ff2a8bf9f8424317670bca7fbafd4c58015abe69219ba1e4cbc80fb4e1afad7f82c11f9696ce76dbc3532c6202b26fbdb16b44e12a8a50c5afcc41922b88276147b86571979d06a2680349178a39c4c1ca842285b9d5b1c71cde1ece7f46e2c6710aecfdd741f1e64dc1c451bf46c0645732755668d69381c13126c0bb9df2f0421b3ce7ade2eac2a6070108fa72f00233e0b2821b2685b8a7ce753932ae8399ef59102cd95463fc97f32ecf269f98b76218a14c0f28bd4af40eb7fbe60bbd01e317599212f9ee9013f880ac954e280c36e2ff3757e6c6554af5fc8e6d710faa9cba77ef81e2deb5e69fab43421ae5b4a295073b0764c8bb159859f73c218cebffdc6c154a64051b719f734548b7e5bf66df4b805063038387e4154f5ab7046cd3274f0c7ecf518e00c5986f631c3c99fa5b94c43a6fe7923ad8a256c86815b7412a8bc69e2d601f4ed56bc0aa2f67fa01203add76eb0c87b1d76918871d0e5bffd552a7a1720b11ebba3d618040fcc72443537b889849c099945c5de85f643a02f59ec36277bdf3dce1c1506d25810a5278d66206e1941f47ba2f7e658e000216391201b72f24a84a27e67e705c58bc576ad3c68fc34e7ce3494c2e15fd577d8e03fef0eeeb0174d9169a5c6cf6278ab8947ded8a709b2d9be21f06f2fe6e9638a122a68236fa05e065fca1e1abee970c884fa1f7f6dca1450bbf7d1159fe4711cc1f0075e89e543eda33c40e6d7fa56acbc49d9dd391f767491e9827b35a6beccb11fec6c419c00f6533984136854b3253998865be74c8077e076db8fb6a3ceb44ad3ddddd7d05f623f0ae8a71d1dba3baa2a172ebae38eb5eab4e81aa5cff3b375ad8cf3d21a6daece797bb7b97de8d456b9c6186695075d686c5f6f0e4dd91826584c0b0d37108839e7fa7f3cbe805c1135ab542ca71fe5592525a247f950530541ced382d7644216e57101458b2b2aa4ae157626e60122e4d320436b5b7c7276d4016a1976dc7397aac64267740bd6a4dc947930874b9bde0193123e9c7b4fa20f114fe55715f337dd8221a41d3dc9c50e9c913a5a2498904da4fc599280721ea5c410dee54152d082e18fa0cbfcc1933864a8d4e2f47113b850e3af8693769cb62e2067e90f025de19095149930977bf6058aa4971b7649aae5df4caed2702de5fafcec1a4a96a1cfbac75c4c2e855f7004e217fd1d6174f4e080dd5a5370a71bb32883845ab44b9141d03746f86ce4b2dda84ed5a1cb5906a42e7e962f09374fba4cf0c5a0d9612a73f468ac22b6ffbf362d0615f80cb696dc06c0481aab6517c6c65c0e01d26a0dd7038644638b83bbc616fac88c63ecdc9086dbf76212607c2acdfe1822879c85842c81fe2283a41fcee13d429a094810ae66fbb7def353be73f61957b724d7d5357be1c0f94c7f3fd68915a9d02885565f1010fedd69662ed8533e9c7879cdcc228ebcdf7b65a711b5b9a14c2a7834c7ce3d6d4e6e3f5a26de5e87529165138ebb7b053dd2d2bf2e8f659061c93700d5987ed4b3321e04b08447ce060d1023d26484c6900399edca39ea9025de9d8c804a238ff1dc10e399a40132d7277610bdc20fb52989fe1cda9470ab9e124ae7156dc22b55e9543cc82b4af33e6905a7bf4c6b1a381bc4ba3d0cad2533662ddcc955b074cc88b7d3904a2f248e0ee26b3ef42c89e58da260e7422cc5355cfada45e0dbec4e66dd18ee2156d3ad0e9f57bd884b3c97ba017858f0357d7449546846632d1fb53be592a8210f6eac056bd7c0c25cc88c11d280852fee433627edc7d9518f27f385efe2ca75a217bb4e4828bc8b1b386cd5bbadd1d33b60b0fb1497c40ff9fdf38926ebae19138a96193cc7aa0788647b30683acbadbc9cc3fba508b31a712a307686cf82236e54d4e44cbd0ddc58c7598398d799a27867fc0192387af65145b7da38b4ee36321a4a7eaa754d55229bb869d8e4b990656bb3a9a8182e481fa1cf5c806a455181d533594722e4aa2bf753bc0a66816a4606f1dd5b00447b44336422377faf9059a0066435e6539006adbbc0d91e7319666271a4eaecaa04ee61423928c9ca51df1e1cfed446b94e002d8588b7c60ebbe6c48cfa05ba66aa411afbc149b52569e8e7b065b5200bdff104bee3e5be726a14fc4d94609c296351791a570e2080c167d01de7b0bf7c000972fb9ff303bade0695f2a382f6a310ceebdeb17712d29839df2e64ccd63c46ff1b31f40388c6362fad7611fa6b3fbb14e8057aacd1dafd218da36e8732ec9fc20fcc09528a2819371691d0b4c5fed43ced5ad97e958b11f02b376ee57904bb876fbcf4f451187962fd7de5cbe409d7fed83e819cd9b753729751a9bea871f95c5d6ae3fa1d8d999051bfc7808c22656e65397d00ecbed4e2af37705c49a815b1cac996897c1b53487fc377a61cf5e679914c17aa765740eaca5f1cba45b582ec55d8ebfcf2da5ab551470034627166134114af0fd6c36d9e3e2e5bddfa845d1f68ec6a7a265877d5a0193245138f7eea967be7e245c9b82bc53a0d556b4a6a09d65b55a341bdace6f979ce921d80e480e57f5388b3b2e78e009ac0f9b4bddc4e5298e77c46997397b15b1e3dd7ef5ee7cc9c1c78d67d4f571d31e190740b7cdd901b1a8ac7923f4498ed0394ada6e4e8fb8c8f86f6d42eb08d6e0e3915e8d87773e37bb4b4617da5b4804fe1d4becde089e153c7726b6dfedea9f8d23498eb25a36bb1a6f9b5f4cb79ee964256535c68152fdd5ef05b1b5aa5e3f2972cbb4c06f91cc6de992ba848e2760c053c0e40f6f51937a9ec7b923f0f54e75e0bfc75f15b36f425fca48ed577fbf0c25703c6ce0119579b21985a7e7c726aad91ce11f2019809b650ed6d27530810b5076c9b8e7efea95801b79abd5c3f49a6cafbde3dba5c711703c4de3ae44fbcae6f4086743168e429157b441bfea50732034e1b6dbd774eac8e0dba73c702419213eab793a9bda6818109441174b406d3f69adfc2979d47904e9db4808861d16eb819cfa99b008a0e0872abdd78c436ab3502185d46c342023406a10fb19ce3862fb4f2bbd45beb0b5da7bb3d21bb8fb5a4f7801ca199818ab2521d5bb39424c68c0ff56f8197609ae6a392566ca70a4cf235b0c16e74f345860d4fc9d7c2761c79e18dc1876916aeb7c85698e3fd6af9e28bf70c4efab50b72f8740a055e44fbce29174ebc36c27a0a20c1d658ed77002e5159e3d5e9a5bab3a62045f1c5a558a6ac2e4c5b149959d2021c823d98255a8f9d724303ad3f77872fc6dd52ec7967fb6ae004aa126eef6f0703e38ff62a3bb30744830a6b370b4bce7e52dd132446e1bbf44746ce5b78cd5c9c69f2036008e6b0951faf1f51f09fa7cfede0a45f1c77b58b8d808547e68167bbc2d6784f3454cfab9188f81e04efd4127abd5286eaf1a34034f2d19980e9b23783de56739ab91291743680c6cb356f163ba2528e2f03328f8e2e0526b17ad81db8dc25a449d4a71a784498ff8856a76696d8ab11a771fc27090f186c22f7ce1a6645177217dde3ebca29cbd0de0611e181b8e9400a3d0f40019c652b18baf2249a629c0a5ba28e3682cc8819b213c393684920208ffb240ea635642d29df5ef2947db6e31fe907e6323461e2744daade8e46453430ebfbb10613723ac28568e7b301c2d0c7ffe695c709e485d4b93ca4e9989630cf448cb8086a3880eb1ae87aa014c6644936d477839a20033fa5f02e14be8dc574fe144609919b59a746537aaf46fdbee487525a4723cf0e39c92744448779672b9771be15d8c00d6b7eb8f07352aa06c46a8508d58a35e87f0d190b682d0915e1fd04e26206e4dca0f5850bd929472ec0b2feea000b59f15ceacf077f4d21840b4adde76a7686cf23cbf793b47636376815fb6dc5eb230dce8190279a1609b1f23a426bb93acf1875f073de3a6c19e8e75d6b7b5428e6f8811a53d07276584087127f4b0101beef1ac110c0e88070ef094f7a67995ae0bcf8f9bfdc9d275583bc39c2b67bb8dd6d5c27244adf5cbe9abf6897e93e231a6b8fe99f6842ed136195d869ab33d553a52070dfd7e87e89af617286a6c86051e57071b36db5067dc4b55aff7ef16725a6d37ed4c06e9f179eb21373eaf480d650df56383029b5617d0128915aa1294dca8279f9ae7e9abbe6350e9de4f6fd41f99d4b8a6584bd21634b4935a6c6cb7642bd2713d7fd7278d45c0f7dcc0960edcda5fecec6d24d20c3873f43d2c875d755b379b0d18afe79308da6f337dfaf17cda2008aebbe8789105439d9451a4de7435346f4eca83bc830527b7efee8a7473bcdc2da1228140a1717711aa925da9a3631aa5535452d1064e40db38d1659ed486238d5421dd334f4ed9133fc070722de9136df122d555f4435f1a0a21ea5afd0a44d6166aa1be0b1cd70e5b4b1767386d789d18aa3c7c501c240da04536a3ef387dd72df0331ac9a7406d031f8e5ea12499cbc6d1d9d799f0486ce8040d7e34b5ac43b2737ffbbe1b9ee82e2d61cbcee74f469d4e7f54c8cef4c248a7f8c0df7f8a0fde4c36ba0ea1f05ffb4bdbc1f8b2d8ac7d7ad6a9c9b28bd55db8cf86ee69f00bf05b74acb60b8c977bfcde6f1b4bb787b99ad3a1550769b53d4e91c71010c2a7da186a1e3b02df48851e7fd84fd6aae4fd6cd135a52ddb1727cd3fd596177aae20876ba9a37fb0bcdeb7f61dec663e90762388f6b94c63ee4e96fb9176c3b0e10c2bb5a5075b5d10aff7a81a9ed647041484a82148b4330ff428b7093f2326b4cc03113b42fbe221fdd37d58e2b8c4ef1403fa85b517e1956fa4cdf58b68d8b789d258c9e720205f7392b0f988d044ed93896825a662f3d382240e070603be20cca7f48efd61503726e568accc55c1586ffc6e0444ab0440d74c2270f3a5744840a81affa18ebcc460acd3da2fffe47de09851859affe77841931d9a140ab74f676096d2193a4997dccb91c1fc3e5f060476405e7b58b55e6f43a99ac47dd28250eb0dc8813159a4929da93f00e7f520fe5ed680419f2244387b8f3553e40f82e90b6baa9025b6749436c656373bac5345e6a7d58b54fbba8eef14c708b2b829f007295bd5c8bd2200c45ef49696c96304da09eb7220ab2a82498ef645c1d6494c877db6ddcdb0b3677ab6df78d60e537f9c40c5ab3ea88a97ea8cb8e5d9249eeef284a125f7eab243549a86c424cd95566d57ab0fe0603a6462626e103d176a529609e0b9f2a7700564de2277145360232e4db69e18e328779478b79ad5a3a43d56f6648885655eaec80033812374ffaf32e32f6ea37b73e127cffecf1ec5539202a55059916982efa7d186757da5f953fab8b5b856430529e1e9030b73521bea8af79f85d4c14662beae93e63294256337a7904af07be4fdb9671aee6757925876d51d3bb356a73a3815ea0d881a04cb0a59afd6ec5c829cd8d760dfc2ea203740a4e131e761af9a2211d914427005bde7fbabf79d9768dee792188b4d220ecaa80f1c0ea1b14aa21002f05b8b93e455deb05c787c3ee7617bd9e12c07d1176b63fdb7aad819ec27c577174abf3752a8946e308880b3e4039720d2d407d4ff7f6f61b510f0c3f77dce7789dbce8209bf71514f2f6b6bd307938e38de6520e3f5a60f1c73572e9a4f0455a6312ed843dee9e7a25fce08a0cf5794ffb6f94cd56f6519d69f81897822ee56e1b9880a8db126de89ccc5a183a29924c0d7804ea6452fafe4054beb1bd99dc133991028df7425f48590bf1b99e5513bab88ef5eb70e44c8bc1505affefb84c54a6524c8ad519176eaae8d555e16df1ef95b6090e952bc5080c572057f67ea07bca20354f6ee4b4d29afd989d393e10414d508838ccd5fc5a031b08cd9dfb2c482a35fb208ab2c90fa60ed079c6813f69f87d5c3d559cab682a332261a2c7d06b5827ad6a050dc68233c66455de822c0cd825a9e82f7cf4e637efb683a2772ceb841d29d05e999406c0ef2b77738fbbd1e3cedf3dc3e0315c4f2516ae9733aefd921cc6d16c8f33375d23116701c33a0940c8ca8e5a1930624e631746a8e53c2658cd0237ee0f2a7dfb2422241f621c84e55a2bf4f0d74f72f4e5dab951d49c0cfb3aa456ff6e34be6e2fb583f0a89e4874aa93c124c1560c70359c67304e2b8b8bfc256d3f06c7c0a02ad574be513705a9c70a698758420b153a46e71b8cb235afa489d6dcc9dcca071fdebe70b76eac9ac8e81d922c0efc845be18b9f681f9867e22e8299cc52b147ba949b6075fe8dcbc4bb52222d77b2b9561b9fe9e7c6d01219f2d06b0d9109a4aeaf19f559c9bbc37f42b128df58ec4a16e8e29750221173ddd13327cf07e6f5e90ab7abc98149523afa93b3e877333834077d830401df33cee669ace971d6fa61c61f42bd582dccc486f85a9df043c0d37cbb631f6bc7fffdddb67bd09d8dbe20ec9d08df0ad2ca881d6e201d3ac89e938e6fcd77e7b036e23a248e63564ab026d8b66d8dfb746bfe8350d62d21cf6dbe284ff33022d4b1e644345a56aa170eac253750bc26a9ad91459ffac6dd3925fe59f48f0046fa77195269c644a60340ce1e490ef2cef8d66838d233b421599944d90abcc4a4cb15c804b89355ef236ca78e67ee1f58da59e0d3fd106a59425d958b6c18452c6d6800186d3d3b2702135091e6cf780c5ff0700412caf59cfb8590390428ff25671f5fb8822fc0d2e06b2c37aa9c5f4374a126f78b92c11d0fb90cf8dcb54561a1bf19315bbf69aca54a0dc13b48b7caadbc41538a5b9cd3dc385f47f843fbf7e646ec21c4c279d9191bd4bf19d80d524b141acb41976204c595a496b234a398bfc6bd1020d2885ff585320b87c412ed5c9e2cd87a4ef07b430920674478bc7832d9bd36d7d88307367d9c25099841bf57f3c481afacd6ed9e68d367919fbabe035b9878f884c80b10f013cffcee49b8bdc982af162302eac34db03473400a0e0bcf8bfcbd657a59f6038d6b9b57920a6ed765b64740e9077c1f570551691a420a6acee996837d295efe848c9defab1968df8d20dc7e330fe6e25bd6f91f5e3c89158e63431a5506f27b7c283349353a52dc161201651f28c6662146f8cbf5bb5460a1a8e54de31a88c8041cdac8527e72bc7e36b86ad2654ac161cf404103854aa763e6d99e3cf2f796138c221420789cdae16e442fe8ef462057bb4c5c1ce24acc8926a1462fa3a40d2ab60e4f4f8dc3cf9855a384b5d2f33d2f6acdd2e3e45d718a01b8730a94a99332ebb4e4f8ef62bea82b0528841c456d61afc4179cd569925ebb48a8ea760c759883c159e1900911f7ddd753b04ee3d2ec965f25179706302ad4239f198f0866e1f4e2709282e3117f17e2d1ed35c3e018bb8c74e99f85b719dcba2f56c39f42d07e3940154cf849a09bbd3c1a0e0a76bf70272b56eebada8b4cda0cf20ed03426040638db706c9c65b18ec358ac70338a8b03e57e66240a38b565e9841deda4e17ce7bfd66e98b910f58ece8a84d8ca056d8f5c1b5033d8574aaa6f8162a156e3417bfd085f7f6ca7d70f60859c9413c257ecd4b13cfefc8a2fb7ce221204850e3a100c77409f0a37fb4f3fa0400b43443c88279db437ba5b77a6807b76b6475df2c8d6457edfa946bc62f2fdefa22cb5b1180125ea59329eabe0a84d7e08b3e0a633fa8aa295a251b23ab7ad3ff5b9751e41e7feb42e5884d843e58f6206543de73f0325d0bb0582545ef525376c996dd0dc6c8e262be74e0b6f828d04f51c7fedd57f949686104be8d4f115cd4491ce1d7711c2d7732d050341fb1e4cad87623c5b0beeb4d29583de1c3054ad739c6b5e6b00f3ef79ecbc38d5201116cbb9b38d3ad8d0bb14e3e6153de62be63eccde9f7625bd49d02fe1eeb380be602ac4f67a4cfb213cb60211bcdf2a9a48a1741bf1a972f61655c2e59221a1e2f9afe2fcbf52686c8a2963155e6ae9ed5bfcf431ccb2df06f8925fd77608df1207902a44bb972442f4bdfc7527f04f850ebe7066d876472f4bd15756d5c050d62d06bc82d645d2f239529f1507bdfcc025fd58701c46399e677d851f5a1c919dcdcbe3abd0b1c749534a059196b8a06e8cbf1a3425add83a89f46635eaa09c8fa2062c633a8eec5d9f0c92757ce27b8d0992b13556cde48271c588b22b6d7bf703cbfa83f79c149b5a81c912e020887ac119becd6ef80bbfb672b04fddcff8d3ce9ee92a73e03a680248bfba9d4ee324b83577047eb7f59eb39526ded6379497ab936addc0f3bd253137dd4964e4ff51bfb85a7ca23fc5f4442fce28f65c9c73b7a5a99928294c08ccf6af4b44a933ca5cfa0b909c90fb430b2a03ee1e170c24bb2d980d0cbede21b5df7cf70e7399bc90a4d7251f263ead182728e4a81d3b76c0ff171fba45496e1d148a783febfbb23b4ad73c3eb5dfc5ff903109ec836f1d50dfc768e7d19f79993dc98b39458cbb65a5921355b96227a6c6ffda8d2b8132694f9bc0c09ca030defed0759d9eb6a7560f8ffd08ff3c45c317e64b6ddd47f4de67be49e05608740335393c170452dda758557b9dd2b260fd4cd32bc2c9c269f19721daffaa167bce2ba51322516699c374e792a3367367bc68d615e141a3e738cb28804e55c245528640228f22bb32de9254ff21c04c585231abd76b84e0e4307770a3b6b355dbc59cb1015135b18a8b146e1de44f8f0547f892f60d9056381adf9e11583720efefe45f8fd73965eacfc4bf878ff0abbe9a055eaed88a97fe069f1927de6f85503e50bb1e4f42dbede3a6dd42f69ccdc54524327eacec2db648df3ea331f93fd265aded8a3739bd72aebaf1cf5de05891385054aab4786ea2908efa851bc2f6c7085f6f5d00173ff2b904f56b928b854b1782a2d735541f50751f928a026cdb303b08c4ef06dd426e663754648d6ebea6566893a9c9e5d6a7d79a152567eb70bdc065e94b4c682a51f83e762733b84d5c7795165a4b151fadbc2be6739ef5c16275462da9a8c6ab04939432c9c0be219b1a906290285187d1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
