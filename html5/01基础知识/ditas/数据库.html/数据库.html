<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c12a4209df5f72e366f9a0cf2cc304685290962936396879447e93293a8dfd6dbfd13c34eccec3a6b35668c7d6f9090d48338d95ab2b3a43634bb47190515bdf700a726f0090809070179277470d01885a3ad4e56b6fe5aed007dc3c31250428f260c456498db9afdc1f27e47c73c077984f4f29c748229f6f4bc88fdf0c2ad8388db84fdb92c3657e1279cc35d49204aac25d713a7d488649ff897c35f3488a09d6c3eda9a8741fb81aea2116409050c3c5955a384dbc60a8caf2722c4769fb88272aad7a0086f222f1cdf478a4a182ac1735c35c7f936532b2732190c9e36230d5a73cd17b6cd8230277e0e4d0dfdac5e2b55140d09f47a5f6dc3bcd2a4e568570fa68b8997fab07be3e7020972c2be6a7a0c17dddc8d012b11b2d43c4cf049b732c892ccd14574e1112f44ab68700d8d05e765ea1c727e69cdc77750a5a42a760a736bfd71f58ff3c9b89ff94f0381161c4e49a3902f664652b53fde7537b9b2eb7d0d83c4c0ba8e0f928916786bec52918e56053ce1c38b4ea69455f23e864c10f45696512260599c0d35058c5414a653c75543040ff952ea94fd5d87058e02ea0c782e639e9fd869b9d2b3b0fdb820901da3c43944291709de9547c088cc5a0d1ca60368257d7780f7b1acd68e599ddcb371b2b2c299d12fa19d9e3ca29dc32be888f798acefc802ee9b259c233db1bec86061eb19f28e5a5c094077a9d27397e64c0efbb4209b3c253e88460d9904726283fe3a4e73d50eda39672fb36bcd6e4e65b92d4d5adb2ba7b2dec7c8102e1bcdf4997d47847c17ced93bc9627f62e814e8f5533f9f18fa6d49959a26dff483e4856cff5936c68d92c84a3696a2f71427ace93d77800607fc4d25bec1950fbf2ba0343e0454f352ed4ece28a783970596f67e84cfce62796674f2730716634531564fe51a895a963bccfece9d24f239a181e4eeeab22f4db4d679fb31b1588727e267f1f6bbd6c52f6bbd4751df52d78c93d35472bd3075fa1fad43c8888fbbad50a40b3f6df1e73408b9d63200b5df10180eddb62097766fa9d29d0bebcfed3f845c77564cea3c1fd1eceee2e2fd2b9e2acbfd24a31126434464abd0f568e7257acad58885692db0507f02f8e95f2c3acb1072aa3294026fff3b8498adfed3f1b271c73d1cb545a62c368c17facbd61495ae64092db8b8eaa884cfba62b0a3f39c72d09b7ef78319bb2afa233d7f3f36aeb2b84aa4a120f65610ede48717e69d243b4c35f6e7bbfdd714a28323a8e15cdcf00f82eecfc1e106499174f67dc4fd6e06980f2b433287f1cf62ae4377825d64793546d40476b043a758620c0904e2b09a754e9fd65923fdffd941fb64652b6ae70b7073fa3e1fcb2fea330d08fb9ea64a9d4a6db81a381531fc2c6cdf2c3847e27c3de161eafb8fdc89c1c6ccd5620436e7cc1696608effded355d69a855c2cef69cf202167524c287620f247381c259d8c1660c1ab43b2d4ec7475fdb5aaa130a77aadfa3cf98023a4b8e16a23727958fd51e04621638d1e55ec526cb73dd2249873556459ab1087b9a6a0f492ac913fb90cf48a1d3b2f4d3947a939f8c210ce5c7a493104c1cd70012e210e07c7c3bf7ab40790b0ef25eacad0a7921a653e8b3fea531f3c53603f1ce0150dabd0c3148c0aa3d5b1b72237497717d7b4f1e646a4efc5142e214d74384d744cec36075afbb1d20471a1e5dc5b5b5e927936f02f3df3d9f799aead8c12092941f95197e50a5a6715cfd71b3dbe7218830afda3148385dcd77bed227474d59568833939d7c963f0d218d988432b3d1dce44a5618e503d86a04652df7f6ebbacb5b4c778b8b092a36b19aa8447287742c7dd0f7319497af2556566e8dab30afbd6dfe2975ae9bce067a7f32686da4eb0cbfeafe59eb94033a19ead1f8cf17bf8539316923e47c0c107fc1680ce63ed549575bca456495fae9e371a6b83e28aa2eca232fd962325bf162639f43b8d37ee0b0038a9e3ea6a2a2b6c5fe6ee9db42d0aa71f7ed4a7d0b195b1fbea6a647dfd215c400c662768c4a24e76983f7d4bce04888c5fc62a976baf0a429a8cf78727382e187abc4964609a8e1923352a6babb7d6a0515e4c4f43029286fe5cd024ccc3e19dc84d4a7aa0d355b2f938510aef80860acd8a22a04342332a5e347ef2721336aa6c6fc6dca1b118b6a1ee6a0d65df966df46cd975ce5fa6e06c81a0d83dea2a0e011dd71ef5717e09b3bac6bd14220895a6ba3bb377df756f46787cc748bd07c87add5fafef7b1303e8cc4f70d834c31a5969ba650cc541f5ec0156b7b145a4f3921dcb959aaa970fd10368a8ac26e73aa3d353ad33e1f536c6c76189613bfa4d1ac0bfe1b18ac8d96d6ee09ff29f21475af05ca312d743f1b796743384e949bcf4d07d3980b32e1c0ea3b4dcd596717a83a580abb7a87091a32afdd1329de6560f0f712b028342a61e97c9357eb876c2ad10cac981cd9849e3dad504b8732a68ee675267892fbb3d30aa081851f4c207cbf17c225577b68179923539a23dc3c41f2da4ef3a286ff1f20420785c9776b79d22718a2c8c4aa26f0d326ddf3bd80a7072732b0d87a11b43b6f12e13a2d50efe048f1c210512526f3332389138f173eeebd906b96be52490268afa5708d02a9a58023556d76531b2bd8be078057245188c8443993535bb80f6e12639d49489f349374247db5ad94a7626424b9c9399406c26ed73649e5571f6c129d072bae3763734afd7b4b0c9776010965812ea878eab4e80a1ef2c1163469397597c409fbc0f2ddc2aa17a8caa6756024638d95e5cc13a47cf9bfd087f63a9a1853aeb88f57559b349e247199145bc655e9ce8407437100aa5c46a42a0d04ca59e7d19e64ea3933a307fd8a67d6bd256f0ffb204dd61c240f8b69635c1cf6e1250e88d8fed9f769fc8074fea008e54608e8a698c8d47300fcd49cf11df473476ad27244cc2bc1f6df4131e73249a2c4ea7128c758f78d836b8b66cc40dea8c17edad58c568eea8baf8b09ca220cf7c5b60e09360f447c2001467d5ef4003939b6d71d0d33cda59d32c7a656fb72eba7b6425c77327fdc2d8e32b752782ce926c10786a1d6c70e4d610729a677ccd5718800bc84fdd91b6e9e63fdfa34b16abb54eafb4db59b8fcf4ee39fff11eb92f36e1a3151497b10e3747e4ab255c9c0ca1a18b71fc96f52176ccb327aeecdd7a1b194c3b787a0d4f23979516aba554fdf1451f3acaea5552c8b34bd1b7b1cdde2c76ac58718cf6d519f90a82d1bf45204532eefad8b30a3b815223f75a772b7b9a70973b23fd1023599fa920ff7e39eea0f42fb96f84cf089f0282a5a57a0e677191a05169eeffee12dcb4ac6e3aeeb3db5b2d99868243c1972bf4b6e3d3fa6c1c43f00ac88d8053d823636fa336612e7125b09c86cf389da6051b3dc80fe51c422192ef271c6e7fb1ae2f9e2fb5c310ed004ae5c2a3440466457248c126c82bdff84bac1001cd91d5718ea07d44f0ee9953be49bcbc0f81de11a62d8c7088e947a77e3abb2ef283ee0258f9a23584715edd9eb9eb046702a9adecbe7df307212430933fe0bd6b01fd8d55d3c62e43fa7e62f068280c9597fa2ab6c12fba496a631e36a086816e815b4a4711a927e31e1df312c50f9c7924d84a78eff6ea9f9f46a65247d49e7641b3072d6f8599460f94fcf83cfc0d5e8823edac05fb84f0328b9be70a1975397d32173ba8b6ac605185d9cec625e6b4db62385d99aaadd347e7106d98413bf5dadbc55781d9d98fe8ff44756050216d8a839f39b91eb5eb6ecfdce5f9198963a3ea3b91ad46fd3d909afb1ac78e29ff6027466dfcdc2087c8fc41da77fe6e520ec05f96ddd3896113e5b6e51545b33a2575655b52dbc49087c3abec3434675c3bbdac044b863e402d1fc3742b7dc32e30f09acdf57ccc8f6ad88da8d63d24c8d8768407266f651ba3c8c4a5fc8992fa2e7b3a77e2a035b17aed31fd3c63bb9a0b4f5c029df452c664af35c1cb2cb6839c07f1bcabfbbf9e1fcfee22c83165ff5c0ebbe5afe295becd10e7e2a55b8e735d20f8c3f91d92cc7af2f9a4f99f46f072a9e84a2230ec3afd7bf98d957ee5bc182cf3ff6ddb89560dcae708d30c0fdcee65ec61108e092a990c654a485166056e54cb405e8de35d97bd530b689f5c056213f925da0c8f5ecbf00f7b69d093d2b13b70e8a31edd2f157de3be0d9d7b5520cda403ea95e8d19008be2fd047de27f9d298897dc6398efbf8f61d9c5297f0825fb714467562278cb80d57a40910e3dfcf0ff91844d2a011008509981905161750c7d49a922c5241623f84f451468b71b5b3af73c9939d37de5cf9915ba7776367dc1aba3ca62ce0766a21fc638d31bc4b62464dad3422ff5b173c6c1911fd056606834f0d4f5b276377ced9cc4c02598e82ffcf61464b2a4dc66fc9cb49d0fffc911a4f0b727ef17a055f72b42905cfb46c5b6b528f86affbb4a73ae3841f20c354dc78af301233a5044cc6934d9ee9fbd3327e8de3981776f3aeb1b3f32375112672378fcac2f280507e10645247759a6fa5f9f8527ef4684d81a7a9d0af4c20fcda65d6687d976be5dfd6dd24bf05a7385d9f5e39ac5951f5e7d74041a8067592ca5c750836bd6ae377f3da0c68b71d853ae85578c4bc4ce2a29291b6361f12b38da4e43a8b16cac652fd4abb059316af12ee6aa9e6d813e16eb1444645268f76f2c0d491e6f8f04195a6495884630dfa442e8d480e463a9dff6d0fc870b71286ce673879af0aa2d39598894bd1e0f9b399f21c9ca9247f635f128c6472d818584239ce709aa792498067e7ef6a0ff7d8c45e80cf91fa4f8fdacbe1c2c762bdf88dce1fff5fe8e5606066df2b569368a47c0df4f7bcbac755e60af03d47b79c1c05ee124b3e04904611f82b75bb2e54505723f88be01dc78a00a8482979ece1b6d1f71dccac20236187f6d31760a8084b189ce96654dce3c7c31dbe6a49cead741cc90c25c438c98df264f2dbae6504c93a1e28b55894388e4e93304c65c43c47ecabf73b6667dab75a3cfc47ee0403c04c1f34e0e5c9308e99df738bf54970d462247750a85fadcbac0b9521046ee47ed9e511a96ffd64ac13eaaaf41f2a70d462ac2a6e38519d502411ff1236febdbbe1e3f9a73099921173713ff2fe90af915942506f35c0a9528899047d9fbd4f2a4f1c4158347d41f1eaa94195d6dca7eebe8acee5be3e54c77f182b90b2380da88295ab593078f30fc256769a4b10169a39ef74648319adf43ebab25b469fdcb2493e748e7eed7a293b952f80ee16e8c1e22fd7c855ce4bd2fd03193162c83d04a434d569523887e22c666f966eb98c10004fb8c29e23f763eb17bc4e96f3fd02c62c96b4fd41b4d33e1401640cf26e32d2eb18fd99300b15029548b31c1a85b7fff6c773a75651623f5de7c4b30cdac5bc706ee3bfd16288fac349fc9e60a81b92c8b27676ada93b94877e671421ef534e05fa8ea0c47c30732452d9d2bcc116268b52d26c386624c5dacbbbb57323d1443ff6f43d56bb0ca7b2e6d1911d9b76f51182783f5a72b219f5d7996d78b49d9d11ee250a8c413251267e8cd0225f072d8bc3f587d0c0d385fd238580eadd5ddeb22dac826a9f14282fe59fd66d931d6d0b34bb92249681efee39b17becf7e4afc42b7fbe4ef4693cab789b2d09029ce4ba6890ac5665417194fde43ebaf1d32c1ef893070752e2ee97c9d8a4d077d8b66bab5df3b93192f88c19f136e6f737b06dd40cc798d995b7b77ad83706df199667888e0180140d9f52be1cc93b38daa83ddd0066675ca234e58a378ba0779db15b088bf56dc7ec52b0fc349c191d7dc7a76efbf48637eda1f88fbe367f73c125b2099d98da2fa6e3d100a218642a58b66949ecc7ae760d66b851e20821541ce35ba5ee99fc109fd794b56aa36c64faacede3f7e72efdce4675fc5ef00d45cd44558f5ae0f616866852069154f1357fe49eee14e1dc0b0b94d8245113af66b584c3efa032157dc0e5619de6d864d149603bbeb1ce4167f744b32b738f188f044d5d19d4255c7b23997d9e53084ee38884af90bad79184a262962b99d980c7448e8a2f7100cc0a14d1a88ba7df55e828b602106a7469cabd31730e82eeafbc4a1bfb7efdd00a2e1aeb74902245dccd81f3886143bea24051cb23adf29f9fbb2bbf08c4fdd52d25a5ff668600a5ed1ca0b45061f3e5cf80a44a7c465fa675e486346a8e3ceb9529f65ac0ffb382e795f8a8ea0a0e6595526b4767a130d01057c006f239ec1b9a9e042ec1f5d82b6d9944db2f2d9a3f04e2dae6f491c686b0c0f097894a609b65c7a07d7617ebe1466748614635bc048a6f5352bc77b9a8c3bb4734eb791c537d086fd63b9fa267a43fda8a01fd8c60bbc8df4381d21be99de770c096b7be88bebacf0990c3b1a3a0fb920e4cb94a4ca730c09dd5d78e936a0f17fcdde89f494db6233997fc5e4361f21cbf4a48c845de11230c65badb647e86dfee28c02bb89662eba3049a8dbe8f972e51d7d21668839ba58684dfcb77e8f2eda0414eb2fa406dbe44216a01f22023e5ebeddaccd62e4dc45f5da9753bf9fd3a39a909fabd8acc0823eef09016d1b535b2dce5d1de93981da0e339bdc00cf1bb0d9e07c7aeb32a4b11dbe7f124fdcb8d101ecf57f6d85f6f4b44b23bd11e658c9ca08f679ea180598d627255059a54b73d7e8274698998b2ebf34e3c4b065ca9716da93fda937266c0e687165f1547fb5a537ab240707dff31082ac486b844b4bd99b5eacc54a0ae4d828c4c56afff3b15061823fe5efa77b971f2f214b5ad3f2cca89c6efa443ecb1194e87358d4af68bf8e86daf51a215a9616291389dcebae0b304193cfd7b15b4f551623cda69515f5166e3f33780b15547b9b86035a0fc57956e7ef76f183316e73153371837f6a316f703495d4958045a8fb4d2e744de54dbebdd72541febb2aad5d66040b337d6fb2efa100ba8c287e3da8854dc416b55fd079750048b17af10a4d09a81c90eee6898a64ba48a29c8362d012f0019bc28c9cf55493fda08058e248aeb4e4b3bd1a618b867b45c8d3b22951d53bbb01d2b7e8aa2d396fad606ebd0008cb87279e3043e8b43d75be3eda99a6ad37a2d5454ca376dcdc93dfaa765e4f3c5bd03564d611b571b6a306e621297a1e65171c3b0652fe8acc076106f18f9bcb7408e8ef87a0608790c8e1b59aa212fcd3e533b6a3c24d2f991ef2cdc3a3eb02324bb6e0dc8c700eec9429cc35141c178aaaa146160eee1a3cbdc148539921e32c642b2b12d6d4ea09f4dd595f16488dcf6958a38679445c35d9189b43d59f3e55cdde2f0ae94c1ac75d846e17dcd719e83425420c12f06fed9b2f66c7aa8d3d057cd94db3b72ea1f9e9b422e03fcec3300aee5f2c9f406d8e05f99cf78e158a3528f41270658d864758f33475fed2461ca87991cc73f8004d2112c95a96667c35da190fd6ed0679473d022c563d2790dbb348825a677e2f3fa810d1adf0509f1579eb4f1052ef4544763ba8e200cf5174703fa7935fab34a02635cbc8504ee524c9144b914bf53ce3a13e15a7f9e14f7ab9be8d08163a218b97fb74f651e4152a06e3f49830f2431dbcd62da036af60c43c9d125c31ef19a32ab2fdcece5c9c016b2d5f513025437ee804ff6ea4e34242f5b75f0712a8d817c05a38374b9a569a5f14134b0975f9217d31ed92e4ad64485aacebd3626df91592e5cc0354135749d7ed8d3a9c70ead48516f8c21f3ee93a05b41d793464854fae05cbf9ddd4d953efed5a9e0e7daeb41ddb8062cf5b3222609daedf9e65184ccc40480c4dcd165b1f67bff0c2363d0f0cd671e37015dcd7cb847adac375a0ae77fa8deb8c2f3f021cf8386bde513b104536b4d9614541ed19b7cf420fd3408bd7f20c8681928d715f8168082b8ee6fe56cfbcb47697d5d4de81c21bacf05bc2c228486568ea30a31041feac19020722cc07e8a39f905f499ffd4d08968ff852edc5fee97e0c5c267d67ff31bec77b792a2b71014b641455559e096c7a2f77e9c3851523ce9e39afd8c3794e7b7f0cef1223784dca9dbc487662a7e31a29b6503dbb9b4643d0a99a7a664718136a1052f59b77df4223740cc947397c09f61166dbc64a07e35f87201c28f6fa72f1f679cc5e4f77d732feddd68f3ae5d6778637aabf05e5791e945ca1c80b949b1374a7a77a49244326c3ed488e5ae79c9203d048640f613e8ca345f6e43d259d5ff4db8a8a022699de2925f8db888051218baf02657a1187bb2e09a0ae2d415fff54bcf67db338c7d2164b1459ce6194a9563b70f67aaa49e944dd507eb76de866a7fdad63ec8bb5c2096765bee4ed1c0cf69dfa1c44e55f3338812e03c5990515992c31d6807bf36a805d3f08ac5b0ff550341e0848c10f3b21923858b9c72773786a16045dae62be5d208d49f4f894905255d30d0226f810fe2bb27bec0165bebca6a0743db4c2e1a68583325deae5a4cb26c896dde3759fc155150d62d3db875b737502decd6fc3a47f2600f905936f2c54987803b4d55342911a98620641566d0a7a2926a2972e9c2808e4f4125602acf80b43b053d79c6014540fb2e1f2f5a21b88fd12ebcb2a8b9cc9b3b36858ad7f1c10e0f0ce985a9c27c49db14c30ceb7634c46303cff039d1bea87fd13e6b863f8b61365a2f9ce444cb1ed3e2bcb99efb40d433de1bc17a876810d45eba996f3fe011ca52c574f970178544cf1e6ac642ceca02d21ad000c943fd4878c85e87c8bb769219cc70f3f10a41591825f560a19e811f647a56b1a3621fc412c4925ebfc4c30ce306dfed511164e51b052da225ff407f28c9c2a397addbc9b56a1d5b7be19501ff25fadb11f59a1147ea17bee421ec92cd5fdaae2046e3c34642b4ef8eafd29b65fb9bc186cb28a8539f93a6a54f63e8d967373380164dc444919970e193cda468f550d666f1e6270926d1ec19490bb3a4dc2daae9a44f3a8c74bebff574572c646b67f898d37feab02c8fb7f8ab573f0f0e8e93970721fe6d52608c95eccd6f5843b3ac7647efb86a213cd56c92344dea3c3fed158d87dfa74f79bd665b2685213a6cb0a81764c3df1d6a151b69e94603a5be45336c3bd0068a809a7195e097a5a7208a74983274bfbadc022a134906703479e96278117454d7bef226a8d7cb0a7488e9a525794a9216be15734473416e67592b620fb1815db4fddfa862dc44ae4865cd181d1c14baf08483470fb1e75b5415628f9a598110741bf37bf760e5f8c06053a8a7c8d30227e4711e8cf786891464c9ee36631c6d41794b5e9fe5f3c41e6a6d0b21b54921256ba5f43e0abbd11d7eca21ca4aabb8054855a2ae1cc06a7933877b182f0aa40e535e2225b84c570934cf0436790851afa100f7436264c0e2caca3ed25ba7e75f672a10e350d54c1b3cb980e0e81b1296cf28345ee01689364993e1460670e4db64a307c1463070feaffd85747ee2f09df8c60b1a1eb6199432ddbae2917df8ff807461407a42045856070e7e2f30f6c562419a3fe5ce9e9fb358185ab78c838d10414fb2aa0797dfcb4e4adbd9808bcd597c74b97fd36de4ff87f133e67f2a5996eb959dec358b1691730144ea238eca9aee7845dbc6f3706e87f0dba9a5bac0b69a801494c78b79da97457f573a29b2e3b37bf358b507aa5a6ca919d9e3c2762eced9e0577a172c6a2c1606ecf79da4b987afc0210e227269d61f13cfa757147434752f9ac5d6f3ad4b3f6799d19724df7be56ff659b659e696356e33891bb86015f8d42950e8c1d913d07b459512f101b497a9a1cab00c20b4f13aa53832e114930198942b66b3000e59b97ba3712d8eebe548aa5da1f92cfeac1ea48ecb6062d4d11bbfe1d3f204a2af6395d96a84962b330d25d8840ed2cd4e9977702c1e4372db77ff2c22966256d1da030568fc827b7dc4294f3ec28269dbecc6e0261bd18775154fb8a80e2fdf81f4e05c482cd6afbd1b93bc194253de326f5b5432adc8eb070dcec63fdefdd7ba580280003723dddd22512714b21235d6e2c4d07c36b3d2abea25365d18c693dceef60260a021431c7ebe3d499f7c72b7f62a3e24c45a2bfdb317b7095680b5ea8f02e15245824e1ba7a562c5816d00257fd02ce9a5249e831fab3942323dfcf2b7b466213f9709b425b9aa66efea66a99b63520b91ac4df53618b630701df356d772c7ff7f3db186c20a8464b6e5123498b2eacf38e55e06ff9bc7e237bd7fe918f5f26843171ff8e7d974255679df6431b0953677342db376c4c48a8ff3dab0b7d304ff2c261f1a5d9b3ae1e8b1aa96675ada3df15ac13e9e513be2b31a51b2322dc8e649a0dfda2e101efffeaa4159dca462673866f5bfdfe62e76daae9a5b9e2bee7508ec8074e4b784fc495645228fd143ff31ab94980e25f2e8f5e2edd17fbc57d8c4db7bf424d1103f3f5070d30b61a43ab2900f51cbb304e8b9f9cb8c539b452f5a8529cf3da365d584041f656fd6a0209edd90031341fe4c3a5518a5fc38d8349cc3a597ad73f671675495c8089675f2bcffa4b98ec139e70498f970575da2565995442d40be754c4e474f47a2354db87e62bd560a8b4d9817d14ae4cd9916b326b02715dc289646c0f5bbc64e0c646844ce5ca5777e99230e89ce490ec5788d61f10fe63231403c5a97bdbdd476490fe8ab90a6d0c7b9971fdd04509f82ddfff5599ac70eed447c46d07552c0cb6ada5dce33908214deb879c3404a9d751c980d2ee8fb5241cc50bd137013f86300a0cc436162dfe793c48c3e65576bd886d97a45bd580de9e850036db9dec1dad576a6de260a5ef298ef531f8cc4e0c780c426e1d4462e7a150162962679a75182372e2fd09f06714644be1caca3246351923dcb61104fccb5b8a18265e2beb615d73c89aa3c49fd315f76e57b1957ca02fc1b91b1e24eb0a1377b9237deb733f8f55651f1eea6d92f23ec3c1da15714d57828daf7018fb184aa598d2f22028a811c44c76780361afddb1bab9cc54a03fd83909495d4b7ad26a93ce0903cb5c5df9403827d0f3446da86f2507fb9924c04f83aaaa59821d2c1a098adfd88157ec8b1d32490fdaf37555dfe6d0707c87503e3c5f7430daf38c1ad8f4f593103b0c7bbd4b24ca1bf57920cf80bdb6960936c5f13b75d94b4862106bbc3329d90777e5aabf835c7c62c12ac90f247bd6f35c7b7afac30990f9b7838eddebfae057942672d94c26d1b5900fe78e40bd4fd5c3a1a75152a37744d1d8a1b88b74e0c4039191749f36f8865b1828ef5be3a7a564947b0149a2227b06110c59f88664c66a7fb521374c0e9b1645c1f8890c1cb5ca69686e45fa1b1c24533443e2fa9ea26fae77bf10fa01825971dd4e097fc1bc8c48a918ea7baf5256a3d0e3330cdf588962df380c861f59e97b22aceb26074d14a8d4077878be7d6bef74721306dd085697aa4c58033db0e94ea872ddeccfa1d5d3e62ae7e50f29ce83a74d8fd78bc7fca3556b597ad0a5b99b0d208155bd7e444187dd51bcca7fc6fbb6af49c7b48444e35824941f979ba3e11d9252e4f8bd716cb31f0785659bd629c0679487a7dc9fe8638080fd76e5a81a8ca5c4334306cb79d3ddff1b855aed77d4d4beb45d10728d6d689b16328996b3ecb94a9109081046a208e348182dfebeedd351b70a9a0191f652e047332f094ab11e90960d5fad2d2a15ef8d35b13c97368b599a684a215d58661f80dc40b024c4f9aed02dd0c6cd5be447ed91622d7b3ef3b83dbd5c28a7f98e0e42d2fd20b25ba9886e917e8b79180951063d80963c5c36bf36e49e9494cfe7b276cadff36c54258787180520abfef283447b53f43b0aa0015ca069db6131aafba8a06e93e2ae0460d9caf4c4a3256214d11bf2f5d2f70a813c9da7cf4405d1180d0aea5f1da679799c9a96b3e42617b7686942bc506e5742d933a03d01e6cb1b9bf72f36725eb24b09faec7b1d9cbca1fa537e2152f5a410fa96f77cc1fc44e28f3c3d2dd762c9eb90327611900d7577faaa463e78cd67ab2f7684f601b3dcae5daf244bba26a9fd5b6794181a2c95862fac70429978932063bab183b780314e8f31896dd1605dace9a4f37b9333f5e2f0d4dcdfb3e36ec5f2e3485a1b1a7e93725104754a4a1efc816f8ecd0ea40d4716c32429fde2346e7f2fd40aac14a12b997aaeb4565268858e24c6b755fc23d29c089385fb7dd1b6464f149d81518ee338497336555ad187ee2812c236024b1a111d6fe2ec135693f6be3f936b9a06c447038db3f5ad0cc98115a7d3118775dfe477360c8f4cf9b0c2ad50e6f25f1e0d462fa36c09e877bb9a32340e062af423e6b6464601c1ffcdd2de1998ac1c5b3e77407e158dd308059296748e41934aa616ba3b876b0fdaef09b648357a5017e96fef0e8e0607bdc363169e37f84443d6134fd97769135e73408f4236a793e00691bff075e86ee42bacd6778768b765223a074ae6e7c14f86ebd26470fe0b2d3d89e6af6e817b37393e8bd83908fdf8d80b98a032ef94766bdea68980525fdde311d3287da864cc1f32100bbbcf8d61292f4544abc0ab7bcd71924ba22427192d705eb4e75755d0a612dbdd5e4d26d8d917c88c790d8c11ed194a68c8320947c0f7a5598906ea33b472bb1bf67442d9601f04e4f1df4418935ebae713e44831d8345b79c1ebd694492bd39da18b23488ac8c3efbedf8ce2c302e7518611aa1318fae6d0b7115f087f1b9e956408be9304bed17fa156e6bce68784fc212fd79f8feb2df1bc30a8758131a0a4f6572a36a7bb84ec008815e737e5b683d5d0b93d68c8b4c44385837483140e9e439f43507b307fe5256e0c2a11b5d715190cd3854c097d12326b1e9fa8398d6364c271ffc1d075fbc45406656aaee46b41e9b4dc3acdf479025621fd9edc49d75567d9bfce757c95639f1293eba3a497476bcc6c9f4ef89e0aa3753c856de74b7116434e90a479bebb991d71c258b0a549fda0ea9e3fa2b9ceb2c1cc5d2c9141527110892b35c728224d1961985a5244e4fa06b7358b45ee0a5a68ea2bd157dfcd488b8a9daf5641a7ee8d32bd08eb2de156161eef3e01dcb86dc12d51a6bd943c98edebf425214d793610eee6b457b5c2cb74259096e9bea151031620ea221a92b325986465870bca1c8f657ca745f77c879b5b1085b26355ca86dd1818a3de5089e360b54c22e982ba85b1027215ed6c9c7ae0f77383628d3802b53fe73a8f0c5cafa7a034877595d791b81cc67264ecaaf3b3da68fc4494c235f9ab5f39e98a3a6950d0f5f7c7985f21bb7b782007b201e669194742e8e18beab834072b87186d90ff1c77135de126377f679f8db9b65a169759a8c784da03e6a88dddb8e5ac891a55144de4dc4ac11b7bc8401af58e5c0470d88eb783a9a8d4865752933ba28f0f05c8382d34c06eb536e021f933413dad40f56b170cbba02a375a558ce7d6b1a68cbe0658af50c25df9ffc58557f1e68664e7924e1ae3b6611444e9d382b0c53fc2d9a47501b5541cde07c24937d1302422c1f8f3253362087ce309262a3b231479a26f94081a0815994ea7206498b7a9cb3d484ac7b2432114a42096a2c653ced487483d4e6c1510411962e9292bdf513febe13d7fc1c55eb7cfd0e5257fe7af621c1f74cc0d210884d35fb9b438fb3611bb29d8fdc6a9da82c563b4cf3341741b8be68efaee5a7beee08baaec098a56d16b6903253adad534accfe7e388adb4d34a53bc1670d58f2235ed3674478013e7477cf0d14ffc093ac8d69a570dc805eb222b93c2a681b15c12d4ed921e054c81764da34c6c301f558c0ed334a7b64673de263ab3e46267548ad28d1fd8c2d3dd9322c77ed8f5c808c2eb22ec74950fc896196ac6f0ede8483b1eefb06eae8900dc351df381eacf4062df7fa8297f1af6db0ad86a2b26333c3880ae454601a72efd49f88a01ed73f80940b446a093333afdfb351b707f508c76975c937f28703937258a63d6c06991e1caa2d449be387b806b7aca11cb3ae626d7f87270d011a3f4c22b3e9d885b1ba78ad6b58fcc28e70e2b1b5beac43323ce5e13f57957889fd8a09ae173b4b305f9b7df497deee13f9c38db6839b8d1b5958fb9a43c012296b2a44e3744a132d630907ad49ec719043aae04b3e581e350a26cc272c2c54688a5cdd727cf840bc672457460d23c91f9d4ada44bbcbf55cc3774aef921151e304113ee6bd55063a44717ff373dde7fbfe7fff75688c36cff6324da60ff55ca5a43c5990a2b8658aa6f0697f67122a864211163a2b390596a99f9b9856025c3e0ceee1f71e6ca0a37942b40b827a2c072dcb17c0a87ddc5cd43ab1b0112fa371e1eb84dae15e489425c64053f19892604328303ad2cfdc081451de5292b034366361d05e6105db2bce98e7693b196b15b77d844c1cdaf4085b963f686d47c4fc536d5d01f8e6d809292894671166f694a8143ea99b8a0a360565dfe13a5db0a7dd5f4f1634e22266e0cc1128a6483927d31c6b5c245b8982f97a43591eef0e232bd5fd78b3cf5ab42ca272e4392f9c61eb78d96afa7bfb0e8d85de7a260db89df9073568cd695e31f48724ade3f62b4fcdfadd8dcd7021edfadb29e51962fff8d8ed0836c316d3f9a60f2ad38d64f572fb218aa9e4e38becd6db7b475f6238e3ac6cef0d6a35970381cde9719c050dcb1bd151d20c757b06a1b77a7fa5d2ab94981fd7a1f01a71b7fbcf5a7b205acd779942dc015a07bf526ccbf78974b4588b8fd24de01e772f809d039ea3942fed5dbc64076a16734282d210f17e41dffdc1ee9896f72a7d7b95f19bc716f98850bc0282c3a490a4359c0ccdd5d7e398ca65fa0bf15f8ceda1f9c6b7fb1c5aa9ee571beadcde49f2cacdf5f627dac15ee942a6a03fd0f7f682a73708b38e6ba08de86e03baa06181708095a7d18d418b2b5eaca8d6b38a462cc123e546c69c8254713994d6c77140737e68f0a847e84c28a18227809bd2115f0e61ced46e88f5639c98847249c0d74738cc40af80c48ce5dc1fe794c03b28ab7eff0645739403c9082b7b45bae77b0a40922e9eb23bd188c9f51f7467c2a63004574bb4f5eb105e14bf83216fd2d9ae7b8d416b9b3ca59b32b226997f1d6efcc9c379a8c14b35805a18e5b68a2b56d5e5c0e1d1e6e77fa6bb8c8441e625ffb23f13e2d18a6170cc59dcedf18f2c6511d6d5dd90818c2a211d16e997c84c121d12b531f7141bfae345b864c9add1357973a51a467c5bfdc25bba79f65b2ded527753ac0d9617a9a32167a6287d3d9ec1b6d8eef6500b1abc183f904fef335fa7a29aa92e621790ec6eecfa5b69ff37ca9f0bd578987fa358f983417e73a6e35cf53e262051cb313ed74f949b74bc9dc8770fae964591a9e59384a667c6cc28a2e792320daaf3401d8646868e3582f9a54307fd137c8c47f6117d3c30ed3b46db0c986d0d7ac4622a5aaf5bbf4ffb378c65fa7d916ba0ebbf24a95c476334d9d1c43a1bc6c1866c727932c64f4f5b4637c79b6f9b385e910bcefa73bb384996f844bc474c549a363c856a4528842fd9b0cea73687146b511abe042fc04d630ff333f2d1e6cdece2b68bee27b152366732cdf6df95b6701e20ccbdfda6e005cf132d4362a03ef35fd7fe0439c78040baac89c1732914f5511228190300db8dc8bf252626fbed4929529f45a388c6f7c47600f70917118c7b7a388308c9e43b90d76c87b237208df2182e13d5b2d7688dd8ad209721068fb22b38efa233417a0b25b024c990095df5f8f813f7e2b691039da5291ca616d1e137b32c4a8f722d16d90e822230befb1dce1ac88d1b7f666be3bdd4f07e5f0c5ee456c379ac3b1acc903b957719afc9c1309e37df9cfacb90e03d7475f3b065ece6c35f670bc67ef962d34139cd4d7ab18bef27ddde6129bf9cbe3359fa88a0588ac3364310ad0d5303adbb2b8be0bcd0d4610023580bb3ac1daa635dcc6c7363be97465604dcf07a17747f82389020d01ff5c77fa677a29a90ec4c4b921a114fb6d748935e76517223fadf5ef6e3f1b4af70d3dad29e579561f81601f3dd4e286f887b1880918fec795b9b0f989b3d7ec54a9e04284dd465ce675fd1d2a1fd01333d35ab2fd6daf9a654cb8125191d89285b46e2a7b4b451b4fdcdd585fb8dce116f3fec5e22960c1b7897909912b0419f8fb2f79b90375b27aece9ceedb4731b65e57430ca96040aa05f59ad6440b5328f380e63f9f2210690be45a743635326505c1b61faec95902239cee2e8f1148c8837b8a8d0ffed3a6dde866dcffc2bad5d2011c5e3395b69177524112b5e356daf5453ab8498b592d6a897ec25a4b8117394a71273bdd47683c5731a24365b75b073fb304d930f5c7cc6b5c9b9bfcde3597ae186fe420e4bc8047edd5f0025e1de5c5441d005667ffb4208c5a9483fc798e2744bb04356e66491396cf2a470bcc4f327b5f96fdf5ed77a41b91f7f33075309ffb34a742e0c314a01c6ae4b95801819b458920943d994fe97dad1d7e224054d4564feda61b49ed6efd0eae2d381b4fa4e133a5d42596209f7c0fb337affb2f7d14386db7cdc443a8f5eaa5f0ab0b44ac2f2031123ff27a3031a0abc6d6f5c872646b00d5521257972dbd977aa7fb500fb8ed6041a92b2f74752b141af722033054e074e6168bdf4ce80049ffe8ae7ceeedc0e72ccd2d1120988354aa1b9508012888a11e3da1ca3984711b65fb491573d8a119cabc8a7f67d01183c11834c968ead8c2e86665b3f3d0b877157c791339a6eef4d4e9e3860e553f28358da54efcc4748fb143918e5cb48363893c0b30d19ae85b77181823866fda2b49338054a29d7e26daaab9533f1d54db5c0137cb5c67926df261390861cd016435308d1edba41e2ef05f34cce8406d811583b4d75d88fd6664b7a1e26d2b0af65f744465b20e57bc3f0937c1c8d76cc071364ae0307bf92284edd8341ffd8903faaaa40d2c63e9ceeafa71a2369bd35811e6b41c9b12b9afba4242d6212f26e12eb02d7949a3ff955b1fbbf79c6222e0366d6b1123931cb22e7e787b34fc8222bdb8929447a5baec2142e70fb4aacfd81d4150d4a2aee23a78151810375514ddcd92e0eb56bc8ba0e65fac62a069275ace69aa80b25c1052c2711f97f7d8bfde9d0f2ddae88737a39b13492bb5bb11d2c87c10053130d3f1e4f22ae6bc6562409eac5f44540a48942defe6392b594a7c60d3e621daad90ee3270add5eff840c309a0f4a0cb8dbd0344f5f376b82aca22503ddd61b126be346d32ddb5fe3e8fdd1aae91118c913e8a1fb69975bff591270903664ca38f1693a81dbd23284b44f1d3326eca29393a9eab15eeb5c76316fd5f64ae3a05b53e83bf33c3481f8f69fee37d72152bbd1cb2aec0d1118882e9850fc6de72c109ce40a2aed0326f8abbf02de5b17a9ae5e2110563cb8f013d84e42285659f1e7555134a97c39553610a5e02521ceac2afddf4286338b7646616573ec4ce53b9f225ca676157bce7a4fbff980c581e5131cd2283cac18e20dd6d48b8332c7c276d0d044ef1cf33fc356055aeff8a2b814f981adb076a147036888c51cb083dccbad4f4a5801057e62f7ebc283ccc30f46b95327fc9f52de6f7caeec3ce8b02e6ca211dbbb7032503607febe652a2e61dbabb977522f172bb34db2aab2dccfa8236f44dd505c750f7417badda3eb296b09c761d68aef14c80a091577cd36cbb2713f7ba2729a470054e9af9d5b76edd9403942d0e5877296038933b84405ada0d3efe6bc2814ffb065c60a455e2e40ac8ee40d56b39e3078e329cd45f1c1e42175dbb34546ea1e58041672ef309fa36397cf98202c09654672852b5612a38b0e924f709e6cce6df6057fa5da32c0ec58cd6f5ee1d77e4ca12093ecd7faae9c79d101e125697af0264cc21b3f48825ea0e41ab53cd2ee6571813b4e25f7121cb143f91eec776f2c6499d91a7a4dfd0cf5eddad1a59f316232ab24d3b7219a85920756926f313e8adc82a4908dae28c5ae1c043def135fbdbd7b1972258c2eb6c3c6ca517d616cfa8bef73b94967ecabc9edb328a1135dcb1ed2642b5785c4fb2014505d60729ddfe8d414fe2ca8b0bc6e2861e02c98472987aaea96ef2fbdfdb8827eac1ecc961c66a7c61280fef56099574c465fb256e1bb85d641a62dc68c4f98769056034a71ac82cb899303a8e080afe0a2fe9af183777dffdbc4407ee8000233ea9ff67c710ff6f941a5075c5ac919e3e7a87b4298dff155e92fb366d4a7915b599ed98706ac52d96c971a707ba30f5ea0ccd2e43d70bb2bbd25f603acbb1f8a930908ed4220296d2ed65af3a24b8a41d5fdf8eaeddd1e7588fad39934e931bfc8b0a4ba10ce894459a513d99015fb47a7280cc9d930a17fb0dd069e511e5bfd9df7ea3956bac3930d91f2b22fd3c5f4e4e367a2133e1c2315ffe1b4a1ddabe714d4f310bbf275fb46908c31c580d64b988e49776872ea3d6ad0b5032cf8ee8f050c61daba3a52516f301a56591e6ec2fd8bff4d7c8e6de64193db13ad92ee4aab4b17305a003aa8c3d3b55f96339984a14d4f0bc5d5c5dd5fe657073ffed0da479983e8a0ebbc68f995eff257e139fa41324c29386c7b7bb7dbe5359c6128cbf7daa6af612a6a26f4dd9de4f5ce6700e1bbc275186b1d53050d725f7b228d549904d4835282e80141ca61610fc718072fe04c373ae973a7be5e33f247403ae8f594634f7fa3ec9d4af2fdf340964dc80288a73ca28c9815ebf10ce945168c5ed946f92ce3046d8947bb5a743a8f231ae828715fda7a13e4835e49e8fbb6393b251bc0cf8d48bbd74abf726b220dbb0b80f55ae3e9516a25901b959473656903de1ab298e7d79242d6d5d9b116d960d702180c6f9f54624915db0456e77c960c384dc2db8830493cc0cb36cd9cc52e0bc6fb8ef076f842b9946b49a89c51c71143b15af3cd94d1275ba6bf32ff6f2f93463b239ab6b8a76dac18be0bfea93dedcfd5c65f5d9ad90d01dc6c61a357b3ca3a2b105214a229d33cc39db41c53254bb3ee541a74121c44afd078322b4c343f00ba69c14735dd8a408e5b433e9d309af6ae403aa36e7c2ea448007260ce7a06e35ae7a06799774a7d81c1a5b67481a766cd1f9fe810007833b979de2f0cec817d1934024f0e6ab1e36acc6f98d97dd1fe4884f3c2d3d353a2ac5c1706a71da560799c9f366679b94416c234206d2abdeff58ac50e616295a47d0b897dd562c73687edb20f1967e1427981fd884710e2e6a6ce2a464fa0cef596636e3a490d2250d2ed9207520475dd456bb9388a97880263e170b2af03a3e3dc03cb4361f953dc5e76137af03412039a2b61c8b605093ea57a183ec8a8cdb073551c6d7e6d961aaf7b70bc9b880af9406cb802a0ed34e24e62df36f2991ba95e624c6fb2cd5e1c57dc10a21562fedc496648995cb2c985d78d3aa04b2fd57afc6b789f51204d625cb1b95cdd55008830176521a6c362b6213ba4a7e413549a3ac5ad6ceca7ca82ce4104fcc7972df731ac91aed66378dadfe78ad710bf5395c068b214cc83826afe9cc4d5352d4089965d13d8146bd2debc8582d5779b81c69d59da939c0ca1a7ef6019d35e2dfcffeb4f586daa829aafd55af888ff88f1f288214fec3f8f8283ff79ca6dee1a8895977605da082f96200b2d77e11985c17205505ca48d70afa80168420c80e94eb7f7c7d6b01abb7512f06df67acedb19cf1a6a8f2ab334096f9fd56888b2279f6abe110d7cff340614325e76c1ee4811ac84f2d75427a931c514129020c2545ee7668172e9ba93de918e7e747d5bc637255ff33ad04682d0163628d2ec7da6212db5d5af356815183a460472b0fd1a921eb22f919924bbf7651a9b416de353eec7221a999f3df5bf192e62c2edfd05ed363e28c2674f04f6de5afe4033c6279f1f1c4eae254f848f1cd870c5f680c0bb4a0b6085f265131ec7182f5fc39d75f3252c1cb6da43c287395ae143ddd96adeb6a9e7573b30dff22826a111e8114e932854ab5d749a35c42dd08a3197f7def708f60eeb8fb7ea40b1ec659ca572e0091c8ab271e7792613f5ceb1a54eb60e8739bb4e6a7bfc7628ab0f306862139ae6e757935e85316f7172cd411eb33232b1d76292ff54570747f5faf9a29713dab31402db4408d57960c60eb2c29f432f89b16de446626d75440c303ae26a92b0095db1a8674e8404595555c7db545d945960ff1b70a207767a06280c696baf69f0a1b7ba212158e03837e859d50d35b36be8bebb6789a9cf61d60b39e7785b868e2b473c5229ffe274116739702ed15d50029409e73778c6a14d20a445c1b5dd8af6584400b4896522b070eb6589e9bea78955fc4d8689ea3000f0089f4eef2837858ac0c2c713cdaba371720bdc0b8626d3e361af9ff3ddd0bb8cbaf23e59582f17ac557977aba300bc7f3bf87fa30acd9f0fab9109d339880c2ecaa27830c983b503b07bc0852dffc376919e157b299159e601e2b62ab91b012003e9af0a9b096881b6f6c4a63c0850b700c2712cc92d84482fada47fdadbcdfc25934cec7c1deb04475c919a0a97112f18007f309c73c70dec14a7269ae67aaa9892733eb4e6dcf286685a8211ebc9a7aa75433f91290d5ea45114a35335bacbbd2bb09a322a645cf5bc15dffd3872346d1d32afd3e10f20f77878fac70d050fac760fdd7816bc9066fc8566bcc7a4e0e5a5872b4788874e3be5c38faa90ae07c95e0374c245bf2e0c23bda3b413d23db47e47df7e0ffa566c688e089c9378984a41ba6edeb1a4992861b3e6d51c91fe48746b10dbe93329172fee5f13b363ad74e5c99db5ca3f28d06b6e74c1510328dec326e84678b7f3fd4eb3ed20e0f6d4b69b9d206efd3efd10d3e815dd3d91acbc6172f54a1b4621789429e9f0c1923396fc8e3f4c34c348d08ed42e86be3ce4423d59f0192767d6cb53bbf95b8be2e8e48d22a08aa532be800d5e62b1881e00e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
