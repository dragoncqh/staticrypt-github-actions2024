<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8896262c4b25ff29979fce2c78d3b378bf167499a0e9339b675d8ab9d954b5772b18b4ded672ab01d004762631a94fc3efad9c51052be0d4446f3a2a93cda74b97ea8846947830a65d1de9d8a6dbcbe9baf623380ae18acb647a007be2fdc961c19712f1083da272de35d95696d71411a431d9d3cf4448c06a97a59d90b04594002813a07f5f6e4bcd7595c130ad77f2b8ede6a25b5d4cbdd21144455d3716991e30289081c2a56ad5e6a7f98d343156ffd0157234d89111ed278aff2c7fa97245edf7dce19372c1e2c0a8f8ecd4a5aff37063f704518464de1040d5f1c52173094d82102e73342c09ee8db1b113134f63e645ef1892a58f6d0841ba59fecb01781cb7d50b1265d107af6c2a4e3d2a240ea2f425ffe3b635bb270bd96cc801ffd4e043332a3742c3b1da8c38d396df7184d3b29ca788c41a3fc41a148ca42c8a8d86e3c31cbd487277cc93614eeb08e3b0a56cf22dc4cd64fb13ac2c8073cbbe80eac055a03299f2f5cd93580dc17c7547435ee42559286f4354bd8084418833f63ce2d92af2296ffe2852a7eec6edd114a75cea2c1af1a205a9f2169856ed142c79f528f27be481fb5e783b8d17e5321a50a7d7b1aa204ff82aa778581642756bbbd00d9a3371cf81221d0d2dc545bce1065ef2643fceda02cb1ac0fa551a5d49b4f4053a117af37cdee8aa83d1a11040381722c92263bf78eadb92052ba449b550c7f2a25580e08e370c76777b6bcbb85d35cc2e4553d147ed1cbe4d343f0fda7585a03c26f6017b92f6db1f28aab20eacef4e8aac295d9d48675aef32abe87e149dfd58c54895ba6be39eecf3813580fd3a0cf6d19fd396ee656e135fb78cc47798b4afb793ecdc2dfecab7f10f0061bb9b738dab64450f3877a34bf7539a1abc4df35332d5d05d4eced982a3dfd762c014915606abb862d35cb26b2f9a470d620bd21440ea23f7f97135c9fcca83fd5686c12f27420506c45c4f12c1e43f21720ef70feed1763f22362c01b73ac0f768ed52b31f79361f0276b1a985dd9432489f30079d4022e2e38e42af70cf2981ed074e02d052b9fb0661a97c242672848975374c12779567810f3614d0718a58429b493a82ef415ae639ce12c989da9f7d8c441a804823434d1518b5fd839ccb0b1e98634b422029bfc10fc53eb5a6c76c7605a83b747a6f915ced67742358e1f3602412cbfa98b7852ea7f1992a69150127dd1f23a6cb0d6f47da7a9a9e7877b35e901132fe21cce80c6b4d770f9da45333ed12f39528df2043b0f4d3d2bc8dad6ae8f75dce560c618a660ec731d7a8e5bcaf5ad4a1de71451a73407eb3eabdf37b5a1e2d0e8f67e22309b8cdb5f1b6f11d206e51eb5faba679cdb0a9080e355aaea7abc462bbfdac01f477b9bd0296d71d1bae73e36fc4a6c0d127f1313b9d5862179422606f2c1d85d8d9b6e1e56d8dbe07149ea487c060f331b88f3e7c344e47f302da0631c6b292054dc207cb149fb42c51f9a66f025b7dbd61890a596477154023d534410f612aad7856555a4fac8fe354d82aa2e5944053fa552532f7d4b9b3fdfb9270f48046567a7e29ef808726bd64b1f70d2e8621b1e298cffc8b9b65df4fbda024233b74804e3c9bb7bba35900b6672d6b2972109e1c8dd1b905e82f7f01458d2d7e3235b35566aebf10c949252230267dc1bd3d86aabec47d571e27f8b78f35f3ae34a3fd8137ec89b5b2e6bf84f3edc8fa29c33f776ddc75f08af67831c3f3bc8db78ca88aa13940b098a53b12c526c00a90563982d9ea6e49476641e4a5c3585918bfe4a61df0f92cc4c7a558a42ceb6367b4f21eeea20a54ff9ba7d69baadf10d46f6aac5927d07f958df2be2e70e8258bb75baa05fde7651e50e95083566bf983740ba5c5b15799c958973c7a1b513f80994ab3c16707970ce433b211a0e2662d1712c9b56e0e2d5878c1dc95dfe7618aca653424af3886750d20fc2c50a1c1544b7e7061a54dba7b80fee6fa2e533c135f5918c0751e67eed7d4bb52eb634b3bbec5b48964fe83cdc78224325a5309e298b134127ebd6d24e97b9af4719c65ae28935a3f82bd9f220234aa5829cc9bbe1d5c8f724a6f74ed5a1962e8fc8efd1b2bdd3aa3d1d8f973124189c95360bc8657ddf23e07fdc73b669a3db880216265930232acf3832d7415cc4a2225106f0e40da224faa367062757482390de31492f90070e066b31253061606f3b95aa831bc94ec4eacde0ecd80ee577ad7b94cc4418c1bd7ace4a92d9c8f47022b9d3e42554c0a813ce6262790bc3baad7175717ffea39cf609e2c12b1cf8221fe94ca5809bd9b16ee31925d4aec8d9e824d2bc3dd32d4ded3178358c5388a76ebae297ecaf42f70a85549523756d5e458325bd208fefdc12c07814a5a331a7312e557f61bd57fe5030e46cbadf5a4829f83ee9fe7c2d61a7ead5d89e09666c18af45c73b2098b9fe244af653cedaf6676cc4240a3b2d03c018da5f4721c6c9bdf67ab837136e099b9d349b8594143a97f2b6ad9e172731c1236b782e5f9adb93fb0a6d7e104e81d63459e14a392c456d088607c140980a052853eb0cc0c1468fb2092df38ca8795171664be0a7ffe8f0be3ce242714f27310aaa9b93c00c33218cda69b9d6c82a4f8ca977751e39c4bf11bfd9f777cb452bc256e359e52d7e9c418dd758ae672c7c3df8defa56648858d833eaa6574e68a7434b295f6de2e6be2817c56afc7383117fe219b3be9b5c70554a82d61cc3870a9e79526bb3e5bb6158acee8adfa67935f231e75cce3e81be32faccdac0b359b75eb8ff3eb703c07f9df6f248d242ac0dacffe1a6d502c105ac61089136fb35f63c52c583a9da079dd0451ff750e2132e538cb8b77f0ae7a14dcf9a0dbde80c62493e8599f3520aa06a09c1a4527f667bcb6c52cd3e94b141c8ae9a74679bafba8e3310e4eb24730ed7a773cf1bc1f11723f6bbafa751ce4c837fa302e39b06df85c393eadadd6f6ed151162936614b136de287d034cd76e7072f754d04f63aee8500cc5dec5284d5d04ff8daa627eaf536a8457613060cb47a47095774762f10d79c5b4fdb23133cf121dcb4a161028bce08c5d00d417845e4ebc6e5b57b1d88fa1d7da38f5f8ab5309e08420ceff1f6cabc9d0f89d5c5d9f419f65b4f661678000238e58a4852c56400f27157b6f7f5df89e6fc90e06aa84135dfcb0794743c7a48a4862fa27ea0846e04fb363d98133e067f3b644d7bab1347e07100df1e7fb722eca4a9406cafbc3182fbddf0406059edb21d102e3bac99a1fdcd2753941097e97d0f290ae20706cd8d1da9cc9ba2913930aee47172011dc6d1e6dc4d949ae77f442984ea16b011c257361fe810acdcc86b913b73ef11918218e5b58c7c557769d44aa2e0e5b471cada0e36939b0ea75664fde13680d34439e35ec5beb8b2655f2f2b0f073a8641e4134eb6b674351cfb8a9284fa3e5f94b8ac8c2931fd8dcd42909e8861e70ea5e74292cb7e7ace45517f1b732eb4dab4ebd44de377c96a7a528613dd101c6a9e2f7feb23f24d942676ef762afcc61010d2c62fb56295aa864d256840f23f7d43f40e4df58c44176ba720aa1f7d16ef9192dfa16a7365f2eafa1ab5d4d3ef1cdc32700e3e1525fa509c0bfad2e009adb078ff94efce7d2d8e19a573d6d7cdfd41821d2cef13999a90c881f62b551a45a5fb5e63b545deba1256582afbf22a49c062a4981a518aa7809808ab0bbc35531c8014214bcec02bad368480b5613317bacb688caad5d5a5d619d9461f977fe24f7c75c46e472936ecc285cce8efe508e5c9c26f4accbc05d581b3919765cad4366d1ccd9f2507dab91663e2b42c7c8ffa4f52290186b433acf35ce375640c9ba18310278fb651a4d9c706c9172d3e207528543aafe16aaeeb08e22b8aef6c0fbca86456483bd648058c10c1936f6dd60739ae7a32da57b8a5e526aec650c58823f5ca8f6d2b405016304f47753ea5c09c8d14ef90c1ad6b0e655ca8b6f5982b3784400a27e1c939ff84d79280a8c11f76d50eed9ea30d56cb441aa21dc5d414afdfba299d8620616276f4fbeb210edf92d99346422b81c44459f648e2152c99ed75e8c8906309b947d006750b6beda206ae05aa664cfeddc02ea9e2219d30a85d3496b54822fa4fb31e643717ef99be84c8db63a8eabf1b1f98aa2fa5139568e389c2efdce3cf322d12fdee25f58043bc39a06de896fb3e2e709b0c13e55eb5b0dc1af8d442e689fa127c242effaa579929943d19662b91c6e713c1bcd131356841bd71f9d5a04dff13a238840fde41f67c39b502ebc0eaeaa5af1a493a24c7e963f411dc49279f1cb5b2781c2bdfc8a3654dd763c55df3cc2ff6fb64466b0e0d32cb2f1a216d75b96cb45ab72d36003b5a32fc94f8bcd5de7eb037f013b6cd42f42a9cad0d6f52591890a58ed04433513a474b61094f9a92e1b3a82ef3a14be3e1b4de9a1032a8e9338f499ce4b9c32d88c558722f9e1fe9ec133b75d0872c421c7de1f031979584d236764c71b9d4bd9a552865d8dd7673d23ddbe8493e6cd287e57e48a3111a9173d62fdbd418cfb4550cdbc2e4fff3938d6e20f50ec8b6d4bc975dfda35e2de2fa519be32c43bfa518f9d4bcd7b6c67e4c1cd412dbfffe4e3ab569a03ad7062aacdb4a1ad9bfb19d5e2b33ebcbeb9acc580e669696daaf69897e4a34a49540b3e9f3687a5b573463d04a711e848693a56c864f6e1b2eebe90216e7c747c1efe99b6344c84091c13a7fb44a83ab7fec003162fa806fd3af7f71b419deab756d33f0503c685ebcd9e02e58e656af7a2ce7806bc46eaab91ec5c59b7dec273327347dcc1553c1cd903b01cec4126973b599a17e484a9491f163e9a7edbe7c7b0e8e8118fda14b77bc964b5d6bf2f960bdbd5a84c22a871910d107f52e3fc2dbd31113ebc5ffaf393cc29f86147375a510c725ec6ad827c45bc7e0e755eb5612bf3bca8244b33964212e94f634f76662b3abdbb755a909424a82cc0c0b37a2999b703de2aa69d35481718685d7713f75014f963eb49e3ab320ea2482fc6b56b0dcd77dff8927c34346e6274185d1916159975dd7fc151b7e3eb86d9820104a37a984b942d583ac96ad781dc785ea77a6e02cbbe46ce626d69201239bda41b9f730ddb39b7299dfb7b2796d41f2f43bdd7721dbfb020f28e93dcee686d0fd86d7cdc480a6ce91a3a83ac6cb2eea180accbed12aa6238b03b5f3f2ebdf4cd61fe2968f28231f4a972ab42ab7d926bc72888fa434b1dc9bee5a4dd5ebf77a753ed25ef16a5f75b76f48492cff73f8817eaa1b9002da25625d53b27fd3a85743b2f83a84fc5a5fd828868eca8c02cd0ef51b4ff14953cd512c9965c39cc48f137302a1c5db071ef73c52e8fb5f2018e1a5966d2912121f9d7da985c91df9f9fd70cb76664a82fce3973409789113b441f353e6a3b39bd7862fde4cd66c7d48ff69fe867b23c661d91b1fd85816567165652c473a76f7cbe6f916eebc58e1ce200afe97127f5880d77023e04809a6c797017e271d23a1c0cbd3066689d231660591ee8d814fd130d81544b8096fb09d913dd93eda3d1b65180a424b4fb39d52a4d1aba3b9c8235f4c42956f144dd8cb9ff1d97e87ef6d8d998a62ececd2fc3f09ffd38ee8274d226281e50e48db62226962aa3a419c788f73dad726c2380411f76b24d3081fdfc62857267a021b6254755741bd39e90d8111337bd083407a04190ab94019d6e763302bf8d386b67b14bd1bcd6337af4a97b79450351e9e1e35f62b05dde5c4229e5731aada76e18886af01990fb9d42c1b55ff3c44552d99b14ce13334fe1160955a70e38fa19a4595f5fa712322766efd6d9ef9a2db1070ec74b5cab6ab28ad63c97c27122a53c506c0879a62433c27573239fe1852555016d8a9a6764d4fb0b11be24862e0353d8d4084e15ff37808ea226b0c025afb12fa377bfe6142f850f9944bf47dce74650b187e189ba34f0aaeab4229f67a740d9983e55dd943ca3bde0c4b9ff3c357f2c0189bc492bd282382c38c081b01bbe53cac2bc4928d2a794cc128037ca408fb3c3edcb5f16564c99220e59ce7178a93f2585a0ad403245511953601faf38edae7b9fb652f04f8fb2781cd9da784001a5f3ac21a04963c0820c86f60bae39b6bd65ffadf9d29af8a8dcdf7e4310427226ced26d3d83b7aec9d93a87f7c0aad14408ef3089d90823d47bd6e0817e7ee1550e31a7c5fd8eeea0923e5bad3be7c4e5aff37fc512a49bff6c015dcee730ca822cfa4060f8abf00b9fae1f16cd3775dc0fe458b08e530c8101e76be904db9eaaffcbd74ce3055142a310282a209f0e457d7026be340e13eeaa6b9b1bbafdc39bc97f1c19cd31f284889fcd0b1026693a1e4301804990625312b3f19e289be5bd68d9646229b7e49511de0cd9236acecd80a010a0e87bd24aafb105539ff6a5ad0068c886af29ebae9acdcd2f9efb125a54158f969b7279b23c9531573567f7f48304a9670cd645eba77e9e0be3c5a1964769bd4e52b604b0779d46c1f87f43efdbeb90bdcff1889596b31f062d63c2d8d3298bca712117c1badd4152e22dcb5b36d6f3950f9728a96c2aa01490379eaaa41041bbe3ab8789c8aafdb163f7366d0760cb23283f4fa066046859b78d51cfc113da2f5286f5f459f32c7e91d56dd77d797714d1a8187bdde2e0fd3d37f201d345dadb8bb8b6cc913e616557e00caf19c431071aa38a0006bf9b960f78be2555933a3bb0b38f7d949d50cd017f2379baff91b48577f37976f0da2ebdd79caaaf34accaf4cb04e6301ebea8a644d44c9e6eb655a439a86bb7ff88a6d2bacdf615c397d4cff66a811a940251dcca1f54797d613c594ddc55802f18afe58b366bf12c66b4d493f78dec9d8d555a8d4eeb87fdd5fbda6a22a7da296e1b9a0d4dac9ddc1e7e1ce6ce7b2bbe0fd09995490377d58c0971f85e700731bf0704a0e8939e74b704ffdc1a0c6780a2bf0a124678cad86d579288656f4fe31607f58e883c00d7b272ccd1f4dd5be713e12fdf84187e36386f25d361b062f315c38d8da862ad82ad9bf1b2b463592d4040f263584fb0169bf1a81de91d591fd44b0c54f568dd1217859b88a3110025ecc6c5de065d17644d6534b75a02735ddd63ead7dd6e3cf804afd2481a3ab524694ce9e0ce9d819361258247b6a04684525903464c1ec38f6932450c5de3f771456827b260b7fcb4bdd1bd048c0e8689d58d95c5a6fbe9ce7b30313a93eed86983fcbb1d923bf2de97208900acadc68bab4ed8eaddfad8cfbe5eaf76f55f3be422c22f5710e0693f8de3ff2c3bf63c937c0f5be091a8ba76d0575d7473031f38bc5c21d690d8add24fe4879979ce097f5d5f109883293620aab737fa87ddfb5daf105dddf1598c255fb74028603f6f4518967139d6cd15c817241d8388fefb3b496df30e6c15b5fbbbe2d788068e27d54e6efd76d0341fc0f9b844de39a56cb09c8a4d8d17a34b018187d078636a9c815c9f3b78ee5d4f51f89c5787e2eaa3102fe2288a9cd1e6784d2fcb71cb11fa6006e249d488dbd160bcb8b526e1e60c6ede0e03644a4e5585248f39f5d63cdae827abf952932366efcdbdeca28e514069e33f550d735a37a40d96775da7d12c294bf6493599484d436b9659dd996f6d039983ca33b9bcc040e53dc530166606583537282c912490bd3cf4c9ff9e15bb9e05c72825b70973f33421789a3284d516dc96d2a6b160c9449d174c7d9f189b69dc2ab914c872fba0fb199c4fc63c2bcbe602b16f372a2e455fd134c966e55fb119d5d5b25cee8103707973d7ae91f05f80e0f89d7ac5546d8e70912012606aa3bd9ed38e8adaaa7ab3e8be9454beb6e6d0a0e19fd80d94557ae5cab1e98beda764ebb225d42c93cb601f4c306ed1bba911e851c01dc5c7ba390167bddbe6a9ef22c66e15d1124b747b1ed564f41ad0c16d47301e7eb3b55fffe775e4d4b8e0720df49e1dc8ff9ef282428ea7faab29c167f5750d73205d16f2562c7fd48d7f5f9ec3ebeae1067e202023f7f1abdeeb9d2454ee99d46806c32a539d75cb87270342f9389a8707e1f371db60f927287af46db299d610dca8bd80a3595db65ef83116a7f5e5983e0bfe7f760bbb6a8146508293a10d9f552c4e2e1d8ec197913192e429b54db6107f48c37aebb2ddde113f0ab110671aea6b9118c48d1bd3a2e2fe35b0dd047ecb5204575cef85108608bb629fa073ca708b18a6f031f21308e782d0ecc88e4eaae4c36725f5a9cdba90b7b03646ba58d92f0b981cda6f49484aff0774b928c93c3acca1df5c9100813f5b8dc9e43530167c901167acbf57e9544289a164f21a06f08818d82a5ef1aefe90f3daea57f9c8082feca646f550c51f631a812ca50a8d85b0f071295ad1761674f5fca895785bda22305a0f0a8bd756625d4dbcf6704a885597c09661c32b182ef09ad861310d4df407ea1934ee46bda1bf7996eba842b1130b98ab459a025a90a9abe20a842843db22704de4fd202957d45cf910bb96307fb24e88e1251a31f70e6f2b87c04cc74cb964380834eb4bc4f4a166c7dbce8d29146b063dc9f756c940859917e2c0437aa9a63d14eb2e3c126c7501d0dd2af4704d637782f247e1f7d89a8a7e713cad0a1db6337e445eaf37cec4c6070669d2e014ba32b914b8ef2b0a0a31ef6956ab11400b4e847ca6afdd4e519078d7ae050ce13e3df16d7d509598e8b88740550d371e658ae8b501d8025f3b4136fbdc6d516cb7b555cd9481b452899271b427d3f086abe511741a254d0366cb936d78af70f0d8693668253a32fdbea9a765d7c6a96f4c41916f7141317c6bbe4714119d1630e4418e3f58c7bc8e0c582a3f202555efdc3ae88f79b0b0e73811533ddca8f8db3fe0b792a455b173f8e9f7203581e9f414a10dedd27935cc3e0cd45b8e15c66a2b019681e02b6bdb7afbc50997dc9192768a0bb7af309b09788b4e5eae8eaec6cb4cafc70ae33da704e48b2e71bc76644c5708d2d81c315ccaa281027aa96e164ab65df37ec1bc2b42a4ae3ac74495b8efa6d9202c940e60ca3d7fa7888fb6a2b144e871447929aaff65f0dd9a8d569947354aa05d925211051a42e33b8f46bac29de5bac1f944c89ae54322c7fe4015163f519ed653c7d7d49e6c001496362860274ba7d4dcfdf713c768f9b520dd103ee0335a54cb264efa36706c970016eb9c0f957970382e98863e39e0a4c43a1a81bea6f43eeb7cf1fdedb0c5533d2fe5e9ad01acb65d7dc21547f982ab0656bbe2eb4b54e6fb4e74d4e9c7c1e83ad9af4771e1e6baaed2eb0ab8835ec4440d687b00c5a20078cb19370d9960ae2a8ec0b32c6563a9a759d563878afc847d3e38e76fc69f48a9006744343c77aec573b0fd95380dc73583bbcc388a25d04868c188da6f4cb612ba0da596071a2d8f6f5479089e6a795768c1e09e555fd70bd7eaa01fc29d9ce2c4ac90617e84cb555e799c065af098472e667cf46b3a50c3dc84a1b44142e22a5b036d6232b57c6db394e31dfc9b8796fcae2a88a61642b8c31bd4c1ff8cf68da51999d2f3c84ed54590157bde919312ee320fae0976fbffa286f312a730be131692c3b3e5d5963c448e914a83a08c2147a3272d264e8e9eccc477f7a78a35ff8ef59e5495225009374160f3779b4ba14e919550dd1c893e799f31eac5263a43fd568d05dd9d03ea95a92dbda32c4570caac261f2d16964bc00fc3899f86f1898cf69b8cde10e530e49460d8c57525f83b56429d8c27410153eb6505022127fc8ee2187df307dcf3ae598449f51253d9f3d395b3faf06e44a8df428782925a42cba80b05cde549a05ade152a0799f289bdf0a31cc9b1bf30b0b36761609c4a569035f9dd42f677ad39d7b57ba6c8399d4a8bc998a90408eb6020af773060ad7eaaa6f089e148988083b2f72d8647b9b4ad567fa044af592ecf821cafd10101449dd15222f99a7e1d5b520dc2013a9211597172b1e8621aa4036f86e0d3116125f18ba59f9164044e64f39db700b7ff284ae3fbda85782ea752bdc2798f47dbefa4f5008440220d33aef92e5361e796ab5fe0e80771cda9393b2bf13105384164dbce2c5d8aeb705c48dc8bf42f706667dc283b99082f8ec660589827ef857f15590fa37514e1420c40198b5630ee98d4c75e250b24e4cfa94226aefe8a093452a0d5d39042896e599cd8dc5b8b3dcbf6372f65a8413bcea2b141fc946b59910e61539680bef1eede1a93513d1b8ed2848379b9f2c0a773a7ff99cd996ddcc4c1978f58622ee09f10978f7d45ae13323dd18fba7700c281f251b418abd5128fdae84d6128af414e8074b87a9c80626b190849e9262f7fc1cdbc2db7dbc73c0b2992d6cf8048ca7416e172d799951ce0c2cbc653189fc6c2512b18126a6a818b08e6a388010531ffdb0b8ce7b510da2ac599091cbe3da92be319cd116ec2860f2a36a1e7805e1e80b7b52d75ae217403380e056675374743a808c9c6232e11d68424bb31552bd8e5d10281b9b188bad351bba5eb55295e0919fb463d19119024c0e2421de60fd3b7829c3ae2291fe2bb67af27e85eb22105818fc309c4dc3999dc291081c07ba1860d10d9f58e12285589937672cb2c7fc3fc558c8de2585235550438082857409e73261502bf08aa611a276a46694827e468017466fd2aae3bac976d0eb7f56177c7be2b5424a6b93fbc37c798eaff36d830581bbbee6246d514931b77e842ec181f457f56ca7f2c600dabc77351bf9607da40e7ebe36e7420e1607e02d8b0b31fbf5d585e215701c63332655e512ecea6cb3477fb637a8288f76195a663bf2393245a162538814174bf967d28135875fbd8dd75b87935d9b46a0c5cb68aad67a4b65fd0c71fa8261ac65c40c32f7ce8e09eff4e9d59950f343e1a6161ee86f7aca16ed0f9c0269b6e2392ac252cf203778b78a41674319222ba735c54788febeccd46428e4537c7d8ec8120fb3b6c8967254c482b995f2b4a987d712e24406ea45e583145ba3cd22179819bf517171def1db4d42f5a870059e066d04c24e301c2dd1a566e254a722b7bf20e10c4e91e45c48cc83b948408f95178878a2f919d13834c09d083382c17a1d252554bfafb124e87f0df64ba90522c98a1138c048615c375c0f04f66cd9d7fa0d74e424a91962798694ad4913d58acb1ecbf417c451b45195ce49cd2200b9e6e396113636e20fc54a59fba89e0024ab8a03f3c95a131dbba17cf17bff7c2b88fb9484c8de7e29fea6ca2bc84f85c821f5e82676c298b679f447d32390eb29d3b9700363c30d34dc2c2a09ce0beba4464bf9c62a2418a30a317371f342c3a03d38848421f1da2c7a62ae3179396359d4ea296eb835eb683a03f7d1fa7a9e4224aac066fdfe59caf6c976a934a0327f9b9bbb20602b29ed853bd1b18ac734acdecc671362b601cea090d8ceebf9c93b34a662e30ab4ec9fd981bc52e2e6f5f612912fcea0bbce0a7f15823446304502088e486c22380038512a89e57a8fc8d4da385074dfa41fb3f53817f88c6ba26c3c1be224a3fa0a5eef5b38f9429aa98dd9c69c2fc6b5811580ea3326a01ff7606d41cced1f1169c2b99e49c5eb4bbed31f94b6ec7204e60a16240046548d837eb9b1fc5d51dac3ce44a7b9470cb689c85d1e3bea69ae089690d2c5f24b94dd9593f862434b2b5de9271c2f30e6ba9ea2874a99255e561b0135d1251a3fc9be02a6e9a3a5efbc7e2155496718e71cab57a1dc22c2b006fe3293d24a4f5b9f3874f41c2846a31f9293c189078ab88dca442e7214a62dce1265bd4edb66cec625928a39ffa0db93cc2fe83d00f2bc6d5495b6355f74162adbaf08d769115466b435e8492eba533f1f7fef4e2b157eeeb2cdd76eb27e70660af1690b7918a40e94ee1f8821e855999c37de862e6945abdb0e2bdb656d584346f4c3deb0c85b95449584ced06edf7e89a18e9be4e94677b59f7abe0da85a11e17fc957d0166567b0b1ad9d99bfc5c0015ca1072a438d9602fe6cb0949af3eb944c3efe1584920787d3ac3094f5b9c6cb79cc881507022dcbce72e337523a536605b02d42651aed843cd2163af4a25240bb46fddde02384c3d5ee3e16dba0b25d1e132fc1e36ee03e1025fee72c30fa081e0fa125543d756f44258b1560c1219043453f745a760010aa294075fdecb1428d996f69da029a7b42452c771767795b30b052a9455c7f8da6c134cc0dab1e4fd72d7a0b21034205f43e33ef1a074a3f6052aed656b5b0814f733e0e771f81dc64c7de8cd326d2e37fbe3835654e1b413419bcd1ad1cfca2869005d82c59e89e184c63d3dae1704b7c0d9a68ac38a3e4314ccc07c7631f34bfaea066a96ce490a81198972f3bd42b3b5aea6568f2371aef0ebbad519ccbfd5f380817249a7d57c5e36c4b976b04f3429647b6b98d35b41fea5e68e48d824d23d935a6b08b8b939dceb4179d8740e5a386642b9e54c7d0ecf2996cf5b309530bf149a6c76920138e288e37e82b9b57e129f9618974995aee6d88e3c4de758a76ea92e435905e6a820fa722e73e4d8be237c4c357f21ce4e3af8d07cae21201a0d850522781409dc7370c508a9cbce9f0d74253f348efa592b22c341d2b84ee0334feb4e6090d9ed4bfa1c29b7e36d43b38dfc5a87dcca73d7b8e2a464bc1ea0c1b4e73bbf9011d00c984ff335f0d57c1b79860fd3912a1d1fd4c284bc9198f71b9ea99211962156f173771d84e072a9442b0de0fa8f74be4ecefbc7c0ce12401975fcde1f31234d07736c2b18340fee980d8b78ef661ccfd15d0648722a5dd24a77fac627f6a6e62b87c496d59b4ec1cf1677c03a7e62d4d70e45c242cd00c01e5e36afadfa98cf8c3c759ee95734576be6573796cf3121838822daa53855010157e643b001bbeaa4ab3d3423d930f3a713270775353b834fbd09a5bfee5ccf487922bc217d07d59cedd1c488dde2b821c10a8fcf998a26c27486a477b8865131080dd875b67e287283265250b748a6203fd70b4f7048ebefac34b1e193cea9f9d22e9390117ed2c62995f430ff6b0e602ac4c9d4afce08b0faebb8a0ce8ac12b73469a5ccd69ffac82e32d1ed74f29419ed085c7037d0ea964af893817a23ecc4e249adb4dddfa665600c880516ae35650b43225ae9ae5f5272d1a1a7c670f3f59b964b52039b0cdd8953ac45c0755bf41d7c4a0de1380f94444000d1bc0f8129ad75db0d429584fc6cdba6acc9572db2478d665f3accce7ce125ec15298e903bfabf5b05056742aff6ce612c39004bd7eaa8890503b5dca2083d5c15b3c31fb974a432205cbef56ebe11b1e918ae23368d4ef7f741c00fd7f46b920178d56e72f5c11aa519e89be161928da182f6f7be2f614e4ecdde586ff1d850642c8a54656a7302f910ae137fa9183056f2f832609aa9e9fa1034ac59131b3311c265e77fb21c29a3fae3e9916b121c8de53c3d20ea0a710830c7d01bae61af5dc3628f6a9397328d7272238899bbbfa5f34f3b30a602881978fd91af2351c18c83bf07fd7781907f0a271027d847cebef6910103895a0da0934fefe97f2925e6b6817d55953b911bff62733dd48676f8941addca2d0f388300010da028a0bd7c624e96a5979a32eae53bc335e24ce6240b524f44078f4795d35ec1bf6f227eecdc0905fb127738c6b2f0e6cef54e474db202e8cfc7a7d5ce9a6eb45c6539456e54b3aef843f3ac8335dfa2691e0e6060186086ca5103788efe62effda9fb577adba8957c557c60bf6429ffcaf4909af347c9e67942aa6decb1aaf05535cc3e4c712f98ff181186433fbacc93b9845d94a6ae71ef1465e6a3faebf5b017d7f1f774d012cf59e2b630aa981424e39ad3b83fc3dc639ac9eefda1b72ddc6bb07bcedd5c95a8833145774dac038004402e0a82a85c2cfde704800457221f9d544137fbc393a2da24f3802a284994aa5eb17d64d7b8439cf1139275ca966438dbbf33c185e461e1ecfba3d5d8a7001248c9e476701ea296d10a4c0bc6d40e8ad0c8af2d2d36bc89c1056c1514f6fbeb8c1f76abe3e09e3ba830d41a0d3da9fa8a347923ad8e4b63c9b0dd42286255030cdb245ce324c0c78f30375cd361d92db8405f7cf039a662ce3caef865dd17407a87d3109bdb597521c46a2cd131cee3328a8be9407bf9ecbf2c40176f657ae551ad971b55f2edfaa0d099c93aaf2759bbde701cf60d2043442186aa82ad7613d500ea396d6fd6302a22e39cee627ada69badf8b6300c0b86eb3d897d2637bfedab2b0d9983d2e0c2c7ce81d53916e3a7b4b18612dbe2eb2ce13aa9d43755931cdc44daf09c17aa60064a13c901ae12826379d24f7f236d069a3fb5de43144ee3f310eeabab3bac9c07ca8c7b3c0ba7b5fabcd57bfb4ffe3c0123a677459e302e97773b1ceb7371fde093e858535e276dff42fea019e5ce8a700b236bb9265e99747b594e5db52697dbcc8382168aacc9d0994e6cc339ca715983fe709481f5396dbac5b67132f2a55124b661c593ed52ff2b43617ef2265aacbfea25d5a6409669c62a113295688d47776bab485432f1193e5175ef28335718d508acc986deeff3b39c5a16ea0d46ca225cacd71e0f53b9cd728274e58336afb82ba27ee7a49313b1b475f976dbf72e34ab92aafee538b35ea25a9c5a5d1578ccdbdfc3fe3824cf45e7b21d4bbf7e26213a3730ab76f73f609befef366a3bdcfdc412d3788196402ce0b727795f0252e562ada8677bf5beb660c14ceda4543d9e7edfac198d7416d2fb83bd45d2962f0911f8b567c734deb78944c5c4df20a8a81b3f6d1d6deb735c9b79e6e0d247590b699073a8c951f633d732d947f8a178e2bab2fc363d8211cd3b3b0004ffcd4a979e4ebcaf699a54cdef4d3092dbbf3e3fb8c65976626cd372399cd8a07700fa1d4803e815fed67ff8454bc823e57ea417fa22a0daf5e38e877f5a360bf1871c7feebaff78923073f6490f3e8216d66564a2ad47a403a26f3cd3d1e09422dc3c676633b4992c78e571c8247be1bf689d9504a4946b8c0ba1c7f6a800c9200dc19093a308c0c5a324b1cc7d1bef46ee9231c99706cef80912ce519490d965a4ca54e3c6b39fa677bbcb31c193809457fc939efedeec839894f4b1307140b20e04c24ed58c53c71453f1f1443bcca2919ea6ff442e8470800d8d854cb6dd6b004e26714451bb4264dfb3e670503e231dfa10749675b9bf5f0961d22524531135a22234aee5e3faa899ca664f262f2111b6363e212a89500353090229a121d168dfe2d1e762d8a46b536a984a4cde813670106e070921d8f5a1e6d7aa1097935f237e8a5eae152455ebc7c8cef20b9f9459af1416268ffce71d7a866ffbb558baca7ee0aa4cb63145c281d356d316c3bc30f2e13b3c5eb5c1b4823f2055e1f5f0bc3f10846e1ef5d4bd2b9f5a035728b32ef6ace882dfd713847e6abf1fbe3982d2ef2cf6d84d6381f46ce36a5e64ee270ac0587aefda4115dd445577ee1eceed58dfee820db6b6fbf2740a67a181f8afa0ff6123a7a0d7bdca9f0a6f09834f7492edba1d5fb42befb0710390a09b6dda9319cf7276b5e255b5a457d0478899b27f66b83ef9813c5ca5eff4fcf3247344339bdc319ca11a209c2f8c02de8dbdab2ba29dacf3c3d989201b601f6900de897e1eae85f085da822f67eb33bd8f6644aba314f51a92732bb92d865c099c823c7a073670e0c1cbf26ea9db8c4e1a353b5149337832696f61964dabd01926f080d627d29357f1a02bc40354f75a807612a7318c9dc7f9fbe8b4bcc77bb115ae7e99254f69b8c813dd671f9f95860cfc280d591818123d05a1fea9803de53e213ef9d23ab2d7782051b1a3025de6fa2fc5ce7126f319f3f39e67cf8c2abaa7b438f06d81e65b6cfb01c5a0f18215c155e477cf049cc9681ce03aaf7bd86314b920e0a7d583fab6ec178c0416ab49cc5fe40b479bcb243bba6e54f8b3031fcacb7c1096200be53f9f2eec37771401ee818a8d68c096abcafcfa615d86ecfdc9c036cc408c287864eef2a4549252b3e45e3599479b10ab28dabebf7640af42e97ee95c2d4c26d62db9fece1982c85e8f23e39709559bd5bb3d4e6d1cda5c2e2f5adf2f234de43dd0d99a14cf2dd1e4555031440cc471f2673daf680571bd2720537e1908c4eca52e711ef5dc20e79be61f67f3f4c23ab007201039ebac3157f8831c8cec5d366f8566aae7b1f37ad167c0be63eaacb0c94b185a29448fd8bd4c86f0ec05f74a8b84bf38923800e1f8b8df3efe601c77306310938d51613e3997a97cf48f495efdeac66a423fbc9273f168aa7369ca1be30b51cfbb8a04f72bcc1e49964cc0e1b47c666e66d13994404245fa7bab1be38c90a72467d4ee844ae48682878b52ac17fc6bcd4dc22c4fb0f11088add563207d5cba9391ba9d5007107daf82d36097d82f8d4b232d7219a91030e79204df9c3fa0e842dfb27dbafa8105029a9d3389f73b96e038c17c55cfba38a5edfcce91ed35226796c2a6b4fc7339feaef6314f2a76c8eb404ed082541f2f01d8f52a6f29157d56bf81574e62b931b0608194b17cdc38fba0d82f239d68574f61bda06454cc3a1cd9360785bdcfe6de5f88b24772505c2ffb6f1dcda1c9af9afcf35f9d9170583de763b4ce4a1c8d7378ae833bf649c983cfd7ceba082bf9acc7ae61d27d7e366a47f0ca3f0a1c43dff81bc06e97469ed9dbb8197fe933910ea450e829902acdac1f36ad092d4d3ee0789a408f1c216c05ff0c9227e42af6f0556b621895a44768bb33e1a1dfe5689f00cd3d85f3b47a63bb578f79471fe0978a1755cb58571848136bc50b33224f4c69bfdf07855f8d206bd6b7206ba5331e7fdbe0c2553690035f4aa869d941d9af0388e6710b159e62a170ad3785fc74f780cb51d1496c3193c12aac35dcfc5df803a97070bf799a52c20e777fbf3d10d19446c22068ca291ad498d5ad3b2a97a30c8c831d4fa7ae1096d5ba213f7c758aef3df622a79370ecbbd15f9483328a5c9330ecd66b7c8ab85a5b984245387ad7e889fdc1313b68ef67f872a029b924a9b6c77b094f8e26d7a9a9573e51dc7b756ea4118891cab2ee4008f893ffc1cb4936e190d3290f4554712406221ee2165fd2aae02cb4555c5037bfd38016bf72f2d2aad8ab15b2e58a1a2b1997d9f2cdb4c2e4b9ee604c2d8b755bf79e936c834b554394d60ec12410613f5746dc1864ac754b7e5f6ad2319046087f7b6037c6059fe99dc1f547ad6d590db2226db35d689fc859f658ad69ca3e8ed3eaedfc43e1251ef371bd2aa77b46614f7005a2f49ebbad8e1ddae5bacfe61dae311229de837590b5c3eef1875d4f4efc5bf7008d3503571e5be4c804ffa7c0fec186b94d0b0f2c9a75ea1c35de0ec27908362dfef7446b5d2500e768c19f3e30b332622794a70ef15228d2e15d79bceea47bfd9bc15659335dd4303e953d37c9cafbfb212fb2bdd9f5a0c24a0ff3e7769d05b32b28d434d6ad10f8b255f838dc486764c004f484978eb374df7c75d348d0e24c1f24684fd4610756e725be2eb0740bf087a229d4bfc30afef130969098ba2b12b6bab5b78defa0f9a457515617bbac7e8891ca3f58731f2cc28e6b8b5bbfcc3b73e4acfa85b8f966bb3ecd3c324df170c14c3c9c6ffcfac6738b032fe84293025faad510bf338623bb6ba8a240d9bc64af887e4082a361068a92f7df5782491547307cf2e14827ba536b0f0b5e5870cf1edd51b0d7333fe1be648e5ebc349c70806ca3f847d0b47835722e2f551010a26a25284651679f7b2a822a789c3c03cfd522cde70168bda064b1678fd936e7595acf813768923b6db473b06a6476adf57c1347aa54a2b11ab0602f4e582f989bcc006d61c62f921e176cd89d5658a1abd47f512113113b074f95c872eb0c103171e654c0827d68b90374f910794bfee0ae48934c7dfb2bab4e77d11411f37e3be180411327a0dc8926fd2c6f2ada195d330881ad183575c18cf6796cb1afcb130569808900981582d40f88856a289ef233db4f8dcc512a0f2b6ec76ad16a96127bb86b8b3325ff7f502c03485ac97a45279f3fdd6aee54741eb60ea6810d2beb311554dd6c1c24948a56d868a3e2d511bf43fa30aa162a772f323c20595289b4c9cf74dc2007452ce3f7647cdd1397d2db0825a9678776dc489279ffd3ec0bb176b252b63dbda7e47e40bc308e3e72c2c2bb8e979ab6c600c8b27080bebe69fb75eef3b172904823fad24f9ea208b7191240de7522ca45524a8f703dce79328a243fa134def72360088c758c2c74912d1af4f66a996c4f4d1632f0ab2f6329adf69daca06ad56a72ac756ffb5c6bbc6483cd60886f54b81f98070ec629150dc8de2d45a5f8b027cc31b247a8b3972e11813da1f939f16cb3a746086412a95f89ccf024695791e9d996fdb6ea3dd13952f86653f27fd2bc647ed715c7534b0653ea398cc43d62e46ee6f21e7ca866509643f739091b71ad3b209d9b05a72fea6fcd927560a16e3aaff25501e8cb873c3a8a7c647544a466cf88a7d07bba7b79e02b04780289e124dcb411f6902604a4f6da11eb00eb4dec1fa0c3fbe6b0e5fd3317b09b28a898ed71d5f35b0852f7f3d63ba9e90502e5ffe9580c4be37f43b4375b35e15f93b055c9ea9f3a29af655e0093c605a3a5c03a1c9ba92511312036d9363b901950c7b541bb6dab4e91c6267943c7356302a16d77d0f52535ecb853838045f824c1c3657f2f189305d12ad8d91d4e3a2a57d2e006106652a2b7fe23024bd70e5bb22a9f808db82eacffc1dc8faf28c6b161774d2935e01d2cf5dac26f52db2c4c0b64f8912d6eca79209fa9c754a727bdb76e5efb047ed10570704cea82742e827e3acec1dda600d522db77a22e8c0d36aa0681d39a438a3e2b486e0cedd240ac51fe2ccdfccf86092720f710645d3bae3ac9b9c65b993a46e61b3b8fca675a8a5fabec636cbfa358bc4e60a9d87e4198831451dd8a4e6d144521a3d48645dda9e76409428e13233e8561784116c920cab4087e17e793d118b2b486dd6771bd324cee402fa9cdf64b3d798259e77080ceab02903d226ca242a74e55a278438e17805786788f6af8608e28dedc859a63b02f92e5f9e15b621e4a4cb1c6542de1448f25a9abc678c337148e5218f0b43804e34c6a099fdc933ce6a6999c71e8619db11581668e584752a28fd20cfe268c215c3cbbc8a39e07dee481bb3ce27aaba7bb17eab4b18416a1fb14b216a1f99c7ff462a21ecd1254dc93cca804121f129eb59b89976f18fc58994e66e8ea66fa896a44db76b694557d042d5a01778c5b58932928ee8efff305ff8348ea183a04b1b92b2ad306769e84b8b9860b46bd828d2a1d2a9040308fb070e17829b5e15c641f6baf60ff96174e5628b1bc87c679d2716f5a42a15ec822144f8b40ae5c2f1341a4b5c4f0da4fd597c7b1536dc5699ff48b3cd2c832f797dcb7b2d33e9ee8efac3306cfc1b272d13af8d82b75b901b86ef77c9f3fb8b8f35b9b58be68ad912caa14a79b7c06e36b9e63b6866e1671f5ec2ae676d5f856557a5530dc440b14b026744ce10b2f015060cdfd74342af8360c3de2cc7bf6350afd39b0acde77a47602cac7e7eca1e395a2d33415e487fefdee8a3446b5fdc55964c1389270b3996b58fe1ebb64a00a6eb5d4507cbfc7dd247a14507ed8fbd127f29b88212195dea26475dfa8a82c30a9deeaed50e05fb5aada7edad1631b84db8d8c416b34d6831b285208c353681d893049d89442ec2260314214489adca4331efa2e9fafb1b10582a892262a6246cd48de80777ed58aaa77de092129acf78105107db877590342ac6fd9715299809891109b93d016e78ade5a50f3bb9455beb7753bd4d735907b533e34e756d1d696a86cf457ebf3d8c83cf5264010c495c33feb1e3c28063368666b3792f0fc245a5e75926aeb5c96d4af28c8860a7478e777f21864a50bfae84e2fa5d7c6f6f5a7582e6c138762d67c5d62c4f2fe82c2e63ac5f593cc474c81993701912b316757b1a59e9b23465d3fcb0470bdc8afa0196a4f2738b5e94392eab412797c0b9cb96e3f05f05b09c2a1a54db8c1cd5614fc4bddbae369f579bfa9a31cafbe3d76aa0189eccb8524767fe7bb5f476d9212e05ed80cbf296f8c92f089ecec7a0c429ed52c6fcfc0c3a44e34b40f08239ce61a31fffa4e5ab82fd1916660910a7ff0e6fd237d5d62b38affdb0c64fc30943d61affc231624f77cbf86b2431870b66c4d0bf5872b45641eb7ad4973b566fb75d0c322d890ae6cd835450bfc8f1207c0ad8a571ccc5c3db167a58bfc773d898c5ad69ec9bf9f4e89446ac897c6d12e414988de903415c237f6d23cf6a153abd1ac7a9fd6fb76b1ffb355cf296d997014483786380aded9e80d777c433501e9789d67f3ba742324772e7a014c184fa4fa9edb7f077fd0f9350fd992b61098a7734ec99a308f992b46d349cb73a347e6fe1b09c06139c35d5d8e9a7d86eb114cbd7971d7f82eab5305c54f4ee2433cc26cdf5c809e160e8ccf6e93c2d75074f93c764a1a6f36d32ec4b0867fdf0aadfd4dadd42b3892de26f08ae86408572c30de0a1e8c41ed1c860be111461d91e5652f5f03dace12a9e34f2f3ec79464e38f9821b83e689540c4051cd28ccfae2923f35e7b4d2952704707f6a6d1f17a250ce86c556234b6c75838a06aaca6aedb50d5d4d2d7f77121136a22b7191a86869926085ac3799d408dfb88a0cc1c6e8569d0784eaa67d4e3d74947a43c771fc43b65105ac732f84ec3bb09e76e5e1b50e03ef832b6a7e176429e049930e1e2f4c44af9ab56a4b0376ad0ab09fead131c7d537bae4d9f5c7e62cf99ceb5e82095428dd469914da5fc22e8160449d8e9d96d2320048a75e33531d76773babdb5aa8bfc30b3e36971ae8c78564614a5703e5c05621b6d44ecd313240495e6f68892a432ba98","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
