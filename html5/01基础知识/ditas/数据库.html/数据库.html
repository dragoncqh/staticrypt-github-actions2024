<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2a73866de5d90cb8e920c68a66e34db55df03da855ce15f909dc7050f5de3e16d98fa3113962b50a99e14c2a5edede1c3a2b8e0c40633350473c2e30ded7f4543ce2a9c1dec96be1d659476e5f9335b10da59234327b3263d180c18defbee3931912f1bb235a31db4d272da16bd17a3eb2d307b92df4ba1f5a77156681b9c6926d897d32eff0020c3434116ba9276b3f9e4265b84571533f239133091e7d9171568148013d6053e69cecc14289ab556f62777c6dc4f89a38c85781be94374a1bb1c26b6d0eb658dcf72844f0da4b5f04559a772c54f954315141866b48418a0225fd6fae97b2a63dfe9d0257204bd73cf06ab84ee07f1e75f8e74d471d04b5f318be7ec965597146343bb2eb86cbc6e87e0ae495e4c795d87858837818cc0e7bb2d6bd2e555790d40a094a9c7bf68db68acba14f6b00deed01677fa3e99b2c5ade2dd6141dacf46bac1af08a3e2dd5d3861188ebeec9206ee20df4eda0044d94a3d9d61459fa6c83b900266a403d9eecfd924d5f857513181c24e0955b0163976d44021784134726974d9dc9823be935e88adfdc80c019de87d071258a1f788203357aea79afa44a248c5981a441b49eb1ddba6d2f5a18815e3b69bfd537e9c014a9f2333f6d1b0cd9467eacaec65c688b37a24e9722f78690a37d004d2041f7797fd91b034add445ef0311bea021e03945087919d50eebb003e50493573ff65be8318c042c97b4833e9eb2c1a28d78ec769b6c7509d39c9513a6de092e356187938eecc7af5122f91f0fb22af2378ef1b96dee44b1e10117bacd3b1de999a84b466c017961421f2fb1f56106fca033e31bb7a1b8d79d7c8432f86f78e4377c145e56457f9ccd80f67d7beeb68950d40928b01d9b27f37b7a0088400b36483a917c68577eb9093334984a0c94abbef5ae89a84155a76677283755d427c3831b46c21a24fa6f7b3e362aad1bb273cccb083a64de6956c8cc7555806b6361735e8a0c274e9dee2f455055d1e4b0aec82ff1fbe9fd685e45abe424298284e0ae4452518224c1c0908cdbef72b3a30303092056453c8d026766ca8a02419f7208d5bb03c83ce2aa71763c0e849a7a825abb0b63f17456d76d4cbd8bea1d5f60dc813a8809b7cf414af8a12b3d85767bbba1bfcf768e8ee719a1222a1940163019fa98be2a9f2748f79b9500f46ea84f4f80ef3ff741f58e3861658e1e5896f8c0619714c87ba5343e948c24014156862377eb28a01831eb15b0c24d35025fb96250b96fa778fbfee088141841cca1eb865bfd48ef7ebb89c80238665362a6f48f433589ec0bbd4ea3db8db6416eb6aa56e9cfd238d79e95472ee70468ff30c8781109037b7b108ecf5fcf3816b719818389912a671042edd1521220079610aad1656834e736ed5481e4530384e550b603c15735faf605d116153ef71431ece3cc51e733fc292e4ae0817406e9eb9ff99f98d54dc1bafca9d88ca28b98543ee6adbe560fae6452124f5251bda8acefd5af55dc624b22a4fac2bbf61433857a3c2951fb816f6e80d8b1eaf299990f7cfafe1ac547ed73b9404ca8175cf2caf6e5236c97a5397610bcb7f16537a45fe397bf00f2ee39c0278e6d3555afc689d29f0ca6597f6c32539b2de266dce32e78523aa5761d56a1a469290639a8846e846b0d3eeba25c16dd26553584144846dee6990fcbbb6ea70a65d3bd8b4fbc4ab1f9eb1eb621cc659a7e0f6c3c07f28feeaf84b4ad05ec4b37d374fc227a8995494d16c66a7d87531b03b604be9c6b015efaf46b61ce38a96152eb9f519fd8c24dcbea1e5aef0075ad4017ba7d51eab445ddf7bda07534ed55afdfa1892c05b1a0ed201aad04376afe59154efdb3ba77c154dd2dea6481363cd37cd7f799aff19ae5585f8e00a5ba01e43d8c9ea7468178c4b6926794433b9d76cc0c30248724811b5b0d7ba78e81312709cc1d570dddd7515af5149b83a8eb8b0004ed98ce1d434ebabded097b0dca834782e5fe208ff9406cb8fe6291846494e682656acb0d93465e6e5532b9b8eb7f57455ace537c29c89bacc02c1d8f15a172c66c09e985daa799422932642c899312a371b44c23ad0a6d49bfc300f5c7953d4c7b442f9df0eb6995365cf1a7f84f33fe92945520a54904deba8080a62b8d13480fe523b14d1b70e421a26d86292c26620ae117755764bc5f8cac0f8930ee8ba324acaa74717d14774ba1888315bd0baee5d3a7f64e62b9c140a7b2cd4fc2d3149841b60c21e51fc8a95b9c8e3703cd998f9fdb837ad4c6d8b6ef98ef325c89084af6ac119e3588b96f0ab3d4d81f177a605bda931f16574d2aef91f962aa7eae550c01598aa50a3304c980035c14b721bbb91c6483eff123c333869acf4d5c80f4fbb5f5dbda67430243f3fd153b16136c49e51fddd57c6e29ed4216b5ef8060bd67a5adf62b3aa8b9870005b2e69f554c49f7344c9db547dddd892e2f7adc6fab4809db7805ca5b6280d523b724cb91102ab4cfca3ee6d3becd994cf066ff50b42ee14124e0c675fd7ffc734644bb0f1b0f06f47ba8e4a93f3bcce4fa3ed42879ded3a3f5cd06216932179bf799dbc3b4d45af60d2824cb33d55fafa1e946a1ad5580ebf193df262f5ba59e46c16e046b23742aea559784c750100631bbf934ff4e8ba2c64ffac23801bca7aa3c5d23f90744ecbe66338151a7cef6a00d003cee3d3e6cfad8d207f6fe3e08f0f8a039944af915fa01f523a7c62f9fe0dcd561e060235309325d47ac94b349d3d8ee7585d3950f790172e6be784940efe277b23b4b2b20981b42c2fbed2c234afbb244c90f24cf12f8b154f81cf46a3438a496c496fabd2ef057dfbf7c1f0dc79b796784a080ac4215b4113f39885c7e0d79d8a27cf2ed60a6e6c258002465d4eea06a8ece26685140c9bba7e64acd95f4030ce84e2a9d7417e067fe674af46162492353a60819d79ab48bbfd40bca105150222e23227924153999a3efb1c1b5634d55cb00a9bc6a471b388b53a1cee6ecd97456f7260f134d97c2811a83899ebac463f2783f1f375d5a0da7595fcb3d47735aee4529f950fe9e5f990bb419a6702bdaa6a373eb003e12dab2de5630e9add3b66da39b7be0ea950d325879b47a10bd129883d08c66870f2cc8f9db726f390a0f0fa72e91f5dc1bd6fa7276a8c9a6cb391227fb6f9d20c4253bd85a2b6a70c8b16e5f1af978a3cd8cd2988a7e51c390b17076c6d4f86c882d5ba72141cd41c8d8a5048f3db9d5ee347bd35ffbf5add886a155cd4aafc79a53ef03248a312cf890a41aa78bb3e589d45740bd3ac4b18dac3412afdecc61f46c27a1f891cfeea8fd34b72b04c6927377f378906778a1ce79cbdd31ad62011004981f92f1a033607d9e55e0cc76c0fc52ab276505f2aa4a06765237749666a0f25acc0db7ba536b11768cdf70307cfb288a703dc8d723f90963f8f1dcd9a79de7802e54f2f9ce9a6764a5e1dacb953db72606b49490ec75bbe5072bdb73c6aa21485b99d5ace06a0e6c9c3e934c4c7bda16214584229cb71773a728c79b35d480dfd9f966b4f6b3d6219650dc4436c76d0a6b2f8cb9d1aba7fe2bfcad7f13002399dc15febd9d65684eae13e5fb82a9f74f20c49864f4cb60792524c16f48f2d6ca023752df3d4d4e26d8d826d3a0468ef3bc10fe3766ca54bd69f9ac3b0712a0f6bd44e1c8710322956d1c65ba47c0af154238cf64c168cce57a66cadfc191152dad186b0f7f6d11a07934d099e2241f8372c27f637232bdb6c2898c4116d7feac6483fc8a245bf21902fcc4be21e54ab59a202a4d405c180ad13e5b126879db769e9f4fb54659b491b2f456a6015b23db02bb6f2d08847fe8593b50075940b227bb97c95366610afd3a01f744e0b778ef860d23c2ffd2d35637ecff5e261b0fda310cd1cff637e81c8d4963cb77fc191ce041d53efe4c3bb04d3b78cdf380c390868ab6d076ef241d5806676b2ac16261266fe9e5cccdffd24675fcd52c57baa46730b91bd3bd8a5c30b92990ba630502837b4ba9548cfb76d57648bc68c630675d97df747278033eebd30765d7fdb1b6148ff091df888200043618b68521fcdfc63946fefe19ba9aaa023a3a07baa587bf235eeddfee66414a355dd37a42994d99ffb3f8b457c373942b960e045abbeace840ffa92b517d11aa1499a79ed5d8241cb475c84598f6e3e06a696ca26bf47b9acbf521d9e4661bcf8cb634310920672f6a7238b0f27b335f20b2b6cb65ebda49d7bd88e33052ca62b5899037234b5421526641ea025df8733ae3a21ec55eb6383e8ee8e221ef403211a455df0d13be5a24afdaaf46d98939d244d7d8ea46a51f67e3b52b9956c6c33b3d7947f5442d73d9f227a2b37d42355906752268868d01331cc60bed9072ba6ec47667dc8ab90dbe92c13aed17d3a6f8cb6f42b7ab27d9348453b966621df985f89de7ccd384305b5a9aa2a2420a6f2cd96ca30dcd87b1e873f1d76881f0a545c54ae05f210267bd7dc9abb1f33234e0fb94ed73e94d98993107034c18c68e0f9a5118069faa9d3302e3707b2c450efcc0308a8e8c4d164bad6ca279b18cc73c6beb4c63613bd27fb9310355e8fba9c8067589fcdfd3d189602b482059812df479a137482d5d1ca59e0421134a9b8aadbda1f4f70e9037f7362ea4cd45e4d10747e4133032e5a937f4b5abcb0bc052bc5eb5baaf02503b913f50a4d5b6611732303dd1a0754e32a57116df9dc56508cd47011d26a8b4239d3b625d2e7b1650785f5fc73ce8c657c7949d3744952b0654337ac9f28165d305dad6a0547a99ce14fa5b19e928fe90155bdebc3d18c3c48bb92981874d21eecc86900056e173dfffbd641b8392a86bbe3a083f074abc43f31fb7aa8ad7fd655517e8abe178234a08ecf9652bf258ffb38e6f62f5d03f27a7f7f212fa5af8682af913f8f01f4da502641f951d203ed4609d9e77c4bd4a312a79df7d2c72b319dc2595530a184da84c62aa0de6c563857b1eb536b25850079e819200ee737a1ab6de51557556a5268bc4331d7c29834095bae089eca9d2a3fee3acc6f3c0c7d5ee165067b75e3cbe9ffb0d03c24014d69229fc08e40b31b516141844181b3e034d83909905b65e501322b148a910e4d43b5c6941f3ff4359a985ca09a832a807f0526c520cb92bb72d70f71caf260588c57dc9ccc6bb63d1bce5a9879a1298b1c19f04daf25ad6f421778d6fd661f0cbbbd5a9281bb261849e9914dc935e0b74bc765fa0cf787d8f91d8589b1d8b869a9efb22f9098ee93bf11a53139c2bd953a726c31d76b722e8491dce37f55f8a162e3db42e10d8a88b402f6834ca1a9d78bf49596c08fd1cf68d88ae48040bfcbd4fcd102be8306d39dd36737dee635c2fef3883ee066ff85cb5f38875426e8acb05668a62e2e12be793b1988365b0d20490514f7f6e3fb558d84ecb2870de48991134e2483659de889bec19147d02ef5447d4d6d3dc51dc1268333c84ee9db47d72fdf608f8587c8f444d4a4021b97a3a9a6f44853d96bf007d3011433e803c0d0fc46c27ffdf7d19f8a1ef2c2569a028d857df8dd8b1d25b082cac2e07f79fb6842ce329eee2fc41cb6945f5d35a3afb1659ed577d8f9b079d1146145d14aaf928c9e971dcb68e1727eb498ab17a5d7dbc77d15d0e189f1539b9eb9da6e6375b3c851f8bba8126106b50a956fd7173656ee7192e8c85beb7d4e28f366d2e66404999c11fa0220390024a495a95c40c504a299b52b777c57abbc15745d4fc4f33e5a18b7221d7bb136e2b21f3244881ed63ba8f1594d0ad6e20e9af438cf850f9712071f1fdfbb39ae43341227ae423e64ed0077319a4e70f1f55d101f41b688f8c66376a4f6d54f49622f015cffaf206e1c4024906f840b64167f49bb9a53edf912522d097da5320ab51f6d24eb720ec9dfaab580df5f2b1142b9f9d8b6cd1b377ca002ec58017bdf5cfe05a6aff11f44aa97e35992600f5dce8580c0f7d778dbd5f9a114f2f61475dee3a6f1820c7cb95de729c28db7b5b73ac7b38eb7d06796a794ee0f30669dbbe8ce6e6f9918518b7bf174974074c7ef08e265401cf314941ff5432f8758e3b2a5f0f603f5de043870284d7dd9e06b44f8a8d889d67f538aaf425e825f8a9f84741cdc74a664833bdb65cd3bf3cdfeb3b02baf65ae55cb1f371aa85d26627c3a86b96a136a11ea80d1df4a99286a6fb48d1a064a01c71f84f77b1d98adaa20b3cc9bb18131038f1e42e8b67fc27fbb310a297158f5f4e113aea67a90e80d90a428c0df5e57e4062ae59c942d4822a6b42e8b0b6e17e7ad1321d46fd2e6e18ce68ef84c358a33044ed9cfe5f73d136719ed61f598cc9724504640db2c73df9e85c4c568758eafa49adeab4b924edfcdf90439b49645fa4f30948b58b41f0ebbaceb33984b974fa65880be34818faa57ea691423b37fa0f1fc12b3802c66aa7605b3d8198d443e4ad23a58ce54bc53aca6682d5fadd0ded190914dcf2c4a89b46241b863e3cf39b2a4599a53463cc9e2b2ddc77468ed0d9320150d3b1364388037d6f0402876d43d0eb64f9db0c3b78c232a7ab7eb0ef4b7052b319a8ae357088667cd964f7933c1019acd6e83e7f78de337827cf644c1819d5c9d96c19e3222f7875f1e80839646ec9e5e3487b3fb251d918b42823d19664790785bd314ffa09ea15ead9e878b8d891e5b255e453a4e119aa09673c21184e55c499f5b055ecf12fa686d34952eea3f756c6960dbdab2504021deae6b85c9114f83451ea0952ec4253b8d17b23dfbc73e9022432e0309793f769c1f76bea734c09410c9f2bdf8cbe0fa90fe1398e1e4fb400b5a9bc8dd9926aeeed4a6a7c7dfd1b2720899b2298d32ecb10279122f7a0918b21d2adc8eb0c133f62cc010222606e570a831969e4b4939c3846ff26f0d5b8bc278fdc3163a21096685073de9d573f668fe2676d8fbaac2cc4f096e669483a9e57c7ec95f41f6af1b929af3af3b69c9085c310d06bed235dc532d4ecf94bb3d15c213aecb3e95e83fdf7a9229e8c64a962176b63f7e4f8e9203f81b479cd57f26630059d0304717c0b903c08f2ff143b9130070293d34ee8db2ce493a98af7efbc6d5c17ad6c0eaa280b26bb9941f2288772ed775bdd5852eefe361ce005601c396b91ef228c837ef468998e265315e9d7f826d79b1662a9854a4290b04ea428bb44568acc0799070071370d198e31c643ed133cc55343568fa80d7c1b5997b75c319c8d45c731093503ee24276ba46dd19d8dc21e682f817b5a7aacbfc3dee21ed1428122777ec4c2b3e34135676d0ff64aab45e9be3719c45a84a657425f408de17cccb73543253a4619dea98ad0ca54962c2a9270d90bf8f63c537ade58bea2faf3ec873cdab4b953d11091e8eba02d25c0014a6fd7e595dab0b1ffa078102da0cd7bbffda36393a29c7fc5f831ced5c715f38b4731bb42abfe0a15a92b2e09418583acafb2de2c719bb2c2b124b3a6ccedd203b5175b3dec4e4154057658f2ece044ae9bae400868e705ee1b717ddc8b5e87e6d51893e6bd34c0f9f3773d37bcf5c5d3ce8d8c61555910b1272551653cf3d80dd26b8ad5ade5c3a571bdce2c11ee6b38efd9a2a4af52cd0045c405ae137d9be0a0e6c15212658450526cbbea1fdac6b6a160ce854c88a3cd707fbcadfad76b0993d72ccbfcd0a14214e4cadec1b076184367b64b2d2cdaaed63682f13db80d0ddb0c189d6d5ccfdc716c8287c824770b2af151f97132dffaa251e2c08b585e039ca8fa36a9ed2140ff8022333e317d5745543206c98795b1d09b957a59d4963758bd14a83b145ba104c2eccb9e5d88b1165ea0d0dd2a2758748aecf1f49b7dfadb6a517ae778b6a6b34aa51f3bc64fa7325be18e1864bde58a0bb10e7267b37c033c58b7e67a59dcf085d5b3fbd6698578cf60d9eacc36170c585cfdc4bc3ad957c0357c9ff789f78f4aa8e6358f4685eb41c8385717bf7e272f86c42db99dfb075a783d8fa4fca6af3a5e0a713a0bb81487872886cf529f091bd26cd3dbeb9ee2da65dbc4e99fcc06ca1088fd57a91adc2e905e6be0086bdb8a54adf30b0a19cbb1f72a6cc78d69fc5985bf73e25ecfe765001e498e64c93d92758710787283821aee220a5bf0a448fbed0fbe31d9bb03f042e3f2a34477f2f7db85a8355212b929f1c0b65cf57cbd2e44213854c3b61f76842ce855ce1b9c3a2ed6af90af27cc75ecb2339bb9c5f60e5af7850185e19accb1d595bdb47e188233e33e6031fe92a97a9228241f4c33e4585cb2cf97cec07aac9cd147badb7815cd29b0bd35efc6786213df09a889ebf4147c1dbdd5106c55521f05cf90d22ad7bb66b7ade9c0ab7195a2019fc5dc5385e3776d3ef5de0a0e8b98d342abf7a2880c00098a154ac958ff2c799bb6384f9032fc0f5b19203411049eb5fe00ffa86930c120736ea7a945de1aac90029788ae21ab3de5e082a5344e214b475fc68e83aa240ff6b9a2468d93ea53a8bee39ec1cdd30352459b63e154ff099aa6729bd13f1313b01bdc94a7fa65671344efe01c8ec76abaff5662ec4ef8e47c7d9190f40cab4c381f91b8f2f97914a082cd9b6d9fdb5028a26b1a11d4f8642487c624b6a84824d84556b5dc683aa37bb0569144bf0b63c1e90a22ac3d854c2c6d19cdc96d77bde1e6677c58cdc0781aff1b826861f539a2166610b135b2b70692e34b0b5fd96ff6e92c8461425a4c5f503d75a71bf7de9dd7ae5e9dffefa98255883d8c92c030f554f3a15ae56e8c613c92016ad2901bb0333c472a9bd0bf21964a23be241c6034b3d60d9e70163a705f75e83fbb4742a00b3fb5712e9ebc4095660b519c727098bdc11059639a6faf1bce14b0a21bf46c89563f4001e01095cf3fe8b93222e0b89ef555927e263bc2cd10a818e2cbd309c8785911fff552bfd2c9c8d9059b9c442b983b1bafe658c06999904a9abed6dd880ed41a90f532eae5ae139e793ddcf3cd975ac9f99887e377b2595a683b052ab5dfaa846f872600737c0c41e61c3a4d2f4b7fc265e1ee5aee83c5ec61fa019600a35d71b648cc174471c667560e4d079becc404496678dfe2c35262ef7230c0f0ce04cbb18acc70a2cc473dd9d4862dd89587075b4b6ee3dbb0e2ce932e99e82ba5cb4d3e62da434df70ccbcda1394fed0810c9ba4c127b1e9500e81069d1e7e4b72ec9872b69e1c4a3fab73bf059309df1ecc3a64d19eb2943101e4d9f57738ebe4cc65ae1a336d5df3a22b07174480f2913d00813cf061f8eb63e379f36ef1e1b8d03a4376a89d101e09c53c01c63d04ae9812920b75c2c144ef5ec9e6b872850ba40dbb8668094a8c3dc8f05d736622f6542dbcbef07674c85d5a735794a1a8fac0967a225ff50f263b92acd580240075e0afc95ed7a47b33acf563e5cf5935c702d49454fe559d33c221b2a30c8b1face992cd719e87a063cc8f335505c3afc126717bfdefabcd721581501ea6a3a5962fc054570c800cf460317b93a1671fdc22a65da40d5fcfda6945b2277b392b884cb03239c3b3f85562affee102847c85a71ca306a82357e350b7ca03d2248fccc0e416793d74df60cb9a2ead66e7a4eae739703c4f095eacc266e96afafc3e0855742d15d0c51cb0f2feaf7a28c585b45b70bf7a361805dd19de9192b25e3c961198a279a0863c06ab76fb0845d51188f06556aeed15af7e8e5ea85b03c19d6d0ab8fa78dedac62d6212aae6b9457e4cf4412c26002c2ddca143433295352f2e8a820dc64bcc47b09620236272e34eaa4f89d32550f4b617219a9a18e573ab94dc1e7d7145feed9c28cd816ae11101d14d00c0ef8b517533d0d38c737986e871ba543c0695e13b40d0281b645392c1d066edfb910dfb336e9251a25e974453a15713917ce17297cdd6ec2f1fd459fc4f9c70a940f93f4debfcefb4204e093a289667fb54abfc3fbbed94c1df7a11c463965fe16d6b55bd087b31b699de8cf8bb397f4fe7f50e6dcdd3ac1a8afb6d0f95aa3f42b9a7c4938fc68119ae71d4412c1ab38b0fd41099a9c3ee9fc07e76be35aa6a3846d29f7a882066e0b0a2c7e39df53d88335d59a10496852151fb9774787c163cfecfd21099e89d5372fdc4cd2a1aa4dbf3eab5745f9152f671773df0c399c1bb413bf75f6967c039d26ec9c4164e105d13ed5bb4c5a3a1cdc72d7d8c0934e7406611a278eb93273a0d466576e7805fd597dee94ce79a2708fd7956159148527aa59c18dd6399dd219b20a6d4ab54b4af093ceec04ba0e0971ebaebed817b292e7812e2d40766b39376723b2cffae058f4fe92f2627dc40ea16251a25c0a2b31003ad6bfed4cffcf2d87cec8b150156bc59c92642583e75fff4254cb3d37c7d18d9c2d4a7f9fe3ce2669c4ae9c3bb1322866c4eea61e9c41016d30185e4b4e8d5fc6bbba862525a043fa66cbb2bc092fd9214c7860b9678c058ea01930587c4b05456707926173b50041d63a3caadadfd1f6db4990335e45f8bc6a4167030210641837b2c1674d0a3dfd5f55e319468e4b12130e38ee03eebf7962145dc9ef991196cc19f6b658a6bce0fb932eaf4f0d0d4abb887b4110555110f98b32cfa3891aa77c0851d6bffa5b8f1d06b93810bfc5e0559671d218c89d02e52aaadefdf7bbb135be3439663d8405b9fa50058fa8b487e558c3b146a8d3c319e9d1eac157245065b088e2bf2ff9c0b2b089c42a730833ab9dd0a5442702d482262f871acfad0c592d0f98c51592e14e20334341ea8b45586c28ca8885d8eb0ff9aa0e8b875a9edb07804e75ff4b182a3566913b427e2683b968f335206c19f65729af37b110d432547978f9c145a09d0427325c660aded13a4562a2651b841503fb5e5b7120a55af5ca48dbe12c087e2a2c21d22c22270b612a6a9c4a7167efa341a95b79aca526ec9852ca3fc011cd5005e70461f3396347f265070709538c02147bcef8763e2d01ea3a8ca09cf0aeff50043f3d9002516dd6e51677dd203215811db535c8160ed571c5f330835d4e0a386de08e4227126415e0ae8e5f76d31fa6a4e85bc7a639b81bf9c4e54b440c5249007485d7d9169ace61cb7376b58a282439694ada8c524ede3f5e89672eecda2b5d42c34b00472a802997c39a8594871e195e2d61cac1275bdcfccc9f0c8b70ea2e88cc6d91f5868a0dcde87d5779ebfe5e35bd0b31191cfb30aa6e2848cad5b9e69b25d644fd113fba631d1e10110dece89ef42ae3d61c357cb3b1856337417ddbc9b576e5f3d0f406f9e547142c1ed99cefe7a55c10a8f5fea4bcd9c2a403bd3ee9f04fcb2556154fb5eebf141a6878be7e961626f4348e987e07425a6733c7d577ebab0f3d0e1f71143fc2cb618444ba1e7e7fc32d7855200261a216c48461f40ecf98202ba3815137d77bc8f3ff3341ebcd0ce5ceea468871a9280464f842eb6fd507452d6877b02ed430a34aadd2c1bda9009658b65c344962c6da4bc7ed8292515fd523882092eb1622416ca35012799158144a21688e01e1ee648b54e99b9509f53f9f8aef3c7b40d0b714c217fa67d5be6ffde0c5e27529a869d4e7bb103157d6fe10203caee46c4eda3905ee00419680224033637d2268165b57adf26f4ce99051b11be598f1e5c964f538a92fdea2c7929c3585adab3a7d14e3b70b88b9234fb19f7ba125cdd0d0c5ad42de82354c4cd96797905640ce8fd0f964fa16368aee67959b1428216012bed4dcd779ed8a9f41bd56a61275cdc223de2a7e9516f595566ad310db4f54d41b65bba7057f5caadb5b177071de4c867c1f6b3cb7915a95ca5e9236f0e42b701884dbd3e7f5cd762aa9625291bfd08f37e8e0176c5887d15a41237d639cf8b6954b75c706ff3421b08b9d52e1581ff60d272dfe21943df8a2ae81244f1f5166293c72c5b648f3ec5d375eaab26c5ff7bbf418ff5ec3e970cf6386e28b0dfeba375177ea20365675ee7603f08b4f37003c96f92b03bd7ae6527f80ab2a65fb57113d562f3db5023dd53c3cca5ae298c588f0934bb4a6acebd45a284193b5fc9e831c8816f6674f1e82fa90f336e37184d00f22e491b06689b92d41b861d21c7829fc567aab75c41d77486c69a151cd8b570e14bfecdd53cd70ec6e54f9330146992b63f617b8b534ffff0cb3d22f2233c469551aea36300c66f26b282f9fb1308a853b1f79b444753058214328d14dbf2e3a123241b7998a34b1c108ddd6b4a3b6254264e6ddb948add740dafa77b740e9ce33253759b32634a7164cfe2ad441360fee11f86a45d3e828209ce2e30ca28781c768bcc3e077949f17f8c6cf3001d1701bf8f2191098931da3e329d1f8a44a5cc2165a9d790c18e5856a880e68c1ee2d89133b9259d9e4ceeff14773f1567b41cc94f38ed69e88f52e1a8edb7b0011f4c920230478c66d3df164ee8bed4ca0fe55c5a6e33bab126aca8d5b0fff67e27cedb547b738df3bbe2cd94f9bb02e28f185ca21ef4c880e081fd17e4001a405552baea66defdb372675f1b3198bf999a605960a45bd6ad02aa544f066aa101b43d0a6628b4bb77025c2ff74165b84ae0b2ac0bc1ec08f632ee314831eebc8f73336287163c2fcf586dc49ca6f25850d903ac291db4a820cfdf9e532c79f12e72754a128c3c5c5a39df14edbbe84b77b03c089d7670262a95ab1e2683d23cc2813bf0a172f895b43ee03c732569e4864ac927089e87b1c596d9c0cd98b98366aa98b9b643c602caf0cb730bf084b9af0a097ed958caa20476d587ccbbf8504c98618404c96f311d02ed210a5707f781ce99f97ec0d7cf988693bbe99747f23a7b3ed465ca92fe3350de84eab07efe4f555a04dba6e780ed1dbb4f22b001c89e386d60beec24b06364e4071b9593ff6f936c9785d9eac0f99b80d5af875b3487139739bd28bebeb6ec28807609ab8601cad90868bd88a2590e41ebfc7f70239384854d306ab6cef57e71716676b0d4ccef5a71721736521cfca4a2e19bdca333b9e07e4467c24c6f4bc7c5a618d5b8d76839aec483b4933bbab1b1647dab175bcb2e1f69d649db2c30729e01ace2464844c68523bd668ad885da88e87a0659000d0aaf5a0c2f08740815213675b43caf4a5ee2a9d99bb98ca477ed7aace4c15df680744b08d6a812d12e009b16b4f90a17f97b93f19295abf6dabfac890b427007c8900ff8737c08669edd2e1608ce7da85bc78ad40a66e041a0fea28f9c8093f746bfdf295958466c536d764067821ab63cc5483da8096ad297bc2c55f055da7fee171c456d80d54511f2feaa6c7dbca66499ba257ac35004e3fe312bbef88a8c76bea6e3b3f343b4fd34b7a30c3be6543ba2c0250c6e482c08a3375062bfab84652350c217251b13e80dc52674d0a255945844cc706dc29784b8a69824f50b3b406416bc955d48d32dbdff729f24ca5834ce8ae47502add4b9bcaa0a50e92572ce23a9cd1a9315d6442e6a545351abcd707ec162f471096e2f9c21a09acb0ef5913df63810fba676fbbf40e02c923100adf7768e85cd8273a6b1f7884315d24b738a9b0247cbd541fa9380add82b921b93310b8e9b48065fab2062b47471fb3f70c46ef5f6d04a1eb817bc6aa230d32fe78e1ee0103af31da60c93cc8f76c3da765e5856c2704d744a5692857c7fb47a436916e0c59dbc8ecc8b674cc89a99d744a89dcf69b74a4cbbc11d473e3b0d3606d7fde8f0637a794391544ff980cbff0f15af44ae8435c9710c5f7b9a2e1285d30b6e17e312135f6ab316b71c7eba69a0d0bdcca36a5b84a4b33b8fc9142096e51f475b5ae48ade8a13ba698b9fec2eb68ef05acc979b3fa2f81d67da0becc3e98e82f1405ff902c8f129a7abc3377a2e591e3edc7fecb4e1a947915660a6b5df139ee708f6dc2cacbf6704463113c44a786a51c9312268e708f6b43fdfa3a1f60d128cdd66a125ef7f7b6cacb1a98dd26a547d4f18f2def54a72fa9b91e831e06fe74e19f1b7d107e2a6783f21e13c05847463a321f6241c1072216b48acdd56df444a125db3f0ba42232f92ee83381db243d7c2b4bb16503ddfde14ed55dc02c1812ab458470fe06ff6e89d7e800a9911013765f03de0eb39aaad7e8b653d3c96b971fe2aeed57cc3f5f2399ebee8f73e37e1b7de38b83858b44678bae75a21fefe486d5fdecf2af782167767dc581795a1276abc4aaaf164d95e42cdfd8a928d8c198eadeafa44d3b0427c296bfa535b5a8fef5f0b04718d188aac3b4fc74f3d83ab96e2dc15daaec2812c8316c13025d071cf6ff00bf7277c23cac248668ecf15a85b4f2ea1a08ade06e0e6f0fc27dce542e828b7456da42dc44ba845b41d0e3db77fb3fba370bf2d57d264d1054f50cd9a3991ee5a3db873e123102851bc08f97814da81c1bf5b8bfd025b1ba494918f68e65dbed9f26ffc9fd21036f77c5bc8a85334f55f95eed6d369d6c601810ca8da94e82e40f66b8e2efb89b7adc0cd2cc614354b268fbbf6d5b7d1ac3297dc99b59dd1beeb51cc484b58eb654ab70bebb918d4edb2c7f2b0e01326c03cbd0415b1a0d07bb5c73b6f325e5682a4388023a6d40d52724cf7718cf782cc58bbcb2242765100ecb49d66f46e014149e823e32f30e1aaf205a2fc313fe61b43cde7fe8b4f38f6826c79300198e71a64064467730bc43acd18588d66cd44a6c5d3d7a75362df665457a3d67bd39aedf803dcad64b11863b6c93e44290978fe304a0c7e4b20b2866f562b890cb92b5a4500eaf4729a6bec03d4416b8889348c896d179ae8fc8dd1ee716c2f374e3641f7f41f5d83891c9fdf1f249dfa8fe6209430ed654dd15fc864eef66bf922b267df325bd095c3a1880f72249806ec80166fdcb17963b1b4f43f0208712f8c9dde3071127226ef4961848d48e07bbed736c4ffe488d6779a1a302fe8aa27b3398ae29406e1b7e0849347f7b9bc1ebdf2178169728ea7196b9ceb51e81672f54dbffe970f97b09df34b2e892ae132f54dda91bf665c739b5bde3b4f6bc6dac6d1a3bf48106d5fc60c5ce8dc46ca5181c7cfe2f3b907a78813c2bfc5ac375795506cb91b4d3a822ea798a76d6f0564d0fcb256c4135f9dda93cc00941c6adeebf3293817ea3bcb2d34bd405b9db3cc090604970d21e1c7e67e13c1b57de4e5283f7e3594a790ebc597df269eb19c8fd4a5d7fa403a7c27bb0ea73d49676b4b8ca658c4415529bd7ead0dcd6b01dcf5b63cf8b667429467f0a6a18ca86311b282706e90bc3bef5160b14514e729278a3e585d4c81c93cd88d1dc6d329a34ed3ee201261e99cfcf08db9266a16949aa5c6d3847a1b871f65a4514230539e0f1de2c2105d78ab0b162547e11a50977bd242b31d84c4428a04e205ed31e510efe5b223fb9dfbaf68769f333d6abd5aaaaacc5a4bc01fb807a0d55f7edc89a23bc58369e14c5e100e17882255908aed14b6d6b0ba5269f71eeb947aa1a8d31ded528ea5197411497259f70594120a6ae0a14fdb8756a85afd1bd2d48e9cb90f93d75ee0916198a5ff1c746b5ccae0e1b733c81835a19835ed0affb296fc09d42e4398d641d9deac3f5cc4bfca88f21e7177e5d9605fa596b35d60b8522f235becc0ada02e2f50558d0332b856eb066db7619acea3d019bac96aea407d8bf2b5e216cd3dbdf43078190d15f984c1a8584740b1a759840c957dbace81a588f1ab48e70b9abf9f7fe149917eb48c1137f506dc84ce40dfd6a5f597265468e44d4ae896d3586ff7ca6e22d464f111f97db76589f602fe33e51a4708143148a4a58a6a5a6abf5e15643dfe0e21942c527ca9dabab9cb3f0f938ebd3038540feff568efa8218f4223267e92539da8428e042365ebbabaf4c9e97390473f0f91253a4e739ef2494cc9cd031e7232ce7ae0c9edbbf254424f91a1cd79e2b16b2225abfc98bb6461ed65724f3af3b5011caf276d294dab98e2e9760a37a564649775f9c643964565234f2d30bd6b021003579cac9b53573403c2518300b1d29387b3106f09cdb129e97b4a6a3b60158d8af6e93483c5f1795a1a8c65c279244fcbc46e18be07ee6f6b3252fc08b96bdc23722f139b1024dc899a82edee2ec1e21f7b696bec10b3f3f7e46e5aad0ca057bd0a8e9d35dfc395d0fc8b9d317d3a159d4a27925145c1cfbdb94cec6286e88302367e2e6ccb471aeb3c1142f643a259305b1233e3a4f6d147a7a1f8fe04fe4ca640702c0e12ff1622b7a7abca0f2514f87153e9ba2afabd9333e59ade4adc0bcb039f916c7e3fa636474306dfd2d69bf0ad6ad08a3dd75ec69f001d00f6140589b22350b0bd4b03c8565d023e3f7f5a716fae37d2e2f3bca5eb1bb92f50524a30772adaf794d5897f5d4fd1ee9e21ab38af09461db77f4395984dd489d6a18af437ed1e33102e6d598887d754cfbd7cce23c0175768989a8019ead747e9f0ead2d551ddbddab574b507c0f0ca5b571a9a061b442f35885d776c56b232bb687ea60fea5df2d8e3c1c0cfedc2ef855f1a03b86dbe2af58ecfa59d03885322ed375918292aea5954875f651065afe1c6bbe5f8dabb3a09ed02a90cde7d7b3677760759c8720fbeb1aec4b72b880d85e05ef362ba25438b98da58e8becc58bb9b42a9f78f6daef672cd59fc738decf1d46a521a2cb041bd837cea7b4ee91ea38203276efd4d7644d0d0c15f217aac188edf831dd31746cac6c8a72421c8e1e939f6f941f78ca4c561b8c7ea0ebf683aeb9a83b2f5999f4735239b74e68b2d7e7ac99ed54a9d17ad2cecaa7851f0eab25b4c5ec553a75ffe11f068b8e95f33ada5b9bf63d9e10ada20203d8a5f313252d5adffadc592e84daa249cb7f79a7ce71292b328fc8a7ef25d56a0d58bfc14b66f415c09278e898240668a826d7869574522952f91d558723652370837e853c7ac1b82fb5d94e61bda04089564e8d68c4c198066c4d058aa8518582c699a5eddc0dd5ddb16b56a1f5560be441f6bb423a75afa4c01dad28c2578db16e7310c9d601490aa0ed089e44b5ecf98989a4c52700a60097a838e41e819642de2b5c0418b914538fb66de59ae5420dd3272df0f6cbb28b3672e91f49bfd4b80f33da5f0f2bcdf650e579dfeba721daae9d04e4d3350953b58914f6f2dcca053f553dcf6499a58d4db0f23f25dc965b78b14539fc89a75c4ffba3c00efd99dae4827fb632114e4c9271433450e5dc6d9dc676398a6e749ba9a42ad347724dc1b2691d35f491056345ec2e91e509d45f16ac033da9785b96b735e540d88391222966e964f868caedad7dd5e9fdce1ec94ac52ea4be5026bd75d9ba79d74537d811e0790333284af84693867c8df53a01208971af87f067f47a82414701624035a3e2b53f753bcab5e71eca431a8587ac5e520d9cfcfe21c7f2e4e7de67a465412f9dd2691950b961d7bb58906d7d3e7701fb00ef63d76d66ad6211f5b900695f7505a6146c79c52c691e38bf35410daaef7e63ee206021156a9763d5d8f12384905ef00ff66cdd7d515089ec592fe663cabc8c7e7168b5658ac35e65c1d6b0bbcad7eb4aa08a9b3875cc0eaf5e3132e413fc710344d4a43cd1b43eb860df6a061b0f44ff0d0975ad52fb68304374ba036c1349d832058c23358f2a71509eaa3d5c4b51f22e32de561edfb5df97701b79b4d17821cade56f8fc28757529c6ec9258c50b84575e8751cc143962eed4dbeefe852a0860a8958218bc8f25c5ab3e9763030e6c4777e726185ff4d6b064e469ae15875cb9f572e5b0c7f5525b0072b8b2a1c0d2eec0fdb75919e5403d7a7ad119095d36d0378d9446cab76619ea10f9f8932c668980d67f3b91711a7bba88bd09fd7dbae3371efce42d90c0b50a595e313ceddecc44d916cb768b2eac093c0647171b86ff1d00c1bccca476644f785921ce2330b91b40a228234c02964305969e8a573d9b688486215bd58524ca791e8f0ab5fff10bbb72c7113d2480aad7b25b45639e520427cdc4bae28e4e183a8520ba96a4f9c2e134d1110dae729d4ada4e964d6437e3e84ce2aba10dc1529494a666541357cd5d8c3faa5f269943b79a85dfa18b048e789a36426a744f6727aeb43379a7e8b4b1d8b8f09d910d46efeb7d72197a4dcae869de07eaa0a9e9985d5ec323e3156ecc405bcac7595710e7740c3de337a04c104102f86cee7d014c4eb5ec4b71cd7eede4a838fc39eef6e7a0a348d73fa8e42fe9be703da9456cf1c77489a04f4214322c62f1f9dfef11e785e2495a22941be6511e7c7d549424515238f6a6d7c583804f6bfe25753cc69b50dc146064b6fc3039b2b9453910b6f329790ab09432f64dc80edf8d1c68b4f5521e21acafde9425260f39f2177d140dc6d3d3d52245365d56410e969a77c7eee5e68aca7155b512f5956d5b2007339aeb7d63ec99fd65e016114f3253dc4c865db684808a227af490af9990a23ab8b4cc5c58a3e3b88f99537a84d408f907eaff5ec2f7ee037098a9a70d971acb53873083a19bc29111c2db84ec60fc72cdd19bcbf6394138b5662ad7f722b776412602cd881f44ab06057edc2934c20e79d7545ae5770e56984d84c3081866e02b521656a99d68b7a47151e82924ffacc2b125099378b4d475b65bd3dd38985ec72856e06ee195fe2fea394bc3806a20a366996db159811ac439ee80b585f6d45ff0c782096de00a9d62ebf15649a9e67355d5a67b226ed23c310b33db3ff3266a48fc699701b0c5f534e3ca96268b41f162618805a348188b956de13f081e238691f6b346f6705a45acbf52896d5f638acc19facba1252046a0d528c3334d478b42f9a4de5b4f19e5732ea24f9e34accb357fe6a0e4dc32f81d7a56e5f4d3309581183738d39fa65cc3cb86411686326872228295c1cf71b1504ffe4462a85b230ef58633242b99ab80d74960f94c4e0959d1e5a306763fe1a66d17a8572874ae3f38ea9dcc111f8178a34f062858a8e286757ad91b73c1b92b411aeb51d63ebc6cc0bc438920c6c9d35b0e278810bb72d518cd7d876e036d2666b124207dda62155541b448297b037920c54424d411e4fe3c12adaaae05fd3c5bc3cf8016d54b791c9a75a46644aeaa58202b625adf7dbb23c5bade1e27c45f3038c327fd17b75246a8be99ae36a87a30aa2a3370a587a61dbe07f57558a53120717f773fbe0521146a7bb1b81c5cf042b71b09d38e4f140e839150b7c6911b961e1761f7a5656424bef73fc3bdbb470513a43eb902cee0458ae01bc5e16b07f6ee119f17510d334aebaf2c1e1c3192caa2397221fb7b36b4e375a34f86d2afd9b2a15ab0e6c8764bdd2ae6da6b32841c1bffc093d94c4371391e3db5dab1c0752456001c2abf8a50d9f23a9176c519e47f1bb91a0b1f9f6164a62ea306c87d1e8481626ad06d4a2b6c23f791816404653b0703e8f0d9fcbfb5cf722b56e4ce4640d1df41dd4470ab85ad3cb4cff84f97cf7a6fcc7b0573d11cbf723fb8095d4808eb962af19ebf26b1a7e3c7e57b94eb0ed6d82db96e937d6fabeedf4a800029a754429da85d1006db6929b0b851e5586dddaf6fdb0807f06981d19c4463c988bd342926685ccc33d6aa2ac0c93bc1a87cba0a9e7632e7350606a09869fed0631fa083bc956d30af91565f2e2c72a40d231cc3716940d45d92af938400af91c4097bcbb582bafeb4e93ece058a04d26369d32d85c3ce1c356cf4a33f1559b0a000b3fa9154567ed43a9787aa248a6417a6fb22e1fb8690d39d4971330ca4df3fc02aace184b4ac6e617b86cbb727597b37fc522210fe18cbed32f16441c9c841cccc065687e13e297e5d464d7dc6b9280b28406e1360a7529a26d6c73d708db664553e102c4feff5783b1da56248b8a3a91093d21958f77e713f23e670045f7348f7f38a8568ba76568cc49b67922a1332402534b08da9231e365210d5170c92067f7830c6c64548e7e95b622b3b10c9cabe4d07902b7d46cc60e095a4f7de38d83e097a5ab65f0b4bac757d078b68a7f887036c0db6179e071af520e07a13bb6b94861e3fa194a5bfa116e59b20aa208b16aad901a27de681dd03f1bc50d718eec12497990b540336434e3e072baf76cfa309b477d08290f4bb0338e9807bf89d45f3ab3d9ad48186a17e37a97541d690398d6d2d828290d85f81f10cb662fbedaa74b814adfafe1bbe615577ac7c50083eabdbb7679f08dee646ab4104da46bb58535b8f58bfc6b703b2b83f2490348f336f1dde7210a0ca558bd2426bf558954e9459ed85f5bcc5e583e7534d4ae0223d3460a79189f696bb76f014842abb5f0d64a3343adf11e8487b43e9502f7b7d2960e3a1800a146a2a2e12932adb8e5c89903dd7e89c33a6c89f354a9b23a3dd2cd65d29e71b3751ce0051fb6a22743ca5c6aa00924484be88584261bbbcdae1d12479da1461c1aa82dcbf534dda6035f86cde4985461c843ff631b062665db35455317f18966b3cc642471f4218341c872b87e834874f323e90058beff69bb30d96b86ddce547dbb3beb1f92d63d395a0365332499cb3d5846541d6f4d6d6cee4b00265ba0f635a2868716e6c81c8732a30b8a1691a90accb81a701619c0578b536d8cbabb6e46449b1782defe11d78fc763d87b167601ca41bd9ef2940919e9b272ae2afa507f491855db055735c0b883549b7e92f30af148f8c71ba83b00d00825bca747241dd62ecab25e61a90b6ca7ad196c6a01cb8c0d196bfa564d42d86aadcf21098dccce9209734897a320fe745b864d3b2dfcc23a8b992b35de7f6f3d96843f20093a37866959c412923aa8461470ad3c912ae2e7509755d50f4131cc719c287373406aae1f8a35a1fbfd8097283e0c0c8bc8c754df418cb616af695d9cca32c7dd21f491d39a903657029b98e98e943321085ec6d9e391ff2c941eb6a256e1d32140b8058a9c27a0d105e09c30dc0be98d17c27d15d23b1746ec8b5638c83f39ac2cd0a874a6057b7254a02cfa267563441815c4af15a2005331b31bbd9157d3f7c809ceee309a2cbfe5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
