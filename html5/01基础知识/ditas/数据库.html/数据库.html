<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d9e2a16e52c9214f5b84da066a2c9abd9b7df84cf69c49b1c79d0d661c783ddd47d5e6a0d03a8e3522b63a76fd0375a099c53be07e3a08c3f99031ed94c66dd0c7333ad2bcf46275f494da5c5243f07173808e11cc8d16e361f3d94098f0be472b0c3812bbdc532ef2a40aff42c121d615acbfc26d56b42dbb89ea636140fa8686fee400b9c5ff3da6487f5d05bf19fd6835d51bfdd71362323bd9a2af1c6a8119c11100341c79332c9b25e4710afa17803c485205a65418eadbe8dcee4989c4355af4f14b19408fb635d70a67fad6edc297153d9e5ed53ded65819f7b4e588ab7110e8752c2d8ae4dac1e88db447399a15c7e47478772e462be01a5000018ac89df4625de5ec10e137fbffd21185660055a24f896e5487f369ee7d504bffcfb326308749d4e39685427fbb44fbe23baa3c23cadfb6141aa1ec6c64cb0c1764254c6c7cd5b92202aac41f4bc9ab7e052bc0fca967ceb455ad929bd3a89a15a6cfd42b39e8ed854954a512b483f306666c0f59eb7fef22fe123d4a9d3e30ed7efc5596bbc60140f0652ac7c475497f19d1a5e37a9b24d79c28a76419165b61f41c2348073117fb66e6929a412e5eb1f7279dffc54e4d824bd88c2a618384ee7755e85206eba6f638838617939dc6d3340bc191b242a6ddd7428a7ea3a211ea91387699ddfb3dea49afaaf1490346b178a1709f837a3dbc2806e3f385c519fc3fad89321ac55e5bbe9d74d5472dc8ad071b77c9e90a888a3efd4f87b35a8eb77e4716e9038c931eaa813d70a2536091c6b1e49ee0ab6aecb14bdf0aa67c7d0ba3e0bfda492e71fe38e6ccd9f027c5eac6b9095c6bf9bb2b45412f3e9f59d2ba88a1ddd965fa8859f57ffa93d48ed7df0e8daefc45ee86849a98f6771094f3e0d79b0a8d3bb90f27bbb24f8364ba0e1de835566cebd05e5b89507f36efb293fc6790980e02bfce6a18c48cf3667459a85ee5c9e5db6b5c53fd05c56f71e6e1a0d0500c6e8a37914dadf53d5899337f2a091d5e5be2e6208d59c16ab18ce6d3c8ca893e9a41654ea0dda99c7e430a3beebc40cc900a68c67c99f98726f9e0395aa8f067716fbe4d534e41d85f3ffa5ff1bf5f5bc3ee6e03ad78db760251dd339d71cc4fabd18de7860596cc94fe2f70e858f6066b9135d416674f20c2c427d366f0ee855e0f42b92c4c023f2c274a59c7500ac33196b67efde1d2214b19175f0efc16fcd52874b4c83d605a919837447cca56609f49e459a07e2590537c6609413e458cf5f0332c766268f4b11489e9996a65a5a5ef12d033000c7d97cbc5aeadbdc0f2eb1b1ac954046287322b09bcf91dc82cc95feda332d2ba4c6499681cefc486ea98960f01325132ea18e605bebc0b99c16ce6b3559d14135e64ac584e7ff8adfaa1b5795d482809aee10342895853c639f496cf5cc09377f3d993fe025563fcb4d68eefd3a586b96b27883780cac44949413c3343e5c7434cef9d966b10034a834e9fb1b47b30b14d2277d728f98b8721d3f669fd555dd56f2ae9bbe1522b428d82bbcb236e2f4d91c6b92bc433a2698d2fccd3eecb97bbd40bc2721bf36acb6c4ed3cbd50c17b9503f45019750bb3097d2e4b21308628ec164f117c46fc271c8d786bf5bff35cb0c0e5a44956c3944916431337e37bb5bd4068c9a8e48569d30ac0b6f8a2c51957e27d736cac515e77896fbb11894ccbbdc45e5835b31fb72ccda63c954decdb9e04fffdf5af76bd944737c4090780b1ed006eed8e65d3ff3e4bec057421c462742662d8317c306c38e9bbd5f474c8e3916cd0c14994bdff8afd0c84dd41d88fb005285bcf7f8f3fdf47bbdb6e79d81ebc00fcbd15227cc1c168dc713ae0b00d629db6306fbfb43cabec0e97e777c9047a985230ffceb182e745e44108e6e3dae4796a679a37b335ffcb98407982cb85ff7d8870178b322ba5adf708d82bd29e07a89e26646d46af3ff0b48534a5e8ea8cc9bb04a63111dcb88f6a49f239d345a51d80f6964de15384beb8d7fe6a025a02c236536959a475edb7249cbe7dbeb9bc33bf202bba0f45695b406d1888dd42a54307e783ce39a11f37b1d3ef0d426044efeca19b7a6e7bb51f7e5005c840ea8b39d98b76a6265379a00045b3d25463867b9a43dd695cb9ad45cf1ff37e3adaf3ae57076414acdc1ae791138bb1169885113a092726dab8a258ffee868baadc13e11c871b49baf62030dcd4d932d7f6f4f2f9e6b535ee32c583d6ebec491b7fb9508a17cf01f5455ead9ed10e59c5057d8750a1e8d66ac6e5787b88572597f46cfd9748e18aed6ed08fa5215148a943ab71ecccc482354d481440f3661f289c5cf13a1ea0fb076b198a00f3bc7407e0d879b7c5f34f03e04410a016070a0caebc95b9d100c1b3b85c550bf59fb7a2c5539f504454c6785c2f978eb5a97d67094ad721689599eaf09f98077bf9968b367240ffc096ae379af00124fd218d48d00a545f2129cd79ed1ac276ccf69f2b531465821735aa40e3cf8bec04701dc495e1379c6834b6bc376de8129a36e30d27ff5ff81c9943abe6188ca672886a68a89815c60d01dde84400831d95b551a0669e23f19ffb68abb41ee59f4148da2e3de4348c191e8bdbc3f1b32f32adfc04c9c6da680f2e60d51f7f7ddf357ccc2e6666191cf1566a46a0ae49e2a25060707733fadc0843a2ce9444e34a51e3a12f759a50c90b5048cf5fe3cb72f6bae87d6edbe060ed355a759c9634255f65ddc30db72fe6e0ee45ace9c042106ab370a80d8b94da839a8dfac655c90ec9e5a062fc91dc57bc65f8c63462bd900fee711d2e1fcddb13cfa240e18b4a16026f3242a34b8257fd3f6ff834db2dc9686540e08131b20efdd785ed795400e48ace2099671f468390e0dcc3df951ca6e1fd4046baf531a6047523d4f8a46c635648d80b7f3e19f3b8db2f72819e39bcf602258c3d840f00c6022b5a764428024ae1992217e545a2a27f145b5e9ee1ee2bac96a5abaa96cc95716688178798601aad40e49e51a5dd2982660c70bdfae28ac9ee2b7f1fe550fdcd459dd9dbe045cde0a14a198fd26dbd8a7c3b2d7423cbd7394a99eff5f22b460bcb3f407dd7e8a8cdce8c5c99c7862dbd4ac6328ba99a717800ded02ad14d1a401538362f4258d2c68ac5efc07fd3b2a94831b5239fb389b0eb5ed5fbaaee70576065f1df4f9666238bf18c5c2e2ea3f083019160aaddf7fb861b3c216d2b2478fc74c6c82511ed0a7809cf06d6248c12ec0dcdaa16b89e81dd4f9c0adc376f3d76932dd98874093616e9b1a88b7dabab5dd19a57dc02f3c5c204409b540f8418b1ab3209bb4c009910485ed53d583b2f52d28b8ebffde2136a1dc7589bc766137b23b8e5b78694edde9863df747169a41192debadfc6262906e43d06aeb94e79e394cd791def126a41ccaf56ca01b261ea5e4ac216bcf981f8564773e20ebf77ac33ce8e6fd9012e7ce51614621f617b3dad5c0593e208f6eb5fe09203eb7435ae06f19c5032ccba48e0630c2de28a49f7aa580df0071d77af761f0774879711af504a395aa45e00a1397d3df3b53cb1dfc69e4890732706da3e97b619eaadce037dd0d0266c5536be447272561489ce4e566abd5e73dc149f2845de4c7eee9fa9b98a2aeb2504fa6b4f760d68dee40f7f08f20be0ded03dc1a0de4879b8859d007e0c1d3d47d0b218f651b63ce040d34d221b8305e948f910fd5c0348c4e9f4594a0744aaca3abcddbc4ee3d47d1ef756c2e547db5a9183bc5cb1b407deb91abf20cec033092119e1cea2fe6d00dd76f42fac5be62faabb8701c60884947844ac4817f9af13bd767ddebe34c7e87151e413edf944c462a45f232eb92c16587a1e18a243c2a529a2dd693c665c2cb56299cc3953a8648ac5ffc61a55ebd3e6861c3b4a2aa022dd0cf9529c9ab4e9fa28f6e866c108996bfacedee731ca59fd11c2ff71e08640355d5dfa14763ad5da02e11692cbd43871312e5be1e09f499615c124e4ac289d093a61c4109b871603065486ee80b0aae3dc1fa8fd5a273a6c03daa37da10b7c531121b22285b763c94f48812e57836c4083f8391d194bfaeb81faefc9853027c3918eba9e9ffc6ebe3098626b7acbc0e8c0ad8491bdf2ca4e599c38f86ad92fa0c0f428a512746bc0a962a48dbd24c625f7d8c69e00381e00c5629c7a0ffffebcabc37bdebc805881b4b7aeba1cf63c66e313908254803a6bfc6028fb85602737bc1d4a428182d0eb9e9ef73c09c2a5a189fa1952ee7697e4a0d52ac709d347f82c9baea1abc5900835b2f1f203e311eea720a4e789a1bbf471690b8002d357a75f23bf3cd9d1a2b37995fe09e80153293d0ec4ca64f8d3b7ef98dc43c8d00977c851f30c4911ab7e1cb6048783a6f737a21c5e379c9038255a149c6968eb6ae858ae2f603b9f085e659e2ebfb54917d159c4c6b808a4f1bddd20b07516d0637dd0dbf3c2c8fe45c370e8f96ff69771505ee7b09fe3773ed0e737f823818560eb67a7a77577963f49044a3d9dbeb9dd561c3b8c7ad0ad01db43a9377bad6790490b2e96fd0513cd4fe41633f2e6428da6ce4b9e4ecfbd350163744ac3adb1784112b9c199901d4bbb3d559eea8667bb088c813658c81f4ad8ca09acf84f52a65435448c0cb6bd599f9d3b43b610ef7cd8804a7ef59146fe39c3fdc5833512e640619da3488e2190fdb71d0a69d7a323ac9dd14eb8ccc45abf475a9b3c24b103a316be42169ed75410f4cba4726453c5da2379cb4141af7e7c995d49f5521449c6d2eb29b2f949f19810223ce3f82545b27aca5f81eb5f382992e0627efdf393522b393d7c53cb42d0ca8211d34846689fb84ff7e728644d0c15ad47ef1dd9d57671f80b26e15c29baacf4cda2fc2581fc7eca7b3efd20418909cba45e605f75fe758247fd31ed693620a595986e15ab539972e6597619c2af1c2d9307aca8d34ba4c46e6badd7f951e46d44c8a3259185a1cfdca10555741b8f7f4caced75d52245d974d0520303718867bf1b913c61801e9d56d69383abf5989e8d352111a876266d928ebc4a7bb19c43b22cb5c34ac4eb4cc474715b55293d10ecf9d412dd9dd2c74da391809b86c8074668993b2619cb58f0b444cf1328d468d281cde26287dfe9aad26ef1b03751f62e4a0c87e08a69bb6de0e3690adb0dc5bd877df9443476d51da2583a6fa62cded82796b1e45fac754d373b7f92a6d10f162f75a60850c104ba4f4a25de1d5ac841876c445c65f7360c6e2608dbcd07b96fee03446389cb1d13b3c477cb551d8d56fe6566281a047202e4271b8de92238abbcdc3e9778a961df066d794e7c9a94339478cf6ceb96f4816a58a29504cc92db01c31bb8f7d8c8824c3ec5a5a224c77104cb56c0ea504cd32649a3d194f16bc91892811cc6a8ebcba341352397cddae2deeee87ff2af4be8eed45dc771ca9f885b7408b4c9e50c41edd39459980a6f947e207b9c9633988ff850da8652bcb4535f5ffc9abef3799dabfc7fae354531d8bf5e847cd5c40937b01b1d07f961c799ba6e6494777d84960efb8ee7b3f3c3023d32174be0f709069d50e92b44acfc92e13f97af5b469d30f87cf6303a8e81613f790da706c354b8f010818add69524a66b97ae79eeedb3206bfc17b752cf3bcdde8d8e08014419935d8018697b84643df8f92e8942a7ca1cc96312e06e6d0493d2dc226432622a38566735654d18ee1569dec523ee5e4b86dfe11276f47a86eaf07e6b8a432103d4d630bda8605f6efd56b9f0d1f7cf187ffab07f39d7cfeefb00298e77353d2776203eb3cd2b343ba232993c6dceba346a87dd233780291010068ef31ee09fcd7881f5c9c34c0aa73717033e0ec9552c898a696cbb2032e2d0122a6262bbd03bb4a9c20c8fe2bcdbb9518a58ce4a6a0a0dc08445281e595320afeccb897a2f69560a9ef6345e3f0a15e4538146431eb425b5037d7555024d7f709789ca3d205578bc5ec579d45d0c2c13f2c4c7263f1f0984875088f6afc42e16e82fc9da756184eb301f9a02a391c6d225c2b4d722310a27922d3568931d919f761ae3e74c6c0ada66ce216550c571e6383ad7997646a5532dc03baffca6ea76056a15dd99935899a7b34276b7fed93ee3106f04371d4b2bda44685a44f5b87d7acdc0a25919473d441874c2342cd74bdc02c23aa2bea08ba2532a53ce88e2ea790f0f1d12254274c7ba64f10241dcb948b79350daae918f7f3d3176e760685b344e938a73f6bf5e8f180137a8b801eaf2255f23b5b405be4367e25b9454a8c95168f0aa83c669a27f810a15a49a81673cb5a61d8cd80ee5658148fe6ad066e59a487d922d07248b80f2f410ab5160e752ec216a3eef73129a46a88b7939f6396841c025860837d8a46c97f28685d0d178864c0607b7d8f12de426154a9877c71826bd771361265dc31cb57f0cc6f6224c5bd98cbf47a2bf96859579cf66ed9e2a50c40b75365f2706d7a13ff03cbc8329bff2258d48cef4b5d9b07e2bc1c3e0bc8f3602a68eee9411c00a45c085c7a78634c3d97264cfb25ea4e38f8f1052b109acc3f3e88854afb44db9765784c9d55a00ac89306a869228b38f4f39637d3bbd125e9f506d7e5b95161f41283424a9d62fe30de4fa58edec702c0034ea1a92e5b9c1c7abcd89109de371ed81065e0743d4f546cdcae4c93640343d5b87eb9da26094c3365f759fe2af2647a012a144cd3ea6be3b712e5a44af6a752468543e7430041e54f5864293f3ac6dd302b1ec204dff196949228a09d98c32889542377259fdb70f75a2876465b36c51e8db92c7bcf33f6aae1e5dfea1a7c88811e0b9951351a9b7a413a3df792041c6f98cf0edafbaccfa97f4c5509c3c719937c1dec4ee00f03d747d0024276b649002d7074de426798718b3422ce2750baa0942411eb0cc7db7a4a13dd9badb772cc07e8238236fdf5e58e3b88fe457d0fde3a7ffdd0104bf69d0f389e253f89ba3fd7747d9a86fff27dda2b27c014e12b6665cd73ae54e1192d50e586ce0a9b876abe3590f955cbafd7d86453b7bbbe776ea36ec23c7afcbaf2caba7605e8c4841f8eb554e5c8701e8cc16161c52322fe4bc4155a9cf5cccce98dfaaf8b28967ad17ddc8d5097462233b65390942941a7c1fd6531cddf7cf750eb22c1df615603f737a7adb73b80d492f127aa679d0c7971f64c7c36d9519d2b571a1955a44c7440bf8e2b185bfe909d0b2415244ea31e2908a09b4ccc5dccec48631051ad5bf97d62314822d295d2a8ab7e463fbb828dd1c6b69517b1d1edaf84f7ac87ac62f0c52039c12367d19a7c2c6780a83d9b7fadb3900ce09ff2174a8934065ab7df8a90f62cd60d4a44388875f7b41f4f06299745063c3f2fc37d166441878425931d51ba55e9fc952c1e42815c22a8f1385b9915e431aae490f58f70e96693600e33f66288ab38ef715562b68cba88f8f00d3a9b23c0e29f84c72bd09c1ae455dfb35a87c0143759834e1c543b678042b4aa92a8e4844bae01164617578dc4177f56e880130a3372c76c4424c4c3f94cb1d93ebf84419f6698c661562e8b89b2723d50c0204d58eab113fd15bb948f1cdacdb08526f7b3e37c45c4ac115e378e00f2c7472fa176453b31175a1a2181d3a88a08a266cf6b4250e33a1bbd3025993fda9c04ecd51b9621110ca5c53f0ea2bcb091cafc7b26cdc55da6475d003db125110299c14b3d67a1c6d4cf5231241ba4d8550c6e810a10d616c53706334d8ed3d20543cec0251764eba302e6ee06cd784b57e3b31e777c5da4b8bd5b6e925a568253e0ba65c61f3d8f33424c59e9a438ff949518d0b2520ce4d9f7eeb67d700aca43c3015abc5c30803f78b593055a8bc9a517c13af7a2efaca2fa515342c12db532d4af881ab1f7b1da9264144efc9ca12521df184a4f132f0a113fc577c847f66e3286d4d81326b171af834bba1a558ddc75611daead939e15661957356c590eadfd9439798f351e86e386293c9fe07783783bc5d6b7e9aacdf626a0843dd502ca58c046de9de7f633418d5d9967a5e9d019c9db5fbeb597087f63cd52992b8a17f83c2a9141c96eac19d144fecd040548f6a75888b868fd9435e4909520e100ea15b06c53d1989770542e8142d6b9ae6a019f7f10b5cc6686a999c023766e211a446411acbed3d3db6441872dc0efa281e370853eafa8f7cc0f93a33a333c0e19b133f33aae722dc0e923183608cdf4defa9092b4e951db749a9c18b2112da6fb4478d2cb7ec56c5034c09089fd0a404a1260eefaf5dbb03e08fb563a5defd2db0894b90c90bf46fef3f52b62d93139d0f4e7c0746874a46c095dc062360d32975adc056b36c48c04e30f0bb3176d1b04d190f71dee7adb27fe7bc883260263c62828d5023bbd285a56c0b1d56af2871d397b8aadca336a415b71a3d83ea0ae8f231df5ca2597fd29ed9543128270cee8353aa91d66497cf80dbd176cb31aa22dffa4f9162fd74c8903db9b5ac6787dd11869015482a35d9361939feb73690f0240e9ba328756990aedd943964beaccd29f37f9ad5c7650a8113ef409b712c61c89efd61cd0a57dbb691cb6754f1adbda261c99a803bafe8ce7660076013934d0a6317aff49eb427475ad834e75925ea27b990f146c15a94a75f981776cf42e8f6557e15a4c5d92114fe50c3ca6707619bc3e39d241dafc65aa2a65861ab66b31e7726d2889567e3ba40d46ecd63621ab1b35c715ab4df9828584f8ceca52dfc78f5abadd643323b1582f29f518c544b760300b876444623b35ff81b6ba0220537a1b33a4f7e385e9e3b856c7fd5e13b134e79f1a5e4cf056493ea933c2827aa8c235cf7cbad689abed4d578d1dfafd804199bfcc3a21cb8582ace15b1ebfbe97bd6af07db7f6715263afbdf153a603ce3d91493fbe728891b37d9a9672ef0f533e0ae8c8e4df6ebca46fb61fe0c68c476d89176c0d929fee52f22b0a9bc8198ada461aaa7e6762331debbfd3b3ca73513e22569eb155ae80ed7dfe02084dc6e8dd1495781ecd031cbfcfee5ffe149017fe16abbbfee40db0035d27715e4082ec538c3b38fd90ef6afc576ca9013a49b112c1a0f55b56cad907d823b8241b61491c1b6c8e77835214b4473b1557d1342c5cf9385ec02b01010a404386929536b9b6317f96a7629bedfaab8d7316c07793d98588c4eec8ec08c0822eb285878cd42dee6fb04821f69e4c8a6d76bd46f0bfb2eb298564ea1f7c22c78e373b2dc07879858e0661ce17158cae5add2ab42379d9c9a4e743c27f74e69ff2adb257d94567a5aa907f282a338cef6039076db1db2fa1020883229f242dd1e0adb775831799502938aacdaf528559408bdc543df7faa30baa73981a6815e3ef0d356edbb3bdce18e0eea1f653499c3cab57cff186ab69a7e35fe3c351e2559a7f2403b5cc51aeb07b30f3dee5cbeb67739994042b165940c831b7914a5249986f9275022cc8e8df63e419da3c21e6bb960f071db5f09de8e9f5315c9839beb37c4143d6238a46756416ef51393a0d996d269650b9c591e41e11759e3f086c3e79f62fbc46a3b04a768eb8d45add08c2a94525bbd9f62d3ca8b12a2dfc6c9a9eb40b0fdb3f3a84c13483d27d857078053a559d68ddbb3935e1392c0e23d7b4345c4ff058cb44285125863291775b717bcde49ce384a3e440038f80deab51d0bc383fdc2cff1e2c5b2b2b695f1723ea5d5c1b329a2fef027c29a66e02435b0bbf9167115ecbe40ba3815f6e7e3d3db4ade63e6582a11cdae3aa4432b93cbc6e7799fb9b56c3edb74497b22a061cf05868c2e723f0b3ca5385d667326ab3f60b72e91473b9c0137e93f64bd2f1347fdb869d0237f43e277109868b21563cd97348b6fa2b906624bb08e01ccfaf83aa40669ade30733a54fe12cd5fb68e042a0b909a43eef08f4e8ce8fabb00d9449c3784d0f256a2bb7e825b95a516e2e770dde6cf1157ef20837d77588b110b95329c103f9d3009d67d8fa00a065ffdc2963229adaa8bd3f8f06d97268a58ec010a4b4e8d4bb6a1c4d6bb8cccce9cbd3dbadbbbfae9571c4d57554d4e36223b2bcd570f06017cd8c896878e87d8ab8dee8a1e42198402c9ff76cae1d3cce977d5c491c2391d5e0e5790dfd4d789107a1ffb915ced1820dd088d29f5380073c658348db352a11d7c939e7e6bae66402bd0c9feb17163132ea7cb3d3d821b9c9b537d2fc9c6c5c0f30a1778778eb2ec52091fec7a16e5cebc599821e274e9343218da1e259be90f35f5932b43ebab40707ce0565919d6ce511fd1679c75aa4cada966501aee3ec7625f576168d8ce76eb732eef98cfd05a8fb8650d8dd9a939f4bfe3096c3bd88ff978397d7dfe34452c9cddb0ae92bd64f1caea8c06cb61d348ab111172f20b705279b1e93035b7471fe17c7da6b4e90a78cc272ed960449c02583d113f3368767a85d91c8d640876b30b650dbc9642f8eba70d9805316dd3576719f85db72dff61abf291586edc3064cd61846ff651f0ec851c9f0bd9fb21d4fa88698450587b6408cbb9783dda56d4dc36bec100917c0e3701f812b725e166c2cade8116855d5a8ffe7bee52e6dc818cdd85735074a36021fbf698ae01c688cc09f02737ad83d16856801e47624d4ca15ee7ab327388210d9306c4b4f737c36d663bcb001512169c4233b2ad842242f5f9cedfb3cc78196ab9fb2dd797ae3e29a49f3d74929dc482f2d6588502bef06178c194ebd014917e9aa3f1f84cf74565c91f9b60b9c6edb0e4b16f7f212f7113e4eda641de0722d3ff86ba8e4d92bf6c7f6f0a02522f2e4a1381d366833073eb6ad8990167794639c86ec99678765758bc98e92d17110aff34a619da93c4c82d1cae9f94f19176455af8f08cb2e46b2e006a9992c038160f5fb6ea328aee2ab7fa720164015b67e4d7069b23a8c95cacdbff8a24f2014385542a6d0f982956e711ab2fc7bdb2121b20c3b916b520f7ca396e21a0a01332d757d85ec4aeeb14e66956961cca8c61c189bcda7bd31350ca163e4521289a83a7d2e7826fd5bcb2113fb55f18dcbbbb6b82fd7da097720a3ee5d8b034cc8a60f1ef6a1e4cf589c8ad0c7906bc9d7e25846739e74317b75bf0938c5088f4bbc22084547fabcd5b2702efa26f99d049137a908806de85f974ae87d6932bb03fe2c2418d9bc2da714325d3b9225bb353864dcbbb7dc31c5c240ab81016ea2508bff5b4c08a95118362baa03af2fe5387e5acba752eb78e13fad9564a555ccc6eb918d539485b59de96cdbe4142803e2c24ce68a4e87505d423f7146db119dca5898ad5f845cc8f22e97b17ae0684b58ddd9dba48311f271550a6dd432de401cf77a5e6f79be211c1e4c80df7d9f90c0944ad110c48030f490222b56c9ab84bcd160b8ede7a58fbc56d05b99e7a664dff84950fcf746bec00250541f54ac0eae99cb1789af9fba41f9bcac45d9e499cdec4d83c43dafc80d1a5772d9721b05a128bd2dbbb811bf5152fd3a1185954e64c122e0e8621368eaf4265a8d364655c9fc86bd49d2fc5201e8235e6f8bcaf4b682c915900b8bdd6519f5eaaf785ce4bcdc803470e2a698af002a2138f547941e37a4eab34d38f669d2b115122c68a293b3ddb9e95b0b9d0c4f04177c227096bc5b950c237ad87f608d490ca498bb6a912583ea4387b78e6723fab60373c83d3a0ec41f7b985843048173c794d43fb0cb670c4dc272483c8789f4bf042e847ca799371bdc7c204927739e9959fda3da8877ddb1ff29ac1670bb9c554ec05eac809035d82e1e55d119eec50717b8e2a47ebf99268f901cc706257e7a63f51d18dea5808dc0d1b745c8a3be458d844cd65a84d59e5746be15d5ca74079efcc7eca27ba9d61395208df378f4d63f0286bd6cbda7f8002fa71e9a9aaa350b1ffcd25966d6b2ecbe85bd60663b947c2421af780acef6a41ea917624dcf21d1bc8f088102476059158034d0d2140352003f22dd1b94a12b3d5e1ab778a2f8b4feae44ec592cc4406cd4198a7475bd442bd8572fcedaf5b6cf2f707d13c1ba8f550a1277041f702e6c9250b2deb0dc3a1343792a3c4579cef28b7f314f05facb2e1fab6135c3b5f92ced29eaadbde5b62b75f833811d3fe1343f85e428956b371e636cc0e750a6ce7f2f1283c6013112cc15fc56c307904d4740037a57e39a3515cdaca234d036020c1aecbf4ec9a408b836493a55df8e7cedf0e099f446c784e35085b96795b72d3fd7b62f426df6e99c63d8167b23d24943a22a865d0752690c08d5bdf24c8383b0a93732704fd3c4dff73eafe835f098d9afc33b7779cacaec311926e00d9ebaa5c39a0e3d0ab38fbe16896a6c431a7364282baba7db5e774f2c34c3111440e618a245e59936f740f743343668d5a5b2c79218a135bc1557cdabec65d4d6bbc42fd67cc0e7c2a90e018219acafb09cebf8b8fa2fda5c3335b15301fe3c5c5d1214ee501c64ec0064540189186563d3cf6c17a0a008d0484b11bc6719e1c8c3be6fce82d07fbc9ffbcb00febc36ab827a60e833bcb571071087d765a0893b6979013269d93ca9c211f8b2d5893d61cc98b50f8983dcc24fcdb3f6737a6c1d2474bfce5ff5f46ae75b9e95f8bc602ad6e7fded6c7a9234e9a6368679f1070b9378e6f503ccfd43a800caeec6a9db3251fdafc30fb4fc773e170ee4a856edd56fcec17fdc42ce6125511bbca8c03c5001f1ddb5d1c8e02f0a597732575b36a0739c17add49b9986a1b55f4f6952c3f30a35fc90ffb960aa8752fef599ffe539059e40481b7fd3fe405dcbe0354e50520889906fb096ce7ac0f9b863a05617af7517f1b3ccdba4efc2bbfd1562ebceeaeb94279997fd01674a1502b3a06bffd5c3934c378b6a5a7912b7357d9f4d5317c7b9bb706b8a5b3312d9de983d0e58b77b4c820a20e5a587ce7a1b7b4ee9fd3fd3af50ec3d6cd1c2ce342dd187ca5fd514edb7e175f764523a3e22455f5aa04dc4bbcc88264e7c8940939adf0597a073deeefd7a718a94229841859edacd295aae3adec04348c82512db04de4976310ba5048c9830fc70cbe0a42ac9f6203558e8a452b954cd48aa06bf7b2b34b76f433ea54bc3482973150c2431a5540e18b0f057fe1b99c19de1d22c0af47fbe8c78da6b3bd595ed3fe8c006e0be9412b874cbe979c9876b144a157bf06707a4dd51f0049c6f35afd47b7a626c6fde953033465099ec8b91e4b6cc7f6d9aba6e352e52a4108ccd549dbd034b8506a8850faee55814e2b720358a6777c06f421294e7a0534283088b9b24673c053c9ecafb427e59a560470831a34653b636e7efa43ebf71f842fae40ba18d8d17ef8300acf600b0f4d01dc6002fb43e38fa757f8cf55b4b08441da6e06f99bb1b67d3d129d0b4cdb590517269a0ae216731591aac30e05381045e286197bba1fb4a29ee51126e017d2bee321994b87a5f48fc6844cf729049e0f855efcadaf1399c11f90508b56953a61ab8d5b75f035f4149f17d538e47ca2c298f84800cddc72673c08a021ea2bdcc7907523772c09d6076c35348efaaf77c5fccf1f98566f8a2d635ee24fa4246b86d4645839b27db176076b3fe2dc98c91f1cf7b11aa7416a07fd1369d1431dba845bffc510cea43e050d0c35b754c0ffd123a380d69026b4581a55723f94fd574a59da329aec42fd09296870c0d46e535e6de3779d11a9cf953f1b119a7ea3ab3f5b7d4ae03467ca126eb0e7b029b4eb54647fd18595b9a573bf66807131bb093294bbb18ab1877319d28ec6288d2f2c64dd32dcba24d1a4f0fe99d6b33235a35b1813bbb7c2134991e7bf04e2be52a699dd285e642537f5256dc623f534c4d13071c24e2c3ce31bb60123251a837c906a5eaa305564552c954fea7233cac4dcb2b661297a4edab29b2f248ae659f8b7e91a3a197004f4ca6bf0bf5ae9e3c6949c187f66fa2a6c4b7ae786e7253f8ba762c2b40311554e3c062c7d5e2258adab4e67b18fdb8d95d64aab43dbbf3f8531cc8eb6400d5c48df3ed444aed1e4b9adecb604a61aa73f6459ac1031cc687b441888c8a01c840d6f7e5f9a0dc6cf9e3e0c862791e5179d31a44ec0bd1011b346f6bc2b1eb5c4315cfbb9a3e7e4c2306cce4052e4fd3417d4089a970b382dcb2ce57b9f2e6bf3847823db06221c3db9bbb06d57254373f6fea5ac6de3963c9ead719d8b6bba363e74723f2aea37e50b58acf0d8dafd5d430b7aaecb249119d8f441817d0347c43d1eed60801c42e9129d13e3560fdd73d90b5f32f861b4bc6f4a21d439f65af8f5abedec7ed620073d0a4ceee2d0c13e0fe14fbecc13ce62baceb9bdd4dd5be191991606e8e36a7b2b59ca4394ecd06d1555ccbc8745329d035a62dfd6cc7ef47e5f804c691f6c8e24b3eb77154de1df1508db1576b52fb730a8aa2abca63c3c27bf03cdca08510622a38581ae7b33cc9c84c748c7bc6fe97ce5a42398af94c491f48dc67767859cc4032252d6419fbb397236f816d30e80ad4aeab80d60c85902fb2fd0160fa567229edb06d4558fa0fbcb7ed815541f9fabe4650047e655f30e860a264c24180ef0ee0a78da36165739f57598bea667f1677ecf68dcc08b3d5053fe75a0f765ba81734ce0d2852de7dbd1299bd9e70c1ddbd2e95e9a4c24dd65be3d92666cfacc3d7692be61f6aa285b31f37212b2b1d86be7fecb417e23cf9b4138bfd15098d3777f2ea7e649da77da6530f429bb792cc3992cc92076acdd480e1d0e48dd324c77ba8f3aad595095971c3e082a486bc1284c5d3fce99c00be727bfe549149534e01014e13c7784d6eb1d88acf8e3664bd70b6564e789e755a315c30d2336253ba04af3e5c50ed6eb861ebe1335889cefea81cdef81ca98f3dfa0b3084db12beb88b9d3b72ab16e04d208063446e7cfc6da5a631bd2f0775c54b30871d80d837c1b252c8341d02e7430556be262adaaf15cf7c446c08fc179242a7a1855e621aff2fd5a8edb33815277057828d5687de2dbba33c23fdceac253df1fce0bc8a538419d858a128183312b97ae17e6a94d9e3c6be16821f78ac3fc34436dc017568bca571a02e6a710213d92cd444a78fce4c0ef6c95d585398667dfa287e65ce31bb6f9e0f7cf9be449ee9024d16b0a35f88af5e244f11291dcce0d2129faebf093b4858a3a67bee92e67d7ae9143c279892eb171bc709690742631f2e721e25e4ebd10aa1ad2e8c5f1709cd05bae31a8abed0ee0c9bf7666500420db29389540618cc3364e7a3a23671e1fe2d1db8b986199031cc0920102746f2786b903d528332a8efd6c745444af4d6f16124bcfe7e9aaf77662d26bf9a03dfe8e400c9ab61b6facec01557eb76f8ca6fdc14662ddfa7c0206a0e6660b770830e746b9014777d8682bdb06adf071e40519b0f13f5f894219fc685da9e306068fa1ffa320067670e041638540e7dbe085f4f4d62a09bb5a4afa09085248dc34b44dd5599ba98778b7b5575537f8b66ac04ad283ef6fe2b850028d047bce38e362f340ed3d29b5a59bc9c77944a2d9231d12b8352e0fd425a5c662d15aa800249995a66b583e8183257872498919c5ee594de892895d3f55272ed1c1a79d4755e3c3259c781ae6d283c36a649ec827b077b6a1dc60076ea7671592489ed95f89a28c33a76d0755c2a1db4ccc6f319e7c0ac48dc15e4c3357ccea3c3e6a780fded26fae46fbbdc51b047b85e5c4dcf11edac5f1716b3a089c2c7b02da41634a82f10b6dd277faf7b6b01ea6adb8c784849bab7a7d42f35812e57d8dc0c5dc36931395027b38684c80555cf453efd7f9fe1ac429fb24feba66ccf2705c3858b51f8035e1c01d7a7cbff511845bfaeceebc183bc90591bc74a25938c393e0bf0daa484153482f26d9ab9e873e4370b3017c955d5d410c4b08e87aaf5396d4d9cd709f66d87df81d940888faa61d12d4d4b44113724ffa56d50095db8801dbabab4a575ee866f858bb6c7f0043e84e232f02899a1e5b3f2e71d3ddf57ef748c6690da54500bcee1c9d5cea6ff52075bbd76bf09844f434657de86001b3d1c2b870cbde43bd16d0b8e2447865c6e54f4b7c48c2f4d740c65ee83ae316335a092807a95198f24a1fdac5c3c951d4cbfb45ec3bef542558c9673e8a88c06d18f8a1f09f1a02f4a6cb14e0e6c31bb72097a0b2408153b0ee2325a61081a6668a0a03979e72cd8e92fc41d942091ff2908bcbca33f7ad981b37abd7b2154ad6a192caac5207b239d3bf94f2dfeb699f6826448c99855d91d9be111287eb13c9daf5331d676972c55d22c7df159b47c99839a8786b06a61ef1c428458fd3265de67ce8bc388be87582643fdc98d619321f2069c94be4506c47b9c022141c59d9386caa41de8ff987e0bf1b43d21dfcfecab7f375c21b94a57dcd918f59f13447669c780b62ca9a305b06b545f440d0da91eb3066a4f55d01ffb6c4e6fb809d03a719f707edb57bb6ccdffce2c9bbd3faef33f11f70dc26cffa67ab439915f7316ec9d98603bd62dd6a11e9eb46c38d5d7cc416e4d8e52ba0d698d4ab9ec8a5e9c42ab4f1fcb24c3fa28e64e8ec1e11adafc25b350ceef12929c9014231f63fa0725bc3ab491a6f44945812c6b2c65e6aa62efaa3c2c61ac97bf9768333b8cc297099cbe0ff2ad966039eb36b227d34123af741c9f8396d91eb1786d89aec7f47d067e2974bc888129a7f1c2ab6a479245592d01da95f0fc63f6a84dcddcc78f6cef1b262fd3b20a1de9fd2534f20781023c3e8e65c47934cd97b006b472ec0456018342f3bc15596326b9570b7282439bc0e98e92a098253c61ea515d369a52ffcf014e2032825450b93e3a48a62a89dbcb9dc44fefe3268d9ed566b902c851d71850597d6ec14f1c7800689b04a84c13e8d7e9cfb96d8df1c43253b6eb838dd13e39e736e09bb4eae6103330db8746c46a363d6153316a61a69219721b518619dace1f09d3d30e49a66c2afc93ad36c4c3f3030a0666ae92e16d1383cf171bdf153380e43a6463a2306b86ccd0d6b6e0b750b9475104baf2d5df8d5f697913cf0549570b9079d11df40d4caf3e51bd44cbdd9a049d254f22d5104f111e764cf284e17d039e0d5a94b1152bb9d589bfc3169b45b1861907b2b27a07918ac47d4833662777e669a88d59f728ac125d4b249ebb82640eaf45346f6b2efffccdfd9a7c81f4bf371284c8c7519f1b032dc49ca596eb0615120f701d7c9830a35c2b0a924bb9e8a3dcb0bb0e1ce2353e54294da79c9b18d59e26d7f70c52124f891c38b42ff2d19313f0b35bcef8da640ed67fab0460af43c8e6880e8ba24a320f2880e87d6fde2db310f9b3fa191ba0d39f71fd90bdd8304d961d60d9909d5155e282b038098dc3aa4280c50d6c4d09d8c98b153aa491ef20dc478491741c199a79c0e90c67c5594de5111f54632fe37aee00f1362fe3460d0a4dbbbbb65e9f1018a77fad6b5ac677f263b5b67edb42eb3ae6f33a1111dff806383459f32657c9fbeee3d35a7d9284876224e9c4be38d2809c85d5677f7f7ca64a34be9e3d6bec35558329c6e04a708545173e564c686d29de9be4200c83b3c1d4bd54dcb5df80194c0d3f0372a60acc2fc8d88d9f03e8f139276c7bd0d326c37ee032437039d24e909fbf480b769704d0d6322e3c768ef98cbd67a454ba4bf32e2adaab35421c3b88cdaeac127a71b68b8d976baeda217bb5e87a3f2b2f66e4a3c27b5206ac3f1594b9d27854de97d2895f91d7456d6f4ca732eeb90db44cace98d59dcfa840983f3a7f1e872fbd46f2945ccc7c6120f0a9d86fbe5ad73a2ab3ca422e6c1908da1319f2eb980e8dd6633b6cb54683ea518bdd5b019a5fc1ee13be11b49331df4f0e6214ec3e5d9239b2489478a28d9306d9706851203a2f24af3e6457062cc92dbaa29ee6474e7d4cf1fc01416e444700705cb9dfda3ba1852fa7090500cb629ced2b4546b27f77fab2c74bb406e251328e25eaa8eada37bd85994836b7c1da6f6df765836426e200259a66c49300670a59dc1742f85c148f2bc478a20d011e4ddc85210e9e0e08e113ae73361e18ea94d8baae6ed21ded3960973c9232d23bb273bc19a4bca30adfb00c730682a85a498add9a4bbb9256fc1d999fbb4a1bb3faf405fe8fe793d63d6c1833bd0a0f936e3c6e753bb40ae64b86b5442aa073bd80fa36d1f4667c429617e9279a6b6e233737f7f8fe12d1b8adddc788c6c7c4fcd3bba9ea46cfe10f1341c8733ca6f0b4432e16eee965add0a9736ca2057b5e8c575a0937f4aab120bcccf74c42999fb6d816d340bd75e3d03f054e81a84e53e818aac55eba8a7fdf1ab7aafba8c2ea9eb58a0f9c78e8e5d0b2b3b5ad865dce5e02cde0b1eddd7c2da5a26425e1b13c4c1d91c815af6dfdcedf4086251cf5d15a0607d1a63d597621cb1e0de1617417b2efadb8c6620d720c810fe2c139ab834825f55efdb7e3c51d79fcd0712acfc729fcc7bf6a204f6211e2fea56a54e5ff6d8aca6f1645937756b4789700fd538479b334dfc000fdeef07b0604b0f16167ef554d32850eadb9f3a0a2cd8073900ba813d629c483d70cb73bdc5ba79b5d572f03dad99a847853f8c17eb9f370610a277708af12fb57882ddb4e51b8bf22d2173f66803fec3652a6ea0239ef5caec688c8bfe12bcb92c615a79d3fb2522a5a2178c7bdba5231a519802fe583aabf43dae4bc91370baf5425f878be8f24d5e34b5e344e34b457da18555218c52dee37030a6d169ce94b4584a477ad0b14de756ae7e257cbd3a935d814046c2f7256b1250c8f834081cd92aa428fafbf4110e11b6be8e4cfda362e641ccc26aad60578e0a70609d082dc4d72fbdd3dd4c7da34417f52213c0607b118bb13f73f5693015e27a20c41b4acc67c0f94aa655205f76c1ad14ba0ff20533a1595d05a1b6151be254346b8f17fa490699662f029e38869818136599a34afd2f824069b0b4da647d4098aa9601c30a0d400d29ea778a000d417a6dc8a4f81c8e45fb8a350566e0ca395927194c0d3188dd7f8449868353a87c18fdbcc2778308b125f329c1e826b9d17e9d4dba2d4835ae6d06c85a5753239139ee6cd460da7ff12226d837d7a11a26c76bd5441f628cac1cb3f9e14dd2d4bd9a0d70847ca729e194202324d7e3ea7733360992167911498016efa0b1f1d5450d2826516136a21b7ae5dc73e40ba58d55d29cd5daee3cb8a6a051668210b43f6d56533def96d9ac6cc8cb8cbb2696a10d2f12c997d8b246beab5a950517560de107082829dee9e6a9ae2ac953dbfd858b5ff4c53b06fcf9c5f6ea80150159f7eeae8ffb4bf84e8d9ca6b492bf7e47a412981b56b95753faa4ee21f551a3d4220a34522a4aa3ec56da906a640a9a9b70ec8dbc0be2cdedc2958ddbc6c33a0d9e12a6880b6373f5a224cf6703ca22451650f4b58c1572daca70576913d21a61c418ec72a133c98f637b64057bf48688b8b61c16ebb9119532732c34bc42578479c2fc8f6a13954d0b113b92f66b9c598594970fe3f9ea829767e6b7500213c124dd0493bb62bec7f9516d3e436fab9520cfcd3547c00c74b4ae97f1511a92112fb98367de66f35e0f9ce58d39f97620e5f06568fc4d4cdd69229c6ce370acf27f2cc8d955be066195a6565612dba85177d9953033d4cdbb2949d4605cd16fc0b9e48a6dbec7a3a8d06cbad91f932a67987e1f081ca238e57adbc97f7bdd9946904029ecd4bde7c29f17e37c52a2268ff81dedfbbff5335c48a74b71af27c82a4a949534811b556fb8ac2da3c0ffcfb329e656e2ca65409bbabe0a0cafdf22828e46b0b73a4d5707d68b417c7085ef286a6eaba9e17a86b892dd7856b355c797346c242497c43b8a58c9f84542d017deabbfa47a1efb5c879d61b28bf4d032930349ff2c8264d3e5c6b3da2e4292671535a9584f91d159c3b944d3c5d6226800de1c0f867e2fedbd70ebf28ea78d7d217e149ef3657f4ead4c4151ead21ea497f4a182fcf0141159791ab007e2a4132103ee50aaff22624e792150b7c4578f18a144e9c7a22a4818dc6e968a0ca6524f1a43ac84299ef0eab0a2898ed76626005f9f4ab6ab21b1fa8241929c0c12bc534d7677711728713f018709026057cfff24a20370797d52500f9acac90790083234e048ee7a7f05e3537a58e770621ffa2f8969df84298c3c2e48991e349a8d50d00990018bab3bdc61ba98a4e53e0391af6de3933a6288b5d730b1f8f297ae606e3c192a1a72f3d7ddb714551823457eec39fb569afc77cd904053724c0121ce6ff0fa14296fbad825e1ad5953bdbd773dc6d3133eb1dcb333a3e71edbf155470305b67780ab16038132ab01448a5cfb1f519efddfc001a485a901ec44198e9e0cf78183a69603e16caddd14423ed8a77dd69984a7e4e6918013654037f25ede9aa0ee76f2f5059a538cf146fc284538759a1f7a8e4cbfc2774eeb949d93c3e1375c9759e5fa59ad8d4e1fb7e3dfc4b158a87ffdcc87ce1c3aaea2f930b40cfc277506e85594ddaa769f355b8bb689479c9517de2985cf25080587aefa1ff1d9769281c8904c36f36edfc771022539d5a0f9bc54d2f80ad86b62b6c782343a036c9ee7b0e4b32ba0e24a6aa7959e1a7d4c57a9f826eb063874fb6d5a77c9414d6e829c9ea270fc633a5d2c207694ff5b2f20d1373c8c93f47efdd52d3402300d2140047ed4c5e82af5ee2bb35e1a9e221c1307ee88007f802b2727b931236be4e7e4ac72130cd4770a9792124e5017d02afbd99a21e9d55321b5077d5d5fcb30b6d92d5c005de38712ac7fdb18b97a53bded98c145a8092f2149818acc2020d6a3d8bb6b09a7956f5908c9494de79e82ec9d88ce30de6fee661475f618844622e6a07a72e7978cb426db9f0a77676cd66142b9ac93fba3036a6e4a04d7eb432d8a1c981e82779ace63fbacbfc6810b5f4dbdc416d3ccd87c5526c2ccfa66278eb2b6f664f09bc4d15d45ba8817c34a075c2e5afe0b6d489970df9b97c0d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
