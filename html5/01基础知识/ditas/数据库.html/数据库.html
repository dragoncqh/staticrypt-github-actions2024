<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d47d6d4a81addbdddba9b0d2ba2d155f61a213c2825c2c8accf5ef0837ad3f4b01c298214b8ee85a9be684af4ea6a1c479d65bcd323a6da73b6ab8f578c4e214c7fc9d7525de684989ed8c7b8ef2baeb129e27d0fe64e94bd40c4588a6872849ad054e22f5906cf2badc674ff2704ed6f8c96abf777790d97c682dfb6e5d7b520989f4faceca31c9593ddd54126a1b44957c4cbffd4a19a1dc9abe784fe4b4aaace278cee69924f1b4fbdbcc0a7a6424e23722891abc13fbbf7b1da6c0305910d8ab09b072b4d618f14e1ffd4167c4b2e2ce213e815ce387170af55a02acab5e31dce8f60e4611e22ccb208492681db4cec840a30509e2a1e32eb515acf950d6b1c2ab9b72717fdc0d0a57fcddd928b00666dddcbfee9b0c419f25c77f35ae99bc52b76b73c3f5fca13389ae6d07d455fb217b9520de33c57ca86493d261114783d854597471f43d71b0843684044ab74a049e184d37d177ed60bf582980acb866fd7560282b76d0a4f1d685bd93f8c37f9460299dc6060644d2bb5d04d715b76a3bb2365b0e3c4c038d285c83bb0c893b9397f9f3fddafe31f1225da4880c404127c5a50690068c1c7f9d88f67cb906f73dc5e09673743e89c00d63810bc2aadb5fcd66d678a51bed0c3880a3e3e68144b5b66d03d181486413597b2998fdfb30a96d5336b604130159c05c6dfaaef5f6db626480c848ce48fe4c327ac4eec9883cae91625fba6705fc50852e2cbf6797c8989a8a15e641e7f7088f2e9b4dc7e7af0d2ac4ad9c9338c8ee21cba30ac223f7e1abc97263c9a9e481960fa52d94fc39ca6b3bbf759b4b41c1c5efde9266352faf3c18c93add5832fc777476f314e827ff90ad328892f7244551ebaa71761a32fcdb9541f75701710530034eb116f7514e868f04a11d112471fa1de1279c0a286d52680b3e6776f02776f8ca5bebbb4eca2c553c20c29d2b9053fa2e424edea8e98610a9d5cd8280fba354f98a5b2a80c78d48be32d83bfd3507e8840fa76900a935bb5536e47b8ce302eb91de239d17ce10225ff701afc55fc58fd8895405a8fc821ec04290fc07078ac93a5899062bb07d3e79483de125dcf827d443e5d54a6ca3f822dccecf5dea68a674125e90ab8f3f5c8e9c267e7efd6dbfdc14ef01bcd3bb680b7c746021bbf5c9178921c43f764a81ef4de1ebb33079a2c00d8739bc936b1ae5c42fbca75efcbce1a562fbe9bb642039cfe899920d9a44a0605a56ccf85e1ef2aab805f6692c78ec1941e87a270b851f2a1a38cc3b2f4d3657583c8eb20e305b8383649a484b6acfed2ae84d7930f90f63a73f0331812ed6843d5aa12be92adcadb5df4c1e5901e077d9d0c4ca45163f79e8ad3b69475ac753196deba33b9b3f0d51d5b0a0722fe35205fcbb0729d088aea0bc4a741fd9d21a39181649b2a5f2631ea75da6a97fc5854a78202e5870e56f97bc879a571d1471ef3961410f395384a87c2acf77eac4342c8bd740ff4a2da5594ffa2afba6dbd5da8321eac2b21d47c57d22db24340764eb4d9d2fd65a069ec6aa27bbb6fc3e477ce1ecafb470b331a5597947a74781d6be6821a214703f0b8e9411b6abd0fb47255fd5159c8cbd803f296d05cb5f4db29a0ae206081e7c6d35742a7547ff83ef2a5ccf64fc727df20670645d8745995d5f3fba97c31048a1f9867b3a3432657cabdf4692dd722c3f745cfcee071a2974cc33eacf3283a5d97f944dc50213e1b99d1ad1e7a3f954fed7b087e3ce74b817343a1fd63e8cb5babc8e5c4db6ba85e75ca6cfd79f0c211f765edfa81365259eab8c58a488c3e7f1f219ecb8c7c0059adb04b3281bfd726fb432c4f1a031d137587cee3c74480c2905ba1bb0ab94374ebf852ecb8a30e90c32ca932098f808058b30384e54cc2a62322f12915ca6c0b0409a050f3717c42e85464d3d5cd6e01c0ccac431975cfb2741882b7e1bd21ffcdd649f0be87760ff025f5d559023ef57d6e49f09ed3dbe61eb97118ae0a21aa4ca38c5b1b8edfc23b299c28e88aa47c8d9f93eeb551eedfd15d3966c2cc3be7a54336904b0a87e7ea12514002d3e14964a2089bb8e894e8231dfa5e3a4c2049a1dc7f6f802504c8c4c749c63961e12f14cfcb3308f78f863d7223a4647c210fa6581110a74c5e676ca73aaad17352b1864aed028b82cb675cb67abf8307276b9dbdcbd54759d67edd9bd7c8fb6d8bc7b8561bccb4f39b1c541e2021d2bf454d2c046263f1410927e683a42ca5d7a630b9eba32dc44ffcc90c7ef6d6ac9dd25509caeead972b1ff1ce6b2a264742ead69f7623ace5539cc0d717ce4744e3e2705eb2ce0f507d89d95394afd76e5c4027fc634a08fefc004b751491e3d4694d00d7073c0219526cb5ef18742e3c7490393b0d0bdf3473cb0d4222831ce1cb4fdeb62cccadf584ce0b16f30a8d6df532062f5c55501d1ce90e3f449810ce4c78a47b68c6c93c759b2d1d8ac4639540cde4e158e995fcb530b4e3faa3a2094bb044ec8af43f689fa8555b36bf309ec938ca7a12feddaad00b760e19a137f8c75e767cc75291937f2e0739cd5d541132cbe31e1781613d2d023c1bc3a8a5637e5979ed12014bcf632f0d0284326069f102b109cdae946cb7462bea4dc7ee83e78e2cbfad14cd8122cd94752f7856cfaa02b05a07e1a6d2f656374af6c3a272d4f1e668a695ddb2b157f24b8a41ce4020f1ac9d752dbc62f014dbc831a0968b315d5ecf8da36f5aa048efd6c3259dd68d9f56ef199ce1d5aae727e6091bd32aaf2d24c5bd4b0ef78334c11bde3005515806bcd03aa08ad9fce6943c84be34075354b354c4053998db2246a1825572d824cba18e1096ab5fc8892463c606530bfe0a74d325e66ce770fb68707ab55673914b544b908a86909b71e0b771a530a481e6c350c4b85e72583fef7469922fbe9b2948e6af074527759c2ab046c3f11db5bb477d9032ec7663367efe08eb0935abc91885b3d3fd65c11d9e0c39852e606aaa45e523314b0bb5cbd33cc918947211a4ddaea181208580bdb6682fc7f50c44f0eae5de62d8507d3cc63a2a5422608e017bcc59a7aa611788daa3c1c6819619004b3e3036f8b208d2b42e2c7d11f67437ff38998c6cbf302ec870ab8953d149df1db849fd8bbffc5024337be357f825f79aad459c0c9ce81280e6175ab594c0de1a97255f887476116a9b3c8e1717fe1308545755185c31f73310f61a00e92988e8fdc11ecc59d9529161f0d9614b363e82b0df44f152c6cbe9a719f0ca4cd60105b4f44a739c4c207ea0ee4687f76c12a8268b590e08749ebe3588e66dbb197cd18f9bad6000cff3c978c374a99088fc37dba7ebf9d392e928891af3c18fee4733bc7ca9c0c5322abb9ad2424bc047a1113517ac9bd43c554a47b41228347336f5a1ed4988e7ab762953201fff2ead10f04c6886ae6ab2868bfc300a9b7c990417c651c1c6d5b288657c784c01b8e5511bbe0bf83afee38e6edbadb310ef08021c83b54938d0bd53fe93e268f4dc923d2b589169d53c95f072186eba949819bfa4dba6bbbd25ff8a6f27a6be1cc752881b1c894e5792205a7aa9ac35cf5a6839d14f248d63ee24cc0f16d687fc275f8636022e83e7e5fe8ebe2d9f840cce0475a80c9e1b85ab50efb5397e97b95f454e5dda6181336578477864d080f103076917170876df147ecf36182abac8092f03f0db48a10bf2a38cf7a914d7566023012d1a4f1f62ceb88774c1e6c5fe886c8aeef91caf75275f213ee5716f993df3f312f0f3fc1029959a4f0e334b8ce6ef047d2e8f1a04ac30e1c22d02aec2d324119c595c4eeae7c0106d7190f561e3346fffaf9ad581cb161bd1379c019641a46a40723c7dbbdffbc0adf337f6b34ef6d239d0af55372c81112a3001ffb556f22abcf3be8565d1b534dba536a294fb52af61e3bef62f9a32b355d28c9589c88a1ed4d0ed64fbacf5035e4cc2849c73f25db3f01f67752da29a5dce50ea9c8bbda042665649f2464632e7871fa08ecdb43d53d70ab3cdfc8e9f46d496266f6e4aacf5aa55de74a3655fe5a4035e225e3721fdded90797f3650bbaee33512fb4c93c4a2440360cca6f0bd8b82567598b16d03df1d2006c0ac37b9bc28c478d8af7dfc4de8e05151a31a329bcd4b1a73828d6a6e72bbcddf530cb85bc86ba85a6661d63a3cc6cc056cb76a6f419dc789039f95dbfc78e4b9472bcbba14f66216536bd8eadc1a07fec486814bd9800a32c251334efe3655a26210a2787581a75b2ec907ff3505eb0662c608671ad0c7d8c3af3e88f00ee40d2a0d032157fc7624f03d8350e9fdbc49905170e117e8489411da2b32bc6a854106687dbd822651d81d84faa3f48c1c60cb79566ddb812fa197498f9a63cf9198c9aa4f03e1e0a7d1fd356a10c497b9737802901f2c637d3287e8dcf3662b48828c6c60720d98c012002e873f786bcf9df9a45334d02ae794293e66ab802b9af2d7e79d2cf3b4d54f38344ef16b4bf0dc1dd414703bf83411463a6e470fd17dc9b3a8706fa6bbb00770302445c6699554cad5f8b8b0143563f70e2c625eccdc4b56900de3c66b03e18434f406f1be1acf42e7cd712a2605e0c89aace32b2a5136d07af63536ae67077f5c6db3a7a08ca3f091d853812340eb31613c17edfe6a7c3e7d90a03a30daec1827da9ab7c9250ea83ce7c289b3f8042c73010dfa2abc4e6536fe9f49cb4e8f8a97b663bcd5c5e945b3e4f933136f7cafcca05076136d708c9aa4f5bd1acf4cd0f43dfb84af39e9b8e9ae4912c01991b825f2bd31d687817f529150861f510d69af0e5c5393f591274345da62379b14de982c4717e545337416606563d8cee35ba6398179b3535fc29a79862a0c65710e4aa05c424a93fc84b2b6ee6c16a65d52d31142ff996b9b32262679da91582aea7a94640cf4a1633b542ca15723bb96a8b65b409f2e238be9fc81f688910ea7d9cf5e12b19cc60cac16793e02e9249160166b86f5d423d0e76c54091570f657403d7e97d604f11791e6ee52b49eac635354892ba41ab7b1ba25cf00f421cdf305ee76e1bffeee9b9cb5d49e112c0f26a355a5e95c8fdade4f457219a65b1d29d5ab1185a7a540ce1fcfc1f807f9e01afebef66d4728cdeea2ffd682a34bcc5a854535e5b1f6628713032ba2ba56f7dca34e018cc1c94f5309b7ca992b1030c62b4966ef6ce7366035adfcc1022db68e565769e00c25e7d68c37033fa7e2034d25959907a58c02a84ad56c51bc367105449ca00730cd45ead3e1f6b24077eebc52dd692182bcded3a6cf3620404d95dfc719938c7076af51e4e5875357904a38398baf7ed659cb2d013a15d3dafbbd2538f2717520857b1491f260dd7792a4b568b70b85360664cf2340975802ff5afaa4db9d1895b8b7408272108d8b22a1ace55e1baf9f903ecbc661ba431e71bc117e3b9285c179a76c767ce91c390e38b8cf09ed2b9edae997b73d294a2db23247f5918456d199d45e21258f6443f9b8e45a48af1f0cf4542825dc47964a596af4ab8c80cc6364cc466d6c03c03cd468dd602b1ff0ed2511a2285e5b6ac22924cdb9e78e1c5862b17f0d1504938629e60249b154977bea8cf434e0d2904fde17199908729a088195a7db0581371544e54ef609ee7d465e0d79990ead85cf07c6e05260482ce3177b45aa241458418e3f91da4cc116d2024040dd5f36ab8c59f28ee0f7f042d7f94723bf1996b6fae38d030fff9139412ea02187e38a8a22d5ab0e69eaafcd85b2f73a757538ea702337705abfa361459847d7403a9df04d1e63b4d53e4f9f17c61883d99da25aa20af7f0544cbe6c01053d6b8edb37fbfa9a9cdaf4d9766d52721162e7665481beb850b042524f3f30516f28948beba788326994eaa49f7add265d316c4c9bcd57eaf2b6d824efbcced227ff2f9cf66d5c43a1bf0e9461cb6383886cc1b58958bbf43d041109e4723acef9a1136ab63b6702a97ad4270e54e84744fd49658d1d1b78ba2e810ae322bbc639c66b686d0f0680f31e1db65b34962a043516f353479f19a01bbb3d35ce56e60e1d833f920233fbba97547fa0d52a52e60ac9556e6e89f2d776001f7de3a3f12ac421ad732fe901aec0508519dadc7851fa61192a1d93cbb5e29be5d00dc2c68ad485175eaa91535830d35c2dd8a62008d1a81fdf3852a444a7774b35fbd8d74259055e66594b2eac9b2a7b0c3ff70ca1598714a6b8ef5d76e00f2d3aff8ba216b8180e26db36ddf111f39377a2213e36fc980b5dad6de430a0ccec11c647ce90a77696c8a0c35e613222346d975bccc502e8e483b96b90731ffeea17e8ce56e1ac8fb5361ee5c72ab15431ba9195ae0dcc59488fabe5c91d3b7f526453289e95a3b77d177c2925f55a43dd19eabd0b2ac3baced663acec9d62f3e1e2d79f116177f7c6c34a7deab2fffa9f196ab3e601dee3a86d75220266e0eb7a8cc4f0311b0e6f298a68206616ceb83134e481d7d7df89e038bebb8a18385a6c1882a30b7aa196fb503dede2c73410f2b5416ef815f4c3843a61ea54c0a49e73dc6ba69d9696ab4803b5ad42b6b0749e31f15ab2ad8eefc9fc23845935ae83a75841b7c8d3c9a2930230883008370a0d9b90af3b039c0580e0469b9fb2f340f1438a1c2bc3b9ea66abb54891b21d3e606e795c927e1f1b38b1f2c50d1f7685c4ef157a7e840e71a1eee9192ed67d6ba11431332b54a7df7e17ec10a47eceb426ac2b88508f097446c22cc13de7c27f5dd264fadae2c43860a789d8c2212d8a665a6999e4c6debebefb03be783943df45bf56f3c9df63a8e97cac5515fba996e382d02c119058371c25cf327baefc1234bf836b24dc177dcf2714257dfa4a039e1859174968642f741a6eeb43f52a0021e2b737236691e7eb04137493553e4648b841f83bcc8344519c0a5e004950c1b4dec35f5bbcedbd542a22df6520880b144c016daf54b478ee318394d20986eccfed2fb4b8aa5894c665ec719938888e1bca053dffcb9ef8a903b68ad1cb9785a4760e36eecfd42326335a9cec3ec20142d1122707d6b03c49ceb600f324f13a5b9543c9b2695f2dcc7b37166459458e13d45078d3b0792d93601a04dd4a99f126fce5b195c8f37633004c93a3005e8686e4a01f379ddc10903c64de2cb422ef8498dac96865f96158cc0006c74507cb2a0e4a18d3271bbf692751992fa41523f4a5f5808d54add915ecfe17b9ad33b8912dd28992df2f0b4ea9a40debb770883167a55f2f34b48493b9a7e33ad10dd31c3c9caa755c5052c89cd2dea4fc1829a6c2b7ec6df8eb68b6892f39852381c84724f4a7da09c122978036edb7598506cdeef8df2197f38ef5b22006c2a023a7bfacab5cade31907f7dbf4f0d9b036f84a70b23d56d752dff7a7e1719ef481b8a227c920824709bd2cadfa072cb61e13f9401d876fde98fcdca22bc5a1a8014dfeab1f77cf6e06ea6bf55217a06d87d8c2ea90cd8bd2bb1791245d64c5506dbf4379e4a7bec449ec96d6b5ec22aeed531de2e16bf4ae3ea133967b6686c6818c438256d468aa86bf95a095e73e33bbb58dbf66ad6258f72457c5ecb50ecda19bfe286844be007472f2a6d52adff89b936118b94b3dfc781aaf73083972547632c677f86a8541b17ac54d5b650c1d8c23ec01134ef4a9a3dbf6f8778111b7b0525613e510721854568df1a9ac149c65decc2ab77fac7962dd39642d8c2b831b4c6dba25dfc31a72ec21b260ecd6855a05d44dea959cd05e6931b8551f6f00071564a4ae7f45a1b3f85c7dd66205ca336dcbeb154edac5dd5129e1471d74a62183f668dcde0269b2bcde610b90cafec85b278479f8e6a574a7dd39316382ec477c62034128d40e4e12131c1052da634a2619242700152da833cb8a483d73363bac23c1ae6250781127361309c6aa49c77f59b1f5dd299366b1c9c7fc5c820086159c8866fafbe0ce5e1c443e41bcc132322b86b9ca07f17c89c505dd0009963ed64677fa8b7ed445d6d6e4482ef46b508d1a4f4f98fde93b608ebcc1947bdf5125e685abf042caebbe87647135c9c4a7d4db16e31c94a50918c4ec3672ca9c510b81339dc4e95de8ce0866b0f0c5248c52cb9b78414f7aa489646700673238d2047ab2c497764f2714634e25249eaeb94903e8ef15f1d57927e65b6f72558211d6b54ae05f25349686b4bb09a42abf6a24d8f2978a5b953be4dcb6f5678418f2fa264bd12e5f0864cf4b59824ed7586964a1bb569627bb48cfe9d419cad2dea56036969809bd9d8cd57ba9c00022486a32fc38f2db99447ea22f69f83b140da4d966e4f8eb318d9961a28b21550be169f6fc1f024705bb93f53456518d04ad798aa4e3a56ba4c5437da6c7943522da9ee3c0ad97fd038f4237e5d760c3022a4b57e1f0d38a859d089e246a42c486600ca7e62e0492ecd183a7875cb536d11610eac9b73d28b96f28f761a0c8d6eec5285ae22fa16fd8e33eda470fa051bb1fc5af611f4477dfe3c52fb64d711471c9fea545d8fb95a6ee18828494d4206b76f7611e080944d23449b74d00a034ac9acbc7e15e7491ee4f4f166c2e2622cb8207b5adb8226bae4e3ffacf9b800be2dafcfaa3ac058232d58f07a6f9d80bc4ecb2956a725db953a7e00812a6dcf3bbdad9300e4531b5271bb054c8492767e36437853fd1f30151a713391b7eb3890d7ace4d7b2d2c70a0e70cd1e90d53f5dbda0badfc45f434ec5f5d190021b3f507f272ed276d587cee67171809ff856db17175d1ced16ea142d7c12c8891cf6a8aac29f2ddc2c1e15613741c2c3d8bec76f6f3e3961885d9a9bc57a8f3f40ccdfa9a6510685d47ef4949ec5b46d644a5edaf6ea16522d5e2453cda11ead5e8abd9cd13859d2331ee31544cd3fede870d435722b90328647071ae43ecc4d9485177b2015f220bc994306888208bbefa33ef5909b672d85532f22085063baf995315a869e038ca56588d5b4389e16d7f168561872c2d268ae8ae342dc1b34475941d9a059bf771d471b73a1666ca19bdf3ff625f56e8cc6d89dca448eb1dcad687fda2cea827923c24845e747198ec8bb454181d5df13d7f986b11b0df6418ac83f6cfc59d2fe831e44e8aa7782918a81499675d07381d462e216464e86de7a2e3389561743bb1a9c7b43233cf8df10abffc5a5631dcb80795cd8a5602ab23a940633732a138c01f1b6798f2d6e0f32cd81141b603cbae8525f0f3b0e370e30117c7f86cbdfc3f83163d0f35a351d2c1d9faef480865dbae6195076567c00d3f8f569547e266607f7abc00974dbddaa1536f18244dae4ec1dcb8668e98f9fd07407647b942a960e87d3b1d17f578195200c8f082910df0e40f52ea1c2b99a6abb3051d8c8327e55e1fcbb7ab411a7e6bc9d2f9e234beb57ca97731463099e6f969c21af6a2c394854f863fa5a6f1ba0bbc2b962844e6a79856fddfbc73d86d32f5df91d1f1c61f949532fece0bd4187cf1c442c43fddc6f69999acfc0efca23c5495804e7f16bc5a81b32824ebadf12554651085067ee3d95fa8304dc8bf5b278abd2235fceef00e117f3ced1a27e26d4484a09a2ebe515b68477cb64dd84ff51d341bb67ca448f79afaeefa270318ab82194fa2a5726c10ee8d172863c647b8e22f3e2bab8fa9c323b552585aba404c00d96b165666dd26adc342bb0827fb0b315d55ab6d6739191ca4be107bcb7aed5ab619b2e74a1e1c2c99c389913e240cc42cb4543dc179b582c58f6ab6cc0563b211d063103ed678414161162cb8c4cbf464f502b07d91566093d5d4d3250fe68506190f6f84ebe326b008131ff676c3ae770442ad9ea5000c446a14b34b4589077b0c7347c6789003d2a54b9573f3e0deb2fcf699f3c213c4bec668af900f8c72081c6406b4c3424abbeb793fed77d05b1ef21e68ceb739c73938ffac7c36d58a834c497ebe834bc31ff4056cc84620782d61e3fef894afcc92f727c4f2960e7bf94a013654bc8fd3bbb9a071a1c7c808a393621aff09ae1543943db10dbb6c60d02bb4a04ade8dacf224c4114b2333e789d8ddf75a75f4161e3ab0f2291cf09c5a7afc61fe1fdb80092dbeb14045da595869a265bad41b10bd3f7d0b217d877f66017c23b22f1b32e5679b4b91af4e39cd706b05d9b0fd3cafce85dea700bc307b56849c6dfe8cd20b38e5c2e311854563fe5fdbdd7d71dd059975ac22282bdae6af12cb076ac8c40ad56177761db57c56a1cf7fb305a8aa41fdfb4d8de7235ba906294144c2613bd06a8f0c67de0de9cd928753a3f7aefd49b92600f93d01736759c2c1ce226b51d860611bd1b3d967d80e14b17650cfc73575eb57472666047d075a65fa1c47a533d424e0336ad75a97334e5d4ad2178c506e940a695d0ce8d11477a69bb8a105068956bf3c8f1b322415acce0319ff1cf36b15b9bae00c83dbed97e439f997857b61acc58b2f23c0beafa25bc679906955b4db9ce86f9af504e9476bd799063b2444f6b088564009f1e66cc9940a2ee91f302ff5f9bf68d978394f9c622f5cf6e7ae74f0467a1a0bb05289b6719f3ca2a49632647aa07340903ad96a5ba7b44e705286ec886c3942b378ca62c92a0d41b93d848ce10229e4ca6d34b77fc49a08dcc492a2c3349f1ea20a5b7d813946ddf7fb0c12ff4f74711954638fb892ba7226cc810264877a664ee3ad5188f35f459d4e8b4e6b77a5cfc2f89cf3ae485aaaf68854ef34120896dc9fef7a4a2aab86e78d334809fa148243d5e10188869d1e3131dfa7a3246ff7a2549b7bc7f65bb3c98cc8911463327056438493a44814e3da3bcb7768b09e6cbc4dc9a8f505ce04b8c6fdae8436e167dba74a297013d923bc49693b0f4ac6b7a6afb2e2b136215bc77b52c2829006acf1550a56822bbe86834cbb97228fc4db4fe6413e4e2ea111e2d342d9f575d66c44c739b2b465e1f5f721e2e82698109638b6c5a9ce1ee64bc6c8c6e476282857e07f57eee99bf1c3c9587d7a75ec79a839d533ece821a3ad3bbe9afb75a91ca5ad9b6f36e2df055a1a29617adaa1254235dbb41d54f15c84f9a1d0b86e2a75ae5c8965d1a9d1e55d2ebf34b3072dbedae65b0a8a43e2539bd410e98f3e7e71958be422bbfcac47a88446ce843f9f43fe362d06054f4f3c3949f876774e26bf6182c046a5a7983b42e70e72b7a0093efc6df4c71c890d6de70d117051d0f288fac798bd183ab354b66292ccf69e7bc2b529e946545480c44fa7b08185317cd5a25aa790f33af75c309625fb02ef1588fa0cd353cae3214e7333c44b49b9daa675678f962cb86c180124413177af52f5512b2c5943849f534b6654f559644653905c01851c2fa960e6fb4979c43671a7c6cdb36952bfc5739de9dcfb0d07c3d468c0eada7cc620696c28330d2be3021a483059dde3406b015562f25057db454234702ab66b905cb2d491ae5b2ab50e649d0d1f0fe27c942fb65415bd7dbc576227f0a3a95cc1247eadb33aec6d4558208a910da2188b33cfdcc1284c01160f7b058c1d0195eeb69be3a5d6a35c2c927d2fe79896c1428aca9405313d6d28851f67efc63d559c562bdb816a8b2331ea85e15cb40a6a465b28e2f1d2f7cf016d5e84e00dc3e2f694fc6062547485c54244026efdb20e608ff931d7fd57908e8413554ae642501cbe53036bc3dd880b6a6e749e7a6614cc330dcaf90e413628f74b9efcd7a28713f3ac96bc96abff12f4aaa8764a6c00e9f7f90d9a937c5e225743afefa59e1df088b503d3e989b4ba7574f0144d23c75d706277d7ad83de7b94622c54c9cb57e7a6b1f448f36a9247e5ecc8d22478b5521627669921c39dcedebd51b3d0601ed0d365322d69bdcfd1797c45b3abdeea9dd2ca57f8746a37e3f163bbe7fb0bdd4ef8821544cce41bef01029bc6f28c78450932564648d14e21d23e7d3f5e5c91a28f26e451bd73ce4989f40abee66ca5839e992e31954ca7f9c9b7080ed605d8f47637d9fd0e0ee25ff831f79aeecc977b0f5742855aa720ae242d3e32f9a5198391292d7019aacb621f57dea7a7e2d50f2c11b462de6de37171b44ef699db9a2b1f3e428f9c3d0acfb4f77279d753042d1d442f12515c8a6f70c9b4068badc65adadf62f994151d92c328b0e7f8416e05f43bbbcb0a2c77970b2dcc815090efa58b4e92277feb827694ed5022957f4f6159b562d1c00fbbd0a2bbcb9bc954a7e9bee67e971253c2fae4db20f307be9246dbfbfa447464941a161e407958748d71e64428236d216ed43b553dee804f2c1d0be7676cd65dd3f5520157adb28c8507d8f8e896d60f412fca00e89b22cff324f8746fcb85a987cfbb03dc001db8f4e03969547f9b236b0a30bdd15ecdd6208c70fbcd3cec2c785622f0177c154134c1394b8b515b332aeb9e24fe5c4b90937cd206ca49f25bfa631bc2571b3685d7eb216099287c980a1edccdcafca372e96c96ad84f588db1b1ccabbfbd99776d04c6366cb37ce93c53952930bdc985f2026fd27d8a490a837d960d35e800bd1ace37d66197807da46c077a2fb36b0f9685b49bbd646dcf01b3d600b84d07e26fd143b1c2c8628d258dbc1af31dbf531cdf2349ebb2d285a5a123a5d9ae834bee84db3214553824753511b1cb2f1c7089dbff86003fb1dda88ba4b2b9e5a6b075adbccb7a81a53049131b4fa575ee1f0a2d222c746ffaaaebbad03f914c145d0ca31cbc567a2cea8a4569000675151d62b773e4ec538a41dc6798e8fd388f9f4e874e3beca6ef360a9909383efeb75e0cc8ae617879a951a5aab46dad189acd19fc3cde71c9519eeaff27d3ecdea2fdd1e4c1e47f624d5f6dd920c9f248b37581b478c2ed6a20c8b33ed915c68e36c5a7d27dee98a178af9fad5cb6a334e2dde0a2a9e6a44ec89c2e5ce11f6a42f620accfc821075aaa549ee54adf3c89b99492c9ca3ec17e8acbbe645a620508d8f6734e73151a5c960c40cf02f2af9b62727fa824fd766f7a778eeff6359a6395f30aa5be97b92008862feda93cd3335f1af9d9ecc4728dcbf5396d9d788abb40c06712756b77f2f58470dc84806edd0c0b9268a926c794230d6690784e68d37d8782554d91fa7aae4dc811555faf071a7837ab6ad7178a01f22a06b47712c1fdf51cfeb8e443fa379a884a072f688347493eab6d6b57dfe18ef5696bfd99e0a69e1d605e83d303b0910f006e301b51a4110456ecd0c62c249d0271e25811145adb0441864e8165b4c6bfda395d2f779bae349c7c6fe30240d6ad2382b2c579909da5bda587c880b5faa6773860b04ed7fa6c58735b328cdb065742b60cab6c1c28a014463bdc1ae13a5580c37d5b19cac8df7671f8f80140048df23d67fe341567a3439ca61c81fbc9f8c45c4586f4244b07aedadf1d3a24af1800e138edcd0f64cacaf3210d108ae4010a4b2f314dfbf59f4514de4b629796af3e7ba2ddf3fb0cd3f76d92081476e290ae0b11f79b3397203f6a0e57c6a06675ad71e7c0c9256662d435ce478aaf3a832610223794748f8a0241f2b8eeb15d4da2201cb6914da45cd6f1eb0bf9d21a79fb80423a9c034080d67efd9b21f2d693a9658994793642e7bde414d993af313be5fcd01180f148358f39028b72572c20dc893c00c2adc5fce0c047f64f52a64723a29c3697034a24236ad7246c230ac01c3125d5e96092e6610e514de3141ba54496fe770ee8a86cce529748f18b8bb7204690abf052bb74d7b4574a7ade40a20acd0c4ec3da7fa47118314477ed0f45582cdf5be3d97c7d296bba5ba8c10fcb70f9b68dda91fdcfd2bd5110b5f06f083561bb85b4d4d3175bdc688ea50023f40eba1676539968a78800334403e735e6991b4ec9bdf8892eafc9205f27fa729c6f061d2867a8ef9a7671f316eb8418367c2e7c9ee2427cfcd4d2b92173652c52901bec46814da5c2a911556fa745cc60ffaca9a34de5de2435399a4a6031ea91388d1dc6ab329b6859d31dc653cf59d860f2523382006ce031dc06fdd574da25aaf8cf6cf11f2b4e85b337a95e089005e4ac28aafa538955b6fa40b0b0dd28a284188ec23cb86a72199b76bf1a84ebd2adf1fbbb5180f901eeb5c8b56236fd404337a2a69a2f90506442a01af7365ad86948f0e0620680d4247d4b524862f615ac223e2be8306348558b336b50893ef4a8e62023b0b5bcc822cfdd717cf40e71ca7dbb76b029eff292d90841467cccb1af1ef2c03722f001ac06bb18c88757555d36dd52caaff294a342ea81cc6f0ddf0ee4f264f99c60706af2af36089cc536443b5cce3c5f8cf15f7ed048a789c7c24ee22224282ad563c5d13441bbbc14bf55aed7a1bad8743252f7581d5c9f128a2c7c68e87005e14d3acc5065da076298cf5c2408ad7995fd3d3752b95fe2d2bec3d9f7b65f2df52d8ea0080d0ec3869df5ff1b147fb1822dcb02951c93e3253bac3853a51964a985c64c1bb590fbbf5ceb90506e2ad89fbdf855fe41c722f4052266aedf16bdb29de1958baf35c4d53fd3f98d595f3bd008eaad3cf88132b3867ca3920dea9cbf47f65cd50e7f197a4572f02aa69c1836b846b9a0e511a539a01732b592c7497a644393418fa6dc34696c44f6a958f57a9684be6cec175c16671c4ad1f9661f139e9acf90867cd1dbb27694772b10c0c41f04dec0c435497ec5fdc96167bbb3813eaf01b9fa632ffbad59cefa990af6e079d50c13286a46204e4243f1001a9bf1af859b31508d363f956dc1ee853b24360cd94074eeeef3c60d21800e16bcc1c4bccf9209b72b8c6506f8001d69cd7b0088b3213385fcd280fe9b85fe9c3d1ad128ad7d60a3905f1a88470c9c0d98a228ee1a8045480ecc81cc7fb6c3a775af2acef4afb8af5d92a2c260c9470f15fd24d52598ca39473142a0bd04f53d091f70619a309952746feadf76de1c31f9788ddcf7d511fadd710f01da779ec51a1d64a7a2f0de817c4b02383a2d4c44cf5e380705731aa19a28a70a356339a70267e0f7f5a78cab0f3535cb29d2e61fe4f40cbcbc6575df15f7240f77bfbd24e57ef09f5a95fa48c6e02de896435e7c20dca90f505f211da7747be25f5e68b25141ed4162b71544e491a3a6a207b6349a028cc0e9d5fb6a3f50675b5acf4b9f9e55d202ea4ca169cec545bdebed1decaf890eed74de7c75cecb1a9ca2ebf4fd6c31d365112796201a9df2829c8231fb87b4cebf4696a1eba7591fa37760838f4ab164f3de9dd3924c16ca8b4fa383830b6cd97fc39289d24623fc005bb847db2dde8e2ee1815aa6f1fcd8feda516d547738abcc0cf5b37072e9d0fd226c88d916395accba693b857cefafa46d9a80c7cee19aaa6f8dfd6a5d83527872a3cf360ef6f35901c715865fe5f174e1276f55a90eef21e5e3ccb184f83a0b11fbf51db3d7953302336ffce184567f956604ce7df041b7f4b2cecdde0007862c25e62fe92968a3aa4c442e95d65a7d02b68473fb548ed11318d0949d02089e5586869017d86a4365692ee733d1a9a19adc72359d4c7e8cb07bf842ed7a934996556045b5ece2fc0ae7423428dc50e5d3d2370a805261b83993887cd03e73021494744d3c34ecd5c609ceccfd6c58cfd525f85608f34bf1d7fb7d6a44c835ce6f3813c33273bf39751911dc19f8276a063819826dcd0ecb623a18ef807758180eef780751909f33638e75b46fce5d30a3e32f05c31cb04af539a7db0c69f425538e4efee97c79c8785680704fe3432ea1926c576d129d7618b88f71466f4185123c6dd1d1dc8e67190e5f358aa306dc35bfa3ddb4af7ddab8a4fb3dfd48665ba18501fc5e5dda89958b39a0db8fe1b31fef68460cf31d4f14b205b64e25adc71e513527abb2d867fd8002afba0f2491132d9936d2c87307f3e92ad22dfff8ddf6385b06e1be5c018b7465ebf2cdcfea24340ea80b89444fd5a711b3479dddedb4f06ea8265fe4014718febeb6f88c225fa33fa6979528fa7a281e506495b52c09970257d8e53be7af84ebc0d90404a4a70bdf33c1a34d6752cce457fbd1f6bff145879d1cde134aaf7b486d01b8c1e1f14366b3b03ac63ab501ca655738f6da375e9c12d9bfdd915366bdd74a2ec7ac9764ce1cd719120d14ab27376be5991aa271611fc55f0c12f987418b190a6c6b53b695aec11fc81daa29f157b5fac251ec4a12e58095959dcb1f0cd2d465a3ed1fd62c0dcbe1162b1b7ad00d95347a8e96b431b3b73bee92bb7a1d8dc1ea9e33b43c49aadd9aefe5b6425cf86bee9ea12edbea6160f698e9b38a8c2fe4673937779edf638d6f22c80252aad94d5d19ea38ceb19df52b459e57ef6c28e9f7e2a4284bb5dec9086b2edc303193db30b8ce96de6f7507d0c9212d10cc040e727d4ce67df63c98f9f068549d0236cc14bfb750653db50c730852aa3e194af60240c9936bf5aabb86a391214bb9796de2c8afb8b1ae8fee5191e6b9e034502ec805741a9bdc02d4e5433ec4fd9303ef959668bd25001b62fa6a9c8660e342a43508f493b861f3eb9e1683b3c88033ce5dbf6d5bf2c5fb7c2596f2f5706b4a0926a73ef9a9063c5d5b847b9ce783caee13a5787d4d3af1c47f6508fcefaf6c813d45fd7b6b13b2a97ce058e56a69acd72d9dab27e02b6f6f64aeff9a9be5315cd228068a87b92eaff1ab2b3f8c91fff5901ec324e05f9f19ffda8dd3f67ec912f8b2f65cbfe14d73cbe3f8ab6dcd37333fb002db4e2042202ac2ee9f1d448bd5a499762bd010a462987dfe7cb79f29fa50f129b1b03038db8fcad0ed38c27c7f694b1052b093b1f241fad843f6b197979487f13f192f769b8a3c45f3f388e247f819c303b64b0430df2ed7cc4631dd564ce4c92e23d1aa1942fc1355c6e3516a6ca4424baa321e614b587628884ad3670d7459f8edeb83a75756570db560b70e8a23a7a7a7568a2700d81ba0d51287c60d7d6ed8b5848d4b29b82496036af260c2d292d5e1c507c931d1f2f4b522f9ecabad875c12966d61c6f086e9770e6c72f4418177aadf8b9c326c5e3cacb068319834c1cda9cc5356227bba316ddf2ce8ab4f4e5576778f21588f64eb6c53b63e2ae3189b2aa2ec55a5a4a4f326d7350a449c8e6dc0759d43f78791a9040d58d727f20ad326c5e6dd0f7c30ea782175d62f1dab79f3a8abfad795005d6370dc2380c613728584b583cdbe0914b130e4c4b7691e9083243b3355a0515e5f1555efe4c77e457c0b264028bdd794b7f549dad376571ee417ee911957f112377956eebf851f1e286b75042079f8ab5259eda05d195074238a93b0654fb3ed8916ee35145c04bb8a6fa5d55b972796eed0be62bcf991fecea87a2dd53f8a08046739b77af3d4aeb9d9b2e514edb7245bb61b9a4a31030b9b7cd9897d4679bb472ba659e9f9dc85e859764dd85fdcb206b4bc2f1174d6582a2530e86c89221a5d906c534ef10d45271bf201d41ea754d744cbb33cbdf43407e3ed10b992fa5d5764e3290de4e19b7b54acdfadaec7ac96319b2a32874379d5fcb4f844a20aabd9f86aed935c6e8ae8d43891ee8424205d3ba1bab6dbe905931c4fbc6f60a6ad82d64928dc8ca07755f9a7f69964cf2086c7ca51448b95540d1efb6e663e86f2c11142bf28a30ce536639f43ed18cfa278b9f31fbfa840ef6fbf2f817cb21769396f35e7c44e2ef0b416d5218cd2f52d42be849f6e4481d0b0845ac2d3852122c365aaeb6d86472a693d87db00bc562dcfd6f9649af489af65b8f6d77afca72acc9e1e91225019de336a10fb751336ec77827104e56529af92870086cf87386ae5f066c882b194bb3e13253c3c9caa8da9ce6fdbd5bf09c5943fe4309dc5467ed571befde5859cc464df3bba05dd7affa6a242e9bee130dac4d2fcd87eefc3099b748f359a6e7950879338bdb4d8fbc88dc4f399ccddcd621c7948789a6723b3e951d6a9a7355a6ffd0da581024a257798fdee041f5819fbc63983c13a179087afa025dfacf1d2a868a6ab548a0646d35636e8dd91c5f5081d2dde6be26001c56342243a1a40fd6ffcf21515229955bac688c22d38b943d4de6fa5deb11cb4a8ed1ed48bfdc469002a06eceab7a296c1c651aa9a32ca0746a836a8dc2338f53f817c227ac18702b05ac8d27ee2d3fffe14e1d26a260a7384aa7c625ce176114628d7a3117fac77f707f9f80372b69c70a71c8fce9d234dcb96bb063db2880f63ea42c235cf8088369b0f7d90672548fd3f966832d6ea80e049eedcbd7a39ef5c9909b36d7631bec9972998aa965fd9779b1215753a66be3fb4d8b8b607ffca32b65e46237208931d41dfdff9ed0fd2ea428948df25b7b59181b21b49142376094e5a489fdd58a6eb358e2705191eec8b938bde773d4d1f2b3db211ec326c65c368f1f8bccabefa976f068f449f93024127b70e0d96ef2c6195eac7e5a13cfc27081879213fd3607f03d6f579c208e0a54c0f3c5311d0b0c0c71d49a04fc8399c3ef77a7074e847af9779806d0da9e5dce360fb805de87222fb22d507450ec78be01a1ed79972a226258dd939698b2b44762a989d84cf886dbd415165b906f4da783bf60057a95a05402eaa48c65a1a647d0f0cd3c32cb42271ec99fad111d779824f93e4844ebd702b4f58baa04a09e91c29326848b73a1012dc8a9d9c778210834aa15fbba70287c470683e8fc4d68850c70d87262f2de8971429678efd7ebbf18f59e8057bc4f6996b65d65e8a512c7aafb0d74cc1694187dbc2d5f0c04de9020de84eb415471161f9e1ba9136f5250c181ddb96401669dd35a0cf307df2923d479ce4469c987aceb7c43379cc9575aac9c87090d226d8b62153fc38df77865c6a06f0438bd8c6085fde8ba5b1e9e3fb9f2e1c5b0eddbfbf5818d5c4e847bef8b6423da2ef53ad263b0a29388645be46d5c50b76e1b8eb0b8129498a4ed785711b21d9a9032e402ff6aad4182cafe026f56adfc383bb7f47114a6d732473b3b1682648c5ee6fce7a50c21797740b3e4ce5fa68f040dc22e32ac066fa3727281b0a33235e431d53a11c86c89c0e5dcbe237f5a72bd430defa550fcbe72afcdfaa832739320c5abfbf1ad6eec8ff40b1af73ff88f078435b0dfdff37034d94b49349df40756492fc1d8dea5a7cf0f9fdf77caa5c234ac8bb650f1876aa27515f38491a6993f73fb1fc4f18431c092839f4ebab759695e273cb2697f7af0f68ae7fb2fb6eaf4c782df4bbf41d75ce6480bba575bb4ec2de9dc62a8f66149d41a6f09470f80ab0a5afda15686c70eb7be2b7564ea658a113bbf1d0465e96f475a4bb38f8cd727120096c58d6f8aaf10bde0655f08dfe5b8b5bfeb162d449ce403a084bf36ed6c94be588c428c8a11ac91c7399f839fef3ee97149bfba584ea3b94b301963539af86423a6522a4340e63c3ffbafb8657108e5b184aea087687fddcaf9af153100a33dc8b0a64c22d5d9715535fa4edb847f64d8e584f68b94c9875d1a40f4c5b288c32b7430e25f0798da4a13f188add9663b0da24697cdac02adaa1a69955668ab49c4c54fad4be015de7699e3df0b1b25ca2516552880b482d96b719b794a43c28d9652713d8ffd182a89cecea93ac6d556d97dc061e14a023aaf07d78846711f97671f85b1da5e3ce7fa46aad60c1c339027cf6dbc89a77141f1b3dd242561dc019464614de384478eec31ae5e1da1d92a6d5a239969a4ac9ed745247d258e992e64e998c2788feb979aa2faccad00b6d7cf98bdc96caea3c0a50778524994316611c098f3c9314d5e397725f8482daefe557fec99442b9ae8e06dda29e9bfb4bcbbec217bbcc565898155ae73abe33d5b05ab2b57aea0ca98a09baf4c5901756d651256a23abdc81cd338e7edf78cdee29236c3119f0592c873e099040eb05d649977c1c57e78c77a1022519903a5da624e4fdaa10addee5677add81376d177167bafaefb41540598574e7ee2211638a5d17a6ee763aee1e9db1c4282ba13ab59b66b627f75c8c6d02e5963c5352c92498fd31584318a1b13490d158113cbac165a35e2dc8e9c265ae9889393b0669a15d6dcf18a1e9fe55439c627a3a649f945edad2c1277ce6d715b2fe44c2078e3806f4797318aa0d3f3838a3cddc014d25c39853a0ac63e9e3e95517aa6628643afcceac65b1f14d28d1e4e2b78e32fe6948e7445a663ced4c603b94195352d68ac234eb35be2e9515fe75c9285cb9e3b847608fe62d93231e10697621433c1f00bb6c8701331c33674134289796f6fdc462cf4c34dd8f607298fbaec05510facabb54b88cdf6d69495d9e8a7b749e827a5afbdb9ae6ae720957c0ff7ae18bb361512ddb5ec63b53682e8eddf8a49a33eaca9e5a55c229484d97bf15aba20dbbb43e2195a73a507ce7b43620da0bcc81e494c9f8f039d5f4c39707d0192dffec0094cd1777270a51b07cd911e7696f75479ff0b81c97735e797666b0bcef04f1eb2c1b056a932328eb93106b68f53e494bcfcf73116cad56877fe692878c21f38372de40fdf84ee5b79f31af7d0d304ea53d3586f36c3cc0779e790b144d27574191f482623b9628eb79632258a7337e21609bd99ab63d2a1e527a8170ecd732d8cca341288e338ed50a2e4b219d3eaf13906068071b101c8d09c7c9ba7d1745f5cc36ebe8327d12fb4129966a6c4e4fd690c1b9aad6b596caa1863f166971e2edd79a324e7629bdca24872445876fa0cdbccbafee2b5ae666a89c5048bad43b83633fc370a8f71e01a554afde32348fb8260fb5cd3385f1740fb49e9e87b914c5690387e2e35e01ab2c254bf7a5aecb7ce9e90e56038c7ee83011d437fae58c76cc3819b600bd51de78a90b49fc9cbe155775fd66655e3ad853ab27844a5532e4e93d6825db246a33acb18cf292fddf7c2ca0a38dd737152247a23b7359db11cf1a34999005fb8bffd6828e2a7a1c7b1bb25c2a5ee85e56d037cc93efb91112dc9fc6990064fb8c1c3a8c530676e7155f4fb87b4c61e60f6864c7801c7aba2d106d858bbb1d5fc6c78bcdcdc8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
