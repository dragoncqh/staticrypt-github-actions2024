<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a053c378a4d5d337ad2352de911f1538599da3215d7a8ccb2dba86902dbd33411c46b88fda47d906e11ac3086475419a46a6a679e3d4a00adf2f6dda84974660d8a63c4d98aa25ccf952e1714fe20024219de78d5b653ffd3a0bf92850e1c479cb6906e835a7925d8043fa88285f1be4a87d24e951559b750479f3583f25a41cecbf23a2b113cd3159b924615555cfd522a36b7fca8feeec560801dd6980bc93592c825c3880114ce5f1d9813f3190207c01a73e7fdaae6063208749ef0f7cc201097510a775a12c45b9bde6780b8168ca7efb1d31b060b108e8b1b5fc5c07a622f80e24abbb204e2fc3647507d42eab8fc28551d43601d5de582b40013c2ad771bf16cbd8b50bc7e4d664d190f4cebc563b1cb780ae297a3fbd1b395e1d95ceb19dad1a3b9a3a273a133ddc6db828076362bbe01b0d9b7360406dc278baf1e9ed6371476a39271e4d13f08a3d70cde2f04606fec50ee38fdfa4943dd9b2c4dee0eb63efcd3fecb362bcdfd636f732d05f880ddd4795f1113477876dfa15e9a455a525420b3a600cf6b499704c74629378942925355b20a08163453407a44b0de1b0eed4d529737271b7fd454f87317f9ff1bcc6a1fc11dd3759eaf4201a1a4b3621e0fd80be8e3f4dbdeb42957cdb0c738d99428021c3dc9514f214aa9507749413935688f05c07489f7bb4dd67f8e733404acbc06b7f9399253370279e1e381256cebd07b49dfd32256f3721383c4de0b1aba8f228f252f54f843b0ada652362bcb2cbe68a18cdcb9051259d8f27903404f7eec5650ad3324172588557e10cccb827033320f578453eb84edefb2dfe191035235be2f85bfbba01d1d1bc71b34ee140d8e2822db7b4ae6d3bb64af66aed7c19d0e03ccf5b4c6d097e0349f44d2649ba860c195795b358167638ccd285078ef7a203ecc91f4ea050f21d568635c4cd57db00a4d401d376b86d490ffc14eee77e3b7990318fe6b2eba5fd869b963fa4b4c699437a07c2b5084d47a30853423697940dffcc131f29d398b3b53b869afac651f41b64042aebe9152b7ce8b0ec2fff6d18c843b6192141bb0504fe48a2280943d74aa81fdcfd110e5e7e95e231be2da6b534a6ffc2efe004fb9473ac051605c3552edab7b2e3e6911ac3737aa763185c6b039b80352c5daa14055355ce3c2c607c36f86b7f2ef8db61af73fa47966693c66b26db3eae8630ba4c911c03657f6f5a1be9cc0fd7f6d534f6083d4ff2fa1ee452ceb5da9a7801f8e06501fcc335d0735645eb19982fb7463f1552e9cadd0104ad5678873829c0e96be4f01be8d3be41b296ac365818df47a407f14268067d5271b6d88980e9bbbb3efbac0a2d0858a91faaf4e7f7805da73df87356790ed542a922c66b9b8d1d1f23e910e98c39c884f3915625cbc5c337741a9d580c1d09eefbb0983b00f5cba10c78686c31fa1b51cbfe0088b8a119c97236592c000c976bb37e2cc84fab6e67813b530c079862b24cfac836d02a2d5b6318284bd103a674373f5ae6bb462814b0aa9653f15adf792222ae4d02a24c1d7ba44490399505a809cb8d24433e539be5b0bc40e623493b1ebb47fbdf9cea98bc748958296416ef059cf7302b44beb14f57a1a028395f15f89647d688d977d65995b59566c4e2aa93249561b78bb374ad7027773dca8c293cfc20d2df67262b28f890ea73c1c52a118e1b161b0bbf7af4c266370ec9cdbb6cc0a4e92cdca526725d37657102f343871d1fbf5e75e00c83e22212060f4b6783dad12093e6a8af56a5ea898ade9b83db63fa24ce769430e49637adc5d64c738f43bb2cbbc35cb9e18325d4f2d1b4501e28cf7a1d1a6cc47c662cd1186aec272042fa3e61fca8ea63130fc23019f75b558db6f9a02133ef6ae0d39d7e9aaa42ff069e606b40430280b3b9b7b9c2f6915bdfd003a9dac9ef6c2b95c51fbddb763b6822d63d78b3f4cc17824abed8e89259c96f900da9d5e5ad6e7ed04d347b5fc543561059029d2502426c4d7bc530628b93e35d14512095e1eed446bfefa6326e1d05380877d47078b6190ea717a80c0bea1bda0eb6ff55d033c33bbc1a85af69db89a292646f8b6778f87d9eb72ee6e01707a377949bc5626d49d397099c1be2ba98ef3d559b75070be6bcc4a34ee2a1a319df2cb30f497324e134d0e12658dbee7b1a7ad09c655936373996614a873360efea1fe9caa7b1f4bcc7d38a02f1686cfa1ccea9eb0b4a75dcd46eb2a10291e2fc2e782fc9100c0688b9f74b828ccf09d5ffd4987e692c49306ff2c4cea64343d1f3edc70147ca9ff8753e5424665e7af6aa2b10a9137a601f7c3c7f14a0d1fd761f0996d2d8a329fa54e6bc7189fc5b2f42096dad75a0d979265058d872faabd9714362f61c4968399ff1ee3f161475b9ad6d474aba3cdaf4bbeff3f8d5f725288c0518f307c24b6573685a0abded722345cca44d1b431efc1542f3d1d346617e16b76d9be935d6d5e7564c59bcefc5aebf8809a42bddf3689af4553a49d2c1e9c279fda2a11f787a636b288bdd83cd55b07890baf92c5f4851b3d9f73bfadd215e75eb47fc6551d671e44d941a438334ebedacf9c94aec06c2a5e7bf6ab36db0357489b498d870a80e216a15d5fa96387399ef72bf2e4db51bda9af2069da93e9de6ed92a9b8a3a3b7b71bb6c8f3c7f3d92239532f56a8cf7a500114e48b82f03923bb63bdcebb08bbac32be36d19c15d6548cc9938c4affd8d7c97e4fd45f85924687b57f18eab15a8c01da25f70d1a3ebb97de84281648bebb7a2d68a7a0cccbe4c5bcffd9563558a613feb9bf3b6461cfed232bd78119ef5494af5a3622412befad763067dcf1157eabc01fbc6820eaf5b4559e333419ed42b7de91b06ac77c38dbf206d26cabfa962dae2670b2dd1fe09dfe419528f8303e57199cbf81a9559789f57b1ac8863f48fce9f73d5ad6731f74bdbb38f7057937265dee2aa9a0cccfe03b3dfa7bb8d797249c4693812dfea06aa9798e74870efc5030df824e63060297c21c56289f63eb172ddcc705f3d8b2ea9ecddd9fbd73ac7b7a7b9f0ae8972e2e192cfd91c3f4700c4c08c7790dc5582663e9596ffec3a00eb87d6edba31271e2bba83485e73c455a6abfaeeb4e872a8c4dd5cb0ea79d6a62ff64664cf0dc7bc3ad0b04533190965cfa7516654b6179beb45849fc0624f8179dfa11adef71ca45bedc9809f4c8fc16a231ebc5f8a294a205382028fee1c1a9fb237e69d7a3a6406761a46b8306c2e268ea7b6d8022df52363d4fed8bb1615f3ddb9dac4dfe68107d6a1c06ff77c1f308b50b234842f0c4534722dfc42e5cc360acd992c3143fd6a85ac7a005f71bc3e5c9d17be33a6f3d0829a7166b7c89b0792b9b1cdee300bf21ac850361ed3968882429ea3a062e07e3334f1f3cf73f3ae900f4c8b26129cbf5c3e56142caa0b9f293af530e7c8ad08226dd5c117f60af4d38873227abc70b20c1555f778794aeded08787bb209ced2e42f5ce7665d4aff1b87f9bcdde7c3615c66d4efe4a5b38a53cc554b8181620081380ebf551073c718817105aee39b3862d84f1ebee610c840a4a9d35ecdc94b2e3b05985aa69f6ea22e1b1374a695ec7187f68833238c45e0d3c5156ee6178f2af0e11705c65dcbcc101f492977b4aeeeaf1e77b3d7de0ae7f161d79995ed20b4d7eb2d436419e395f582afb67081403c175543bfe7c098db9495d1e5b5c09a1034515a4808b177e7dc0f086a3f199f2fba43417de5577f6028e793de90df7320f268e75bec5785bbbd1687811204e75740f37ce444475637753f11825849d674cb58d3af760ccfb119dc4f82723b96bf5ade095a869de5dc26dadc5ad7f19baaa7763e5be2ac3229988f132fe2863ccdeed734e66a2d60fd53793d0985c13b85d3dcdf9560740f759036078d301455563d0db57b30ea1497fbfcf58a910ac904b93f5eb4165eeb9a9a136d4654c8ab00ae726ba7888b1d2e5dae0642c68acfef809a1437304f92acb0131e4f66de2521f899b0cc2d4c1e9ec8ec2adeb40c871f14137285246a661521d1112b31e451275fb66c302437de0400b329f0b18770d2ea67b863efbc79ba1f0d70a2cbed04690c4f2e9603815493e2824198c923a75afbfc9032b9aeb190da71055db37d293d7380ee6322da64e90a449881eb1e93a90750aaf450b8d0185c171f1b46d1b0050a3b5cbca04b06aa3b1599caecedbae12c666d9baab6454edb7749bbc3b0f9a36eca9f229b7b9dff9fe2f5b36b69f66317a9c3470d793f568e1c9b1336e46f9515b2b9363443f640d24f1bbca43727746e4e0e0ef09c2f034294d9f147f416bca873ebb138db6c219ba0d0850da415a809a6d8990f753574133aaec7d871a47ea2fba2f373fb9f146cab1028fc5cce10ec4f19913700dae17c6b03182c7c510eb5d1200262f7f9deb852b548f5c52f3a61d46ec78f48d20d419b96fb23437a14372fd85fa13c15b9ed82453314a00885dc54fd346e809304bab494cad38e7c8d427481f66a96bebb8b2e585c19cf3dfb4743603f7f049a9f00d23cc8b7d231275c95073850df9c8a742804d580bd86788085434a6a64c56e555511c57757dc2ef1f7d883471f63792e3003fa9c56a7a2ed71add55aeac1ee69f86134a517fa794a1fdc1f012546d586fa55fdf254808782eff5096288dddbfcce20845b52ae72ce10896ac217f538c0ea3b85421e3e0cdf76c4a56339b4d66e1c805d91e2d4f656b21b839bc7b62a147f3575fdec91a0044ca5a5007ca63a061993eca0efc772b52d2793f8077b6df6d52662ad6ba1570b802d468f0aadfb99c08936d24503c718dad5710b997d63c33a4ffa3b7223fb4a6d503eb258a509f0cda8578438d29a23410c374bce18562ff41e26a761e28158ca43737b112e4a3a2628a0db0828a2a12d40e84e2e6705f36a8455f4f03b0d1c2fb30150fe3345c3f5a3c0e4d987c9a2600b7dbd0b3b7f04037effbc5569b658effa5eed2f556352cbec5be5a6516036b16a35b577b886a44f0ade5438f859788f40fb41e08e5c045e2bdad4d6b6e49e09f5ec477ff959abf47a7adf44c582bb17a20e9de9fc407afaf8a6e708eb311319ef2b934feffb4f4629dd59189a9e117dd9224b72c9fc7d1fb2a27845aaafe853cb0a0c828d1daacbecda390063aeef782f7b89c807d1ac942cc3883cc30903a7c9038dc4c57598c9c1465929db9b1b3a223d22c7048b40f36e284aa4ccefeb9110c432199bdaac8449e565ec1ad3660de523daea892d56333b20836611147552dabade234bddaee4d792a599165e885bc7241ea640d07589ea63d099b7e77d5664ac8ce1deb72a17303c723fca17ffea375dd2a4426e1704a1b2c2684e114783dadff09dc8e4dd0ce7ef7d80209a268016fb9e936c15ebdfc1f89aefbeb4eb1869ce38b1cf450be8bb2bd037934d55e7d03d1192f79bb5b69a64f5b63a43574834112b1cdeeca5ec072c5f0dd9abee8ca909f5edb823264ee6b3cb5d4d2062b5bae6c111fd921abbfa5f6bb44d60e4b24b4464555ef8e01aa2f62e3c687382c05a74fa90ee700c43b39f8ba969e799770ee7ebb3fd8168f4a2cf1894819f7b67e9af73351fb1c187e235133ae6d691d5eed65ecaa475b937e856e05bce8579b2fb4b3dc92f0c48e52222f32c9bc119f9df94514e6be5d9d6b9b6626cf0d2bc8f9593c1a3cdd42b0fa810dee2ba3f48e089ef3afc97c3da5844294b0266b09c6668d17ee4652ff3a676f07c07bfec1ed9b24d9ef0e60755e0526cea10abe80624ac21e7fc521d07f04e60bd9ad79b5e31f5905cb348a276174548c5cb43b96b942f5cc85cfcfcde78e3db22fd2549d92f1bb6b1bf5d25f2f94afb550ff2298e8304a3fc09c940aef89d8b8405ef100dc832580b8b582d2d9a684edfbc6fe3c54af19395ea08111748ec64aa6d566ef7ee0feb1a6ea825485a46ee3270c6acaada611f23dc843b52dc1d9fa1b8491c9b70d8954fb2426e8ac7dfe7d5ecd279ddfe4858c0f9a2e5f7bf35c9ede0e560c64535662308f180f7ed117d77f0bb85c3f2bf076753c6c2edd4b874978dbe63e95b47b858e1036cc94efa61a9ce382e2121ab56a8974d909b0034a3112a12d2687a54f11802be2225642f571024526a1744d202ac42152cc73d53c41db8152f6a1fe692d694913d9156062c5c607c69dfb13e4839845f751e937bfffa4b5039e29e456a48ab7a26911cf5643cb46aa13652f43fe3024a051e7ae12652674e882c70254f846091cc0ea1c929ed207b920403d11483337206e2a20386862870f7f1fbbeca894d6742434513adbd271ffde5e3bc3341bc096fd29b294a226757cb3341096de8b622b1363b75849cdb8a2af514c3f754bbc4ce5549ee7205a7bed8bb383ab0e2ec09533b08ab41f1a2a1c785dd6477a534eb5add03c96547e6dbc8fc5e482fd9dcbfa9231fb623a6e8130c112fd1199535241f979d50179e712cb226f79fcdd370b7a7bef734c8dae84e07ac895799b49ac7f3468ab6d834da339b065a5bd400b4560cd1a72f05147316683435103d7799ecea4895ac1cb5d83d32279d465b4f51d13373920f148e85d1debadc693d486f22a5463fe39c7c3bd333b6fe5503b710fb35c065ca6015d4f85d56bc46afacde3e7f78de10fd01790e685f7d22444a3a92454f670ca9fb64e88aecd5f1e97712206212de0ac1a33d8a89dbca6f17372ddfcc312fbe2d62f39b5a7955e3c02c773d64a4b0951bb2e1fd3ebc7fba7d32e96d20096e72460a691c4b3c67d829f232b64868ed4dc10b21fad1edb341c6307153bd4f9d769f8bd1867bfdf2a19f6815aa03dc2a750b187e6d96580e86cce89ba55b5427ceb61f97a856cb242e174052fb2fc0966af412d229290327710d6e0fdc2e36579a51003c3c18db7ef80f809554518b95703817428d6263891b19c37f5c01d0d84ed523278c94be9eb261193565ceec19da4ac6db0b676e3b9b89a0f1f814d7a347fc4f0a53993e82a531face105293a73de5dd0d692777316624687cb5df041e171c69404d687c8b30fc001769ffd829c8ce668bcb8cfc2513f3b701ff2926d8b1df5c9a9f734b1c8128cb743ff35956934b4bf3cb1bea16ac601631591cf238606b4f90d6cea9ce88c6456ef4b7c1870c258159970d4f536643ad5ed8bb4084eb19c986750387de7e64361364fe996288bf3675e14c54c93a38622973715374ef25a7d3f0ecb6a45da907b34d401bd8f6a224e79be657de5ae3225da61ef3ef6f189e8c744e5a7c5c56fac77a12639ccf824f8e760c4197a05f0a1289aaf7ad8c2d4e7e2e9f63f6a9d78503c6fec7fec31e44fe6f95cbadaf78f1692f3004910d95fc56f7d067958c2ea82e6d2fd1e6bf2afcdffebe1cfddbea2c5fab9fb377ac1e89fa1603202b8915facefad6859e6866675b824d35f1bda9b48b96d46c6bca5c38e1cedea4f4865ae60f169f1322a810ed10c9a991cb21268ee66dfaaff95826e343def40af5a0300dcec0e6d8d96aa0ed67ae0d08c174bab7454e65fc7dadc8355ab43aa2d18cd2748cbcc0e6f072975cdf6fab6d8af721c2216d9abb780e775ff90fedf3da7d00fdd8971269c614fd6fcf343d22987ee029412f379d45c2a1f7930e48810a756365ecd3a7510dd95b8401a9c0bca8288fa4fe7c38153227e01a787bb3965be77bfc6603bd10bdaa13c5438c3cf1fbeb12f141498fe688416d833ce2efdfc947baa7533ea46fecda8f8d668d53ab75a09d15624010e479a380737598c111e2d247e552f17e382cfb1e09ac48ef74ffc41d9236c543cb82dec889bd7f2f4c572df1c949cd823e31fed01128b7173c344fede4e77826544ba3ab28dbf8db3f4758cdb8d05c43db66e6219459240baa28417b1e860369dd0398cbeb374f7b066c79a44a0e30f5a6787134eeae2c8d2ef4b1e0fa03e54f784d064b3725d0d5fb25eb5feb83d5d39382a4d6dfe552cd9fbbc579d75df14b90b632a53675b59af5d7516adc68ab61097050a6af60d4483872cdf80b40658fd6330d7e759107c33a5df5fed8950dd6859c3cb39eda6e3f3ec0d8ecde99af71752720b135d73e2629405815bab56c9f58e325f5fcd4aa4caca4e9fa1b642048a53e0691ddc9228a3857e301eeb2e7957e49e693b8ed59feaabc11af6f6f37c2be3ba45bf8381d6150072e2336c92f8051f2d5423a3071c159450dbc20e68ddc557b878a1851e97c3e7051dbb82436c1615a85846d9c6d67da90f65abed732da912c37170e52e2d173ed15a4f3e1b80dadd17364dba9d043b6ddb1eeb320586016dfb401afecadc6f96af6ae8b2ac2e58535b58bb25ebbc2ee664247e07ba42ecfa73d740834ac5ad957118b3c2c5c93e6f2bef9bd9b8220a45fceeec69b43d3a6f35a2d12d4170515cb8bd715bde3075ae04033e30396741dd6cd7020e68e3260d55334ae62f1be72914b840bcc652105c9e1935bbf0fbb0c6e536bc3b85301f813048bbdda934a825bee421adf34566b3341ee81ecf5bd8120e2e4333e1a60ed5084259e8927b4c8655e72544256e7ae3092cdf8487098103dd4b277850f901d2ec1414e770e223073e387d5ef53ece14b83be1aaa89aebed675c59021c136706823f6899f36d741463c5fc3cbb46f64b905c584274de9339f40e36c71d59f1e4fe1283f1f4414f1d28ede05fa1ef58325aa33d32f88df75c1396696fde1fbc45f2f5f04af75c422406195db4258d706c86f78095c05cbbf48fa8edcbb6fa2eab652dc030c282d22621f02f210ee75aaf3ca8f7a6ecf52a64f01bf70068d42a5818ee5dd49439899baf8fd530e628faf9ed9b3f41586edc624d2b8395476bec06acb0674ce6a287190866ebae8f178c14bafbabb08202ef4c439a8211a6b3c515443ab10bf8d5784a9236188d3894c492ea652615df6abbf0bb236fbc3369e91611bdfd6a8fc91220201676b0994dfdde8ed6bdd2bf85550c0ca6b85d2b0b013e91d47ce53802fc4b6a09a6ae70e3fbbbe8a530914369abf248b4830c9b127a0e904adef78c75f907460e709412b456e346abc8d1955c79c96a927276b130a1945f816224661da92d3a19b81aa8aae4700d97b5acb5a88032b8b3c62fb64ebf276c08f11d6693f7dfc19c0eb7fcd303ecc475ab3d5cca781fe73d4dd6c2d61a8ee7453ce410b3a77f472a89a68bb65a339a851923c62b0e495197eaa70a1d1b455419c00258761c2d72763a6dee0fa01416900cde1e239dfbfa26b86b570ac9681ec7ce9f4050075435bb621f2b919b2c4f1c5c00989548ed4bb9b911ff6aa3a4d3d2c3b922326d77b466d27b855360b67170dc0167e3dcb21801cb0110b686e3528ab38edf2eb1c32cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
