<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d727b3b4096cc14aa6c50f7f831abdb951814dacc00551e85f5e4a6e37bc4264ecb19e61adb638de28ed39c9515cfedd3f8927ece5aacd5095aa302ef189caec1d5f253fd14323e5f59b2a40e33cb3e00ba36f0306e636ffed0f5572de121694b769f7be8863ec8a65265c685372581622f0062ce122aae45da36c5c8a7cf0260fffac811b54af1d565d6af2279d7d10b618216e382b0a362b9d4d4422a6ed052ec41cea97233973450efb33a5e7052b0198ee529c66be0c7d0935f19d33b59aacaaf72aa67d95f645b3c606591b9d0f977815242aebc642b8b35b8ff42a2c0ac8528ec2f089ca5a6d2ed88283b3ea22027383e7449c10a0b914ca9d33a8a939425a6a9a45a540a8a1c7ebb615be6293e766df1f164d5be0533772221da09218261d73c4e72e1d1b7b1e61688d2342ba07fce321b83ecce1595a8f18cee96d3a5c3841972e16149cc0c3aa3a598425b1edaa5c6a775088b315479d27ebc67ccf1054a3eaa48390123a9fd540aec0870823ff8c87464d2ed965428162ded038d901dd5b5fb720038a8ef310040fb4126b3727150182e1b36ae9d2f4bb08a3c9d754dc042f9545b375237ae26fe3ecfc2a0a5566976d268cbcd10cd6745460cb6a0438f8087294ae6d109c01954db04934f94c093b84ca509342bb9326fe1bf06ce2839d3662bc43fa435e779d0e150714ca33ffda6e4c7091cb7e91f67aa2f8e313aa14f8f1b2a96133b7f330799c5c5a70517662a9b00e448ea17440f180fbb3a7d31e11a6775d25fcea42ce44365dda748e615b1d3dadf81371f5d56ae8f6c0e01e8c58f4c0d824c7436208030aa4434b22ce665983acd3446b1a1d84cfcad9227bd3d9ba65a066124b667062a200cf60daf53d796ae3dda65bac974d373b0025c424db37571a5a40fab5ffe488e34371a92f4d8518a516e1e579232aed4cd03f7d96362fe985573d4dc32f69dc48be7693d442cc73dabbcb6f9fad4e5749fc88758ca598a15680a0fdfedeff146eabe996b4d8050ab024b072a07d6531e604fb86b87d2e1c1a2eefb85283dd4f4a66a57d0b159540410b8701de3c39d091caecd89853deaf699f6c8cab2cf27fa783858ae19c47b63d5758efe3360e62f791a84285978010f84e416830ef2fd7622f5940c962d04844efdc61172d3e7b3b9d0a6d578e43e9d6ac6e950371ebde5e0996d17dcd9c2c0100522af16e5712ba461bd5a32d832a39cd224198469b8d0faaba3645f3ac3a7c75cbea8b991a8be909c494baaf4bf3125d2fc70ee7cfbb46fb67b6eee6340c3aab719594f2f9f8330341d439048cfed11918362b4b4742c9dffb556f02d6cd61d172734bb876b8149f2fed050f1fc829f1e11be2a540f7faf1e0d8e4582966974e9d2adcdf29043a156d8ef145f73c7f56184ac398b6dbdd1a436b7b4ee89afcd0f3cd5b1d0c25159e5d1c53ce78a4565996045cea51edbc40724aeadc3e78c384f35e22cd400448caeb610e044068fc00ac1abb0fe717d1a0ee183eab7f1533aa9821fc5170571f20438d7471e336d055114cec7260eacb6e3c6c1bd81a135e93363f9414ac2558064e99e64a81f3d8e1d9e214988917b093d251736ed0240c38ea38733f8c2f031a63c6b3daa3ec8ec08ade3f039112aef57153f0feda7da7e5ba88d38b42a35d4b9c556242793eb6407fbae124ed48e73cc0d7848c81ce39c78737beb313352e2babb9eb402a7ec8d43cadb9a776db35c36e806dd93545fd17fa6208961ac69bcbb080e1ed1880309b9213a3f193e054219b98d995629eea998a6d7880d8810ef86bfcae16b159290bd87b86ba02729ea0d2fba855449092294f88f5190ba10366b0bb4ad634a98caf9a972d6e8a6a1da1f28daddc47233731921a175fdde19c09e502a8793f3dccdc4e4d8dfc51de38105fd523ce48fadb201a2f52b0a1f36f582d10e96f0df4558cb4bad879b32fcf3ffc10d3421f6f53875d3419227d8d49a4a781363f3ff3658863cbfefab94398579e39adf7cdefe378b899717832a1d5144cd140137b38cfb1fc6c56f2ed6c3f6b5764472a091a89d93a27f205862659f3c3e7caf67a015240122556e6c3f415f7bbf719cb49529c7c315a505a831974a24f0ee548d3e35176e45011300857a82c6ec5ec39549fe31de7f6b5a93c0263d0b1214a292dc2ba6af23fb0715921441018e501ffc5fadf78e65f8ce626b3dd238d242dcebd97ebb208123f2c452eccce2593223bd835f469f6bc3c66fe0ea43146eb6b5896c95e5c9551bdd4240661fef9917ea991f74dbbfcc65365f9b13e971d89d5121125fc02dc53a6c88a57a31fa7553aa078816e12162dae71c8b9da91a58561a91fec48ff30a49e4e6c42a454a0831150d10f9e44af69f4e5926491e14a3f1b51a5332e3305a762979a8a7140c0516695b38be4c170079d3a586fdbc67d054d02c0e0cdb0e89c1c38a43a5c977129ef40c532d7c09bcb94331c4a1fb6379a2cb06de9a8f92f1ed7a52a50f6efcbc4ddc213e7445bdd0f3cdc0347b82e99f9b220012e6cd13824690e992ddc951b54c716aa35fb1b8e466233d208b6611baf61355f295cb0bd5f9b3c33a4810c898231db426be8eaa6e44c8f4493a71e600fdea86fa894e8236565b6146f092407840ef98f98435cc687bc398306ced995975a45bc122af85b6d8f8b6533eb8fbddb3d1b514104a2d45d8fdab8cc129758890498d4a9b18c7234baae4348791b0f3765ac35aaee596718ab9487940015081316cf967eaeb6f4a66f242fde78ad7413b5cba19460fd1dcd5ecd0c6dd9650e35d64633c716e4cc124309aed14ca60e62773650a4b8f1f749c779bc932d9dc54b0a6067da2480efd58ead5df932bc24839da353131288952e6d8bbae9cf0a5ef3967382869427cab1bea66addebddc17062f98bbcc5ef78fbb871c43b56ca037876cfffb80e72f57f0a031dd87b32757be65ede9580d279f531e1edd6090e048c1be8f7499cc2987b3e05e269966822b8608114e9c2133cfdcc4b1fdb8bb5a20042d5f12f6d99b0257d92fa1574968886c2102ad6fc352e98ef693b81c666fae76a9aaf36a8eccf477554648004d8b488d022795ae22932e6c7e5dfeee717e7cc81ba35a9182fb8f0b0a2cda19a5a4809f72aea2a93caea407edf841e2ef4f30e7c11f543a61e26a745b8595d29aac0d17877172bf89b3cb7152906151782ad64931db4225791e722edf00f78b9f2b72f9228a7e681a7f2611f1c5f2e69f3c17d08c0c9585a39cc00a8e4439ee50e8b7b57047b676fe6db049e0c72c0d3295000497a29aa58ee50c96c2e6124037f419d1f092195431f3804189a50d09963b59a5b228d33fd9a87eec2a1e6e1169d529c36350a4c40d9e6d749f407853c84ec6a42a6b02cc6aad1d2c31f5e76a214ec05cc56d3c1a22842e8acbd4ac1961127b625d0a6f0f09b211c539de7fcbb9279ceb3cceb316cd3f1abe17cbe9409e2e72cd47bc8e711fb23f5d53d1149901fd00bcc48e5430d5cb7ba6ef348b32b5f781f57348d160884bdf190776b9eaa10f00cca37080806036d3addb55c1b45a455553f2b568216a890f4a4a824f88241be140e64366a97c31e1bec4fabf596dcada4a3f539afcb0e2e327e12d841d8ae75ad5998817175829a622248f63f4278d8d56a73b4773d9c2ec291fedda259fae83d658818b8a8014403aa250d4723893b4d88061f64c74ca0bcac2694144b373e715e69614bae8273e817a9e615f0a5cafbfc65a680f2f7ea3051e00c300c203688fa1f7c77d488fd91c0bf7c4d8ce8c1b2986865bf0d5eec2783492814107b9adaff42e671febd768810bc48440af487aaf22ba614ebe4b78e93310d5dab3dd7db786020b06d6e79da083873c98a99b6a1eab1d593a6d79d73519f1638bda4fa4bb37203807582daeadb6d99721bb9dc2a4d64b32a3e9808efc52d7307b6efb973e37ff35b4fcbe8c9ba6391d49b486fe4af36c7b69429e911b9601dd1f28c186a698b368237b201a3f05980812b8a1f8cc724f388ff45c21e3bd366c6d872d9e4afa3fbf2b50e7b5379fa356129aed54b96a765f3a2eb3bd11da3c473a567a8e7305938a3d9df733f7b242a5c004c6920ba5c31b5de1bf57eed7c40876e44d4494f433de2d3470639dc1464bd148d77a227f3183a5fde4f70fc7429ee0220dc499315a9e04b812e2e536ddf62ac4a053ab79faac9cc587b55bd8dda61c3fdc8b03a38059b3a79046d3b9a02ed46d7b90f9fddb7d2d4af5b1e1b9d971f17723e2af7b3bf7d9502d30494cc84664c6aa21254903435b51946414e93ddd72710174150e5ca644156142fd4e09c8039706bc532e28cb429cf8a4faccd888a6f2a7ce3e6cc4cc034fb48c6a1955dff4187fa01741ba7cdd7b50508c7e10f8cd1fd444857e9be1df94f7134bd522023f8ae08443d807a65df24c5ac9a750351ec54294fb8e937f3ee6c139a2d6da94ccb58146bc69b92a814410078fd46a904aed9e0e034a171d3b0309e055a28b478ff756993dd56878312c7f4649a0ab1a88327d7e828d6d302b60564e44b50278709b818ae55165aac097f3c7ce88a2d5166a240239eed46dbd78ef2bb862c7983870d9ac2d766fd83de5d65f73e0a52ad28eb227a0d52c2e6944957a0b313a9c141d6265adcbd439c57633e3672cea7af4670db543eca399b37d6f5bda40078879fa24f4f350b3d05349e854fd964c5a2ccaf3ad2331c870b073f324fbfb2f524fc406e73ca1a710a36f4e623f5b23dde08f895b62a5eb7f0b9b812b0359f1b72464b193726381a3ec12c0e2d9868af461026a5231357522dee2847780cd9e6764466192a9e88689be795daa6c8b5a6130b7ee8221eb8425795f231c48afa4fa1bf6dc7c238eab48f47c744422c43e27541ab0279de1e763b85520d84b33f65666bd121f4291b5a50a382c6c02becfeb2498ebeac855b1d70b9ee0100d8a31e53cb2ed07d3f1898471ce58fcc3a62b25194a0977683037d3b31d6cd90eec5e8c2720ac1784a919ce1b3ace39ff03dfd2de5f677bd1d7fbc247f7765b85868f17e2eaf73aef2a0cbbbf1eff201dd06687cf458a8a6d68ff40ab87c183532bc671029979d2d0c9e32494b455e83a07e3dbf0faafaaba931794fb6236547e47261451e35c2dbd13cbe9ba5997841dcf25ade8db779bdfe847fa0d5cf831fcd344ce048c7068879db00deb422c38c69a43d325c4cdba5dc29b70be73aab8440f996d618f44d81718da7ea56f0c8ad0f049220487ef0074e142f0e7928108d930da01e52ae1a3fa29df2cd2ba153fded5cae0e8ebcfbc656357de940b3ff7172e124af59cec17407ba9c7ce97a450f72cde52e6ccc18323d38bb5f910260ca3e89454a2948ee834bf6c98aba78dc882fa758a0abcb2a6b961c89945bfa20cbce3f894b6b5b14f8672cfce3b61b75c7c9343e4c7d2e1486f8bb57231544cfe9ebd60f0b58b28009f51d743f5b31c3a792e6152ae2eb54a151a53d64d412defcb5b890ee5dd22962c57ca2d5ef3657deba3a5ee0b6a701dd198684d603f32924afe00a5821b289e19b96bf749bee0abc7459e7cf4a4f926bfea5474adc9f9263747dcd39bdfce531151185ce10579f215183c32a195acc76c3285254454122caf0c3f3f0816cbb9fe089acb0eee075f0eeabbd1ea1ca76088a170e26dcb0ed030cff6238821e0ecfc563052b9b0beba2c801ca158b9a6c8bafd2b55a0d6d6acd879c0e19811f43443a70e1168858dd89b5e315c43e2a2081e961515911e408f0032ebc8f23aa27f836dfeaa8713996573aaf43372f63f9621dfc609a04e7fca10a02a54f018545b1081ecece13ff4425f22c228c9652782960c459d0f4481a96921d0de07ae73915c88eeebc7a6f750dabb188e4c32ca59f081fe74f13eded4f463d84a9e87b0205e5cdbf9866268461d49b37b40d201ba7c844fda91b8160d2e842d5d6caacaf8a2f3e196515e29ec0647c465eaba64eb16e76b83cca18b3d8a046cd4260f8d6c6df5831e2a5d75b15160a067f313f4cfe83d40bee08e8f596abdb902423c212b72d505081468a42d0487516091de3ff19f0adf54c9b5131b59b1c06df5036e698ac4eae6cce5e532e295791d7fab088704b5f048f39e5d049872cdb6a755fc7462dc0925a92ca14b2b89b383b817b8a3cea8970b7e870c44c770d9fbb8a49ee025f800bc8028229c8113b0f774d7fe9724da252e458ef2dd56c29480734d5c021f807c6a9312da80daae1f1ab81e69923eab41f88051cb550ff2f698b291f4550958155cb3a0a6e02451661c21566f171f73c4e5285908872679961e55095424bcf39fff5cb7ef10d7c97f1124062f4242e8a211b9e06b22f2dec33372892ee8fa1a00994c3d545119aa7b8285e854559977f4756cafc03e8ef902230fbd7c58580f127bc068e818438eec8988a4667f0ff0b49f2a190ddef475fedf117e6141bcc652b357d20357148770a99f4762e0c19ac5d79a47771a95f866e8f086fce9ffa2ceced1b7149382d503681a0b6dc684a565452b2d4770da18bdb11aed5c7284067bd8e5008fbe8ad6e4e43e73daa2f615e53a63876881c883278349fa403b79b30d2893220cbf3169e0f3062dd494b80e2758fd130af1e1f96f80a68ab49a8cff307d6aa953455ed7bae32850c8e7e29bdf368ef9a009ca51f8b95e0656bc703033eeff8417c16658c5fcf858807dfaa31d5e5057dea3f9fe4ece87f23f7ae1ad72605e58680347c448b0502ae02f5cc10ffd07cd4835171118ba105ea1297dcbd03ef608770231908d2a53c934c1193338f0df52b4c45899475faf8fb3955fd994c7255d8cafb9c828bd938abcdb5562befad62b52c2ecde34b4becca0a0a4c87396f3d4c81352328f507446582cc2e827b95c643046f4681123e03d36ff9c6e5b49e57ed27489aab21087fe9199737aef7bd93bc74cd7adf04fb7228b3ba4cabf835912198e9280a120306fc38b15123702585f301122bfd53bd6bb78472c809e3f88e22f9d06b25d80a31eebf55db58432036f0b0c88821a6bb181523fba6ba3a0d732356954eb18da06a7baee120511c865c07692ede0f209366ced457843d29b23bccd739a813a71068787cbbb580051347d5152c462cc059776092432e0a80eb8fb7df89293c2ffd5a81d70e1ba9ab893154d9e3041d3a45c0176496ec13cd9b71606b94d6d3511c5ad194108ee9dcf998408384058afc58576319107c7b7ecf28cc2db728482a5d9a5694d66259844dbd6d88085b5735ac6025508cc4473e81e647baeca8d6d0b3749b3c7659624fd46772e212139e859a140a9d16ebef668115c9771bb87d36b136c92333a7380a3de04058da40bc7df0fcddbbd44cfc6100d32ec1cbe77aebf53cb9ed487ef1798ace0dfff8a952237af4535ae6fa16789d1ecd0e682660616b547d7f058444ef042e02550a209f279df00448e24600dc1abe8f0f2c10e6be3700764c0d6ca65cb7707fe8e62288b7d24f57b8f9e5d68cb29975406bf4d7c49ad939ca62759f2969ae17bf9ffa519bbd228f40365a4172315580bc4577e7678121f183af5a097687eb01f388615a60ae9ca8fd37d8ec8753a8a072473f6ab66683ec88f197716cf6a65eeda455114f651424d57f4e5b32b3e825a2816405c3fe6dad2ab37994f90360974a67895b7eb73267db8cff0e5cdfe0e75df300f85ff619de152c7a37a26c33224dd18c203bfa59a69fda01e7980bd2ad4803f5d490b09ccbe024499abca51ec7ba176bd4ef5145f80d96045711cf1d73556e699bfef7e4372317bb3abee980f98e84ffdfdf1d18b9d71fd52b036cc8a6906f5ef636d54e2cfe00073f0645872daf2310ea3f2879011431f6e60c92fec10bee5bb2fa82fdc4d4ee4468a935ebf889f3a3059129381428d4338f6b63a7added716a4c05ecc71e796610d65111949b08b27116159c8cdf7e890935cec7301dcc2eb276811a61b239c6b7d72ebbe0a66942e0ec2e4a89d21388d1aadf1dd83607c5cf83ffcabf9abb4b6ae19b7ecfcac563ade17ea3091d8a19d47e92bb526d8139c00c4f20ce280ca2848b56e4f26cac59a4febd24b890317c8cad2f14c3a518799f6f6d3b75659328793385d9ec6547d104e2afb70dc31121705e26444c7dd17b5a1b9b5a1250f618d4f540c589e6e337c55962b67e267aef23fdb78cad8fcdd847be785deb4e363ff473202f01e9ddab68252ab5307fd254e4a30c0305b86ce9774cdfbbbbebab453fde0655834d5bf499b23410f0ffdf8fa52701696a3f5082091c33ed3658a819bce11e0c9f9eaf760e68a24d7f2d5584cd51e7bd31acc195259da728db32f78a28ac287b0829b2f1084075a28bd1ae2602e992a3464dafe2555921c6bc752e05cb7e67f9fb46040ce552f281355c5cd3142624ad3c08308df2d4062e58078cad61feffef3d7ecaf148ba6e868e55846bd4938cd9cd6cb888e13b54fc291b90b8a957fd92708fc67e8d4a5192e4666eb2c396d0a1c93be8e046c58cfb7628d66497316afee0847aa2f33bb3586820329fc09d59fc98056b5bba6aad3f25f2558c2526e321330f744ad4dbda66e0397e4235e5fb1f752d024c3482a2f22c394b56a42cf8029d73f9d4383fdff30df2305994b151a47d36a8a832d5ca0c5732eac92c337861c0cb73a43f41a653e70a743d18daf4fce0381f09b6d9c0f6292d7d2dff6abca2e695c18153613834a2e82ea52d0f45f1988a5def860e795f2cae70c2659bc4e536e63be2872645ea057c376d535a339131331fb6ba7d777806d365d5394353a21051a2fb0e4a512ee90731e1744bbc73c0da9dc6b48441a851f698285e2e93d37f94a45e2a5bf1898caf2b2e618c5829332a4479293c4d088d871e52f417b1c9361c5bc2085aafe6f81754b90ba5edba871fa1ce646a658c4b771e9c95048a065720ad48a335abd7bb15ec074b06d25fc7ad79b35034c0bcdab23307567c2daa0bd37b5342ab42991819bf9fbd71118406c6f84fb4b4df183fc2bd137efbbaa1ff72c7cb79c36ad6724d8d0013569599e4bbd85e4a760e6d59045867d564e8e968cfe8964afda4d2af588b95abea066c423e5a5cd6cc442fcd79d949341ea44eb66632fd5b1aeed5abd5c41849b8e0e71a7c322604946f07dc3e4f702231b274de9b127097bc45c1a4142c844c7d07f403be6f00ffec60da95398493198fc20dd4ebe2131f024324f711ad7037abaebb1c0fdf99e21c5c394a656b29e9137bd6b89d9abc7d5097052174db891706e065c0c9dc403ec1c7886c7f6b309271db09b899bc1dcdad1e67831ab5afa2414fa1148159da7ffa5594656b8e845555ca503399861cece075d276","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
