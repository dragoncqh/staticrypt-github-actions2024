<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74f2da6536a27bdd27d1d984a23aeeb3f26e9399314b6d4245a9b5d3309f79f9611e68f5a8fac51f0a5f6d80f9c11ee3858e518f184b3c5d16ef9c01fe5aff267102f5451e5352f2f8d957b72c933f82719ec825eadcaf718b17e7272642e971e5096be197f00e3a1e371b4fe99ab779f5e5c75556488959afdf2f880ffc47017a708a64177640218dcaecacce1611467aa3545ae9d8f743fcd4465693feff75a24456ea9fc46b2f15d4621bea01e8f072ec5111453a4add92b2d1de8b59db4a70477c3fdd371a8481b277e801a5c554a14ab476ecaaf38aa55c638d93edc88e725adc8f554fe252ebc2653da3884168d68bd9753cd6b6fe3f9e8d01f55a37fa4ff4747472fae650b51d7a8a6c94a0d8af4159e69f32981b61b1ab91310ebde779dbb800e1a79ebcd3f28e528608c9f2b9aca028f0b40b099de8c03eb335a874889bfdcdf552d4a440edadd118fc916be9d5ac561c5e5d8475af66aae84b6215ffed7276b265dc27376b83c6ae2a3c1866d4a3eb877dc90d83683628344eb1fc1104a1a9e8651a56a0e23b1dd7d7cdbc535657b2ad05278115378c255be742a91541ebde7da8f858326ce55e442445a80507f676ad15dcda18c2b74e2890f81bfb60feeb7722cbf165a9c902294dcfeab2a5fe70bbf0ce251da3e454848bd83055c30e1573c79abae53ee44a24b62ff68863a8500fcd583b5d53a271b8dc95dc1eb3ed679a944633eaa1c82c773db4e8638f04864434f2c346cd27636a407e0c7fcf421c95d4577687459fd59b89f4a99963965106ca3bb807546ccc6a215bd95d1b10499cdbc6eb0f5811ae2b77e2e1ed87d11306879f9eedc297782c65c636b6e15c101f96b9a337b482bb70bdb4c4379c6675932fb7efc2f937024bc3ba14776a65d250c3b04c42763e6413a192f66beeb97e737834f6473fdec30ea2555595e41e6ce3f1560bb550561abe85b45ecfb1e5b5039d28df339d8c5d8797cf80caa37f11c32c9606c7aca40d930e757dd4f5eb26ec46556687097350536789a1c6d5290fadac606f43e322a572afcc715ec76a68bd6fda2c81f12e01e4f9f0a46accfbb51155f3ad801f219ea3b935f7873a26af476b891aa6a9648edd36cf32598cda4ae712ce6c4fb7204a03803f8cc9ea2a8dd067ad2248fce2c3c7a9ecfab66b5abd3670bc154e5bebd1500d3200631ab562e56cc4d3a1930d85405fbcb25ff6af9f9a981e6825780d9a67e3aced196d343cb738d6beaefa178568570e61935d68ea80b04c67461b7ccb9ec23338eeec186f84364484fd59c49c9035402c95cbd831502badb60f94db60eeb89fc59b4ae19275a0f3f97cbf165f2973c3ec2a1bd0a877c213d0baf79c7123576d473f492f2dab2507d2583b8ba999c90b9cf6e837665d7300ea1be9ce1a80e9deb88fba71d051e70e4b6adfa45cda38da025ba085bf378177922a2b47e7da8da2370fd973c8727ab5a6a4cc580035e27155b40c2b529aeb7b5d8ae54d77526dd34c48d980970b867c39ac208850c6db21c8d666dc67e94ca99cae273a36fdc2e93d177b576d608f4e55a7a356fda73a51a6d26b8da4f573771731c16fe8ea33acbddd2c0ba34e4cb554ac640f9a51d76213a8a58fbe68080992792b5163c6f0c22b48eace7bb8510df155d8b52ec53e7cb050a44b21b35a8a11a53db3e783922afe74e59ec0200dd1a4eb44bfce285525e6701d0d82aa1f1e63f2b5ecbf65cae607e7095861e9ab2c2bedd0670347db924af9c653067722d5f0a7099f5277465105dea6b1886de7ab31113099d402b4086b3b2c36deb9aa417010a030e07b6359877ced62a9e09df704290e78c772554e6e20026df136d7db531fb7b89fe012c38d9dcc5a10ea4c8794e40d53a968569399db621f881b6db472d5f6674c04f6eab4e0f28a1796b8fb4bc336d5c40a39d6f96f8010003629406de950c6a8dfb319a9fa6424677fccbc68eaf7a4c3ce003037f9b3b122acd9f3d674b1df6586c4d31425e179f5d465ca53f0536c427fc1f301057bf2afff543a566f66ebf7074196825fd8be06692c2a54841a7662faf469d33a0dd6ecc7f84af2f9c18e3ff8e2fb61bdbec35f1fcdba835408467d1a45fa0e281e1682285a4f809f0a791fa9ee78b2d27e49658ec3b116e8781b9fa378950f73f1962ada059c8065e03e5418f8178d1099f711758874236d0ea0a6dff0990d0701f581b4b0476723c8e5dcef8ff0481e22e039d06f725bcc8f2b3e921c8bb3e58dfc9e809d038f708bcf23a8f5e78abc5bf4a4a84fc926b162a5d3eb71b96b52cae63fa5f9196f711cfad7ef9a9b981f73ceb7c849ab609603cfa09d47aed96a3250478ce6fa89252bbc838497e5b69ef6b73d2164f34773ddc00d30a841ee483dacc152079aa8d5d776106a6672e855e6cd54ad025b46333ae34fec2d41d8b8db62080f3be0541a52f8e40dbfac78f92e9040b13d69c6b94a29c37af54683d7bd76e1ad5c5cfad66f232fd6b7444476ef0f8708ce175e54c8a4e0af36d861c6b5be6b966611e15702fb02d0d26bc9089cc642159d77509cc4d249f779286fb0173e9a1afa8f4c8754d158f521181410b396e3592371adab9ec6d87d6dc879088c355aea20c5cb2ac8c66cd6f39e019a471a61b0fa6bdd85413ed4277b891787e1333a9db3a8c02907726198dc7ba5fc6500be64f9e0abf5412fba57fa45f3d68a7da3a8df93720fc9fd28cc2742ad960c397cf09b9571c30e74d54e7ab687766a64c9cdeb479481b600081cff6147cd674e5ca99d76434c35bdc3a26680354630a5051b7f211a11f8d1283889461caf35bbef1256a96bfd3a9994e03ca2c3264fa889d079d18837f51a24c48afa9ee14ea4581acd5dbaf9973f27eb97ad981f7cf97c647e88219792a36384cec6ba859cf752b618fc1ed7ecc4433e5c9b4ee5b4de92ebce6ce35b26010c631abd36e8633d49451745e9433119a9b70a3b243f640e0d805afc1f5aa6f7859d451c3b5a3855b41eeeaea156e908ddb1b7d88931ac6998f5c5a413c6f48b51ba0e6a02451708c14103f1627b95dd07639983ea8973f2a79eaf74433bfb3f18bb73f08bb740e062931542b4f83ba93572b2357e59e25855d4920be7079fd7d444d20146c7bb6f2bc75dd5cdc029e7c6a89547ac5297b2513ecedad258c36820f9815effedbe2295a1a48b0178bc7b9b93c201ad589dd47cc50eca13d0d672dd5f2af75febf502d7ef262630391b8fbb773d89f898cde37ea916dda509bf8a8922c91c1c32993d1ea7b6487627128544b701a86dfc11307806868cf2550843dc7bf0fceec87feb929ba431695e46dca2f589e08cec3ca37438d9cc2e540ac21e5591cbb9ebca8c001c35894f3a89299ffe6b677cd54538879a60823b0155fd6a9014c5da8e354df820f09578822894827fcba89a62bf68233762cc1e095cd093c07812cfc1a70d969ca92a4667c2e868b1be24ad5d5ad1871db9caa079a9a21446fd7eaf726c4b8b208f4746cf023e4cbdfc4da6d8230b4b66acbce740da893aa384611fa90629e2ec1824a760ded70c042f9746b78147d462636aa154d8137fcf72f0cf1558bb451bd5626ab8623a61ee30f7885a7f358e3103fcf3c551491c1c43c26bc4cce8f20e72551fc068f5d27ecbbe9562b39b66865f7ebc90e17a6c9ca2d246397fe06863c527daa20a81079f7a49c4ac41699683d6009d3bc227fb32a31b824704977ea078a613212a857547751ee671483b376c83fdbf5436bc113469c6e99514688f1fa6b630f1716a6b6a5785c38a9841b27e6005e57b9c51919a3ccf2d5650ce332020af984b1cde997b42b9d421b43a157fb2a0f677b7eccdf2734acbbed924e635a6e5b0eb770c885080681ab2d7a8db14da915d75f46b1c2736f3dd21501a60ffd7bcc93ace0aee0957f815b729a80dfee2392d1d4a1cd4ca9477ab82efd0b318a38aeb7b9da7f04e9a5168ba027e2711925382002e9c76e6139c1e6d00de958182d23acdb500574aa4cfb25061bf2a76045a21fa3b03c8aac7fc09a16a4b0005fadb420f40497fe0b1e7ba705800f9b8573381231d955d5ec43d92b07a457d72e6be03a0f2564e820b2df228ffe31409dbc700b98016953247c4612dc8b109681c4b4ba8b8e73fbbbcba13a3e2682965e658815a5b7645511df92e1b437b86ea6e6a3ffd9c1cc413944411bc34fd61d163932e397d91eb02b3c935d5c51abffcec93cf0a9ede88d9ca5ca540bc8992eb3fc5981dfb45bff4ccc11d3554fb3e498f1aa0a87a419d00c101e5822280cda53310dc9eff8055143e576dd0bb12ec552e8a589cef49b9c147567dfb8e8a9375d967d077b7e1dc37601612897ecdcf4420f1a6a68c3f5bea5c527baf40869bc0c784824f0696fa281f1d2cf283b7026d107c278e05369b73b88dbd2a78bda480397edb01293b3c0aa6bcc462ffd06fe907f76174e1c4fb8a0850e1aa5d5ea2c1ffafb022da7b443746a5003d9804d25a7e7833c2648bd0229eaadc0f9f5fe525da9ee4d71d2f7ede1e37096c7c9a06f3e916c5f97a7377fd8988da1dbfd958d05893b0bab6db470750fba3fb261f25e4e457a92b31b6278d89e397d2426d22880dbaff087c96940ea9b062f530de3398152a0aba5f854a3598b8fc2efb79862c0cf8947212336159c5df511d914d5294b44496a55cd8181d506bc2f17eeea73a4a2933b7ca5b60371329ef47c83fe872d02c87220e247bccba4d2bd7ffb3b9055d1c4faef70190fd45d7158d7a1f2f119c81acad7bd5fafe3a343748380c1426c5838c14363e93613581a309140189cec29ddeb265d670047a2ccf3c96234813b76b9dcf166359084c165ee0f2361991f7a7eb9baac491e5ddae46c02f8eb3cfa8dffbcc0ece44d596da7da8594b34400358811a67012d3b224059d448bd44b07ba7c765a8aef49ba576ba8fa161a9866cb7ebef04bc3a853d71e9af3d86851470f97f1c835f5d4798c5d3a2ef88691732a9c5449557520adf4310a36e0af9409de8fe2523c37996ea8073b0a304214414bd14edc2ffe706f0228a003ccc770ef1718f609f3fda8ab51db594e1c05438f85d9af15fde4453b13d227ce64e9b74b9ae67e9bcb3bdd9bc2b8afd12809e6dbbc48d26c4fa1d38d82136394763c2d5f55ffaccd09295b80dc5e83a45bc870e2a2aa99df3306c6cc1b363339d16e412f08b568e7bf90c32ade66d4a49cc08e16b01e6f8e82492f639c1c5420363465d495b2666652606a79b7b0d3e8c6228ea64559dbc9cb00ca217d1619d7f6b9d8e2a4af35f3f4682ba5e5e762a57010282926b9850590d50c6aa279bf6a0db934590f5aed1d645a9e6204ecb86567ac6172bf481bc45e7f3dd71db45c75a855215e69f76ce9b589eb23fc918afa5647225768c2fdeb129f99f08abb8ad5066bbcff9f67072bc0c8f7eb5e4f0768f1d3b071adf0270507a77d4a5afe061c0acf1cf2f2b047d5715066d4f026ab0d75ab35751eb80a6b7ee80974f0ddb4fea799bc8810537ba38803219c7e492b79e3f2a42990472aa655e3cda5e5f6a0af66f8ade825b7f7a63a90b537846f072ebb27ca63c63c0117ab3e9e4c6f93bf65af13ed318867dd7f20f31ccbf6320b7e47c2b120751bd0d8626c66d8f66dec9c12484ef90998afa454a95282e50c2bec0e61231b2fe7353805688438af6fb20c069a9df5425dffb696813066b4106f817354c50ba4c891da7b581f966e939b396238c3429554b9fe43bc3eae502dc8cfa7efb84645a4ec8a8072411e81c2114868c7655b4051e6a03a06714989b86d206906f6f1e9b1544588b71060933ad866d75451a76706d1116736272162323d48b086f503eda24ac0dbdf49bdef15fb3d0b082ca0deb27fc2399b54f5e32739e3717429a83068bc36cf62268692b76d69ed2605dbd71da65bf680598bf6ef51e335c141d0265d6c16cf9df16d38572547f916e8e9f3fd2b671f33c335510b24891d6a457bf0a2fe978d0ecf153dee1c891a8ac6020fb9eab0512362c7504af7628dec162e08a5c893fe1859c9a18c2101825a8f5efd754a70aea9b262a0da28dd2c32de0963059dfa4e568dfc82f78f2d0da505e751a95b2ab60c5297055389fe3633a07d8954f6a78a21b7a39b35230e7f3241cc508ea430dd7062d1094538a3b9e0a951c28554a0b4a44a05a6ec4fc6c6d25e99236fd8b5126c49a4bf116589c47155ddc28cc1b8d62dfba54485ebdba67798486a1734f68b4ad65b33cab136f12a6265921af86ca84c5f4f7330d426c7c4f07112ba58224b9f7d0aead271dfd0bbe41d8d4dde7ad07687f1ca171ec3f8b68ab2de40682eca7e16b87f3a07dd7b7c3e7e40d5aee174f611c6108f3254c8f0d7c12d35aa1b6de637a30b3de44496a4ce28317f381ed80017737fdb45293445c07880acdb5766b1e361a7586012a00ad19550664854971d262ab62f6f43c244c696d6c86a780239bbcb953d72c7ab0501774294c2ab501e359422ffc6ba75a1b459ffa8d24872e3b528e319568a1d7a101db3f763dd073ea38142063a0841eaf4094d2cf27b08b26fa5130236c77bc26bbc485ba46aa78b83686f019a904ef1eb97e22fa2bb3c18eed6d8200245947786c3190e749f783dd98092091529f4e9981e400d6b32c447f3ea1f1ab0dd5880e95b23dae25e538858a5d89f11d0ab8f736fb4b9287a842c09d3c09407f33e1ee2d4735c5af7da2f7171c77c4a7fbf14ebc8f1b6744a1e1ea9eaf65c856f6fa18c510b541c4a9cb61b162557a39abf203d59c5fb9527ca998e5837a78eeec947027ed1d26995bb10cbeca61dacdcc5a5f877efaceb558af3364a36f3811f12e145f527f75347c2a34984d91161515eda9b75dd48c13324427d04492e3758a458c7843a9228f024ab10c94ddc0cb35c2199beb4720a2747195773951255c3ffe694423f1b099e5afab53fa1e63900fc3cb2fd2e13b608b5d9ebe001ee41b9f01a3ed0ca49979176eaa3f99c0b0be64dc8e494d665c51a93535d0e582c308166916ae7d243e8c9dff4921483a90b9864f7ded94bab42bf417e5007298be5f44db62acfa9dc2e9457ba697ab82676ee5a4912cfbd81ca922c364572bab2cccfad506fd054c4823f4e6cde91dfa46a711bc23352f1ac9cadb83227f56af82b1f9bb950ec7f33042289656da9f0a937170a89c0e1acdddfbda3eeb93cff4a4eea2dda5b2a6656ed2ba23fd37a424171f6457dd6bffa79eaf08a3ba3f6c14f07e5b92548c09f574bf8876170aa2bb87cc912dbba745a9068e60d77b775ea43e05563976944e78c223fac9ffb1ea788f975b1dd263b24218125e7a73d91e8726edc690b89e2d66e6456719436d250489254d1388325138e3f1157e1140f6aa4b24946085d1fd89bd32eff15199c956f037a29ac03a6b952bec14ad5d99d9aee1b59951111260723e849c43671fd2c84ecc8daa3c3be7b31285feac66e8129575c8f4cbb64e3654d6d2e9616396eebc33458b722b895a4d02ca022efc2211a48f015ed87474a4e230423f11ceb0ca06b0f61d6e4a0cffa313f4bf4374e18dc2d52a698f2479ca6ab7258ba46c0e6e33ef22f9ec7745a6a883d3c8f82a3908d2b27291d1b2d67ffcab8a671ed48564625773d766e8d19d71bfd8b9aeb5678ac5d6ea1ffed387a5e4b8954f3034172e0446e6fdf6d714a111cc95a39fd45d40f9d5a76059c5bed6e808204c563a6474f3cb8a5da4567f0967981e4d773f9cdf3617ddc19f5937af0c4ea0bd1a61341d8cef263d17cfd2db244bd83db688e38709f57cc502e99dc44323ce6a18f5ec3fec57f31d07f95af7df5a3ef46dcc74a357f1b29bd9e7891e2077695bb3f139a48f295c2947ace89c2a33f774d228a3e3cf40367ff387a6659c64ede78ae6f72e8292e305206b43d3b8ea88fda784e4db9489a45bf832c493b9b0ad551217323fd1504f544f0283d553a46b41d5794ed7b76bed05cb6ea71e26b6f1d1e514850302ba2a817d0b05f2e7dc621274f36289833dd448173bc721e44a6fbf67e430e58ef689ec62c6f26d16277b52e3ec49a1d7a0bfaf49b7b0f2ba3d7e2f7cb600a339661c5cff916e6c74f344bd2d721bbc3b03803557c2a85534d16a617b3a9e5a723e26d3540f9cc046d5e98583092de486bd550847e8616ebd89fc6713011702ea076797a4c334104dc97ead7c2c1a8a63370a0c2e6b7567bad87baa9c54cc59ae58b7feb6118deadd4ac7cff60529a74f8c69fad4f895e0e55292cee9379f0aec48c9b86b1e8504c6e88c2e0b8877c030cfecaff0c62606b46c58e21e7007419c424fe1b1bf7184aabe164cc9b391301ea4e6573a654f0163634e92aa77f02553efacf91fae2a85ac2127331a4664b81c1cc704530d787718f9f51ef25d2dbd429b3df63199d471b4e12e5b696f9c10e7d24f690bc931c15510a7205136171dec55c7cd5cf3f985f1576ff361955bbc45ae6e4d6a355a7dcddc8cccb9246136807d2440e0270b9f3e4e8826cc2e9a352e76b963bbb4f8f47c530949433ab008e8064e929f10f64632806b1ea99ebe255947ec0760937a6641cc0c56c42314a93d425d8481c56822d7fa4bf0100e9e6e7448286bb269f58eab73353ffa433a73ab164a9fda0d171a435ea2574983c99bbe2c5b513d875a9d2d1b0eb8de5146aab03294592c6b07a68892bb3ed2a35855c219114736948f15d105bd7f98bf022602e79aafe88d87d47e3072098d62d742236ae79ce04c46b46aa1a9de5864fe0192c1e0351aef0f8ab8f800934156ed27c4f0d936d76600ecd74ce74d5a673064cc6deb7770c7141771a83c69b181c7d1e67d7d951901e5d784d691459a0b2882c317fc0d8153a09c5e8916737d982b6d95a71b66c7b1b4df2bbb975349a385f03022b4ad8d91190bb3304113d55d7a8e8e41327e2623a9ea981dc13e2fefd5e924e2e19ac97fd64e62d30bd608f74adfc29eb462c0699e2e7c88867d01498d9225dee8844c7badfd4de95403af4ca6d63c06fde1fc3177eb56a71b9797c27efa0fa152fbbcb5e44be8088a4769082ef7f5849b173e8dd1d720bf4f895309c75695c116262552ffbd30a3a5193c6a62d72ea7f26b914f5e241ecdc37ac5601dcf77f989ee0d020a6739872c8c1e33d498b175cfe85035cf7d1984147c1d9f2ea0be4793c79e15099643069e9f7349eb55fa316ed6a2bd31a59c2d4ad88684db108068b37620a31af8a80c1c46bf13c0782da57d209507c77ad2b36ebc459495ddf378cccf426278248c3f7f34aa215a95b7c793cc5ac2ea5bf909c6f502f297ee0c26d96caf0a760e5932a9a0ef4b5b49b84a5aba3ae2356a56f67cddcbd52c7ea1a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
