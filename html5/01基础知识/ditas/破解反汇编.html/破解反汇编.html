<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db00f108764feafca967979925148eca9a60e6308e282b541dce13bdb0931210b3f0d604ad7b17db18c336f3938c557ff1c286179f920985d1c06b71e574ab9eee8d8754e7d454ac25854a14dd60083bcbd12ba1f9ea52bd6c7e1301b5f75ac88f71603f011f22463d9bce125191caf42afdb39c72606a69bf10f8630cd767e48e2057de1d043427227251056a7954c888ea1b79ebb229f82764c676cb4743b070785231b8853477a7e5eebb920021d386254584ec9ee95b01e65c3542f20838e21eab0f6aed9d8688bfe6fedbbabfe4942b8a8c379b364d5c748a838a16c4c059e02ab2b37cde4b5c26f79c50fd4e9108a09aab48da1ffdf8834c12552f45a5815af96fae80097c5cb6d086be8b6efbdb794ce3037ecd1b357658ab796b03c75b704c2f7e8d832bcf4defc8656595b0bcee21da33858d50feb312294a8e0e6b94d95f5cc16ee6a812227746a6d41ff8021baa6b1d135c6841caaa5ab2c93d363e11811d3aee41a87c9994d685ded0008ac3a018f839a93cf6db0c27a767ed5a221cf435991e8ac5d28563336068bca6ad2c2998c3672a9caaa6a77bc312cf229743f017cb0baa01561ddc15d765193f3f30607c52a0c7396f981d10321e52c5c5d001dfb2b39112a25f0f2e884d0df57a3998912e4aeccdd516a486b0882483db26e909f1c557b8238447a538c2b4cbbd4f3add3b7f867f5643b65308dfdbc8c0663df965d506a5ff730a2ca74f7ea51be79eb5d00c0992005f958c38d52efd5531133633d4294adbf2c09a68fbd921dcfaec1cfe6cc3d289d8d07778a6329456cf38b4988ff45ca38f025e94b135083d90a962df8a5455194a27e986526c9dbd932a993004fd1c9ef7264eeffd03c145949642b8b67ef95d32e77daadc7a6bb05f63dd854d2e256e46f47c1fab088f53d173bee86551ab1af95d7507c9cdeae80c7548220db36b163902c222e4d992db60079b50d240f9d3cf7b5c9e7c486889da8d21356cf0e8665173f7d6f37e16768448648c7cf14f3fda2dfe634d40253de9b5d23356359888f6d0fea67b3657783a5411f349481b8205bf6327fbcc56b70356e8750cd36d7fe6934f3399c5fdda0a682a6d030b056867825c85c7fd530b709606917545a15e0ccb32744786301c77c4aa6b3add4c2c0ebe22d7c4d71b9c7040495cc8fe99b6fb2ca990823a1979cb0d47abf266b31611e753176526120ca77621786d5961f23f50fd52da6642479556925aea35307a291316ff0b6e0a3b8b66fb6d4fdc859b56fd45bb823f97630a31711fd497ba09dbe04c62a87fa6dbd59dcecf93e13690d931e154554899f47a8f392b3bad2a259a756e65cc2d29f8cf02ebd75c4a97299b3a526e69a59cd297952347e26340fe2e229351845d9cecbd340a931a768326caa89c00530d26bc2419519051ff013f4e830eb29d69eb2ae51c88004931f0cb0bd19b669db9b34873b14489531518be1d925dd8fd1c8eda3f62c558853898107d18748cfe055834376c70e55939c0ee620a777416e756dfa75103af4b37ebe70a80681f1dee5a31af0d25d22fe794300b76147f93a5a1589a3dc53940045d13a26ac6dcb51c07180fdf8de3102485f4f3890f90e3a39fe41ec630af94e88f4b3dc42e5e8f4fe51c35c2362b098ea0f4b85b628777895ce99006eb2dcd7afe77b59fc1c0c682efa02aaa8a388159ed551cb2d963bed5b7a6077df0287e99bbe343860f9a45f2843e54318cb2fdfd539b77f19023824d6fe34da382bc6ddbd1e0480e5cbca6c818e49ef0a7e271f748f96484f30d64c81b868045ba8d08ec9ea1b5e95fe2604511eb53f5a44b17d6bc3e1fe351f8cab059f6d4c2d6e3e847d3202fd77a2ca3983fd8eb5aaea84878ca701920918cb058b58d6fefc1f59ebda6a77ae92148a7fa0a1d5a304722a073406e2b9b57351bca1712ce2997f4a4528ae2f3a2d2e8a401308b02e6719d5c5b99f04056277fab83587d16e4ad25d2d84771466982aab062427411ed22647bf759171c71c30a6e79b2641daafaa0a0b4721c844b8e5dbc73bd3067c0955ed13226de9b39325dc14d5813e4e0964a25bf08edabd91ae6d93def522e5e4bbe9412bb5f30eeb0982851997257d353092b7e502100859aa5ab76f65f3500d43af2a7dafef7e7d13c0c83671b27cc1ac696885798687c223a9883ad3fb96a8d589ecc3befa4697a541a502cabb22cf9c63311ad8b2cb481c3fe45522bca128033d0450b8b151f16b339ebfc69fa308df1534fc8e635d5e829c42ba4f32d7dcb75b8a630963973f35eb8cb57447bdceffb5b2df23889f294b26c591f17285c2c895600ae35ce8a55004a76752b8eec477904552aabfe4348500bfc7661ef22624cdaa10172023b04f31ee42c262ee8320c8dcefb8a01e37c339da5e3014e02c721af1677946583398a53430b85ae28dce272fe11e9725bbe71082c3c2dbee97c2ad8b8148bcc10b8c758bea6bca20bff3b65c51b00a8348671ec589e09bce8bd49792957925be03d95dc3b9e3064e67d0eea9d25cd6bc2e56c23e1bc5fd57dd424d9b09e267390725036f564a38a8290e8a0973b03788e7e6f497dea753a7b39dd2cc313b0623d64a22b7c018b1461745325d2f187b5f71098bdc6e4ddeaecf9c79b06ed45d2f1b1f6414fcc704c2860916ff1204f51ec2eae4a9bf2ae3fcf663b96b06018473950b1fbc140a82ba8563024dbabc3187df2f93ff41261f5d8682b8b245ff31780e21100a58342bcb036570d56fc6549df44b6152c9f534d2b1869ba9ed03e2027c96e8f5d2d8dabd431e9528973b2dc9f0bb98ac9a1b90ab4c40566ab11be9195e6e1a08f84aeebe23effc8e87e156728c468f096b17c6dfedfec8661214af8997acf03f6946cc5319e076d2f1b7e417f63d4ac72a4086468f901e580b61adb3966584b934ef816b9d24b15be440fdb49ca67a1a2e0931ed1305be354885c90b118a8d8e8782b6854a4142c82107ecb82aa7cc92cc1689306254dcf81a0b7d4049a5ec00b1176350d3f99edd5c892adfc7a4a5a790dd8fde29846b64e4f8ff09827657dd6821cba636c5671720fe8ff699770a512cfd7434fda5c6519deb1c79935fb004cf4f868702bca2292bbe6235a9d0a99d5efffeb135a2d8561f475cb3fe632be5f1896f4c8ac1f29256618c2c4cdbf9b6c58dcd8b3768f97145367715a1089520b3f354704210a454cfb60e5edbc3221ccb12f5ae9c1cd78732bfebbff5ac4df6fca4d4f97dd7fa38cfc968559d190a583757501d8e0a13ab8f9aa27c3caa8347f19eeef9754e691ba97bf24da4a0500b5b090014d80240c7b4c68a836f2bf8aa87695f79cb475481160d8611fa03593372137b973674e28a784d2ae392adea3f42a9dedc045eef0a4e9639ad5ecf765c31a2b2a0f8f451d2d11a43d4d1edb814bce8f3591e9dccd5ce820f0a07730f821ae3fb1173e9c7821bcea435cff7e979ab4103866197d44706a51c7cbd560d50be52b5eedc9c897f25c20507ad8a04c34cb0e7d4d844cb6c402dacc2e1f6504ae6f1edb566d021b43f2a456c102df76646f661ece708002f2f2a6702d17702b45b0d0c75cc42f6b6858decb4e1a5cc71a9fcd2e376d64da3f7c35658f354126e2be8860a51cc0ca8c54019a034a48ed72d0fe494ac6add05d0075af267d00af1a9cebd05876ee113f7f0a5fa6942ff78c9a4da4414165bf03879a983194d30daa62990d7a14246b73a80cb38986abf17e7f7922af87f0c024aa1890a58cc390bd8b73b4c04f2668d425c7b777a0dd681fb3d29f39d3d3ba46acaa54f77ba641269fb7ecf630039dd229ef798d2ffcfcb29ead3b1bcd9f0a7cf99958b367171ec4a007664f61e35964091a8411e4342abe8b6ed1115447e2930d04cadc580a52fafb11b29050ec9e20e37ca7b38bf956b847eb4526896155db4de27e8e9edd1cdde7c88b3a85d1fd78ccad02e997bca82f58cc72023e9539d562d9b53a5c303bd4b185c2d3acf6b64ac6da000971293f0676f37f73af7e2e9102c300a45f4be00e63c10bd1f6c39195fb38dcd9181433af71da658a9449eb274ef29c53b447620528ecdc5e7f298bfaf9fd88d92b342af7e5cc8988179c3bf92173b7d965e51f2b9b7c5aac65b9be8f41d4d523746a598404fe1441ca6d0b9881a13a523210ac22634a3ae53702dfd349e652a9b5a2e6b0da1769d752ee3cefb29178aa78ac3c8d93942d44774cb552685b3ee5d1f18f38877b4743504a9a099539519a26da4d5a6d09092e36abc1f2874ad02216ac8b09c12ea1b4008cd11bb61647728ac0000cfc417c54a4b141c4434cff1d60b387bd5dc0f25d685bd0092543c4b1a27b11f11e0328055a87b02ab3b8c7cb6dd480f3146a08a0fac764215dd1ad0f854d87047aaccb5cc0907e1c433b1aa2f109c5d2bf00f4a2a50091771fc344ba379484fddc751fc4b2d8fb79190d3ea741bcbf811bdceb78b8df7ee0b038880ced6b0f419c3bc9642f2e697646ea0d396c4482e392eb59f236a0f2c672f4266cbadd8bb872f63be73ee864bdbd9966ad990007fac10aa6248945c96183c28b27d0baa1d74029f57209028ac40adf5655fa52509157a4453e3820c192be72d6037c784a7c9f1b9ff05dc02f6086776c91ff0f80d4be6768e8ea767cd303480f175dd177a41c812eef52279bc645b9ba49f1116b1b0649ef2543ffab5e9e016d985ba099f38cf3bdc35c438ae48276e4c818858286095dbdcbde96db311092f5a5469397965e41a300e88fbe0b0234742f357fa13d52abb5db292defce2e09769a1d8d8be18df3d628c90408b8e0060bfbd4ab8b211e4dc173e2120c208343ba943f33f66219f4ed376538b2ee85ef1648d146cec74473e8e8fec37ced502d026ea3a51e8b785e8929178f706a501b531b61c899b77b497a77312ea3294e9c46da6741c59807c11274abc553d9f2a52a394558162a47099ca0ac682c0c385c1d22a76f441a6c499a5e3e9936bcd420427fbab4c195048cc5c6256a2fd2eb372d5f1e36118d90102eeb514fd91e39977ea66a842d4769a703fbf90b62e50fe4cef2dd0ec6f3c062d95974010c9da93995ec2f7aa2fd96477de7aaeaf577d4c633797e69720f56b6164dfcd6d6d00410ecc0cce97b248593884d9a3887d38b1330a7c577206805dd24e74f511873d50b8a98b73a4b28469757fb8d57230170232d012446059e322f617baffd3c5d16dd5713f561527322d9502a17df7cfef508b3c0a08b7c4e1cbf4d57e51250179dc4ca7d4fd269ae6287699cafdd62c251c01261cadee8339575885d4630b94682d4017b8992cda1f5d05d5bcb75a3ec467bce5e87bb042bb0d0c0edae1f116c3a6f9b1735d6ad5930fab4ff05e2537cc5482c4a5a8fab8bc217532c73994a4da73fb7754e6184e76604952b1e6e9ee73b7bf6764d8dcb766116fdd018910583a5ea1ac17c9f0d607e05e98b8fc8801ae632b495bc28e1052710a13f29ac222871938267e5598b73b484086d8ea3506cf016295f14ccf4b993327560f5c242cda2ab3d95cd654c529ab1a5cba0e96b1d1f44df2f4589881d29f2fe8916a9346001a70e3b90731e59dc2461c70baf8380c1b6f47574b3f64867788f491f2b6032c916c3cbdd5444ebec4f7350933c302563c44d51362ec3589d8ac458889cef3e9b827c5b679a62be3a6389a8aad8f3eae8ad70566909ea5f56de7bad48bdd437c641ca158ab38ceed46aa154fd22866c14c4ff480b88ca2224f424bbc682fda423574713de8204884a61786985904d2fbd5039e3d14bf9dccd1dc078d51be6702955ca6225aa208867898fee65a194d21711286c462a76645a7b2d8b3632fb7ae780b1b4e8ede211a061191a77f5f9e4cf5d76ce6760fdcbe2be86767cd79c0da50f92ea1eaf6c45923c9045b38f3fd20a3c967f90f2ac5b34b5f2b4da25fc620f12bd5ed251ef01d6b530877c41a3bc02d5b5eac843f243eaa7e1b097bfaf259a4b0c133045f0daad95c9251977b9616a12590f31903d741e72e9139310890645fe1a1052b2c995fe940f84f8ea5127713e1cc344a3507b59c9f78ecc6d981f6f7a8368b3e00a241fc15814dbda5faa36acfb10267a9dcf8515a4f55849406d93456de418021fdc1d581d8731a52ad7cc2fa67f8365c5b9b73ef577dbf3146af91d883f028b7c8cd57d8f61b332df055af37438e9fd0542854f68379b54b15af6151ee6937f33ee7d7f997acbf8b8de96c11e2a7e35c7de7cd413b17449a0af6874ec2bf6972de585157dee52055293c47f9a5a9349d471855a1387723befff6a2a2219412c85ae2c3115a7dd99c1fbcc9aa7c109f0b1b44f07f0d8d074487fb1ff5c4a470033911649963c519985493c43adb4737fc8b9df49ed3713de43c58dc1a2625271b4ea87c82acad24cbe8ab4d7ad904cf5b3118e460d1520bf1446ff54aefd7a53e181749c49549bf9f79453077e75b0dacf228a1a15cdbb11a1f21305d13e22006260d0c2445f04ad109d5234f9f470bf3201546cc7e8afd4d0d961a403e64a0c16b353ce10a6e38f1befe9b9b1688aa1b50e8fe225894cbd01ef0cec13d56b40c896963f0d5d1c7bc79a504f3347adbeec7e964388b381a167f6f78130c2723dd86f62e11c4aa81eda3ad8635f4eb9edf30bd6b96dac3463a3dc4214950fbbad9c52c6c17ea9004e899069e5cef1f22351cac725818d7e6b065918cca3dc126b65921340c2a2a59d7022a5bddb034e66a2164c181ae7d045f5006cd07bdb51b0fe1d0dff97a048420c26f1b23354cd5d025a7517e6a1c071e2bd78a3de963f7ac47aaed192e3cacf5410c0599ac292cda962acd7bb11678cc669b1c5a11b034f9be236240a0879f33a917a30ec5f7ccced99d64c61dbd0871398b35d3028b464921d711556871e7a0165d80d8cad72285d743a2ca7666ccbc73443adb463989455dc8d42fdc687e5a5cd903d1ee71e249edcd8b021611ded86cc01e3594ac4a30816554f1c44ffec5e5350954a542aec80dbd10cbb1c601f8d03ffcf5ca48d41552a531022d565ce1c0bacd72ead90545cf53c89240456fbdd0d01c102043fba2ccd1262c6c5865084ddffc0bf96e2286c87431dece7d3eb3a76cebc8cb34cca570e6cfcc3ee9005dc89b2e02c395f40148c31d3d257655bfcfb7dee8f0110006beff6c4908f3c1cfdc2fa2d31f5eaa759038b9518a2e9f4961eb646f4abfebd3fa0848543bfe69a0ad2df4588249b06bd45747eaf30fa2e8a2c9d6d5ceaec1fe106db4bc65f47186522c085f9085cc068f53dffff67d1c7589e03d54778f73f36f8bf56dd7b09a61733e763dcdb2c54aa94b5a78cda41e2b6d43b1a829504ad71460f87a18798a71f62144d29e2be093bd9cee4f42f689d349e2f0f67646ad3f646f6673910d71b233dbec177ffde169a890f01fac97e8aa69e5ed7ddb1f7319f7398fe6ab029950b626b27aff480cb0f30f2f5e9b7a007165c2a0a21edc7323a166670036bc98151c3e1fa258c1389c37230c5ad9524ad19c326f2fa085aeadfc224c0e193d029ec16520312c5bf79652ad03347cb7a13551a359a15596d0ad300e1a3c844f82668ba878e8b1a6b8e48efa6bad81299b3c35c70a634f4a0060864790341a2682403649aeef3b0f0a6b9e6018366be237062cdda8c938f2d870ffcc90f818e94bff1f0be5ccf537ae3a3c3cb32889810ba449a562417e990eaf74d2644e318551117f9663b8e66189bbbd247be5ca1ed16eb4a91821d76f9d06914caa8327ace8abc121bdf51b29f9897aaab898a1a9968151d45438c3c3d66e50d22957ec98686bcb112d3737b7b0853ea1a8b2f6cb777d5ef576160520a495a9fcbd934fad6d9344ebbc76ea7cbd4b60d83ac28f0a5b41b7ecd367d67c099219dc66057c852dfc0dd81712b35fabd81b3fe16d90ef1c89c116ad33ab1cc44036907f7faba6f9684ee09563697a54037aadcaa768e3ac39bb42f8bab4537d51b43ad0420642538cc864126da1ae34d4b9bb78a410b82899cc3c8740b402ae8248519d2c42a41182cc7581d1208a9827cccf623e5a6b8366b0d3c14fa0c5b4d4395b068292693f6df09592133b96d3747018b06b79128292bca80078f359930ea7e07e95d7921f88f559339976857193ead617e81c7e72d739d3a57f7f6ed9df6081d49bb548f09bb3f625fab4eeab3b24d3c5f0352e5434df00b1a7d8e76e615bad2b70af870feab64917a8cb928f58e93c17051c178b70cdc7e3ab8ba4648824ce2441b5822cfc6c3aed3aff90a03dc73d2347ced0050d5e9e18d141eb84da7c3a870f74c4e31a72148e670d30cb94768609a628d0fcc55cceba7b060a9354641d6fd8fd10ad875f7cf340da4c326d4fb37a64ddd48499aa6f828f242bfe6bd31c767d4f5ded370c34ef90bba754da5b17e4e9b1bf81e7be7d5f5d0b1515e196cee603bb78eb1abc3fda38fbd24d0c9c9a43fdc24200278f655ae79f7e7d38a1dec07aee1a37f670ddbe13c2e9c6ccee828576e4e735e0967d2f2bd2b118cca82a4ca4c49578813a7624b73e470973573324110b4685e37b269c53e7a8fdb1c7da4d5804599452e297341fa1ba2fe36aebb1891165ace8ffd823c0971c05c004ce491af665bfb525b2adf4b62c5410b9b60cbadd97a4296099474daf99182a087f818074c61d22446ff87b35f051c34897779609ee40a69955e46d70d21792b4e3d9ec1155b2509abbdd12137a8c7cbdcd3346761b730d67b1b578c996bc886f7992f8b6f2993681165399ccf1c0ab043d035b4083812b2563f154a5a949a5ddb133b852bd1f9a4cc323fac2003bcfe2c354ed1e1f8cb21ff3eae719f0c37e475d43d189d3eba49d9e662964898b93704bf76f0259225afa77dfd2d9b3e6700f1f3d76301cb2d74eb56831d922c68ef0a62cd242faeeec77ae8a7d415a887fe61af75b80975e0b059eeb4ce03d07c7a805f7b0eaabdb8aaa8910a9adf395f22560077f652ad4c170176d620b1334c805159e64c7705b2cb2f52a2e1a8305d8ad7b3a637fb5e51d8bf62738477598661e0d9a9ac9789ffca8266186bd2372857c5cdf01f0a491aa7e330ccfcc644bf880819744a078998b1f354b9aa42324b6235227a95df8a095e60498688630a792f65e92ef35950bd0fb414aac63610a760ee9efc11f50ee8f0aad45b7f50a5b716c5fe7d9cf4cffab8f6c15a78137682faa4dc6dbe62ee3b13a7d757fb0704b5bcbb0f2f6b3a07aef728091ab42b944e322eaaf38a6db1bb41c674ad9de23dcf7e8d95aa74a77e0a860da6acc662e4bec1f67804751c794aa8a99b4aefd982df4abda9c7c174e66cfa4dea0b11c3c4ca23184a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
