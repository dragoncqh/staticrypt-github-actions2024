<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"109bd0d0e02f22243659a0e3d9e57d00e8d847f33a5edf1ce37cd6fbbd75d6c63341d9aefddedd0d91f5ab2bda910832cb29a688df08e5914c7aee2b8d60b58b16ee48c500befe5156cf21837d25e52029d0d0a1d9e937d88b01e189bcad2c0bc076ae481b1d9c55c8b580982bfd1cf67922250cf67f53344e6c7041c67572eb9aa9fe48286a912945f20d91f46a235d52c2790bd3e783fef795e5689229b0ea6361c72e7ae54de20b7c3c38846753bb755ac2d0e2adc47f1470628787af12c280a9ec03031c76ed141619a894ded1d9ebb9d33987144b156fc32d37ac17157ca02fd706a45cfefd8d837de4b4d12d0922bc8f9321a0113fd3613c3d1cf80d22a739be5d9ea10c5047617a2cf4c65af74c8386bf3fc83d557b0d2d53c26556cf986050c0c2df0d6de95befd9c8eb1214453fc1cb7412bf6c9143b21454721f53909e455bfe97dee22c1d27be05c22751586202745fa7a128cc133878b2a0a76935eb55210d5352f877573ec32559c1ed07f227fe4551be9aabc2c0534b3e85cae9176232cc4309eafb23c0244dc26c83ae45c6ebbd311032da886e169a9e4cd72b0a3767ff0180fb41bd3dc357116d0657349c391c0d5ce9f845fb83f995d7250aa07d8d60dfb07da53754d249eb35ce3df18d09bc06ca1a420230aab25d3ab5d3e3b919b723d330e8235700b2e818288b33eedcd0fee76aad059f5755f701632f908a515d5c7a674ffe08a59afad8d7a183ae71e250db3ac3c5a2b62cc97f8fa20a1161b095f34eea06271d3ca62a910865b331aac0d0ac5738c015ae068b5e42f22edda0d1a7d3b76a16721b317ba19e236d2b805c758597353e5cbe7326f6fec4f10d66d2582da9a387d0194184145157bb73e3ff2848f9c9fa500d71d04e8623b3f00538f653ea60894964df9a9bebb3da6878f7a0f266a3fe7e1fb9407a9db087b0870d30241c06e6b68550eff3583a8b40eba58283da6bfd99a37df82d5d917a1ea76b56994e49f62ed0620ddc4549d95554d1244a7c5a5167101af0b1ac7b7bd5427ef8b8b1ef27dfe19003e1477d0b6754c6ca1e3956b9d549ecaac2d11977d4ba1de4fcb67d53f479bf7c2aace502e62691ac87ae9eb61c9a47869c5a068dd31edcc31fd237b62f5374a7f445f5cafeff68e18469b649e4dc7185bfa3184747ce4f7539841b65f0099ed2c247394cfccabd6243151e478c99150e22dccd9eeb549e7af856337e7cf3f21fc1cec91cc475c9611ae4b7fc28c1b32e10921c0b46bf44a122fd7eac798e30f3e19745633cdec381c3b829499327de8917bdc6ea1b1357330ed9b846b70c86fde6e8eeb20611b7d7e3e427f1115746d4e1139f969981dcec8dd8c903b13c88493e59ee547ad0aaa2859ac02fe4568285e49940de26995b85e5a7979f01f173d22b907bee801369bf3ea93602e92a2dd7201d2921025a4825527bffed14f7114c7ff988a31754e0048e9dc31c9a36b7d74c19354ff410323e108fd0fef03d06f503cf537dbd42add651c7ea35f706a2424235ae5be21f916eef987d5e513c42b1a40a236920e2d76be4a6da18d2ab6a97df89f5c342c96a9abb27359ae13321ebe90996e6fe60d4bccbcec619899fb664b267b49f44dbbd23683cfa713d1196adba930084ce6352c9753e6ac3d2b00b35f4acae146a486519f981aee89657800493bc4352b57ec79504f62c4e772696d14d6f8f19b1e0724f08493d9db80cba5c419b2a46bfdcce2f780301cc909117dae3fb8d1458e3c9fce5f8afdbc73cd6ef18eeb767ba2123691965c06f2c8564d8b2e5d06efbfa8a93595d6cb54769af22647f9f2a64981cdbfd1f891eb6b6e00c5ed437f136087157c3198aca3d964dddf85c469c4169d6223e525dee8f354f56a4b16238f768732914507a381e2799a5109a326a1c8b94744b7848471b30b6c03b5c073d9699d549a30c7831964bfed45ea4e71d683765fde03127ffe602f680fedfe2386f4c7037c9edf03f8d7bcef847266572ec4d4497511e306a8f4715601c0b5889db5a4f6ed73ededf8297c172317d95b82a29045c95fbbd0296eff97f0823c634e7b231503f61c227f6fdff2542e05ae3732d090fbe906ba9310f2e088e27b7912a4faeadc54db73b21c6026429958f37fcd66bb770f2467f8c2d7aad6904ae2f70d942a46b12b0b22ec18edc41abe750d2f3a5ba555733cc4ab87c3f62120c899bd1a1cdc9398883cdfbb1a1aa6607e809b9e7822cf656d469e366f81d7c138c2cc30c0619a4c85ecb9c421880d74619ab7283ecdbbdae9f5a5a750d60a097c22fa5e3adf271f9ff98b516b60256d7b91b45262f1df11f5338cc66d19c0ea552d8e98f87bb913809bc4d150fe80f2f1499ccea45f9e4098d4ef7c1e3590d63d128390afc39dcb90824a5af108d2b6cdc8ab609efa60cfb8e44883357449457123fb78afa028276d5074b0e0aaa9742d1928f402c47acf43d64ae9ecb66cc1b2734158ca8986e7f68ddabecf720a5721c55df7973fa81629bff6ba907add1ba757323e358cb053ebb78ac4e773f4ae255d0ac25dde2d5a53419f7d5107500a039dffa2ea7335971cde70806b76ba73ea15daad145710515d85608ccae99caad66e7f03fdf16b12bc720cdeb4124b398103868b4b42defe17e076b452d0cf913fd7390eaf01fe2f94574438226f0d6cd2ee269c4c4bfff23f0ed9a606c6854c819ed780a19d9244d6c4eed62b0b3f76eef78d9c5030f8b2401eeaafe7d1d84767eb8e13ee776f32b66afa66af8128377fbbbdd662f6099d54e68d0453a384ea7910a5a3d85fbb9937feb9ba5704b09fb2796ee4142722d30e93419fa76e2303bacc7ae20a3f7ff9640e72ec919089fbb85ec4271ebf83b983ece2ee5e45cf0f6cfa545c63f3ec20f89fc24c5d2330d56410b2d0830386d1ef81937888bfa4fcce3f8b89632334336b7fa6d23857a3efc534522c73a43ccae6c3e3af6e3990566b0ac3db38284de7433dcf55e717d63678d0124e8e4da44a1c669ee1433fcac8b237b23240c0a496ecc86610440b858ca3875a25247127ca768f2d8dd2ed1512bbaa71163b34dbad7dc96e20e9c92eafe35c5285705574e38caf9622b1ff5b3b3003834f15a0abbf1bc6903a944648803d5a9d906a3a2890875fea26bfcaa665cfe8f7709ec66428c362a516f655ac8db33b1cc7eb17ea1789ba4f0b9e864f34a7074f41d68a7094e79064b34af8f12eeae421efa4daec244bb759da97d745498a882c6cccb4415b42ed11db359e31c6640a301372bd0be6aefcf6782470a5234b02c7a037fd0e7852991227bf657b366b177d2dba92088b0a473ad9f0e3df030a7233219b4049352bc489a200aaa09bd6745c38d55a646d4bb2b432d8662ef93838852d3cb834fedc6e6074cfa9e4228203cb91f7ca09ca4cc52d0dafae98ab4d786ea44e25e0aca89eab25ad54a8cdb01aecca6114babd5cf0b04380baec8ca3e9f6ea871422c51753167d4db4dad3fe40cc742df6c8c4c2fa709217b1b33f9827e99abf6947f7426005633c365543d54581d7e91c6a9393725a89c781dcee6a0b438599ed1e4615619a648c44e15b122fc12d25e4c4b289f4b4bca0796b108bc330f990fde733d4c8ac03920c87547ba706091db3c27bf2720de7a2bcea22dad67890eda5f7498d99a554830ce52e3557f5799deda8ec26bec27844e495b3d82ce099c17b8676a708393eb34194b7172a3e34074e91969471dcf86fb051d4ff0c633ad7d5a5dd129b17718dd50c4135706e38b796e9de5fa73abdbd9cd33bb563c165c31daf127dfb469525dc36567982560b36d37fc4cee9941f55c59496aa0d9b8e5efac50087ab18a53f5e4d06fe614e5a4aa026a5e9a916c3a0e5e4c6d904721db3f81773185b6e13535a8fe64793231c48b49ac6a3258f375ca7547295a71f377aafb03fce6bfdcc117b8b5d04a7415637f112448db73f2e7dc8fd142b93215c77b01ed3d94835c10f4a8ee0849e2e09da153f0c27d695af2214f53f1958137bb4a952e03ec370166f1dc6520f612fcf3ab3268b52412155e4777c6fc2f29b9b9ed08f219105659a71e8b82bb82991a95463cc31afef2eda5500358e633e6b0408ee3f26997355984685e48df541b88aded9be8f839aaeba322337b6507152cf40b83e8dd5b3d9ae1893e0ec112c05980eb25908bef3084887c0f3e41c89b6fae3d1782448985a422c504dd71de4e972af1667081b3edf33a13f6decd65a1c3bd60df5e74c5e4ab45de21a0c62c9a67b33bfcbd4bcaf6c962f525be8a71a8090a4c50e7976c0f66da912f65c4e53e5961020e316b2e6a5f3b9192dc268f331e8081294f5ec4ac5d5a341386294053d0112b2918b033c4b6b315dc5fc2c33f70ebf9896ebd9ce4d73623b40c96c076b8235fc5cb9331fa2c06668c510a402a90a5fe010dec754d1e03e720e478045368513add5d8649ec61cf5edaf6cc4c2e6cd57460ad901f9b3e2c158d8595658b3cb01d55c99eb1688286ae8413f484e02337a50ed9f39c06a71f7b6ea1bdea1248bc8a32252b9d39586f90600691576ff4bde7e363f12fac9531ea3c3437e79405571d760b689bd4ce6682fddedb661a764afd1cd0c61d0dfb0338d3ec4b299c6b3ee0fdf9a354ae41a43cd82f0a4eabdfb730002ce0b4103e0989f24e4946d5b553a177b8e5c322bebfeebf4d43e5a68f142f69e97cc8997ee027c39ae80898cd71fc400042bc07696a143424df403b13c17bb00d96c76523fdcda3e892de204d01e7fc87062d2c39b67b61137b26ca57a20ff94b9b56812ef3d60f86a123275ce24f29bdb85d6671f1f18986b744c69d9c79f0142fb6acd87fdb2f5c3cab78ff0c1581ff6f0bfaa780512d77a05df220f0823537c0f14f36042639764ffbb9e5e5a0d317e303fb5eff3e5d62504909b3cb42d77a28e174172f741f325cc1764fb599410a5ecae3dd758f44ac2ed40f4a9f350658c2192db0bce19393d0d046e5c4905fe2d9bf20a9eb445ba55695cfba25fc53dd0391b178d99bdd673c45e828219add6015b9a01a32ef623aa5cc1defbcc0181ad2596dec45d952b52545d63bd7bb6281ab58f0c755e31a49ec5a0d0adea4a6659a6102b1c0ef49b3b41a77bb04b5149293888f707134edb2411baed0899fcf9290806371674b078a09f0fc991ddcd437e25a69c5943082e93ee51994e5a5010ff636126f5f0e6a760effd52cbb51c015f1b39785af3d1b9c4ed4f365ebaac7632bb5d9221ea5205dbf99b8c5577ef46f1e5ea789d5b5c62afca737593a8c746be8600dec9651866fd9bd6837f727c5501115d9ba1c643faf9bfd13a379003ed4e8e024fcaf9d128e46a48c63899fb9c604753ac5ad62e5c7c3e19aae1d5a1f0ac9e7672b7cc35722e64872aa443d423b47ef56129a6a3d874cf1f2a93362956215b39195b83c17b9231d11b945f8f5734c99bbc0a48726b544d827cec118ea10bd0669d2dfa0fc41cb920fb7a3da8bc0001c2c9936656879191c2f721f8a8ee464f534e91baf9a5b0ff229846136beabab9d51610b1143e63b44f1654e0cc0efca3383293b960b802115308d605aff3e010c8c3cdd022620aacb4a5103bfcf6a127142dca1a2d853142df40f24a07416cf47d3f0def8ccaaf0129c8fbee6d59ec0786d25338c0b0301267c9939dadfe63acee749ebb950781c95ea0ee0b5b1ed7ed10c966cf4d23f9d1e2de6789ceed707b66e48f470a8baa0baa5dcbfa2b1f8b7547b5ab53268b92bf3330b8378b83c3640e628eb8ddca6b113dc4773bf913674238e56da15690d85df041aa901d2b03d4b6823f9c2f3b839307dc3055bc01fcdf1b936faa8d877e78493755696ce7c8eebb5a8725e2b18ad6e55c7de36432acd4096441470f328f55d374f0c639199f0de6fe1dc5f9774711c706c7cb647597d6de3d065add5b2909b70752038e8109f93238b3de7387f52602439ce29f1a0b2fb90d0bde790e1e03cf2a769622fc2b0091fa19fe62fc87e03c771081193f74df5819faa053ea3ce415f6b95fb8dee0fedda6ccc64e894ffec9d3efed795cc6dfa3a9e89ce99adcd61ec1c64b295d56bac9df7c5ca8a9934d6734c6c4abb8ef1b50545df5bcd13d2b81018b755f4f95bc134f9fb4f0ca9325b4351c1f4af4c80079c32aeac207696ce37f94eaf3cb4cb3f26e5f0360271ac6088a083a7bbc3593b40a9aba3d6df97c236528a1123548ad8a6949842b2e07e9352e5599bb26d97b5ae83a6b776c3794e5f29c65264fe82692c2ba4b2fca0fce08f68ca6615173e90c8fc804109f8b6de8211fa2b9143bd3b62371b886dbdcafba50f1c33c72393330b5d6ee10a51e6a9b153cfa393b3f4fc3d710c0240ecebdbee0c3882b61dc5764731d4e78268bcaa006cb134034dbea4277ed710b6157f0357707f2a03d8c039e52ff7a2b71a12d55437cf1c49ce7efbb0a6b9feca870545026d68ae7889adfc50f1e5144885f45611524f1dfdb26ce18249cc39e75e4d7fcdd349597aa3edcab8004508efef8971834a79075710dd1ede3246a21e70761999e339e40013d52cef147788cc8868a885ee0cf27c48ea042f8d4dc968e7561755ace76b398b4e4f9ca43ed0230243d417577ee547bea45e610670b06dbbf4a8877f52a38a8b2a5ff8aa24ae46abb0a263193aa93d13b1f6ee6a5834088e019450c03e6837b6e93bc9542905cd5e411d8af73b5842afd3775bf1be46eeabfd0ff448822e53031e530ce90c1fa6bb59f36deb68bf1fb51054f299affa953e57f2c5e27e94a6abce1002267dcfccef06a28d389ecb2f9de9f4b71cee0eaa8679786307e7c1f2b09544d8157ac2d497d98a88a9c06614cb08525ffd559b2889843c6d4d9c6ae1af53014d78025797a532fe78eb379698c96b9f8df6bf2e6d79244f27ae4fb56378ed14fcd944e9204387ca66ee4c14b7c829278ac3ee68eedf7f729b2126b48b4bc0bb5c3ce9e22dead08c3c3c852077815131051c9ef9e0532e6426ed744a61cf9a81a7311e48e75321b0b562fd3f2fde1102f451aa8195d9ae0d7abf32c8a8406bb941144cf9d208d6b1e29f10f7dcfff7a31e2c2d5a45e98299996f16bb345c08a6fed75ed8b290db584ad7e7e6bc18e58ebb9cd77ac230d5c657021db053d525043944c313ed5f9c86e172357cba72f3467d1a47e5321bc7c95053ac31cb7e5d49c191dfdb6c2a4529788c929f39f7711fd1215cd8ca948b3dd8e3cb37fa192d5b8003168ec75f3006d2b0e3e6337e5d881dbf6ce9a73cf82427f4273215a8aa9acf2c6ee2ff8b6d5ce63af0ac8a622ab2ed18d71417cdc901e5ecfb70ef4e270551ff8cec12063b5d9b39e71af756dab306ffd56364ac16c8bab1bce676e517bfb1b7120e20d6e4eea75ca24bc465f726c7f2b74a937788124615373293ed441870ec23ffc3bb6a57e05361af11b5a9096374de78ea1ba22c419a29a2c1dcab6779204596a405ee93e8e30f1ca8342bbdd4a79044435d16cc4655ad702ce78fdac4996338d180a0eee7febc01f1967bc4045eaa3f956348f0553c9e479c82d97f699d18cec71b0372430e3c042773e1fd3013575172f5b07574511b5bb9e5b794bfd1d3b3ecf108e6a384876983d771ac6e1178b100895ffe225a69c91f9e7bc587a8c1799dbbddb32dd54348bcf647780d4ac95fc4ed09ff9fff43e104d53262f03fe66d75a1587d14429298dd8cb3b2e2ef23cf35e88a836fe92d9e76a000e0757b83b0cc950e8dfabb766b62b2ac1e17371f3d52ec5cc4cb502965c19a5f1ef40f61101cbb014223e6552c12ed290720925352e56a56edd45a2fb7d663037b825a6f84667f7dea323b1e6bb0864d30be66e8ba3b45eebe7a8c8adcb3ee7e23d9251320eac416d69b07ed363853fcf62555d62d4fb1c1b5efcb06341492edece1449ac0e7501557ec54b1eee1c631c325801ee4810a8b494088c32613cae8fc0a13458b540bcba9e232e7ac55bb1a8b21a9f2dd0388c25bbd73c4fc38d7c5a6251b65148ef1cfd9b7d819606e385f0f415b2752ec63bc7a40ac6df3a14b6ab5ee91bd4ae0777fc4ddba251ea7c493c58116ce5d61792b0a02705937c7893116750834ca08800436efcabc506d972dfd70bc2ceeeac50090ceff557e00d2839075084649418cc725c15db1ec7fc9a16dc756bb3d29becbd8ba6fd03f015242dd7ec5a57da9d372f4485e5408787f79ed2bb682f4a9afe0265c1aa0dd7cd500d0dfc083c6bda786aed07e92be3dc592a65e54d47b473bac72e64d203eca2ef3968bfa3862cf66aa7698bcfbda09a7f355f357a5133067fdb5eec1f6ec012f4030cfded0b37f65828b9fbcb002078fb5297ad77fd6f4585bc8367d284b606441cec2ecfdc8d08f0a85e1311d4670dfca7dc53fc2cc183b2a11a5b10e603d4906b673266386745a26fc29eff0d59b8490264d1e30dcb9e23064ad8311b3235730053f71c76d1631d639121b90432a85130b274ecb3396bfaf7eed13e0fb433fac7157c8199829eedfa98e9ee543e71f65fbfe3c46cc4bceea0bcaa7b04c68f2c100714a233560c27bec6f846a378e9229cdf95c21654d5caa22daccf5a8e4184614d0fba4b7e828852d4c724f645a70270b13a7151be182d23fde68e749baf48ab7d7cd35b87ef5f3ae1272a781fe47cba4a84eaf528b441caf312f46bbdaacfef2d60e0a5fa007c9594896930189421f2183c07a72f2f84011a023a94b2d328f1790129ea9e71990d62be9ee9922c91fbd414da3470d31f74d285606e5f5efcbdba4b29a1601ad5b408a9aab0148f9b514ec61ee70ebf7351540c4126d60c4262e7ffbd2282d7845fe6defa3edfd13e5e82f59714d506d200c4951cc1327a693af331e49c917fa0d7df4ab40a0bf98b22f4ca0517e9931691895875c97436c66332fe63b0883fb7fa0c4878d5b1c4e9708fab2ebd6eba31d37a38bdc268dfce2aaa9b85e0bfb61c8475d193ae604d9bd06932950b0413a3f08122bb5b37598cca629e2771af3199f0cb20e0f1cc996c9d0058e5cfce262abc5d9539a829d09d0b45561c3db0daa42c2f3ef731ace8334790a091f66028a6f4c83936ef1355e0cb13435e82bd549b44ed783a47651fdff9cdf26d97f331d233dc687e7bf6a8723770faf844449be71947f1efdd35f5e5e43408c511e515e2a1666307ef88532b69b53f299103c72eae7b48e524c3c16e53bd59cab6bf04650762dbadfb9f0e11b23d0c755fbbfa270ea97adfdabc1aab9b15036c82d7e2621a9579cce65d590cd27e7372bb4f7a360c2fee2946ef22479296cd6701ad11fbf6213961245c5d5437842a2cbd336d141b13c8add6ebc1c6e1a3e1d94ae43","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
