<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb2077a4115cb269a3fd79e9e99ed7409226c96dbedf6f1f5ecedce84512f4a08147aaebf8d57ae76f5752584c8827d7ba72be5340d4a22a69557d2e0d62902635510057392597ec0ace7d4a08b96e80883c31776544b3bf337e51dbb681a22168eb29f401ebd4ba8174e5e29c85ca36e01bceeaf75ab819440fbbb626575a5e2b0cc837642854b49dd9b08688b5bbf18a76eea67eb3cc1c00d4e87160f709bf4e1e47eb51901ed6e3d459fbdf3fa29dee93148eea37d70d8964fbf6c6ca40d40562bfe3c1fac46175511750961f31b106eedbd2e3c512bd0f07d8be1c6c266613732eef3148ea7112836130803fcb7303945526ad226ad9e3f92135b0f3724e8459a96476cdf8773ce46964faa26d4ad90c0754a53a20865b66244fa2865a2466720cb3b592b4d74d228fe8962b8851f6521016e00ef61912f9c0cf83ce3f78b13d4c48cd0f5bdf7444d41c0457c7a055cad4938e1cbea11a6e412cc5870a302ffa8a791a2ef859ef6602ab5d7ffb20118a7779fa7a655fe3fc209ae70d829f4518252123e0cfbd8c39e90405b20f680d6b825ce474fd0bd6588bab048022f79875eb797728206558ac57ec0317af1cf44e15889153cddb6ead6e838c012c64eaacf4902eb7f3430cc002f81ff61561137eb337f2bc1d87f5de9e53e32c7c312fdbab9f70b7c0dd80a6c0ffb753e1c682e77473d6fc1d41c3abcc0747408fc50218ebc58ad97f1e81d1fd887eb42dfbd0f151bd80d626871bc8c773a8f29c29f80d666e99cfbc15e0a322c57efaf605bf2345531b05f0427db565700a64c7c0383c3ed787fb94c412c3fe889446577b3513263afdf7ba591f529249fbecd3f112455f7e1601324a44af34554f60a6c4aa5fb84dec1465adbf77e6a78408e3b733e34410b9454ff89a24e94c55c6fa03d9d8af0f54d96513450cba4fe6fd302bdf835882a134495b280439ecb4385baae8ad297ef5f6079f9ee6fbd674f2dfe3d8aba25caad2a2aaf4b4256cea39b9093b1cf9bef9f206846a7fdb2c7fa4a0d4e58e1f4dc362a38d73181d67b4dde1b4f0318c904a3fbfc9e7bfdc16a9c389b33363238efb85a7d99b2a180f25bda60835c9e24248253ffaff423b833b5f8e925ae95527e4cee3da9694c711c5ef2bc062deba8d7aab1304e889020eef5058db0c78ed5a61695e7b3142de2bf932b74c6bb45a05898e74472ab974fe049f85022e0fd60840799af802620dc87053fed9ed430e711f2a892511f00b01d6361333b56e7419ef49dc3143bbc5f9633fb8af198176d54b855fb6ee3a77556726f1824480e8990d3db963cb5ade7c65b1695b1d6aa1b65baab03b69b12f481722fb9cd052094881da1690debe09cdaf9b713869b5e3b3d25c973409e11719d641d53461a7465508d04c71f5f821da7ff6664e059901b6f8930e42badcf16e8bb2ebc7db1d8186664fa95b711dbad0c732e87cac8994373b87867912cabb9e500b28a01d8ab6e54e685f74121eb9a32ef905f2cb175768325c377712c14a9c0945175e9b0d94a06f74a58c73b9da767305b54e7e38ab47ccb8f14326942e7cc5edf43f59c37ca86ccbc76ec925f1553d4791a80042d7d3504189e8b8684ec528c36f52e420b38131748cb8045afef644d8061a99306e4865931e67e026782442f22892d00c82471ad098b55da9eff46bad9ea7441872df3041b3b6cef4d16bd97ac95c63fa6c6b7a4f6a1d4f7e5d8e3559033dacd06a7e904cd42eb03b278d5a42e2fa867ad8ecccd5c417990350f0cef3570be8f55df65797efb46980f924d705dc152f65d50a0a12317ef35f90ee0692ed84fbb1a6d10b30a859a71daa1b6640948cb2c134d75535601bfee056bbe0a461eda7ec71fe2b68235828bc16aa06264a8ca9580b01b3d321a3a5086b03f5d7a5f50f6f74adaea282484d8852ae2e1eeb19a4b659493096ff8c9028a64ffb76a199a312bc2f8b01dc9f23cdb38b1749967516b32783a764e48953442c0f7693d9eac6727f7d011a868556e03bf2cb4b4ae16762caf2625e8f6c7b450e118b1778f7f57e254d2e3284f9bbe2dfd1c30ee39beb94118df417928a6d01fa737ae1ff8ebbc96f3fb982f1ddd8900b4c228d47b80e0f82e8954be6dde98d38c0ef0205748794aaaa3ce02f33b4cac00e3a5bb77976a2bf7d009dfb3e1726b59a1dd49417e1ec74b5a0f55349ab7f79cfa662f668a4f428d9c09cea60f587a0a8031413dbaef8003668d2493160a5124008fca95b7636be29e4005cdc9caf23cc436dcc4c4b0f4e5a9991acd3d3ea6e54ff354b6736a5469b912072b43ba096409a6608ce5dff3b48b4edb2d4b971fdefed0f524f95aef6736db0b41382627a066c6c2988fc4cf83fa1d2275a64fbf38f9544485b865329a9e7b5fd7425a4559a61e632917e3c738adab5a71a11583b7567e80e876276f7d681eac0c616d178bac263d3c6fdbe5e3baacb36d100b880c6e130173394b8ae18ec1c6bebec0414454c8b618fd1601661a5c729e40f1c5a61906bd2bb81db8f2f1f72747477354e74369c444549bdb888d3b7c14127bf81f5bc8a91ce95e56840004b7204fbb734aceb84bf5309e996ede21f7787eddd901d694860dbfbd4c6b525c1eb5c769daf1382661bbefef057f3d85640e4a9355f764fa6d62e7a7489ae5fe1573dd50002f3e52efcf04ca486ed9df593624b4377a31bde9db2cabf7ee939b2abb50083407ae6a8d6db5552161d508b7e10f5ca8fffd44c5134eca2f13d5334dea4938329cf575c316e69d81f257a7c0465f4fcc06e89e014b7d1cc553cdb31931f95fddb6122c19cceca23d6d036aef2424dd072988358581a91c2f151e56f5041f1469c3bb65842c56d5de6516b69ccabadf5e9ea41d809c15a8a8e5e41f63a6eabbe705bf945e5788a081e7b1b297937abf2fa6a76df0f205be7b254de58ee533753fdf5a0962f7d08ca8040eaa693d403fea0634077e25a62dcd6853947f71adf50c7078554d9b64650a853368aaac21fedd8baab07131ed645f8b26cff9c6e8d03c94400798363627127ce3493e457c3f10549dad5506941df00220e8b7ae6616df39612010a4ce89ed777b4ee99b1bcc8cd52e562cfa80033223b53cfeb810ea2e6521945b683417d16d3ac94826e99dd90ceedfdc3da3b173d6259d6a452b76fe180d43fe37d5bc2fd9ceb6448e3faae81f7ae52b55a6fac1b2e33953a20d520b7deb4ede6fad5550d217a5ecc15794ff108d1cf57b1d293ac73286bed86a23963485870f802ebd96645661329c6d68d9207472edb847fa34a61a9a73ff7c7536f371c67a8370aa84333f10ecd83c6be3ce01e40d08ed5f3757db1b12f370bcdee3c612122e5a8b773976054fc05fc55a6cfa12d13ab92e1e06757edf40d27602956bff04f4f74f8a62f16b87e7b125a5333dae97fc66ceba4f5f403f5d5516d0b22b9492e873d6f2e9e8561d3f0f3631daa5120f23df6722e752e5e90b7fa7ea5c662067e128ddc5a4c9639884af556fefe8629a8aa59bc44d9848a0be95efed8a0d07117dec6fe95b13ca653d61ff00984cfe91a020ce03dded7c67fb3d932b13d1e0f8e53c0c5561e4f870d83fdb85e6189b960d6d1d77eea764818e1923f5ed8851f424b3377d4e88cd9ff07f507d30403e4134326774c6f199d46bd21317ef58b1e18095788251d23c63706c1f8d6f5c96ef1e69be9cdbc8778589919e3460c13884faa12f7258301f045e9d8cdebc2eb7523d9302514feb91d0d6d24cd6531a2a7ddbd513aa29a5c7d3aab297bed0278ca58b5811c4f6ec0610e070b47a4844ed5e8251930946c414d4af1833967a3135b55eb970fb4692e4e5e38de5ca310b6cf1875875064dc5a6ed29bf51bfde250c1e0fced15588c26a760b162470793b541055b54333789f0cb5f19bbbc31e2f0d65c5832f341ec4e9149dda2b68f5f291476243605f4c1e2147245d9452efa01672c8404b7a3576801246385e9a9f8b60c6bc8e49c5b4ecc3c0df42b99738b782fc9462a23a800f09a5a448f7d57dbfdf6cbb54b98b4f968aaa215228a6c5faec28e6c4d3b3287dab181313ad9256bec12d0c2ca17464ee7ddad3c6f42daf8518397476a6d72ec35cee7e672122998097f33fda57eee431a90d0dac35f9a99d84bd23a7803642e879fc97998986a7aae6dda5d7464141ebced713f887cd782a86041f711d28ec0c1aecfc0bc277ea2b003729e1ced2c2c8e951fa40b6bc220f8c3114cc68de2612be955c012b499ae3998cdf8caae04fdb759c00d5e3fd83cba6d4b5c161cfc3ede5f36ce704050cc313b003bbc186fa3173e718bd80e94db80de56add15d67f6a928c96560b56d820f56eee8f85e9167f818439cfc8714a2d88cbcff36067b5affef82c22c0470dbc7be7d1ad071eb11c5ad33b3dc8a4ed610f1fc33043bc6955df4f8811b4344ef057253d6602715464606d7c738242e38c7c823901b3a04ce3830a2696311994916978ccb258d7b025841042aaa0367d0e4213cb15d91c720ebc4537c5a9b4ba3316f2ec2fbcf8d20bbe2b4916f2bf1701e28d6fefc7f95f4f7341916de8531d405585fe918d79c738b7d4074d73c0e8ef1081e00098951f181b56c3f7376050529f9e9dcb839e33e91309800309ded98d4e66e5e0196d12483848fd3a0fedd68ca36981e1e738a08946a30a10cdf6c229dad4f3fc9c21a70f7d80aecd11455c964059505660b038ac1198100778bc6c37d3b52c4eed1e288aadc6134b5def6e4bb50ad7927a1a916c3aca1a28ff22fba857d4405bc101dad6a1d4a37bd7c7cead50385f6b4ee21948896f727619e02173dc652da1ea7a5a24cfc0f32745901ef71927658c9b1930536af027cf8dfbb549797b95f3b68d210252fb7f65d6df741c52534d345e5a180eb5176077f65f38eaf2223cc24e27937a0baac3362489b73787e322e2f7d17a9f67d1e0801ce630c9e5122b82ee5cc55f08c372408d1fc19c656ca4f53cbeb6d5207d147938c4aa8d40eb18d38f4d1c7be3927c2744cbe17e132374d0bc967b34e9091df83f7f822e95b6bc17ebade461a7712ce55dcd1bb1eadeaa146bda020c4dbd9b593352d9d8338b9cf7e8ae31419640a56a79470be45abe22348f9dcdcb08d61b02937575e2cfde2c829c3da9316ef18a057544a93f3451ca76d9b65b6492962c8fbea3f643bbc59de2b4eceeec7ffcf0cad0bbd8f2223ef789ec1d3f59f99b9d7f3306f2f81e60139438a4a63aa16dd5cd34ada55ffdaa84631fc653d6d8a5743f2f73930bbbc77d1ce2d3c96da5703b00b739a7bbaeb987ea45a53809230c22acc9e69b217826283673cc06b0c9fc828477d44a6af780bc5c9543f09c0da8cfcccdfa4a0e1af4329e5e4275d23524b8bc37c61e640e304e3865e984698285c97c70452fb7360b656ee1a6f89166d2bdee6c2272a98835699bb0412b65a81cf672a374d538d8d43c50ec58f92725ca1777f8b7c4dc26efa4e8766cee02a43c4d5d963676c68a009575802d7577dcae258798d3327239e02b9df18c4230e0eba891de194138e7e9d3fc908e78b0d06c417f2b11378d287bbc547c8b464f45ef6ed695b37371bd6e2bafaf1b7cc03c3a551ddd23eff2a0ff6dc5d473fdd19922ecf875c6e510999f651d550a72798ed8de67412e333b614e9f505d7827410f5125bb4383bfbebde291d29848717c5e95f18c4f7b500a30b8c919e6a0aaf88301e5d67d50e8e26c4d12de97ed68b594a03bdb6d6a2049ce0dc775e111fab4ea09f5599e6d9b380a69248396e6b8a785387b29603e5f4b52d4f1ed185570fcb40a6bc439754e0426271eee9abd37e1bc26234986a6d307952126491ce68473e9310f619bf7af7c30b4888e5226e97834433c3f9193999bd85bff09c61783e7cc5962891e660424b1abee19774402239e67c0359658da1c6951ad66d0320c14ea3fddd5327de515e968cab1cbc39460cd7ea4fe41db8666d19bf263929df8fab64b76efccb845a3cf4bc2ffb1ad007eeee62295d467d893de8f4b60ccac2b8187ec81e4492a848facfcf4dcf51f57d0e84659c7af6ddf938bbd631287f647292979b2a9dc68aea1aca8728ff16bdf5c7775c32e3ea42dff92f4336a3c44cf8761fb71d59e542385cdcf5f84efe9462c94c55aa13c3a4504bfb7370fe6f37466349eb2a7c76b04e7ffb46220f72bdf5c80f193692d2bd3a00f9e2a4b326956c6d38d14899309e69eaefdcd18f9968decb89e4f08ce0838f0e4e197b2303378f98052c9b53407cb754ee3e8fbcd7c11f9469df923ae91b78f5181955b998c62ea1c5ce45b5e5449c5647051137a26a5d86a655c76a729b47aec51c4cb35e3cb01bc8e0af50af0db4e267ece20582ef1e8dd698b2a1eaeb0e1186b2691b9dc7b60315a0ef39fad1f62f12e7ab56105b647b4c5dbcda0544a9014126e35c3890c3ce02b511e9fc02417ed0f8517f50d3be7db9242d12e2765fc1c298b83cbf7e519436dd97b4ee52ce2650ab3378134f402c26a5dfc3e4f193caa9f5284877049483fc9a8e528909ae87ef78d9a206c9a6548187b0e4fe341305772791d69aeb0f63cec44044b37bdbec701659f8982571fdd58429d28ae5b3fd1957764c698db0b61230fee5ca36a8327c0e4079dc43d293a53d908797820b6217166f610da75e9dd8ee6a0a0035a0e49a478249edf047a4893e83783bb97c1715cd325d7c4906251be05bc69d038b5cf5e926f8f6e24919da37ddc0c4d8341a2269241c1f3fb14ab9271898b69198f606e44bdf1688eb8d0fb9852fd94892fcf4310a70c18066213c0055879557cee789006801a2cd8a03667ecde46cb3631a664ebd1d2308b834b0a33fd3c0f3708669161666f4cc92488d15a4f5acb3b632feb383a6879eefe135e7069f3e01048d24c73ca4b21403480290de913f71151b0ad90776e2bae53d9e3c6e1429441db73f4c7e16773a0f82e81fcd36de73b83ea00f22e21adbe40554afefc86bb4af506bc9867de632fb4a590044190752474a2be115cb5822e163982fd18d957c3d0336ff24da947242f0daaf395ce365356d19bc73cf6b23742c0cf7018182c7a425a0649e5c98f6e4112f5d1a7e08bb750f1af117fbd218f0b4b9b0b0bd42249a22f84962161ad6bbf36fb889e60ac84a21008a66b2aa8253c63f43e6fc0fd4a2e1cf49948638be44c4e9890df42635a14756f1a4f2fefc63fd1be9647b1a25e560cf5041233c866e35d70e62068412a0a11f838e22681754e7c451bf8e443ed474a50de70376bc451fb1f043c0da75f902ed5f3354a91e3f75ee92899aa893fdafc05a551697a8a34a5f0e9b509e228fbd9b5e7a2f896545961678b0aebbbb50f40b6c996e6db37a82365a9b9b064bf5e644a6f250935044af60a013145fafb94e12b0273f2762fed379cd18036d0fe89b1b138563d4c41761bd92d8d441f2f07008ac86633a724f6a6e2992eaaf501b55853fd1d472331f3c6327d217f1537dfa18e9dec915afd7b84b59b7baa680d2afcf0e99142d4a6afe7e4a48936b3f2d613702a9e2c095aa68a88172b42e20700501aea2034d941d87860ad7c47f0aa218a72612458cbc71bfd93c16ee5fbab5d631c8c4790ba9d3c46fe955424660529a4dd7bd1a9c2ff9c805029ab29c787711bcfd8cbb968da7e6ac94074a1cbb5411553e6065641eddb5be86a111ae82f6ff61a39feb04f23707e27a7e07fe274303454e2f6a28aa1cf3f9f28d17728e1ef39c4dc55c318c5f5555847b528a0b78c023d4fd7e0cbb64b8435e2c4d9ef34c1713cc7db7f9bb763c084bd2c391383247ec5f7b57f33ba249a0afa3b7d4e5c7a2f9e3241c333638736b576756d99c260ae254840bdb136f2e09983d94f70206350003c85356515c76426b412ebc52213ccdae5be45f57e7cbe0d084cfa3f66899bda486f11bf04ee7e48493d48f5d6639cfacfa2d0d7de9c2437ffbf327f3562abf8435b14af2d3e0a867c257390ba999d7fba9c1bd8e305d6a1e59b03a734a91a454ec29224c78de4a845484f7051f45f5b24f621524d0eb56efa71bbfd66e837d085b65fad3bd2cd80e1cbdc23a13fa9dde5e156c6180da0fd06ab25386f9f4698f084408d5e5b61f0fb6ffad6e4ed7d620a4799ce4f917c8962cb69b01595fe64a74aa7b97bc5080f630106d068c745aed6a5e0987363c78ab36d586605c6b5813a5ba7931c5a6b2e414bfcbce99f347d2c93aa0ef7ab6c37f199cc0a69cbe777327033c1f44203fe583017384fdea9c55a44a106f7214951e02f98253c77d5dd1a8fefe5b345dcedfba417c8bd180117bde4f7ef59a6edd04e7364db88276ccfe9821398802841829a24e7411123b763e099693f8693129bcf09472dacb0cdfaec70ff3d9bc754e03d4af6944c14f26ecb1a32eb8b3735ba8a2d1c4b6090e51ae9fa790d689ae0033cb5ff94efa4563f8bdbf6423eaf85b6229b729e4054e385bad31ede7db6f8138bd1f226daadf4ce029f9a7edbf0d3c8142ffe6837acb65a28457095226effd0a6aeaa29495dca64253fc3a277b5a1e72aa40be32d64538339b4d699cccd841f762d33b3a4425932bbb5d51890f113fa5fefe8daf790a1b6aad7ddb86b2a12983f1d8f38d8b241e3084717a1f576abeb92670efb41d2d13322a7e1626d185a1c0069bace001a92f4edd99021568bd398990afabec5e2860ef90ed451ba63269fd454fa0f71cf34d90ab10ac657e1c6b46979ed81129897d1d21c4fe0c4a90681e34d110ab0179ca2778ee5612c6a474a2de03b927ce34ab80208875577471d54b37af40fbef12ce80658a716147352633ac1ad21fe2785798c398332b6c9832348a1c09443c76402d82a2a4c1fffdebe41eec27eccb8a12efdd54201849eafb689733d43650fe6c3802764860e6f9657fe6440b91ebc750db395f34724de3b8e23e535b6b62e3e99dc3906659c8456ccaa2407dc00bf455dd79ea7be71a355bc5b4400d0a592f2f021845ef36be9777d22923a8470c89f3d25829c7ecfbae9d497bb6da9c8d4ee35397c1033e0637453dedd3e599689a8f2205dacbbec09faf4efd6d2dc62f962348de33e0556aebeb325b17235b4234ecced77d66ae683c1831267ff50550de7a4ec95328610e91384a72a538412f735961d91923ffe65b1c173f303ed630f6d42f1668aa7f5e171ec5c581fb49060226442636997a864209066ca4449f8d51dcfc939e5743a27922529a93623472b7758f000f362e18e2472c8336d70e55ec0a68810df2ef6958f238c8439d34e6b05311b6773cb4bf61025019d3b86b593ffdbacdc476dad306d9d8d52df120a42ef044147205e22c5869c6ff61742aeb559d6dc661fa830657b48b02cce9e3071e65d081397a515cec68dc441cc3ae5ec8dde167aa496c73285d0a7b3f83401ebac5a39b5f6cfffc722d107448c416a7dca944c3403354847d1aa79860b86d195179511cd3cbe27a1ac4444d7849d2f139121c45f2c684396830e8b7a6c53e98bdb7ed7dd64dd5a0271bcc592092be9f04372a40e94b615c4496d6ad48cac25f9720af338f0ddb89c2afbc624f4f46c36ac6afec69b51f86c0a342784bcccf3ed1b428df4b658883a097216e6bb58554c1391bcec87a8939182981c593d7982ec46ebc602625c89970139366203d62d5cf5738e8441301db021a8fd81f855026a85249c35167f12949926e3d45bf8425ab6e691d82eff865776e3611fea9a3aa9e4e3aaf2f02c6df2a86a202451f9a96b45ad02f26f1a03eff73d1654499976586752c4654f879e29e6950ed3f7c307d9fb576b8963bcfa0fd97cd1a32320683cf6dd28f23d731f251d02b7ec88de489c0b6097865a4faedae06a19ba8076bb1c01aa1c2ac104c610a29931e601ca5f8d6a405dd72ee8dc6568b1c01d638659e2afd1f801f10b5c27dad7b65034beda2b1a6a142f6338de79b9ea2d0ce5e42fe4d3f716dff8583bc3af6c32eaa8bc718ad9a169051ceaddf8698d380b078b21c3e78b77ca95a1ffd18c355eaf717810e7c5ea811f80004dd803e3b06cadafd2a5f78866ce038004c8147d5f16550daa54a42363e4f13525d334342159a674f55a61869ef9c495e4ee047cacebf0c19f1ab87ab2c79c7ab10c1786d4c418611a3e9e74453f6ae521edaa004f9a0769d077a0a9e6707a8707565afd9c569318247a0eab753088a4d6195972cdfb432dc6a427d3d4ba14797baafdc8b443fbbbfaf2160c10a957bdf66f2d8480dbab82ac0c71264e899446e4ce6d894f0e94b9347ad97193803a2305503403fc98e8b2abb4b2d661d88223669e6a2c10d8bbb6f05dc22c2db92128cbfd6253481c53b96a913f33f09d2531c124a8382827c6a8d09e10541f02e9730746f49f7d1ad355589e2c7ce8d7f5bce29327142fb983b2bd38598b03beb972b666fd74e44803260b45eec8e1b93491470f3b0272a58378adbe549cfee6a4500bbfda434bcf4042fc819a4df37cdb1de849938ef00fed04e976d1dc188f64452674554845080b3ff8270c8b2e4e32ba8922aaa2fa121683a69a7644d2703579d58864ef1bf87787d5775f79adb0ec49e54780490326ac96f217aae0ffcc060413c13c8dfead7ead19ec4cf3d094b2ed1236c9baa817f5dc5b5ae107e8c8e6675c8636c606ba325bc040f1413e78a1cf6a3891070e2f0db569a271ffdccab7a162b8249346d7f3954d7c021a84fa140f22b6642bf21884230234ff18b25c9975a459500070b1c72953ab5e08f2f99725cee4a52c7818f31a07fd240413977400a4c94b6ac69cb45300c49face688041a3d4a8fefc149efba7c24a55ce93036be64352fb38133eb167d7121ec7b852640ba6bd11275c411388383ad94f20c422e752337576c6c526ed53f90edabbe53da35ea3160abe7804aaf69ff05fbb214b5763cecbce2b92bf8786abbdd7e44dd0431ffeb2cd913804df3b9a6e799a78c97fed2cb2f8e2d92cffb4d3217a317468e0fc69fff7c5ef6b03f313ed866a95a12b9e4cacf3ceeaaf28f41747781fc2595c6fa053655835a3994e599c55a96eecc2d8f6060b81b25a9e7e22a453c49bcc8f59e7e018340185d32d2db6267e715f67f0d237733eaee73f3106e865e9493266ccf96074e57fe881a62144ec0a958b369ee3e06d0966e30ac767c60ac6601174457bbb865c78e63f9c6ec0afe47d8d4d5f19221b924ba54ac394a5e293f00d321ee986f502f5505ea0e8cc2a0fcc0b164bd16cc52c6c603f3ab30a3f2ab2c4f7d51e891442b05dae36e317344d7f333ac92ec294e7f6b4c71604106406279acfd3bd7484a8d92a89d1b4a3ea73668be67f46ee2e2ca5b635a22e73680581c12285c5ad316166e40c4515b86e83b8cef12f2a52fd6ff95909c34c70b662d7d263c76c9f74d8d332aa20189c3fab135ef8d0bc5e1c83a88f7336fa1d8570da52d060c34667b20a52e45e43635e7923c876f5bde1a2b430443a31aaddbf21b130786dd822029987b631637b1c91217f87f7ca7a5732c0651c4339c191b07303329d1ee825c6a72b79456311a4df2b294f1a62dd3cd3051d7046f28cf7cc9e75ad4acc6065ffb435d448a7f9bc8e64c05cbc001bc19147fe6b387aed21dfe894d2b427ab3fcbe4b0cb842308184879d9e7f2e3b9b500239c68789b7033c3361c1c70bb6fa86a1318804455522f28ae6cc5454f9b89d841db503b4dc24bc22547ce2bc45c92d6728d7971483461e07467b94b209e10cbc076477d184ab7f4e6e3f588940592ec6f9b86f0adfc9ffa5d653f4aec32d4fc9f404e39e2251747791cd3d52fe1a337daf21faaa2dc136df85c749a60ae5eff80904bb7c5a12f27c289cc0a47567ebfb45225b557651bd77b705f89cb0804201da51d598afc2d7a56565511d96cf8ec470fbf9bae63d48a3b1cb7eb1bda3abcbba72df2b6bb35326d1c696e84dcb6a35ea4904716ebb0a24f695f6b12e6a3f3736f0ae9a9cc24bead629564124e1b67988084b607719961d37b33ba58513ccc005c33eebf2ddac86b10872044fbdae023e88d20bb4d4aaddf80c41dda5aef30b6c9cfc2c193c36a5fd1d58415e6adb1e63a64b2c36c299ae719cf4406209fe8a43e542fc066f76dec382d9aac53a2249c9ffb872e683e86e43349df38a46f9c7eeacd4452feb1afac65f124f5860f1da54bef0168201e45f62855eb39f3d367bda306224519cb7f16d997e8bbfd54ff6fdb9c84c92c5ee3c8fc68e5bbdd68eb0c6d650c4179399e3e37b67e791937f01a3e3dc6a6fd374ff57ea22ab138a0c599dbef118245ac607a669be22e1e0b9998f9f391f08782ee961b6548c965faa9797d3a4689ae9e9791d8bafda8bc3527630097e8dc86441cd6dd6a4a2cc81d69dfe4cb02934215b53937203a4e1802235fc3987e1897cb50671fb9143a98604ba5f1f5250ea6f88d2024866aef82d3501e443e02fcf0ed034cc57bf81ad7cf81d3ebe0ff6098dc80817774a321cedc63eeb9102734eefce0da89b8b20cde229b4a0cb5761e244afb026300c9190346a5d3f8c388236b9cb549425f01c7f669aedbedc0d07bc9125c1287626bc79454167a7b464cac2eb61aa4d4aae2fb40f8f92cd1268219fcdc276b9bfbb008c2f65524296c578bc1e2e50205ce7ef64990f89b1dcf2a6f55605681c60684ef62ef52cb3a93aea7e1c282f9c888d6df2c474975f6335b8e474b7c5e104537795c182e998fa12c678e49406ee57f315eb708e0f53abf5ed9ee44180d913bb91e1659884664d4170dba0dc2f51c42f00d64be297b554d4d9bd4466badef949697a5af3761ed2324a6bb8540066e4d510fe407a70d7a090616a732e2f53e7042b68df17ab907370de0f3d4621b9e38c660d6c97b88de1b81f765b36fac516e64b8dc6b18d81a1e7d342a793be534323492743ac89fa26d9e7ce3d53a81feb426322ea87c301c7309cb931049de336137d3954104cc1b3e84cf3b636bf6051cd2967128bdf5acf63a1fe8e1ca43a588a40340a2e90b9f01dab6adbb7ecd5accb06c15567cadff9b112b081b3580fb8c21de2d862cc8710aa1f5d04895200adbe8f0712d8fd16ad18daac21fcdb8f46807ae4a5d2eea4a58edb516cb693948aba5e01258eb3322c87d44839351ba91f64663e6ac6e72e346983127f04a6601d8fbf95d19babd7bf8f686aa529f6662877ed680405796d0266de0f3c58a1dcab652673baa3d7f2f83cb43c830b2252841198da4acc94356823b303048ab6633c4c3328d5fe17356d0f608ee96bb86f723cb81f95285413f7410fd589caa805c4032a28fa06ddb6368b8af6fef8deb7e0fe0830983b3c7a8338640931690f7f67b4fa94279b78e411f556909ceaadd0d9cb25e2333a6c068807d5e9bb5dd940937531544caa19432242fdf20c8d50cb1fbec980fdd23f97169ce741c9c81c423f1a5e6d5512a93684080fdcdef7060aa521c18a652aeb9174020d38bc65ac85d3e903619a812544d0fad1bd0bb7968d62735fd5b7de8c62d2ccaf9024891873bc5d676912cba3bf195bb7a8d678d8e14e683693c6669ffcc41a5bd8cc56f0873a593dcad5b923d11cd753f59830be7556dde71d744f673e5cad2a690815720d075dd38257a5500ea7b74c69d06112087ce1512441e1e19491e1dc2a6d062a9e47171eccb46b9185fb8d5da83e1441833c40a10bc703ec9f6c29bbb9bb9882992c761400d66301bbc45462ed16b0d7384dfc66861173eb5bf8f60d4644451b9fbab8ca67e2014871fb28f5878fe68d2c334c32269598da66f15b4527ba834e0d197092249e1c31a86a668bd5203298ac0f34d09f9505fbf7b3393774df650b470a640e7c36307d9ebab6726d6a3c1e2ff0f88b42d52a41ff024a81eb49fc327abe82afe32ec444ff0e9bcd138736bca1fa7753943ca05b436902287a740a64dbdce30b193eb810d0f058a10daa90708f30d4e6df23d545fd93fdc68fc40e375736b9c067ec07e45405235d1437ad368ff9cab4da7521f0184bd07b7f6b86e5e891c402d2b0b5513ba0bd147877e9c31b9f4256f8b090f8e4803ebde3204e62619fbc95ecae25ae3350daaca89447dca21b891fef41e1ab4bf89f82803ac3cd4ebf7449faf29f2f8e301bfcc51525c143f5e94b0a8907c93adde28bf3694affc4ff48779d90b7c0d1b4545444c98d5c38e1b455a7b8cadbffdc6f246b75a59d0d412f6917b529562b150482f2ddbce7d3fff1a490237419a6f882de52814b0ad039a0a4bcf351b88f3d79e4d55e0e912a92575208a2574ee137bf39a0ef3f10f1cfc13f02c4ab8f716eb06c17b7df2be9de67cc950f7fca581fd8ba65bbd8ab1a2c876ca0a66b1da6642762cf569bb4315ca275b26c912376af2a65c40e96ce475dad9f01ed0de9e8a5b72affc9d9333d35e9eb904eddfd96002c36388e8c27d3c6698d05b17d3eb12119cd67670cd5ba10bbabb18123d3b2761b6ba9224ad2c530eda55788a1ec26da6f6c7adb838c8b3a7f9cccd6d4dc2fb0c43165aea94d922294a7b72e7e521262b0fda9341af9bea7ca98ea5fc6ce3bb583e8e3245e2ffa1e0ff4d994aec3681e32e458ee490405aacb9aa547a68daebcbd8da380cd5184ad36191dbc76fea882aa962b7fef30e19193848d162eb0449dfab7f12caa048fcd0da493e7b0e06069ef5449eac5acbcfdbb050f47bfab4ae27c28164bf02863ed24052cf450cc3f93283a9f55994ae04a820b7f00765e59dafddc04732bdd41d14343f47ff8216ad6cdb2cf11168fc7e0a7bb06fb1479f57dd5d6b7878b00e09fed538326dff37ef64702059579ceb861209a30f9e9bd308d75f78987a262b3098f0b9385a35b04c135b60828bb073a4214e1dbf06ff14c657c4a486c41973aa6e932ef7b9d0e63dfc6360efefa9f96ba580572c4d59f1d061410af8de257ab9a5c6330b2740759f0c0d9c0762459be1d2fdb731cc91881eb1a51dae645c79376cc06c4df136db800daa20dc925bbc5a699ed6454540e8b4ab331d931e0df25655bfc6fdd726ff3f31d295556816fb57dfd84c725c50214e4f886a934e359b93a0f4ae116e9911593f0adc93d65747b88bffbac366af6dbae9afc39317b4fe389f2090ac8756d51608caf750680007a22b9f340a326d127ce716c994e236637143a7e5563fb13e00814cc09c8c89f01f8381e640934096661469abad2c6bd9f7bad7659833923e56e861108f79670f33f8d5451c143a41fb6690f3e51ca0b40b061ac6235455c06bad02e6abea302411a8166d01083c160ff2e13de1663b5df7c55e96220cc79db468005e34f94b3983634c5ee5210e203f3197ccd2573b5544c9607639b6bedd1726341e333cc402bf6b6063f2bcc52ddac3e2562a806f75db4c396402233bd1358e2c3caa9e7f00df04bbad6f41d83432d9f9272fe7b92de640c32a860fd73606e9fce95001a0f368f698e1f682ce3d3efa905e340e24c4f5480a0e71d2ef0612aa6b0e1cfbda45544b02af6710c433228d81a2e6e1773287eb67ab7a6e5cfdce6dc101554f130c1b68f995bbf73d672bf3baffe542c1624ecefe82cb2c332d09015a8b12c51cb1bca3ebdce048de80551986f694582dc410fb116636e81cadde18bc4f633c08fd7a1ed279d9b251d65c3043955fc2f34dfd80f4f8a699d0768b9cc2d6e5a5ecb7126be869ccf9c993536d8bb3acf8cbe57b9e3def50a9de07fd56e65b6b4c32f5f6ab1b83ce0cf9a51d01fccd23cd890b2a8884765bf9901980323e31bc89cd26f5b28a4c6fa079f097f1f96bedb6ec544e6b0ea57ef00d344ec5aeea0196226708a0bc0c19b450fa9acca8622ca73f643a110ea316661fe036dec6fdfea0616058d20c89aa9e8ad2ee0eedb61299a431fcbfd26c40346e94caa676344f1475d00c233435deb7f0781f73e18f38633c89cdc09c45d6d8771fddf053f1db01d2c51ffe278c0766848da0266962787880951cb58e6fff47fc0a02f7d34b24af76d859052177d4bb2496854ea167191b1d729e847639976fc66710511fd4043955c36ca4d251440200942f12454eb5b7a5e9e59cc574d202089f5b7e81c154269f29ba2ec5e62aa61057a014133733415fb993c7b3eff28d20409d6a5129fe5741e8dfc96c39fd2063df67073e7c74fe4ad4dfd801fcd105d0720100eabb9b2288a665cbbfd54129c3c0282a7ae8f821e9259b30d46653589b9c9816f2d920d5569b9a4083d67437991600dd30d66104b19871bceac66f431cd24b53a43584ebfbf2a628df361cbcf92627291f1c0eeb752188b079dc92aab3e73998a83b1a05681142fc6f58c9c807c3a8b37265e61f1857505d182e65c5cdc5a6f6f995ffe6d19f3f6fe113ceaa098cbb8b6b6bad01488df1547bd2ab3853bdf1bd8411ee69be72fdb31523bedb07218271eb2b05805338ee9c472f22427f9c3bc906ad258ae5e73b2ff729f13462177f22fe1f44904082e0798aa115192d93355140bf90548e4e12f252f49becbbc3b0e1476fa8cb39bbdaefaa6076f2a588083cc73209c47b072897aa02440e5bdbf30524be1c5c5423ae5fb60dbb4bac050262b3cec1480cd1cc9ea56db908472a0ad102ee68cb2e9360f028fdd5b588d68418c98e116c13c06322bfe130a48eba1e125fa0c312f7a45f8772a1eadd466caedd9788c7203caeb99b3b74c26b3bdb2cacc2241d7bc2e8c730f7294d569196fade9efd5970c7beaf7bca15a6b4bdf175e760b8fa9006164218a4cabc14e374ae5deeeb4bfe178b132f894c14e81066b69520b73ffe9fe124d3d81d497ed0985afeee3688a03fd612484ccb29a219e341bba77ef45560cd891b06fcd4190c3068b2466171598cdc5c872160d69a892f3c87f962a5a93be40c1a7e237bfc33fc12cde39d2cd0fd20875b8292aa647b33eb04504f17d525dbab7face1cf36c882b0056b0785a2c29ef3bb120e2ada5435680003100d7e1e17ec73683220220b83919188e8e802339c19feab92d53b5beea89b2cbbc859c31662402e828d11a2cafaa360281fff32c557280dc86b0b5fd48abdbabd5893cc8c2dac593fa14e9b12001db5c1c2d0c1d06a0acb576e73e940835ba1574acf84c726b08649bbd1fe52de5c9fef749400c562779497dcbd02d7cfefc3bb135d1a00719efc827fad1ac6761a56d082ecb2bc7fb68d5fcbe91f7647e0424d494e01fe8345b18c1310b9a2bd8db718a8cdd5bd702e036f8e7af7f3fcc9b37b01f6b15d4c3bbf3a8761e7c64f9f5791b4e3b6f41c580a55a219daa1f63778b3abdea399def9ee97c182cc2f309f730f5a6df4b3aec11e379134dd18f342546a2c10d3dc946f2a13f722a1a5ed638730648f4ccaeb1f7dd2a6dcf3ab8e0296360eed30c974bf9acc4d6dae882737b7dd3d546241c389e84e97656e04bb8d7c1e181c0b72bbe1a2bf26a05017cb1be33e1195ca23afac07c652e7ebc1dc17991376f2cfdfb76d3be3ec5b475a14454597ed2a5616a3418af432ea0f17b5fe18b7667486990eb249696c226711a2d5a055de991a1491c47e6c3e26972aa70068a01febb7004f4580dddabd157f739cb5bf782a91526eda7294baedf471febcd4f44446ca0b200148594cc304a3d1b112a0e0d9ba9e80257455602ac879cf1343fbe772aea3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
