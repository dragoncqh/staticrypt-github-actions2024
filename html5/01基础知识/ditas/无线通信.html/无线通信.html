<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"693e4d6ca1537428d50b8b2d39d3065399e560564ace35a91b7bd70afed3ece5754ecefda7ecd4b747a178966bf51fb57a1887877357b32c69c2258bb6ef873cbb601c518f3d3a4b2b611e5de10d4d9872117e86acdc77f05c3102b94a124a57136655f2b63b6fb17a7bd749944f35dc2823599919226a01a7855428ee1552368aa0c9e00b05756b73dd3ecc30e70d821ca670ff486ff4afc7a727ec04dbae2ca7fb4c96cc10611ea1c50f6f76494bc587958fae195a09f3249be3fc8059de08552dec9de2cd0812f0367e574a71244290073b9884569df60326f3d208a7b864292e9e220679bcb39227c1bad4516522fadbe2891d81a9cf9ef54dbeed8d416dd39c9709cd1b4c5b1bab4cf476552806d8245ac17b27eee55ba44ce5bfccbfe2e850b0eb332d2087aa4b255e4d39c1ec124860694c25ba6aeb5faea579881f1163fa50e3c9a3a09e6bdccb2b8e1649e9a06aacf09cba0e3d9b026188f58dbdb346229db52ad78e3c47866e07d20a52de88cfd3f938800d84ff9be230b12ed38649e0c6855a3264879cefe94c69ebdff250beb29e229e5e615c2617f175d974a4b588560d6355a7920dc9e2438693dd74b2c6aa3d4b3ae29bb0502a82832a7f0bc5ed0428b434f2c990eb682b10246a99b1864f039a97f2c3d9a3713fb486035be7be12937c70dae7f8987a76d09eaa0427dd646c1894ab4bcc99583016e344900caaedec8f9d161f69541a463b0b6c8679c877fc6618e20ccbfe5261bd4e3e1f34591ad7925edbecb471d6c909ac29ffa22b960525ceac8f962aa5d6470e0fd7b5c18091176d1976dea17ff4b110d8720366cba8042a6655e62b18a021658347efd7ad07105fe4d60d45dbc8df163241c42f44ff8266abbfd7f01a96d3ad83f9d8969ab29df5fb6ed80fbc9521f1789000e5c070a4e3be1abfd0ebdf2c20e22c93d199a4fbbb46a7cbfc87cbf11bb823ba1b21e1ca076378e499d9b9f80032347ff56b0db8b2ecccf2b195dc27ef364f4cc969651d2bca9232190524b77832b6a993cde3b661a02aba7cda0326ad70a101b3634ec3c2f8b467eadcfaafb460d53b359a93ac6beeb5b5eec874ca5f38bfda610632e6f240bee9fa7f5d60f135f68922aeb05e2963c683a0afd757d01a2ee523ffa7d12f7e069e7f4bc1dad1928d7581fa0d691f7a2d786313cee232232b8225840ab88fcd69563ce1343d0a5514a8076a4ff9ca7f7fcb6fb60a500f13cf7de583115cf1dcc8a4b4c786a7e2311de2871e3de0284a0ff813a80fb176a9a005ebcd83ef6e83f468f060297eecc176e81532c0971a270920f1ef4ea536efde80b4a2beb42b24500df017d977fc610b52ea79c34cff45e7924d1f6796738d7c221a6f36481af703a6e3bb6bcebae3c210b2702011974d0e35a1b8e007a21d6b2a2fe347f2d7d2d92f683698589a05b3d82f3473ac8813a026d187e35e6728506e19fa0c3487413e1ef05b4700a7dd43187fe5b4e2049503d803d28beeb7d87e8163e2fbdcb4b410926f2fc9d4525fd9a5e32f756260f208e4660eb5414ac7615832260603d0c9d376ce4ed1712639a66fbb8d512e22f561a13319d7072157e80d987baf32bb407f7258164e2fc853c12d05c81a0a31772f3c6327677c9026012308383d7af4bb8c2f76bf70f4fcbd04776bc791c6991cc0d07fffd3a7f79242fb6bbe37e333c85bfdc340e850a9e0995cf85ed47ef51f9e13527dc4ffbc9d2702f158f0dfa0cfd68fbda5a95f3368c5ae4ce57830e539065ffa40b04edb731f09191be940c960f131a621312037f45b9ae2816b3aca0164989e89a5605ffa1fb302b6697f3ac31a1aec14aa4134347b6e2a8131b82d9dcb6ea9c2c9c2b711f1b191659c022fb4e86075683a430b609ec0fa3950d84ca8684aeaf4c596a027394bcec4eede9296032e79260e81eaaa004da27daf78273a4d0c193142dee9377587ba386f0c5a950e3fde6d9ed2a2f15d0e561b1e5a3b68a45d5681d2d282e152becbfb344fb81e1802922f407c0402295554f3a5c2b989df81ecdd41a02a769cec9dbc3d5af8e051bcc3a887269d77d981be03963fec16835ba1934ed52f36fdc43fafab838c6eca73aeac0cac8b71aaa3909d6eb589e046632a35e381e0b45242ac32eb8d4300762f49afc9ef5afd88959edf921f735011651ab2c585e22ec62a4367de41335e73d35d8914b9bd4e8419294bffb85c7c73386e163aa08ad0c288f7e26a0d63fc05ca097684d775b7a29dbdc94890e7e1ae3689efb9392d031af4b862888df65cf099ec09033464917f467f6d1adfd8366a1db534d3712712ce888664c8578a15feda32337840347507017102ffb4ad721fb16f5c61d8c11af7acee783de4e2ff6f909a8053f8c6088a8d1410170d44d73dc0e0dec554e8acc85831d06262a1a7eadda6a16ea2835a8d4361947d5bd261a7bbd644d681e2574d0a8fc295817ba214628b9f31b0b71dfbb5a03ee76310b25df214abfacc710d933bb98f3570b3a0d288c6f0681db6e62b0c94c0de422ebfef31290b6b4816af3519e0240303f957ef6c0a91446ca0c3e4fa31efe72bd5385242f7dd0f5c8ddd47649b3b61c276f9fdf55031dbf87b65b56263bc54f9d9dc019ffcbe18726606229b56219830dff4afa541e56567ee9632dc162ccd7ae80e54e1e912bc418aade60945240164969079f335be1a4f80d574b7dbb593295e04257003146cfb7528ccc1b0935f6d7e9539f065ecccf5fe5cc1f107f5778aea57cb097f87c0403b232f27db5ee33c6619f51eb4f6214b595ffbc95b96a4a6c98dc200810a1b7c1d8a318db9270ea6f7a8c0078ba3120ba73fff7f40fef68fad96d58c9a6ea177114f4fd91b586deb0107690e2ef5c8698668f8218c8cf141cc965c1e9b45ad314e6921bf0aad1e3d3c742cfc5e5997f5dd07cd995d348e8c9d75b718be5c2032f836e9d532b0a67521b022edeaffd5c2fea8d31610db291a9d52d0690a49368bfbbb44b8aad33a6ad6332bb228d882479f4828c37040cb3cb06a7e30e32091d702e2f6649977965efe21bc903eacadaf9e1157d792d91088164d887f723d39f3add8601f3f81184a4a3ca5184f6b08325b44772a973cab920b917cda3b48da2a228575b13c8957472ef79a3b6de23b4da934e64b00c91e4a5ba595e7a8c8476af48cfdb0a26f07f4eca0aa75ea123a411863c11b1ef01a83013701023fb2f23c6346c8e506ea6c7d1d9277fb90e487eb1f59e2d9df5dd120ef77edc2580c040af57ee160437d43ee70928d5a784b32392bf52a9afaa55286f43ac30c513813377d7952aedc77a2b2447fbac4bc153df1164aa239c0c1e0e0509e0a73b71db2c377f065f4b49712b5c4f4f76f0c14782233108d724211c3feab804c48002812b6990b0fc42aed1a3667fa16b12685bf319c8adcd98ff42dd6f5c5e44fee00b1a1601de0cd403fe91db19cbdc18fe5e92fc45d023851feaa297228c9c8d8c5ac8856f984555caf96d40621f0b31b29d240a668640d574e1a418b13a20b1c69a94484e25cfcd6c6bd1d138ab0e2f1d74fd2fb102057fa44206f5f9008fca3e8d886e038a71292da80240d713d303700803d952f845ceee14a03f29ecd8565924987baae4f17df1cb17556effa751c7014c61d80ceccfd5145caf4f3dbb3a20e34035d2a9cff59c0e012f23548123e00b448acead7cc3869ab68bdf56b906d9f085c8628744e1e808428dc05a2209c9c1ae9d9808db3bd13047b64c2c84387e57cffcdd91a1e32db89c907d7e6fc348047f74e0295397d4aba961f36c07fa6e337b1eba9afdd0b3b9c0f128064116ef3d2002f045fe5c83e6518fa743652253fd028e18a3ef42a5659c12fb6561bb4ff4867beea0759e5253de60249427a8e4995cb726dc08789d9d7c61a9285e5c4a75d6548d1d2d5ecaa15c93d8a92056d41bcf5e46566743500ba2541dd65ecefdce711fda6040328249bfacd34f4c4801795f0f3cb670d14fd5f74672d32847dab7ba753bacff1a662aff7e6da4f327b5e8872667388539b2cda0e329a95b14eda94f1440e65a7062556ac40a99a05c6e2b8647566cf0397b96c6a657159c5fceaf40e1f264a20b48895cae0412b88835d1df8439dcb679a06f6dee5bcaa11c4256d01ae54f7ac4cba77d81a8755eeaf0dcf347c02188c9c7f2b423bb0e7a4fcbc3b425dc5e8948c01f47db2eb0276e869896d546a6542032ab5729cb564c4292b0abee9dc884eb7680326e6b24180d38736eed8da7f125630a372cf9faac5267b83988ce4262ae6d4412936edec4553c301ca066236ae9771ad65581e501086b80c2847c81422198ff0d0cbe5399dfafae5bf8124bb919ea4437566297a6e74c5954a9d0f069818687f83a82b69fe444de722a0010967241643590fbff04be3f020f79ba0506a412194635afce898d08deefc9bbe200476efd9bc75eb046ffd3b3104c903a8f868c442236bab4cb523698835d144e230c0ed68cdf6c5c2d158d7dd4d5303d021372bc14b96922c1b4088600e1a3e42f7fd245d524e625cf5880f95ed2f2f0e621f8f409e6d8cb3f82e6a81cac4fa7ab73f0997c08cdae8c9c79689c5b2e09ecbd2d7022b35514b0c538e8df1e6dedc7e98d67a031db374226abd985bbf003fb93a21235ebdb5825b08e2824eed762aa8dc942ee7cbad5a7304f71aab6a9675cc3ff3427dbcb8a1492047beea43e250889809b6769746e2f02898a70d92170f6fcd63c6553722f10a29879ae19eabf9ef0c997ac64def66a0aeb26291315115f1a4399014c90e366d49ef1f7761e40d2478d0ddb81d573fececb3a17e02709e2dbe9dd22a392ea9bfe27134f18562f960a098387ccd8396dc0fc6fb0c8b682694aabd75655605a7f29d5e885758675be5654b401ee7c5412dc32215ae3bd4813ef3e1a724a7b5088854a67a629f9f633bde030c69d185a9b2fa252f49834914fe413e359a987fdc8cf301c5c06c01e2bf947e0e7125801baebd217b5375420d46ac0a0b668b88f3e7138636d9aac5a13b042e63fb387bdd1ed9efde6ae376d48181bb784a778171bfffd0ea301036d7f04b7cad684c06558e0887e9b85e13167dad38edb56ded4aa8f66bd37e3d55dc34d8d80e4e300d0688c4bd9b7ec6fddc3752fcde277bcf3236dd1e7fa673430190450bea952bd0628abecb58db51747a3e4165e18852f0bacb61c77c10a8efa70a5932dec9d8bfb399e89d594399013b0215db368a12db19a4d79e5e5ae22177e2dfe3ea538fb3ad3bb41a3ed8d535b940fcc3180d637629121b01287ea563a54c4aef7072f213eddeceb5aa02ffc4e4404d4cad73975647ba54ee20bbd5ed66c4f977a781f5930a5c5795dfdb89a8e5ae466644e660ad195d311f82a9b2e54564749f28da901f9fc3c968368739403ac737ad148de2a5f9d698de7b8b9c96eb82f7a720072d40fd999279f95b1fe4952e3e08f127952487271797be355490062a742e97baf1b4bb772d80552be5105abc56890d57980de8d8d885c96c5f0c63b1c57d56c558ca964a4d725116282f524212fce498ba523eda88f5644e2ff6208f39d048d9d39e51124700faf581452be118437f79d87a113bece0d9fdae6c16bacc2238c92a23abca34f4c69887243522975394398fbe1983473c7543fec5f36240f7d28404aef0404292931dda0a543163a6c50b4fcfd4c62386dd984653799a6edff7a017ac43ec8cf310e68036c9c943143d63d5819ed6881bae91e9b9da434d89f54ea3f781cd0e160c0e21e072a7a30be3e16aecbcc292ad12a27a277938744f13a404ae610fc6ddbca7aabeaf2a1db64e344703dd0d9835bf4e7ff7c2e501249ef2520671ffc027d213c6f562a21bbf5fbc922cdaab111ae462dfec0ec1a700b43276848b4bc4e02e91b53697562874a3099a91f0afaeae132b3caf222ba2d8468674a60666911bf2055bc78676bff59c40a9c9d8a919d2ec89f60afa83b01b6f557a391d189decf062532f7599ee0549e73942ef8137c4b0644f50d82ab962389f726a88d2158fd12a6b4e675608bd030ea0f0bc7d0b75d173356b5d08e2ab572437628c79f2cd6b27c994d62bfbf7c2712578987f95ee70c186ec1c970b29a45401e3cd6b10450565796345f6bc79a730c4ff91a0bc4e75a69a21deec34a4c522a49e80d2a94e67d3531b627ec2e65982c739313804f1a0a5801d76fa3c0b40f012e4b97641a217ca84751fd48b5cf3c89f5bc854b6cba73ecc0214132cebb606515af834d5c451bdc972e81e58f12e161ad630e720b1cc2a3712e0d195a10f5ffd140950ed1ce26431e12e989bb66af14c29620b04c633e30acf8ee2aa8872875ce71eb3e4788390181eee38a009f06b0cff1750d0d7b16a022a48a135e71ae2b8461647e05c330fbfee7c227ea303bcddfc665559812367b7673e3345067b87d57a7ac3588730d9c94fcabd75a6a55d957cbf1885e9f03f0a0c23c250a38e58ec2ab4c642cb16b54d182ce03632f23fa8dc45b2a95fb1abc88aee15c861095020e8ba4f860862a7d7e2d5fbab5f942831d94e2170831af3ec4f8aa7bc335314e0e9d0b11fde527ddd17cea0f022412262791020f39c54048734b86b1b86aaa1f4a49592a03f01788d3b1ffce2a429aace36033afc9e0dcc900f2b8427544c2f92e1d68c325cc934fcd4c0c8a70fc9458ee7b1d8451c6dccbf2f22ad23b46d9e460521167a0a5e67570a726163fdd08ee71283beb26383bf392311d1529606eabca55fda53e892eee5b13a77c73db0f7a8b2849cb65eda52522776fa8e794f4270848d8f0ec7b869973b6a3d3fc4adebe1881b31a2ca3a2984edf199358aa9573b75de87158a5e5be1096e7f36a01c760d1b75e6785485e611795dd6d47192f25818be2dd61096b7536f42dca6b697d4e8ceed16a57baa60eb02c145aa479adee803c596c72f095cd46e22baca7114189ada7acd0ea00b2f55c6b3f8f9ab689600cb3bd8edd4e4b73ac634f89bb86f55e9765d7fba80a9a3e6026c33f0e73a9c5f0aad4dadf366666d00929b5831e9319268e9d7e7695723a2ade396c2c3eb011bdb5d6200e023f94f81bf807b4449198af7c2c3e93df4732322b96482d8c8bea3795463ae53f954fae3107713133c8bf442082a4ddb0d31fc01121f29cc95fc7ede61f1cf58dc9080ec94520a662684f6c6074b1d4e6aff7267eb67e4272a218a9daaa5bc78075f84c10c6d8aa93f92cf6308e13e79b00d23709923ec12c8813824a439c9c517c2fe1b2009f838729717593c690518c81df89257032f9b6c36bfe4fe7a3f5754ebe89e30a2e78978691c9e277ddbd2c41409dca999ec92dc281bd78076bf77373373b29d4fa006e8a2413fe781b291216c8a68ab94db7cf04497f77406045ce27420e5c9ff964d54ba2ae697506fb4a8c886012e8ed622e68fd8f10abfc75f72e3bfe0a4a09f6b99b5ee7800b7f0905ae671bd4ac9bfdf8b3ccf0bf69e9e1ccdf394363b35db39dc418debf66ef956f8d5e6a88d5776aa945438f9446056c0e7e7d8b8b158ae9ef3353dfc911f98f1b83f963efdf27b8fc7833c5dc8264b2c3fde42a7fd7e7df5b5d1b442bf1325a21c5eab98599cfa7f53f118adc3c2ab0a3648144f852b1c61bcc6e2090ca8c7faa6b0fa9bcc48ff3a1dc7f35493ce27e9e0898937a006095cd413d823609ba3d2a19b26b102065c0bc21549d9e40b84337aabbd9ea4c56319c8cbcda2e754bf622a718ed55142729b953dc529d441b08269677825cf2625a21ed139c7fa14c1811cbf95bb3bfb590b9bf65d3e320328dd1fbb8a83a590ae1ba53a91f251b7055a3f85b22cf9e4fa269cd1407f3e13ee3f69fd8ddcd485abcc96a767af61ac12eec307fb88adda287db9dfe0655985693d78fb1746e6203c38363c814a22f429a7bfdb1d6759974877ce689b72e9f6e500742d8aa783ed444ed900d4d478887bbec881dffc9c6030a563ce18ebe34779def40a6857d6535434dccc9e597293dffbf65cdf4562b5b6422325fe6a9f5510591de2beee3f64c7bcf054d0aaba7646bf63de6f1ee10269fd0f8068f05984efa9e51d47667fac5b648acc6a903c98976a73ae81a8999f220e849ac68ebef51d72326d4e4cdb08dc98afe95de3b3111934e0e2c298e48e86c19f4293ff98a874e464141f012ca843d06df08ef3ebbb9bc83bfb1913499aa8f884b9a67f5c07dfad43302b0130f879becda69faf5d0df1adf51abb054080bd57b6db6f5399ab3788dcf3efb47872bd57ff06adb0d50ee4c7963bd1e5f630b4293d7b0b5fbd420a3952ba72b68a8b45a1a17c8e107e99e895d0de5ac0a1f04cc6cdb2c99969b8cb9fee0908889181c5076540760e80a0dd87dbdef5c9566d15c78f24aa91e903e09f8bf740d3f09ffdbe68fbe37533d4cf5aef906303bce0b0bceff4c2e4a6c0b49c44cbfd9d29ade254139d528f1128e6a86d777f0db5f72ce03b6ea5cde0eede70a67e353ae22d0bf59dc7968af747fd0f66655b710437bc0e0ddfc030a2d52dacc505a1047436c6b3168852484277b02b33ff9699df5f2027d8d15bacb9a146ca8108b1772c98e18dae9e7f3a492a7780e98b8505de6b172e041c465acc8127ec89e81f047587a05abbb65f40435099f2845b8493c57fa6c915572b3653db314446e5e240bd367b3fd10ee776a3976616301a0e30f62b0e12e9748b2e1cee1416b259d78a1b3ee596a163f53c56f3519e0e6d83fe031e68e43f9411f97df991fb9f93875656687c5b38ce8430a88475c4b2d527c4d846b3d3eb8803ec9ec37dbbcd602a2b6eb84bff495c38edbc81b196f3f9ed3ade163e71277eeb8abb3cdbea8d33a684708b1786407150ae5ffd806bf776bd8f5899dcd24247408b71a8e51873eec7e673e545e759c3cb50b473f77431332bf5117bb0a91e6ee1e8920ea71bb10dfea88a04a4f8f9f963aa89740222da8e9f2745486c44a964bc9deeae135ab8ae036d78f53ab0acfdbfa6e0e5af8760a35d58bfc9ed644e6b16da557442ab8d9309b0dc1538dbfe17d34a355694cc671eda1a786584c7f7f17bf1a056d1ba1c875acb47fa05456fdea06d7099ee86c44955e05dd9102e75468329948393f046f7a0b3d9662712a02d6d607706268bdf37f498dc2a09d841dd179f3faf51843fcc3e8a19142c7b33e581c0c866cd5ccb6d145ac50f904ee9e042ab8424ac31829a908956d0c5b0d32ca08b6b8f449780690558b79a999ae9a3852b2735c1a15f842a0673e062af766a026793d6a8d9caf7f75ed45455a6f943580754ff78e2e2d2f279b7641f4aac6ce0e266d66c7bcdfc637503196db3ce49bde6d41b58fd32d46f26a6a9e3a57ccfd6bbaad0fe9b5b4f964506564ae8ebbb40b33ba292b91c43fb82f6f749da671d3f51bbfd109fc869d4eec9259cbd70b0d431f7c466c66948a76071410d617f133a5e48c1414e56aa9bab65d1016d24228761e5db26e0a424105829af9bd79860dc25d37e9c38dca29f92441f067bc16a9b513fe6f40092abd1b3b23f0363786603e04fa9efaf404e859b6533c377ce83d8f99381c87547ceaf1173cfdfedbdcc2db42d5f67dd553df1e5abb0d840f89a9927cb5d629d5d7fcf0d9761f2d9e228f6834caf548f589f00ee206002f0197d9e9ab3f4898ee8f4891273e4b64a88e922d91d8ce6039096a2f359e9fe0cba123159d7b3913114b8e4795c824433db732c5ffcd368ddbf0cc0726dff3de90fc11e1420d8e13cf1c1a43379dc50b364cb73d7e6eda5ec7d6c255fca16b6524f627b3e4a789b6df5dee9c99dcfc19836c8aa1bcf0fd6951af42c2048516ef50e522cfac2d15fd16835c9813754953e9298f54380ee183ae59fba5c4dfaf06f3db836b0c445e6d333e178e173a82b67f7e8a9985335f9c664e5afd9c2bf61c7364623d734457cfb4bccca2d47e59e5c7e7c7882cc0146cdba44934bbd74865fe95f912d758920b99abdcf437b92ebbb5ac989d5448880fe486c7914f0b05d554e8bc4824dd0a74125a287d620cee3b841c7a082221196633555f1a8e7801cf0d2e7af82d2e36bbc211445314f86fa9b6a38f2fcdb6dab36ef3e58d9850c46ffbe70cc4972877d9d14cd0494f1ae8db7c02dead52883ce5c9599fd65ac703ea876eb0247c267cb0b6cc2d43c36957b46fcb1da98234a5af5dd7db2cf801fd0050c593fa581efbbe8483a55164b270cdea690b7a9d93a7c3a068ce723670cd73ab000829c06f321b55bf51beb9691f189b937ed08e193d185d23e7366e590425783c7fb3f526d45f4cc391de2a2d5866744b9d7c6360d942c01ddbf28a776d9677f3180bf33d42f44e63e0ccc7a2b541680a53e591bd4ee2b13316449c9a45e7ed9094fcdb993401257ce4bd0dd565c9803484c968c8c8d715f80f21913ab2c8db693790e776924460650c3ab70e34e05f8e87d21fda1d46395c0caaae2cd906e472f4772d334e3501e1fac99ba74b77a95ea3fa86ca1dc6585d1082272c7722324ef6c5a31a644d291e1af2ff5ae4c3333d8744b01f7e7a792db9602bdc22e2ef460e2945de111b7cb7e97a57490f36b836d593fa3434ef22f44f413c80f525fc680af984007f5a54606591769fdacb0ada9ae14ea24ea4291bdbdfc67d59b6875e6f7bb62062fb56e9f2fe0af1080556ff7cc719cb5cb6c6a379a397fbffe972e7649a89cca4414e2faf6339c1fe8b2a5e670d5cf6e0309054d59648b8eb64543f31466e6d58438b55cf2257557437b16de3f98f90a3f2250434ffc50fba9d34d18529325e1b811d7aef41d54ab61a6b46bff74570efcf62f16ff68291cc63f3f1b1a845d9d65976962c4465935681d3093c47e6b25e76c3c5fb2c739ff9fb44e0006c28ad203ee0d4946345069a60a77962881693dcab907c842ec8a4b1fbc13267d860ff8660da4425d634669290bc0446d7066ecb9e7656367e117eb63a1b0f23dd1af544172e457c8624dafc6a07cbf173efe8f5435de70b9d909c1c9c5f28e9e31b014296c7a31215ebc0ceaca7a7e29a8f654856ecc44f62b7da11c30be52f6500d7a7c9cb0c338423d42d38b8076ee6d4370c046a8c3f3ab7ed3d87dcb6f0ad1da9dbc95620fb16f1cb89e9b614389af1efd97eb9f4a1283d08644ef322851199baadd33cae6bb2758bdd6cd32bf2b02da05c82c6666b86f3c987a3f51efc89fc7e936467fd5a69150a0e745a8e58fad72a8238371de4d064255bace0eaf7b49f17da1e725d735504ffa7573c04c4bc95ce0d995b6d78e2bbeb65a5e6a463f7b3ad1ac1e2f2a8035b88810e9c4c097d9fab57402ceaeb2e5feae62dddb8d237c50344dd79869b7c23400338a7d72902f59ab01407665c54014bdcdc2277e73263ce40b4a356dbf15704fa6161e39fc2246338214e81bf8e07a7d6e410d7cd89f69dd97943fd39aa207286c81107a8b4853c53fe6bf9d688c8b068d30edea5ada4e552738478803e4e9ddcd0b190b9b8b08f099da2b9081c93c6fae0281120967dc24f2f612c7b0eed9befd3c24cd2fb1b055ea36ab13924ec7f20dd031eb27d8aed64deb9f1de52137d2b0380fa2ca022bb45c5b6ded7e526dac3b9bebb7468d2f81950a0369cf9a6fdf349d701542d3da02dcd5642c1fce940090ee7cdfd58c55b0e0fe59f0cf95fc04f103b59623876a0f8eeaf643d23888b667dbfb12350f2eb15dfa408216b371986e5a9cfe45763f05ee31d2387f5f6f2a9b70a00939bb0d59c994b0105424afa8688414e8b7638a1ce61d7b8e20deae93be114c92d4ebac0e8b7cd7e52b3e9dcb14aa01d6f2e4e9c77c553a7f3c7046397489aa07898b9835f954af35a7eaf022357a4c04f9484960ef087df28133da5af17b098d42d0c0581d38bfb6603d47891e378148744ad42b413b5a11ab4cb1124331aa3400cc0d45170f78e8dbec27a025e86299a9512f5a92647716f81a3ab67a0f3c00afcc1ec29e5911a0bf00b13634d53904f7d61a748de907c67e8d7b43f7d03e7dfa01fdbb3d93fc07b15c42c946ffbf94421d42e1560830250677bb0efe41a3df3554aa90339296712fddbc5ac13aeb382b9bb4ed152f60e4392025bae56a927e0b0db7eb0ffe4b837287da7c3080b1aa5597ee2f7be95c92b061dc8690427590e8120909499f77cf9a5df827cc96238ea6bdc9bfcbc41321fbcc1d7711c8cd209421f98fc05f93bf93b72ca2f74377c223843d6f7efa710e20a43191da583ca1ea59e07d090e3aadf9960e64936b849345f012a30ac76ba5c8095aeb047a09bbc81087818c88bcd5b0dc4e2f8f823ff7789b043b392633ae4a373a47817fcdc18702afb5bfb90565f53d4862174ab334d7a812fe1b40bdf2efe14454432c04eb443380a9df120eff81157990bc9577ecbffce5adc647d3e5f5cd5790b43aa2b7f12f669abd062f7f944a14e3e0c67d92bd89ded3e7c302c10aa15205d9dae6f89b7f76acfb107babbb04079dbcb04097f67c6013fb54317c77115fa8e05768dbd6e6ae70d6196e13915030d86869105609882e6c7d390ac175d9e2e6697536af4fafbcc3c7978eececcb0dd5a5a930640265047469e13d0e849bb1123472603b8c984ca90b8f636911634911ed12a35d2cb6091b204d69eb4a5f8ad6839e62873426cc38ee24d8fbc20d1004f24a9f97107a9450a62871635d85c1bc76b1ec126ed042dd4bbfe559827614249a5b02d12f045e9bfa00276eaf370df4f8732d3128f25047f2ad0ae3f4be4ca53c500af537ff8df80acdd1f1e511176a4e88bee408094323936cb99bc638a437fdd6bb99fa90d40b700ee3086ad25c5982b2353b29532db561dae13c1111e83bc15d8118240c26afb990fa2712072b09c9573ca404013969056c7f521fa3139f582d0401043fca435fe70820efb2a7876613a10020a32f8dcef92c826a80d3a07384123ce8e238d88055a3e497e65f3e9581f99c56045fc1c067f6b5c2d2552f66b1de08bbce748aacfc755ea20538dee1a2f2f373e5af0332a98ab0a475d9a3caf4d313ed2e32753234ab9740cb1278f7047b85ba3c73d6038360644cf38bb8f8ec8b8f74c72e162d21145f7f510a1167f9ffd98a1b2da07d094e8c15d7c03abd9dbd8858600cd53a7e17dd7c70f9afdf9c7bac4f482393103d5f1abbdd3b2ffd4f7d74122c3f4e50fb0994bedd1903205995574287129f9faa38010bafc3c0561c178dad2cc8e7cc1f79299fa435414b3c519305300156dbfc109201d0ee3a958962169b8adf11f9b69d75721c0dff38ea4c965be7b1a74f38a5cb5da21f8de31d73bad322a9e99c6de24872cf5f673eb3c5177bcdcc1e03301235d0609e21f661a4785a4d0f9d485bb61e69a3bcf5c06fe86fee6f1888b3bbb56de4460f3a3f6f1375f25aba400dc03d8a7323b978abbb85277459cba9ee76dbbf2fdb71bc0ea5a5982a1aa96523709ca2b201efecb5b128f55c365e01ae3fd64f0cfc45d0c69eeefb4def1ae79620ff934ce732385145248a809d3dd95d057b865dfd676d41b4d7c7f3ab9b984bd23a0ac9ed8a617443f2c4e68ba5a390ea2bc9e7e1db3a3e0afe4126afaf1a4ab3daf568a793cc43c61192f0e5cb361eb3ff3dd7c2d55ee7bfc57cd1a912f45d8091ba88bbd12911778ee0e0e71c94173445776c88675b3e9a47dad479be790d9121059806c2e0fc112345a41521cefdf9a9c94abfe1cdebef9e10b7113b84bbd60b5ae200cb6e92a9b7990f3a51497972f2cea311eed282963cd9318241863932f001432ff836b77a43626473b4adc794b59ec0370257f55a3f11095806f7c9fdeabba5d175f35ddfa072eef52a9fc5d33bfeb374015136bcd17072c96b74aa227b0106d650d637387b1d0c2ac5391684c0adfa5814f0f7d1a1cfcad6efb89bfffe494747c5c4eb24de783b05e6062c6043e3d83f8b25d170efd3617943ebc5c4f559dbc9a3dafa7daaeca62ccce729e3826395ca811b70198a04eac4ddefa2d332f7b0bf7699878b42becc0eea69ff6f66c490c1072fb5e5875e83a378c6bbb663857f7ab6806c6aabff3148bb2571edf5a8bc6bb0b119203879d748fc33d5280c9e4f594f6896d19b55f2f412b294211225ff6efa667dc2d9d1ce2aa150c23799be216b650d94a662b44c525060315375cf8531c6907e039ebd79040abcbd8bbfd44ac9f385601c29d6fc74a896a176e8d71962f8359fb27fedea7d97ca86347c619e5313abd5f00a831e4fe8efb8bc752fcce71b8f08fad220b28170314d78214ff2aa21367e7b7ce9db5bf46037c20a74d356d3e8a04010037c1d808a4f4bf70e8b0bb000a98f3651cd20a32d7f8b93597dfd8e176eb7c5ce3b4d0433060840da4c539888d5e487982371b4e9d4ba8fd4a42716518f0de53f7a5066593d9ddc89047294ed4f70b8e81d14db2fa4b59ef3439c269e30b1b5ab6b97350848823886399ba9e1a36a825e59387c61788ea236b7a5ffea60f3f5893be90bb04011f13702b0930c23c82541b3c87615c8f0c68a4d839ac5fea30426b5c0935a2f18ea6e4fd82fa70e944fe4b51c53dfbfad903082df2cfaaaacc9714d5aefba67870ef3a6b14de35f7101545589b2da012454df113d80dccb2fd3093e92791dfd446f5838a0418c0d3d459cb3b0216cf6a6bd2dc3bfd8bb46ee662f1d12e5ada33b1f9f64747da86298602fde11f0681f1cb5e5a1ad4f34b636a6fd0270b9dd496414ea6431e8196d1f3e9f1d5071e93f64df511ef6785e257834498a659c563688f80bab5e5ec9f75c9184484761099e0e230429c0f6034a795fce96b57574dcf965f46ef4d4fc508326637f8a58bcfefcac7b2744389bca6dd1e2951b346ac22d26a3b79fe81d5617f74c13775d7f689832b6f0673f978f9eb2dcfd82a57f79af45a883c77bb256f8eed37dd4801d8e0c61d55c30c866e66da1ee8f7ae0e276fb0f0f80a87ffbb5bf915e8655ebe106df1b921124d89a8219926172bbc29b3c1f20c8b04124cbdc03ab871bd11d99cb7bee7a08b4cec7afb131e9672f32653c833cd2ab3aafeb9cd438bbf1b275b0cbc2e6fa26636ffb0458677461473574edbf8349c2e2caa2bfd98e893337d5b4800220ee8bb135210f92ff28ec31bbcfcf0e17bf4e2e7db13d8541f9df79cb51b018f0689392e21d87405c2e7d9f30175674089c113172c712f088a1600993a19948e29178b881e9e04226f388e4bb4c7903e268b7e2d9f7c56059691b2f365e3f5b232834e9272f3cfbcce189ddd1c9b077dc7359989bc58bd227f1f70c08fb0c7cab7c7fc6523a1c6a7f2bd771cbb44430479d79cd317d7730af3f3f513de65de9f3c9bd36a1df847309687aba9394784b10f64f24abc547821520732ffd7c9d0553d1e51abe8b68151d8450dfbf6c0c4815544c5058049a6364495c6480b88f7f1b531e35e86d567b44d4c180acbcebfa00db847ed7885e111be31af6ef073d2db955a655876b161e3b8eadf7e71d87d166540ef0b627604f82b2e311db6db08439774f27a775fb4caf1fa7526e92c197bb2bc6585becadc09f7ad0c3fac6a0692dcdf5c15c8a2073bb935a8c6fa0a1139d865b23bc1d2af278e37b6ea36598a7b5b3ca14704ed36f7938d9e0a95f7b91ed4385665c79f717deecc2f3596cf91be8b9b6061504190380e474225ef99ab9af7186d97e746938c92012f1852b8bb9bdb3d65f2eca1ffaba4f51a052c5f8bedc69caccb10e4e00ba4559d79824d38ff23b9b1ba6e0a623fd770fc897a1c502316e7a8e3acfa3aa0932851b5c0a19db409bb9f57a98bd2deaf4de5b41436b25d93ea92e2b9592809e638d506601f72622cccf69cfe0c397acc027cb6194dc048dda0d3abf8d23dc30cafc39e2e56db2d791b6664b5a6c5d3af45650fb8d8fef8580dad8f11c11299844ac92f35f6c515642ca50fa65fa352a89cd754f1baf6d6fde0c298c2955adce59a0c6f7b5684b1a869ab18c2159bb778e175f84c454dbc0e3766bacf18b3ead03087923bb635012342201091b7c9d0b1d5e430370866be5375464b9c5b45af7c6a7f23283599deb4e3d2f662f82f1ec7a02ddd5ab2cfedba174c5eed033836b3698106009165816ce58d9746a8856d4814d2f8abce8bda436f71b87ee0228e36a54ef1aa4cc50292900d5d740edbbf743a6eccdfdc83b4af6aa14775803c61b0f27d07b8df06757297c3b3b8902e2052b039a9134d2738ccfab9c22da950ae666b6b0738b1908c857c2fb15162f96528a31d83c75195ba37eb8a4e1af5de0595244858670a33a58d4a1a3033c8d434ce2518849924287ff882bd6b86e8e10b18baf69dff433d7f9f6026831e1a0c229645071ac35c93884717ceaeaa10d68d8edec0698a2bad4f7f6b4a9fc771ef441ffe9909efd8844635ff475131a5b508ac4b6776dbc8f87aad3b5910d64e849d5ea133370c5a9a6c174a40a183f4c52599c8ac76d24c9a17d0f530f1786b53dd17f4f25d6f48f36062e306c2ad33408a4837ff849198bc9c38996e6276439563274b3e1c93da54c6980897010319960bb31b418a3aa82ef99ce3d6e2121caaea55deaf05f395b51b1225f5800f1f28eb2f921636191662d42be76a2b47466afe29a6b0797a230a2aae5159f24936051d5ce754d8f3727a038eb4672f7df51a1f483e1b1ddcd0cb679d7fe9bf77a0334ea8ebf6266066536e49defbd52cfb459d47a2ffac9a8db8bf7955b6d4bc789db5081101eebc578a7b6b4e1b6fce794a5e8a9308dc827fea2fda0b737ee43a107ea61df2e5f01f3d274b047a98440d40e968f2c97b67e391e779fc7c816b8a2fb96a036129bae53076e8eaefd803937c2c288510404f4bcd32be79a214e728849804cfef0d8b8d16424e96a648e344434dc1db459dced3b03e8c856146ee85378b26e853adc9e0d0d1e29b7d7f14931e6d6be3dad5f6ef57b43899471fff53ac95ee48b4e5cf6ad9dda4c6771caf0e1941d9630becdd224a340182403ffef2eebe673190c9e8676a44ed86a368f4441027aff87271f685cabe79129ec4def957d39d5214406981c7ef06b7847785c0a3b093c13d3bbccf09aecffa37c04dc54c59848182c9caf9d82a693575e856a29bf461ad2b1770214421c823d62065d36caea3bc1c1380799601b5f961e7999a778e88e7fc17b9fbfc426e170f102268eda51add0e493ee09a48c6d72a6754d4e896713dff893d657eaca2c827ea6de88159f2908f068de3761f865ce3a0a074e0edf52721c9124263c03f657cec4d4fe72b419f3aeb2a700859b1d58295564f66f9ce3d3d414e821ec8d92f613fe1bab4a0ed5837a746aa5cfa72d64a4e9d69ef9824d8c795be030f9e82d12552ef417f7691618aa24696152da05383027b130d233df1af8b2d9be58cbb5cef0aa1c3349a5265a1ecf78f6ca500726343ae615b8e1b43428fdfe60caa9bc810d32d00ae84f27c39f1bc1f48f27689ce9af71c1b395970de3a54c772b86a16f9fdf0bc92741dcaca36d85d0269882172d6e53aac1c5e0cfbc22ca0e15ccf10cb14067c57ac176b6f09936be35eaba85f640c226e0339f65adaac4c7230d9223f057feb1eda825f24653a6a14e7037f297555c5ae654700ae94e97c1d67c63ff3025cfb6123fd37433cf94ae39c98ec7b37a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
