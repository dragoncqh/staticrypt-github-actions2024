<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00c5aa9b96eea3f58cc79be9d3179c1b5eca9047389cbd589e93370995bc69e996432c59f9ae1fcaad8511122586b59ff9bf0195f8168043f6da65a6d611630e1868d9a8c57f44a04f071173bc5474b18b8c88c5e70722d731bbc20a62cf1cfb0345eb90d50b9c7f203a464492fe1da8bdf72a5b59cc8cb4fa863fdfa83f09c0192d388296cb142fde9eafd8b4268a6a3d06c31b49590d390655e9d3af6aeeb4447bab9772b41fccd23623e1f4689bc597feb9264a80579b7fd64647ca90e4af97bd5f76d3b79042d9f9a1794ff3818de9523f9cda87625c9110ee821074383c44d347b03869b24abdcf8b04741c3c271b5558021e20cddc403d316ab1b5c28034b5036a535c5a5d0cf8eaec0eb3834e818eb8dd644d6e143472139c11397ae4783bf3e3cd7aedec61e2a2285c972f99cb8c0e893c09e5208a81475353feed1ea9bd6ead7adfafdf7fce66c74ffc7e9b6dfd3862a1d942e9d29760deab6d2a0a0914f4d2b992be939dc2a28ddd449c34c792fba8fb3ea68b6ce02cfa365d8231477ad9055d1311d9f459ce05bf6855753d6c65dd7b4a92b38dde7e23d90b3eee5edfdabb1c0ed486bbe476539f62a5567334407909c00c41e79f0b876499f01f4b7df7deaae3c0415915da8459c4a6cf3644e69f30eaf3ddf603f3157ba20d2d0296b0192b940b64a6d05274de82e819b76dcd37e36fe9e2247d56fc947a18fa15a1557dc9b967900b0e9466088ef89d14b3b74806cf7ae0531059e39e1ac85a6a6eee79da20b45aaf2a0b5783380f206ae1fa3a3a866ce32d352c5a6278bb0b7f4f3298c2d91d5ff622773eaa819551e08c9682557a2550b04b292a79a6627db837d844e3e5a3eabb520ba85facb66cf4a23bb03e30b5567fefb89dd29755aebf153dac26a2fc7195277df37829528eaf415fb57f554b3b8bb16bfa929640bf1838bc839151d6414b5b7f29332b939514522a500f981a583b2b34ece997fdd0059fad3acabe8cf0655fc1b9a446e6932f43266979451bfa975f5d18777c2dd962c9ba52604465db5fe5ad0daba9cb11195ce1e915ef3ced266ac8509fbcdf8ffedef54e52656c3a665895db599da3f9c537c16db8e5438550bc9ec2ec5cd8fa73b127cf1f0eb6d6a3d62fdfc2b337aafd5834b199f9576ac7f8d28badbc46fab668fa3a7df3bed0b6a7e04c1fc702cc35adc0eac9cd7d8246096ef7a522d3e157ad9f95e63167be5c07b5f17ca04e266b00fe0955cf98939fe4b8d53e99f7f9c9c636ff54c089e72a06d6562be81f6145021c9e443d5f61b4457195615bcf63a6d3c97897352eb378385cb75d48cda0c5e597c9dfc87040e110d5268b996cc3c81f4af4e6ea54636ef19868ff2847cd56f7e361b3cd562a8398846ad9d3ec40d6989f186f02cbea1fc6081a9a1bffb120454a94f3af739eaba10ffebd006e1d526b6b28f51561e8253e9553cb8eb644d16f25b8249068d8e439651e0d79964635ae113657b141c29cb3b50d458c3d451a1c7548c8a111dcb19599fc5a530ff842cb73b47d9586884c8cc4a5b5c6b3366224b880f12cc22e353d867152b2db903aa7617def5bc612e9bfcdaf014be4414841faf21a52ee11b50ff232243a33982d5ec0d89aa52fa7b4be615df641b49fa7e55f4efa8693ef2a94713b96c2a1265a212fff0a509c8ad31476ac9e82ce49eb5b18dfae94134293409390944650fb580bdd948319cf237b1bfd13e5b8266bdb913d7e4ab14c68f552fcc54f1ba9b0fa1306cd0f63109bdc5fa27f9755fd953761230ada511565df17305ebc693279d241be4134de141dcf97e8c1fc2121ecd29ffb44f981917171de45ae30acd8200d8461e8d66816d44681ef90eef6d2f9065e44e1db7e40bf79a0ed655b5c38ff0919a151d73f87f8aa689da0a58c8625f6e6ab03b0d2a11b8b0dc3c734c4974b64cb136e2743b12890aa73f64ccc8c8d87999558da41a4b584cbd774c2d5decfd33662529c477e53723964da18e9a9d65e40fee02a6d020829c8a80b4f269de46b6e284616d27afcaaa89d6c8c126770e6aad9d6c4533e4a9460224423a2f2e2a4af76f051f8d22d7ae3ca909a290fd641d0b88ac8780bb17a9e0774d27edb5c025d1662b0cd458bc3a57200a1b551cd5528ee9fcf2ac22766e9ed0ada665e433eaed1b32276f1b3616273ac4ad7ac1f8764b579b526dae40d325bede3b4ad18991413098881f4a225d1d8fb909b80971490d881d076a45587e5f873ab9b8b2654dceb1b4c0d0d37c80d56879f215e893caafaf34ffaf2d86eb34eb14e63800d90ff125467fc2365fcc61ce1a1f30a89d43c64858a256b647192bec7f28628880905510df0baa7a1276bd8d101d50ce2cd1ed3f597d89a287aef79a7112831007cded719fdb66b843cf5dbc8ba900327039abd880144dac8c5473d37a34da0c61dc1c3474c89be91a33f5ffec65b7fc9b13fbbe7dd2c001f228055154f8848aceaecc5480edb6ff62150d443dba06cea166fcf568372cb10a6d97bc950e755b6914cc8716b76998280161b555071b33879d684fb3a2d6711f13baa4950029bcef5246190f3545f71a4489eb370d6d6d08b9b500845a1cb93f1aaeb08f6341e5a0ded218662d05e71bb4caf378750774bbf84b1cb9c06ba3605ebc522d3b41f91758ddfb272ab3b6a3e6792a69d0b515bc90c539d646f415ca8bae960951ea00adf6c50d2f9c439df2bc4d5d0dbc5e975928479d1402686ffb1b1eff713873753f801ef548fe7df0e73f4ac086f69dc91f5733411bb137732d771f35b60148dbbac369de0be24ed925108e9f61bbed8554a9ab16123298ea6a8624b0a4fc7beee340ce7c0b87d2bbf2879f4fd7bfb000339ce080ce9bec4578c153f3568f7873122f31c6df7e1088a99e9a714e664541e64fe59587e61c3bbde4676d06a1acdad92df063e8b35104e45aaa80242b558553e96558ac5e8f5ea84b218779e4e15a0a157fdf02f5a7b4572be54518ca929b3c88a054e2fd8e528f528946842cf120f12a034f76da53fcf40796d922513e7be282e2fdee8d4cdcf4f20aee71a2e389121de7e02b5a3c137ab2f82c153655d74914ac6b92f79dd55c78747e98f404de752f9b9d7fbeb1ad8ad5fc4c79e5140b82fdac024fd729ed3f65a6cc71348cee4f217452cfcb53b3936a94f9d1a9ca9f5d1e76c788cef0d94fa822334f73ee5634fed33883badb5c00c699c10ac0aab95cd9dc3a34b68fca5a2d2d6f59822740b5c353985a1f28956da9bebc0f2a50fcae1459b214e4e0f43062f39a72bb678226b742c29d95bb78bf818713a942cd3fa67dfa56713d3cdc06a9d7db6f331429a7073d23f14e5103893b112eee2210576aaff8d8cc07054e3476deb13669094cff54450e37fe0725ac606b79d12cba2396c7ac539423050b61a096d753e94033246a022bcac1ac684c8c56756abbd7c1bf832a320ccf85917a94ab7ce9694c1a97a4796a862097a2ecadb91c1aa6e0b76df9f762a1ec0e87864f4cc6d2f2a4bea7dcafed380b95a6db8c44450c924331a6e0d1a0d806eb4ad323ca2de757bd0e2566b009274ad8dd1b1f0460b906928682d2f70e09e8affa494a79ce25b5e20e3cd36bec9ac99dcb401f52a66ef209d112d96e34d870e515ea1157b4ea63e6b12e6b5a1c230f3a3971864b7f7c99e3f3821409b0e8ac512845b66edbce6a44642fbb17803648814fec9e1818049b9d398ac0c2354bb085dd898e2a4a1596781eea2c1da4cc48d3595397c2b9d56059635e68489cefbe16639300cedea310a8d83687abcfbd8bc75422c7ec803e4b06288e491fff3f095571756b6671aaa829c42899a72f77774f2fd147c9c069f4765102c1c539ea8c8f7372da3ad79d829e0b51712cbe62a47f3e8a718eaf3126ff380f374478cc0fd0c954ec11b0c92b8ef7f55ff1bd353fe2c7ba69b9d5d2ed15c87bc9872a937e047a5715efef41fbd79802cf0af9727512ec2f8c8469e5d1172eae9c23e9213fc8577e5dd8e43441ad797e9aea34488e44be2541c8326453830774eda93712d2b5428a8b3059e86ab557c09ee967d59e6c4e86f8345668783e6a0fda7bed7497ccef5859a135e51ad3e57badd0df869a57bbb2d96457360ef3ff1a4b5ca206703bcd28985d3ae85b17b93647a0534fd6b73bb9ae288860c744cf797b37c4e9cf553212aed6b6165bafa2b93a9d563e4c064e5742855f29ad37dd1241b2c93c0bc6ce645ba4a698aab6f57ed14ae559888135538786ded469b59252818a522a631046eda335319c026db5f1a07524af14a0e6827acda47bd324f6b71cc28854dadf3cc9db4c225205badf9b2ee26d5a2ebd0a65499c35c8ad27aecbff4093844706fd69e55cda1e862eed3378e8fc8bd72c519024a8cb8119e446a1003a6d7cc93ae3850bf77205b3082964dfc7d0ccfa3bad8075f2c7ce1ee3ff8d557b69c39a5be4623e9b15127ffe08a45a1dc98ad0248790c146e3adc251c2d1abd6ad66182a68dbaf15ef0dc1441782bf78de52ae30dcdf6d7a4640fc76f24b71e3cd6a29ba5add95a5354338b289b92b5e01d0aabee7217544f7bd224d6159b956b9c26dfd0575a4861fe93def51513df8d23109af7b1f0fbc5bbf4374978730ecba929902e8898291825a68bc7274147401c67dbea0a82199ff155575602cdd3819311c2e435e15b3f7983f8942e1fe33dc947c1e17bb4d9e29bfe6a5c516b4e7deb072e7e2b640cffd0e21c8ac3b4de53e38f2dd1d4835b9f1cd1df8d4768d2fc456eb42b6615a3f26d60e6899b4885066da95bf7e1dc1490d38c9a586aa296ab6f41347ca8f9217271a2a1f2ef2cfd93f6236b8152c2b6276d478301ee777651fd7059bb44ba17ba077fbe745bd56504642692e93fba86eb7a6bb02e0888f89a07f4397d9909fbc75ab9bd29ec9b4f5acd6438b477ef75dcc9791aec460fd7e92f42b22d4ac6d3cc9f46ddfa2712e46d4209e0495e83950998a1c8f5711099c1512533be60cde5ae03d9eb2f03df6eecdbe564ee74a26ece95c95e30957e54538f17a1ea721848e460c3aa3348748a807f760a5cf4b3c80b131db1f0b0a8c75cba659f2e3165c7b338b145e77308bc07d62e8e119154ff4076b7e69455d0528d83dbb39eb29dfa442c32bf5fe4bb97a503caa52cc94cb7b435953e0c5f458285fbc34106bb4906b9100629ced7b57076af99cf94cacdb1e94d9a83c4a223ff5bf223bdb84ac801774d1b3553e35f9fc8d202d2dce19dd0f84b9041f9ba7b7e651488df19befca7144a44b53d638b7a741d051950ce4bddc267ec35ca5067c2e52285a08b6fad91a736466b8b2e68936fd9e42d31e196086708eb1cac83b1534fcc6875a64358e811e559aeb50fc3a65f68f379171a1e5f660910cccf6578703e44d6c518c2452f9bc579b4305b87fddb3c8313e0f9844cd55d19f6fec20fd69acb3cc80f0ab57a8db5559e213d69d8d618a7cc0f3f04e4765e6eb4b84b950bd3374d0d37ff9d54ee23a448affe3854c06c95087094cb55a37ccaae054ce2f3d142978aa90db4fbd73990d007b12c102f19d9a5bb7bce203bf955ddf13592cb385f44eedebad433cd085e6bc82749a61574e0d4aeaa5f67d0d83a4d39b6fb8f4be27a07ce50a1b00834483cf9b0ff7bffe4a3ebbdfec2a93e635f0bc538ffae3c5887fb97b0d7e97659967c21f49e9bd091069afef00ac3bee3f1507e941a32d6e5a739dce3cee61ecb8b041393a59b709527266f19268e70e151de2c427e62ec2b3c42b497062c505bcf6ec075377c1c7517dd45c3f85960f411737ef346ed03e413dd35bcc91621df56d3493a9996695e0e9f747c88720146e25bb444274fd0f90dc1b294b6792584e4b52e0f1e9f3f3697469e5fe4e324936489d0a2158f3c98b3ca04a9fbcca55d59c2c12dcf0ac8c66b673ff21aacecd7d1c8bb5adee2393ad5e5c6790440a04ad49e1d6877eb829cc7902410c8f6fba2a08cee86ba11d0adc277a663dc1d3072e95de316aa10e30751fef73227e46546435b673e8196c7d49bd3d802bff3d45969f7d653a614e52e9e511a4e8fcebd0dd8ce60b645188ce7b90b8ad0b0f43dbf8bfbf0f259f7935334040da99316509f74e93e1d80d847166bea6c823f0567c95d831ce195f488f93a3f2daa74e1773dc0be0e2c5f935d9ee4d34f0fd4c7c64db8ba0390e5b9875ae4eea194abdff08b6e770d321830051c9f59efdfaabf3cd01063c91327193766be6e44056ec199235a5741cae1c79751acb0f2bc26ac3cc92a8dfee44870ce4702f5516df2dd95b889b5165aadd9079b7c1d9ba4d6a88b3df3ae8778e415a8ec8f4016c57d758ef7eb04006bf9f96b49d3b7f9b9b874a5e4729e6bbc111aa59a686e7243c3667f934d741520632c4da7cf23a5e7445509e2ecd755dacba97e5ab24261451da0635f558d39d7411613802f394ad77da3cf876f8cd93a01d73b205e348308205d2b59e2e98438491a81dc371c54452496752709f4ce7a95487fcb498c2a331bfe4055261a738b217cc8387c6aab66ce0907d062806df69ec919d9e4e01336c4e6e57e00657ba5140442d0abf9de100dcd0ea242ad2f5d64dd7f337bd2ff5b5ad3089dbfb58c8977d26304324b382e2371db2d3c1940111655ca30ffe7a2dac562565304c3dce9d4f4f6e74f0dba1cbd516485109d1cba9e8592d1206d1329b30ad5b40cc309ca57bd6c4488f1651ddaea7cedbc4d913c03a9c1eef2bccd12ebf068c688b1cf2c40cd8d197d5a07d3244a09980dcd10451395456ee62186e6e9605aca526d3a42010e3d47eec05884e9cbc7eade0e4d253bf757462d5e609ae6d4c84c4d7e25c57836be78d0882dbcc9288f401aba625f019598a40289ee6926dc5235f6f6ccbf8ebab1a355c41161ca75f177923042bd682265c8c7e18fb775144e4d2f71f74d9a5b35a5f4c2fbfbbef923d3a756b93403144f16bbd3f99cbb8b9d4406aa44d170649e334a0cdd10d007e5972adfef2b3037633367bb0fc51c263ea90c588a660d83066ac4750f8f016819650cd42170f5495d13a55f0f81ae166913d97280f73fc2c5cc723f45973a738775b7aa9b274916ecc115a6f86790fd2a04e0cf31a260c28bb5bafc04961693088f247466b8c1859d38916f963d617f0465b382e4146d492daf3e9815739bff76b89a0c58475dbc4caaa4aab970022272cc7d66c211c522581cdf97ecbe3babdde41dec2c8d863d0d6a2601bc1a79cd666032b8cbc334eb5ce39ad64158aeece0ff566c9a1969d16f5c38afcd80e9bb50366c1c2bc8ef0f1533ca493bc68fe9d90c7d666a4ff4dfbef2f36ac9ee35727f24062e9b02c6698e780f1676fc509fb2f1ced3a8827c2fd2e6f8b09c90047becba32ccbae0db7af437f89af4cbbaa99c33e7a8474f668974a3a6744a0410839536f63a547513426300b965f22919e132d45e3e9fd3afd5496cf6a616091988f1f8a04117381efc93c7fdd58f9a1ccdc6b013297fe8781176a5543db9b4a25aa63804c4a83b8495f5ab2510a2a23076fe7961d4cd38410aaa08d08fd3ecfdcca8d079c54a199a2daf7a65558fc16649b91c67176e1b3d0fcfc8661f9733ad0333dc695b373139a7f2d034d9608d1bdbbd9780bfea17db70fff5cf955e8a7dfb03dfc65ef29a0fefabac7333117dc1163251717d43c8108d024049a5578e96b1a8174c495db1efeb6a7dc04626a6ea3c683be78b957792543403c03262ab58b3e701703aff8e83466b15312448859788b03338d01e5c1d75b9a625206831457654eb73b2b18ac0f44d818ba5b47d0aefcda0ca4ff258c1dc0a01dbe2c57d314c3e41152c7bb1b10aaa27dbbad7c41514fbaab2dfffd63af58125cc33f1379834eef6c52c5f1112f7f06cbb33595dbf680310a359d408d2672a5c906ae406fe0fc0e796d3babee260690b77c1ff84b44241326e4a3f27c6a258a89df07c03ef10b0a448141de0e4e1d65ae81b9381ec6a3d5eb4163df6d8c0eac5980ba9bf949bc44458dc496d8cad3ac351b6efb64591e53b32479d2548368234c3504618ae9d413990dd58250c6a572e74d927716b22df3571b0047d18571224618711ab9b80ac8232d3a3c1d3cd5f3219e986b739c7f246a34834f7dfc139cd260171ac85bd905ae24143f569882c389507bd83f90c32b3c387b9029cdb8bf0254de4d46c8065ed281557dd4ab6c600bc9095cbbab7d5caa24fd59cc7227e84402b8f962b8898100a4e12e10f87fbc4ef5bb0b179e1be47778ade0eef7e9e99ae716187b0fe8f71fe2c654187e5b659e489fac1b16227a8045bba3f7956e4c868ba42ef5b1aa14581b9081165033896e138edfdce6d20c5c9170c5b378229c756ab1ef61777419961134af14f4606379d8db7c4e2039577a8ee450a80345b40cfb3edd1def6e416f02b70d9086ffdc4f4014950d5aac6611bfa68a43445f398ce8597404b8a49311e53ccf6e7508511d84b6dee95f263fb623ad646fe2b302ad5485c628c8c2779ed556f88e7b67c53a94ae2238377e6afc726f4c2208994935a69706a93218c418c404c26b2fb594e9f05bc5bfe626fae5047866d7c27d9b24ba4a72e238171f8a67feb1c7cc3dc28606258ca87f409cbde0d00cbb62dc01e20d138f318f5fbcfd4df96759420ebb470bdb2dde1109a780b62191df2832a17781053f0bcbd7e41a8226ebb379889e109e5553e8fc7767c7e4275c789a984297c7222063232ec1b5d9716b41411e152bf46a81bd3af3692840db66e2f170a2a991f108e21401719d880499bd9c986a8ac9528707c25b4d62129f8e44ea1ddb41f1ce5a5e16babb357be15f80f5307e640cb61c71c06e4f6f53897cd05ea29af603d7366069fb555a9b8c88e71a3a35aaad2e79f400038c1bc15bfbdd22459f50a9e4f7b020ef8c47e6bc439979f219dadaa1475518c845a1fe7ed364c6bd3c28f0f4fc072c681eedd7fcc92a9b603c26318d627b18e9b13e79c1f7a951852e0a9d069889a4d734fbd691637c09e82bcf362622b9f56a5f995620fe5a2dac329a2a86f2571fb14e97b6b41448971ddd5bb3a4728385bf089bf9fa9af0f237f8f6851daf34ad7dd29f685f260b4f012f64ee68d9d095c567b2e16ac121514c2fcb0ff8d2208d9f3ab89e92ddb77bb22ae262eae05633e89afad275a5be3717b5c53b9a412ad901f6bf5317aa188f0a8a6e2f04ef67c1fcd293b97352120f95ddc1bc806371ffd2ca273f6c4cc16f5b98516efb7d5236e869f5a3daf7e2b8e98fcab8821a84334bdf03665d0a0a81bdddb6e461fef20b93f2ef9e0a70b37462dfbab8ae1bcfe5c1cf09d71fc0bb57faf3f2e8c9480fa105ec274b9c230c86fa37dd6ba740334b066d094a2f25edb02f94a4040d7684bc1200fee8a84e6400f985b9ff45c4ef3be3cf2f2c62e269025f962975495c1a14f1560010880c0af7c3526b084ab4cf0f2d017ae44f45ad212d6eaf1f614f794c89f36d8ea1409922aa5cc3a0022728f78e3f857a045626f3022057a27ae1987df0f40783b539cc59d223e91e41a3727e39428d79557c17ebddbc93e0f215d186c4e575895051020c189af31456feec56df960b5e6ad78b2a1a79809799d45604fe5279e0e77fb86ea5c39137dd39202591e9903a71cf76f14780b65fe973cbe0c84c7e2669bd11eaaf9d96c87cfc5f4b83e1e32e118e4f6861ce2f798c866bb12c9f89348a8c31b922fc895c045df46803f3f5f6a3a0f3c9e831ca65ede44fce78085c1f0a6a4714dd7b6e77429371764d8bfdfd963a6479376b8c004cbc8bffdbd018781ba603d696325fcb54ad9b39bd273607cc64cf783517eb2d9096d52c7e4f69717117605255cdd47948b00c8138647db064f87339b70d92b6ebebcfdd0af596f5c359cbd4864ede612cda41daf542cc7c30a478a9f9ebf1cb99ecb72676401bdedd776fca7468831f26b9abfe86a6aabf30303c2b1ff0d24cd02db6e4b2d4fde6d294362bc352751664dd88519899c63c8c7750441a14318671a671030e32477737def377f846ef5df08fa51ad8ca717d60c2a1ca17e96218bc8a81a2b945238fbc773bc1605be917f72cca5d8d86ea77ebd72fefa3c5ccd126b861f1effd955cda5478fb65f016c272660154daea3bad9c78196c3b5efd37341a7baee23e08d3fff7aa804e1a2d7e09c2a8b881be1ac58788a751a26459d67779b7170ecfee182b109e84675b4402368dbc61e9d4601e1d08a07ad78b7492e4bbc9f4477424a1e98a9d42948ec93432f4298c691c49c4032b02f19519920d7a666e414d479485a578eeb0a1f509eb73da8460f8c9beef07d4e166e46b7032bb186c91fb57371779b07fff156c56ca2886cc88869f004d2fdef6ae879c1bcb30038b7ed00273c493e77facb36af11a25efa6325357d79ee2a352de37c8c0a9fdd1f19ad9f465db41ef20d15355ebddddec69409aa61c017ee91a1506ff809ee21e9273fcc1d01722bf96fea507f2072b5fce75dec5b345bc38a9702298badd2d93457860e02f88a89a1932b04ce9f8bdec3cb518e10886625ea44b2c65ce46ef58f66f17ac0b35e98b39408bba929f8b027b3dfd9e7b3166f7507e5d7dc1f507eb16e8aebb0b9e2a292138d138d8b1193213a396a8ee0ae29955ba61ad5ab1f9a7137b2ee61110723b0b3b982de9348a3868bdd4b169f0d2621b3ab3b42f85c0e95f8999fc298ef72c8982beed2a4d57905ffe6dce34ca1feb916baa695828d6e2f83160afca3730cd1c43e126e8d189ba5035291fc0527cc2b2b8dc40ecf68ec29220310143b9887a1ec3fb2d0ba33c6f8cd5be82913e56a6e5eec946318a5c8ca523dc17a8cce3c72b539e534accb66b04114bc10630d852228e2d31aa238fc405c556d7a055e2bf096252e629601e6fb9ee86cef3a01724c4bc9606e3f0a556a46b8515adcc5a910a18ff0b4336f54e3a8fdf69835970fa95c12c1cd9bb4b9871e3b48acc7df24716e73fcfc312edf9b1e70af1218753cd9db7766c60b6d1fd9fa8567f2551b7a08432dcfe580eeac7c94b7fcd55fcc5194c5a29005e76617f5503aafca5e6a40b555092fdb17e4b76dcc46e84a0acae1998e1e3fc2feb81824442fa50877eb8dfe3aa2978e370c1833c194018069ce77ec8d8885e4e0538c85dc2761a1eb0165edc52f01fd60fdbd5f26ac8c74193a8dc16cce36b8755666ca2013446f74be64f63415cef0472563c87b116b9ae7d170c7d74ac5c49c24094f9f68e686ea517ad66297a04385a6aa69dbfc6d2f1a32e827ddea4869ac38f51a470b09f04dc84a856331660d8078172fca243dc20845a073c9b40a44da5a6d1a470d6a968d94398c6d919999f29f94bcdceb4d6ccc333c5dfef7cb3c38b84048e00fca61679ea90f669af42dfd8b70a7223871c4fe55eefd9a0b876f93970e8f8a91110eab00aa34d37788983ebfe0b431aa98cf974f786c2e541d3b6bc8805c1e6485066a17e5430fb24c340a7e9eabd3c0e9260b7bb1859819c1628211ab96af2192902965a52bf36fc37f9d089093473c952287908c28147bda4d581d7b1b120e3a6e523106b9d84ad5d059d7db6ead03fd1989205b8ebd37702c9acc1799ab7df50a3d33e3efd867664c07af742f765b07bd57b978dcddb5f466b2dbf429eb193dfe00e584c5837e86cc7542831378e94010f2c981a1f52975eccb946c19b13273eba55c169803d36d1e3f1083b68235c52e025def5afa35cdcf4e347a635ebbbd0ca6e62421e79c1c8b06f96fff4b35466c9a5c0c1fe94e470dd5086399ace9f3b63e59f69b75fa486fa5005175ca4ddb9bb045a934dd5bb83aa40bb42a81df6b643430b30ebf58f735fd2cac233fb05b88d023140a0fa181e6b087154da5cdf6611d4cfb60d4eecc615f9a955822789b6921c47687a1d7f12943bd59668c5a5d85fcbec957eacd10aac6d440b7611ed347f47cef788ef074cd785d20ecfeccf02ff28166caf44ba4b226167c8e816a306a25468b36fcf57a88164c78c2b6b8488c5355c622287ed54a59c001c29ad7ec408edb7eb07f33dd79efbe76df2d79bdcae268afa49e1ef9a2c472344efcd1f567c0e78c9e1d737c2672e1ff93ca2bb7d1bb558bac86d31331f870dd193ae73c84152fbf7c19831559eb055eb67028a812fa667c9e9c83c5f2070d12298d0f31f6e0c2382d49329f63798323456f60a77f69388f02a73ba12c3b71ceed5c630c01b4d5345fa9fc4d942d561779d81c91f4463ef0c3d6ba012c778cc9f10c81d47c5a59e1dd1f30cf050163fef9ed8684178ed7dfff3d31f0d2f1f5934439e0db5f0e6979840d0d94505521e62dd07fd34a84cb446d92026480fe7f5d3b3b658d992738c6ca9eeb6bbc2d1e2cba2278bcfd2a5f4aa92cf4d966ebd02e176d1fbde1cb3c6baf15de90e17c59094a2465abe23b0243a9d2368b33e34a6283f8d4dace660ce7f084e74ea5e8052ea5865f290359515a015aaef07e3b3f76ae15b0a4a158e4892b0dfa3d4e0195d0754c99193488eacfc974ac08c1a06836a0900580b17d5c209c4ddf7553e8871ccddc39163e31c27958309a6b723b3d3dc09b88b1e2554c3c83f5cb64baf08cb8380d0b19ff4225e86c0b3e21d83b5205f6e12215306dd3e066ce4dd4aead5e849768eb0595f6a52fa5f118b1ed4b0f94f5d4825c50d2432de495ed3ff0ca40aa529d60c2ecb6a730bf80004dd013ba96daa1bed3c633299424460a0f79830009b129b292f4f84aabb5106b372bbbaa75a621792df2b057a3a7e0409e5876d30bbef1e70073093ab2a3d4005e761175f7a2e9dc1222c9465a6e246973af5e4119ea1bd7292b7348ba8c9ff656ee5c7e9c6519c68c3d35cd1f4e273d125e1f74aaae30c665455beb46a488dadbbd691f17ac9d89201359b603dd4bebe37e4bb416d84cd3f24d798478d4f415ebdb5367d071467e6b5a6f7be3a86f1d8bcfedc71bf615e2bb0b51fc0c1f9acf383ca924def6378ad1bea4902cc38448efcebbfc7e11eafb088db01975d8681175563b7942f8030b561a51513adac34d7f825426a7b25a8f2d861334f70c512985a59f69ad32203fe1f78fefd73aba56c8e668c9fad260784b50a96af7fa895a5ff734a71938c68a4ccd443228acad2ca50b3b7c18a676aedbb5b7450d4f4ba7dbfdcd347a5d3ff218dfe64bf4ff1c4313723dd07fb9dffffd2f78b4c4ee952fae01ea2956a27f708b7eb1a2dc17e317f2937c87e4b1b8fd51b4bbff2cb74b2416f55e9c149f1ede6a177a8c96f906b4e2acc7fc5749b94b30df2e1fc2ca7bb34c2f362857ccc70fa67c131215104c06518b9395379d6924f5594f96f19d3c2008e4354e5b22910e4215c464c403e583d078c2b410415a78deff6cc62a11ff25f58c35ed812d9c8429d292c55b24cb1e7aa9e7d760a7daf5ab8723eef1e236687776d8621bc7d5d06bc4f765ad432ad208aee7e236187df7df1c813fa87344b6ec324797f20b88dda3a83c084946101d68edea24f658e126cd028f15b4ecae1a420410bede58e5f4440f34b71b3038460e7dbc79cc5dda0819209421b771779ce532fd3cda377d6a4923ed68171273052667e05fc7da6f7b0641c5e4a9e47ff3ae79f1b9ba3f5a592bf31c5d92fb674068c6884f142ab1437269fbc84c37a74ddbb66160870ab4a761549a70cf7af9a3af4de454fbfdf5865743cebc380b9fe82d543646054ff3116cbb182f789f1d7c7f8d62c4893229f49da2a5ea05102f8ceebb4d1ce48c60b3f9e51f1a17295ef6909f97e5ef77a092307737c0845e4e88f1e30aa33bb5dcffb014ceb755f34b27cb80dbf20984cf3bca4bca12049d9d7894c59edda0d6eee461f976d12a24b310ab995df0f5ddea9eed67d59138e873b3fbda0be8681991248a16e708834806f14bc0501a0086aba345bb9c5a4d2aa078ec558b172c34a49cc472313ad6dfc1cf07f8bb886cd2dceb04a0d0619ac55ec6e0990be1c1d9600b0848759843925e42ed093ba9714ec7fe8e5cd6d4ce95b50eb6dfa1e7fe3ec2632417d014d6115334bb80c898181a5a59c343a9b41ea26d549c3f029c96fd606b5ed69d27de1180118b38bd62f021b5c4dccda8f089f0e98567db86c9cf58193a396b13c72d441a5d4f5b9d8e44c18228b9ea9f47daebc8c9ca1d53bf0efa994f8abb7e23e207597dc7205a896a0f4f176a9edb3740d4cefb3a9736d38e6b146b6cfd01990addf0292cde81f668716856b0250a7f3b45220e573e4cd9a1baa56bdf8eed4ed3ea077f35ec38010edd0a64718a9fc968d09eaaccce66e535a13c60a6b475b9a6090515444ad30abbc508af99f52a5ca3aa7a973ca5b59192a68ca095774c6f4148d8d8f935f7bda2593d504770cb9be358e9ad756c8c11c18d376bf17efed88d126666e835f2df9b41aa1e3ef4ef6588afbf8c4250df00782fd1ec320489e6ad394b10faa9c60a33a1a84750d7b8743d2a4ccb1614e7039eedc7675493fc9433766cf5d4fa96a899b809e621aba6ffc8aeeeea892973834990a22d569d30ebfc45e2eff626ad7c613810a7d2297d91f00a888ad840bbd63dcd21eaaa4064392593c7a4a83a246e1f9b84545158a87b63633c10d10b4448def12889bd1e33468fb25c0958c6b557d9d1de4137bbf87ae3092c813300c3c57326101e6b77734137374a9474c945344ed495941446e18b24c609738dd3b9be77dcac16f3fdfbc9e2c077710ff318f82c70dfc26f9f253161eb1343de7a6d29b8c36bb513fa2097ca34b110be9a23cd0245df2730c86fa2f65fc98e8e0f196428b2d83bd64d77811e1a49ac1de68f95269669b4412014b7edffd2531e7c014a18aa014108ff304b90b8a37871918bd04594f3e707eff89195a2d65726c33999f952d734c26cd4c04c318be58ad45d370fea0b3238f21729e7f16e0f22af3de97f71a3f6d55013d9b81a42364387183868d0c8870d3ae0f494b4f57bc31d28ef0fad96a00f93d98acea63321faef89bfef900763cf88ad5ce4cd0726e69458517e018e5d59f2ff314d8444cfab84acec9a8cc700a993740ddd7544637deb011e00d59dfc2cfdcbaf3c28b11f9c72d1ec8db07541a605e00900573564f338ee2d875f8aac81502a66ebeb013c0bf6e7b491fbd53258e00b013b06350705226f468059641ca147e13bf71c0149324076dd4659be6ee2dc472e0e456fc456ad8c0aaa87a22e4f99dd4b8cb384dfec67f17a9cc1e0c33a6f5eebaf0d93b95adc693b16392bbcad20fe51f5d989469e2267eb06e0bae9ae19452cf68754b9989fd235ea40e55bd2984df055c849a7af9ab97391bb5efd1a039c83bc54dd116e5e5ad9d716c541d127b198c955ae97bf4a66d464ac12a0200c048bcb53f6dae704fad4c647a9487c3a5ce00144ab7d90fd40551688899f171efbb212435023eec1377e8df57163b8ec1da15c199551596982e641c5afae6ac634cc04e8960ad05021803ce844b72af96d7ea5f3131ed1eab9eed3e3eed35eb24dacd1e89847659e1f37abb6135295a32ab36ef73d69195755425023954ea3be8d777b455e417b8900c52eb73077c96924ca5c05489484009f23159f74fb60351c80865365324583895a486c5299cf3f391d2b077f6354589bad86398eecbd3e4ae4f53cb13c8ad9d4e469009ea79c14ae2d9e526c4fe526eb27ec0180f834df14483efa445ded0b274aec0c974683e8213cd220ea4f20491c1bde8c32bd606c1c5eb832783002fb734f8df9bbe0f7a383935cf03f77d4ad52e49ba10a02d4d25597be14e90539b80bd24e47fee63031fcdbb0fa7834afc8c21af4e13987674a361cdc7c82668157c4c7c869db6e75a174d26b9ab732f2cc93e8a398db5d860e8595bf74cb9e561ca49568d60b095e26778edc8cf1da70601f8584316542553c9d8247920bb82f4a165e7f12618c822877494555f025509409b61b5115f7a46fe7bea9f0679f72fd83d3e035db466045785b080011e4e552e14fa9d0d44ec3062db3b0d05a1d0d921056aaed9dd4fa52682e9800d562f6eac42fa5d56b9fd46f8ad59d0f67fb471e9e220370874f59408e60809d78d913763fe4db9dbfa364cda82af43567dd229473340934ac6b4fed6f88f4881b20b532dfef689270fbccd08c112bc0f32fc9108ab04995ce2ed5694eee132535b299cea809520db280a013eec468b9da1c04c9e833708c4aa5bfd18906a18648fa6edd2d82e0f44db08e76f93520a0c005e9bd4154120d28302d26e90841c99a1fa355c81602d5e29bced4a93286f173994dfd1a0e42644d086da450318556917d9d62e3ca2bece57c566fdf93e8cab11fbfe5217834966c9b55714300715bc8a36cddc912c4524f551901fed63be1f4ab6f81112360d2608372bf7c904a58116b59b9d3517657853d05d321ebef6b06c710974a4f3522ec395b5b2b142a6731227151a93cf77504f59b5518d725b903ae7c394dc85ff4f7353583a169998dde19ed087b1cfa8f103c649eaa9f6f695ca7c9a5a1c3b14ae3655d2cf2a7d784ec6ac89bafca1186e419dcc93f17073d8aa630cd57637c8ea07ffd56637931f37b73a5b047546f1036407059d39678991a4831525591b1ca8eb5fa7bc83444c5c277da4c42f19936f2549be9d3630fecfda3c053ace19b45029d7954e1ea64742a0207676684c480ef0221de1b81060a17c622f3b20d8fa256c7df7d319f3d3bd6b03cf938c328bc357b6a0ee255c2a0b43d2f3fb0dd6a5c8e8986292db25b15b7345de244f3600ea8c1f8623c8168a404d80b8a199ed3b06628d152b5dee85431d6e6ad2f32234b53dbe96578f6aa66fab3316cae9bfe3dbb9e3ed22d42a167bd88711b43d10a5a50de1c500cdadc8ebbe07e2a9d4fa7236bb1d3ca2bb0d22b5d89c4bfd0677812c001028f67bb5f9699092dbb38060b3bdd969b9869a1600ae41763a2c555006c11dd0ead9d2ea6d92d57676d433083b4282f243ff7615debbdf93cc16dd6743a4b88d527681abb673ec1690622d5c7e22036b66094269919d90cb17e9aedcb227c42291aa9b1af38deca05d639f98ce727167b173b37a47f84d0e42afb68025b1be6ffeb7a243cfb300008a008019bc84b6341d79d218d81454e35c211db21e2aa80d30583cde0de3a7c75d945861fd1905b74fa330ca6d15dd8406e9dd42136788633ae933ff3dfb18a9907785966c681bb212971684031ad0b0d4cf33cecf16fc02987a77a4c6c18b4eba2e245f0a474e8c452ad5898bfaa4853311ee23e55f1ea34c6009c2d3838427f6a41822726f92c2bae1b6c6d4195b8206962f5ab40592e957dae215d19cfff26f08c8030242c902ef4bd0642d0c8da818f474bc29eb3d070e0ea1a7eff05f0b7fcb51ffebc84a4301f680ece65784a52fdd91bcee2c9bd00577d872af46914eb0462a2c714a97e783e901adae4c52a31735d871fc0c4c68fdec16f8e6189c6b92eb2671c9f3f406d08a73cdf5977c0a59434697e17f7aafacc296f23dce434b7d21261c53361d861099cfdc806bb95edbe4a99f7c0769e335e9c77188e2d546fce2396ddcc6ab83b8638ad91cdcb10c63d873d6cdcbd8e9d69ce1ed2033df9e39ffe1162047e9a9273035ad70420a6d6a03a5178b35b7dcc168958df8e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
