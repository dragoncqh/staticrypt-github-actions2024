<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2289424dee0de090b2266a15244f69c2d4fe16f99115d376a1e5cb347415a3dba00f8bc1a54d4da7960c9a4f000ca9f3478e6be294f1c5f65712ad35cc620a75d1258ad44562c5699cad21fd49cd2b75a5c5ab61377dd962384816f4d7edd88fdd3d39a95d0583173fba23da0cea7d33c39e825a90535583c368977c954166c095499bfb4b376e98bdf55f12f1c793b09a7632c0e5e76c7e0212a16851004a2b5224d9d37cb6916a633333852d87944fb2ab7899080a43aba4e8791d79857861628529ebf16b6269989628f7510c8441a86802e8203ea3a51d2d574dd61cb4bd4b39a907badfccaca724bb2cbab0a4520aaab88540be1ea6309e56ec74687ae817d2fe902a2d9e38b01ea136941037a808283feb6ea2d6cc88c73ee72b845f51588e02f34439bdf2e3c9634fc4512dec6c8c9f25c2c59b041e7633218b275b5c68a394eda078b6f4a8ab56fc43373635693a1c4f03dd06c7dc9b443a35dddf52928bdad4b2750c53ffe151f168b546787a2f9d9ab84c936c8fadd6fb3e070f1b7f90534a7c08697980a34c1087251da687583490bc846a0cd74eafd6964c1224c0beccfddb1b01b980c82749c52046c320580f61c0210bc32ce4b8cc77e69a91a5249993a95920b8e2a37154cc22bc7bdc753ee63afac59b617393d82b67833ab6cdbb41bf5ca6081155bbf9d4970a4d736fda6ea48da91d9a2f78b55f0bd6ca8a51d7ee8d350c725ac2de4ba43335167ce1d318d271e8371350d0d5b6e3d561dcdd348a0ee3c17db8d197386b7f76f15bf723f60b9e4381d2445759c92639e15d7881fd2cbb0232913dda332561aab12693f6a8c8765106af5a99eb00c5214b14a0b2b7ee0052bb4d6e56eb2a5507bc1173bf58d92e0281c5c4df3d5870fc0fd12f966b26f79c969ce181479b63d938b6319e1178c68a711125808453a48f3395d3b02d7d940a2f595caf55e8b2d0125fc8e1834d79fa34919eebcd4d964343d70ebcf142aa6ddd4135ccfb87012afaf263f9b22d9e806fc6d273fdd449fdaa2db449953067e76460739f7cc2242040cd1560b89014a499eff3f7bcaedcc545926eef24847a56c987919029b6c23452bc03219bb63070c237912d4651b638287c7ba8a4b255cd071789848b2b0eeaebf2c3a13d0d18b3aeea5b72467e6e0875894eb82ddd694b95322bfd5a5d683c79519f915c070b5f84a5728e6e6b9feeb99e325908bcfa5653676507309141e9229450701383d9ffbeea6faa2f13e41d194fd205f8f52c318d3cc2dbf728304772743ebd6ac496605c14e6102e9adb13b6d5ab823526cc9a401cf76ea34ecab5ccb06bddaa2aa460e5754dcda3f659933f52cdf78094a35c9788c5510e632685d36e05a5af6fb1c01635800756d193d5044a13e4d1599d9063b6b897bba5dc4f11ef4d7eaf7d299fe955c822ac95caa6ca7bb0c4cc4cf5e6dee6ba931d4c9369b21b570d18ef56687ace9f1c904763d9fd3302c807cf519d03377143d2cb41cdb74e1d1391ad008cd383c084c59402146e2ef1511cbe9ae06f16963a3a73dbe7e0729dec17dcb4106e849ec2b6c414c9a565c3f45a2eff53f20a9bcfba05cbdcd421c33585c36e3b4091675021c7dc9e5e752cbc8d6f65dd53d2249332dd3629a8a0886a65bf791f1a0377d4e77adf68b9c528c17f06ec6902375380aa442d91f7fd7c9aec77627c9ce34733379cf548706c76fd0dfcbab6d42cbbccbb1d59b9e22349844f649b5e064558932883c1f6008799496bc310530a2d9856025c6f7938cdd1c1f2b053e0734f935e754aa693576c5e252ded7849d8aaafb4019d5d10e841caa38cc730cf046d3d850836bc87861eca44cb772791995773698a327847e5d7c586332e1d7d22baba3799655ce0c64cc94d643f9989cb1bf619025c6820e8b5c9ed589bff555cdd1c0ac5e384fbca2cf00e7e8c37ee6869576e7d92eae05eadd40e1260797b8b440e1702228996d1f14beb7dd5840995e88d6017ac45db1d70022048230d7f4dd32648462d1767e9d25315d755c93eff7c4b5b25aed899c6661d43d41306cb2c7c35a2bfd2850e3a74974ca060b90284a448a367bfec2f75584edda6d470bdfbedecd9c986e40956b87d1b5a7bde97d3801f3f43c8d706f99e0d5f2dcb4637e6f6d19cd17c2b9d3b08344a604212f09a3c9e318e0f75ef13e418286a5e6da2855e71e6145098c168bf4e3eb886edce3adfc6ebda18d4418b4d206f2fae2da9e6e7e08f0c703d5c237d2d4b6deb3d07de8112b2fd83fa33d57b33b869d0832881218853c4cadeb2aa153bbe35447b88b523b937460050c72449c5d645fa085affea853d0795590cc16438c7e719182a16a72d21c000795268ff2729818f94764b42f5bdf1ab57b9dd9050be61179a3e688da49b882b01cda61b07f1a68e90d3b7f85ff8afbae328ae9cca37762b1c68ac60c6c1cae8683ad2c7d917ef32e1b42f3a7c845b7cf216ff5d8bf5f22b1898623d587e3cfeda5cf616f671d19de8d60cc158b7f6e5536e15da52301b52d599bd56bedd06f965ed296bb39e9ecc7794c3b3211afd495f32e62fe05dc372f80e2b3f5a057ca66297d7e9acb27d038bda2459f2b5cc2969653db4d6a52d390de5c2fd1ba7b14baabf2e058c0d90b20a17d3361d1ced9cbbd404d8938d0d200b6abd09583959c8a568a5f6cae26eaa4707ffeb299a46e9d59f4ca495484b0c58454fa6fa3bdfdae07ad8dbdb2d018e9386ba7c445754ced408888c613442a7484bb460fccefe1599e1aa5e5e7155d03d8af7a2fabd0b9282aa3eccee43203d14dd56680b20ac8117260fb2915bc4eed90562b4468a333f0992c85231978087136723ee08da305acafa4c7e256b18984e6b2272f4ef8fb0d2bf3676232a9a5c3f1ba52cea2c28e2e2cadfe1729697301639fba6eb5ff7add530569313631f58dcdb4b6fe68a8d30c7269fc39faaa5a5ca7187765490b25736a42831a1c60bf8360a868c6ee92f07e3d77565bc42afbf2d99687ad56e6e206e0edfe65697ba46651832fd88fe381396f4ebc21f4628add0e0434247f78428fb48116c1a6871006287b035580f577c32f0c1cd6efc7d4fd9c784eeb8134857a0080d3ee2941ebe056e6f61fbb482f1ce23533c2f463384d1ffa790816838ed6e40f461739f04ec5c632da711c2e5b0ebfde9f1311544c8bd84da5007082b07f9284b35281b4204fd7e64d88fd67fe2a261656077d70bf801c29616d18eb900e2edc681541a04fc70d05f8cc5dbeb2dabe81d0494e1ce91c3e87ff0dfb77e31a9f4f6ca0dc5d950a694a4596b02e53a17fb81217ebd82bf095dfc7e09723e03e4adb2dcc758e84b73c0e4de2932b973051e391b33929f27fa1b0ad9b346533215dbf10bbbc066db57501f14e8e9b114394f371558726d679a0c21ad3bf523daffcd55642586b514eb4e08a9e88b6fe8a44a16b0331c4b2bc88d1cf30968f964fb7973825725940be7336d7e4b818fef05f08dff85b2ef3a58981bc17bc8efd095ff8ec220151b4bc4d060264a3592772ede0679d60f9aee4857446bb89378bef178d88a85981e7d1132a677698f1d2b25f20d130a9818bc25fda254f8c88b79d88db7d84f64d889c5c70d3165c0f502f232ccc5656f1f2e9e177d2f7fc916664e73a285854791511039c1b718a989ca9df87c308a2822ed794f60fd2b45ef7bff18138202d1a5da07cf4a55219a9c1c5f771434030317755ee65a1a5455fffd253ef313db6b8f3afe9bbe0d086d097b310605278f51df75277db281f7031314f7ce6132507895f0f97568fb2f122a11cde40d362b50d52fa9f65eae70d0881c55b62197818906bb8c26e444b1e5d18ce0ec57cd6d8d35bf2afd1ad9fa8a2211d1462c9ef356feb109904290483db71783e0a49ae2e97eb7dc296777021f9caea2ab548ef9efdebdac9b7daae5e033adcc4f1fe00bf29008b774ce15c4cd949e72791bcb0bb803e2fe3a9787a7f06dae92198cac225fac1ffa5cbc2070f6e83ec94d7171aa18505da2ee0a08a5745ccd3ba659d92b4692c907018e7901c6db4f01dd7193d6b0d8dee9547dcb8f3560a066af8e9c22ccebc0fd761564b623ebc4d92db7212aad65bebf6fd00a9ab29b36822e3c0f4820cc8e26b4ebabc0d4534a2b00b54dee23a9d9b7ffd5c8c003625e6bfc331cb56aa1235cfce90c0c8027e5e717c7a6e0449ed03d7f2d8b2489249102d017e32c316cdd20c1a452ac94ca27611c9b491b15b18b6bb880b5ac28a8968239174f3178e2a4437e5f7547ce9458b1873a7b89f1fb7614cf808d4c7d583da59fd084bbe41bb2434af5f7fafb0ad2e50b1eb2046f5bd6860e970c4d9cb8c84d1d91a038fe05550438f32c47bbc2bcfcb5f6d9893c39f7e0f1716f170184b17ee249f5dabebb81e5f69e1e568ab00779392b7e51ae4e731d818694957d50ce109d7fa73bb9b1a93012b047eaa6a2b25597349e7d163fd267dbf98baa2e7011dcf2dac1fc07bb25662e0501e4a5cf93ec3a74a74e01af10cf50317ffab5528d40fa0000337d354b5f5609f4b951537b13ff79b3332b03bde73fb827032c2aeaa67d3fc15dec5b68c460c73066eae80ca2a541571b3d0d4a835699fc71c1d57e3e754c9a9fe3403e94106b0279cea5f46d03a0413f536811d11f918f624e6ecb5f3d2111aacc59253076201e92c38b25c07478b50421c7accbf690ea0c162a6878571df3d0961bf8abc2f0060a560fd5a5a07ab048b8ba3ecd9237c857ac265985144ebc03a40e51f937cd80119788e636f44b282355684018eb1b7372bb889540763a2042a6909391659e893a0c3aac9701e8d96bd6dc2b5dd62739a52ec80a53d9cd4e01ac55e59b7e38d86cc8b4572ff1dcf322a98a7ccd25dc00b19cc0752f520cac43fd5c8fd3b81ad3fe486f7ec3d1c22280e47d0d3068e49737e9a3effba4720ca63fa3a8872e32446b0e9d5ce70ac10489c745e90b52095e57204bec7efda24d545e78cca53908a411d00855ec984fcaf82ff9e931c789a9368de95e379c72c945687734f6dd45d38049f1a91544311952fde3423d16e65eb56cf5632a691f5d4a5ece41bd852af3d425ecb15ac94d2b41334b08e1c8c71f322494cf852344a968f611f0052a53e5647f6ba6cfeb44c0b7f286302ee10a04014a968c56a2d832a504b91f9b96aa456228b5fbcf38d4ad1543688a8d673c1772cc464ad630a6dc4b1d0aaee6c048f1fa1551e2132199195c0f990bf6e2330db70d6ca3cbb988a339d63033b7ddfcbad070a0b2d8e3cc1808af4aac4cca758619c87c63abea3459462491ad191bfeef28fc5d8228981f35ef43051c72fa8e3134d5cb634d15e7d9cd32a62ca0c7a6ae68383b08f83b37b59da165df0415c7a95b7a622f6798bd2a39883a68d141560d35740808cc87fd4a49a47a95feecb608c1e23e2919fb144e39a595d22bb87dc8401806af9f71b5de20b36803b68a23db8c8e10d17554b1053a8c4e3738f4bdfe64f80f4d529a759968d27599d8be521a6c52cd7a8d4607ea4e8c3eb078f10d3a4a1625748944fbf76c6223d25523748c9a6dc59deb3302625eb7cad7ee5476d3de7f553b4a5c3c3d178d15fc93a2b90cb4f32fb3f0e69933e1e7e8273eb5602b2ba9108ac0132dda29bdd2fd05f34e839d9bff9a516253c21036313aa8f70027c016bd09bbe109e20c75e646816a90e7fe794083ef6161de5abae5362795f788a57760e0d73635599b49ba986b214e1da1f926763bfcd2e77316cdf353616199ed13e042b87b3e9073aab5a959c27017d47f2ecc9f573ca72d5d5f2bf01bcc351c7019bc0dca992f05916654a248a325e16d5ffee6a69c0332f18db340a4ae090a194e0f8c58d3f5108074145f914c1e7a2683f10d0bde388fd4bbc19c54e621f5665748fcf2147256e7097239a36eebddcc41d338aaa2194c4509fcb67e5712d16abced1a49fe1fce1b2d384f621557c16d859a18bae17d5758f404003c8bdba492091007d4917cb76afcb90c818bd582d6a68a637984340be30c57a30ac37add46ec2ca47cad87b9bb285643308d6bf1e84ffa5bb768118a0cbcb7494697dce01def6ce87484a3330d717891cdee5180dbed97d8f98e2dba8ed3c0f95b3e8e7f12bf049e6ef0488b28ffa92a518c085210a4d6bf098bfae5cf7e34eaf3dff9f99cf9c28d1cae92e08d47fab6ce5d0637c5e18d66ed1a5dec91dabbc0ce1b39e12662d8b68bf01409ab3871bc68a68d8bfef98ee4b90acd6b81207b97365084ffc563488adb4bbfee13271c07f64c814147ecb9d5d93dd1b9fdd1abd4104293e6ec074a3ca3cfd735698bed58608106ae23e47ecf43a9fdc6db9b9a4b237da10edf8de1d7356ee1cb1c79c6ab8435b78a85c1528065e169bc46f815c964e065b6c569f469b458ed7c71005eabadebf758d967f465bfbbcc6934e9077932a3dfa6924f3ea524364bb6d99c58a39a1cc4bd6227ee1db43c3c2d92efc49296b24db872eed0c3973beff2e4701f3b174ce7a2a9ab077ec310d01d36a633db3caae73f79075b5385cd4a87526d6967c2d1738986616b6fb1935ba7683865edff32c36e13bade0e59cf46bc0326321703a75b7e0ed64880bfd66f630ab5e135920fcc98a6de1266722cbbf61c26604eb74d370b5f623d04af1d2a4802898f3b63552f54a6f6c193546d1c214c59176d381d6aa4677e9ec24173afbd319a928b9a3feae7511b9a5cc9948976c7d3ff8926c8bd5d45fae24f4dc8f31c3d21e3792748ee26b376f5824dd056ea1234b0690aeee6f857454858dc8facdc7a0496c132401e62f27b4b72ab1f1a672cbb067b5a3835bb733a6aabad727fd26ac480ad83b266377d97acfbca7618a3dc3880c5c59bc911ac52ca9f946da6d5c8e39ce54bcdb2e1569030fa2c069dc84bf6a11ad3ec0033008ef49f96ad52917a22411e4aacb3fb5901a021b7416ee0bb5680411f5ff0aa9a9e11db567837aa47129027c4b66d577007d9e1cfb5d66d283fec816527769b341aa7e79019123f20e08f582a7446f3a8ee876b10843fbc7c80e14447c057244945aaa7ff5e082319c18493c3a6757eb7e0987de7cdca6dfb595cb7c007950ca4856645bdcff6d7fc5a3f64b048b9b0abdc4a60d7e089f3c67102d18802bee27a9c75b91c25f6acdc8c31b2aeafd3c14795f1c65872e620ac0ffa2e7f2cf654a4a74bbbc97c7b59ccab0914575d4f457e126960cf7d7baa9938a78e96e65da3890d0d7831aec19243b3dad7fb2954e96472e46a6330b559c6340dc0786fa16ed65644b030b8b5056b87143551f8502fa2377385d156e1176fdaa471673f91eae83e9ff0ac48ebff5f7e773bd71650a61f76829497b4afa0078d8277ddffeaa654243c699dc4c89f1cdf8573604bfc90e1c66ba94c78843681a8d2c24d2cee9d8a4d1c7de720f3c785485878eb19feae792b8375358b3cbf4d43d06de902a1d5e7a1e70782bb0cc740c2441a592f3d4af3d460a7319da649d3f4feb10e5d9fa938d299d710b2c1fe9371e58aa03af0ae4c1f82f18a86db15b8b03e4fc9a35fa286e6843e17efd6fd1cda8b66622137695c79231bd27a3c165f90ca6f3f9aa42a24a9bbb8801761bb3a915e8e66f693a057111e9a2f0a803ef5dc4d721db5b6518f3fb597e838b8809ac631d988113fba4b5e628c09cc21dc813640ba00c4a3e98fefe1c39d9e6272d24bd1450862f1f3cf701a3aec1f589783191a8976734b1c8fe27644179caac1fa970a62bf6b9f04aabe1ca83613755d1e402c2ca5ad5280c4d0d0ceec3ed0d57350057c12fb40d4782aabfb8c64f9eddaf5dcf5385e07b309f25de34b6f4da0f23d04708eefd4cdf15e4f45f4dc465a704ff44cbd169754ad1473b66d9cfa1aa75a1c26700e87ebd4a527ba23910d0001ee56cf66877d6c67f7d9f8a1cc00b6185ec01e15b380a798f8e099381fae754eab3614ecf0667e67baac833fc6a51e7079cf1927fc2d44cbaf94afc5797d337edc654765b158362ad65a3b9f307408eaf030a86476e56268e5be1acbd283326032447de67266a6444a1136a0ecccdba0da021d245dfecb7c364525d3e04a7f95c9a7806e5571a3f2b0b4f65cd90adba6f4e017fc47f5164fbd1f96684cd0760ab3831efb146e493674e7cc037945a0bd646eea320c23e2f5b06d6e453e7b55cf35111ee01281c0be7d256d81337073e373dd8e4c9dd583ea700f5b1e5e26f44af06fa32d2deb2eb65940d444a814daf4a4849c2c3ec861ad47e9a781d4ee84ebf10bd1130d2e5b4882da9d05544e0c5651cc44db98ce1769f751869a8811d8c1d43b1f06d1ecc0004151b3a82ab87400c4253251e7f70fca69313005d2e777ad77b807505276a8d12107acde2cfff28d6ea4bc4aafbb9be0858d9d3ca9137464b871f351e72a2f6ffdf5d0e16cd17fc564b69c8c2775fbb622f0a36171f85a778e3dd626ceca7a6296786ab75c04f75aa3eb5995d5c715f377eec8d1ca60ccb4da0a690154e4bbb6e042b7741fd5966567ac1d71a982b1b996cd47af55d21f95a81ce8d47024531304b0296a2a19bfccd3cee4c13ee15f57ee2591061d84660a8835c89ff7aa79118711614f0c9467773ad50dde187fe88db55bae19dd5ef373f921a1b88cddc50104e21dea1fc3c120e9079f7bbb9ced455df90c415fb72bb1b86b23d9332ccde79e424d4af9403aae813e050a11235798d69e19761d14c482c920e8fee6a9e62ff31a72b6dadb5d3908179ffecbc0db2419ce881a9edde6dee7db201aa954c900e7b2c7e03a91820e4ef113bbe51d9b3a2748c2ccd37de88ae3432b51c16d4db16bcd15d26b6d150210fbe28e4131ff28d1a8e097bcc2a63c521ae33ef778c8502ba81775a413e8a35fb1aecbe4355caa459be525399b4eb6af8128575a9f6908e1750fd13be7ea31ed4ba75b3d7c61bcc9a1b42a947c012134efb14384a53272ee462719c30e75cd9a1cadb52e4caf4cfbc9927c5df694b70db64e340f46e9c6714d6fe5da8dd367d926f123947c17ff7a9c93091a8710723547622e13b3347cccccbcfcc9020b4cc4bc2691c41ce1a38dbf8a0ba8ae7d6d851e16ac2560bcaced53036e427910bf6fde24818de7bccef1f381d441a56fdcaa9292c9b7acefaaec405f02e1c8c9cfa3c41dc8c3f4b987b3f6e0feaed34eee2173a99380745880abc257f992def921af31e050c699196d0a8861169ed4eceae43d3995e31294bf9d33ccf29aab9d933b733a8da3c7dae2f5329a98b0ffd808b895953fa3dd4a8507fc543169f13085c963b4d1b1e4c7caf1e9cb40a9ca76c80dc8499de5a52c9e52c47da3e1b9fa5e7d5f6d53bb3327f445ad5b483ff1abb09ce0a1f67b073602337d2d996ae9e2465d38aa219e9edabeed705f4e080642904a8c066b891d6ab05cc598a3bb32c063c968295781cfba32e86a663be343c44f2bc96e9aa894b697e5de6286cbe4a5546ee06cefcc9e942c7d0bf4a9fc9a6e9a73346e237b3849eaea79dffca0043423e7e16fe4f4b99609e1fe0bcda791a63598f33b4c251b636f038e70687acc8440ffdb54cfff213b51518f793758a1b21d327b72fbb915a883836ce8269c80992c8eaabc5ff2865652a74a30a75e00b7bd7ed6c5b9896b8d43561c7f88aab13b4284d60a5e1c2b4d860e94a21f2c090f405afa89ee73b0fb4717db96db4ad35c4c2b032c4aac9036253175a43bbb858e9a05795b56ec54aa1b35adaa13952278ed2ab85117b0c50b8e783952fdec5a9327e6b35a9441fc2f6d9b23809308351b36ca831cbe1e9b0f4e2652f758e8d264748caae6f99add2a9611e6d60de1b71a572556950905b8d263eeb896468f86db8511189602483cac81d4675763a4344dff04d410e135998125afffb30c57b794d551eb82eabbdcbf35811073763fccd2fe42ccd3e9bcc66d859c6fb839b73879165b7be83237a20d35a1aa2540d39e3e5fb6c5859d52ac61bc54db53960e246f53eaf79ea86f304febd72bc2d39f25cefb60e260e6da0fdbd8ef0d0126b81c5498dc02b0c8c0b6c521c992ab5e2e74ebae6f631bfba7889e88cd4a702b1a39a26b0977afe1eded42075a24fb9a691c38692657ea80e51f76c8dbd69e76972acdd2fd567f9cfb2ec1e5e8ecad96ffb859768ed38281238435e1b6907b9f79dc6a316b1ebc37313aa12bbc70c2267549943e7abaa861dfc01779e8476e733fb49c3cc8e4c61fdd43b8c1138807bd5749a818a1b59d4614f5bd5bf30b2c88279e7785a0777b6faa2beb874a4b33f7fa458f96e8041d61344f59ef1eafddabb96870e05eb452bde1cf9c6ba742fa4e2b7d93fb82266b148374ee0af832f7fe341c815e4ed6f00663ad22e504e49b0f42046b0967a42f7571ac957e705fe7525378d5345e6ae05d3088d90324667423e86b2f702c05bc21cc9aabedf44b08bcd711fa7032a68f60ae5bac6dee03e264e17b7d17f723f064484c896206346a8c0637b4bc065183014abf8092fa4fe03ff6ed0c52c59ace573f2833bdecfd44b437dd2300658cde57218ced192d76757d630e72aca1114a9f35ffd1e7c4f9a50e24efe9aae659e52436e3d5967bf115b76f39388e4d6d335b5524b75f267eb9e2ce4a0037bca6102dd93fa7a4765dcb87108e41d89d6c8192bbf8c6dd230d9278eee467e1a9142db0c3336c4120501332e98ea9f49396e405d1b47fca4b14b9b35e4466d228330bb93811d7ad43988cb616b4a2b7b7712d557182c662ac8892be1480382f14691c7ffb625c7e1a383fddb99ce4fd02698975c299e23f5eea09a95e0287c6434fd290b6827be892ea54100ad964105dbce833db8e72f91c4b9b0993457eddaea7d407b355611791ab41ad680e7e365785d29f8b2fdd70e14b5335c6ef767f3549141a3012d968c61ee0627b27630486dce24583515ba94c2169306523b253d0d681aa1c3d879333bd2747bf6bf48ac60c6f6cf387cc610bc5b22e77bbfaad8308706a2a0e6d924a11721f32cca524d45c3ed3d69a8d3c96dcb1c6169db1baa569c2cb6ef64f2c05699cafecb149d739cd507e4141d5b95fc858a2457b0b2839c192322aee3aea453683b0343b96de16f9a12e87f607e3ea8709af2e671a116add180f24cb54452974889b98dd58fd8173bab304efdaf0d306850f3010c2ed16e92a2b9abcb0b62fabb68aca09b61956cb38b17ca7e2992e85d3fbcd4721bdd586b52fda51f83e91a9e84690feffd9d921628de004d45a5be9347c62dcbf5e3eaff2f8a5f8f47e0a7c21920c25caae09587e8909555a97eee206c7502548b80c0fc8f490ec02f043d7c726adbd2585528463e65be1b1efb28cbdd11d7492b6f4fed58fdcb0692bd49d736a789268fcd74fa3a441b3955194871c380906e9926fc5e191f7eb93f808aa1252a780615573093fd2dcdc46a31fd90ba4c1f65234974247cef9d2940e237eb463a83b252cf2159c132dd5ea3fefb13603d41f215f18e29bdbdd01ccf295a94508c678eb05cd69e3f15e0d8af922bd8604ca1f9873e3f97401444795218d86593894c6e774638cde993f9b05291fbf1b31bb96539c3f4e430d954fe88b1807f9c283da830409fc849945834e926492de1c687aafadc621c0444482bf27f0f364d37b4333c41a5087aedf19bda0c786d65be309a9c8c713e9deac687801157c8e82da36f003181447d2c49a9aadb064a3153e38c7268ae6fc38902a803c9e6abda18e4206340f9c9766b9f4b0d1ea62e8af334cb0d8066b580bf49710775826c03c43030c9417d47dfcd3e6c729586452ce52dca7cf0a747acb26e9ba80303d69b3ad43d5badc98ebfd2d8581ce8a920b3ac14bad4706d1174c8965b1cf280138992b4a15d916e4a8ca618946969f9daa43bcf34f6a3703dcd061fe077ea24839a492719f5ac8f5a250840fdaab9e7736c59d3503395a3599ab3f88cc7f7728cb7102922018a42bc3af5a790e613d6083c59e309f2adef323c64cdefee276792a01caa8e905d4d6c8dee58ec27161b21aa43b552264b4c5f012cf92101529f9d7c11fc7f69d10a223d5ece067560904d9a98982cf5ed1a7166cd209355799df2950194ba29f50a49aa0d31a7a4f96912ef4516364c47019a069a2969112a783184b2ff3ac9ab5a01d500dd195ac3743580727678f74ae8a828cf5bf4499c2b68e00339761a484ee2b514fc0035b55d69eb8753fbb9a0240ca09c6d8ee0f39b51d660adc19584ba0ec63ea1c8548358f5b82c30af25d591e2ab3cd959de78c68ac5488b119959e88d9d5a8b727be54fe849b28b45bc71c98a301902cf2c6ecf063988b766cd8aaba1d484a67c3198dfb08a108568a2d38e298b391d70ec33ed2c70a2dcbee50a3dadad2a2d72e8620c9eda4ff877fb421b53aa911a7206e2d0d48b4c04685ff5a11d6358223acd958c791ad4117e5377c117674fa24230fa40dfe7f7d268c0f60b15bde692ecebc53f58d25222a5002f9cbcc25fb6b59eb647c43887d5ccba8dbfab3c968ac47f9ce94cf08b476928ac04b8f6c4ee2b87639c988996e50dfe5ba3d747ab9229a16c3892f101528e4f9bb3811ae43b4e8d7fdb495102f12f42fbb8ad2cd096b25998749f6aa60a1f85351ac37de35f35f3502d173761ab87c1da868450da9198fb76304eb476ee867dc360da61b69270c7e5457079664ff5c5c5795966a1efb233732cf5bc82e1668649a306ae6d0c35554688a7c0a7bf48746eda07cdf6cd66448e0ea82e992b45365928b71b54944e2ef96426faafb575e975336d4c40a91698f3bd0ff7a5d50b0e34f008d04d23ac67e5d6eaeb834337bcf3eafbb49dd60f26cc46b54bf2298ba978a65b701ade57c858a284ede3fcdad387c8ae101bc28f20c4a5aeb8a75b10e13fb20134bbaefca70c63a5d41609c980349110d77dbbc034f85c2e4d191aa84fd340acbc0bc2497a806d9ecb5a6f84f41dabbba21086093d815cc0bd1256e308b4a723dc6846a746d67cbd7169af671e1102d60b4433a9d1cbfd2c99c635804fc7d19a10ab52c2a2e5ab22086b1c1660de4048529dd00995c8459259022146662c0db496fb741f6bd062bf2c129715e5c7a6a1ea7b37c43a8fa9d1e3e56243fa5c72f1c34e517aa98cdeb62caee05035dd9381c32f048d66a2e9cea43e7d1d8acba418bc6063b46e75506fa8150a1c2514da3155e9aaf7310c94f7f74e60f6f9f91e8ff9f6d128a038a1fb9b2696f55dcc6dd7b5a561e330c243099fe3070e866d5f16b527ff9c4b0ef7b5c2ca5a0e3d9cd81f26bf4deee41fc230cbad9608c06ac8c373bac7f31fec358d2a50cace6b5229894b38c3508c2ba1db83e5f653bb8019ea1cd5336725e59826aca72c4563734cb53fc49241c0a903d31d786e871494ea606eba5087155ed7ec77d77c5a51a1dc54f7e3523d4d6b935cf3f0bf3821d16348eafa150a03988f0c6dcf5fd08c368d3b4cba70519b6297fb5f0dcb9b9064fa59e6230a3a4a668b1c03887fdd3537df1beda96e84eff079e4ac3bdd6c6fa7257ccd313866d34dcb1e9fab8fbae6d33543271fd1791b64a07803504e7bb16af50a1c2e8dd98221b1ef7ee85c0169daa6279d6c25deb57b8494fbda41adaafbf7a18abb25c9c8432b92c98f0c5f1cf764afd9900579ea5d6a20b139b91692156c9e05547a68d84a5f25920fa300a9551f80002ee94414ecf074118ceb923e2653fd3aaa943438fe38378bbcb0b640ffe491ce046b00b9579d9dcf64ae9b2074985dde49a7d1e8fd66a9604f585879c5045f9bc7be6a723c7c8c9b59b190a2ee7594358cb656a5b4828d48c53f939e6289e4fc185ca8bccd9750634876581498d185987f0a6894f5d77d56c60e64ffac3e2eb3002747e7815671f5e3f80768f02abaa4266011b83ffdd6905d6713ae78f841b57a8c7813cd8851029d5839aa08ae463e47138333e416db3d1db28d6b5a62c98af9932ec3d7c77565c5022b9a487105be4d064e1f541bec15508a8c433635ae628678191696382c5e8a44a3a4a27dd3f1cfd1026fd654e7c7aa5ddd708d85bdc147eb6ebc143407910b5889bafced5873a00580053a1a6dd5228a1395248d43b52754d56b8b6656f9858d8f7dad4ed97553b535fabee6b4be283e4c5f9b502b186fe5ba7d8e7aa8a58a682ce85425fcff8521d122c6eb939ec8ce8a3f302317dc0ef7d80d7bd0bc46f311ef99ac674f6128f23f2cf2d170185b32f558d2c45babeec8f1772b6d3544bdd68766ed50dd362520539f27b99f76498297ca3d9b7233e4bd2ba04071d351dbc676564ecc8be0589bad3fb0c540579ac83bf4b30aa868805b4832b8f1509a83b0fdca257145c9cc8585bb683663b61659ac1d523727db8220576acec9303b64eeda2b8d02994da1a4829a8eaea9a9294c5f82cee6e97ef14f5408b12a63adaeb40dc382a53959d007a354ee290e467c23071679058ded9648b1c9f7419c211b88a327f7945383839de729db7bbad765a286fa6f555e6225667b1cfb5d8d63a94ccd7e77e7ccad1f32779f4bf8cdb2726fe802b3a68b0fc505daeb919ef1a00e1818d2c86b1077231df4b7bd0ba082a453cc178db5a302dac06d2f8b351fb8e90b73b18eba488bc749ba78eeab84237ec61fe8077d2c5555e31d4f7a26bdce9591ea0afe72d3fb191cce40a9d916173d2099e4499bf1090d4cbafe31313b54b97c0feb3968df56a33d88eba2c817e39d581ddd4ec64f712444190feaf8c70fd74f348f00147af3ba4cf8f5feb70eb6c1f69ed2ad0488d932199b24880f9fbc5c41586e53f6e66a6809cce3716f728c81a995f662af650475b71ab10ea401c895187ab49f0fe364ac4dd636a397065bf2df9f6137ca3f6e2fa8cc2cef918f2de636f0f97af06899a96d673d8437b0fbcd803b3ecb8735bd4e718b1b807805b27094a5a18604bc76d9a9c2d7cd5219353e68fe60494510f981a3c9061cc8686465bc8edb6718770e071608e44768680bb478ecb8c7f5cf5a17072e3408b44be0300ecff041f83bfbfe090e88fac1999545c73fbaa2011ca6e43fd59766442f28d1efe30a5241a87a245d7f2998de2d1a21cddd9f51644adc0e9cc00ef8e6ec03cef346d728defd5876e507e110a9caa7f70756df0fbc32b480c73cbadd4bef1d8aa7d1c8d1f0c65993410838b275b0bb54bca50e9394997b06cd7d44e1b0bedb18cc64fa052a52fa721a0e183a14fb8a564f7698250c387030f812e1d4d4b09e2513dc17e611f78a6d5c13b8c2a86ec30eae1b5debc4c47d69eeab003cd45ffcc8feaf90f5851f2b3798d2b12444b96ced56d69b00cb093698b0e8f4ee2163934b07ca7a87d653360b7657ef29ebe362b98b23e07ba80b88ebf7337ac1854ed89665664b0f8e8c3e5a2b35e1b9a8d862672b9a8ecb29f3f78ccb9980aff5c83579f05f5fcbdbac0add6032e7a0de958fb1545d9a162ae634b8b8659e9899e357b6fdd913beb2c5e17ace92caa9c73f813aa5fff5d0fd902b105db14252814497fa3dd353e1e9f58364ce7cc14fbe242aa66bd97746982bcc8c026d19556c23fb20b66e6f5c7398f4237a4b33ee28c51f0dbfe3299c4452957cc434772bca3180a327810ef52d76738f1e09ca86bed21027e296e9c6f63ba2bd2375ce4d71d41365d37b81ae1850b100270d99536bbc407f4e5c829814fdbcae1f06e0d3fd9316e687328a9917e7904c7c1a010b2322a158928b1ed61753f4c389a7f5dcfafbbccabdb1f4095cd322c53b714202191b25549fb64e478b239d1af7a1068179a1589fe08fef38c3d723a5b7ce8a9377ab9972cf96c066a258c13e61a23acfa13f6b0a6e087e7cfd04a925d3265d40a676dd32404d3387a2ec8017f368435a7054be59a1a8c8627f73d921244b78e74bf7ee3a61aad84cdb9c78bc323f091fd4fc694b3ea79fc6f1c6da81ffa77cedc099ce9b3dea8e19d732a5b869291b3e03a62557fc35e57ce93018f79b3801f3f6ce308fb13ffca367297407d92d2e3ef87fb620f11fef6d52a47ea37c22cdcc54cffc1b26d3a7d6d1f35ac864e0c7d0e4e53e10310a100847205044a6d16de5e7ec2ac43498bae52c7cd664447f181f06c55fb782d27919fd25bd3590ce4546c29c12ca7171dd6544c5812aadf8715140d6de1d8ecef3d2b77449051621ea47a701e51431bf3bb869a9f8ac5f9fba2a400df433f444deb9f1766fdfdb7182c4a82c2f7a0232b4751ca4e877c60e92582478d38870ced0fa41607906baa0e96747bdc823f9151b74ecebd1df39a458c957208ba62a6c8d699827d7fb6e4779a8e749366c65cd9742a6eac2e4afe2a4aa0a265f43cbee5080264738383a45b59fb175b3b6ad05077713a408ee42a5913c8e6d124e5fe2b66d30554d232d904139258664655a10b9b665a68c5c4308adb221195e7462979a79f893d8d40b3cbd8290a86f86bab1ef7c4eee3a6ed6c7a4ec2b44a23d2a3977b0dbbc978de5b3aa20c3b956f9643608cf9e661ef9bfea2ed64679649ffc08d482dc3c90591e1af98d83bb7b5bc8c6b868b104750cdf948f5b3cbc849b1e56784d45965ca8bcc10cda761ee234bd4bd1d32808d1b81943c3d97148549e324c0e581f96fdbe3c121becf58fab1ba7bb6f6edbb770802ad84552cbd70e88490612708646f9845eac2efcc10061c40e3e25f453d1bba51f81e326882e88457e0981c6d4af1d5b9fcec0c027b7e7d0b2cb6098755da8d3bf5fa2feb17c7d8a3cf353630e96f860e9db6a35fc9bb3431c5f82e6bbfd9b6e29d0fc31165c2262e95592cef3ad6043e4f7c65775c711e4bf242c5e64cb5f71d01246cc50f6864f8cdbe1d552fed9955319d0ebde1811e7b0780fbdc6afea8870c93fd5fb6dd65907658617d6424d56b74f4cfc3fd721e5439e5d7297d4e196697cb9f6a815b1fe10a3cd1eedff1507cbd6c07b07d4a81ab068e517ff10cd1fd768bf7dccc6b238c5c072a8994153a279aa69890b1a06bfe661e903195343e7a271d8fa99b0c8d1772e74f2ce53a079fcdd31217ef354ab02465109e4950ddf404297c06cb1b3a31d199bc6f42aae39a5031e8acc9e31d833990e36c0288c494290c577071bd2659db8b0eee6788ccda2ac98dc2e8489a7fccdd9056245190be0a2f1952582734ac48e8905a7c83354041f9a01493a108c8e88f9f8789f64581e8aa6c73efe8e61aa20ad7b29ad8f8a563c1d816621b93b18cf19df832c29a1e90d4439afaca5ff52afb1bd4ae21af1ae9a2e153b03ba77315ae7667d3ca74aa4c11e9743d1af12c1371e3cfb7b1d6f2845dd2bb7db278a9f47b405c8d76cf9bb305fab74653a7a1e3cd1a022284936314b647afc8cec9a538870e532b6bac7420d77311bcf03f5a5239868c551b450cf1c563bada3edf0c39d9877b4bf9dc79735536caa2be595cfc215001f23615328cac43435e064aecfb017adb7f1721a36875884efc613001da3410d98b8ae79696609f6fa2fb4c7a5550c65be181b8e0dc18df4cbc2529a2b5edb0e1bf80cfa76c8be9447b7e709d6002022cf8d7708ea0c27e9b3f292d43b40609104572c86e364bd5c77095757c2ea78ac22436d7d19ea7dda270f2ad9394caf2b8800e8c06d645b9e6c6a91f951bac2e11e446aee717a50491adc114d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
