<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1bdc626590f7da6fb7688be7caef2e5daad95cf9a8bdc8b90dad2b9fc8b178204476f27c962baf7df7bbb872d2bc6e758c71c7ef941f578e13650a703a7840af7cba24de15c355e15f3c07ee56dd72c8979ccbaf232aaf653eaab131d0fbd8fe32be5fd8a6be12a2c3b963b7495edc12d17a3fffc20a736b6f53fb1c4c81ae77e9bb144e0302f17bc0da15881b2b1125b818fb2c2e1521ad38409516a16dbb332b1184dbf795e3773b9f2c220bb24fd5e9bf2bd91778582e49c654575e433d99eaf38de0c6d55b2064a07906d9cf96ecf549eefa53f6768fe0603bcbf8e19550e1f7a249b2068dc330920156f9f39daf24b1f50fba4576a55caa42b27ddca7547a39f226c3550d5974719212b206e719eed45e69b8035d1440da75568e59135356afd97df982f3d7bd98b17b41d7de572d46f8dc180f60d008d3aa19f11216d496a554b65d33b060ba95b0d3e6df527c1e29d513912c504cff62f8feee75c8d5f128be9c9b2e5809bdc50bf807b5ac4332ce27f1bcde07aeffa0feaea474ad0de3b5277cf232eb920cf780452d2eb70e43a946f358ed6b599ed54c0585482b700ad8087f2ee1701b20e05222a6eff390cfff3c916da019eb6e1b7532b78c0e1004edfacd74d758a150ebb980ca51aac2957ce33a09d90fe61462734695e41521d1532801f505a5aafafb25679aecd1c0a9c2ad7a71ef31ad2b71357e7941142582e87490340f53d9dda27f98757f424f9915b242822314a16f97c6658a72715bd13db4cc093140a2a30be3a347423cb6c7469f19545ad2c3811d1514dc20d4dedcb226b6ef56f3f71342249bb3ef5f34931b4c850d63d58c0f580e04bd99ab2d54051f203a4a2137a2a64fe97975b3b21b6b641bd913c402d5a645e28a7f6a7eaccd7183d39ae235c404d6c5e44ca4530e06553947be76d4ac0f9aa056e9c997e217413b4f1e867598e736a76aa462fadd08ccb3d7c59250d194ea6ab98db1592d72aec41eb2ed38f6d36fc419f0f4cc646f9861227e97a7b50b664e9bce1048275fb49bf790ea92308dd39d126b099dc7cb40ae45e4363c34715431dd20b751d817755744c6a92c41f387e364ac7efe8bbe702a6daa3b96025961f319fc8d490175ba7d505ec28e220eb93d9c5c7ff6b2d7db84d0600dd3e6e70a9ab824970c0c79eba64848c5377fb30da452487fb1ac94aacb5a6784f3bb1a1746976b83260c953975a0f84d6419fd0fd69e09c6cfd8e00c1db136f31a233113dd0495dc35a84b47784687150d639a9bd78565d5cc34040084825d0285693c8b758fbf731be6731db05dba3a1cb4098e56ca19f4a8cfd907c5ecbdd6f6d22c2c345bf00d84685e2f612d5ccddd9fd8734e7bb6f914daea9e848b30f8ff041bc4718d5cc83df123b185fb28ad97d12e25b2d463a44b3f61c57a0c7431f513b1c9927548dc7bacbe667f3d69a63523157e6c50c1542cfedd82c8561398efd1950b17f984b129f8cee6ead23dffa01e84f6e6d8c8af2452bea9c799b18d4972b4128b4d18c92d711f717b0244dca1dc8ed72f87669c64148cb32df1ea68621155487a6e2d197ad6ae812a85081bd39a48084a566a3890c06b43c53ce3d1d2ce2d7ca7833a94498d0bddf1cb31eab1b218429349010c2a08aec9c1f68e6fb1e79d4c909e28e9d9b1ce231fd9361f43db1b2e064f95dec4eb0bbea8f93e5073ba2289fdcff092d795b35c9568682f5fcff7df355aeccc154c33afb3ffb8d97d3435bfa4a8ab2c0ca01bf89231e5b9b6bff954d0134bb0d4f781da66bb07c2b8d87f38efa670bbf18429c417c408edcba52e49b4795717576a90a4a030a8b882c772d9c1b6725f3e18415db747e049d2a125de52003939bfcab93f29810e998265bbf1953f639e8cd756b2a0cb8b1672fcd0b462985ee33098d37be7403f25f5d80ce324de9ed91bd017a8695a071ff72632b895006123b671da696e868f42ee6069594edf28b1be189bf9a8db702c90c0db1bc7e940ccccf463165c3ea98a052c8befc8945b0c75f1206d3e37016b46cfbc927d1c43436dbfbaabbdf71390b96b8fbcabcfad15e524d6352f9648247c1452542cccbe97ed5d1740f115bf659e5d405168624f22bdef904677ee1d5d3c39f692a31e061578040f1c7801af1aba54cbeb5aedd1a7254ed587ebbebe4527a0850361534b977e9167f6e12002a5ce6b30ca3dbd292dfbd46b6657383b7332c82b671b6940f4e5aef5f12adee3128044db4ae19503b067ad0af567781719780c8432471bb492c9efd514525d2291fca97cf85aacc334bfb6af763e396b368442cbf849a3055afe03b6040b4518739881bddf848c4b5094a6a9e9d292f6dbfcdaf479404ff0e0e31f944c08c8ab6c395185aa6b3613e72f263b23e559bf6e2133a4ed194fbce759f22a5f44153912db274d54c202b79566f8fee4fadadeff36ed24cc383a9b39f5df5fddc18de59a3fb5da43c424c7bd132c92871b5517056c089de51707511a4ada452f7833b0e39651bc3b78c98ddd0200867e54242d68a3131614e21aa804bf8a54714a1270dd0384613c70ed03b6220c5bcfb7eca7825c3fde118eb7b174418f38ec66ad45bc321fa5b010212d9b1dcf4bcb7c750a8030a3d9c8a52947d4f1a4b76d4a1c82e570fa0c183cb2763b63e8cdeae78de6b6f58bb58d9d9b28688774b59a51ce3af2bed197bcd41c481c21331783f08e1c15d14cc6def9869b8eb5c7a27fc363770e4a8213903f36031455bfc8d94143678e6832aed7e41de9cc65bb681a276114bc01fe2caff2d762cc3584619888518d05cf45b47f0c892919affcc0379c3662ef82a87327541adbda2a94dd383429abfee9de583351bd529e62b9d3fd6485555f6bbd384dc808b14859342eff748c6b30b0707070e5d2f27db198e6aae414619c0dd79b2eeb50227c707df12048f3ba9eae345b9ad5dbc8ea05b388ec228581b8ea01d4493cba0ff7331be315d1394c6a64b270d19cfd1715c3c97a5ef482265a96bff7341fce777d081f8ee736550525047df6c6c5d88656d2923ec37227e687a37c86ef3e11f6d4ae5039c7cdacde847d4444db1a4b44e10f34dd8c3ceaa7db250de9b5313fc4c2545ef8cccfcaeb54d555bb3b532c725bbb2373f14a595a5981d09e5af7a833c5ee8a7b235abbaf5bfdf11f80bb50b2ec62d3add5e6570f69e68376c707c683393e2d08cf64f8c9656ff809f3fb422b394d03c3a07b878ce763828dac3b5f421083c11d247d9472bbaecd4a11c03dff95fae9592a1b6c88a214a1781ebf8eec2e3f3ad60344b70c810c9baac5c6e8506a12e2f318a1c28b303c77b8fbf48d94f2f6d1682308ca8e6b9e346c429f32bad302207ac8e58b70046c5580ad41f73b1c36fbc65b828717faade66d1ae7041e497fe622db4038554d4e35650aa816c1b38bc6d6ed7a74691101d5a6b8cc6fb5c664466e83ea838e843231112f3af6e8be2a679f150e377789a8b6c9189fa4ae170b1e46b3925b4f0e9306022ad0595f9ca8cfbec86808152efe88a47e016af50cfdf773aa7c1e70509b9aa5128e9f75b10eacb0085f8eebf1b3362f3ef7bb4a42f9b901072b3485bd204b3f0d3eeeb08a2d4156b9a967ce96d31d4355c58fc1958ce289415c9f9b4a8a17bcf74dfb3cd7cc7b943706389477e30895f621735f185252152f1590773291dd91d477a743172cb64f42c7953f2742101c157572ad8dd605c4bef9e7d5c23dfef1c14827a614da25dd9a10a284d2f009d2a1331f37893da3feb24bc6753bcc9dd4ef7168ec149679d231d15f0596a81ad28eaad549e3d60b6efa7f7741e8a6d673ca4d2db0b248cffb1832b49a765d97f6ed119ea7a5631acb2a3fab74fd313fc4ba1670c8bc368a9d3257e1d18deb526d95f125b105838fe3d4db97ec5c259d68f8cec59f229d603f3cdf74dae4ec7c05c5d02e67ef3526ac4df22fc9826b5316eed8ae6b66c38ea4587fc2d33887fbfc4ece70e53622d65bf3d3710ff98b6d47bda2dd9cc00704acd7543063933550825b1aad066ba71359d0735c4a7f89511dfad6fa3173b5b34df4191ef106eab1cc3c8692fd533b0305e7243c3555ca963c33310b964cc75ec49dad9cd805937808f39e44fe51094c31e38c5314551d5faa22cd5ae43c0095a62cccc2c637661e12ef610c7252dfe6636a11c153daaa4f3a7e5b4b6f3aed567d1380070376f7ae38f87bf5bbc68f1c68e13a0f0a2f1f9bac095edde0ad593a5306704c0af1123d20e61c52afed0e84177c8f2808a6d04b1f389c048774605e52b1fc2ce6b6884b1e0d3aee0c28e62a26620438d64652aaa070ed006e018466bbd1ef94979263c4d1ec1a279cc70c2491bf80ca76902dded8bc2221cb46fff13cc008673a06eb998ec196304114807fdf7ac0dbe03193a5996b079113ba909f1d758a549f1fb427669a89adfc1dfd1409f331196b4ce25964d3c7267a8723f8c222d2a81531424d919534a1c79adda6fc7a602e2c59160b08762fdea8a9e363700b45b5bd1264d03b04fe94c71469621db2a19de6ac679edc1f9092d0006cd1e0603564258f1035c70fc08708cb3b8e5c206df4b8f60e82c48e5902134357cb8f1dcfb988e8aff887a532ac2a861aa0c16656484f93524d0a2acd8312e61eb2a953c0028d5ce0b8ec4ff553af27f7d97295ac8f030f13e8109fa7824f4da7f5d9eaf161ec98f526beac1bf94dcb02b878953ff07e65eb37970259fd26f366b665dc698be9792f3c6bffe4e9460a58ee4abeacbcc68a6e9e807a565947b84ff5a3a05439e763d6844c145fb186fb3bbb7af550a47dec7b6e7fca4204aa1fb9905982a4e23971cc62a16809fbcba12b65447cbf92bc5e95739138d17a0b0f283efab19319b90a876ff33fea9373541e8eb80d79153815eebc34d32bbfd8dfbbaf1baf1d6040909746e6a0e1315660a6d4922bfbfa72b6668a839bb7ecb17bd0521d1578744bac73ae23f8bbbcc7d509076c65d0e00680c8c1e9fa59a8547cadfd76bcfd0c763f918834a7a572859cb2656c5d74081a7f1144af47caa1e3b4c113daea7158d4031c2e06133d78fb3a509fc2dc422d47f857223c12fe6b98a0ded6459d2b245b29ed3a9715483a65e698fb3b0bf3dbacb66c5e5d4207bb70160552da190b6c9222c1430d958687021f04a4a9a33d9dbcce12729e90f3cf73ab638ed536764d9a6cacf5075740595ae0aa98590f3eafe483e4240185d3fd96c0858d4bbcaf7ee892172c95ec7d0e6a5179fa4318c1e8a217075fc94f5a8b9a054f62c1731bc4d505e7f8eade2bcb52e38e1ab672e2a582fd845c7d1a8696eef70537fc6e9d6c8beb10f95a2638a94a47748e84f458f9ccfbe41c94be47b241ff1389647ca2b4b60c2257ed70edab8adace7f8e50fad41ad9bdb551808a02c9051f79895dde09569e26f3f6e3593d118dd1612c656e8c72e9d928e6c514a5d45c881d9a05491c6ef74868188030dbd4b054ff613127f3e044cdb4c21b9e694ab6c2d802ac3ba099e057a629b8f710e2f53b14cde2962b807a119e7758d0ba5d63eaa85856e73a0ebe15f9f01b91479d77702547228ec3612756528b27fafafaf87ae36338d579fdeb2910a55c2d10b809d0df989915629ecd02d2199ccb2443be2bd8a140df82847fec080f8cfacda33043cf7fa2012d96a325307e8d20a991841468622e4e1e2b9045778006bca615ac00f2864a9288f025a71140bc3f8c787c565ee2d45f5c520791aa06eb5fe8645de9fb6f31a8a02da1e0b5bd47172b14d024597b5332694b795a5d4b77c9d50fd4b6103c5f4a11951561ada6919cd8b027690fd1f6a0009501e23a6dc081d642316674e21a94af278d0b3267350149e29d34be114fad116cc874579ba0e01e1d93a35ede43b418eb34b6d5772302c623a7707a6bcc2b23d9bcfc89ee0402376ec67f7e3ea8281ef324a67d9d1eda4b014d5a5308ac6afc86d6a5bdc394fb04173f71950787b0ce553218d761b29255247da1e16d0d5c369945041151db3b4619bdd459132d30aad3d12ce15d4f5a54061a0700eaa50db32d90c7934887ffb53b0e6bfc53f9026af7630470b9d7630caee30a6d5aabeff19ef1998f7ffe6b60d360d4075a17fed17733b94e77d09e4007a7fdc85386b136d88bf186ec5c18cc470ad425b4fb36f8e9f0f030a8dfbbec4147c7f2c2b0e495d1999a2ef04c8f2ab6ae5894e029b4690fd7169e5ecbc7b36225d5af9dd44cb5b5c4253a8133d7cd64d3e342cb49b9a85f2fc92a14ca74428df909d73da404bca113e722c2d60310959563d0ee6559fd78fbc916cec4f53a5c2e814c1cd02a67119c3799ae2b2e8efc3a9ab9ab3b0e8cd94a3d4c2cdf9e40683068a7a58df3b25f6221ddf66be09ffd2f703113b4f5378f7aee7c72652e3bc8a463114e8c7729bd642c1d0e55bb618f2d881d9ff5c691fa632a8d704b7e7b5f2f18ab5496d186aff7034fbfad8230f0c4320d1b8f7088e56852b1d336be0798d293b6e360f5b88972ae87c67e920de02c85dbcf4d3a0603a0e6ce92cb0575071c9071824f34c987dd1261af3e4e963afed126c880454fd7002b358598c7ba1fb16d038e459d37777a2f423ce47fd678385e9932fb17cfbb0cf95e453562ffb3f031ad08c05a8550673370adfd1eddf48400b537bcfd9ed382cc07f5b89f3c5472e126a929c0c87b22aa0a06880050fb968d820d0a1cb89c14db5db7463f1509d7126da72a76ebb9a823d964edeb5efca4651040a83fa8a0272c249d55d4f25b9804c99878bdb80e8175e98d0a6a8a2a3117b11e02972fac58ddf085da118299bf3d1a706b0c8a3fd86d5a840ccf970841663827d20ee7ae7eed132e0bc33ad8b2e7bfd49c9df6eb42594a3e65cae6d05b801cfa5747333b5f8788de30e267d16c3cea1075458d618c789306d35eed7c5633d67c3f40c96871818d3c5a061312018ad8117478a6a4135678553831bcf111bfaab9f20be38864b3d1b074819e8ddda7c2b03e12859f2b039f9a68b70afda034280709d001f3a49edcfbd14feb399db8f9a8d1559f6551c574500f8c46c29d9f418de87d1f6e42204ec0a6eb8df979fabdff60b9388413b9d6eb5c15a3910e78a242c1b1a490cba72c59b0d8ef5f0639bdc2c5167362cbac1ba8667303d9038593272798dc788d2df7796122b2780a61002570bc367063e001bbad9d6494e3e1fff0a12471f4c2da0d319c8e6e477da8f38d9eb5577f32a94f30a6f320c69be3401fe44a588685336b8df3298026d02e6bc95a05090d4db9e386d4b022d101f627552b7e7bc73b90e5711605f63ed9f38592cab0d963deae4c40f5c15e06134364cf342141c784029e1eb4ebd44a138cf80ce62398ab836cc470d92463fd52b0e486a5470096104c66c16eeb1c47998fa2509977b3cf23cafee81f0cdeb326d93ef528aa1137ae7c5c79cc4d968f639142decc2d2b37746f288d42c26b51258845e56e036b208227b9b7a76438f7eebce1a1cd79449dfe1ad3023b710b90bdc3adf76a5017a1e3bf1796550b70e34556fdb543eded2fcff74a419afee2e0145f69391234ab5ffbdecbfe048c1d99bdb9662fd4c5d588ea2a783293183859b68676c5e61b7d1a75ee05845668bea08869cd76587d577d542723b5e19c71f521e1c72926cc302eee22f99b6d402bcebabe6ab4ce2b118f0cfe56697c949bfb663ef2871411da94f5ed4a77f6d1aebaf731aaa067ff250fe79bee589ba7ca34bfd901ccc782f0fae4e3b3b97011388dd9d2140da8053e7f76eebad9d0716e3b3e753eaa4470e232bc1da1f83b6d720f2f7184e235db3f527112ae60c5f28f1ec4c0ff0ceefb5223de0e36e767989c0c226f4ce41a1f79f177ec19c01445ec7c248c1bed79bc0f81e7da3f36d75e9f5bc8c50405bfb0ce32664b6cc2f8ffa62e9d7bfd461e27d65350ed1d04d5b348fb0e67b9b2400b5406a994b740c68bdd845c639ac642b484456482e316a7d5f08942341cec43339d3e112e0448eea209f606a8c88314ff05561de336785013a9af92536904c713be17955ebb131c278fe7a0b72e5b57d4adfc9ed85bf41eec12f7ea764de4b16745a3efa8ac45420b3799602e8f9a5bacc1f1950830728336c85850db0e0f87fd78100b42f34548a214526f99b18e6026b191fea232be1ad240b64e1dc6897bef8d3fd3cfe69fad703a1dccfb50107ddcf29a68f99d1f7a71c60089fdf60b401a4453dac739a63289e0a49a027aa9b1bc122859d92797b3eb7bc67e669b4ddc9bf0c9c4ac6dd41951628a818ccf1859e6db7210a369f7c8679292e33c972f38b2105678ded2cc69839d729b34b9fa070ebb544b6012bb6aaea0804c1ffc0a986971ceec4f19d77dfec59c67fa8085288ab52aeda83a4cddc9776e6dbc9e724cf450c4b4eb17599533531b50b9b8b185054e5085721c211b146e1ccecb930697bd2c09ecf086c76064ffbb2dc0d04fcf43598d49eef8f1641404cc58bc8987ba0a7261d86087ff8c6c73a515e6aa0b49925da460d92777c668a811cf2275a0159c965862c2792029bd012c93ace433c797abc61764ec8c5677071ff73843f5a1f2b785cc4ba48eb2a260089de50074d3e91369fc1494a078b097a00ff91dc8ed2761f9c34d88969b1e29145530bd5e51eb604d6324ca232d7e1092560328817a367f777028762d0d92857d52c105006d790d74ad8b62fa3ef013ba5693098b7ff79111ec1bd03562e1dfb2a002eecc830ab766d63ec7c4edd03ff759e05ef351365a12963a529dc047b4e6dabbae69c66896fe919fecaac4c0c3bafdf8d0823fd8779b43c94c8d26aec60b9f2506fb61aa37f23955cc189c91eae0fb87c13de5f0447721bb990d34df928e5720b2484e38912adf1a70b32cb432d5f5f890c7fb42b9ce8b1af33e00d2868ac935f6ae5d063a7a7524e0e8bf9eaa54073c00bce14c6256b73e2ec16c2acf4acdd4cdf2d90c0952d542b3fab72ad5d858d6e0483028108e22e52d55a428cd92551d351a344d55e3e35a16006f0f37c9049d30915480b991c2f81c29913062de6eaca38c4edfeb970c8fa491912189c8f9f8b38b2a6274bf29d3b70a81cda06b7b8cca9928506e1213d1bc73c9ebbd2dd0aca59af60e885b1b0c2b0ce6af45887cf055a1dadc68b593b153818e74527b4f4b0a945e8d1e1bf9d58d591d13c9a02b44a72a6b62ed51f655235a05f72c28ea773a284a97523169d2177f080aa1f437bc71dc4889a0f5eb0764526a4e255c5d07616a2c3d087dd83a37d6197bf681d70d80c8693d7b5343f93080c5cc8f076e7640b98f8f8b8feb2e94520bce1e3f17ddc8edaff7085c9b95715997ec75647966c3ed48f96781b76a4ecaa4308213cd59d6394d7633f706c08b1f85bf31634ab5e4300f7b9bf8696352aa9bee0457dd6464678409bd3a330664939ff557a56fb257fee0617362c345b2319535a9fa8aae2937dad2920578a8841b441ff7145543793fa38e71f48653b49073dc0d0fca230dfa933f8cd0390c8230400470d4f956fbb74632793cbd1939121a8905954e987e1e7652ddcd381d9a09a351ea693ec68077e685a7a20d4863a77b9799db4ae4448cdec9e3f621984368a11ebe1380b6f1dcdf6a36423933e55bd8217adad1180e88694b69773fa38bc4de2c84195e625359fc8c1271615c9155ce493f026d46f9a12c247e8f16ceeb0c6fe29c7229feee75cfc0879d06c7b9a562df84a275d468897e6b7a422c690b0fc433d7d0b5e0d202a2cfa6fb5c32fc1eb9a0a3f8b96af628455498b94deaacf9cda3363c291ab262f00c2e62dce1d90b8c47da4ddfa35c596d2dfec4ecc23d87a6cc258cef8aa89a2a9438e483c712105851e6aa63f7b8d6b1480e5c84fe54e70bab424522e41f28efd9ca47b34040ff341dd97d1c5d570d0048a05559ac341e8a870851e03affff1404c0cdec948db71f71e55824fca0426b389ded2924e2de2805f2c94a0f37bb8275e6cab58eb5505b6d43740d9f4995c72eeeb3af3d9d40263d2bcfee6e07eb508a3e76a8911b7d6a45ff43d4f606944fa5830943f3276b19cea24ed2b105f23f6733c61b02c0e4dfb43755e5b210104cfeb50079cb56f2dfd4f05a96c2dd7cce16bfd4ead8e35acab90abdfd682d2bde8bf1dc3be35163bc3e9bd8d17c1f6d607813c7d2faa8f9bc87875bc292f4b37315823799b6d17c6a77d919b1ea9a3f1473509aa12abc572361d8c7c4bf6494d536ea00e68a4ef2f334f85b298401e6c8ad013942e480a04abe889f649cfa493f8ea46505783565eeade527890ae7f3639b00d02ea59461bca1056f2dd1d1be57bdb5769db88f7a2881b3e25f12c327f6b08a817eada2c6f1c4fdb3e850fb9fda3fbf9910c64d7b13247708273dc60d16823e88b400f2c03b11a6f6fdbfcc0c02d22d1e395f155131d46595a2479b22d3dd1033264604dde0f8c795816c14f84c73dfb67bc202322e3295cf81b6d2fd1c3bf4769c63e93a9489768531ec37c07cc40c83caa0dda8309884023e99567bbdb1b8b6c36adaa487eea60d1b0180335981a5997532df2b97e512c9ed4f958c4b7ebc3c544d06a7deb90077f0c7fb98e8fa6b92bb154d557f80ea26f2a08e5004dc63c29e136ff65e82ee1e85b5e9fca6a011b0d61f453f9b5070566106fce78c69ddfca6a5467806c21e252057b29f1f0cd0202865fd04c9e50a2f0048368074c7fdac94ab4f3898fc1bc86385a1c3f50f4a1d1be8f42270034025d4ddeaa45edfd6239673601c2fb6383e15466f1a4ac097c1fd373ce0b065eb11f8a58ce0908b7c66057109c17a17a41a66f0e23431ee4d637dc8d5b7139685562cd2cf9a38f8e39e81f64b4309f7f17f4aca3be47726f8143baab4a760f1341183cc5c9c77d289c8770585781b0d9916a3003c2f702967c0f2575008719410d7db6901808b9e6112903e1542d3e7c0e289e0a0aee4f1addf9cd2f67cfa7cbc45b2821a47422fcdff1cb2bad42788a52e1e1ddcfb5b0d7f6c95f9005d6373d81c4ab7e36f6d09eb6bbec0fe0372d4b3f08d51746d0cf8d33a820c4a579ffd87bd85f658e09c458c14b1f047a56426e8f5f0968a92319b83a26ff776cc69bcfce8cd57eb02bbc9c4bab3783861f7debd3405575ba11f3a457c1b598e9cf4494baa95f280baf23feac802a2b2f2e152e8811c319a96f30883f4c2eddeaac6d658fa287beb4938e7dc6356b9779567e639e5e0d86e6fea6e2de979ca2573aa76c1996b1a94b1909743176aad1a39a476581399d1b4d90c66a4549e6f744913159af9dcb52db90c2c5cb6283a12d364243bc0c873911a67dc32bf6c22e5c272d36892b6e7bb725dd5a15c9d9f2bfac9469d9ed5c93e3ca6f07f3250290aeca0379e1b64a7fe0a4b68e604497308928b0c167032fd483dbb64c03493db0a6423b270b5995736bac0508e08314a9131120688a1f7571accb9fff65084e8e201f9e68cce8124aea6c48b2a13f75e91290fb48997f693c242e5999ef580e34cf800647c35b194c5e90865c27dd17a983afe4af27e680873f8e32a61c194d78ef36479014c446d5394611bf6b59bd0da590e1f00f4f7f41ba5df64a3cecdfd092bca0c17529bc4632cc74f82a5b5fa0f4a91ae31abfe272215b012802f4d50b0f85df38e2ef1bc19b4825822d21912f7221eafdcefcbd87cc252f8bc19a55c1c6e163a328df96e524a4291909c3294f0181aaebaca6392886564a7b169a04f084785638a5735a11f21ed68fb06de0170e84f130c3dccca0ff3e656a3486751d1793f67b9111ec60363cfb4a7c7109de36409354161f61f37588a38e160a81c77e5b3fc4615c6e8742c605a3db7841948361fe2ef0c35899635c5940ba230dd47a015d28db5a02d0ace4aac7dbbb23b4418b1ca499736a2702bd9c841ec283ec5f80d466de22c09e010c26e7dafa79370ab58d44986aed5c380dbfbc3903f95159b7ce2a43b62eb65199b483c539302451c823c7396f88024d26e522c6f97bbb646477db86b3e5892df9f8ddd61e5843ab0af30b942d05e7a68e175f6eebde09517093ada442fa8b6da7a35fa9bc7b6041435ada91e9748c81a67901e5871213d5952483665babae5ce2d62c80ed675ae1f979343cc308cf1106c8e73fa793f4bf785d72e8b7fa9e9080bdeed2b7850a185580c907b858f4ed05a0357d2833d36e87fb5e83f4ef0b0aca848adb0f4b59f28d458618c324cf413eb6c3244fccb0425fc8b7b33b05958178f630fdb41b109b3a18fdb2fd347998b1b5cace1eb3779a1192a419d5c8a5a731aae0afa7c58eab35bfcc0583b21eb7af2ee054350cf6dccea4a29117a5308a9a96095804ec466753e431ecb1877d395069c8f815dbe06936a173843eabde4ccc63d275b7dfe1e371dd3913f728e36824e581c4b2b07161e7d0a1b0d9bc5d99858feb985ee6150bad160fe4159407178cc9bc26693ad945bcb1296f510ec9ffdaf69c4981693477f9d6fea2f54d42c9b47d5b75c0e762ea236faf203ae8fc8d93bdf536f46003025ee54d28fa470","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
