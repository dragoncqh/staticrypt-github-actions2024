<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6acb4cdc55d8952ecabd501d3878c5fba112e06fe4298d7782501833f4836bd4b3ddbd1f00410f20e7b7f139c78c73ef19878498b48814f5fce4bcb8435f9cfe44a27dc57ad651ecb4e44e99ee3521e0cf9683ef009559e150eb0fb2fef579a6d550ec36d8bf6494091a8bcc3177997314d57f4e11f487ba9457dddb00328048f42dbd0689d1d2460ba5f1454270ba5457f9a4890e6d5b6330a3a327a7505b80d348543ddae9ea42f5ff4b7e73bc5353a2d919371996bee93670c482872e2af528798e2e9262cf6fb920814be4a225ba4722ea8f665512c53052f7fdd1befe2574de6673c83a9ddb860e0f1e8b79cb0bfbc94d14c1929de1e4254fe63d2cc0db596e2832ca91d689b6537e658315150201e77afc36373a2ae62f43c3165bf862040f2a0a94b85ea0c41ea3aa7b7934788f4b6f3036e7df3e3bcc2e168d9b67db07bd1e86c067affcd9b5abc7ca8719dc7f32a184ed72d1c125ab223a5da0b84f330e6d7e3284979963d36a9eab1afa642a6e1999dbd534b008a38ca28c8a77e8981fdc0313db076dc9ad6a9c6ea08592c0c1d071f6f3f589c7c755ea61563036c8f8993b7f259f68354d6d77fc06f3a1c610d82b538e8e56024bb6f2a768657494524117e1dfbf5de209e7dd724e6491567c21474bde31454bb98f02feb600181bb768134b74f5996c16b3c9eb11ba20fd957597579125dc5854b4e9fbc84f19f8416794ea1b7f9d3e94933ec4911c0c0e285e3a8f7ae43e2a4792a4308d06c3621cee300d1951d712653b725e72fc07b042168dac244c1147c8f0f95f441b9f16e64c787d35cbd8095c065d6b8be0d907fbf1066f4c91e79e6ace5ff9ea6a45aecc0ae81209f4857e975fcc20b1affb9bc972ab051f4c001531af46f95fa0c04b4c54bb88bd0f3d06d6f12d212b89659a413ca21241d093a2371fe9e503ab709e9eeaee69e32ea28673014f7af2f6e0c1098d687988ef4d8f8d50f5d947a03a684241417bc51679179d25ed0867eaaf9b7c9212f9718654343c7ae16dbf1661f69122384f45de6e513f5f5d58449a7bc1d51291de9cbf29899315a5b35a2fe052e8334a088e42a0765bd472a6ce612a2f8bf42cfac1768ad911119406730feceb89467da5ee7b189dcfda2bf5b82b86cf3eddb5d8011c77a375ec018c7934ded9ae47e13dbc33c95f65adeef213d6254c6d7dbbb2faa86f0a28a616f79595940b2d9b53c7e6b6bfcaeeb2de5ee3665e8b47a71054de184076c2dda5b9f9c8f1d37f456722d944064991ad8a582a93b3a1a91b537c4a3d3af734d715fe3c8bf5c51f9c6c39200374378c2eb19ae71a118e8860489d44f2d9b36946641b9a9ffe4e695de737221f04f578d3a11812ffed0446bfcffb79cce02ff5c53917b1c8565c3d383ab0e80c6d6cab6fefaec92dafe5f42eeb27cf63ef3f5b41370e426ee624a368adff813293e430aa9a5014b504d17bc013b033fb347353abcd473d635ff266eb7c7411f8c9959e5098e7846d421194d4e6b296c8475301aaba884f991662d1f836bae1123e646f660cdfd80b1895a499bfc594ecf60f8af92bc002443ee456343967ed8f7c2da72c5d265cca7f5054116a19613a3cc90e6dbad95ba8bbf54d2808b26aaa8df13be65d5faea156a1b030bc2ea2462879217257a8ba6fe1fb95ac1636258fcb4a496ca8a49f11510b8d2c7db32384dfad2a3e86c288f3804c0a444fe2dac46538a7192d9f2c98da9c8ee98c2e70913e4015cceab1ed9abff73eae856082b4a5bc7cc7a9f3537c58de2ccb51424fb5f7ebb4310d4b26c07eb3b3860dc7f3d9e73e66b1cdacc1319c05c475a3481c3c02ee362b5625ce45ff420d6676a220d3cba2fa7e7d7e204d56572664d338f12c6a9720ed692b638e86ce4d884177e32e0cf5c99689df03c11efeb8a62ece54ac9f37e4c8b6a74b3f4b777adf82203c50c9fcb579cb42508bf28b194e67cef19385770dd09db7c5c058871987d36ea919dd0f043ff7012f78158cb0104e6de5658164fc35160f62c8fc9f6f2f0788f64da23d15832be6c259109493ade748a4569481994b2033c2be9e0b855e955512aa6a421b5e6caaf977f434cb2d2b662cdda1eaa5aa5af186a98bbf1bb72565b60eb3f5c5320ad9edc09790f6f01e969e446d6ca5374632755f9cf5dab2444ab8171f93114e4b2cb69536be1753d9b26b9cc9f700cdd19ea1610c38e90551b268de29156d146c70389a4d2ef83e4fd0d98e4c5dc9ed1ecb0067a8d3fd018c31d93c871bf2f73070641263b48f686680a707010973bcb35bfdb6e7b500e7a531f01e112b067b740d65e187c34c46cead4ac824ff90c431bb4b6d2853209dc234543a2bc431c8e557f0865ee4b7c31839f8b5c64807524f188617c4a960c049cf86de0259484b850d8fc0be644b84f7ea73acdd6972701a784d9bb3f36046f5eae6509850484934d84b33d4bf56fa29850a7fa9734fa2df258059717354268c5da82082ed50d02453269082af0eae288df9d545a5b2e4825f6391bfd3e060bc0fb41264609b698a9a984db5cc09b36ce22322a3d63efa9cdfc341e5944c0e55bc01a472997e74e23627653b8f3799431f006c659146f5d9d69ad21e2c669120d17a04e7d02f12067272998fe94421f249d2bd6116a00f5eca34ffe710a94b49b212bcd91300e012422d33581544e79d27703a4142710a639014aa4c1de48473acb7ad0b327863a41aa850b3da4072e6937564553d4e6d4e69043d05fe3b39b808d64bcc73a7c657395f19fbce5bd4df2b0e205e5f24e85b874c0774e3be1ab32b3c477583baa4303170cde9f909e22a8e049d56c7034979d11aaaf7751fdc5db23495a5d479dff6fbe32a94eb42cd6a29f44e6a35cb83e4dd1f2bbd21bfafc18fdd265f12818c5c54daf4d6d3ea9427f234a40ba1c7046cb901af15b0a9d4c317983cce8506f8386a74c294729231388bfa9585e7927527f4181243ef930bfb058480cd76b8d715df61a76946bcb022565cca51e1f0169ba8117eb0c552e152bea13c0541281a0acb78bd1f77e218428507d7b1afbc1d8d29c43269711974bb55c94f0307a230d2ff16be0053ea33cb92dcdd83fe7e71a6ca3d94205743363987b33d7621b45d6a6de078540f0c81b97f8507da55979fb7a58ca2179f64393f64722450e05a1062796fe6dcdc1878ad65e7ebac292c14a8e28b504005293fa9784aa9f42a20dd657128a9341d59032ef361390a4b1e1b27dc10a89e788d29a8b2573d6d03adeb02d89c2ce18850e4e69a8915ea2214cb6bed8119ccd353774f62b816062c3f70f71adaa0e4f6e2e1397adee7aa93c0619252fb3a2aeb1d1c0d2036430b1a26f20e012ea48dc42eccdb7922f4f67f1a1b855bbfc0b7e1e76e6c93603f0c721e887099b76c87dde69984ecb8312151a744f911ae0a660207ec73499ba6bb0f0715dd1bf93b064ef9e9e54c00445fd1067748187de28a28261f944b04e47052cb41c98a86b0544bcb2ae719331179917bfec6b91600d1e63ce78a43521bdd16cf99fdb57a8105f75dcbb7c1701d11a218b26e179fca1572ac9f9bc9dda14d7c71f25898e296c5776d1c43e17876a6b7f2ddb491341b3e872e16e8602363409afad3d9d3b1c1b0a25f237524b098d12b73001ec491cd8013d8d62c6c5bdd7ad1a4dccec64fbf7949090fa68524c6fe75b9b3e2e4f837dbf06586ee338ea5a0ceff2ded30b7e8d4cc0a58bbcaec167dc625d9c551f9edea6d7e504f746ab0465e192ffd76db455b4abba371f4fa0d92904dadeb22cd7e8e36670b3b0828292fa40b4a917c463b56cd33be2508e44f4bbecab6a98cb93f7db0134e01b8cdb1923721361724f492bc1d4aa65d1354f28e5ca279124f3b255e8031d5e1ca7dbf14f65aa6b7129351dd48c568144fe4e1988df3d07842bd1a927a3638f5aa3a7158ddc9c1175115ba810d1d6bb9f01ee80fabc5d83a64f28b6b01765e19df4a058a1f38a655b34055dfa14068ea1122936538fd1f185937e7a78e914386e0560489ec467545755255fcf8d3c1d9278400e90bb5917b82e1f785b368dc19e30980491add104187bbba4efa1de737f003e9c649f7a5f7c16cb0d648d378be052a77c67f26c9cdcfa79b62a0e6044bc59d9eb6b48d78527c7e1d0f435ca07c0c3bc7073ce1d98b3124bfb1b43bad9c12d9891fe5f196145b0c1aafb20a1ba76fc85bbbd5f810ad62d23598c43cfbc3ebea37af73f8dab0ee83c864dea360fb4316c60a35f1ad12d7d72ee716dc206e1a987bc02d047cd0df93df7e66d74bc3850bac7c4e1ba2fa38b2b4087fdfdc895268d4097147c7f728e997920122da40033485a82fd08f581c56b41ff777387c215c62cd40e607f5da0f860e973f118d490734b2c85caf1bc7b423bfd34180ceac4d0b40ace76d25183a6e27e1eb5212cc08e68ab34b9a1efaa0a2ac8fcbcc9e4ebdb3d13ea1e8ea21f1ff3faa3480cd19872f01da5ba90af937682ee6f07c21f64a93897b29106bc077ba6a604d91c01ee15fe2c4db4ab0dcdee8c8f429f7cc8df27bcc35ad2a2ea26fe84d9b0b77b88b27ff79d666ac30120b4ceea4d8d187cd78c051e8b1c7fb024d5020f650af597fe0ad864e7e3e29b9cc578935a263a3319cc606a8178a3eab05ef71b92eea9476bb3649304320064db556181286c030cb9a44464bbb40c628767f8699c092c079301b500792fe8c9814b61b410fbdaa2442dd7cef1b26ae4ebfb7eb7beedac3d6af5fe223070bf7e5b083630c6d11e7ef3d570137e8d2caf074d17104a7f76d9618ce7257f335d088237ab1b4ff1375a7f241de70e67ceca83ac00252511007f0df4098e756aad1908b77015d95fd799a5be54b78d24bb642af6f8d2e4033277c7668eb8a3767b2bdc612e25bc54facac11f8e61ef66062861307fb39659259923e131bd5bbdf6c80b1fcfac0756ec928cc08f4e234bed64476a78b75871bfed9db8871f208c56eae91b439819b7b39b2bf76813535f2b3bf5f35b6dde29355f4c71aec47efb56ca3a146848deeef9030999d80b5e931ed996cc319c64f1a96224ef78583b97b33055b3b91b6670c1743c3bda982ba446d78761bf3ae7c5425584ddc85fa815b24764dfc751403da70f2737ed14bd9350f532caf0f1d6ebf7e8060020793f7d7060be93a2f649879d109321c8f179e5f7dcd5b0ccaf9666fa7ec404c20ad4bd2eb13449b706d2ab68f76163633f9f95d0a2fc193f41a32ee1e536b020010ab7c096767bded137386e5a64ff3fbbd8c08ab965ffaa3c4a4819d26cf763222ccb6d4416b9df3d223095a912615aa142d79daa8cd81d3fb2f489d0d1467a3f528bd324330d0e518ab9343b621239a7f870b3bc8463ba6de0583ae164fd7b2e197942e1eb9cca3148cf73856cf493820ecef1911317eeb64056d275e30b462b777a6179a8a102f97ddb386decbed2ab9f831c4bbfe26cd8c5514dfac87c53b90360b42291fe4e0dcbc4932fc10e3e0f6f176845d9ad063e1a2567e86a49a36616a54608a20325cddeec217e24e5774e95ce03374a4adb2cbe7affe64aaea8fb3f2e0de33a40506dd619c88b8c2bd0a315e8824e8680f0e95e559b9dc0bc96f7a37c1a2050414d46944cf29abe479574dc3527d32c8684901da60d6335e08a8d13a3fd976f940cabde658414e460c5e0b100e9f4cdc56f18db29dbbd9a37ba9883307480b9595ef2f0302cc80581c3f68fc583036f4e3c19b74dd772098c9824d5af66b89ccf41bcb10aa6c052a05cc7cd6a594859b05a0bca56acdf48ca59402ccf62abce0486dc8dffe0af2109d53585cad78ce279057619c1e644ca92ad7e820e2ff42eb8c2f4f2fdf6f3e0d882dd30bfc88cca70d87825f437fc4d4b65909a8a31a7ef973fb9865b96f44ba86ee5f236a70319d851fbc1d7d8dd00254a6217ac207209afe07394e7ca186985846e7bd800bf2e48139dd25abfec4d40c968acb1eb19f38d525d5c7bb4f0ff40b048c225198b378bd575a3ef0983ab6918d4f0e3de9b7eba2742b846364185544bb394a8568deebc34be21b398db99c9008c79524effb2fb4f1e2241d5f92f8059ad28738f66bdb65d1b3c9c492c6c0e2c87ad3876f176734e7192091d675b6bc3bdeee65e5867a1943ff8031b6b274e71dde28922b40887377b1484b66e242cb9251e66cfcf6e4525427e469a9406ceba2a933fba417bec51e5f7c0987beb862a1e2c71816d628348351c716786334984650e7792b5597a2b1fa874a4f1edfbd48a649af4b34249f0239319a60f3a83c48fb89c7cda3899d607307352d012b18061e585af095ea367c194bf7afe4b95c694f438f58865403adaffa8c61e197e5eb0c1f65f2e13f3c4af85cba6dbcdb9a3549c894b6e2337bebe302c0e468d798e4a99313281e76577abe6ec4659e5fb69119690612aff8ec21a7a6fd49b4cb1e193168454756b31db63202dbf3fb7094293300bdcbfd429db22d88e0731e4e73c07ae257b818149a8621aa2b3cc534c86dda44010e0f250922502fc2e686d0033294fbeaaae28e92405bab08de0863fd6a71db0e37f0ebcfbd4cb06f7765c636a7c3b6c94cc73611f8224adbc06e620f7b35b7164af1f6991ab81d2b21b56439af3ba99439a8fe60b585ed3c1fcd4ce35b96171d951163b1534e6c4323ad1ee9a4527e8fd66f13f3fe4aa36a36767bbe882256e806ef2bd10f8d17320597225bdb9da60c387be93174400545ac688101db2803081b6d96f52cc254087fb4b9703fc88fd2fad355c0abb33f3b8ca9bf49b6e3fa3730bbe2257c791e5690f06929bba08e5bef09de82c7a8eb6eddb0b8acc58789d6c39c12751f5aaddfc9388b3ed06216c2fe4ed1831fb65a9981c71b9799094b13718ff684c6f7ee344de7427430fe9abd8c6c50aec2eddb5da1263f40c73e9341accfd008d9056c0fda2716a952379090fe65d93828f25c69f64eb098e1483d825b724e7c13b219ec98110bc93825c435ccde4b7ee0e15f20e7c698f2ed07b098d0b625d6860d773d6e8794f5cd2a085b147780d5f2da84b22edc2b2cf9b06fd677c47d3593446917ac019855965a5d8ef20a8bd6a1acf69135324c78bbb62b4b49bef6a842ec506dce5ff489078646c2910a7fc22a6194826af951495ebb69ec9e61ec152c67ebb7854fbe9a85c958f3d416a83942bb07558a05af1fa02f6872524b0ad11b5674d3fd2c9d2704bbab3c0898ca83dc11199e54a3ed6e898f9e18e236fbde3e992253db98736f6ea0f842be6ffa786c028f89a128d22b7dfc28c7957fb27639eed323cccca33d105a1801caea6b63bdc9d24fb109f0a393e279019a516ccd2ccc7d8e7e6b61856359c54d95247901934d5e63548a4511d061dfffc4aa1215149c52cea521ee22458f6942ca6f0f1bb355a6c8de4795cab7c204edda8d89aa75758ef9a70b617c28e3ccabc7e5f8159529cea5e6c247396c88f5070c701a6f4ff6016c1f2b5674aa0834100e3516b3946e8c5b4e8f4d790fefcc888ac96cf9437aec80547be8e9036088b44cffc6fce90024c93f7e7ed02656121ef530a0c313f356e52ab8ced3ab6e38d710a634587b8f4d324cf869274ae2dc9e7edb07e47932132939ea7bf9ab50e8854640b5c3a0db272f3d8cf8f555c7d7f1b31f34d7fcd8839ed59f364df192a11c45b0f56c19ae4ec0dc798afa7ecfaf6774730e685af22e499385cac4cd9ef01afb9c7a55b1c43c7e46a1e144c0b2dd24124cc7efabce2583bec520a2bb24210e68cbc60e997f2309bcc1501d19b0fa4e29d3dfc5fbff3d0fb3d7ca205e6132056065cfabc06f869254523efc1f69598ffff239c93140195d1a0ee62bcced181bddf007b6c9b3c01fa5783011a82424cc704ceacfe3e6c4444cfcceea60d57ae9cb9e71159eff9c12608be0e86531c65611bdf692d127a10dc957d6b64b6049473b187b32f3c96e6ec79ea601ee690cfe0726902f66408144c75d1566fb8b1bb07506d6a1098a3529ea19b7c86ab34b2402140f1a2061d9a7c5ef5b4b45e8b104da9680ee9c4f112f6293bfc4996c6a0b8db7e4d8ad20ad35d7bd149210f4555f7600571273883b3861d88a7d18e867cfcd9f3ce4311c29c7ad55c501400bb56f909ff7e834e1265eebd68d04d19701b979a256b89fe4b09f3d99ed6f123863a8391136e5afddddd82472a938ca8256c2db0bd4b7c2298560778d40bf341bcc1e9cf74e3981207dc1ba6dc80f78e008e5a2e6aa20b57beeb35ec2bf68465441e468e8158f51767b538bdc33fcbac7f40aff74a39a39070117993142cbb31a973dd62727d109e3417db189f75a46b814ab1a54b0c674fe649b5902652ace7a210a81aae7922fadf40ebc984392cbcac33a9ee0f6d97a1e617c4d571b7e157ab557e941774a8190854106b48f828c3695541530559df95cc5a293e7bab783aae7fe8ca612145c36d96501784596c143e9a92a3af4e1bc9d69025ce42baa2b80dd3718dde83328027386d501bc59ee5d3e20837ab8a7ddbe1dbbdd445a74d29e8a8a460a252d760f773c7306829f3a8724473b4a902c9ea54232cc01f24c6961a9d13fcd9c1cdbcea79f7a6f071146b30685a51623009f6669a9a8126ee63ed6a873fdc3e7db8728de49013a4f8452dbb8ac8a1ffc4a32b2166a8422d317ad5a79ffda09237c2e213c61cd8caae970ae0d2d2624495ad900cdded42c192ade1022d659d835cfe058fc027c040d59ce3c2c38188878054f2e98d0435822862e500825f6e55652bceb8e8300a5d0efddb54032cfdfd1f6e8942291e6674625de71a55da66551d105491f3b652364063cb1982c1efa997dd9c779b5140a51024958d2cba6d6dd5f273174893c4b21e2e69b601bca04b2dc4a1bb3a79048bbaa53e5d8f9de2bbee0bf19eade758969a75ea1afdbe835c6b7f5a805021b27f8ac7e52c4ba3cc797f09ef475d9b39fce9f9be2ab152484955694579742cf6516462081fee285b194b4349358178eaaa595c220e1f11b4f29391fa9963afbb0bb82188f810777731c70560df36fcce7e00b033a58a9bb5dee06b62e3ac38c3a2892a96adf120936d413f28b9d2ba79d1e0c4500952c16729117b3a98569d66699d3f81686c1781c74989c068b814c049ea7969beb94c6061bb216ecd7b239bdc5de823463ea85247adf97dea0e718ff8e3f4f5d47801fc16ae76d3a39ebc31caaa9846b4f451a107b17d8df8ca19d2ee6df07f4ee4f65a1b6b496c40b64e8203faf4e323147c289c42247ae10147693a44eee0ae32a193863e2a4e96aba26c9e024bb46ddd193dd077bc5702f7f3eece60b6e0dd707a7372f838c2d7341ebbe0263409261de082967d4bae7ecb475f78c9c2b7a0e6af2ec5521c62a1f0e9e0d95c4382b4d8a10cf5eff855baa95274e5debe062de103bc239e69980544e2db7bf3b5d88147b7944660317adae2fadad247730749e48726081a5f9c4cc32647f336bb360178229d4c361a8049b8340de1d0a45bb91ed52585dd1e00581ab571fe0452c72d99fe67e4f918970633a8b02b0883761da9b9a41dd08242c900cf6f0ae314b7dd4af578421fcfd73e1cf74a078796920809636083fc1420f01f6e09b626731bfdd099043b18d65b711edb8094326b76a8cb1cb40118dac5e669b6d87c34ecb6ef8e119235153c3374d02deb420284da41a38cd9ccd6c449d7cddae9a10d1cff15c674feb4e4900b31ec46c05497f797aaf7d31014a1b9afcc6e716a6badf26b006e8d4234a39089e6351f779155ab48dfe8311eb2dd4de4cb06e5a3c0b2fd9232f359c157e13091d4fc7a27f5697097cfadee8cad76f0676ab38b4f8c53df49e710bf3758d4b8ba64f037b5344f7d068668ca2e6963a6769f7a6cf17fd8e7cf965a9921692d822b748407795105b6831f6b123dc719a4731ce25750f8e0a3a1816a2defee7671b7db0ec8c1b9732f152c54ed559143aa3c1762ed2e1094db6a7cfebc687b2e12edf7f18b7728612e4d8fefd396cf76ad6f65c9f82385278870e225178fdb551506394ddc1e5f7ad00718d0f43796c6da7365a91ddf1499319a3d423b481cf326b99a90d5707c46156e5a7301e22ae4076120a57aba7624289e3aeb3be11e10c39ac658b029f272d1d0cd5ceeeeae93ef02db45c280106eaf74146297dd4f68e0612dde247c090083404505f4c82b9ecc8ab7470f8f7a4fa91bc5a110d77c83610693901e99db909c9965fa58a5202d403ce6c93882de9412e9afbe3d63f80c7501c40a325ce6486fb5296962c97e19a75ad97850cb06d541cad602e20189169b0c1641a63d316ae971ed657e68224cd5816d060067c685a0f63d6e6b721fae014994894c2413d803f319a808b63ab4f6ee253e9f277b5e0dbdbb6dc033247e4c12833a1558a30cc902285f354785afa102e48115fdf9411e9f180d52f1a918c9e804d53c02e4e452d212e7969a6ea1890fd52b7d2e59431d1b5c9a668136c51f887ef62e0d048711f45d4470478a9bbd8297b34d68c2ad6c397091530a42bc710943ab40acb6d93deb053363475fb3400b4fff514d124e898df06dd640a9b80e458b1166d210b6e0a8e9d870f68ff7705aa9b80d8fc05e15f0f9e3cedfc58a0901d1ed7ec6fe3fb63fa2ce2069af265c1e736727caa9c896a10a5509eaf8d949e1cdd430184577cf189b073ca1f843e5df22d8111f21375e435c77e966106bc7ad3bce4ad96700cd0d9e628221428b7eb507afad93462423498003ccc9e9686349ae251222586e695804993ccbf1f14b940cd2087ab235d51b0e46b1d39a206f75477a264cb17648722ba0752725396ef92b09f9dc866ba22a9dfcd20077f6f22921720158cc843ccbd2b8eb65a5d02117193c32bbc30538d2dc01bc36bc2ae5f9806382c727d943c669069ac9d7b5158f197385fcbacbee53f9249ab94b12fad8120520d81f20b678cfdb80de772ce9c7f703895a54645d8b4fe6292caf0ce3c08ad04db32a6f9c9741781b0cb14da3e326fd805e6f97b5fe8c5762a9b271f86f03ed2eb0ae95c9424a7b16fa583b80a4f6f078be0e4ea6e8cd74910d2def66cd304ae967ba380f381ff31c67853300034f84e7f401447d1d37c84648fb7df2c13a9ef90aee8036ad5827b8c0ac7d8c5c129e4641663973ac1866c6ab15536a6e143b2b027e9803f337ce89442f45aa2824e5ff1e9663e40d5efbc2ccb91aa9eaf6e5d14fd9b58bcaad1a438021a609da7cf2ae04e00ebca22d129512b2537a27eec1c7d5afcabbfc25c2e1d6120d8eb5ab38add67434a4ab06970f60959464fcbc8ab1bc21dae0519bfb874a5e592ba083a90eebb8cfadedb417cef33141c62f316937e6bf2970069ead04e97942e317ff4c04d38c0aaf4ca7d5cd6989cc7f005fd18ed5bd8a4408eefe74a4a38cf6d43f76702e96106be48abf237c79a3f6234657c18ebeb0ae3ab27d48811ae1b8b5fca5f0e9fb2ea319aeb8b47f8b570b3ae691580105d4c1d401394ec9a774279846d7cf2e5a2f1283abd06bd1883d9a6ca6c681aa024eefa12dea1583570e0ec88bf80e7cfa07961a7022ffccb7e31336cbcc60ba2e293ddd0f4a6e4e875c250681d8d08bacc10389004133c4aa7b12defa84f260447c7663b1e298ea7f4922b8fc54f1cda08d8d5cb8fa56ffd9139a6060d9b29a210be000b4d2dcf4a1c1b8fd34f5d79b5709f692baaf70e4a6d74dfb44ce90e76714ea1b60c69a65bb091b0b2e0bac2c24fc68b3fdac6fa36259deb526c2bb84036f5dbcde38845786c6c931c42e65005ca9a9ed8215d8949befa50a030641c6c40bba717bcd5e7a79d3a5161a819283d88ee547915f0df787ba14e225ccbf3f2aa7c2ba11667aff0920468eff992702853123320ac1af102578db437c6b93654ba4034f21a1a4d251b152d38d07603bd360794de9394771dd02acbc830b519eb83b1caa1460de8a7d8c650cf000e8ce7a3d731c4680d23049aa370c4f6b8d404151eb0c06e909b0c6bb78e87484a15bbccefe3c16472f2a1dfd68efeb6fc973d5171d9b7246cecf65533437a2795ba32fb2a19f2754f6fadff180c60ce0ff22d8af28cbb1c8f4eb4c30f64e6bb1921ebfe99efb28ddb50feda7a5e5aa18a98e598ab716099cc6f9edd6c10511aa0ce36932c054b317041dda2b694cb573e5dc87415301c16ac34370655ff93acb0fd00b39c435f99ef4be48e38702d7cc017841a2ea034d97368e25f93cc7bd706a85b44fcc3b6ba7a30cb507535029e0bee95a5649ccdfdcd4102c8d344968effe6e5f86b8347f24f0e1c2b249429da076968c9b2d20096f2234d7d4980306798b0a8c78c08f0a1fb5f2edec0008b8679ee6e6bec7b38a00ef7dc7db6ef7421a3afebf6910df1d76cfd1ba16ea2cd60740c49f5d5388bc6832c2bcc9065605544c79d0b89c6bd3b9424f022e5e839b090fdb89281be2df0dc039a6db1a0465016d6f4d781d6a443590e3bddfaf1a547d32e0ceac57b8f8bd67cdc1e1f10187cc5a42ce776cb6bda385c77dcc0aa9384073fad0aec1c92618413e5216636","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
