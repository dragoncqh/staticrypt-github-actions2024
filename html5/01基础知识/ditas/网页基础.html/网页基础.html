<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1852284163f6cc7830ab5cd9807feeb2636e38b9f56360b0d68e185c2d91f52b06a3632d2d8924b77b0aef3d1c8794fd0120996347f6cc6de1fa3f88f069154aacfbe1a25e8a50b367b39df1ec1791191a4ff266c7bc48f2d15bdc743eb0e7d12cf4e3c181bf7311e9c420e82704297b2798cf5474533ea45ab6f38c563f87b921c7fdc6a0c232cfa3847e452613b210a093ddd124378509f18ebb3bb2b048ef53b1e0d03cdfae004e9ee19e868eccd05e044887372b3b5d67f9b707f1ea22dbf3093836963008141aa884184f7cf7cc964474f4c4589c06432dbce0b19022bdb99c79202427e02b1ae4fbd14e54559659f2dad905d0678d7a3ae8d559f25ca9cd9e40320c31e66812aa82a45369ded8068f35b283bd5cda0bcab58836d0a50b557559dc47688df38ff55531af28a87c0eddb37a230f05c424910d5d809ae49dff3e4f85904b4d06d21dbc031cf9d25ee109b99a22f1668e738e28dbda1330cadb3b96e80e4e106bedd5aa06a49ae5efc369a3a3bdd9973dbbf13de85e6d923e41d0af0792d21ab92a0e9c07e0ee1b7f15cbd6709adc3eb79fffec0d0ecef80b028311ed764198998986785805f77e366e24ba53dd72cc80d99f68c89484f7beffc84fb19a57727090fdc05476c4c1fd3b0e2028df1ffb6131dfa93a6c9436ce55ff748dadff384eb653f56ff09a7c846058055e75aef68f07a1ab8e254e87e3c6d621abd1fa6a6842b2034a8868962e297296ec2bfcbf9d8ec6ccf6fd3bab454b480b6ddd1489ce3ce35f7965522afc17dbf3f1559adffc723242f0ecb6f1db202f948654401659e7813f42835046fef727e4e9d23e602f4d17e14b3d7db7e9e2f795892b08cd6746b3241ef4dedef8a7c97600b18883fc37350ebea70d9e8777824ac0d8155ea6e7ce615b30246d74f81b0a7608b9adcbf9987dcd2968129918bae166eac8a6ee7db88b7c189f25c5f9f9f53b347504b2a834885b1ecb71243494e9f0212b34e6a7bdaaf756cb5192ae8df1553f99e436cd6e0c781b7a415b947832fe7657df65057c2b43942d7eb51834d0d5bd8060fe318a6b2e82f1e9511a34b07b70c1f06487a50171d87c395fcf76d34eb77813449f64e3c8100a9ea6712dc9b2f9f33d39f2722500c13492524e633a3ec400bfd5d9755805d7b0af3286e8320f7d6346785aa4ecc2499b00eb138732f120acbbb814afe61434c3dfa15a2ba0f914f06a19742e75d57525688544f3a47426345abe9138d9a1cc74ead76e8e8b8af14ab7076fe09136e6b8683bdabdf7eb66535c09b31a731f3b4f4ad34de65b2dda85b87dd52768fbaeff5233ed83dad74f32646b37cc05aa2bd2741e1d0e70652c53682e2f72d7742cf86ee99fe5e88b5306474fa0b6c429a6115ce8e16bdd33a79ab2b88be88082600f335fc5124a3c84abf4655373608e435ca3c399b0eb063b39f9a8f853e0e05eac81e70fa6f35594e40ac61d18c188fba48e076cee25eb441e7dbf5a0ac7aa368ba92167450ea4cffde023b1f393daf3954395f4b9804b6de043231a96a9d7b36be0dfe7a96feded33551a7cdeafcd891dbf7a7c92093348d209c15d3c7afac65adcae7c504ad815f7cfccf2af6146e2ec122e0f4c802a1f0d8c39980ba0cc634a3d1c57545b44fbc6265b17ae3a06eb1f81952910a889162ad22b0d894137b4258cb092695f0cf93dbd93f49e3dd69ba6311c3261ae004c431b7b991bff4a9f83381bcc374e10a44960b551f7d8e99b12d2dc9e1034f775c4138abbc70e2950bf730514ad727ade89640da7bc7609339ed473387cd6d9c58138646f505fd3086e87fca301f5ef9b87abbd7396c54383ce0f0a7e34433b3beb975249c0dc7e71fc3b5fdad845ca2f2898d744f234d24faab3a8e994ac01b7f0710400cdb8aef9910256f8d2a735f27c6995f744af78aa02922c51153a4bc86c97db41067343f4391f66a7a3c9367ec69ff58eefcd93e518f9b18490cc1e33e46e7baf591345a35dc9f925162b2f30f02ea0a1d883c5cc7de4fdf18c88816a7f8290bcab0c27873832be9b98a01e8d81d54f5a9b020ee415fb0f421834d52e08635b101acca8d27befc7a75cc2533090673f058387234a14933d653b4617e6c638b54cdcf577ef5e2f5d336c927c3add18ad9143f3c2489c347a59c19aeb71151aa728900ddc38714caffffcb648f9f7de7601b1ee26ea089ed92fb8f0a378af78cf62f0c919f97bf56c823f31a56f9a3ad1f3ef26f473ecf6125273bc754aa42f0deecca34a9f11ac0aa6ce48fe19c3935d49cd3dda7725b7c23467073f65153903ae8833d4e5c07afdeabc9e963c12496893ff835fc57137f4b0acdb276bc59e9be9fedc0aaccf27e89b8170317e7b63d058a09d250f09925213bcba55bacd539be10c696ff9080cef52c24b7c52c38ac4c0e29232102a89d7d9e44ddf416c1f290f3f05b79af5c1486b96f92d91ee2971d820d219f07b94c73c7bb5f7e9b7b31940681ce488e9335d4d944b9b2d54df974b33d5636bccec79817f0d969db20a46027f3a7f5237636c64609b36a4a19d6c3660600b0590c83398d917639c26363c2b300f33eec482e360a60634e9025865600ebf82baa94633c5c54999cca891d86f0ca647384d10fddc66f9b31c6185d3e35b9036c9245df2866e645a10436acfb8b280b8a26468b513dd067a05006ade750088945395425c6e86cab0e519518b5d690a9701a2bf9cd29d5dcd396b50ab4697b149f66229d78f165ddf3cdf17b5f1e23c16c2484ac531fb2d92b9489857cdf01aeaf6db25c0c625789304b7581456805f7a8ae33c365e8eeb8304564d041e2c0f97a1053d94963c6d5890095edda6bfcb4fc34070d9cde115b47e6aa6cda974c3cb85a9d53bb187e19b11c6e075e2e36b8e19b614ed2ba5a7e9a1661a59102d2466917d0a74c73b387dfe5bdd8783956c223393beabf411defcfd213add505584d568079f7dac9ccb787e6a55e6f68b9deb075b829d4388f8bd85d9753f0ee1b57b52988fffc934368dee3a7b58e33bc1b44e66cc2a797ef8f0679e76e7266a204c562b6126a25b8349426d635dd8d014c843bf451767b040119ed35496ddf9cfe65ce60d33ec9c39a4f7400c283fac2af6520037af1556ad3cdb6d25865697d19e3a7d081b308edcc75025f90eb4aba1563244ed68a7a0ae4bcec038f3d33ec0389d0dae08eba0b2bf92ddd60c326c58593ce5da938b09ff6b0ce782f642bd50aa64f105e51eed6e036f119ec4f49e8347f61327a040f4fb292a7d3ef3145dacef79c36370a37461c667d46d2646785320b492b71f58da5b54669892d6ca373797ecdba79253c83fb3e204d6b18b06ac47d60b0298ee3bb22977afb34636bd32aa9d4fe04e109d04412e5bd44e45c2fc762a397c37ee0f684df09d465534d17a4d3850bc8b705ca3b528de6ce9e137cf914aa5c19496f04ce52b6c9754535124d4fb506050c8d6abc08ed3f988f4d6e149e6c4b2c143e6b7e7f9763df77463633fac879d6e6aa7210cc10fa17d355cb220403b96cc08df48c733ed7659fb3d24b0ef5214b9a5ec75f83106d7130cf67cd92d72935465dcf2dd24c12dc1f6e88a28104e2704e35e838c03ce5e96b357c4779ffcd21a3aa993e61fa3189c6c06a5432eb64f1e729201869beee0a4d35b51cccdea38a30ddb071a2a48d771225c4d4a1b5d088f87a951a1a35d12896198fb836559dccefe43430073f253d21e3303f44ed28614899a085b92351a1ae2d2594241c586c0bf38fcdceb18efe451eb77ea3ea8019d4c61a4737be379d60a7b7058943262eb86d8c6d835422fc3dd1e50a5c292bf1e30a845a3bd59db509b93eeb2c7918fd8adedd793e71341315ebc49f0998ff297c8d938d7d6f2693975525e52565c576d08733945cf73294d04d9dc9c7cb06a4aa078f8cf6fed44680e61fb4267a47758d6b1afc0a5067a84430985a1ce6db7fa460d3f3c9d9357245f8506aef1c062dbb47b1561a184d7507f24b7c6074fb43cd1504cb5a27c9b2dadc98e06d9712027120eed8bd8f3d91c04dbfdca99465276ff1fa8e0c528f8829ae6c146b997942c2e73ec9795f81d5f5f36a6dc19be0a3472f4b1ee1ce9522affc54c96db2e52afd07d4708cef2b7402b25174a5a22f03b04cff229162ca3dc4897896cdb5d8cae2a37bdc2f6263611aeb396ce8262c98c94f4f7ede399db6cc7629d1c91c2946126bbb3df8599abf159600f338b45c99b23e823c5f72b5a78f8f3a3ff7e181a3acbd4894859d13a25493a2fc7dc543bc3159be6295a18fa8ba7ab7c0f24c843965e10226c52c65d081bf709ada7d3a471e45a03e1b9808d492f8a9ec6922d783504b5c35dcfe2d48f49613e1cefc0e7d24901afb99021334fbc77b11082e67c10fb8b69c2b7ab73d8330127b2d40695803337f9745b69f2c2b92cc9abb583a74d84bcaf4f83e6d18e101eeace14aee90d8d0b1c56bf190db72a4236348b3b8c73d4c1100c2a1b439874a9a2c488e2916d898f6b1fed8129330448be2b20143698672e9b88f2cbd286d2bb0f0f7a9130b7393284201e6bf949ddce132c8b053aaf280510cb64d04dedc1a0fcdb39a02db9fa3f86526e8a493df0caa80de6e41999e989f4c544253f9d1305429f1d66983235a1bb5935e33e4d0c5061aad5f40c110bff71ea631fa27ee91579f50cb06df6e596d477fa1cb992865aa7959fad6ea5e3fc9b591f98473b11c510d593ffc6d5d0614e0f40ef4084d3fc01069bfd2a391f2c218fdc0bdd570eb370c7139822edb4167de12109c95e808af6b3b1f524dc1edd70ef66b1809d3b09cbe6d57ce0655d9bbe295e9eab3bc116157c80a96d077e13fe17fd85379575844fb50b93bbf6796981e188933623a4349057bb41a42e8fd58e9d8e29de00abde8463dcc433e9b8d5a4e42b9ac11dbd2b0fde481fb99fa054962234084341b84e215e4ef8154d8391151ebc5a7e2067506e85f341f7ca6cf885efceba38459b26f1353b28bee3dbdfa11a02109a1b7fa166459768e160c267c78e5cb288608590753f8205e6a00afe533e728c63bf254cdf973aa24d2f48af9a12c285a9ec8ce36c580e993cf912fe557449ca575b4bd2f35c8fb021b2b6e6d4718eb84e005e47767c968666407dc755c8cf646e8d8ef148ce6158ab3ae4a5161d85f8b5cce3f461e9c37aac193fbe83b5ac81c337e8b0383f22a3e7904b9a73457817fbfd7c94bb67ec77687a66f3fc89fd37eded50f110f148769299dfbe7e31cfd9b6c4059cd387f2b911005ffee170e98cb093885a0e39ab445db20a47d4a8835a14d670de11f152e8fda1f541556bdc110aa7108d8fab8458da68318434474752742d58da87a2a2f6354f9f35c535d916cfb8b9c70be97d0008cebe9f407069f877adc231fe0ddf649870357dba27ce7cdaf97ba4fb8a3cc31e84c363b90d3a9e66e5bbdf745a33a90ec7d5eb72fb60fda4bd20c73054acb45f5defeeff678e35baeb3cd32dbeab3c57249f509afed5e45156a9c0a0c58025e697814ecca76d099d434c6eb5141c19bf2fdeab0e97428253116796d8e9ff79a96c7b26e75172bf4aee8fbdd618ef374970de2e65f1ec5cd6683c8ad5e46787cf250efee26d5396bfb1cf08e69ac21dea868fd6fdb0809edef028b213c42766e30c8b9a3c7d2e4bbb674ef300bd64a2d2492e0bfaa7a014f0e54d5c97ae0b9889db8409c68e81cade5ea0f25707b9f34b74f4481ab936995841a33014f135888520bf6f82bca9f27c79e1aeb5a02dd68b210237b09819f48d6b9027b00da492ef0aaa384a2e522e1ae7b1429e6421acd79a3b526dc5acbe7e77369d34fd0a9c424b8fa90a6a673217b80cfc8be9854d822b0896ded20cb113413ac0a1a9c0afbd043c2d5f6cfbd27ae8766fbf8dbc010c248798fe002e3dc71f24eb992eee0c0d0fbd4c3a85bb300506282597227b8c7e66e978beb3c96bf753f23c9f37e7f63d3f31a5c69b97b0949291eefce7e5b1fc26f0098e8b34c6b2e24e0154e0760505aff951cff209a3f65bad30f009379175aadedb2d345dcc8608ba9704bae88a1fe84da65879d2b59d5bb75e0d60b4fee9913263dd2f283f1939031675f7444b3555519b08449354624ea77ae330396055e0d227eb2cee10cc7f1c6bb010357f56f12b0c4cb64125f48a78f04d3d92999a9ec34b7dca73c75da4f26fd310e8467e72020064786aebdfb112f81b0af8efec93a3b3dcaafdb6d9b5616f2176940b612246e42e6c28d42b2b768821ddaa8dc5a32f337b4409ddcfe0de73ac5aaf01f32482f8c6bfc65fdda4ad135becb1e747196e382835e6b04914360c6ecb28b6f46e106e79760df847aaf483a05833f015e602c9d13cebfe1cbdf33fbbf61d9899c4b4152e26fa713a7a134c554bd0df597e255254a01a719d796bca8c6c03e3963dfa3430094e761e90f826ff778b693166edd7418e2ae6f301100f476c41d5ef89cf56c5a4c971ab38279eaaa7b614fc22f88d0a622469df1b07297f51a90489373b4557457c5f50ea5f5e70bc066b7041057b8d076775a86d28e63a0ff5a5e6faa70b994c329f9cf196afe5b628a86475b9dfb3b25507b85e043e4e4d4e7f6787ea1de44c657188909f098c2195d80fb79757e2bcaa2f5d1bc85d6024eabfef0899c5dd1e9233b943a50675a9dbcbb226a96d827689644fd692431c88454c95cf83bdde5fa4eeb0f2ebeff16a790a01e4e7a53caf23b045b096de4f428e81b581d84f421680d234f611f9052e07828fa0a012f8d13d1551f8591b2aac808e6ceebaafbef1eee910ff2ab9020ba9d283bf4d58a2fa50ddfb422f0056da1aec9715ad110160bf5ec7d8b416e281a7e717424a08efb97faf0b4525be3cdb5bb624d994256c4db2e0d3f5c575e43141f715c4d260e8089a290361876274efb7f676d7ceb4120b0f2b03d150e08737c7ff26553d3dfa0253e1b9c17e649f784e4e1648fbb3b87457121bf9be95ef656c2d7b1e49b0b50a02032078ab71e11deee56c77ff038d7737b99436636ad742962fbf265b8939fc0e76a76e1b2d3c6abe430c826ba0c78ef678e8410a63357409fe8151915a2cc29b7208a3a72d2c80060a43beb5e7275b6ee7bb9ae41843f9e67d4f2d0866e19e2910f615e625e66d63fd09977487a580cda5abafcf45e66e9c2203addec7b5499c31ac941caa6876a7c6335068a39ef3c6b0fb838d34ac68bc145bb23b870684de573eb4cbc44b9522b64ff60cfec15d363b9245b443b7a1b563ecc4849579f586a31024180bd64da707e6dd44514864a4590b09937e14ade05f3f9efa81d8badfd0a4e5fd89e8b93c56a17be57833dcc10dfc2311906478cb29d3d5ddcfc0eeba7c692b251bf70c881a58af9c0c1d2b5053e51004ac96050f909f714e742a148dbb6c38e946756969683976038e3288e231f13a1bc2386350fb84003a4bb3599b9beeade913674d2aa296118e9a0be37cffb6a9e0af148e7f3ed5cecc1ce209d4f0940d4e9bfe3a012984191f2092b184cd116ee9101b754d813f210694f1bd48b008cb431cf217ed5e9cda31668a83c4716e18a08507e85ceba288e470dc15afbb1002bd2c1c94ccbaab5cac86b70a13db6a8cd2d6a64985aa162d7cd18e815415f338f61f0dba1f41b9aef561c0d5d2e5f29f74ae3165721814b8fcb69b9c74c3fbdd8afef820b4e76108160a9bc80e6587b006699784bfa07be3eb55669231247203cc4adecc126fa4de450c9fa3379645a4eff9fc5f1b884d94c9e4b3b5fed930950980972918ffce973947820ece583c7237706fc0f26e330bab8463e0437e28285d954b38425890ca044caef0a06ce00f452da38dafb1af84eaeff590f963ba244eea58db79576f1f164a2458cc1c85beeb6614fde9eeb99be9af1f66a7b025cd859fdfe47ce25d8fa0ebb56664941f2d110523706492dd8f860a0a2a2577a6cc0b599c5af43f4c3da5cdbf5d7d28504dab112bff08ade37ee49b4fcb38a1298fff6e682054c0afe1630bf2b74045592439c5a7ad9b870ad45d3a45695fec01ec841848bdf119c0f2be858d973398e4b8f9a8e6d9e279734219d3e5bf9c95fb4022b328a5b937103609c82c70aa4c86e3b69dd29e3154d03a7e5db65e81a9edba56c343d2c9e732ca349d38a6dadd6f9cfa5d8dfb344e54ee9f23e28a3efa27e4be1a7b13ac343be3be04baef17dcdfb77596c6d138fa9f2348ae70ac555300d6664e71a017c1c5fe26a829acff66774194d9ffa8087709fbe37bd41e0ed0254c1a22c1aa83463623b065c6a99bda4afe16f8598ae55ed860e1b4660f859706eb33ed2f4c18f71e876b4ecc8333f57d8acecc230b35efb97d23e9c440ff7637bb42d3073b49825c03425705cda6bab2a17521ec69540c1e2ea1f57b566548ed9c7dff8589b59d7609102dc007edc7b4e88940f8720bec5cf43a1a7331c7ef486a3c7922833c66e0c0761dd67aaea703a7ff391211c426f013c2548e42a745512d8dcf14c7a6f26f82445469ad7b9a0b138d4412d2b7ea819bc4187999c63cf4fe4c76cfe783e2c51e3fdde3768ccc345c9981859a90848ef22c6d362fed0141169b0336273b296d69a6c8c7627cb9f15b21e991d647d85d8c8be5d5387c1f2e7bb7dbb14daa9517544b73059f05f76e505b71e71830a033beaaf87ba2fed46c15b4ba4392602f906b42381697791cd1b8e4241e15462ba34ba79ec1fcb4ba8b53c98a04d00244b55acfeefe939a3e6c101b1578616c52f3344870dfcdd491c254fad0cb7cab73d5a07cfb47b7f4be7d42dc3db08cf8fe453789a9b104174b739382146dc17a3e998b78d7dfd95d18c0d862ea1762b8ac1ef5fff610eca018707711590b1d36a23f56e1ea712087d4f649c59b7b3779e6cb573a986651021a7f1ca8d335b4781bc839b6e5c552bda194e9876d855b5a46881ae7837ca434ebcb4c0f5e7b77823bcbff65df29564e49eb854c23f3de9ff399b08a8e477ccafd20f3b123076bd6c5d3928be27c037b194c38807f5b14496cf7f76c29786435cb9ccf074747ed00458ff317d2052206abb0eb741efcd3fddc930a55cbcf9c3d78cd94ef457bba0ab710cf2d12a0b541e0a0d0e2ec7aa17993b7cda56a1e4a6c622efd15f9889428736e97a2507c57495383cbd27adfb48e668494dbf78f5676534580b87aafe7e5f77fa10773dfd6ba002d59d8b7224a145f7f05717b64a20a6ca44782c7decf4384605128d61814b8e84a97764b64bd61b136f6a1948e4bc4a6d95469f03c01d3af1d8e060d69cf2f17ab8c3f1594e64f5716b69485a548b1e022001766f3d9696c0aba004e51df231bc776fa8534b109de83d4f64b9061c47822134a6776686ab3fc505d015a78d6fec4460366d4b28e7ea6f629b2d224657f88cfc29a4b80e139af56b9632c8b8116a5f03be46b24d3c040ca9ac1c8e492b0b41a603b398b8c96cc5a0ae9563cde6abe01c1d4051701dac67eb220c4cb1a2be848d30b40be2e07265b38de23d2c967ef5cec250e4e8d16b2f0e88793b11eef23454dc956f9febda1ab236cf675f0e68aef660dff7ef88c186f6776997e5b2802a26e51781596932ddfad8b19d168e157e4f73e229f38d3a49db18919d436eb780f254aa28b567c0c7de01a41003bc9ef7e158e2e61b33fe65c437826894a0eefe3daa54f0369815fe50189b2134b5cf5265b07e537702679056ed8be0b039faf1d55d1b810e84a24b3122e5df2aba53656c6b0688a781f1105f2fefeb0b74e048ee2256166072d51010cd312d95eb51be90eb521263ba7a57cae83f92674376e912f4c84cda44e6b601bdbe3159c21a01bb5e3a86ad9275b9a07dcc6a2d2170ae82478a297b57c5758b041925002764f4f4a62cb805ed35af333d14527412bf963b57c2c62df9c2a8721bbee7d36f9a9d93d958d05e6c800dff50576b1ff39a53597dd1146ec7ab65152b642fefb9768c3025ed554c74ba0453e4fd5c947fd86865a9839615f1035e7649dc08eb59ec042f9a23da05868355ac224474e445cd738f21b4caf6a51798e4458c5b4b36a7a5b9b7bc81e1dd0cc73091d2a80b678b1a95a398e68fbf025e15ab477049e8a5fdd729e7bbe37ba4e911720a76c8440b10f5476566ca49b406d7cf76f48a48ccab2d2b44cfe27264e820f77e9c83880befb580cbe9dac26ade7aa1c9dab71aadc7e12f09304ba2ffc59326d38068cf105577b40b7b9704df0b8919d2a7fdc62d793b03b038d919e53c7b5de5b1943b4e7998687d6cbe20d034060390a860b624c81fff868cb3f0d15e163b5e526c34666a36d7a2f633f1a7f8306e77b22337e20f42932d009ed79c3c00a86497933e2ca3faf7b8b4230e2021d53702f4e0daa058c96f728b20a8f4a3b3d3200464533347ed669db071d48ddac62e1b5956bcb00ac3178d15db0c70f627805df33c91d9b3b9a8ab1d039fb0c3f267b5ba83554c3734d3a02025a024fac220c04eb06005b0d3b4d443643fbe6cae27afc7059d01e9431bc84b7433923ccf7da6461ff62ba5e21c843f38985645749b4506237b353d18ef4f21033d9113a0e75347335491c7ada50e34241266ccd60d09f8b49d1181d1b5a083fa1836bcac9e10cd8ace49f37ca56e413b7c976d0c10876fa2ce65f70fb18b4f1a6a5af0c87e01118a7ce1d8eb69d2213b4bb871bcdcfee33d8c17df1fb339fc6dece54670260d1890b5fb76236831063e49f6c4b926907466d96d8181c385658fdb8b05899fba4bc7dedf58934e3625ee053384084aa4c0e87c53d1023f50f1b86d4839ba0e464e2fc044d613b8aab9540d25a4bf257be9c89f0e27db505ade8e0d578c0613e7da6662a996c5d5d5bd6939b57a142e4b3e8a7ae83aa2b96fa57a2fc88fed9066c4e3f25e943b4c31a1cec9167dd4aeaddc73241d75f494f61f18396042baf240d20b094ae4e30443c1f544d7b80c207ebd9a3f0b4da088b9afa8f3f3a8a02db9d103b45b30deeb8a1720daa7e5e78b360600688378a705327d75d82283413fdc35e69342a1e84f36e7ebdc4eba5d4f98db9feaf9ee79acf3c64d51d384c18049f194286d00b3794039ab6301967a675f88e6ee902bde55aa427673f81ab9e82b7c3389e6f845610cc4a9d09d73db77d38f561b3b65a6aa9ed5830f2af7ecd8bda026357d8de942e8ea93dcc6e5daa9e543d69c25b5e3dad7b181ca8f48c03920b8d65c525086361e994e98aaaf9a831e4d764c8e498845a8ef3aabd431ae2f811ac9ac28fa5f65d6970e4eb8ed97413977791dfa4461619292bfca38f525bbde9d8313aaa0f0880b254980dcfc23cdad0bd0956b9a7be2672ed8b3ef4112f2d0aaefd257ecfd32bde6eee550b1c7a0fef4440c4f0b7ee9311cf12089251563e023831ff1b14a2d7050b1a55d73885f27b0baa6f48d1b7d5e0867740b7106a4701d07897cfa96de3d31d201c9a10f25afabbc566fe27cdb38c692d99794c07f90d3e4e36710c9fa9a414a3ffb9ab74aead3fe2bfc1c2ef4c768f3c554a8cd5c6a8c6d9c3443a84845c4fed349456a052307dc0b198abd8c2befc567c32387cf051ab51bed070df42dfd472ce32ff2e1ac3252fd644debd2d6bcc4b8c3a4f5d2bd91314eaff4f963da0961977958590ec45e993e32ee1ed26af4542f2732467a914cb7676aa1dd6f007e41ce9153e7bfac4e4e226d53f447aabf61cda67371eb6609e842b8b399d7ee3e058371f9696492eed27ef19dfc0b74eca908cf0e4ad533a863efb70497e066157fd4c30f479b41bcd3ce1934d5a60ab9fd8f8e3bd12c7d87acfc8c64b46d8a6ab62cc37d093e62c96f30e98300735090d8eed37dfd2444ff40a32628ca853a38d535675c4a9b38661c7ca9a213ce206a9f297972499650267243fb37ead99afda01dc8df9e3977c3c1ef2ca4add83e3670b1f291e67269b255d26cb5fb928ef57bd45d30e23a8518b3fbe9d92041acebc58ee76a2dd4dcd68669d256063c51a835cce3df0caeb241a3f654bd53b74a23e2bf7c59ce2d912983bb983a191481f4d8b9a3c20a2a1e856384b2436a2e64d61b4b22b2ab202851d2122546442923191e1448aa58ef7ee7344b011f3c5c3b3a4b81ca93f3edc21fed50b03b217beb9c13357c8f81247fe1966de709227ac86583017bf64500480e0ba8693306c312322a962a6cddbd843e06fcc3a3ca98a6f84293c21cdd2ebbbcd4e45ce162b85f03deb407b034262a5a959922960c3a18e39d81d1a87823e85f540f488d627be595ca6608eef71a17353ed0bf691a9b15ba3dabbfe28a994d0f0cafe7d7cebb4c109d9bf2b4bb0adde8d9c9c3f44d93b9aca807e365843547ab59cb69e9219eec0669af33919cd21bf73c290abb925fca922ba187ad58a22e8385bbc353cac1f01ead3c4b6b1be69dd61d2fa688d801c0ee529aefba7269024f0ed006b9cb6d1cbb2aad53213e89858fff38bf128ddeb870ec017660fcaf0a3155ca61baabc7773783e95fa3c07e2e2a871ccd3a76946602c92f39fc3ef5b3c88a141de23fae79a0b2b1f420c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
