<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c05480c60864d0e99d51ffccb3bd9dc656514ababad4435a3b89d4451588a818212cf2643af371352aa72546ce57db05b428acb588edfa9a645cbb206ea7fffde39cfb1b0996af067642845bf30c4d00000ade91f1daf19a9e84599f9e6735fb4c36bc5ccf4b9eccb1147008a314c62adcc0c9892d6f8541e535833895d17b6e7312942ffed178a0b7717c86985b7c4408230223916116a7b6d06c429fdd58737d037de469029e1773efeaf6ea3c88fd227895b6137828cba5296aa2eb80a23d937673c6a114278ce2ede0b01dd66a0dee74db4e723537cd4d5cff01b2c951dc373bb94f623553d57bf5ca4e172bca4b1b6261653e258e32610c312bd29b537540c0d9dc96e40bc6442405ca575cbe22285ff25b56216934f11783803099da384451f868ce72cc4120d52ad1be72b52f09bb8b2d06427d1660c12bc32b22b28ba966dbcf33f9d6d3655fcb180249b18320e73bd03f1afa367d3255b3daddd6fc5a7c96ed917e27da022def8cd4ee8ac08f49b06b55e4516f7a193c50539900cd891ae206f9862dee3f5fb1435879004fb4e15399143943a0a7481a187cef0cd6a0e3bbdffec70495e2b29677b6b34e39e12daba4e5d15bf15d838e7980996c1de66cf1b770c3aba259c7970661577a9c58ee6374eaacccd813e370220fedc1e04bb871ff5f4da7f8e85b97c9b5c38ed93c09f34318dbfd19327caf830ffb4c416a5244a0804fee08680354d2969e17551d7226840c5ea12a56a7bdee66a9d54096a9d5d0bc53e3633f789a81eb1d498c364e442b8d3392eb19f6fe3496cfd1e7b3aa6ce0d4a0bd367e35585be23e4b9b3e012a7e5892870f4cf1b00f7d925582910df4d195e164217da407677c4aa17faf17de5046b1fa9e467781dc7fe2d5ca93f072409b288c0eda6d61fda906504e4e52184fb911630910407ab63f45485bcfc364c7d94631e2ec7c7e16d4699dc179bf6e65abbb4cf96790af3a0e1506ad1f4d736f35de76bc01ff01469c2410540f9a90f9a81e6ffdfb80f003c97d5d442179a0daafc0189b876a7f060b4243090de664c470130e8af0a39070f1ce489b56afd048cb67484bec80273b4321d963bdb39303f60acb48f6b656810bc30ab5d8eda0c7a37b2e0d8448fc9c1107287df2e7e2eaa067b38148538decbfe46b047488c45343a744b05081026cdb582d9383e4ec29a9b3378022c944518be3c31017587c0516609a000e93198547a6d694591cbf7fa23f8d896fc5f3be82fb6dcd8943964ec1e6c5216fd223c1575566b9083bca83e6ff5882d82082745118667fc423b49f03a13e6cbabfb86207400b3f68154119026b9e639d0b7054956478bf812ab542366abd14a77de650eb9c79258f8bf03528ab256f7e0df734ab6e18f28364ffd0233715d9d45c047641b142cb29354f66e215cd1ca04ccedb2319f67a865e1e49f0863e3296954e6a3d7c55e8572546748b576d5e1aea4e2068dd3ce8db71011a3683a8115866f451628f26939a904025c4967744822ab6d34209e0042285276889f4b79fa54f5e4eac463bb873f2361aae15260c69bccb6664686b028f00efc6e5b034bbaf5553baa8c889cef57d4767d11bb8d59467626812579630ba3a56d46a68692e8e4196de3fceac0af505ecb970570755cbcac1b8befc637637cda4c950e9bb165baca3cf2f58103ff60780b89841589b6b498b963b93e7acd37e85dbd46cf584486565ccb2dbd6f1325bdd65400d64d7cad32ff87f4b5f06ead670e9edfa722400525b4a5b744ad2fe55f1ed126b9c8c62bcffd02ad1a48120043db799839dfe070f4d5f18c5a1e692bb5201d565be2fb73ca1cf8f2b9641305dd7b8a7c05a55cb4e6d56b500ccf4f500e7a3f52ae06a177ee89f47664bb55fb134d7d07207c0862ee6aa7498625b1fe1e939c2c3a4a3c76240834a65492bb99ee552553b6680a0b2f773a3a6e38fcba2c8f5c36ca3c84b27b6b1ed80d000cf6ffa4a7d9b54af4fa50eadd3b28d6f3e264204c299a02d1a02b2d0d5a6ddce777db503ff0e1db9689c72b20279347ce4d48c0eb93a01f05a4671a6db1a305df9cc8ec9f5633a12e27b0fad34aa5d6af65479d4557bed18a5d1c22e9bb5e26c0d7118014ec3166879639471955ada44474c425f93b8aed21bd8efa87aabf10de7cb39e61d8b07f6160e5ed0a2635bd26b0507b163ffdddf539de2af909ba50103e9cbe34a438bd96f8fe8e4453914fd8c2013ab74b04878e2df268beed219ff3768c05061130af96090613b199d28b9267b145600b7b1ccb3df9193d6fe09bf36504d71c038dcf23dd029c9c51087e7b5b2f1933925373c27b005aa334b745d3957a6b4cb953a81dcb3b9c4ea0d2fec97e3223dad9a48176f0ff01feaa6acfc55d502ad44780876d87190bfc0e34e49575776d508661942f642072a68151d14a97eaa7d5bdea394d3025c134920e9ac53c29c2f32c3a968d51ff1d291b5ca3974a431575a2e2af4102708e930cb7cd91d214d5f073ba8c2863d11a6b5d1628316dc69dac6ce58eef0316c3a345421cc7004078b77667167d8ed1ee970c3c7bd8bebee9df9f83d20b3f1e5e6c58e7bdbc1d47255e3bf7e8140af3852347f5984b97edddef96186ad127d914384f2a10907511ec49bbce7227f45ac639eea4940cce88af6c9567348d5feb2655ca50a14452454555e2def0bdab03f36cb9956be22b7e7f2865ef74ba595bb2d9e4f44e9ac2266ee223fefaa9e7012eb00d80d6414d5ef312cbc037f752567cfc3037c4bf0a4308883d9ec8313c1e8087707fb3906188fee80c07408d917b6ed2ff59fa0b986bd606b05e4ce0b2a18b939c09def6ed4e1dc30097a412472b6e3f00ce463405d3b2232fe332a468e4a3cce32c40f534812ffd0d60718a72b98e300db5d9116a97b603bd7c7ec8751f5e796c069b0bba538ba5d109fb42a94c230edff0f300b2a7558ed086e4f9b3e1d3b166c325f36efd3ceb536cb6b537b99048d63ea1afb7e22e97a63ac6896b0c02d7ae814b58e5ea5ff7e34c744f54b550c5228c2bd354bd226de471cfafe31bc334a5247a148b2e79796c3973fc829ed56b2f7e13a3f12cafb23b696c1ac0c87e9c4088e74fcd6d683d2e3341f80f76ef7d20facebeaa013e144d358a0fd4bf21bbf99061c588c1607de7a5a3f77e7720627fea813d6e71409097ebe28c0126c812bc515001c03af26986e0d8a2961473241a89dfb6937aad3bdbf5b19614ebba671243c33b421602aaec3a503ccf248bd6d1b309449a79ed439d70ce56b1aa5e55dd0dc750a6c29b4ca97138dd4d10cce8b92affa874a80aaf31223f15bfc0a46e0e698ac27895cbe27bd9570d3d6c2ffacf5ffbf75cd3df1eb8a184d8da0886c69ae5f1770cc3fb326de3c9c0eb6491d771fc92950e3293e5e7f73c0aa7b9335a148153ff5e7f31c903855cc45b5af123f5953be188eecfdf3c6e74ff9bd39d893fe42b2667d7b3d410385541a09a331b736962c9512020f76d20040d8438dfc331286e61eacfc07cd6580bede92983584fbd3fb08c3e69f1a673a438edc84298a0a186c2861ff727cfaafeb6cf45492396e5c7b1815a789486c52e1bd506dbaf6b4d2ffbe333e574e5af4b3c454b9399ac1c8f4e9f38355503e126e0f78301466ad94f8eb2ef273298baa2c0763fa12efff197e1ed4add4dc9c6bde694f5bb866301e930d08cff5c0aeb4a1a9156a46b74cd125e3bc697cdc20ad207a712c09e4b433567ced063e46c63a01e67386a61635b87a93e6a1c71bc24390b35d70de258813d71a641d613862c8f62e9aaaff70c612405e73d12855b6fd6732baacc6f36b80ae7f220c942a7cdd0c43f13752e48a3f9835dec07c956377820338ede2c2b49f1081791935cd543d3695fdcb57e52c23df6ebf5ac2af9aae0371886a17fc03b7cdefc56e2de3c0969ca61a46c0032570f0c5c1ff7788bb5cefc1d77474d2c5a33fe5aa02f286e838d76e20f9b8a8055a2f626f94b0e6c26a91f502bd351d48fc5c3d4d4400570f7b00eea7f6a96355fe437b441501ab00b282584d1e82c86cda156e624df5066eb72a5065d9d015d9113a31227a56e593436330e7bcd76b0b1952e796faef90e7d9ad70fcb86cbe9714cfa7968bea39af7f0f364e62aceb6394b4585ae7c2791d0a019ca85009615f41aacf8a7c9b5a38568d98dd224c8297a352edb962639d880e474bfd4f67bc03ca2da01b5976ab5541e3efbee021cbba4f3bb868a28fcef41aa405225fd46e749751acba2e65dc6b02083abde603a7473c27b57cc4533dcf42352459153c4e782f41e938eaa7ffd0d28c05af6a0f958b948c51e9ab70360ab78b00751d922d995743d1b5d06e351ad7a67e18545dd46698be9dde1f670422f9b7f5e5c8127ea7755e52c485ec026ab4e00875afb5a0260ff12aa3cf1a05b3e3b1d18f8527b6a10717e5a8870115a2fc3279177cf4797886c57cb4fea4047a65bac9ead0cbf4d29d93bc5e5185bf8602969376af22c8dde01748648b5066963422d69b55314919b3c9e2780fc9e929dbc2a174032a3c4e066bb5b4cb5d46f2bc5ae5315916247d6bd3a2f9dfaf51440bbf5953b4194afca998c483fd909e71fb75e8c6574eaa1f5ede654f34d9ee1882cb749ac404f5cdb37fc68d04f44b5631a005131984ac89eecbd3b57c0ce4f4141ca41a0637792bea72afb0d1a89abba916f50dfd38c716548fcf924b4297e02d235204cc1bc2194abf585d7b71783dd0527b7df72115d8f2db76cb474ebfa292ef27f74b1b4ffd334e99eb3b1fa2c9a1b8008f3af3b0c937684b00a9431e1960df4606cc012b266c1d1465935efbafeb7c178878a14d678a367b042bcce273ff44fd9b0800e0943ee43757f2ea8585c9ecfba1bb6cdb280cc2c52ab5a20f5367e5c6a010d72ab00223fc18184b783db07fb5b5732984173684a66253db9e10bbb9ae6d5636746ddfff5841ecd64e6f460ecbbaca6b28bd334a96316b6b45fc4b89824379b6474ce2ac5e73a124a565378e4d8aa564437e8df255160c3e0ed2915c1a0d97f28bb965ee256249bf79038dbd4edb73a95d230292fbcc779b1e988224c834adf4620fee11934c2b44251571561bd475838b54096c35900130a6644b0a8916751a5d6faa1fb216b1e6e2574b3764727f0e1f17857f97574b73a56bb6bd3bcc9c4f6a8af88793fd3b6f5d18b16eb6b7085c08c9a9017009f71a3670a6ac133cc5daf0f48a5778feb4f1e4f3e31b8e1477858b8261d4e29a51e0d55b5e6d191bede6e83ae0e4c6d3e3b3acaef23667491d691cdfb6bde9b7ee440d10ba76f6e3798c0ddf9a174769702f73b885f77ca23e507ccfdde2867d1186d95d57cd4e27a1ea10a1f5fd38ccfbf5373e708dce83fd14cb336761a9c7bec8cf17bdfa3e35010f1a012c6d3e11ebadfd8396571b94a6fb29127b612c61bfa07c6705c151f5e0880d0d33cc2af9bbe2a884cafe97181d1370480fa44ded69b4f69bb6b1f619235ab53c97a450a77465af32e707dc661fcb4031aeb1e75587e4fa01eb28a7cb081eb90885d14ca7a0f1732cb7f2f03a9dd7895ab8260911c811d2b481a202e99cf82ce9f637c0746278b21a24291e7167928687e529acf144df0aa0c746c3ad8d2b0244b15ce493c1cfdf58f47f651afc2964d79aeb53411b2a9fdffe142acb22ca7b65190ef7e0b4155246f923b9b7d3540e29f4626bc806ff6f4efaa8e01be408d03e9e5a1222a6c441a35599f232146853a91ebd9947ffe1929b3c1b167803573a3c9293ac21ffe97536e6b4c340c8ff8181f4d10fa0550ca674c47c6b292bafc3b96d6d22068cf83c0e73299375258b0d8aee81bd595436045ec03413adee703921e4331ae0b76de77422e23c28c7983f1648680dd8b2e77defa8aa71b366e1b9aab1f9fbf282726aaccfcb96a170fb004a51b6a104a333a698b8b50a56dad9cad01e44a085dda3fd63f66992fdc45dfad65599dac6274cdb8a82b64ede317dd3f2e1960dd57fead18b3d3fb3ecaf5aa265bc0f4c903324bec15d2f94fd9fe8605d1a86241bb85a052c0378d82f4b885542685ece3614f5aeaf6bee68203d0a80240497331548b6965db76de35c9c0c9c5b3aed3715bf1bad5951fa834525eac9a9996291190930e44a0d7a9bc012560bdfdc3855299d4bb7cdae7e73172a9c5c3e246724e296af580c0c291770a54866378deae9241ed4e46069de092245a18df82d84678965766357d108a74dc61149ed08a55ac88096c4356916ecf0273d246bced64a57b8c080a31f73b3c295ce36dcedf2e3f8a54d652fa48e13282433acf2ecd93acc96e7aa84d032e8584537f29103c517e170b62b461e9d8e729ea8b1183e6c250f9484138bb8da2bab16de28ace01be459dedcb8ed3c4b8ee0a103dc543d0a71aaae5c5b53239ac957f21420a15c0dd4c67ac53fd1e3af33b7040a11a33d6b61f07155fc04991ac0ca5c35c1ddebefce41f843e2bcc3b9b5fa0524a02bca2bee619d3be8ba0fbcddde32247221f298de46a93eb5f19e563e00b9a623d21d7052b7f47e04de0b8c86a6d1dae2bfbbd8d0a1d552c0923872b5966d80095b4509dbd631141989328b31107a4f0d85e750eb6fb8517b688fedd3fcf0cc28eda280025a78ef4eaf9a8aa574876ce1db174387f5ef8f2626f292288bc97e99a76186ae1ba8ac06f3c06f08b3ffcc0ff99a260410f10f274a815d0a3859eaa707a1fcb663730fbfbd6c9f9c26f5fc1555ceed42a5d4e2a831e9454f41113298b850a70696e6f9c81df794990acd1ae4e92c624ece2e508697bc5de689d326fb9f59f338b3c7f978b8671548f2503d7ae97e998025f4e11d1c44618381a352f8a36406f417c0068067bf9dddf543d3b89d557c435a6c57e3338ab24490fea2ac488f087839f0037f32edc27c91f750a12418821a7bbfd03e94769f355cd2b49ee6531c7f03536aefc3ad4128cb4c25fedeaf38430e201c3dce7123cbc3171d59f64515b357e63e15d7132f131483c46101ad186949926dc27b487c195c2b1170dd013ae9f0fcbc7358ffc66c99066d48fca5f606ff7a9488702db36ee826e9a4543de807c24420981e22a23c4eb2af8bdd57d148448e2899f550ae8fecd7346524af9ff3ecd2747744f11eb58d19e40ffd5eb309cc0d4d61167ff4091b4b73232f6bcdd2f7f0b0c13cc7d6319ac8d826d24234e8fbfe345ebccf7136e4c40c78770ae283a30eeaebacb70f2bbc3c9f1c87b5072ac29d53bdd61f81df1188d44e0157c72c09c7f4820e7a5d42ffb5fd3e83d139dd2d4070d7339285289fc2d16c5b517dbcdfb6cdf7cb040584ce5509c110cd41a77c4f768e54d94d3b6f6dbd747a312e632d53039f866a92b20823e8dbd18d5544b12368526a9ee7f7f6aafb29bf3380b5ddf199c70c516810aa229c5a89fb38b3ccafbecd45c7a92eda4ca11b1e74fd85681b4f897ec76b8b6f2d15c6b907bcae5cf060b7ff94e3d5165932f41536b0003d25803ebf09078e93daf612c89bc2eca3b36c385562d2595c0b7a4602ab1b2835536faea9a065b9ca133b1d0fb07ca460dfd37f98d7443f601b08885a09ed03d990a1877a168e726d6037939d45fa5517373c5a451173625a165edcac7401f76b54573dc5221513dbcd1edeb2d0778a75eb6c419a723debdf3b36dc32a9df61eafc3aff85ad21fd764fda37cea51f5b216995572d7fa9c077a5d2c67506c69a2c8d92350bfd8b29904dddbe0652c5a0c7df65622ceeef9b5bf3b66b3046112cf0d4a34fff5f61f228e8e960c1c5abb9618f285cb73e989cc9b8b40ffefe31e108f4e6f113bdcd01fc7e5d199ac0441eca8d07e3c472a1817d22441165125698335198bf66d51e00b074ce0521cf4669f9ab182f626106702f53cced9346a7784b2c1d684b5ea04a6e03d203599134d76addd5000f7d37b6348d6d8de760c1813485858fa6833a1bf015d241e0e6917873f0fe48c77fdbc6edbbc60963aba14137bca6ba2b3062d2a697ca97f6c8c04e927f6968f08c5029845b30de6ea5f3890d76b77ca2126292b967ff48e0f101454319705ecfcb65f63e01f078ae4cac17fbd8f89b44f2a88c9779524e4e71a91f30e07b53283a7fa0469b24bbfd2f5b7b4817f9d63dcbee3c81621cc0a82f29848f956abef1aef1be41d3902ad7dec2a4e046cb2b77f2898c0487898a25bb76be4e13291778244e2278bb86df6b9535bdf1f5641280d934b01d89ea67d4882b3d0741624428b7d97f3318c1ce3a165d72402da61c4b2102a1384787ffc65eb3c51f08f71d261dead062861d505610f487b8aa9fa1ef98837ab096f93c8a037f3ec83b55573fc8555f4154e6c6816aa6215a936440a782e0b79cffa85dfdd32930c4eb4dbd406aa8f5b9368e51f7fd4c61aa7ca43bd802fd6aceae2f10488307992c47e39c5ceeedea199cd843da6d40aa4dd703869e3e3b90a6362f7220fce67796e381934dec888e9fa7b08ebb0d37ed8a44b885bc3c65922be980588d269ac04d190ebc12e212d4cb18e27ee595af7d8871bb5301f46c79d907651b28d50f14106769b24c534dcc9421b5114f11e06175a629d7d252a9a7e64e24d7a9d9a128990fa6ad9f969064b8fa0390449716a8d1d4a6a01bd26504d584226dd3edb4b0fcaeda1141dc412872d026ace8562330e41e2a5c3e604915c9113de7455e23ccf620896bb142d8de9c17f5bcd38a2c0feee872f373bd6107f569fd5ccc5b5d48ccc90c550f4e6832f3d40b4eb089dda96a9f998bb09ae06034d7c0ebaac3706dc9a25931d30ac4e9d28e1710929ee8ae57392eadf78b8f434b51f444346edc3b1fdf74bdaecb52941bd3d2084667eb3db4041150feebc10f764cec8b49ebed19ff338c7c2349d67c5beb0fc033c42d6e7d0cd87cba48b58e5961ff5b0108104e0fbd1ce434389a904abd90e0626a432c96c1212f7b856dbbcb9a680797b17ada79790e6250506853e5aeaecff2908c14c5bb6c3dffdf7c0ab77540d9f13c1efe0539a58fc97cc41d64ed77fa16153a9d83ce4efbca1c417b2afaeae127b1e17deb501bbc8c67c37d984f7b14b15ff8f3b838bf4c6031263b25ce1a96af560c1b4233351b85d8778e5294ee1285b425570f2830bb74b5f3a555815ddc7299f100c2c21aa86c1b76b5e589b2649be39323c8e97dd8fbf49cadf79a61cb49ca3055519d721d8e256ffba63e7778b30b610ee1fcd667ceb074905189e43f6ff68c879a923f00632acb8351f13c5608e1320f912ee7a3cf713e9605497377e59d83971eed1bf939ddb9d950f332836c197063bd46b6d2bdf311a310a4140cfdcf9ec4a126ca96e800c243887c947022c913cee19902d0a07f9acab6cf58e4ae67ad22acca180335d5c92b52cac11ce8bd5a888184f6cd9ad2a61cc3102a846d927ca631e2a6d8259708a06eab0e6a350c16554fd181c3ddf4277a79df92bb572ca6a383e5966971b719fc0d27c1ced6478b035bac3980bcfc0bc657e1a8800b63a54b48733adf4d80ebac4aa5bbd5805955e436311352c42c88c88f66a0407e790447ef63587bd3b327e5b7b05a1095bf5481dbcb2dc18c35c046b04e109c50766288f09a8bf2323e8641efb4a5441ed27e65db8b32876ec8a16aec8f5c42138d014b0863de35754815529b5227171ba3cb7dd61cec150f13aff9a9522f0fe2c4d92bd5ca3a225dea8503e7cb513e0f86088b0f551bd8827c586ea23ded099ee47bdd1c1849caea057459331eedbb80ff58d1ba3a5c665ac23c23d41be42f3538fcaf593e5c982e2c7b084073140b50d01e9831f08fc3bf4137b5dd3b99b872c849e96fe11fb7c425bc3394dba111ba3d15fe64b4220b38ded6704eb978e607f2770f06e73ae7859ba39d5966fa8018d904318ad3fe5cbdb69fd8bb766084fb980f0d78c3fecd6c566f08bc1cbb54d1c603cf7194508e41d36ef8cb3894a1f8e6665242b5b41686d47f7d770e0ae3308d6cffd1c01dfcc0fc3aa9bbb4bb16aca8f52d5d7aef0be6bd2f67c833861e0fee1121394cbc4e4c1b6e4d9d7bb1572b2be6ccc754b1796bc050639382bd6b542e0a8500105a08e75a1e1ebc2862d94e46a08b124a6a0029fe371c5fb8c392c82ccb7676955d262c9878e6d67da5d1094e956194158ee7173cf0b2a7810eac575a044e41818b7e3502dd2e7e708b1c5418e58679294286a5e221bf62eb932e609365ffd1b0d507421f22d2501deac3400d1d5916c90a870091954d9020a4053e7ee829b7b21793b79f6aa6dea3cd4973a59e6c073395b187e726982c708ca7983864ada567fb68cccf665e10d83f2237d6987d01dc50641485b1bfa93676ecf7ed9a324073914c6195de08871c120565faf2bd112debae421e9badcd2c000f9287e41adca048818fdd42bcea50dcba40afb00d59216d914ebc4000ad517db84c7602812966c4c6c0250c04f34bc92ac80351ec90bc014f00cd282d4e274d38699607d61cfb1242601d3169e9132c8161c6e5bd91d085e7205e59e2197a979cc4a93ec4c78d0276811f20e8863a110152dae11d759e4c6f239f38346b83f967f65e1b53f31471a147241c686c8ce9c9a09bb319d4f514eec2c3ae79a2ecc17d9262a8fe1f0ff1a8f6a1e413b99f401a1f43dacc1e10232567fe1acda50588fde166bb21d11542b0ff03e1df63318615cd3e104ff8dbbd9f2c55a238e211813547f4762ea61fa452ce9404316f0776825d57885b1fd9902b0d416786fd395f89f797037d5a58e63a621a0ca97fab8ad9b627d51b1132c25c0b485457a8fef3dcc78ab8e08bee1212720ea2747393e2f4c2dc24d16d22d28ddf081ece95f6d1c0246a7e3cbe2e925a7b9755e7fa08e1b548c0397846a948da7cd48058af268fde789826a4bae0a416d9fee9504072012dc3ad039b279d4d8b61cf7642632765be8229152121a6cf8567929ce3f21d51cd2c65b7f8460f9166be299a8833b3d3f3f4f2e8675291cb0a31b3cc907c5149bcd4cb81a9cd250b750a901b84c7013c17c7daa028ec25745cbdad968d5a517fd54ef3581cb6c841bda8e3f983f357fbec6c5d7753784dde9c330869d0324d855f87492fd2de222d48d6ae34a2e1d0caf7698689e209d724fa0037c34a4dec03feeff7efe57c1fcab0bd769e0ab1f44e9324581215a41084e70adf3da723a84806eb7afea4ffd40954afd63c1a428d9718b8dcb87bf3824921e72536e76d3e24c1b5cef0170c8711104cf72afd3c3008983d4a9382790f6539bc0b6f0d7532145a4611ad5d2e906914636328bada5bd2570e55d67bc2fd1182e432e94ab399c0d3cbb057d43f43b361b06bb295e8852914a83b564c8c56d9ccc8c3b39eeed0f1b85cc74c53ea5d3ae1ca1319546cc6aa332fbe56a87905b6ac8785340e58c7781e5bf20117cef84a7006964b49867d070690413c5b07e10b82241b652e31fb9edb36650c257dc3f3d86e94517ba197403b4aa4d1e4356c9faea411c8d9c6c8a073f214a3d3088cbc4c48a02e103a5201055373c23ab5b7792c81b90e7c3c2d324e1e665e462d9191a66107e1aef8ecc4f976337093611908b7fe106a26923aef0e04ac629b03492891eaf9cb921c25667f9c89bd6514c40bd1765fa972e50b5c2a454a79e950d1b50a6638c246af7b0d01dd06119f1ddfd5f113953ff28f6975224b0109562830f9223f5eacf2bd9d7dd2f3e6989a11419552f9891cae4f5447afec652558deacaf0d9b65ac7a795f317e797908bb655e24162820ecc8f619b214a67f2398089c95b64aac722c0055b3ac189792a2e3ef94e24d1d086dfb7b5f5a42bdb6baf4aa26f3f1a5fa11e3523d4e239e33b11f086f993688077f58def39596cc84471b8bf85e45d5ee17a2b8d73dab8bcd94735a33eed4d2e85b02eb02da04653db951813151719eabc396eb561acc45744f68fba4319d236e77df01b858758ccd13f8d64203666178932e04d6c69801068afbadbb8c422ffdc243252d55de15c641dc4aa606cf766984eeb054d3dfbc614e15935d3f260c3ccd4be9ce2f9970c09b44f92a61412cae47b11c0ab35096dffdf8531ddce2861f0ff8606891248c61d198aa2b707480390cb2cbe88e4f7120e2a70906d8018abb4f55dc66a607cefd9455a0606e44ef9d58916846d1237b6ffdc990c835239d7b6aee34c62e5d05703858266b02fbd568586768a57be75b0724160eaebbb7051a469a25f4dae32c737884313baa86fd22da465f7f67bb8d69281674cefc5c20827a2db02f2590ae57a93f12ed2f20d9fec32362cc1661271aa6645fe6de5372211e67529ff0500be6ce84938c808b778128219a2fbf996b446ad29e0d08331b0b6a634dd039dafa1eaddabc311e85dbb023cbd06ff9ffe080c8977d901e4fbb562d4349ef05a64f592f034b1aae6842ac84f693126c9247f5c36e8660f27d0a82bfcd5dfb7b49425f94f434e5f8dae1582e7d718304dc62e059ff0f94e41ee86f2b61d54d5facd9cd421262eddd6e038f5d4323ade68c2a0867f230f5e01c9b28101bf864ecf527f6fda9d4da9489b9c3288d165a337a6e8c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
