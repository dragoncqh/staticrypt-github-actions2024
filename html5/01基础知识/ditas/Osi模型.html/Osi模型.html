<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b4839a76dfd4c7d0940bb70d75c806a1e11bfa474251be87896bc1da91d06c52c3a1f642f960397fdd39305cd9a44b1699d885aff802a965582fdbd16a547518a5b927484995de2eda6268cb96c41f1e8017d1cda8dfe7bc74b67fe6beef263c4e3b321a7fa0f9d0daa2b379930b01384cdf2ecc64be31c06a90c9c7dd90b3e2d87a2636108704270972f707a1b0f1c964bbdab385083bc2c0672eec8970e2927d6849f4dfd4f51f99d037b33ead91b826db575062191c1eb47b645fc6d05c48d2536900f548d4c7133cf55bc8c9b7a35c6b83781efe805640255ca062de0d566a6f4834f3699f00190ee7566b86bcd7d8b5b1af96d4460862035be2694cd444a3ac150736e3277969c63708e213609f998b2a628e9890b55dcd44692c22d442c653cc6423bd2883368ebeed07ef0d6ccdead6ee4527b5caebcb89eed0f86a5f89be40e99ea16b73a9f2cefc4002dc6bd2cb7ce29459d0f751d4caadac10ac83e38f181bc0f72e91febd4a3806ded6c51cfa60b21885829109848d2294f704ec127aedd7cbca52d5b5b3eb80ecabfa623b68acbe809a5b80ca1b15a6d05853b68b3ad3f71f8985b6f57b0cffaaa299e08bedeba82930f01b809774f916be0094beea119617b1e2a5811c8f3faea6dc3cdc0f5ed730c17367238b883498d7982c7f7fd763274e1ac563c1e6e7d8c6612abda7909d818db7796fcfec9cfe5c228cead4af483b5c2888dc34bf65bbd44f9a203bc8c61b5b66c8c04af94597d89f37cae26852a87cda0c037340dc83af974728a9c6c61387cc4e0ca82e8c51afc8ae320c61bb84a6bd49a5847f93c13acd46be787f017ee7cc7bbd217f2590f8559bd803cb2266402cc91d2f16cc9844ff3a07473bb5ca863217dd343d52dd68b7fbfb162c94e5b76dcaed4b242e241a14f3db937dda10f4bfd4156326fd52246d112c7b3244c2bfa1f63d0843e4c8b56c6744deda179c8702b9984a22b40270dcc52b266c351c7243ecf2dcb1c5aaefb17fca85f00d48aa9d92b930008d367ad7c6e0520a0d1e174136c1d8f35edcb0319397375634e5a4ad950f03f4462168ffed768480095a58ca6ffe48ebef5ed4c72fc63de67682c0ef0e2e824cea10764fdcfb5ed26a1a640eca95c4a8c5b54de3d399c1552f01797766c883899e7ff3e9f56bb2104352bb122e00f031f5c292c0d5a0b803212085e474c9546170e9722af91fee1eb83c03fcb4fe2bbb940ee71f724a4684ae293e2b0d777244a8308ab333b33215b98b7d77d8584c218a7c14448c0fb31946a8b69e6b793fa48f21cce974c10ba27d658618650a45dbc701700153e32b45b94dadddaa999a4ae4308a985a0e0d37f2b1d566ac63716eda59fe3604affc732a23c4719541360cdc1547cb75d32c44cb9d4c0400080985e175700d4e21f096d6317851f60093f0835bcabf1230123daae0701b1a94bf7659679784ac77cc43b2680c12cbcbe51354fd7ab8735bf1af515e0db23faf04d3779fad36defdadefafb90194653af3004ef15ef7dc46b1dd17566b555ed8fdd7f36f9703596501b3114c9392bc639f9f24c9f0a66852d0e87cec2e45325636c1d3601cf805b76f85420fa5c2d9e53c2b4069b0a23875bbf440509958211a9b4a37f8d05c65b033509ec6139c9721db27ec892a72b1cc3087255fd847c1715134431dd81c55d7af9e6fe1d11798cfff330300f5fd112494cb34154a4ee68a5a7b3b340683c7c86131d8d6bd034462625ac815a1eac79664181eafb75a54c52e2ad4b366b94b5f6d5e2512cb65578671a86efe97c3c1901883bf91a84dbb732d92558ef157be20d4c9183901f925d054bd56057a3a7056ac2ba2ba22a78a335318d8db09632488c5139ad110ed057b61809e66ffc9e77bbaa653394c7705367acbdd5106448c45c32b71227d376c53cf8c2e7f0ee553b57d7b18753a90b6796046f83459dd5717d12880e50738ee33a5a83648ea3cca8369e7e2cf4db5b13b2c205b217c9ffc4b874774b21bc5feb61cd5579049221cba70afe151367dd1d05099586f3d250a376d97bbd8fd7eecaf40c72543160af0439e22da9bd61617e3698d9adcc4be0680d22fab88dd260822f597bf801acc5e2275bb368b0d30b6ee5da727862472052e03554125875f5edbb559458e89f4e3a5fa3f23a953586411a7812cc582b3965e7e1df6a5995ad44e2e7ad592a0079d3237031c9f180b3c8bb423b59e9114e737b579c7f63333311bc6d66337b68eec67a1c8cfb4d5630249a81b9aba759862461f42d0f94fc0e4c53018210e37091945dcdc0224ba813ead7b87aa52a276e5e9a1cb8809cdf534904b8f3e0b7b57276912de4197f8ef3f0047bc34f1a80f507271e8aadcda35cc5be6ce18932077724da7b51144dce604e30251c308a996cce91fe17df502a95ef6bff8e581469eb6e6bb5bcec5c77068df96df48842545f80012c7cbee58929e996462182493df2361cb25c8d6bd0984b88028eb612545c26781cdce4377f48dfd3017370ccb34831cb30cef2437203444cc056622b3e3007c04e8acef1f50753a88520aa249172edf0a2094080d231369dd2c2905cef3421e3210c2906f022cdeee43fdf586d2188f3535971dc22c0f1515d7e0f539dbc65ef6ce2d745341c38a837cf20ce0d7681b66c7b46ac1d460b2e327d48db8ac15df789c2633eff376da0a75b98d6a66ce451f810bee47ce93d2b1a59c3b5fa0dbcc33fa2be4481a76138deaabed2e6d0c324dc4794c973dbbddaf2afa5022a27dbf25f24438cc87cfdd9e44a919fb571d3098d2c2a4ebd0f4529aa76ecd8c8d1bb0b05a593325c26fb10504074c893619beedd52f2615f706983e641b243b105987cdf92b6302c20c68f542f64bcf8f5e5256910066f88a8f6db5f0a5e6a72bd7053ea52e5aa6b116e8aa66e22363c88e9bb0238f8e2beb8425afd5c9e7f55d970fe3ad77c7fd6b16d5da0d667244c6c28b977ad9ba4e79f612aec4c7b03c34c98908815ec5a63888cf5f1f95642508fda12623aeda15d67af67ee334d0875bc2b46668a58da4b86fb266b53a181d384ac8b7bbae21ef1839d1c8656951ddb5fc6fcb4b3967d5d6a1cb935aafaa2bdf04e45ce744eb90fc75a0c22625525ec5840e66be007bbb2a5882766a07e0b913fc5401772a9f40139413addc663e55ae70990b6a3f31ab4e140fcb3456fac1c1af74770fb5859c87f63654eb5b496f06a3af465e2cb0253076f0a7fe275c5c3643d65eb4cd6389fa1acde6b82c2bfb6033f35aeb8c17384ef39e8182a654b38df1fc2c472faa55390322c4731746d52f0eac9910a8d88347976960e0b92aeee224297a8d7fe86b4164fb9a7901dbed4430e6efffda6ac443bb39d7aa723e2ba8897adb536a62074610f1c031f9643e17f16adb7021cab732ffa5d5603634e99282bdb40400fa7d2088eb6190e71c55e7167621c79293dcee5b5fae9281289f657d9a4045205e07f8843c62329ecfe6f971da0615d79a2aeb0213076625523324cad1662f589484e18ff848985a24ffaa60a497a6b7075c5e26e541246472dcb9d89218a5990fbe3f0d5fd03f3c38f4477639d85b60612ea4965d0e1df521946e3cbbbe24e6d6d7808477bbfc68604d12d042ca63235c62108ea803a1e3ac0148362ac462d0969c4cb4f09fad944a193aa246f368fdb41ecbd101107cf0b36d209ccfdcbf8764a05cb8b79488dece8e427500093322ff75f4fef6f9b73c5015965c1f6be15e70e480331097e763666403e2ec457fe2adb707e5776ce501f3749f8551e27e721d14ee673515960c8b2581345608cdc2bb7f54006b3129cb04bed5f228d038a7f4d8fd59ce5a5bbf32a4364c221ba5fb4a3d182fb4b54f0d643c8d01336fa0eaa1ef42958b8f92c0db34dcc94568139d67b4e7b7f161c6b457337d8765d8e88d12c0db2109e8d96149e055451f599ce5bd467b2ef2af760249a530d7006d0235182c14f2db094b2f8dedecc3933ec76a2b63c846af9b81e1c10e71eae76b94803a880c7c696392c2332a2b94ab3c4bc4f8fec71e5f252640d6b10aba496c447fdeb16154b6af321fc21906e7b24347497147e10d6532dad8ba26640c000388804a67eee84db427f7d084caca8506de4b88abff920c259a6b7c6a0edbedec4c412dd9c66d000965db75f11744d21fa6322350f972f5f6f8950bb35fc8fec3504ea0319748e2bf8512272336d3ef4b93e972a27bf2f02ed5be0a6393bf809375117efe729ed2e1a332b514f27daf84d62b5a14470ec321bf3877ef27b442de533229fd1636777be7ad465133fbf124e03cda52ead6da551ab7c06727ca814554d6a46977b561766dac4734b700dda58dab132ecad39cf3d10c53ca28b96073e8a6b6deea5b484afdd7c67f143ba60b6672318831f4af9c823c9f6e06e2206a58ba6a6af001ae023693312108a848d8efa456d8c54d69dfe610960da1b15ea5c3ce7354c3ecbf667bcd53d2bbd9fa0607f8cb09fc2fc87f8b2106929d778d2cd3b47a9af35ccc2ab254c1d161cc0df8909015d6e646402249928d049d46719e851829ee1af97b76f5eee2177b3124eca649e1c025a47da1ceb2ca28cca16fb3c1381093e404baaaea95521d5f1e2d57a3839f125aed5f8df76f3540bcbcfda896478032b72fbd60f2913a6b911fc3c47a12d0c1bc9894e32ffe41044d389bf01f143f6c2c33e333e4eb941aa07fb3a28b372ce938daff6ca3e65b5b8969a6527057d18e313093c0fcfe79c53b6ce490f5a5d8ff70341c90752234dbdfb26cdb7d60ae440bd924c35d54f28aa2b7cfae6504447128d25a196fdacab4d91fd5c2b633ff158ef843103407efbccd765b819cbaff97ca53d7e525179191984a53aa76ab8114279d143b54c3a2797e15805c4ec435a4b9b2b99b4c28a511473df5de352828b0e8fed9b7033f1057b4316a9907ff4239b115865443899ef6359c7c2ae352ff23928a60f7d6f7bd9eda3a280cea0be88af6a28b279a940832b4e72dc9b63703ebbf02f9382b8638d88f767ce03ea64628150b4218143ad564164d1bc412297c84c1f583795b55a69a00f8d239c5c3d7a666ff3302e8f8e148c4a245e6be05c8e395797fe8cd27fd5673a9c62bed8694ac15a210f2243127b4b917a90f9a56e8c2d2c3ed5b2d4b7ef326fb294d53a6eff65830d6b6eb3a78557ea4177148878e12eb1ecd53d6b8cc1a788c46481c56c2b338a14a16159ed006190291c686b2a28ce3f79033c4351d504815f7b165c7f71b6c92008eaa8a0ac9ff2c8689cec4cf86193ac654bc99814871fa49b27721faf5941668eb2b64bb680d185378acbabbac2242b41175980320f95a7404e24e9c9fbaa978b7501f13ba6f05b7c2662ad08b8bed6f66dbb0c58da8334250c9d404d6737a8102a42db30f472b25f6fab41b74cb0d99b5a38fdcbf0f1629824cc0b06c691af67b75ccfb09f8d81a983344a070425314f6cb209105fceb46aefc203e6e56d801c168c753faf4407a08ed63f4dd100633505c73127efc94354e28e2cdc77a8e9d7443961c977d4fbe70e66d5f0995bfff1e483e01019f51abeef4ee459199656bdcea9489f2e13ad828892a0726d4bb4376af39311fe936bb8d9a7a3b58ab261690b3051d2a777f9112c8918f6990a0acc98264c237ee42a0a96856c0cb0326a8e6bc21bbcb39153d4114e571dc1d667613aceecbd410f7e35de36ac14fefe62382169d8f8fea0a1ac525fac783eb66827e4b05851c7b16a41fae8310bcfa022112056671f2b3a0112cff236c5e1d293d90e1917af3577b5a4a5fc8f5d856b047cde739eb504b1a6f7660b171f160698d3f31dbe13c9055c24a1531bdc26bbf68dbea8acf366f5a33ae6bd9bff0d1178029acf0b325784eb148d4bb7a31bca1b0ed7754ed8d9b187cbdbb9ab24130d2d1775b95833a814e957356ec1d9f3c3efd58ea9d17d249ad89ad98e2fe4b1a5a6b4ac5200f646758e6e7af584cda5bd498b85d1cf9d8729ca32c7c48d34662c88ee46d425de1e56d873fa901368824c160ec0e253f394b988b09c9071ab3823ee3ccf171a37d930a17a66dd347a38856d20778830bb287da3d07a5d519c084c3cd1125cfa5802da3412dbc16c34a060ceafea1fc20fde4dd7056968815dd659702e381544bbe706790db5b91d6cc29c773323b76dce62bd4f2377a6d6e4f06a85ea22fe2bbc0f0efd8244ebdcc2f2a85c59d320c98e3dc1cfcb43bd79cd22acf4ae6d50c17e8421ffa8a3dce980b44f9a004774417b70c9590158098f3c6216325acd9297f200eb6756f106fe529c865da74f5426a59348375ccaca44cec869bf1d5c86be949f065bccf31d630fd56ec0ab712bba183dce3ac0a8be07ababdbc7b1466c0dca52a85ba69d9182b995ac0d1239c573aab684fb310c98e99c2903961b200b9accf161f294d74e0b312198733d225d7e63102cd6fcc893da1361afb221a3f965ae0f11836475047e335edd015227d081fa4855ea646e467c763c52b1169c79fcca2ea78d553d4447a562859af94d397be29cec2fa6dc9ae007b30e51f225c76a22b42f7d8f28e104fe73da576f82178130256dfd7e38a0917cbd680bac5ccae7764c2fec233fb01e0192f956519b3de44cd044ee152f911f1b3bb4999fb602cefdc726a6746eafbd04fd1a6e06e17a9e4c8f730720faa0bc4ef396afedc997bf23ec9c1907e421e22b57d2d6b55543ec5d392692e7cc34310ca58e7060f3ed3fb7780a450ebfeb90368ac4ed54a28523f558b77abe81601ba92904c62b4ea4c2555db458a65a69dab715f4a21e18f6b2cb3ada1312720f6d0b3faea8cb887112316943fd3ccc0850ddc231172d491bbd69bc8490bda1309ee1b53c306c5b53000299c795dd3846e983ae3b3ac8d8d6ed2bac2f60731d2af64ed6c48e4f15e797cad54b9d2714642361eaea942f2ec798b76a4d407665d5fac363b6cd89805a8304889b9eb2730b936e6fb716a31db6e5e7c351522b3916113ee39641e0a3fa7bfd13dc61c4046f9f32964cf8a960e20e19d5fcc0ee793cb9c067080a92ac071ff81cc1becc79097ab33545174ea29204d239288b1974c905dd5aa906d7f419bc1866eba50fe47a4d8bb67f968aabdb71033babc6e07beeab9cc44eda32f1c0867650770059cd89a3b16ed2c432a372fc627a37dc41ae899517c68702fdbfe40c08d4b5c3d6254603c1a51c1866c17e31427ad3f650491cf6a72b638a034b50a98922094f3d2c160699dac21c86706fe84d135cc2774a0f16a567e653ea8deb023ccdcb8d890a56840f601a60e527249e13662e7b2e5c2b51281699f960681c6159f0f96194906c0648469eace5250e6d52a130a45322c189341e5d0fb692ab784d98660ad404cf41baad7b7b36e160e68d26e86b0610e84fc51b64152bf89a1a39bd81fadc3c12b933dc24d5d82ea7fee6717cb092a183871bc501166eb50827bef0c5584e13bfe0578b684aa82b1d7a0e371af241d6b2488ea09254756e6e4af5820f1c1de2f0003cbd17381e173034ccd4637ae9cfd04743410d2de2248df1e9366d02ef01edd7921d2f9b717827c33546a98248850b877c8d699c0ceb5acff25a804f69e5fc5c3088b6b07dc2adfd27e8aec10bfa7299bf9ba4409670cabdf0760958035ab97d691a7696699bc6b1a1e4cc4961071a631df2a64393666181220494f7b81a2132c96b502690367fa8fb0ea5f270baac6991c116b13fe1231335aacb57cdb06bc775e39097da96695c9c1323d3c6576597352b609026c0683fc05cf8028e3b8a447501cc562d324281d24e84d5dd6001f53913c7755e9e719a17ed484b27a057810ff7925e771d177c02d7a000fc6ec07a5ad36bd1cca631f9d2d3afc46a98b19c931aef5351b778d48e4034922d385fb8095311fdfd1a198a55a9ee6ad98bff8b57b33850d13c62aed498b468aa0f93f369679820c22b245493c676dd50e2d967829cf1060cbb94fee105822ccf15d4ead0758d9957239a5cf99eeb8f959109c0bec0322e822a5892dafad6132270f36739c9be5c50538f0efa7cff733e21c7a456b7ab3114e1216ef1d2c2c9cea41cd7ce6a17bff299af608c2efc8ff2219946f665cf13792603bd8e62447792e4d76d9b164531ed096d61ffcd5c3284bb6a3a55b75dff879a306630f22e8e68758cfc5bd1997f7d59f77b0492019f8f7c6c52cbde3b82364325174aafd230ec99641bce04072f69e115388137f5df3cf48bd751c555ee65abfd867b58f1942a702a3a303a1f8f623a6e6b9a5a8221ff7590f264148e256bd5de633617d90709e0cac49722eb143a10c470ee048e14e17378840055b5543ac213931796473bec5c052054411984625c052e7ee1723985398e1af37555ecb7036530cffa19268391ded46a8818fde3b0293567e850fb108eeefa8c5b8c71d472b7d753161ead1a341ac5bdedb214b1ee5cda5dae86e883cfce5cea874528d277ad752d628e3f083ce65fdbc31f9cd830e4499fad9974ca0d5886cfa7bb9b9e69022e4474acaec1d3be77352b26660e14c5b843193c249d2df84b1aa12b62083e54d8ec60e879c1efb26468ea7f7ee3ea47e984f15bb67cab5614ea2991390d24ee0b30d35567b0885a9b7a313d4515136a472a14b123e2ae316d1d3ae579a0daa87952a1369d60046db0a1ad299de1945201508068dc19b3611e54da11045a229a450abf60d0dc4dc4b89774412e97143101670cb7a842e4a328e8651e15f37f94026e1a24a4edcc06956c7e9c3a43b2a1869c498eb4c8e84500725fd6904be2a654659f195ab3df576197aa62efb15f6731e4eab036f746118f29abb8a4b3918ac23cc580b556b85812181bb9cf1c5235393f51ee588ebb55fe88ecd4f0a51c418b9baf1361e6064be91aff0bef1e8e1bc5fd6f2ea9be697894e08b6cfa2f0bee713dc2d02ec39ae4f48d8c3393d9e2b8bad4ed972674e5d388e6919c1d68a7136f740d48bd1cedf51bc21607b27f6564d2ddb5362cead8ca859ca0cb9e628bbcf923eb7f33c27f32bc6f9d077aa352360d0f592c9922a725d38cd638c4f35d8ca1230bef3feb6241ee41c3d5fe1c7b5b70feeea9c4ac08e53f5732c571ed233e096f735b64ebf3de052f321ea3ad2f4111157c77efea3ed0363b283610b987416e4eb1f6ac57d88bc19dd0d7d2d2c5ba866c39d200f6cce46bd988806845154043e40ccd16c6289b06880ff13272c4a1c2f1caa62bc0e372241397cb72529fae7a20167de099d1959e7e80df7f8c1d29c14e77e38c688a2979e875d3b9e28ac43b464286d26e032271232532fc780f751fd410ceb7d40811fe3d75da65cf3b17b0f34d648ba4055394d02c53911aba32a88e2d3cefcca97e1f655a7a004dac4c2869601780f52a9326aefc4d766608618f9c1de6c35a6e8dd02a6179ad84a0210833bdd23daa9b5d64b2acfef7158185014915e4f37bebb21a90dd96dc0e9c3cd1e93dffc392ee3f77236779e24b488a4db42fff91a4e3d6d2587e66c093004b48fd6ace7b18974670f84151433efd96ec88daa03b75a0dcb1dfb40fdae9e0ca2af3d64a68d5b4aa91d31703090033a3e909de522911118f05d69e6b9bd87650ac0115f5bea95698b6a9a37be0e298f7c208dd63223785bbd3159d135cb265387075b547859e24f0eccd542e9645e2e8bd244af7fd9e443f33812d1205c78b6f4843b46647d59a0a264f410d9aa3679758cdd773291e85a08cf1472c11709989c73c6bde86441ff6bfc740154ed5e97a66c453e9c0ffdf4e861f7feeb646c9a0b0b583d0a285b1c5d9a0ede38009d5ea2a5ddb579aec49e22b83aba8e76665c1c40ffd2944007207662f3180dcbd543d5f170491c0d90720c16c9302c78222b0d3644dfd16406f1742943bb65cfec51b2edc74d87a8c673fe2bca72a9139d6e8b878a816af96052e0a93760412b4769952d2a6f285c59e474f823d9f2b2a571fd379e1ddd042f384d38401e494cbd7ba0e89898417f1d8010034d49dc6008efda4b5ff218ae0e73a5519b1a2e150a7785030ee0d060ac952a2e88b4ecad62b24e40fc5fe0aeb7ed1ad88f917087da239bb94263be9b1351e8dd6553a9df0feea517620e497ddf8ea1c2899b8f91586e5dfd3e3a7bd8efca1163022bccbf3223f0b82089094aafb48130bbb1e21c3cb98e5682d1482cfe044d80187f4d39464fdadea911db396c7cc3d05cc41fe1efef4619f7df31380db520bb8b73618c38889e661dc1ae9b4445656b0336437f8155a05af61f762c7e27dd5bfc88109b432100435456613145b18af9b3d3c9af6e09cd31221fd30121594258571a5747b48c99d59b4e5309b378917012bff7350c0ab3bdc8f547f7fcbcba8a753886dbd2885e18dd2d0f5f7448f13f9d2d9c68162030a64873a7c3c5e749c4f9eb177c0b8ed32c99a1f70eddc875c25822c6a7464ad3cc00544988b1a8da123ecf78dc801e744300ee53860ebf8a20d04fa9536d31b20877146e3e5214c242a33feff80313e9476b2e0d6be9da070187f61011315d85a65097ddb75f021cb94f1fe801cafb763e0341706df0bc06c719183f82e58d90f11000d7262f8d3dd5354472d974471c8f12be13495d20d5d3ad3d373dc3fb7b754d35ec0d955e7c64bbbcce822bde8caabe89e7118e965d53553eb60e8f7987ba70bf13d2ee0ca50765a05f4d1a577b127f006c0323972e380c42de8cc7d2ddad789d8f1c3671935c541916c7016c48a84a02967ce02dde2fa9e4bd61775b42ef5adff6c07e0a97819b094813ad46414fec1454d05dd488d144af1bd14382d0e933feabaf9ee24af0f0eedf51299ce151daa9f4962b5480f28a08ac29ce7a7c0bc72801c286be41240ebc534db986cc2461483123c2a93cd0a16ced0f1392b6e16b8fdda54018886d3f431a8f15768c5c8efe6e5885619c6ab1332c6a800822dc44785185d5ec209309308d2f44f10c12f4f04023fc6fd910117851fdd1578e50ee48f92ee46c8c122bdf3b6529e8f10915cd487ef3736c4fb55f5e4aec66bac57197c3b46c7b2ecb43219c4762cfa72492e76e47ed99c54f8bfae0009140f887cd129ebb9d99fea2d75de54b68b4e1182c77592385ef2ac1dd245185923938e90e2089f8be388a4340b9d22a2aa0ab2b57f2108975d59f0e069b7bc4fc6e0490460c35b1c48bc13db3cd08c28794c4cdae3508283fa8a519d4de80d25ca268fc273718779d6b0bf0dd85f2dc3402ee79f73c62b6d0a796d54542b039631781098dda639d62b56914a7267ee611a5426cc0ef557f24049870ba9f8adb6cf3f3b50d5058f434462f6e01230bc12b4ebe152e256b93ca3008ac3075666905c6efa81fbc4c39bb16e3a16c589e5af327ccd026c29766e5d7154e527a4d5b914a3ec93f04483b732ff56c433e1b318c492bb3728eb8f31aae691838e704874496e0ee1aec82a696eaa4c8f5239d3c385c67eb4ef78cc21ccca433eb919d2362541db57772b9edf827498c132c5ef74abe9f2596b3dc246d71b0799761367f6a182fba48496d5086c0f38a7d7ca45e4cd4c780bccbf600bf6488687f80ab082b95cc09c7873b974629fcb4aa94a1549fffdf6bf9c8905e3d9b8d964e39f11938349f710bf71f23114994f1af9c688f4c3ed69ad0602a08398bdbbcbda07af755b6691c73ee7fbcb6fc27876f031d35e51d9d0c0116c33635da3bd8d015ea362e3a9d452fac4eec7573f8ae314f0882eda30f9489d78cb487d39308f38da872eb11fb938d259680546f8404ea01418d8e017281d91de3e162ae2d85d9bb9d49ec0e419e64b2dda6bc7a7a6ba817b57acee3a691ed415d272390d142e0172fc768171d5532fb59f69e74ef97938917759aa9fc3c2e450b15d287cf77c0b5116967f5e2a8975844c81a50627680fdd1de0d433bf39e4dd5751a136f0ed679ca6976a9c9e661229bf18cefbdddf76a4e1abc15788e7b5fac9674c6253c62e53cdb673387206ce6fee5495afb1503dc40b56719525df31a28ed25e59110c339c9fb0b950da86c664cc795d8b61340470a72625fa3ba9b3df13a170d2095eedf8a95bab77d33772235a830ede3afe8e9ebb0c1c48d239c259937ea835365599c6bd6b12e8e2bc2e514c9ab99b8c38686a1dacca783ba8370661578a4e9f248480d1ceeaa6e43a150d8a6c6bb05fb2356b8ab2693ef90e03c7e13474581927a74e020d6aebeb4ac9233532223da61b8670bb13e0af93086b5376d8569aff5a0ada1f3476448650eb30d898cc846e9d344f0f9ae0991ecfc4d7c61e9b8044df4d68711c0b0078391b198956bf27b8bfe0b553238c373567055d832a02408125c82842671256aea346c4b9265eea8f79829381fb648d759a3fce88c9c732ad6df80425a64e6f8d869f2c093a91af22100fd64c7019ab6f7993dcdf9b3677f1c3a286fa350aa4ff2e442c2c34274b82254eed3d81c1c048a2b0ef60e88cc929aa454e999adc2dc464bf192f3a6c8c9aed1d755f5e1173a187a56c3705d245db443cb57bf88403d48efc47d14a681bdaf383ad5085644c37d5bdc6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
