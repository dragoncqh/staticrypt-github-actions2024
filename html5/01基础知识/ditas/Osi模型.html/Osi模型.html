<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88e8a89536ffc780e18bbd83aaacc1b8808fdfbccfa952e28df6bbbadbfa0bd4ebeccd1683959557137b1c3d5d110a7c1f0ea037de3f5b36faca2627c3d80c81f86fd1f4d4655d1a9d9b47ba079d70d47911267738ee43f0192203dea0863f9a468819a5cba06cfdb2ce52faf2f17ddb3b60fca9e670016415018b4bf197a91e0d336d3d9a71b502ff6992b16ecde1482adfbae79539bf20b9399c09519a180b9746dc8e3db2947ba1c82092bb3fdda0c65e11965794ede35d4f5d4bccc124ddef57ad704f1acf8a64cbd9ef28244b564cd4b4952d7cac53ca61a9ad06ef655c657bb8452b31a6978c3996ba15245d8b62cadfacd645004ba3fe4d65cb5ac6bf10c4d3cbd51e3e2ae55a43d51bb5498edb78a8cb4acd7f3a3f1bdbf305111e597f1856339215502a1d50c841f99d8080e067e0158d030eb04122101aba07a09b5ee3f734fc740438e9a24994cb0b76cc0930ded08f48bad5ce6abb229e25307bf48616629aa20dae686b97e455317e2a3faf6ee4f2aefa6362c75e4d85424b4a6829e2457aa1bf1dfe61f3be5483ce8029b16da11a8ec2071083899b62aaf629a4bb9db88ec36221e4837aa70b6de350250384ad947a268a344d5a38ea9066d0fb20771f763bb723c58d8ed5f821a93ff31c7c993fc7669d6f1ef87871272cd3cd255a11ecc45f56157842bdb165e4559fcf034302df771d711ca51d1e5e0ad4384dc0f877493ed605a00809c28b225ba977459db4155a0c4485111210f3ce520520ed274cda5a431c45ca72eaf0fe8d467e4139a27b1aaf049f3117ade1a00b2855d9eceea4c4a9dc3e1631dd82889ed65bf1b9a65dcf25adaae155b2c63c7d4547f40a16ac19191a0d008063433d9af36fd2ff7121ecfcde5099b588caa9bb686950cf155393f1aa48a3c5340606d23e0fefcf9e1b95fd6a2ca99d633fec8bc36ae90cc9a6dedb3fb1c56209474a91c63a6c57d33cf16a0fab0c352d665131b432ab5d8148af16d1d5ffd2253e145647feca8475ffd8eacc9258b76834a7863eff7b05dc7afac0c4271f67c928f2aa5398707fdc395976fd4eca2706603cc6d76267c0b794d0c628942e9df630b3510cb7cd3bf30cd70e3649065731717fe706587ba297164361ee48c96d6467e1b7b6982d8c096fcf1723d60ce7b2a4d504564d0dbaf3c73795ef82ad759347650d06c231b5132146a98021533a138c648e2ebce69b1d3fe039b549b5c948bf55ac88b4f27d6194f2cb61cd63b6c7f281e8068689295476b35a40e922249c3abe1c479423f18baf742427da7cd50d59ac39fa93a3e7f9287394cbad2c8a6dde9560b90420e2b0f41a98d059ab8b811f5ef0077517257ce549e91e1bb2779046a4ee56b4a7890562c37dfb3f6217279d5e9486a1fef7e6a914754a02e123eebaa6b1845862f2afc45f8396c721aa9d6c75c7614a167ca8d4fdf76df12d49f4ae787dbfa212a91faf0490ac0f226e692ef27166c7f991e6f96ad56781b1b8730d9ef62c9375bc96cad99bb776ee77c923806c0ad136a79f0db5fa0167d8252b627246b53e9d202294ad38b07b6cce4923d9ac758fc4d8e81a7b22d102eaa589f28e194311a08db4cfe6154b9ba7c930ab7d103677840b8766bd0f93288101eb2b208ac5750648cfc20ad005b1f334385f10051962d34e84238156b443de67a7b9e446682ffcbc6ba83ca432207f4baa2ce5b99f22b4224c2125501f71dfb792ef85342bc605858221ed9fdc7892d478b1f5ba434f7271f13a750c56a7a5bf59ab649bdc05436539ddc42be0dc9fcd17fb46bd2ea45a541a2fb76d57d812a3fea0b890cd565d72c55fa928fce536eacb1c1027c07b2c5adc49c706af0951dcf6c246b1fe00ae950fdb7b74b43a30e23d126efce5bce03c8bfb4982c38fcb3b65f148e7631782025ae00f24f833ca98edf6647698bb572ca3fa456038b7eb0ae86aaa1cb0ab0e31bc01cb6fe1e1c290f55a615d5a9e3e4efaa570d1c43b178be382cdc9b6602c99ab81b55a13e021787d376e6f17d01e121360d3f35ed6f246a73b115d16a9ed015ffef1dd1124d0ec03aaaf45fdfe8ad4eaa4f13502641912081a3efdf3d520f8703e25f980b74a1df7a47ae7ddbadf1ce279191e963f93a480042077f72e79d0d296f86e4c0bb1fec8779cb42bedbd182d05ac7c39f64235fdae70aa3b21c840cc86a251ea667d0e212ec0bcaaa4cc80281dfa435a3492ca38c4479877b68992ae5fdd3423ae782be7065a7baa7b66d6ed779468c38c4ea1c62874c7264a07a157d40292af4c0419c5cfae54ca4e9105b52ce7596d1b14bdb7e6388d963126de5aa38eb8e3ab13403c77c0c50bfdfce3de7131f230841196e4f3effcc5a4220eda48a05c46226e61883eb8a9adeebe2eb67cb37a792232ed794a3f09fb72acba3f0cd46038f3376efbc59f256b9d6777f1dd90ba0736bc00b6cb108b0c08302bd12be3c2daa3e979d42fde4f4b8b748770c693fddd60e9da8597415b31fc3367aaf029de4a51b8ade4403d7fc9b551bd0623f199bfd4b3d910bfc1ce5ede32011b5a322049c428ae01b49b9628085c0e177f8233860bf9504f91712f04ba05de24cdaf08da034f6291ebb2425d60b3bda63771d9cef7a344c17e037a74fbb817381569a955a168b65e72b983e747fb3159d33e7c68c0b12063feee8556c9406a3c0003aaecea07389855e0f2725bd573655b730854cd3b0fe127142e8df2ef8948c5f586e88bfa808d361623c708e54816dc1009858a9b4b8662d386c0dfd4e74854af095d0a540a92da14dbe674bd140ee2cc0129ffdb491431850aee14ab354ba189c6e6772b894818d11c1aa967cd6e3ba50010490bcb8f4171df4fba037a091e9ac16728da8651e60f5399de7cbcb7aa3d313a50b2cb8d5b5b43aec4cc1485a57eae4da106c01bbae9d08f1cd2c5cdb006ea5917c8690fd65cbbb437e182accf4c9926bd3c48cef89825050d2bafed04150387d85c9ad46fb97c2b77973e96e7c67ba2601c90cb415b712ed6c9aa24756f56888afd1a10fe1e4468eab81b4097cb2898b6ae99b034ecf8ec61f7b0e6a397043825f7d30df41abe6fff382768de58fc37d09c45a7c2b5763a2f5cf7fbbaa3924fa175305bcfc780a3bdf884481b454330d39a39a65bfcf2c04160dd42a37ac4b33cd634a1ed8f65971b72a9c9fc137fbb0b3f35ab33b7a57f3f353cdca24c0e23dcefecbd1562994058889e5a66154b7c05e5aefb1d458e4e370848498b16a46fad94c0d3dbf13b7b7132b86bc33a17d2f5d3883b9a14d7cc1d3325aedbf303967194cb71e85c8b9cd57360efe59d0dd1b2e93acf737d7362bce47e90e0e1e19443894d17e7c1c13e4b7136f45a5b55a2c0eb05c0fb62192e975f7e5a0d7638c4d5ca206d8790caa1dcd9a4cacea60cc8b8f37f673a7fc7a9a33965ca246ca430e1fbdb0a8bfd60a91588b9494dd8356a601be1da7baf585ab640c6d5b6acc22881027b612695c0be8e9d7b0a9315c5348f552d6889ebe6a053e1d56a80a47a88c795e886126ce85bcb7a7e5561a797749ba01b2e511042b7de3cd9d4ba2aa57cb62d1e2baa02e257f9e924ac64336f92685163df9faef7075510559e10dfe362983048f655a0b3819cb9381482db1b41914495ba58dae4aabee4736391857cb52cece47f879a67389a584ce43d3ac6f1a0a6252b5bf566d805810640870959bf54ccaecfd6f3389967965da916d0e917c0abc1a0609b59d544b73bd1cf4491b59d5b15a460acb2219e6975850baf278efed558b08f702aba7eda50fa51f441ad9693bb6438dbbef8f12d59601a1c24f63fb3170198249f4d5376e55bdeef6a5733ae4ed9e6ed64f903c984ec68ff7a8f92353e6e4cf0fe988e9565da6377716f55d288be74f0917e0c3b3b2f0eeed88a63f41df48822d4bc798b233c1e6fd3f6412676ca69ed0686ff36efe2d19f61e8ab6ada5353d1cd590d2ff7cb4132163ad6ef5fe0e2f71e974c6a4316e85fe088c31b7557fa9dc6b6708a5e19f30342c09dd0dcd845fd68a2eef2b656f1d595625997eb2ba026aca6192b6e051f6d425bc0ea5b48294347a7f4fb9822c68e15977cfa334d911bd267499c072a88421f0864be61d72d8d864a596c5182afa3f2373bfa6201442decfa418fc07fe07681cf87b82965368ecd749032575ee6ef61b657c80a78917fa7c29a2e060dea0b15fa735894d87afb98961c8e1d800dda2e43849a168922676cc75219fefdbb2d083e9ba775e3aeb3b82af8c8cc92aa60f6260f77df9cd0e6bc64f6a5ba523178150883c8c022f22ca43a5bfbc652801e7bbe529a4e7332be7d836c3e9eb2dd1a358a83db8a45828922919b24b8f9e585cd8b8cd977373fff8bce8e81d0c1acd13544707df659bcf94725c5de378a90494f081547ad8cf7c390cfb61734216446fb164d7a62f5e55e22f0054c3303036d11b0082258ca9a27da8340c9d16553489f3692cdd82cb85729bd4859099df6cf4bbf441cf03d41429b14c3217a9afa026d0be576d699bf8b11eed7db50aad90b7fc898da309da31d8b41e7b5c5ae0393b6a87d8a71d0d35824f776e37816ae9d24c74382bc008b9851e6370511c273d9a9aef86e61348c8d65f281632e0f596a68df11b9b5a54aa1b1a08e64e0d594e55c3ac018d8df5f8d387c03ac802d4f6655ddcd54c618a65d9b0a689beaa7d6e6d1963620373ac5e3b490999f6ad87c7e84dd7753718a6118dd5e348a8ecc294fa6a32dcd49426c7a46bd21ca7a7ad3662c841b545ef95ee687c1bb44b8eb039ade30e88cb563dbe018a632d9180e6e207961059d0ae6e6a7bae9d898c1e811828505f7f8c94d8e1cb366a9ef2fe8eb1995742902205001cba7e4e40c1999fdc0da5be57bd0067f9992cf5d4cd89861fe820bffcc8c54913013934af531422f4e414efcbbb3cfee1bda2bdd09827a293a75730ac42540ee2a185d38829266f6173537bd1a5963fecc26f4c34c37ba59b065fe057838ec7f3fb56bfa77142e6bec81146b1db849d9c4b625d895acf4a48755e401a5e68d8d6212d0676a8ccbc932b784d3c822dd50b07378ce4b9da88e1a4e754822dacce5f3c3d82aece9763e8d6245649e88190639626080b73d1465be4f1f0b8bd04089fb8cb40c890c5d84f123749798bf72a2d250eb7497ddca8e48eff07a2cf48322adb25c0b78ac49bb99a6f55a1acf79bb5f7a5548600349e3b37ab8e6be7348db664c47186b807905652d017030a0e9e76d428e46789e26d21f369fe69116cae58afd4b5c716afbb8b186172165462bc188f4f0c6d5c6ad785ca86cf203eea98893264c355d455d822ae82826f713a92243155d110dccbfe4ca9a6831ad213f88144ee9af0b1471d8989f0d307217f1df33cf1bdc6a5f4ef9e41d67ae6ec4cfb1b71b88a3c9ad6af9a24227a5f6698d058b02318602d5c6d1a4c43d4c99b9714f18eee2b278749805204d3ae23af6063b013b5516e1ed0d6c6726e7ddb38ac65c3821d4b02de0caac5243e317ef9213ed429fee62ab36f156d7966bf3eaf3c41839d0fbcf214addb0fdee7e7292031d17b3b140e640a6c4b505c2df4daa9d67aa5e5131205d15f9b5546d52b4e12af6726f72790153530427bf11c991b1226013e6bd44baa51bbf5fbc5c96f402fe48121c56ed2f33804501e0fba4045a1d776469f857c91ea05aa121cc1a25deb4dccc0ebaa6e84281d9822c131f2c330a6fa5b1452570aa36b95fab9eba942085b3439d3f5374dbc172000789f0340dadcbc9f2ea90c9b6522d4ee5ea681e12793d48cb4ddb3ebcbc81f6dd0d581d1e4450b15ac24121d5b295fd4d9507952187663e524712481aa988fc9e658f7cb2bf1ecdc0fe79a7511d3d4aa68c3a0c55fee0d9fcf0cf65683e456b52f55bcabb4b1f16777029ddb1033136e9c837df294f3205b4ba600e03efb1b211310c859fa028a34e05f79febece5e8278ae0860a5b2b9a776df8e0ccbb4562fecc851ea428f719d3cb024bc8016558f23c40454cf559604a7236a02c9c716da642630a95c282452af71e2594c28739f33fd391d373e7e65d766ae59b0ad7ccf230ecc8d1acd03b06c6c9708d1dacec0706c86574efc5c0c4d98cefea984c3efdd0a47c17f72f6e248dc8d698bd992be93d853cec793ffe9f19a8040c00831bd872b5e0f54fcebe85b5bdc575adcfce2939645877c51f20ba17e8212c32c3821536de5d686203f96d183842c43b607eb31332e6fbdf087f8c88bc8ea2ea1ab0277b7c55e8d584ba253948a5f460247a9465ae40621e16f594ba5b061578ad0e610bbd562e6b2ba9a795a048cf30bd944e7a61009e7ce8699ff67514ce1b782b3e0088009f8a39c0cbe351cac42337292866b846d26110dea1894e8a2376ba9382d3eae17a4191cbd03776bf3e2198c50333006423a36ac317f58f1443100126da31a0ab7996ea62241d3b0fa5baf33b7f454e83c86f2206f5a8bad58426aedf3f27f09aaaad5b12d8359675c2279243cda7cf20b2f101fa30799c5404400c30a44a8e5f23cdb48b4920d4b07e665f70d1233d07f71016c35054a2620d64a0c49fc1747e58543216512417e97aab553d55e790216b8ea5de6cad25bdfaa6b4f4e72e0b5abeb99bc5ff77d4fe849f5ae0aabfeb7e7fa42eb51671fd2bb57aef0e7a3cbd48004cbc382ab31a62c1cfeb8ef953794496672bd975f782a2c643769a15fbd7b280d1288250c1e2ae6510c3138606111dbc2a38ad8125945b9a8289be5fa013f0a2fc978e24c41f473d6b29e9a8c608b98dbfe9b14eed397e3abe4d3ea8a9b2cb6313d4d32394a038f10a9359e3bd5c2e5b7a54cd8abbcb3125bf6f8b2b43cd4ca9f9907442a95e924ba8f7ea9f9db7f82819a6edded4e07820fa76552069a7878ec3352518f020ebde297a9a353deafa1c6da33ecde734d7ead3d1e3d9b7910849668d8e1ef708a1c8c5fea2603ceed5fab894f29c2dd2800a9662d98bc53ee1dedc03bd85ed5e13d4df330e6bb2c52ccc23fecfd337a0640ccd45e86348da9bfdaf20a9e61e18649fe509d36b240034fec6f2e72b879c7e7c57d87c2403f995d9878868d289f9ba7a691fc5d83be7f38970dc71a308a69fb098fff077cdb2e8b8bee5cf671b87b72c6d9d8b1f44937f935864c8442618ef1f99441454dce768472ed5f095b76b1754c525dbd28d10e3aef1e94f0d998d88c62e8ecd55c557a4592468ce297ec22b3994f1a9dd6f43f10cd199067586c7979c789809417b2e51c4c093fb7ac60a89f8af9c29ed70d7d1d405fda2e539fccfc432b2d9429fa85e0a1112e9710525f3bc5e0da450087e852e64506a35281b086458bc4fd5d83062060bc6b6ad72dcfe317075d37b0d48f60fbaef0f122e610c3be767820179407dae8001f17a03b4d33dddd89cb99b0ccf1e91b68d26d6a80e0113d7d0311d5bc7d2726da762890804002754374d8d702a1cd6c5287f7b01b7c201b5c50bf151ed07a5c198dd13bca75e22065331d93124f888437beae36d90a55f6b5f8546e6bf4d6645ac512d07a85f3557546efed17ecab6931131c7431a37f68ad68ed603d41f16438011bea31a2aee1fbd4b78bc5757a167fccd5a00522a35ccbaba245a327c0eafe3d553b374e562b8a73205122b039b3cab9c5d885d738bcbefc1a1d025b4e4d551ca03938d737d70fd0de6884c82dd22a02f1895b5aae3cd16b7ca9ddaddba3cbfbb944a34b1183640533c9029e22fa26172a0b6506d24efdebc511edcb674c34c205ea7dec1ad369b8cbe025a370fd7d341fae6c2c5cd3e1722ec09dc1a91de0887c847726ec3a4d3f759c7322f97fc64bfb2557dc2cdf5031fa21541117865f98c1240ced4082b6df20aea9b7d806e106a1f1df01a9163bf51c2d2774f6971f3a823c26a2e543e36a3970382e5c0ec1b2b8047f85fa54ee1a3dc8c99915cc253dafdf3cd63507df23b1e0001ea3908d2530158df114ed4e274637cf97953c852cbad16ff088d9e9dbb78aaa922efed430128489376a4f8d11720510a9cc8492ca59e8b9d3206c06aa57f7e5f51e052912583be802a980a80f93525a04fa61fc179a24d6ba8e208e348b4ab9942a0283e9f9434915f479b0ddd55f3211ef56ec1e15e4f30804f17285a9d3cf18cba7c284af7fac790ca14ef4cb41ff666f128e60c8d959b4520a6a6dfa5d506ae83e3f7fcb09108b0f157ce65ecd2ebbd87b0c74b6d6dc45b23958db032dcb8da4f2e618ac97063c3974ed06b343a67225b17d267c93cf577e57c884ce9c5cf923eda8f2445841088a3b4ecf78b005975acd4507880f159dbd8b65950b88727781c8395864ce286a2cb8b226836696b8ab7917425b675ee1faa54577466e74982b2644e2d60ab5066a64d9f8f95f2ae7885701ef9fd270922b35b7f87f30f24985799a1c2f6e880147275c38e1783ca4c4e8ad3368979bd3f8b60d21e4b1f6d76c9c9cfc3c73110a7f2154fe36636e19f42c76e3bd37129563a93299c83a1c7c9a9164509cd1d2ec4786e4e6b39986864887609be9b0ec1ccc24b5ee42c112726567734a8427a96c9c9a91724aebb766ca398424da567f65307a8eeb0e69d2effaffb0e582ca8ccea5d9fea3b532ffb9457c44f52aa1fcf053d4232dc5d9fbaa668b51d112d986cec2fb333b7062dfcee83e731187bdaeefeec17eedb7c77da60010d926148c16af6a070f529e1a2e052b293eb6b11fabb06d6d4e8a820f8182a5d0dbed9191e2806a1f145bfa03ccf60f7cf6fd0f1da317041abd15088b08518de28253c7931ef7b41f192fa131b3bc1535493dac452f8fed20580ecb74bfaad3831dba8428dc593c3e75f12b5194ef0ebb3a1de4da280c944119c1f3a95a3fe182a19d96eec399da55b177e131cbb7f2378326db849d817ad696999ae3198d3fb94657c6fa55277e95054071328f06e440fa6f40ff2d2d56d3535c1378ccef0bbf5656fcc12c31189b3c32a8ffddba15bb90a1637cc1971206262e3c60aa879d627cd0b00b6a8342ce44c31985cf1164085a0493bd26b98058ba070d727b5b3ef46bf5e7ddfba156e31c6014e88182b71456c8755a11a9f13bf5eb1be1365fe4a512cf67e8de231dc1b344482bc66f06c4ae4f67a30e87ed2dfc5cb9f4cefeba014f89d166b43353d0e945261719ea9040b6939fa60947b0573bc5c0ade92a15432452a7cce68e993cce5164368523081ad6bf5e4edda73e150ef44c4f91d446b6032de6d1929b7e037fab382d977a97c0c3a47448102ffbeaf620b6f742063cae044e7f8774c7748c2090438b696125554d76bc1bb7a970d8bcd89e8c92cd7ab0d74c0753f42708fc89a3a0cabade87101c7de88a1a78ab2086944f9b054378aaca119b9dc989f29ae0f965bcdae33c0f503f7957731794387beecd01009922e400256c527557d38b83ecf697847bcf9746ea5f2ff88d040f0fa97ad48c8637d2dda893a5f268f1e8b85d09108f6e6bf2aa18ad17e9eecc6a21f2cdc7ffb0927a754c4d207917015793ec5fae47389b315ddd491dcee94979bedf7e5ad1fd8e429677e83491469f99a5e774612cd19f08b5d8f0c9a929d350bb4e7bf4fecbfa4b88b98c9a1f52bf94afb8f890bde8b1f77b81710bccb0dddea1ba93cf2199812e71dbbecbf851a79f48c28920d1725dc0edc999d000489314bbd3ecb8c4ef2c6f2b1ec4b258cdf09b1a8e24f8bca448a7f3324b91fe89611453acdea631ff7b3ea89cdf07248601db43583c097bf97005e523317ed955ff87403c7c4bd66f1a18355913967b002cb2fbae0cdae1ae08a905db68b83580546ad41f669e3ea311f1f1025b9a2462bc7a73c01aceb0735fcc33599247c812de95ac6fd9fde6729617538e78c1250cffbf87ca82bc6fbb84f01a7020f8208a31c28c118af71caa4053744f5ab5efbcace1623cf8b87dc98bc24970c3690ba3f199b9146d3fbbeb2272f93ad1d2be01f838ab6a63b87b9f9d2932ba1c3376bef7da5487316b4f7f6956e1acb1fa0a580c70a78dae68ba2aceb45edf86648cb541c4f6fbd69b9ff1a26ba4981ca186d09fa9f59eeea231150b9ed82857f16b8df5a7c45f6966f7571a542c0d91ace246beb5dee6fd54b697ba97367ba0e042e44959cc46790ed97c1dd74d4f6fa44b403005df6e81023cb89e3c0c20ebeb3d1081c1fc4cc5f2f2a4780a55d9b9f3d16332e42b0d57ce5d3403edc587e770872e29d59309700b5eea76d4de1369c39f36c331cbe9c74b7ee7e862f973e41cfb3543111454afa14034226569f5880755eb6be1566e0473809ff77f246ca3141983079d3fbbb2fe6970e29a3dc4cd7e323fc27ef196ddae9fc1c450c10dcdc6812126607e2c904aea1f40bfd4c3e3a18fbcd92f3a7d3807e7192a0eee02972e942109db49c3ede5f94954966254db2a4bc8760f47b32c6c215fbf9193fdb9fdf98352cfa9d0f949c2a18a6998019a575fc95bb644307710766af17ed89c2f0aa519d89c40e9bd53bce4e450e0320982b9e782aae4cf52d78ab28d8d7155cfd6ada0451fd3543deb029ae4a47f6c2b37f467c809f38f8a43f5d33a5cf32a7f143b424f4fe6146e14d2c1d2f63467ad93310535fab554ea22f3065f49c958639f7c6e1a8716fcd29eb186968af1e4d87f7d88ab5f4c9a3c8276aea27037d867fc65b39b6500242eee48b8b70fe424003e6e9b02de0122ba892afe7be3b6dfd601676260b8b1c4dab7b70f3aebbdfb0a5aa566bfad9c7ca5308952ac0c63d69e2ddde5bf8019d0fbfaa85e0fdbb95bd3cf863792d9a2b7e58c04e2bc24ca006590add3221744c37b4bc6b61a779d3cb15aeba96f685cbd5ca67f19120086fd5893cd181fe69b65531195311e8a47d8a0ff28bef01b4b7b5b10e64732b9f014e5e835629b4449fd85ccbe12f338e467c06b00ca52a6ae1106e60d33576998481e67a407a602be0df502e5742edaa82068c27b2522a7a96b91476c6111056e20296799924e0ec3cd2a4d2854154e6010931d2574b3a375375967f63dc727255fabe5dfc5681bab8cfa6f8889df955d081cf1f5a196925854d4ab62b82a58602d5b4d33c242bfb4cb1431e3707ed881b0133c62a132181f21e1180c3f0f0d2a286a493dc911b6db66b9d8f20310286c330ec4caa5cbb4154cd6659368d3b9820ce85de7d8d3a2360dc4350a02d093bc340131b44252e8a2eaace6360371222264fd9399e199c1d9f11b9cd8ae1ef1a6407f8b1b0c6fe57713f5211dc1944919702cbaad4f67c2f0cb365d27d98c006750b47368694410ef6ab101ae61b43a67b40cb5c0dced44af1607377eb4695621ffa9f16c22a27dcc8b5f580b941f9b22f559379ff9bd717090faf7cf57c520d140185658dd1d2827f00603533ec2bd3b368d753c60f6b236e9dad2b0647d11d7306e212c16f9104cded5ee969d1bd416ee9284562ad93bfd9aaf42e8a1021eb7c0e906b75ca97be1a164319307ec9c659fcd09c326b626174480bea4b8fe12025dd41f8a9d68ae79b28ad084c9d1700a5a52168af311510c8ff4ed927bf2c0659ff3244c7b3497fa705c456257424573597b5010686a5190e145d4418a99ccc0a3db4707d31f38a14e2ea2e7b0f32280b11d1b1933098931302e1e5c8918fec57ad707d0861756731fc6359a1ec48321d22a1b42821991a83b43ceb012b71fafe7fa0bef5ec001e4b61d2c97ce7d7991fc7d2d965bdd267b276f69df158fa3ec50daa197efa1a42fe640bec21746d1ec0717437f1cf9d463597902feef85e92b94ce0f1dad76788783f1576873ff195b1ddeb02a5f24fa3c5115510e978925b4e6e24e96e2e4d35de45733768a1af8f9a6f0a0f2a86aeb8bb823d5a959949c051e60bae32dd1461e4ae666dbe6afe6f075028847f9a6a4f09ab9d85215255486fa517ffc1b46633904f11f1c9d152fdaea4915a747343a1c3d2cd46744b2efe65fff7e88a69011344dcbe76c9a1b3b958f2f973449e36ef9353256873ed5fb6c798091d78cb1aa38370538fb9b623bcd2de1013e9ee5a7bc409e5c713056943ac46286b38b15d3594be8b832099ba83c20a9b375a0c5e627f8e8e4094c41ff804c9b20797de73bb44e66962d65712c7335a21c0abd37d775add372acd17b21734ba0f424083190c9ae7b1135239bcb7240772d1f636f9c1f862c652e389dd0d825786bc7838a8adc39d9d97c5b957d6cca69886c980d15f01a8ab39455ba2662edd72df6b7b2e319f2a548d1c080f7527ff8b1a045929560ff6f84f4e8f816eaaeba1bf13df9048d5a477933f34d04ab77e83f99c4b4ccc10fbaf9cf1373fcad6a8ba02b27af727f11298fc8f1ab1efaee0242307335c7a65d3cc7dc3ef450ab192d69f9f035c7bb7884c2b3c6a2025e90abd29e2fb164b3e978a7520d401e313b2d475a0a851d84020881e2fe848db86f0159aa6766d378c6a5ed24bd00d25e82e68a25b914c491864d1a9ef0086796d0f9ba41f68f088fcec5c8e2476c082b4f51e6350b905a504d79fdd2927ac7226a47d28b82594fdbcae57f231d0845a3d3dfc6e910f20eea14fa62f74362bf69abc6b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
