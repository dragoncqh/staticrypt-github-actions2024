<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f85fb9327e74fbcef598f2c29ec85fec7fd5c31b8108fafc7b23cd73b6c21a07e1219afbb09a6e1aaf8a928c57db8fe94815cc098e2e60a2b7a72abd631c71b99f58db3c7497a0c536acabea56362f501a046fbcf2efb6cbbdc48491b448e46cf1604fa82cf29c5191e5eff7697c65a08f786c1dd72f2380d8c70ad3541d0807f0ac96cd0f02f3c05fd3c7706039b5e91a704b88b904fd80d3ee9309eff9099b32810daf4416921bd05a5e03c6014fa24316c3dccb01ca0104cb5a49bebd5804d2e01f1c8f12e8809a95b04a8070e61be64dd9a2513c481e86edd4b24fffe42e534716721396685ec0c274233c86078def71ab2f266dd7d29bb2b72b1c71cf4432295f2505ebf8c7f6d65d19c94f4e31c617b62bbde8ac9496e51e12c6850e29edb51f3794eeadac56639e51d72520bafa3baba8e056a0ee475fa9e12fe7b79f2149efa5423e2082225ce46001e4446d21ded85639a12b8945533d779d258d25d8ff15a75572dcd3440047c2e73c9a455f9b7062af1d4b8371f94730cb8330ba803b2bfd35aa581ce1365d94bdb038dfde887e3cb9c69ef69c934aedf841932a4918854e4ad1a39df069dd4757b0053ea0c17ffde21a076bc29c78332887e35728ab0f1eabd776b6e4b013d6d10a196a2ecb2b894284b3caed6066327b602dc3c89dc4e6099eda6aa3d881ed42e9821e067119d03c5302571fbb455ef6a818c48f077bedbd19d3c4c497a16cd4e5a3149c81e364606d067dffc98b2b4d1124b0990650852da4dc7a7d00e94c0f27d475e14c99862e71883ad6a47a02bc0c790fa32d58f6cd826b1e1452152fa80edd8f2079eb19f02dc61a01e5a0c2567ee764737131213d36cba90cb9fb9c71f0fe38f19200d679328004d902b0b66c5e25d89c314a7c68fb14e97eefab6d54f3737d508d6222b7c922fb60b092930b8f89e7c81ee69bb169d764d7e2fa954c259b1f6191675dd8e7388faca7be259ca05334f453bff14e49532f57d134731219f3acc2002788933e5b11b768f0da21279f7fbf238f64abe3d365763c7d095dbfb982cc1a0988bc20848dce4507e446e3fec184fbb82859a2d25a4f5e74976e8de70fe127bb1a4eddad806790b0016d0117a2a2d199e30eb8e15b14259e8c869248bab6f95c952112f668698482e6aa38cea705732724501780edb89fa9aa46d23c8bd1b1c78c3043712e0b6fc14dadb5c37025044ff627ac67fd2ffa5a593eab7bf212e69cb64ff728b92b7729f24c55220ae2f909154650b63b8ef85083afe107b0b4aa6ebe77a2f1639802582e45e941fde2adb45a697e1f87f59c9e6acf8e0e2c8d04e73013301b384ca74618eb7ef2a94f2a5a20e246cee53d8676786ccb4b84f8dc48a5f12d1eda6eb381236ea935d41f772b024bfdcc4e4e1a66fdb392adcb97211c861faa036d28c49a2a0b49b8cf90b4a0b9996bd0907bf6535ea77d3f05c3398d35bb8a69615ab4db00160be477613971dfaca9b130e80f52cdc979b2581ddc62d9ba12f18c2086d1b343b1691585ef7784df2cd639dbcf0c454644686a8c37aac501467f74c456dccb3d42388ca669c5371e99d6a4a8f391819ab05932b6a38693d578ba9a5613cec289d29649a358702b7fc4884e5c3006730c5e406edf639195dc473a44f2a5a70f40ee505e146a08a3dab212a5e4bece9d6f48da29a5ea68b7147ed03a3868a1105e620c225e776922e0f71452b8e68377d4b58cddd2fde3e32f2c9df0290a67bd77db605e587c6c32cce8630e367d4f618274be2ee98afcc702d98d25a83c8906cd87a90cb6f837a2baef332c2ee6ec6d6c0ce95ab4ba5b1d1029a5ca09eaf002a68797c910e2fa463b5750fdf3d17ed7cfbe183bd65dbd6b5a2473c3a7567a9a32573c71fb95482f5fc57be39f19f589f7510faaf15a049d6db289a09712ddbafc6e518b48bedd63aa830460a019a0f436fe01065c36926cac8bfa322a4755932e521cde0e6f583cbb6adf76cbf93c4031b4ff8b211e098869ac0467c08c5095ff1c0b3af91901eb39da36cdf6f386ff255b4df310780838d0511842beae15a847b274f4a7cc6abec075b1f0e8f7afe5f5dd90f67cd98265a2a03b798e696835d9905edbdd7e2714ab72f85fe4eae0ad11d542f8bddcdbb1f0c730f919fd08f0c9ed30cd6ef22a0d8fa399941b259c7a77333ccd21e687e5c1b3842de85ec50785054f2884a52f526ec9c2c5e0ad00896f07e49dcbbbbe2a85cab7978457e4d5fd4442f5da7e8a472e901c51ef8137a7523b5aa4ec9f5ef155666ef96394844b07c20712b1be608e11a112f0d73118fffc90c589fd7fb532181e5a707b13969a166ec85c7ff8d56d2ba5eff80cbf87a13ea1c33a086e975eac13d967faedace7f812e553d674d59af6e44a6b88b85a605f8ae10a8ca0bf010007533306420472bdf3f2b31daadf8063625db568c2b5e9b24f6de96b3afe8d58ffaba917b6212463ca6d185ea5a9c58117801c632a8e0e16bdd2f66aeca59505027e17da5dd8f9b50affbf395ae820cda738eca338b92d8162e2e4b593e55ddec599fd16db963826c869b61d87720213691d54a062b28755bd8b4547a18b7e691f4510d82b14ca68190b6c0ab2cef42a1a460a25d2ff52fc95ff1a927ff3368522ce771cb587aa5089c6e944447fcd35a4d231e04097367b7d3cbdc3621e99706b137ed4de5ea6198c06529c15bb3e6a3dec7c5110c1b74326ff26b3fe9a4e5a7e0a232986e4b59e35c88d06a3e27fe5ef0d583364e45402bdd6a1bfef06c62f21c2a7a940868d8016877f3a7261c3179ed68b311a27425cfe2f9aeff89fc87886d7701b87c7c74f406cfa2b0f5cc23e6b0ff381f0dd29507ed31f47fc2950cdc8b777bd7adfb92cc32a641679ba5828ba952723c26bd61d0a0436ae613f1b9513acc0c221578395dbccf4d293b9d341a9b434cfd62fe8081507fb1ae20329738a099b146d45b06b810eadefdfbba1e90a832baee5faf653981a19625e828e30542ac8b6921185d383f444be4c1d523993777c779463343ac001c57f1f9e1e9a0ce1104512ae2b02c01b625b8e53ab37785396a269f5cb9ee29400ccc20c3ac4b2f92c6cc85b1a45805f796538d39b5bdb6dcadba3cbdba603a7e921a7a0c98bfb41d72f5683980793d8442e406d5f798ede30970fa8785fdac65fde0933d25b893a645f7bfe5b8c769849c375c26a34ca4807a126b3637207733ab338d669c9ea965295030259d6de1f67b537b62edfb2181779a6343f8322509b6de47a80729d7974e3cf21583f7854d6bd31e13bb2a2d58cbef9f1ec415666181744fc4973ce792ff946abe203c75a5a6c24555eed1ea20b2d0c86ddd4e9510831723c808598661dc067da37d848ba2e87ed63c594ef708e0bd7c6a33f6771616f22a7be97bd66140cb712b73161eadb353e3c81f33922966ec34cc3337f737a58d03233f6f34a58db42a2a8df2b743ae0b8d86faf46a13499d19562dc61a985e5cc8fdb81413c62b79c8e28c0438172c4795511d387ada5d62ffc02e10699746b9f37dba05e37765048805d75569dee8c4fec01b151e4a9cb9831f362421449907b7b9c75d4351c5f90bf60cea52aa4182aafa517e435ddd9cfea242642dc2015cb609935b7497dcd968a1dbe3492096a8be2f7688b7f914cf487a61b22d8e06cdb4a8fca66573e141393857e1d9a7c0ff4b087822ffd7e2135d6b2485f1d59ab3aeeac866fe68b0ee9c08759d84fd4627ef0ea9c5ea2124442c3466f3d0a22d1e408bbad41c8747ef8f73b172e6322ea3269fc1d0f02bdbdd36b43c17695fca6c01958a5a16b3298e580ef8dc9872f192036a4c87887a7553aae8aceb8f13906c9d13912ff1e45ae14059973e88d2276e081b55cb3954f14cf663d3c047602a819b5beb75acef3db594d0659eb9205848f2d1e050d2b6128b5fedb666d7c1573c2cb6893d429bc822f1c44dc4c00e210f766cd798134e9d060c07e82e383db8b21650008de520bf77f612c83116d29d2da5f1eecb3397aacfefeba5b87180c657154076989432b7f70792f01ff5bae66270839c6191a5f342016c85add461857a85f0c6c60be99f7cbc535fc8628a85dcac81058f9892485db1771652bee00b2ce6e4bb279676e207de6f60895a76cda907c927b8f2918e274cabc52d0179ca3bf8cbcf370b42537480cf115533a6ec95522a47d12fc1e77f8847d234eddbef7181357c808fbd0fdd532f0049d3b390e1d2292cd95a9c9b0373946057657eb13519c29ef8aae17eca1967dbdaf3ec26172adebf81dabcab802caa7da89274d297e2db4ed8f564f4f9c6956ff456853d83dc24bd69094b03e431e4468280f9c875fb765769f51625c3a4de3aa4fda25a9d1755f38a1cf7cabb6134aee15725e2b9c73453abcdc7c86b44772c3ccfba8201b764e54dc68698034f1d7714da3c33d76fe642068e459d92b26b9531dafa84561776740f3f5551c5376c2d42e0f071922008e035360ace417d65886728a0ef51d5ad1c657bffd8ddaf3a8cc723079aee199fbc4376c869b0c9e0af4c53bcbe4192fef8ee4dcd8814bbb0dfd1d43ac228a38ad5327434ec4769fe4af409bffb803c724cfe89486a5a4f69079b55379992cde596faf27dfb2276cf5cc9ff82eb78fe0d5107ad1a43501e45e6c0d4cfff047bd13cfba2002eb918f98468af91ff8435fed33b4378f219810f487e5d15cee5bf446b1e3a504715b6f15f0a08c5577864bb580a0a46956b2acb8e12c4d9fa94b6aee205e81c7754e0f1fadac2522e2bc4b131a3d2e006d1eaac91d6f515b01459af7dd4466455561eb1f30235d88668cbf8b8d7e76ab97fe05d534a338bf82b39895175b19a08d51c8c981b422930b33606f0e3a011b5137aad077645c112f12689de8f97cfd6c2eb9e9c096aa9fb3cba28ccdb39acfe22ad95cf4c7db6d42e4c9e23bfcf1de4d93c57f6a0def8b8b9d624cc1902830e673031bc08a514c71b9e78e07f03e4b0fd240d9ffd03e58acce3faccd478f5fdaacda04381ae76d6dea3bc50d2b197e5b16defe2300c42a403249334e644a07d2345969d8d6ead47bf37fee3cfc00ac32642dedc8816deb9c2c0170e7b61a94e9473ca54cb84cc8474f96986e457dd1e730fededfb5cf6620fd9d3379d77fb3c48d1fb763fe0301a15c26ae55ed1407cdad788ed7bb4b968211d5e8a1fa71c60b46658834c6bd724828ab8c7ceda8ad12da9b094d119826a317b14fe7c11906289e1bc34e600342ebdfca404aba8c0da797a1041d2ba5569cb44d61e3efef0dcb9c50d3d4b14b1c2af22f636f0e3caf11a918b8f1465648a4e68bd1b2c9d40792197252682db16152976ebdc9b86d9f12dcd1d51566e1a5e7a7479c0902bef078305ecc1c67967fc93abbc5d19e122f49ef0469f154f5fd130d966aef5f9b8f8749ebbec5884e61457dabaa1a137fdc52b363d4f919ec9263109c6a43f1a5decde28bfafaec5a579882c771422869143a10bcff5316173a844e0dce0c633437418368ee826490258d1d051eae62a908391c256cd23c2cf95547a183b3086bf456fd33cbd94c1de261379feb7f7048bb2aeaa41a96799b8fbd30024582530e30f95ee406d30fe580b63e301db49586e615d37c9c45a6b041b15ca454e62c6e8b35be77f3350312475f76eb9a23dc0a608c1a45ec85616aeb6b7fe616825a2b1f8884eb6b4af5c4f928b3ce361dbb087e30032d562bc036c1374a576b51a4e9acfff9dd9ceb67516ef332411f3659cb5bda781fdec25dd6a2196ef518326193b560d01e9967c8de67a18f16cb1bb6df13d9dfa443691d3ea984253291378cfb4752b88945c4ad1921a1c3f611d6a224c1bc8decc6fdb9a439c0c8cd0c9294c9442fbaf2d921b5069ca2cd43c1f57362c0fa3155131f6142b551483bc37c379e4d56aa6fb1b1f0625f500e111e610d6159a517cdf0f4534252dfe121ff4a011958e3844d9d0ebe293b42c2c32b354f56c93a6a22476355828c4659d764b649738569e9da4c20a33c4ce06aa0cb7c56419721e6f60fbfc29e5130ed597fb0c2dd6ae8591bbab9f24ad71dea6b32ef459729331f1282bc9430955e17a8fa256b31883d19daa5c765a1b94858d4ea28ea048332448c0cf51dd4e8168194a19cb72f9c77e7a2e474899f8658bcdf3900e962e658c74dd472710e9dedb51008863eba39e2b3049a99bb208f56475104237bd5d1c00d9a60dad81ce656307c9fff63c80ee3aee5fd97f4a2ba2e5e87b340d21d1cd33a54c2a9882c2b4b0889eabaaa4cd960c5362053351a134a0ffacee2b1c77ecacc8cc162d46e8202e727b0ccaae5288b657561f1abe87f3f0a54589cc08399d68f7d0f78b96977692622836964cbfa55eaff012f3d9147c0c73ae98d21a3b84349f977ab89d1ac01aa9792284ea7df7892749dcd1395b10081478c1ffe15b71ca0c1f5f054fbba5d76857827c3f6b335888f1d2540d669c4e12e855a42780cd4a8e452e51bf4d63d4d2bdb5c538240fb9ddef2165bd55e5f95bdc33772c5b983d841792024074a2d1973bd607287c9877e7501cce8e4f4a349a0ed09c420740447c4b62889dcf8a0f400ff0a64bd0d74cc450aa6afecdefcc019922da98a0235aac368ae700b71664a03b76202ef3b5a2a7e06b4f24ca060c300ff4abb2b280638f99e3d58c2714b177fc91872de24253491853339dbd28b4c7d16b2ec776fc90867912ee735083513b156254c72a64b617f6fee69d3fef935b14b02567c1602a1219e6273b58ef865b864ff6005eda50cb89e43277058e7e8424e86855b9e58cff349c1618d3b767bb4e1cdd36d5e3ead272d7f3286d7a8a3ccc78db08341960475eddf3e63934891a02b29bff8362780157cca3cb1326b99752b5526d62e21f162f7b08407d7865c91285caeafa4db10b400a997de65dfd103aaf3d45fc10961a9ed5b5f3f91c08293f4d8e70648506e38ad062907bb7d5d3fda6d8091d7d36f6658642cd2489d600b9f9952b2df2eeed7cc55e456860b19802ab8821eed9f09dda729f8c6b08837c00569f34e37179c8a22ceded25e6828d4099096520f657fdd356400caef9e021ecddf271a7c479ab1bd6388c870289c81b9468836a6807508caa867010b81f229ac56a18ce214d2d27bfdf4dec0e1ca1a703969c7983650d0db8e2bbb0376f16fc0a6cf46289503969c981df6f95f96491e9248771e8c0487cb2e779bafadcb5f6053b3f2407fe6051ce6d8654d338eb1407c0279c5b4f5d399c422104b6a6f32a8a74d97b0862bd421df1896c897251f55031e2fd92f1620062f4540520d6fcf5c21b6e05c57f5602675fb7ef7da1d72b4d6068b7085be30be8cf6c2a50db5e8298b4219ed3a9872c6a963dd790fb206db2ab73ce6a774614a30d0a5e6d326889813094aa95e11107d96e738d63a18cedc03e569c9fd7d3f37e82b1de730b7073706c604d1bbb4f548d22d035d9b8da6fe8d391c38efaade744d8b0b6c58e1cfd949fca96e2e9a8601efc2e5d6fc8b8bdded7d475e5340747ba11bdcbcdbca47d1c1967400480e2737e59adea56af91ea37a17cac285ebd5375f7c83aaad9855d4828278d2bd0ad599d871fbc17c59036e7c6bb1df0bfbdb67356e578e3d100a30496ac5dbb553b567ce7483d4408e5979a816b2b30775b7ec2a7767fd4e4519778fc439e46d1dfa6595483975c9f8ada648c6950e248b2ec9197e46522edaadba8b037d0252c77fc4bb12c3483f8135e85a6cf4045dec559ade274161c44812a3be2bf16acace29adf1058a2904bab22a6612e9527481cfdc8ffb8f544136a8da4c7603e4c0840a1290c8ff0c341bc6625c912d5c379ab7a918c1181b1bbf9c3a832fb7ce99a1db5118487666762888775ea0b2eab3878ec67a62eb15db6bb44115619ff7331554f1391a9976196026b682694389739a1aa78d9befe0d39eee37437b0e81655f793d6951101f241ec78341e890098007fcdf3684a838c811e898a6134b28b3c2fcbb66e3865184102925e0710a43e1edbca04e1fe35f6901858e03504649c5ac30a92fa0d4e56ebbf4ffe1023ef089aeea58c1f812f42cb5aae2d21f4a474548bde42288a31f052a1132d9612f120cab88ac6ad44187e30ea2174c70ef54f1822aeb17f782ab3bc8858539a56da7873e40704b1133533771f20e45942c36c4e3b64bfcd3870214b287de8a34d6963787608fd5813704ebf848b24980cb6960b488736a6d093fc7185548f932b04f3395ffd5d0642dd81657b6ca7082ae1fb4dc3f470e142fbee2380852d7a2e208f4fd443863e688d7bed78c58bfc699c4c7cf26494d902102aa790018e96d09dd766e260b1083455eff97ff6dcf22b0a403807a95ede3a7691bffd9f4cd57ac5ccc1bc20cabc035ebafdcd1deb4ae238aebc91d782b31a4fc8ce479bebc9878a990cf7b6f5b48c8c44aef0f1817e605f0eb2d354cb78f3d843cf37e2fff58605fff15b82d5c1e08120c6f2b1fa674626fb643d24eef2d7632a979da9b4f150a79c834001b516827741155002ed6ed0abfd1a17ee6b7fdcd08274da6366c48da66f3817a5db5fbe950ef280fee3af0a214e7b8a58e574629dba464319e0c2c3a1ba5e50cce54d56fc552255e2aef044643a5ae574c655c73b85a754cb4327ca3eb3b298ebd4bb8af13836d1f3a6a46bff4ff737ad0716fd5afe6a9832a823311e7302df76c5876234ae6552d877a07784b177646bbd97a90f5e8371cf43e9a5433a5bd74e27dbdd9d62ef20f53d5fb537db0758059acf7ecebfcc456ba40b1d46b413f1491bd39bb5ef5af5fde7cfc23f4f36a1eb19281413a72123e0aef62d09f1d2c1b09ece1688fbbc840aae5045d1be62ea3aa3a04d733101cd46294a04a7cbc8e44e6e8c12e34a221e37ee5d8396f04a3097b3b28e0b7a9d9ee1972937f3ed96b51fbfcc4888f765ce581503a037e0cb311af14ac48d01750a50b557a223358e09c104c3726d9be5f35ea60a65c206474c4e2d2fc1818498acc7379f8374dec6e9614ff428a14f58d03a33d4bc1ba3ff1524499f5d480f940b795075a9524c84cb817bee1c59dc560e598f26b70d57d8dc9920ca1c7d03b7ebeb572683c783b27936afed2445d0d3c793a0ffa8934368e4530a34d1f8743bfc1479a591fab7f3353e2ef9189f62a6ef09138ebf77863b454ac78873d7b772b73a1dda09406ad04e75d859a427ccf62571690dba5f9c085759e37e8498ea3f99c4468a6324ebcd2b90305258963aff70335ea0449eab461ca4be4797da008f9792408ddc909df921c5fc0938977d4e9ee498f7e83f2533c297a58928d02225167e0bdfa0cecc9bec4ae3f8a44c34945b60c54b9b670b5c25d92d2ddc511806779c87706f958f8e6debf96bc15b5e2cd838a2290d417fb5276dd043dca0ed2d15a54ada2d280704ff695b5d53103d3549942afdff35989f7c255520317f61c110ad6cfd797329034f1e3c2001496d2f6bac64c5749f9a33e25657ac65bf7bc0d6dfdece552ed329e3d566828deb880e4e94b31b83edcb0191b99ab141a67a19668b655371de2e02548f6757516d018f37a52d7b6100918e25b61d7ff6937340507708e46ebc5851ac3e665caed1ee863c083c88ffedf310687aa8fe8b9f001e86a7dfc50c4fffdcabbce5341b596f1cc73418c65b506d70ba9f26d6b722ace4b52da4a5b127c0ad9b9c4e2f92e5c7e74fccffc06352d59c1b5dd788b94e5ace362570800f5079d60bd212a81a8a0c5dadd74c83bc8be4ade2b6263f4d10d908b7523ed33f85d7cc070c12b6bfba2e05cf3ebbe6d6936ae6b856df40d7f7a3744132c485f7cfa119cef7b8fe0df55975cc13df58d190d903b4662eaada14159570be1538c6b5aa807ed674f171951cbeb17407e43bff424095ee604f63a2aad99155cb56ab8a24d497cd806f0b22b036f0ec079f9bf006a611b5149b602344071fe7a008845ea8f04c9baadcb6299d15b9bf5c72ecc9d26677738b320f1879d50e3aaf8a5d9bd5c6b42b6e045102f06016392cf6e3176bfc895e6370c7db00f711ae2199f28dd1b0197ab5a0e6cc4be934358743a684ecb3cc3fc3fa6104f349c38b8983557d1b67a60c3dc0a16645667e3ee8e65c7be6c33b635cbf95da393ac3b0e467d4216dce177cc09d2337779af7e6a0473d7b2d0c59af7ae11b578c32a7bf7089ad00036031256a0f30e6906f72e5bd17c18f26107d109a9959337ff9ce63c985f2151905adc335cf35a533e21732ee05181c143d5808f79baca73a0f7770cb6e24d7e68cc6cce9ff5e6e289e53746260e15bb34abe01e43f93cfbd4ea40bcfaf412ec3466d3239857a07175eb2b05e0df6f0fed2334103633fc128d5203a38de383becbf75e01ce982efe28e15fd6322ec2aa87868b9588e19e617bd8e8b364a92ff26364b0c377ce4f5034ad733bd43bcb6368b0f3c3ea577203791a5e302b6182f60863286b07ca5a6f4ce43eddc72dea1e92b0aace4147a484a3667b36ebfedb3b11e64ebd7d9dcca1082376397a0965b6ce89ea644653ce555efac6daf613d38dd2f586039357565b86d1c3803e5a05549408cceb13e6a0335b6fdca3f86111fdc771329bbc39c32a87a5f4dfc755b560f9afd3c341ffbe6c7e7acbf4c6475903c168f9b8f44eca07fa0f06243b2be541c5cdbf922b32e535b40e861ac1760765cc276df8696b4f202a93fecc19a48a7f871c65ae7795fe42d67082b6b6120d9d6b1e1936bd7fe485d91e0cfca5fc002276b44b33943e82a7716ef495d205d80cd8c50debec2e85ad594bd0693291b5782f7b37373c8305f4c4ab52177a62476efa0f5f3e5b5bcd25451e8dffc43984b1287bf3e5dfc479f0d673873ccda67472c1e4e3c242232c046ab9bdd377c41e8552c560353452906a8d4f9360201569103a6de5037e1fcdced187682aa675fc6be4935acf75f975f3c4ef87f03a3daef057ec9079f8f5c0545b71d74183f9f460cca086f1c07326c0c1f1ff6be5c2a731dbd6245cb89dab7c9b8d554af2c9b5e6d591275da634662eea8c54823ab7c669962d8a51b0bb2acf97a7fb62ce1fddcc45c1a80d98a3e3b26d49dd6fb96331fcd10533e0961add006c7efb182731f883303734ad51666c709aa2b22d5fc27bac3d5dae61ab979541d1fec087560670e5e48dff164b4d79234af2c58b837a3868d24b17155da179796518823e510f53d9a483edab891ae85f8a4c003c860fe8e1457c94d6e85186ae83c23c6219fa8d1444fb17983f58462bca5e7f5ffeb46d13b11ae1cd003de4a27c4fb730b4a3db95be99d3979fecd853642e7f0eb269900501c74f31cc76fb684ddb6885cce245e1a1f405e5d7e9ae47f30dffb50a7157d5e5c4992c7946c3dcc564186888353c0286395178f697b3167d43e9a620629e5d2a6b695f92a5974fadd2c52284c11c4e276ad3c3ff325c7f4ecc3a2d6e011841215434bc8ad5f6934cc89669f27c4f464ae9d8849bb03dcd3b18194d520ba70025a5559268e0122140922f5bfe1597d6027c1a6d963e6200f94af66059d8ae01aefb9de32c6f06241cbb4b12c8633b760353cebbd620b365a7311348f4309b7bf78a137fa80b51fca72c76d6a2eb4b523607f11e65bd50726a10088e62d6bcd01e9a84b5cce3c88e93169ae19ced4e7d3c15051e73514dec37cda6f1024bf2c89a33e34adf1c416675c438e8222db7cd31ad1cdf79d2bf1c8f1a103a9d108f79b061e04103af86d3429c830ca97be786f57610e724b3d763686075c656dba358d2942cd8c39ebe6ac241db074ad3f2c69b31238bf4bf6a389423983251d7431beb27450b4a0d847dbf07e9a020d81e5fea570fce2089be22b90df6433e09bd5be60db59425de3d4b7f0717ba9ac21d3c33fc289207f792f83021ced1f2f7e68f431cf56e4c128f5b9c72bafc164aa99ec1af8563dfe855edd843a3b56257ce1cbfc78a43d5e4d29f3d96857ad2f0642dabb231e3fd6f7330688079e2c3b0e7e6f63c4a5af527fc8aee079237721f1f5eee487f7df469e5e56914d1ffc51995109c5c5399c19e7e08e3279197ebcaaed85ed2757a6ae2acf3b4cc36c3fe0ba1c1452a17f48e23d43d0e0b87bbb217bbc32cc86e882c9e160d9c78b7c4339cb3230479b285e0f9dbc5bacadc1459d1177fe082cc4cf178cabf8c5af3cf11a74b1d8263335afc729ab90028a877a0e742a3adf8b708e22d974354682186ebb63e172efbb7c256f5fbfb9c2497af8b0cfdaafee02ef94291323e992a77de679fb5632c4be3c403fe089baec24ba6805264ea71393c68a163a3df7e49efc8afc4c40bb48d4aa726f2e507ac323b22275245497f193d40bdf74241e46424b0145e9432602ebe85ce156157c321888350f7aa119a441405c572527585f2f7e791dfecdd0bbb605a40c1798b3833d732925fe49863fe9837a1b958c4a461dd1fd6db048b53da23971ecd09723a8fe5fa1009a8a600feb52dfcbdd80b2b4afe302ea0f9e380f01af37631fd6d627177f82ee1f601ac41a731ae85ac50913e35d94a0bb8af6e80482faf15e8cf9f5c284a8d7d4521b6788c2010434e4c716a511168f10c5987d23edc85d978d60a8b6b8c539b18252931b3a54f8ffe06a133be850e9e193398b2bfa309e5e8be851d3f1627a9fd79314392f4b06696285f0f7491754e07c218b1b81f16fc0ae8696f39653d8c44cf0da3cd39f45fc21f824996b2c752f7480bf9834e4a8d782c22116993e6fba46f430749325a853e184785c19c4334c649548a2c373f839813aab721b3f17e8f9e306d26872fb25d21dd08ad14ed509bdf98501c2225dbf4d0030851da6ede23afb75643e680b29c860b7fbf172cb79ebd140f9d12044cd11dd310efa23dfaf6c5a16e426f531cc7d496fc7f01228c900e571fec670a00b473f58b74aee81a0b5ee318797a35ebddd24c4238b5c9671d84f0efe947c00ff156427d039709e610251992f6b8398f2e469dfdd7aa3abb946604cfcf77ab46507cc56ab97942bf13cfa4fb5d46cea7d30b163802f509c873d34fcbbfc65058812d099f61ee3a87b7ebbae03b50b7359fff1cd3e8faeee958f06a7953df3fc684ecc57c2086e24f4a2795c1e75dddd409c4be33bcfc04c59cc0e99e325efe2c55b3d7134b5b5b1117b0915a1b1c94fe8a0472e2f079e67addbcaa7960497b35d3ba2467f87ba11e1d5336e7be387ba29926e8eb21d7cbbc130bdae942a89b57272ae5de01be1f8fb013559ba91add0a4aa5f73c32c89e0bbc938230d95dad986ba64e094f9f68e71834ac9ad3051d95ea3347bead16da097b4ab429348b480e1362ddc2d7f9e4391ef22a992258e497f8c090abeb8b21062235cedf742bbcfd454a5fa5de8b0c5eb4f072d106c0bb48904d1fb3bc12075aeeb4b6bb5c5282c6d6d26d9d21e1f3a355388e3e23caea24eb9c746fb20baf3689f3a93d2bd78a1e1afe7c38fd3239c82da4247f4fa47ce192745a86f46e4f325dd148e66768de99625866d04f700f63078112c61ae2d3b26b02bf30e5f9e83a0de1d7ae76aee3d3cb692bf5ea9f7589e54dec15db0ca321557ca4091c83d6648d841954c5f9434121d8724b0c5010878b24a4ee71b731db22da594ab90d7ab9d66fe3ba9a3c934cc37810c5226ea56c66e46e80c9b8cca532a690baf403bd0e0ba4ec489e4e51cddae41aeb15569b4b690ddae139e138a4f21e4dacfbb873e425bcf3d7ecfa9c203f52f41ae2ecdf57051af468fa4658227d3f33029be7d52fe667fae0bb4ff22865a6c3bf203263f03ddb407b678d6ae0a412b467ddf8f327a73bfea85b960f0e41b3da8d32a00b79e15aa36d3c1ed0db1693175a41e520d50c791b68be0004953594bfcc483a5e6e141bbacf20f06b85e0ac1416b70a5d4b7bb514e1b55ba74e1987a44e984d399ee63a1fe57cde2152c6fd9534db806476147e5a7515871100aa92448b00c7321df773198920520ce19eed03a73999b0ab47f47d7edcd5be89f5d3bdb0d280b4872444304b6c9ad9ad45262da8d2c486b3c73dc16943c8b847dc926e6944559fa37a3166104aa8385356708fd7c15844c993b61e80369bb4433dfb31c0e7789456b8fe8c230cfa00022e4b7e532f4556faed0475f18c35031620e88e61dcefb41bee0c365114a480769aa74fdce898a6c970a4fe931d914d9cc09dc84b1ce267acef22738d0670c6fd1e2589ebfa330191f4af2941b794e7f7b9197266c4303366831ec309e8f33d4e6d2a1420897d73ac137eba729c739587acc97752d491b89cc8e1d372372e30e0dfbbab2cfe9852568eaec698be7ab90c4615f87df0f271b51e988946c8f2714c44ed2bd5d8306a68a64c5ca5bfdcddb7c7a99b3f5f26da1c39b5d250fff0c235e67d02df99e3c3ab6bcdad2b6884d74e5f7c82e5b2c858989a6621d528e99340435bb9034c4bde2851c60e4052620600aa2cd300680ae5ff3bb2a5c575dd43e4b12df9e3f73f84dd2118538832cd178a0f0b772325dac2a274b7838f6c6dbe1b0f1ad466a3e494512f4854584ca23e0a836d79369e34317bb8445bb35b96f8d12820f9cd1b189c9bcc26634bcd11872173c79814010170860fff5bf585b26bf55a85b903ac5ef739872dbb7e503daaa6c2939aeaa2bc55ca5251dd4fc08685c52e44ec173aaa37396a14e7d9b7f5e94ec4d00182c5f53a0485e5d3d46c7c86a4e3d18518b72a5f2e20779340b5fc3da78ddefea550fbf247b74d6340be0d37b351460d6e6125072d9ea4d383d81494180f2dcdf39962a09e52e60c70eee7c601067132127a5aae464336cd4cc5a4d0b05bc8bd99e14e625bafe70b660d22f1e562895fa2687053b2579f6b9fbeca01433825b31f61d2e2435f68bda5df146b9eb9bc40783e46732c9ccc06c72400b4d8c99fdbaee11e5a656a11530ff09503a7622a3d1628d38e60d2b66a1dbcb041c2db5133d33efe331545acdc9fb132c7ac6736e34e54a50c27539b469e058810056b50a7e0656868ca2203be064e9bd6cef2cf96c0b2dd8b4e432828079ed14f90a30204446cc2cfabebdbb47c739e83a6899551b0b8d20ce7c0388db17d7d6dd8a6eb086014a2ed49801521e46ab3e1558d5edb494209dd00ccf95dfff1ac765201ba274efa5cd0a87d5ebf84bf9a9e89771ffd6f9bce02647156e7a033e3e5740316377d51c596449fbccae51a3d3694f116ae711d16458c4acfd278fb4eb24e1ea243dd3a57957a317ce330b4a5e57b6b00904d48b2fcf6e78ef7ef9e1886c357d8d445a1b5e2029c582a9176615959ba33f118080c4f8307f3228c43ce4477fc05b94c841500b932b09a9c280fb7be26905518311fa5bfa8b89fb62427a1f1abb074846d269d9e732d064c0026b08308b38eb93bf2dfe6f484af39ca001508133734795fc1fcd4bbe96da3ae1a6097bb62a5f03c79707ff5ef60e74b4fca5d36a0624ed2b84c620eadbb38f969dbb4c80e5a16ea5c033d300c61f90908dc3292ac71a10489cda3c7789132edef4b5256f4218035afd310190d6abc4513097d660710a15a88bdafa4024f9d3d5dd1f14a697c8d2595172415b47e014e669d02897da79017a78a727253fefe7edddee18b331d528ad06b0e978b15d906f1cca6af5cc202d9d11377b85c17f5618dcd08e2d0e00e1994a2bd1dabd9846b5977ae20e28449576133827fe0482a329af4514f28141cbb4fda3f7b4764ba93e6ddc413fa6b363e7a129c280ac9662c5aa08defa040fa809b32fc26b259cd41790b27d966ba26e4a6479e757dd00d7563525d97cf927f83ab191a23b92c4a4e47948464c81c36c2e90289fc644c272de0d13f0acb8dad0b4fd15278baf16335cf046d96b71600de640d4a9c3de46356a83ce12a511266984404a2a18cb0b969271b6b13b62671d21538e7f95cf4d2405d65a7a5e3182694b0e4ba21c1bda50e7250cbb17f87436192209fd67c0c950722c1dd406884ff655d23fe90636d240a55081340a1b89e9b9e02d630594ae41e384ff539238d64deb0fd2db4eaacfa5235e2ddfa2ba252723af9b623c1dd96b89a1001d46a1110db88c2581a0d8d0e11cb0828f6804f68a7edad464ffc171177175cbd4de2d6ad8ddefc0b98ec8c264291a434bc0133e24cf9633592b4f939ffb8514eddad5623c39276a8659131edc50a9e660022bd55761bf49bfb918bd7e60fd648e76a7eeaf9f7da8f5bb396c259f7cd30c09c82813803c2d8617aa29650c47f8a75d58cdb0df41496b136722628475fcb2fc1c850013908ee29a088458f4182668adffbf0d7070a41c9411dab884f21b8fc920ad89334cd3a12867ac13ee074f8200246e91dcb58f23f1034f8140c34a269ca046738024ea2d65c95ef8134cfb2387e7f9e667cde4b5032774b69484f5ebe2bb4554abf846a41fcc23b5996d236bf062180b21af2717c7aca511289956476c70389cf28c1615c95eea3c2223bdc0e5310b1d4940ea6bfa0b6b26b8d1bed2f1a44fa11372925a9963bd2a89cf22b8488343a8729200771f3a912cbd1cc61738a2b16d6aafcdccb6739d2d67d1774a3b90ada643b397be25c94533dd7c49511f33e44ad9011cb81c321acb529e29b486a91b81715e3bc00abfbb4d5df40cc9fc844a3e5fe2fcfe653e5479a48744ab236c6d52650009d48d9f736dae3400d6025676f0fb56d0a84c624812433e28844f5267dbf97665439eaf79f20f587a46764abc2721c74daba10b7498ddcfb927064bf7bfdd3dae77c9c072bf9a9fee3a9f6bc510243084ea8bec25e3145d11b5a492b3e8e6994694ba9c23d14f8aacaef789f4406282a2e5a6bf2419af9597bf5a3ec66921d2901409e88795091033884108cd608badab8245657559d08621976f60a615639fef34a86a077120a4cdcf195965a5ee1bfc3310f16c3790ca1d3132104c6f26663b84be2c47745ff1fe8dc747b23a7e858f8d350cb969d2ace045184638e18023993e6a444fed87d214a672e5a3e776004b84eb724e2c6dd145ff8ad3bfee074f08b721a9882726991f856b51aa607f2f261e78f12958b71d6845322efb8dc250f54790675e3450cda9ac37db914e85bbec6f7a5dd17d3416a4cc28cf19389d73deb65e6ec9feb2fdc5e5e99715c69f214f46d9c67d2f87f5a142cf79329ac9ea6292f16bed42d6f0abcfe85ddf3cc2267c88d8fd5ccc4e1c63ae84c41365e5dd03f68991d32780a7ef0008c418b384753e48b6ca5fd329b2fb1cf7a37850f36ed1e0fe0eae00261b6bc83a721bcc53456c9805a81af37bb02539a52f3bcbf54905900ace3821c76e57fa6e2bcde48125e75a1e7e763f97ec3ad00565e3ab1852d17c3a4c6447cd834ce51f1e8b9725e11a3efacbfd6b4ce3074acdedef315c02258c8ed82b08ce2bfbd3ab231f229a52c5bb9b563d19e04765fc8e086e85e14ff5daa42249e447c9dc8eddf479df0db0ab8009ed6fa50b8fcf622b714c850216c6a70a367f9621ba402b5d3e18be02902c5494bd35bb591198113afeb12be8d71004d22fb101078e25e8e945e742bf29f7227fbb1b6c12149b3c4172b58a758053e139dfd33779c51a95e4869ae9b4c660d71ae85b7f432c0a2dde047b6d20dfff11e6c51b1a8296ee29892655f97b15b1dafa0499c0fac4e123f42a4d3c5c56c847561780df7eb1bd3d979ff003699d47c0175d6cafdac3a4ecf291b798fad686526814b2e5bb1247e6d87ca40933a43793b0774586aabceef1aa00ee39f61ecb25cea7bbf793ccf8b62ee3ad4e08d83c04a84ccebb5d9da6ecd6850f7f7bf74d5468c42bfe688b718b4423bc3a9fec64ab9d96b767ba2ce2783d999493e0f8f88b1ef07706929db1ab43ba0723dd2f1ad1118081934117530214313526e2a5bdab750b897761deca3dd13f2f6261f3fa70b947c6754050ad58dc14c616a632d24e6989561f2c3a41aff16efe0607b6d27c9a592cc3fef5997d9f364f881c1c101c42307938741052aaf7c4d53c26c532bf1b2629216447de844e6ebf8fcab5cab3e7bf2cc529c316fb4cf284004f232d68cf23f49cef43ec52d7f1678166373d5512d07128a4db459d7cdb596b243ffb6d9ff6d8a1124152adb4af5aa0c3816f9a923b514f512410500ad7e99b26b3e828ff0321955c98c81ae3bab02cd6af870e3401ed84b8dbe774d0dc2eaaaae28076925e3caa56fb0c6bdcc6e69d9d379978ca71e3482053017ab8876c4b1fb02acb48bbd9ab24e4c295b349daf5f3bcec18ce03afa90deb332ad38c481caef93985ef9ed0b5e7f4e6ef4d3d4945ab4fa87a92b91038909a1e4808150e63f34d46af7ed904d6bcdc15ff1fd0e58a3d5e8e2206c6b35ee6cd78f3dce14cf272c2f36fddedcb58e3a73bc3d44cc4253e71839e05f0af0c38b60f681baaf0a9d81d979a4bc6a24ad52897eabc13aa6627dfd3d5c444ee4bcdd63f376143a7aef6627220b4b0393367c12c518d8ec657728e62744ab82a7c158d2aeb7a5ca14a02c0e3bc1cd1ee360bd85b1c8caf816efecde1ac0d46225c32ec6e0081afd8f5bf65705cdf54938883de5fbbcce003b784cb0340dc0f2eed126aa04e510ac2c9cded85b7a4f93c26455bc84991a97acfd981f18bde48977814b1351ed413185d8736cbfaff05db46b1b61778143a46579fb5d70922f1314c05e2a495052ebb4d6203a6baae7f84828e52984a2451d64f408b267ef68ae4f2d1d008a4fb3415509071c6139726ec59a2ac7db649eec7f0d879cda44b185b1157888e1619731e2cf2af6aef000bf77a60e1e07b76ad03383d3a487dca55907e56c4860cc8498750c661d7f22b82b4386987f8d7bb3d6943ff621fdcca511b87800b5d64a3715f1db94c85464da79262b15fdf2610e6ea579bc022d7c894819e548a116381ff24f55ae2ba91f03735fc072b2dbb8859a320765f52e47cc9cf4358281f4b64c0379f1b6289b6f3199b8b785f35a96af45aa53f0e95872ebe8058bd461b4e433c7819def58b751a3fc76825f4e76377c19b452b5602f691f9d1c7dab9316bebb15f675d69e50d09b197ad3d57a7733d73acadd49694d52ab2a268d29b630919d9a4035e9f7bc4374e5d0afa3bc71fd5b02927fb77ffdbd141004211edbd4e90e56c72978d2b0edd5f44f4eecd5a5a89327000107e4b777ec7441daf6d48cdeb8437a1416ec62de212d99131b5bfa2c5fb4a6403fa62106e3a25a5847c94655d826e6622be18e0463cfad259a85867f8177ed82b5eb988277c4421b03258718bd54f966c0d9308e894dbadcaec326c982a1e5b7df05e0350de70597fda0cd29a44eb0a5a2945b83acc635cc5af8462eb7907f35f30b9ab35efaf27e82534cc8682d989dbdd574c0cd05432a604f5400142866293a072654315b9703c8b19a93373921d4acf80bc4b5f03a17627acfb266f11f51481324409e119d970d4ec420ccb1569d0b068443fcf058a1beacb485f1772be99109deaa1130d3bf80c49bc91da5feeb06e72d9e5042abe95ed3a96d1af36deb0ef2ba6ed658f47f220e92f7d48461782966d5df1651f148d379d3ab642e3ccf7908bf3454860c6bbdb6e3c49b29becf0989f6c6e7dc76c47112effd9f24e37ade00890d26c6363025adb6d6186a3d8c0162d520d077f6d0edcc5172d520db3e3282ef78e543aa9ec4ff14c8ccdde5864fe5286aa48c54999905d9d6e27ba259313c1de14a2e11819ecc7c8c84a205344beabb15c876202347d448df9f42463a2a5301a8b190670b9e7a8952af5993e987b6bc38224f5a2399cd3ab01fca6e866624c904c1c0c7f7431ec13d67d833d45087f4abad1d4df068c489128004d2e941109d3e404fbaa60604e3c38df0f456949a4e40db3e03b72be58a47feedbd0bee60ced601e31274cd80a0df299ea3eada738ac54187535b13d26f39b69e1e45e2390ad7be82915297d6d45df5e9670ae84960022f236e7066c8860340bc9fa5d6a4f73e48b1cb30be8b09523303679d7554535d25e63de56d0d8326c2db09ce15fd6d51a941c52ee336606c6f726fb4226c68eb4f80e37f28f4544ababbc73424e7202fdb9a930043eea091e89c46a9248ef7b1122b16596ace43417e49940978581beb0cd09ca0f50440009afa3ae116ad7a72f3e11001f8192d6ff8bda4b107c4e1d22a6cbb894a52c8d9d1993250e1903fb3bc9dad6398f82649d71cd9090e95f9efbde32a2963ae7e10c12e8d4408c8d7ea42fd3698f4a318545cba059700fad80550e10eae26d645702056628a0a9e740bcb76c7e33cf5d21191ab559190a6a3122004a07315a8b16d3001e56d9252eb00a0e5a05def45f15b366c4acd6e5c300a9c4892d936fc9b1f56a1d34f17e5c71e69033076ff31dd8f0719755bd8684bc2856890cdd058daf62ef95d37e61a0fdd3b40ae31ce6bed3cf68228be22ad48a8286bc97bf8dc8752768497a2c08e7e179f17a808d57e1df2e2e7731762e219167b9956363a4245ef2320e650cb442f1d02c4b6d96e959f82ffbe5de59c404d8bc4eeaf196878c51a5c7f5ac9a38b18d2923ea95af49e720a127a775fb9da5f25c920f4c055782d0e45edea46863f6e5efa695b5490c3d0ee46f17adf337797f9ec5911fc24acdd5a037742218bdbfd613ef481ad6d2c3317846fddd4c80538a200ca29e350dc1575e20c5c9194371c8d02edf2aa375387ea7d3a288b7aa24be99bb7d0b08aa265180dee6c6148d5d7238482e29990c733e649dcf310bb5354939f43a0291008e8e00c2aeea4e765e5a1e12c5c97496d5c6642459c3c508c5bf5496f1688528945787a070da4d9dbabfbd73c461af2943dc9fdcba887ef9b9ea0e17eb3ceec844765e3fd6b878cf67c18c99963ee07be34aae4729847a4d10237f01718d6ab8f636e9b314ada353427e079c9576477acd159d0ec1b0d642837e783f98d9eca601ca523972802c20ffd474800105a199b6913d0c7a2adbb3e56172760f68f6aa7c9e09717226bef91bfdc00d0219678ff558e4f7a6080472dbab0fb4495f7cf69f8258","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
