<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64dc79fa6c9a4e1550c680064a5c8730ec5afd85a80441422c1b6cdba3185e7b5133486532c2fe3593a737b24e6c69dfa1ece833c1397377f7e5f3a92155c936e65facd51a7b89bce9285c96283d6880d36232e614fe268834badf71ee6a2d01044026e6bd01128ced577ff1e47e842e75c5fedf11d830104b037e67252423e64f99810c7a32cf50d64f5a505342785007b1e048751696c08d675256f65fc792f8ceaeac8476499f41c324266b1e7fb29ea364916b6fa593fb7c7745ecc66237aaf72ece4748aa11b1a8f3d026a6b5bf2298036d689fedda391c5be3985fba1903065e527662721ccb8b6f32437ee2b25875daadc8abcd8226d4d4a84d4097740807cf6d7a7fbdcf300cc560b6692b1288c8e0d63f9eed165dfceb39c9818c62d7df2ee63dcf3dacce6ec4671a127efac77ce8008128b612aba389e741f1f697a8a41eaffc1e8e1d4fcac5669ae2791beebb47c52675bc6bb859b9e608ac73820c9a3b52014b447f02f26ff3f864a164bdc32f091b5d4233757be25402b68f14651c83370fa012ea816ccff302af42b258c8a150bf55ba766a193a064c42c259153d78d9c21db3d577fe1467bfc91269f8a250c4ce5752c27752d846804fbbc74502384cdb54dfc7b079aba9e526a38b24dd97f0bfbca67bdea6fbef9a184549c1caecc8a4eda7cfabb70ec6ec966e51fe886b08ac3d6b2054dfe929382abec70277f2b38924998b057f638bb65f28a9d66a3aabb7d3f59826ff4a6de3a155f364ca7bfd05b64cdebceade403cfca73c263743132c548cfd50853fcf0f0737ebf87799e4f71901cd833d06c0e0f1144d3e7b8876b3343a3a0094fda9b2c8e019efa8c8a00aa79d5ff59cea500926694012c059a7dda4ff8a4b22c99ac2f5b6e461ee7f082aeecf46c2fce396cf12f1f1aca1917f02143a67b050be743a9a480acc2ae877c8afd57bb5661e42b67fc9625983a06f11b58d2ba20c481d2015317591df648043bec64c6315360cd2924d77d2856278f80e8c979c18d911381476c896903c78c60044b2c3b4a5c760305a8bee0dbff88318a86363e39d20b565ff2ee40ab5d3d25f5d0c6a9d50702f24ee71eb7c4a857635807fad69efb6ae3694ae8845dc494dd828a67579627f464dd71cf227e6bb928a022b0e3390002b2d83b22cd45060e7fde376191cb57eee1c68c5e709fd8a6e799f97dc844f00cf08f32b94d566d1661bf2ed8f08a56846d66356770aa37f50a59b2f0be3666e9baca387b37838eac59ae057c5151f750ce19f52f7051a0ddb05790a4c052d94049502fa0e42ad7d9aef6044e72e73fa36c4fb88b45b2bdec458a6e1acc82a95a6eb4ee0d7755fa1e863354eb83a77614c13a3a4388579806175d86f54fc98eb2545cdbe928bbfe0673d669b5c752f6e2e7e8cbac566949fc69c48c52b4fe512014ba69bd95a87bb543b14089f91a1e2dba93f19c68f11b0476b57bdd2af6ef40ed8dbeff7f6a5357ef553476008e28d3fdac5cf9894e2a9e139d18f422d324a68596b448244b37c7e6c00fb17efbb205fcff5f1f6c28cd99561ac5449fae5e2309468348fb5b8df0f0c425346ca62be7e52ddbfd6f274a5cddc0a35f66e4a0ca39a9bd6465bb1db8ac11c584757088b60bab229373ae9e9c81b8abd78358bd68c63d6b99584f24f088a0e3f6a326b241c3474b086a5147a894ae09ef282896df2bfdb2ab8d8d75f87bb0cbb327258d670c674556b676e70c213b194d2712df37ea99f8d42028000eee5d9d75d1c5b6872c36d6813055c4a1d9fb0acc63da00a90242e79f5f22fcc1c0e87a126f0f1f8476beeea77656d2fba1647455d97e6089b65a7cdf8bdde25791cb1f9967e4064cd3efeb0038776a6940176c22a752c7b78431f2a01a6762f3a08c56e3194ed2686d552aae7b40ae94d2b7c6e7f674fce0b5e166e629941eefa974a8eda951940d47937fe441b795229e6d6608bfd4f038b0a668bb29581ea91196c4c6519db11071d4f5ea680733964579daa998927a55f044ed303fd8659a3e5842291c3f5b8e015e35aa03358593801938bbc5fa9a92474e2cd1b038b4df9e1887a5572c45021480e5fc96d1d7f54a3fb8d3da1f964beb3d0d9dc2388fd3fd36ce208983ca742a6259c9ce4ee3d2ec215abb0224aa45ae250f63dd5b92f7c7ccd13dd40d5098cda87a944d8090947e6c56630222b6489f15d80543d0da215b8db5ab808eddcceb32f0cd4b39ca6ee5e53d21a031e4ed8950ed23ec66dc0bb3ec90747555d6be8ecd24a4639862472794f7db5d6cc815cd45a4adaaa59436bb551fbaadf30d009511de3da34bb71b8182ba312882a2ea9bdf4ec2131693b36b1a3e3d4df350605e3f2c44cb2ec723da8604e82b0cab4776f2d11adb9df76e8d29af1b525a994d68a14109852c8214db4a1501eb699a5771a8d0d64783335cd320d01708c4a4799c9527a28fc1e77f2ba266983311f5fd5b500261a9a33366e53fc19e4eb5bdeaac791d86c08488efbf5634976c433a6721c76513243612148c43890f3552dfa9e824f09e9389788b334c1bb568aeda6bad60e41ffd666d5e9406fde92acf35fc1245cc514d0f4bec32e43317641c9da68619f98dd96db667835a8e4a7d07f0f868b57940c17285a206ce5e1716e8d2981bc4b0f29b107200e818d8bc5959d3702d1dafce425beeb0e25f7cfb84f0ad86a97ab51f858073e29503303a5a69c1d2079e0be7de73e5ca9a9de9aaf30aeb99996017ca478678446a79d5db51e0f3721318e119e0fd045ff64c419173f5b3eb23af2af18462d654b743b033cb9f94ff49421da042444fd43a2563f2d4457d80e08a7f1fe2bce854f1e6c57db2ce4c63ecc3c55854145cc6f266c39458c6074d9973cb0efb51dcf9c0e5949bda2494f9a8af54c0b32189fb582349da1e0ce6b141b063687829d49cc790a5098fbe485eae966fac85fb863dac87783a5237541527705ba3f5f1d107a466e84fbc98b2add18baf299bc9cd7cd61a5a5adab7608114df7c85006159847068f6eda62dd29b6eeb4069dbdf0390144696abe033d99372dfb8424cfefc0dea51f5f721824c07f469731b35836ffc87f30423b9d7e01acb70c212fccb031ef7374f1e10407183ce54cca7e58c908a5457ef45526eb2c4ecf7c4ed41d530229c2845a8d7ad90a6261faa1d8ae78b45962f3ce8e0855980a2637035ef41cd583079375a173bd541f8df39e4bc593773c7f9ce27dda05d71af0b009f31296ed49b8ff5b3478b7e45b0d33fc6aa4c5845f14528adc19a013d89e289b000c14f978be9d9f708d5ebe06c5ba50183663db77009b326de9cd2b19d7170f7685e5161141bf83872703ca140034d227798d920a73a502f3062d094a913a9858d2e219f5e65f45a951690086322eab579d0f29552dc6db1439de55a5c5215aab8fade35ec95d78fa621e797a74850524653dc33c7b866337d38fda8e0f636bd789b81d5d3d6e87664dd2ddef050dd3c24b42f03834fc7a778b9175e42dffcc3983f492f63aae549d3d7131b149033176e3baa1a10490426e3d33f946c0e1f43cdbecf92145695d3d5b04aacd4b998c6e21f0c38d179dc524e5fbefd89336740bb0b5d21f770d3502c1afe365740a7313dcbbb52713d8baa35c64dc7d426213de805161c563b174220d96b3116f7ff567938fec784eb88b2cfce582d57683232eacb9c8a363e4f60652b3d171948096db1ed9e23d2b2c0f8409d8b183097b4dfcbfa79ee833b2753ccb9ccc8d70799ef4bc195c662858b4243032a4a9d073c1754f750b3d782f7ead63bfbe3b9320696919b91a124b68ece59ed3fb9a9c509bcaaa55836e0f680c2b111df4b15e245f2ad173d4febd1d5479caed39f8a8770953801316229acc162145661f9a3e2c96e6f41f05cc77622762d23c2405e5a634e50f2795706b2a1145c220ae58b4bf051074e39d90398e637512335fd7d6eb5b0a42d2a3e842a1dff2832314515b734f757e3a21c81f9a1088b63e3aac8fa2e9f10b3ab148b5952d231811369a4654ca9f1f77e47142bff03efbffe3063cd496492f6a6c5de2d61631ae38bf328037cbadeb7c806d87dd8322a458b3fefeb1f5a9620522e4a4b84b882259f4ffad789fc477d024361d06112f06cdc0ad967c7b718cc2a343eff546786d22a77c9b23ed38503a9c5a74295efb3d9688d2478e20794e22b441711974b5d179f14c0ee7153d46450d351cbba20254f03f857073027e02a763cc08d1a7d808a059158bbe08b143e607aacb032f34c5ef71d74cde9b44525f5b68bf8d5bbbfbaaaf754bdf6bed7020fb629741fd81cfecc118cb1ec1ac546c514a874ba4c40a84d5e8f3af5cba72c44882e08db243e4b3bbba1ed75971cc131f58364ff19234f4d61ebcdb09a5edbb869a308866c6a0d77ed112ab5cb4e1fdcf573755738348d9766cbac8f6ca03bc10514f1451c821559ef17482ab97f93f0ef12966da3df9a5c17e6ce5206082ec619b1056b09d54d356ecbfb0b54bde0fccfa2469e381d4d42279a0177e27295b41d229c6fd8d2790520b9e7fab1843eb4e3721a3680671a9f06f71119b9b69fd3fdee88df0f6cc1b43b1f4356e3dd76827bda88ec22ed490aa930bdf77d2b97a490c5b1c7d898a5a366edcd52ccead5eab6d9293a9e5a580b269cadbb33e1cc5427f78cb612f1aa4389452b41c74640f278dfeec44c0e7666c2c4054f4481bbb805858cbc3ba4dc1a3ca9d73e193fccf4325597f92922e2bc7d1456f4c27fd3bac0bbdf9ece849b056bf660eadf69d7e51c2287abd3f2157acdb26c4cf81fd0a5b8059105ac0f0580e8896cd07689c4debb17c2a207e11dca00fd07a2b9521ee19c1899925e4fddf0439789983fb47356ab55ab6e1b1fcf1eece195b190b9415ccad3f6c7e46a19d9005ff347badb249dbcb961840fee788527503eeaf912810690a1459587b868e56711adbc58cf29b53c1a3b4e63910df9b9112cd1371bdd8e074b511b45e7802729152756199093b33fd18eb69b8af4e2f2584d7c80694d4211603d284e55506368cf947319b99e73477e1a3b1287bb86287dd62074570a20fe11c0d0b428bd379e9e6628c65c8a42cd497b75871b5e82055249ff0ac20d78b68eb9625a403e63d3a3052c5af7bf3db0428ae65ab735fee82aa2a64717fb807c0f9af21099fd01e21786f06dcc3b2dfcb65d27e9bf38a7d10b4fd917dee53cd65c16f1880b3577a2ad23d595d5ee998cd9ae881906fe19bd55cacd7a0571236af1aefcb3371bb0caf70f630160ee93680826bc7b8c8ba42dfa312fcf3039590bcda76c574772ad953047bb784dca74ea8f8e1e96082ed6903ef2fd1aa636ab62a74fd62f75360e81133b52cc1079859a3afb202d7823d0774aa850cc8f2d3357e64f9eec9d0969263c8a805214e88b2c2754a2eb2cd4e31a0631975438dbb3a0aeeed39b438b194f6d589b97db39a7972195c0ff72c76161f61b9b5c536e84dc8552ebdcb2e0c25fe60b6ac33d3139b1bb2f00ac3b45af6458738bdcde8dc9d1a5f2cba088d5bedc0e82be6eb2dadd7e63cd0fc147f4d598c2c120181fd6a25401a1bc5e3ac5d8512452b76ba2b962bcb9e21e64ab58b1000c54140655bf19578e7e2b797c0e2a220bf0ba7e798cec5a3b142699018012d1f0d02e7c460d9133f8c39317ed07f09e874accf8dde931d8f0f8d1cc17b0f3f16d0ee96df1f597203eed0d758e194ba249e22def2f329c714c5f1ffe08a7ce3a3ddb2496531a9990acb44008303fd28f3aa42108ff3c6c8a1253c5f130d28d6ff37bc811eb79c7323ce171588c1116be0146b87e8d0f9576895200ad95d6a78e44fd0c8e3c2967e1b270863bdff76cab10adf1a9016d849503a2d01b328fea5774493af07ab4737734a6778ae6e4572448842ebb4067b1f09ddc0b1e054a7fbae8eb3b2842f6bb363c63d4d3ea0f093e63ff84bf39d4a94fa93fbed1656232521b8e3c8379550393b0a94e26fcdae32e9a14319f5b93250e24a45a581162453f090102dbc3393461cb20e47b7e445fbe52e3a660330c5bd1dc6c6ba78653117a3d2d81407f4b90688d4069798c6ad96e2e4a5a3b442d17a809cff196f4ea074060e13e2251ebef5055a157769f1c6026314d630a0e1300b6000e580b9e12f28599f53718eb0092987b5c2c78e48b1465433c174db77924cc1c69f41f0bfa09f3d6a9e882fc95d872f37d7372bfde84a270a5bce697a58e4850ba0084aef36f9bda1d3e5651f5800cc8f5c4f5301984cf7394a6d074bb8637718dd7135b958b00b1ad6d06331be836cf20b1087277de43ce44465a6e8f0fb4f2bb7d9046c477eef4cd9eb8353d36f92723bf2286c2a30b11bf5b706fc435ca15e715719409f40c796843f0d81c1e7ebe1ab9027664c6f53c1404582dbbe493675240d7efada14b58d093b49eab502b8003f3f07b1f9ba28aa8518cd6c343cda5f5224fe447a6a8eea0427848630e97b235bce743c2d39017c1b0490bfb70e29023966b24329720acfa4eb4004851a9cfc5da0dd6a6e179a26a5185c87ee90b6973c20026715533f78f760d6c4bd1e1bda9024ef2662f4ae319f6c15ba5f36bf5345910c66464445c4b751c753b7cdcccc2053497dfae7cfa1928b09d147d4815f396483da7f93998389d12fc5c72dbaa4b61d5d3f15c70a702f0760128c6e5be436454b3287d532a89d2e18d3b34406cc580903dd25b61017f23abdf9b63d80967e99c182f2feb065973ba3d97bdd08a7cfe0e4b2008a129e913b3568a643169a5e64c6160e1a97db8c5b7986525250dcbb8ca0e78a06aaa6043d50c040992ff439abc251c4536fdad51886a4e79f26731c9b2506fc86ddd4f387abf43b09abe0a7f6d5880930d373eec4a8c08dedb95c48ff9acdeb77151a0243f6f9d3ee46f4a0b716e91e0bb115c1681238a8f7d0721d02f574ec18a19e023d40df9090577e428a14a2db5dcc5ea2db829e3c5c9c495c4d4d57f3a2fc4ea2aebaafc7cbdf6fa10d78409979d89eef59d772054f005a0328a4f1b2836bcd4f0ae5df958527bd58cb387547998c0290c381e1306891535767f86d5cdd3aa7ccb406bbf572292ea50486d71b5ed770e0f23b997f3757295a0be144e71c2fc2b2184ca8e8e218bbcca12e52595a80ed8e84838b2e929badd705ad3cc43f404ba93395bdace247d341780166155eb13dde9399c80b7fc650db7635eb5a33de7886953e728210c6f7ddbb6946d1e9c554e73d2b678658f1866db2832233afa3c0b2eaf64985ec0de0476ed8f4a87fd2d2eb92d1864b3d9f701348fd2e8b754056f43eb94a79b31380a5fa328e085a8b23169081a01fbc1baf39c28384d547e252d23ac30907434f4156f6a730bc4f6493c78eb550f9886b67903fe112e3c23af865fe50a3ea5b75865a505e71385aca3d8428ea049d21aa2e87392f7dcdf97f0906eccdae4db161ffab3cba36657e64aa5f05d3890d5e40ca789202583e77e7032573d448c62bc22cebda59762d4c6446d76964aeef8a90d12c0c2de98b69ea676720fcb4bf319d9fe347f39dc274d8605250f289bc53d847708ce5442a97f00b5d479f3934ff3d333479bf861d4aa10a8a3241d7af5f28927e82b90a5070f06fc0ef8e81aebe9591cf2a58a7e4fa572d255b59ae748b617b1cebc2c3e2e36e16e79f141e3373000bbd478785b20eed3f63bef176926e092962a79f0b3e64a808132839bd6f9defcfb2f99a35d1fa0cd7914d1045d99192a54dd40fe34234a868ceb6fce23b96438fd25eaa95ac52df51cdd5822134023477e84672d44720f85204217fbb42215472c81750a328ba9912bc79e3f690a24367694fcb9622567f28863c8daac885ab08dfed1e2419f494cd6e6637f524908c495f7b6a826bba040a0ba33956712fa46551d7293916d9207089e2270971d1f9c60800e022d182ee421fdbce4de24c3eb69da04400f17d1739a935bbf7a07905783289009875a585ec78d65e2d12a92d5cf18cc688a8c56343daa2f79804ac56150cc03db3615359bcb31a3a958c459d0e34ef634a4a6c7904a343fdb56d5f9802a87c72bbc9ff1cadc3fc74a2bc0d6c767f330a334e31f2dedca4b2ccc9d2c0a5b80cc003f9cb701e1352500cfebe5e8dc1f4c7fd3a15f9ba28eb88ef8052708f02dbf9d3384d341219bff72f0c7a3109c7eb74ebc6bd061dd1bdb494d22d741e7ead77eac26f9067bb716ade831b6b8206cb80c4d44540869d8a72b581583ea8a4064943abfed3217ece697f9235b2160e1008ba686b1b523cd6f76b73187888a57c85d10f923a986c06c1c9c3e3a781d2cec8284d40522ff13b54c775e1149fcd3223eb694a20bd3e8e190c82364d471020c841966d6097b945a074660e77d407373f3656b720f0acff57ce60535c5726952b00d77b41c68bb0de2dc82e85c0d588dcec0b1d37e418c07735ba8cc034b1e745558b8f9e8a94847bd4ddde131793f63349b506e8077af87fc8712f5aae357f29b1f0c5f2cee0aad128291ad30bd48fc51a3d4cf60db0536b342b9896e1d58a2a25c1172eac886bdb56b5b396eb7ef3ebe89924baa2b5b8ea830dfb27700a801cc7e1e8a830666ed7865f23c8980262d9480af5d3ad65a53d0f78b77aefd7461adc1965766d944a3c8bf019a32e5a4714feb4aed8710017c378146ae5ed9f296e4f7d15138d881c1e4d16c46c5f936cb644ebba84f30bb6ea91efb7ab9c218fb332906743c56618bd0b70b265f29361dc38a663a3c718373eb704ba7e4a18e41d8d204c233c1482d05921d6ac9e319ab5f5312739a0c464797031497fb80337731efc22e280ced9d59dac2333cd83d7cc8cefc11594e73f3a442666e0d76a14fd2fd99a762afd03e84255a5caabc110328a155d840fd1a6aeeb1ffc85691590a6c24357d66e815866d7a6f518cfbf5c3d47d9a0566d9f2d9dbd5f4bd7d768526e8eadf1ea62eda47e6ea5c1fd77622cbeaa784c976b96b19741e3d94a89aae64702b866a8b823cf40d3fb0e7dae66c6f683699848af91a01c2fb68eba06b8542ac172c2bb59a6f7dd3e685a02240af888741762cd1817c554fe50013bf9e54390eeb9a63dbc56d226bb4090d2b01ef70371c967781cc15089c9e25828a68af00c1cb740bd173d67cc24229214230ed023a637387f6cb1d7910547306d1de104ef31f88cc2d29890bc91a9bd9fd2bed4806f9b1bb956d754799dd77a05d79b7731711364c11a693e5129126c70cf6b7dadeec097eb54c1ba6772e071153681e9d257851b4d7b9b35192bdc5a569678d9a15d3725594554bb27fd2eda552d1fe6b2bbb2be1f7d7a4b8a581275b6edfead08d07f4386964b307aedf5a093877e963611f97b7e72848678758dfa0900f80a77ba261e51212339729bb64d8dccec629ced20622817f0affd62ee8b60c565f289212ec5a772f6d4d70c1ae212707bd9b93ca2b59b9848cb8deb06d489d288b6b6cbcd007ce5a3a0f4b62a7098960bb404d3015858b9b23633fa69ffaf7eb11a29039eb0ff9857068a1f8bbba0c255a84902b2b4fe7c1850befbb9759934f83e83fe90d37cffd5249e6bb68311941f5424df98a92206e573498bac28961c0c479ded03877e30acdbc461e9258596fbd4afd257827263da9f1952f8add6990b62541c6430896952692e12103c2be34c383db907ad5f9045e4b95a3ba6a127059946cf8f1aea7e9f148dde3e471260d7f462e382b3663dfc2c50cb8f6efef479064538e48cc522b7687ffbe37c848027a9a47b14c38e0ebd08f9be25add359ecd1cbff3bf2a2cfe004e728612c09df2918878e20a797920281554e681e02ff9ebdcdc7be64a8df31c0dd6b9ec5e566337718aa499303239d48795944242074eb2cfd5b7efb10f010b9068a119f791ab6c786e0c669681a875a12d66c12adbbfa20bb750879a2d571faa3423509db31a3f147ad03ac0775915c3f06d487c111a58faa1c180d2af98bc15920a473080f1c5ada599f5373b004b7415f7bd8430ae01e7647937f25d0bbc265a2f6df16f7528758ccb56cac6e3137c42ee4b611647f58c4c4d6780449bb31f86ccf3c78231ba9f3986c39a4e5081088a805a9bafdf2fbe71ef395170dbec3b5f3af2d79afc5d1ca24611cd44a30aebe8baf47c5cfdca5edb889640476b0cf8c9be8f7feeece6e71e4d8918713f8938cc71f50b741a18d2ffd8dfcc245fc9483c025cc07ff95436083a52669567fe38fe92a3d09637025c463d44848f8aac8a41fb8b13c76b5041401c6ef4a2627b7437ca7c9f8fa7bc3b0671e08473ec895292775a671406526633c3866f3de5bc4cb60d9fd112692cafb26b301372bdacbabe7dfca0eabeb3b087a8a29ecaefa0ca2d42e98ee0dfdca7c29fce17318b4199253036f65194e955af6f1aea6531daa64e7a5a50ae21a629e6a15cba1549c701360eb3df72a5940136e51022102d89d43fdc2ab1696b6a125513681b274fae7e91370c033a6fc7766fd4182b2ea1060c3a26979766b91d0b880cac595b0ef0e15b3502de01442d9592316c5a15a43d4fa8675d2dfb59de75e73df5c925047362d02ccea3ee4afd93871b8dbdce414610d9759d5031747edacc8edd0b0f0aed1934a688f3ee4e4404e2ce4be1591e5d2e2069ab3cef775e181d300c32d640868ff241681028eff19b18d42074ed10c195b48e99bba7f06675f812789fedc61f36b0c000666376c99c40172c0ac6862b609864ed7e136bc953bfd1f6ba67b52c79067c40064f0d56655098b0226b3127f26fc91fcd1eae546a7856ed8e403474cd005bd280ef285686aca5572aa5b1804084980f0b270f580f3f926e566d7ee5dfc64d8f9ff526ccd7c67a576ef9c89163fee7d457d9a27add35768a55e93c9e8784e01d1d43de3bd9984252e308d057a7aef332598f816636a58366793b80deb0fd4b6c3fb3f279e8999863c6ca4a4c4679e5a2a822f2c03be42a68f20030d9d86fd1a9e8afe31eb563c27e63466f4af9dcc5356fbfaba02fd6d040394a8671838fcd0f5ab35b0b98960d945d6ebd5a2042949a78b1c089be32d5f1f5e66fdfa1ec380aebc80876e93bacb77ca87b2e19d00bd57e3c52496a10ee1e0e6751656dbaa5b80187510e915b0934a59c72a43e82ec1dc147c6faf7c79d153778a857ffaaa4d8763212721ad992feb0f014d270a73ee32b80f071195b38c62b5998f3f86c4c2d319dec81ecf87a1a6ce912f7985aa1f607b1f84f52121a5a688ae473f287bcaa0f82ebc8b33180f5298ae420e4db9d655a777d8432cc72b0ad585304cb8384ee12cbfe3b2c81bda4557eac399434eac8ca7b4ad9e89e065aa08a12083a90aeae46faa53b3ffc9a5d27ba6296e173191bfa0fc185bdcd2e72c4c1c581db219c58ce80a2e6eb7311ab76d28d5fa727af292baf589cddfff83e28fb7badef11e7dee58173c52c85b07c806e4c0d242f3de4d3932e098075075a95e620f56049e1270af1c9753498de64ac7f68b5baba57ac7679a48b00793f6d0d695567ffab41e7683f70a14cef313d9ff4d4aaf03cbdfa33b8bf4bf5e74179bfa4ca696da4057f60f779a2042ba72385997f2181eb8434b90f92b794abe81103367d4326af283f4ec3ce9dcd985b6a0cf5f5566d95a0ae55c0d6ffdc11a360a1347e96f80f2a99e33273489173c5b2e1fc5e175f7bea6ca31c3bad57250a537866b2c46cc1c91288bab56877ee42fc5a5a1886c9fbf60e690db9edc9abc234524ad7cd98a8009a897d7da3c619f7f86c2e0a177ace4d0f1912619fae8b581033ccede021b1b42b5a43c5c26f96e8163b34252bb0daf6904b470fbcee4cde2851fa4fd14418748909f47750ffff7e54dc474b0b86daf9d9ce0c38b0fffe9eaad8c360b05e14e71c1e01b07cf2df3f52fd33ad251fa8bb51a915abb0d4ab973a8db160ef721797d387845202cb81fde04ddd9e9d39b5b99ca816a84adeae623e40e12055ef487d69ed4511d1638956cc65ab40e530bc47f3a7ab03b28e26507d34bb10f05b55153356ec897eb40c5696973cafa870a0cdc85b0786da9007e84968217b011a0171e09a859ceeaf80ca5a08dabf56e6b44ee369f935a13768a9622b46ba44620388007b373cad083e1abb001a62e999eae06d956d50effdec771256b9df775f1c608753fe21ad122843fc1c5d48047767ba3a894d0873e92c7662bccd9eb6769f374dc3d6bdce57dee666aab5b38bb488c2563460b1672209657d2909d402b930c43b6ee8472837770ade2772da81ccea34d3e50c22193aeb49e763b650d44bfeb702fffae61aac5e3b818aeb6ddb5ca8bdeae6b73be74e961aadcd74050227b949cfbab1eec4d5b082ab2d197e7593263b1b0b58cf951d1f734d34cd0e28dde806d2573b938aeb63692e9a49de962b7094457214df7079427f4e71def1f532bf6116aead4611d76d642a8a88c77ce32b3452421d6d4f8e7fc6b3c3ef39027928cd88691a5b268bea002a7f76c1adfa45f816bc646c12b5f8dcae62063c04414696cf74a87a5ef3c645d66021fa65f086808ec46ee4142366cd606d858c033b0252939bc77a42360f18cd55312f90e1c9acd271a887162464f5be5e91ecba216e9a25a60b133913c579c469f4a99077787693757c7be0b0150490573ec0749c1d3573b9cb479d2b309e75e289c3718ca88f19d326a4c67b04b29fe2ad8644e62136f819f562981aa90ec6bd67ff4010d684ae8e84714fb36abbcbd73cf8f63857bd9f911ba0f80952e7ad6798295cfa35404aa3f78c757c8dbfa727abd5f3ba974711346caf39c4d37a232fadde8b570aa8a008f416c6ac90b5e6659125142290ed46df10275c27f684d04254b35208944b27535fe807b0472a873ed1446bdc8deb491e3454c282d067f7400453e7c098f37ac819152eeec09d85e3eb6ff15d9c2c7f44808000268a7d0f49d448b35cf02e06df6d5415d99974fb3b7e52d202d2a76e68c4a1b0786d7ac6681f238d3917e665ae62440fee3cc94338cb45362a9247aa2f5113844ff1f55d3fbaaebada380b461dfafd7586d8e07e61e9e1373c8910e41676153643d7c0abf7189ed9d773e605f92dda9233d93427187d4e0cc452fbf9fef19fdbc115579a839aa7c9ff336578d72cc585d6cbee20087a86853200143982472e34b5aec4696ea7a95897cd6b1339661eb97f8804d63f4a9af060a95c16d415937cbb26b43e3b202b6f693f7d2d4aa0aeb500ea081dfc910f1db2f97c1f196960bfb645ba2f3bade39e4fd38629473e6ee893508f0156cd0523006b5e2f375de1764e1f17412d9b6066d84560d0eef9a141c5ec4f9d8aa8b548331dfc4e1db86cc1655b52fcadc84b3123ff7c003514130cde9c96cccec061ae0f72ea540ed61f67537e4c6f1482b1a407346ec204049c08d45c464d892d44eefaaf606759d8bae5b76fa4a388548a9f31dd05d2eec826f69301e2d86889a6e7f80e9a5cc27a61f7a9168e215a7d54b2d3f53bcfeae73b1fafbf025d77c7d0028f8458df12568fc02374844f3dd160b4d2d28a9a3c77eaecacc336ff92efa41e22d0554f87829c1c02c82d06f1a89f4bd21bb9c452163bbdfe9fd2fc0cc6c2ac79984a0d77a7217ede1c2939406eb912d40242e51ebb8ccc379c73975036acb7500e8d3085938da4dec120107cc604565d02c1d372f86702ca94ff0676d7a48bddcad08734cffb2b0cd91db5aa1c55fc96e6256d9b3ce00eb24b10ba0cdec095a60c14ea5ee5ea5704e69e50c2f67ec5d9decb604acd8aaa6ac878de2e66984cbb753d0b1c222e84449ddbe3e7556fef26f1787d1b1c0c5f930b6c96a1c723515de36d09f3e6c0335fd720774ef2cc5f07fe184dd227034251595d594a7feaa5d3265131bfb0aedb5064a1181d1175b5e1d51b13907d89939d1636519652ea3a8c1bd2b6dcfae6e10819d12d6a066be1219f0988103de7fea0c03ca1fad87cd67fcba102833772f54425650a90fe5f8632052e6a959b8aa36e3a154bf840eeb092c17bb000f995eb60aaf4686b5dab82a9479a5c9e4461dd13fdae08b29f27aab8e1a2041507cf0221087889f8496049214d979f37fdf09573bdd0894c30f9bfdb3e1f26f6ec3338ba8423f7c10f1e54d7d5027a8afc30111d78bacdebfd43995029b82303d9562b5c5ebecaf7d86525e3dfa3b6816ed0b4ef7a958455adf8af6a0d4f62578ce23e832d19c6362157c906de100153897bc617339d0018e6b582eb14dd11757f85183c4405ff7024ffc5bf6a443e6753d0e3cf5dacd5f5e6bebd9f668d2b35838c7b346b4d40ac561eb87d6390be1c63612df57088605ffcbf6e5be1c252e50231fa20ca8bbad864fab252f9fec333f334a12e8708107b0a26011a072418305ffca2219c866dbd87a66697ef81f0d2f46eeca5bc0d899d0d76906ba12487b0adff7580a03bf69d68237cc60cb0e23ded22e95889a000a534682e569b95678d770dc33ed9b7159d8409595de984b925195e0865e0a1177701669a37d83366ccf644bd569ac61207d62bce67b6bab7cb7f530db5c7e69323f0fb050f381d3785e394843d1b8b58bcf050cc9022edbab649bbcb80e628df437aa993f5fd1c623ec4f93c71d89d5ab837b28a83b6448ae265809d7b27fff2884b220b77be6b8fa9ca102a39a56a0cab1b7e20a3727314302701a527c222425d8ede77cca478d686b92de90747dc823a5d6bb2a5b2992aafaec949ad6f7393a7c548ec6cd62c2f687b9b30cec4a94a20d438aecf8576e98838581a2334bd1b32450390cec4d92a57d4e387e4893e9186daebebdeabcaea47ea16687edc45cf856f3d683f074a68dba9f4e809beabaf2444aa91234052cde896adc1d6a9a307cf8f5efbc59eab8758f327aa5bba45d370e4088ed33dff42a74724fd7204032049654c26db90e3c32720e9a76d07ca71337527f9e26f2af10e03503fbd2b9cfeda85471a429cca08bac12b63665a8098aa22e7ab07f6e8efc360d2a9df3dacf05b7a2e24df133c3c1b751cb2e33440b86fe242b18feabdb8150e4b1db93b0f74acd7bcacbd9cf99dccba48c9a6a12716fa7a4db42bfe8ed46483f70c3d80cb13eee0148c0e482fb76d7dfecac95e5f9470164a4f0aeffd67743f02812449401b6c99e5b10288b62d67d946b2a358aecb97b6efe7633e5cb13602d42306fbe24b61aef2532bce652b588a530d697022d206afd31ec670e247ea2915cf3fe2dfe6e87a6d964e5b4e0f28f9bd2b2a70dfb5added2f0e0215e776aa378c0ef2de7d98aef61d0291401079363cc4a24bffda85c2f984750196331677c5980ce019492335dc406a26ef1a23167a9625de7ec91798380c65d1989d29701ca52f244f7e57c16ffe631578c2b71702517a5c3a622ce31c523e56dcf09a59252ec2174efe547af052008b4a0558f30d83e6ba4c671ebbfb97ce70e451d452f350ef0c88951f2afb20c7813c2f55072e74c29daf5ef0750dc9caf140296bc7de7133c1848cc6684afd88be45844168888796010d307fcc6fbe66dca27bf2f3d4b628f5f9893c1ccf65ce2880cec72fe7274b1147a034d923de848b63499119419d0d0b24832d67211b430a57199f0921714074708d7fd490b5d6e3c2bf565df792856d5fa3c55e4192e41f801085901f638be08c2dab661d866a722c357a0965a73055aacd1fef3a1ef240c3323608abebc6eeb4870916e7e2680cdf0aadeabdb3803d959e7f534d669596502efe4df2dcfeb042704ac57b7f9e17d161f5f76d218009c2e0ed251aae41a3d98c5662c79ce9027db2c6ff4416df5a0536cd3b6cbad66580cd62292a98272f1aa7b34ebbbff8c512c5c537a9ed7a41a9aca5a3ae1912fb1f60c4109bca91650c1a4662bfe483b12ac05b6d98647846751d69186e8b112d76ac106f06206fbc5d65b39210f61397252390d697c6fdac791bf98b951039a62667b69c8fafa62902d3880333f7c5e9e83641dbcacf54145e287e739957c1da39d4ab737d03d94006045486e2786618e1fc3277ce02d59221fa9a56cc089f4d6b3f30fbaeeeb2b0f8a0166ffb5fdb86a8a44f03b4f244cd45eb529ff55d7c412241c789925c69020793e1d731cca481bc04848788e5b42d1bb643c511347338f0b2d21a9de6de7b89fc10d5549e1c5d4227cb8c9e16fe30c47a9a08c22d20f831a497eeabdadaae990bfa8b709d907f1e1d1e8e847713a91af7d0e8ed41df146c44f701d6718bad529fecedf3a89cd595118f09ea20a98922ffd4aec95b5544fed3749a0f9d4652674a155cf727f44e5faff6fadead4b9c12fd28baa6a1a252657e3530b7ef257ba8cfbbd4ff1ece917b5b465542b75bebc48c206e46a5e230809459169cb77d09515372af03c6b339e12cd061ce93cbb505729991e4cf6296eb23589db98777d10bd5aff95351b773a451ee16e54503a72506b6fcf63cd0d624e50d46dcc23f782b5c4346f43dba17b2ad12adec0f6c1654b3363af9a15c45bff58053192b0505cfbfe4cc5eae7604150626fa41c497d748832b6a36d9636ae30ffe6a033bbc4dd8e3b3fd912792b6afe3fed4fb57def13dbee3da10ec9f6ce3c77396e788424c919539a1d75a78b13993c15872b4d6ec90629ef5cb522f27b514a240b592e6639d5481760037450b4b9794f84418ae6cafe3a171fdca9ba60b8ae761acce498b6c2d59df4f296d489bdbfcd1538910f0bc312536a2db36af1ec6cb0840164dcb774e11ef99ddf7d09805c0e52225110c653ea868e1c92ea8a77dd30652eddf2fc16e22b0770b2fe80f5e0f3243ccf8bc3aac0eaf696207037ff608c9b1f3259ef3404f6999b3ea11ea317f5d1c6777641dae0217859123701693bd410181899b02b8adbb3fcf76533cab4ea2b2f20498e459c13ecadef222a28ab04e97327dae5c833a2c8fae35e8e622487c4998119448f6f12289a9b8a67993fa84f85a09998d2099f5435ba0e0f9cc1f85cd5f21c2f08c33f06144fe35e3bb94d7eb5bcb2a663c295e02c08e244a0ff6d43efa63901c785592352d4d1fdd7f18c407c2f42ebfe6de6d95093810cd08e5c4c2f43381a5fee2faa0016a4c9a8691f739338af87d9d98c5ebc2195bd298d4106f7abec91265ef9be18307ec523f8cbcdde3b08c3fabdcf56b6acd63fa0d31b922e285567ec20ef01a164e9aa29f847d32f9c4991410648a72604ecc3f138f6b448477d73619df282fdbd2a4beadfb5e4c7e150bb7c4ab1dbacc3fcb54154dc8cc0e2fdc03d9a6f2b89d4d156b4fc5504a3b38e2c46a70fa10d8ef28ce9cae4fc1cd6420ef6ba732b495eda32fef52ae845f2118844b0c2b5c07b4310debb65e2c1c2e6cac09456c110635a8acd0e62a54c5bc572cf36259780caf3662be111cc8b34ebfa4cb39cd5d6b7cecf6eec11718bf473a33dab7e0ba98a0654fa48f931c8f8e42f02bd7d0df5a537bc5a5d4f0e21ed17e8459b14159269d54ef72a73db324169d5cc9e38fbf02a33ae9cf048181f0fb1b47c645c0f0b5cee934d71ee9fda028700ae0df8afcf34168d4c78d937679d31c5fd2634274f7d4855c107a47036dc7ace84e1dd811f9cafb150bd79176c31bad82358eb7d9dd2193cce747ace11a7ebd22c7897788e291bca64deba5cf00bf94f2dda7e350420806926dea305c2a96fd0e994cdba07cc0c8f73a4cadbd504291c985f5c0b221b7bbbadd2b270b7b7616a790847599eefcd5bee9b5d9cabf5172487a421d278bc2516064cce4b336c29bf88b687a7d381dd336ba5784309a0e6e4854f4a4a24fce07d0d945a1aa4a3f0f9dfbf1bfde74b165af01d050bbd52e907f6496a4281b0ebda67d4984728f2b95db1122e86e4ea0c75c63991c45718b6c4f93e4cd9985417a1ce6ec6212cea08440812414ed0d782ec549df6f87c9efcf93a6604336a26c8aa9b8493e07a4e8803ec6f98e29886a46c54c68a51e82a71cc2bf805cd3c7b07ba0db89747a33d1024d772286637b63ac5169e06127142a897aacd500c8b5574d0cb5638340f33c770440c5bc7cc0dda98e90902381c43e3140428b1c4ab1c50b31d26c2953cc2840b4038e3bab5891899f37da9ad382929f7d59c4a5859fad6d0ddb747527defe6fa86896e191acf1c90dabb7d6da28e0ef8441e8dd07bb5d1c8aeafe62bd6db5f5d0b3caaa8f39e2d1f4af794b8698cf1b363e046054c2658bf413199d9fa809e91f831da14ffa3bd6bc737fab5c95b2b92c1576e8d90dc3977a584e006b37214b7715aeca093e905edb72927653d9781c9473d404e64c07263ffab47ba658646710c3be8490ff33b350a259fa28e43738ac1c9629836f3f57f0853beaa3a86288d913551a5ed401bab33c0753ef8f51301ab1f5afc06f9c5e3d779645f31063fb64e769c9cb1f75cecc09b7d85862e86934f5b2967dd260c00fd124ff4be598aeefef574f20543100ecf0cc9d9a40a82c0124c1dc45255d9c56ccc3e97b160c194dcb45641b4187492971a542ace1593a6d15e6d3d9641427b0c4d277785863e9a757888cf6e1b970390de49f92ab8d5159780683975b8e42ac3a1f998b41fc4efce0f4dcf91b00e287b23a0f3af729195375d1c7ddc3f1d39abbefa95a6c3311f0ba12adb8756f29f1b6a1b7edc8323d61eb3f2ed9626c979a2f830d08c5ca8e5e24b1da6bbbabf2705d6bad2dc23727880245b0f7f71dce4e24ba573cf09dec98ba4308e73c5801780a0b9830c055deea4c770c6d83d33130713f4091f535036e61734088a4c29b4fbcab5e54777b7d0a573a69b233bd17fbe8f32614a6a82eceb2054ec1e926927adb2ace2e495a14c7742bcfd51bcf1809393110c6fd45c3d76246c295903ee213b2e984d028a6ce6c9d2436a9a529cefe28b4316fc9dafb708da6f359af474da086200bb98361c33d4fadef6883a36ee82427979aa0c36eb14825b7f15630245ff7c895bb060dab4b3cd42dc9941de9eda09208ae27437441ac6aeacee12c7a4ea3cd2177b72915db07da4d3258f9c80810ebf9668d95267e1d80aae2bbcc465d9db9776d5a60a25f6bc760494ff997ed8e95cee42b1b87e879b9bc24e9b475b72509bd395f8f153f1359e21eba65e965f2253fd0ce043e8b16f4d7610f6c0fd68471c715a66c2ddadc01d6a016c5a468fbd12ada70ca173d50cabb0dcb762ca9e896094bdd79898d62c14587789dee76a900f5298280aff972044550ce21848fb93ba4004452622cc08ccafe276f0a95bfffacf2b10594d22b76c5701bda3174ecfb052d6e309ae7dbf0e17c4a3377e343c0b5f9ae27c3f1f2f976bd1977f911a46534b3222ad1e1ad8e57127693a20aea6c8e0c147a55cb8414ec79ebba4108fc9d8e074e813b850e1d62fdbecb48239f33d75deb24824007d32145dc68d0ed48e9dba09a9aa43cb8a0a46fe2f4cde0ef8aba7247ae4b966462506e7a378168e61bda866bdc552c726fa65a80e1bd3e0159c00c498ff04cec6511ba1c7488fbce78e7302b7cba497d7b7f98d53f9877e2368514e8ba9f0a71ab3c8700a4edcbd34a526d4324cf09954b071d8cbcea7892470779fb01499de74b5824c8661c53cb637fd5030ab12d6a7884d95cf858052206f67085a378ea450be10bf66f9cfaf3ff62293859e0baec64e17d36f6663861b502fdd66dcdf64655a11009535b491bc6a9ee9769f77129ffbc9d7a310ad444598a60b055e0cacdee2e574a30c68628310b62ef9cba49348cdf00548bec3f8141e2988bf7bf0610ac49f3e01e4b3a600631f1820256e239b089e9ab877d6e421475f43b1d9a370da4d99cc0d4e00a7c6c87e6687545fac82cef61134550845ba5fe8968ec6a60f8fa446d2d3bd285f8c859df7f18b84e3542f0776f1a735105225c4f4ce6e9962305d409787ba3a082709507ffa00ce041607f62be1858e415fab82ff48885d3c4899e95f04208c2bb16dfc17c2984c7951b403b65b7bb8f9c01f911f9dff5492c982825bae057b5b5d63c9cab1136a02f1fc4289e162471f2f45f6196cd3e152efe3f7b678d4fe2ed59df0cb40da5c824b245d366a3319ad8cb19b5bc7c1d55aae596ca0806ada3953b6444bba0c2a8bbb4d273f69c0790b8becf4e56798cf09ad85f4d4cc53221d071674005fdcfaaec5eea3af13b29e2ca77469e4df0b219c325fa8b4369a5262d5a1db3dc0f7555bc64afea62ed5e84da9be2cedf2b0bdf20f0b7fddffa69c7577636758c1fc6c21483d7591baad677910361086893db8c9267e763828d7fff1010f10bf49291738230872cc776f31285d6321055f0356c1d52322ba41cbbc0321fdd8ae6a5b74bab683f5b5c7c485aebb04f2face830730063005e9653c4c9c81fe1966bc8c28671748e346be7f025a3105dbdda44e36975885cf2dbf88f9b0332d44c6b93fc7701ab150c3466589a10c142053ad7e5c519d08648d291d052fccdc3a08b36a78dc7777752b22b03c89bfdd566738f4cebdd94923c19ce12d4566fddfa120b046c0b3d782a2562be2ff85b6c44f6888b4c41bd5751b1d89a775538d24782aabe8420c2baab3f256974d057a9f8d2dd1cc6482ea434f45bf394196ba5406b977e7775bb2ece18bad980b49fa7c9bf6568b3c186e1efdd7ad6e02a72e6642037aeda13fd724841e302dca9b71bd1a684c4d90e2690ae0c0c88414f827f1126190bfc0e6c1cc77f58acd3bfb2d7407f254f753e3407383fade5d0813062129aa0d2747d07f679ad9774b9362f6540543ee31d570146ecec0bb100141d41b610c0cb063ccabce0ff6023a4bde8530a15b0a2ad9df4bd078db00284b9d122f235848b3dd9f48a26dd715926ba50c554e7cfa700f0b960a429d92f63701c44b1f62c19186c069a01c08cb73e014e6bc9d4d9a8accdff3f5d34c7b0b0a9c6fbec5940da9b16d63a3b469deb8eca80c76650c7d3134b585fde903655f394ffbb275abfc6558dea75ea0fb7c04688f554db7dbc9bb2bba1fa4ae82618889c55ea25eec9c200030e21c2f40b34d815a4a31bd49183adf9568a38cee199526eeed2525fb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
