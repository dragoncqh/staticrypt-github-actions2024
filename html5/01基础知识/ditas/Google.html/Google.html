<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1470fe1e189de98d96ff275d2ee152bcbe92cd0675395199371fd1c8f26fe8adb8238d20f3112db5c2b743b1edac8def3161b0c8f9863ac3af59ea4536c9ab5cd4c5a62595c0a296a8fdb955b0c9160314afcb57d3a529d13b806983c91e5a887c57e675e43a8c55d65a7bde40639f4b587263f2e07772eae5ed46a1ad34afbf18d68e8fc7b10a76ad5a474775ef36b625ec5deee6f1c2b9b7f5d1aebbf014f74a924d54a7e2f27b288512f8e7c0ba1f802ef28db8fdf744c63ac25836e99a56b2b6bd22c7bcd571f9f137e6ebe298201347da96a6534d049abde01de93feff54ac326e62e9778cb57417d0053a5c9f85580bc9e62e0178abb18c3ddb6b4a114021285ca8c0fbe93810c1b3583b47218d2ba49f5abd51c60e6ab89602ece8b319257788224285928956e73bca229a2feabcb9486bc0ea540a5930db0a120479932de947f11814c6c7338777b9ebbcfe9c479facd94cbac6c9902b246851d858a21667c43b2ad9b1dc911e9059eca04daf7591dde3ac0e7a0a4e73edaaa5449b2cc83be050a8f1073cf52c8824dab2160eac7ee57d94f93c298167404ce3ef3576051ba5f2ed2e8760bb7c60ee0878994ea1baa367cc4593ad1175e6e62097b0d61140993f37092eaf756a651a3c7a6e6f5a2ad18ccf8c25e403dfab30f76c16340c987eb306f09cf81f87eb7eb25d0fc42a13192a6723bf8d4172f086533955507fb0c8e2c98ccf1370c3c44eafd34d62c59c737dc1b4484d24bcc25fb1c3cc2905b068778f8e75651218499cfe9dae6b7a6fd42e90c0d56941a6545b9786b2ec9d3beabb36e7bd6b0dda808116bcad1fa3f5f73637415873ad8d51496d29519a2f1019d49930881040623d12e4920a23e4cac382d1c6be36ef7e66680a82f509ee7afbc01a2c9c3951115d5ebb3a4cc0740f2c5735cdff5b22a5a7a50d7c47565fe0fccec26617828372a146b61b34a545c1706a2108ec9c77bd0bc801501b5a1d4b2129c1ada40de29b23bd34ee62a3233b8faa366d3adb91f0c62e7f89b3fae0c57b3b32f15438a43b1c8270416185d8f1cc80af1625468f6d7912fecb24292b38478fa57b65f654283c6d483e15af1d9b55f50ed59776de77852e268e55b694ae4c35e2eafaf4e1eece4d514ba2242e9da4cf5089cf54ada65b7558eae2955c63ae7a2bb8a25d94e123d315e70a19974e5107ac3bf124b80d2668ba270f37c209546e43014e7927a61e29810e0d3850d0fc9051558d9327bd5c831879064ab6b806ef6de6b80ff1e9aad8d0a86d2979da02f113e822866713bf4119a377469399b4ae6483fa72811f116dcd124a4cada30c9346317ffc32511251e0d565a1e69b46147b2db5874be0f1df3a6e13a76c34dc064efb272ca6d57599097b4f6189e7765eee599906383258f3af50957794bd4a5a5eda9bf66647f4063821a891929539cf87d2f8a99f117ef535df16f4ed07b4c5f79bc75d1c57f85e78be236ac3ea7317e1a06c34e70407f76b431cbda253531a9a4eb8d757c49cb82ecbfde0cb1fa28e6be9eca481c0227d8cb466c9e94b91ab330603a0f1b07017839ac1fbba0fb100c71d80a8f2bedf8d1ae9c085458e12fd1918e9125649420d5a6c96d0e12c10324f7842103d466a7ddf23ca6c0a8efe378c857c49b14d5553d7f373570b1f946796625959dd67ccca605de370840669a78303a7ab2b6c1b2737c14a0f9b1283e4aad1dd12c0e5451d46ab8ceb9ddbc270d09731a9dcf33bb59157a7d636c4a175c2a5d5161b13f753bd8ede3d306a320761de1c1af534de8936a8644b9a95051b10c534ee1a6c5185bd127ab018f3f8e128d0ff76021f88311659cb38d5ab6e983ab17c1d08b2fcce15fcb3856c220a08cc7ef183610c0cf07d995780b77315c74225a53d54f47b2f9b0c7ecad20d0da74e143c423ca333d252cf215d6779ce9649ff27453d3043d89817a31e02f267b4bcfb1b4653aec2395aea74dfb9b5abda8bcec860b5ca8e92855645b9e5381ab476bd49f9ffd14938347a337264adae13485bafba6d279885e7d41505eacc93b257989df2c6bbf353137e1331730e59c0a3b741e62f75051678f61d464e86ec51fbe2ed3b928a323ba608348380f4b5e93da13c2a7369e37ad9660d878429509849e35320646171b56bfe1db6795c0d56e5dde9757933fa45f95f171a3cb23f727eedc2ed209f1ca9aea4e302c036254bc36054297ba06c8cf66030454fd2586ca8cb9b57369ba7e0b9b395300bb1f3d37a88bbb0624e31182ec790e4a8ffd06c18e6634d171e857424b8aafafb44b098297d071e9f3e9bc624d592a2439123fa251fabe90b7205f35607f93fd6124516a1feaef6a6f1d64635fbeff4de1fe5033c7612070130ed9ef1ec8caeb129891785d09cade9e833d8e680f9d4608b1911cf683c0ffa8102ebab00c1279367aa4a0283df388853403b438dfff19ed0ad5cd1b090d4e0b5f35ef1f0fbf6b1eba368d17de13b3cccbe821c1b21770d8b49d5453a9e4b9da8d450aaf6c9cac490304c63b3d0b96dc0c23450db173a1b59f8fe735a17858ab22e47da4e86558e66f3e854c9d8606d541b53f68771a55f99f0df7e97a0f8f0092c261c5757c908ebc12b693897ce814fa2ee4e2debda5ee91995bebc7614691ad3aeda5673b0d0bcaa9baccb8c48a16a4d1ae0137355963c80b682161c53910d9f6a0a2c0748efe5598f2910e46b26e870357ef22995e3896ed864844860048724709db9de51361d8b04b62cfc9bc4b1527ddfe8c0813c901d93250bfd96b19fdc71f3842ddd961545f66d2e4f60742b574bb2b638054f90dd6c8d26c8e59fdbef490105dfcba48e5fd0f18731a5c1d06a0024f47e80e4b6ec122c19aedd5fcde918fcdd13b89fea76eea830c1623abe826fd9ced8732725687c33f9c594d6dd6b7ea1e3749a5d92b218f8d720f2dd636b5b9f1df2b03415be882f7dc145308e3b01abcdfccef75d95a18cc96d8dc6041dda1db7795b7b8fd765224089292921c6fb057bd5cebdc829989a0abb4f04bb8d6ee985d5080a3535a4882a4cb4886bc4a41418e38381076cacd715469ac341b66778a9c9b60d75c94bbd8cb545dd14854815b0a1a70d6fd196d81e3d3ab54c789fff1ed4ee0f098c6d55cbd9078190150145eb42049a53901f7f27dcd5bd7a589082183e2aae1f01547e56b0cf8e0a5f7f7a47116bc0ef0b8d3db900883f1fe4acbb16ff703b7f690f7d1c587b213e7df501b4ba4e4c1149fcfe60d62ba17099b4abb8367d2c8da87695ce8f3753638c50a9bd2c344881573271fbc8a031b489b91c84c55156caa2f48da51b1e0f74997203f77604cb4ca17a7023c13c649dfbc2850742ce4cfb1adef04acaf940f60af278938ea32a0ad9e57b917d007aeee07a5ea644a31e36b25a487da4681d35f127106b217674b5eca0a9c2d234297180502896d67ac513841cec809cb0577d97d86e731fdcba4bd8f4198973df340fb82c6ec458aec8aff0eec31b01e17320d9f97cafb8d59e67154eb77cea89033effecd9628315192065b58dcac11c5f64f04b442c9e6f5f09b5e462f9e578b05eccf0c9526b1b925841515648000affd23f3172ad057e88f4da9fc0408ecf573c0278297c29b5282459bc2637f74cace96578575f4ec22d70a58b3aca61ac0aa802c8b1fbf0d96f621e831b042328149c50c28184086fa88135307fa4b36768a8b41ffda1c48316af3d3568121ac99b6193d8ece93bb0e8487cee8c2550d907b5753e72dd5eb84f2c441f20894038d293c117bde300ab5706f0380db927177b9ee5e3352614bb4dfb246e896f3b79f9dce1eb9b15b02e51aa887ab258829962e3876b72bdbd922946644ee6687ed373a68af7f96772b2d906206e8210baec07f3cd5aea0b60297a0a1a7dd351d946f920b5e74c83b79905c95f8c2dcab861d86b1267928c663bb71345e9d63b7f8acfcc8fcfadfe3df3ebf821de8a87b7f077c757e19bb6f00d324c68c97eeb0a0c91daa17750cf18375e7840ca6ce5210023050ded07b0ef42bb691427b765de95f909d3507195bc26334f83b2ea921ad462a584b4475cb1c55e901143f700160dfbbcc53029aca0e8feaa3ba0a21d917a282886ed5c3df92ee3d3a3d85d90f2b6e0917408b2e74691e651f87ccb6d1c38a54ac54cd882b2120c9dc142737a911c1c40201d8763682efac77201b47eaf6faed1a172fbcb464dd29f2bfaee6ca35e22831b0818f31e004c8e1a9eb6362128e028ae2c55da7f367c2bfd2244d6986682b2b6af5f9154605746289f8771e0dfb1815bc121043c3a9d941b1fc025836a32b585579e39ff83bbfe44f8d1743a724a5c9f044e00dce159341fdea6565a60011b61b64c7632b43a442ee933f343aabb8b08ccd54030a05a9648cdbab2174a2901ccbdab3ca2158972d180ae8acc8e437d0d05e0eec5f0fd2f1a53d9771f7a94e37e8c47859e741e9b5ff3e6659da822118ddd98c3c501c31e1a764a9a5c431983b8e6e8af8c5104fc0ac6a2cdfb00dfd0b9a14bb9b49c0f2e84b444de537f637a31bc6a891c41c66740ae1a475406d366082f71aad77a4cdda606ef48f977b2e2072b247faed5b3ad90a2d02297e5d871c3cc1a3e9f850e18b8e70ee3ca5198c2aa0ef2e2d770183439b7ed90d4a9d7303839fd313613042d7ee9aeeca2aa5b0e6fd4a3680dd8309dc0b95228654807c80075fb01cb047618680040e2e7a5a6a6154195086dcdf49e606372ee1f8ee0ef6f24c29013cd25e8d6e21d6062bb9f26d09344b1ec26c6388c49fe57603fc2040c72f1504c6089a554bf895dc6fce2992a422699b3c025784d012508e2fd4ff43b88d0fc7fe8db77db1c70ba98ca7a3e68e8bee8e728a36b73042336d52afe565d444bb2b12fcfe0e296d4ba3f2f83b87b5c594b40c2acbae1bc531d5bee45c5d4159553b90e4683355171b24b5dd7a4c9a722256b8cb03d23e67d67126dab53f302d398b9c5dc61e853f54d32997595d50940ae9ab5f7151ad2f6afbe69a7d25e4e846f6b74b2907b5d90d36b49096e932003d94a703d91fa601b66816bd449e7fab4801b108a6b9fda46c2e164fb5afd0fd02aa5737e5cc7e2ac0f8c127ae764494b9546ed926b67b49e62be3f0c003b6b4fdb0f669ec02bf76fa2a3f6f1ae0e600f1033027d621bf3bb7116e5a4b5367649acc0d2187c4fb6fed8d97868be50dc902896faaf01d80118393c22fbd82cdc182d9e0dfcec922530b13d331b25639c25abb21ee74d018d20a3bf02c2a42612afb86f1bbdb4b91dadf3be874602b14b967ec1f794286f621d2202a36491096362b360729f5e4a558089e744990d73979d709b1352f3ada99eef65843bc70b836308c46f804e4640efdbad39701134f78d44b9e3a3eef31ba37a4bb020729c34898ce9c7af3864a14c15a8901d7b5d156ed79457757c0bf64092427da8c092be2a9142bff306f6f3f5109cf305f4e91bb0fec58cb2eb373754141e8ffe27db01e77fce66f57c33525a06d78ab1e64f7f222108e95bdf3e4c0294defba6c089c4a2a23f3123e69a97e4791958c4f616d12f7ca71b60b92895eb3bd10369b80ddd72dcb0f6b49e67f0f55170d1ed1c4c2a7e2a5607656418fd55d7cd47fc65829ca19eaafbcd6fb1b7bf7ddb684cecf1768f8e059592136a49eea65af63ab174ce408a2518d9be1522b6440f6cba19d07c13cee28f6fd2f55006b8f6d41460d473e5f0560d965866243acf57be3d0889dbb33f4d38227f27ee64482d17c61e9cb8c7dfba75858aae496394a85c8711dea3749bf86d558cabc111032f0f02f59e404cb3e8af7ed4beec7f2972fc48482f85ffbb8144c016453dc18e230a56fcbf56ca0333f2d6901f3066420e9333cffa38655b37d6958342b46d8518c5bdefd39471a1efb8d74e94fbcbdc0e855d32e5e9a6d7f2e5358ae2020a7630fe2afc2631211feef63da005a3b9235a89f9cf138febb42156150a82888ce413ae27b0c1970c547350de523e92e68fd6a6012db2867cd3ee20605f47e1b4776c413b5d0550d9d93cd3e1792ba42384cb446f9c020d6a4449f7de6251ea848437d23f0ff22dc3f9f9a2d8099b8eefd81c90ab6a9c80370c972893792d5cfa21f694e38441c6022d977dafb17806986e710f9d8270d3e6a9ea0c4dbaff7ae77da860abff3548e5fb9a1562535fad28ead919b0ef73255cb27041a0edad9ac036f4722edb8febc4ff8213ac360c226d84cd1b50d361dcd2044207b0605409382acc5b1b7c10601abda7ec77190bbfbb9467514cfdd32d1258dc52267ff85f3c6517392c2464efd067cd8413d33d86043eac2039f48cadcbd922d8b79982527b88595e4015e4e4dd9f9a7d7dc6642b9560848ba3d07cd9a7adca5883d14a9b2f50267f9bdd1284b03409db73d78661222a50871c2ae5627976a4fcca77ca6252453a056ac755ae97f16b59b3613140498ce328fada3751b2d10b68261a62023876955c7cddcf3b6dae2a856f62bb4c5469460c13a5a423853ea3161ffd0a2a3b3cb65032542ea773aeb4b645e6a4c544e45261aa0e27e08343aded36fbd60a9a831709091e6df6da619ef273d1e8de4b3b4ca9bea8f4fc0a08aa94caec7204c2d8cf7e3b8343237afe77481765b1c93a07a4d6ef22ad64101514697e09b210960f006fed4ccba0eb38a97034995f5ad3aa8dd8983ecc5d1d71a27a48ec8c98e2834e56391cb841f595002ec9a8f1c7ccb89ced26c7db0f9dc4423874ebb8d10355c0c7a0a8ecd922001250d1a4f360df2068c43c38d5e48791a97a0395083710ff6a0fba9d4be743d2f7f9d50bc4f42eaa86420d2db19efe16f191c87d9d1bd75ed8e91a2dfc1bcd74d13cbc1125782912bb1f22e86a7fb685071e797e908a5b9a6a78e132e4eb6b50a44a3816983cfd79e74642ba9871b7e8355e68b4d55611431e96d9154a28e2b1b54320052d45f79dbfa9331d0ad458c079a201879dee472fa71527daf340b020aa4eb04d78002f8529b215ee0a7d3dd11928305dfb4613eb28e2dbbcb2d9b1b46e4c168f45b4fad82127bf7e3e3e3b12179a3641d3fbf4e87972be2ed0a113039f4946b468933a91034d27293d3cb2e14b77a2387bc21c1cb09eecb2b2be0335a476375461cb0341753fab0594c2e267c50fcce1690a8c3b5118a20bf79d467a767a67c7229b70c1f7ef3b64063b0ac8cb653011bb64492ec7f3fd47ca2e45ffbe7b8db7d5f59df462f86891aeeee11453cb5f311e42f5332283fba4c9fe659df1e9e20daf016586dbda3484f6cdcbf325173604ea8ee97ea7b2bd068f9c603403ef75eebe28491a3cb8826923a3db2e3517d4c505b7f956ceac78b56b77f7edec5067ef160a49d95400d8c9b39af488d9a1498759ed9eaaaaa8d5f9d9b6bce56778593d18862a0be84d25f95f683dee3e11ad70292c40438b83c6ff643bc2e1523c765013745e4c8c7d4421162fe424d4fae923e660a4c6f8b0fd7c95d5c863d104d487521f013bb257439958834f8be2e5fa9b8fc56acdb3fd915f97dc07faba5e0a0d168dfe08268f2fe9b45c65c72ad556965052b5f0275fe68dfd1743f7a97f52ebdcf08a462e864c378e9a6a3e4a390ef5caba334fdd3b8b4ac4ae633b88aca32d4a02cc6e071bcd17fd28c9c63478e9966e5efb3f0d1153e7119545c9ebdfd525f177ba8473e416348b200290d851d1e0b18731839e51df935c2ab5def1a91a3f7f9c701de2f894d5a76d8d9a77f5d6ecca04394b0c24c6ec60e628f155fe73e711ba8597bd7240a63e8f07f2c72b358c17df431a1d0006db9072943ac68080c9b44167c0de0341364f9a398bbcd5f1ff6e8beccd58af4914888bc8c266284aefe0add1b5d2a9b58e7ecb3dd78d34e27863f738b31b2cbe91da46336148e148be6dea22915db65d0f88b8fe218d046fbf5c2bd009c0c067092abdcd426deb35b114dfb08db0ae72c3ba6822b3749be80a202692a6290c4cf6f56f7fe87c3702dbb76d41dd5d495d0bf5c44b71ef25902016407f80f195320750410cfb7259aa4119dc92601b288e2f6ebefccf2b8fa7693a10be7011c3ccb75328117cea01458b9fa5ca35262f9bb5264f82a0b2823b53ce4b46049f6c88e9e09c06d3ee3a8c7b5dbe4d9aa20655186f170ada26e33957e93be86f35dc8b2b26e95864dfe1d252bcc034d1eddbac5507112d1b734239ebb808e51abd2cb2044538d3dca8bf95e1c3442a3653d7ba86f5ab6ee8ae97bb56ed67459ad7bcf00601438ec125cacf96f18e68348c4034e8ecffb559a7915612f4be797f80aedc00aaf462e6295004ff176f8c268156db1cb7e840c4510fe4dc275e0771d15637aa1b8b0b31de95263787dacb63b5810959e6be00271e19d83bb2d39478b1c1f06b7629e9f9174bfb463934ef816b54bebda8556207b2a89488b2a227e5be8a6d96764786efcecbd39c0cb0c986f07f9a53eaf6ac196a0ead0073dafd48102bdf1fa6b7d3f7903ac78c0286f23ba7742bd06a2e7dcb649a936a88fbb72c4e8de13f8f86512d8f3e869d89bdc42f3a761720b266d90fa73e2e176c3b84c1bdb73a2923ef3c8f22613919f7f715ac9e85aa8513eaa8c0931a64a1f7b13411831959a9c7bd888c769b2228160233e201b6b75819ab29473b4cb72d2c7acc786fcc92602f8cfc88b961825b169e211189b5bfec189e1411c0ab25a79558c6539f8ee50c2e34e6d8191f2c3775dc93cafc45daf72618eec0335675b4a23dc230d64c218927ecd51f67b75c3c5a9aa7e602e078e7758ebcc6f8cfe4c6bba7695b491f96083a2e2daaead6945a605ea3aa473af03c8aad6143a3dfc3286e53a73b983ab0b90b6ad3b5e6c638172f947c75338998bacd46ab382ff8e9c0ad811f9d312f9cfb19a28ee93d714abc0c78ddd9b3a77a67ea90e8244cab0392c8d6930d4ecdf043037fe68d4f7ebd8bc3921506c42e796425bc24e5ef2ad8a2b4c70b130fbd037d5da74c985416fba284e030c20044f264c91a6ac4f23157cdf3fa70fca5d923841d9a67049f89eea2cf7d0d384ac77f2237ee876baf13ade5de71834a3babdbfcd718abf4925e5fa57e6ccca0fc062bc97c157adea91d32bb9a62dedc37690b23ce5ebf0f6ca2171483a7ae6ac2e4ff7855cb77630eaee8c163fff9c8bfe2d489b8480789da3eb45f17e0ee6004698fa23c24b0d27c6d7d6b10b1d50c1d25fa46e3838558097b961f27677d260c17b985062b8c15b6a3bdc481fe0b67aa5036e1ddd5401ed7b78ad95453e6c4abe47613da992f7bd6884da9fa0527c6a3fc0d1b4b1d4881db236f54c872a2e773927bfa80677b39b1a92d9e970c3ada36bcbab136f8750c1a0dc515ab5e3ad4c6d39c24d71b0b0d42a921b44616317ec58b45470cc7a3ee51ddacac233f217951c124c9ab4b70199b9a87a6ad7a3799b40eaeb50ed48c194be1d329c890590aaad93d0356d64572c9b8db2917cc8a63644528bcba017f8b6f1e15e7169f631cda9834a078e0dca6ce215856f41d981b5227f1ab868f4ed0ec2e1b218b95d5eb4a4f41b2bda11e9eeff08b810f021b23f91312258b0d62701ece3ec3db1f9ed2002dbda6c5472777a31b6d0e925aac27c725e67055d7ec423c8eeed75b5b1b80f1d31823e5dbbfed3ec46ba1694b8f2fea09c6049935f5190f880d16b0ea29fc46a381ce60a614d42bc68bb0678ff1363896eec5db15d6f6d57a6ec4be385dda338e775adedcf97e39563f29fe07ab9eafadb67c9c87140cd118a7734969769dbe334c70e8dc16d7927b566045cc7b329ac84a3ce573ddc24dc2f147f40f4c396558b0acac005590fc5f89490a28bd0d781c02a2bce5d7e187b51058626047a86120aae86d8a6decf2b5cff224ae5de05516040a88edaf7a58ed98db215b0006f15b2d195b3b2893a2b4410e6654b19f682eaee85c3b4a89c0cca69e4d75e7a49a29114f73a9873fd81492313c8e353899d870e44d671032f5f6049f1fd0a810e55ee7fe18e10564bf5214c644c53567e17bc8732ba95c64eab68b8306a195792379d1d4462696eab5d23ec182d1dbe3dd0e94a039c8900bb075a005844ae61ad27a5aadf978a827084f51455e8a6990137a3aa212a2ef1ed13ade8553b182226cae52b7d7cf090d413bb7209c68413635ab15fef74b68d6b9158a76cc8fe2c360240fad6b14056220ed07e995e2360ae84db078b912b3758790137c726f8c4f351322ca77e3f27d088be0883f5cdf6a4aad97640447f33c9d9853d1ce730ffd2a614d1b40607f8768857bc045c64854903f32bb23f20d4a44601d1b1de269153d44d18887f5e9afee02d78177c114d33162a9a35f2ea2cc03f9e6097849d21a77495ce4087c39e65de5f90b5f78134a6a8ea645d6eb7d87bbe651b28913607b4ee1c5879dea320711f9f271c6555af14581b5242c61f9f79b94326d26649faf54992832bb8e1cd17e347f5da2bb4071fcdf1746d5395edccaee54181a8abe20a41d208bd28a43daf1ebb4b69448f0290e256321f134d180694cc6b7f30517ee1f6899639647fcd247d880d6e4aaee486b49fedae840d408f6ab080a13dbdac9fae279fb65160c91c0f5c1c46203722eedec1d93b65b61b6321535690c508a5e7fcf483de2fd1b4b17a6827f6533ee708ca93d9235ca9f9d959dd4cba7471d7c0a35246714f8f69c0fbfb50cb182752a2178941fc3f552ea8d750994d2c32b479d9ccd6feb2bb91096d6cb2e9f92e75ae04c3d44d4f1ba15c5851b3b0d9de5ac93644de5e089d4430ff5ba560acf6eabe7d0051c2825ef43cd2beecfcd205bc00cd71ce3cf6ae61b70f8794e742081e401130eed063496da0859dd2c6459851c1c658d8a7494478f1d4fe00adafe666058397ef2dc4e98108f194dc468eeca5358346a30835f7a7ab86ea66980326107ed9085a435f06203bd0bd4dda9e298314ab8c16d561d950adc7beaf2aaa9c2590bc25f31bd037d0d1a749f0fd48026377ed2d6ecca17295df031998fcd8f8ccb525b4907d8b8260bbd1d2183c0784909eb31eb9511f706146798da7d82fe20f3d21b7ac61b9e12224e4fb2eda3ec5cbeff46e0ec02c3f4f457a303bab6ff69fb79086c49dd1cb10c8286701d07bf36c44fa8cb925cf1db0ae065c07ec25096a7be21c5eb438a3950266d6f390679ae699763d9249e8836fd6bee55cdcede520c08e42fcd265affe2958571f0080651d6d6f0845a4072b6b204ed831041e89eb8226378dcc2d0418f4328c397b468deaa5ce7062a47d89a12f803dfd1c042df1753b392ec289f0fc26071717513f39a4a36bb4c88dfd157ca7ca26c81fba63c6dc54914a2b452dd2fd126b773d9732443ec0462b1ddc79140da18cbb374c597a1f33d186bd7b836d3d98ee0f60434bc1cf74574df0023d34cd7447da6d76070849a714c9572ae9b9cc612425dd13fb951ca10356b4834b615c2a2eeb02ab3ca1ed15c94ed4e4d4ba7b888887bb0596fff61920eb1d0b05298378b46aad1f5763b499faae93768a6c7c3abf1b2afe28df2c7017da2dac7c99fdb283be905e1b6f9f69a70c7b87d258e387b9b23973dd028114230a5ec0b639be138a0d4e0724c6586eda33eb0d9d1fe3c7573a9b7c7a8a7174c36f9125755c0c28a6e1f0c8f7bb06bde9cde01eee58bcd0d28d5e4a94c7351c59dcacb45a428ff9d561b09202864d395f2f1a01bc03e3e50062ca90b79455b13dbddc3a321c36417b343976f96951cdee59590673fd051f67896f8aab5797fad429056fff9cdda354cc7a03287e8f1fa20c532762c45083835f5ba963d4984cb266458a69b7508fcc1d007351c48ac63739aa0e88c843d44b4613407773c2cfada49cbb056dd73fc938339e77338882686369cbdbfcba3abe4694f9e1b608de6eea12da65c20f772982b05ae03bcf84dd764de3a8226758f7433505b0f99a3960f35ea312c4b0df2cf305baec0c032a6cddbe66f612f0e80e99f3a6919dbbbed24315c445c3bd1f97161b34795b7f0aaac07e04ae4b7e7b4184f630cd365eae5f2ba6de4f7826c357f0d8d122d6e1dea3f2847e10e0a1bbafb6ee220acbcb56565d0a96b89b1e0a63cd7e6f91bfeb783de0207c8999952f028b726dbab4b517ea6242882b34c8d1b3a5defe4802aab94e47a72f4793e7d0b3883267ca5a61324a2145bc0190b2897c7ca565b3306152c76839b166b4f9fa903f31ac3086636767b2976e6d9b13c4ed48a77cf16d965d1384a073324a9eddf98b5a7d7938dfc0dc83fde4d223aa6227810387d389ebf3bec297ea56eaa2b05e97364e74437bf3ee8aea3f85cff80dff6f202c195f253d9b663c03e2ced010cf710fa1215b39981091adf0bb465c9da42741a14e7e04463dbb3bd54203fd8317bb3655b971f35b0f930840ec16831c6840cb06c8a3e7bed86da646135edac582efead8e2b4231601da7e00802cec4fe2ae723b85185a2fb3c43a8f67aa3ea06c13611636bb33387f8a98c9535730abf2b9c119441d8325b734af8e308a78de054d6dc7ac19e175f183b631e020dda1116951fc02eba4b25987369b2dbd1a3afdb9f86669f4499cf198682f208145e09be897487193d1cb3905675d13bbfdb215754fd7ae9eb5138d7f6f015f89df5166575340f3548386c6ae90c600d041891673cb64a7b4309bc264755a80c93bc75cff20d4371c62ec280af74f614c3e30519d775ad3002618132ad284e6edd5806016fea3957e4deec040895dbfdb500f35b6c2ae76742e565fcb533730cef037b8984239f3960d817dcfe0741d7a9b642d2c7c43b888f7819c6bf94aeea7149fd4acb3e6bfdc542957b1fb1450fdb7e02de14d46d6216ddf76b4c5025b6ecd7dfe6c5bd3f78ef53fb404746e2ceb32977006fda00dfa7b0a4978b28d8e12335302201a6790b0f2c770d4cf2394ec316ab69b93cecd12e956057e6bde13168903e0fe1e68d3e43d15427ac52bf6dd918b840c32919802e5a7f5fe5d1691a95e64dca60ccbb1b78d899986fa9de0cb7ef28fd8e2ef93301ff4741e981f630321da1bfd951403668510a08524f318d754966b686a4fa103658396dc8ec564bdf266384117b289fe4f1b931bf4be2512fc701d32eb7ccd96771c6754b47a2a8358766c216f1fff1fa4709cdc1bf95dfe86ef36a4cef2b2d88859e4f023d3c6f319ed045e4987a24dc9bb6053ababadfcd58778a4e5de6615978496c7afba30cd9ae0cf9ac1d928235b0f1625966bfe869943dd15a2fe00cca3456fb4fbc6b3c32ed670c008830bd1adf570e584ad733b7cdd27ca16a2432714342c52edf481f76e214d1e3a80111961fee82e9c2916c4dd34e60c6006ab2d87cea1ce32b182cb382d42633d64a5c89ea3f6c9ba157487cec521ba31bef06959dde4e32ea68bd50ebbdb284baa5b79603fd6b7694c74a949b077e1eb746af7c74961d074696bb7f699197b4c0a40210d76a4b1ff11e9b17141bbd2070b1a06804b8d287204b2eac3f4c69c5c9d89db997b56865ee2c021765dead1378aef1fe3f832e0b059994bf68614ad0b2442fd8a0b3b1f50023d3ae774892455b12ed3ee6b71c6a8ad5f59e0c831d8baf7e88056164a77e6a422f94d3dcb93267515823090d9b652ec00db7a5ae1792644519c6ec263c67f99f4bd53dd8f5f31156232a0acc0439218307593260d94a379242cb2d06a24352ecc9726bf55f6abbf782f66e755e603322dd89e0fe51d795804fbf1436caf64aa224bca9671cac2f145c1777e026ee573a97cd6d26f16215521da6ee51da2da1174bf14476736422d581dcbb239192d75c822e3c78568a40984787be24f5a05c66822a22fe3ffd861b94b22e420c46093139c93397ce37b412f254b096f5ebe4ff6891f898a90d9f030e2f4f249865fd06e8ae332f61b4529b98eb8260ba8e9f668829763abde761f68923b84dff07b2c4b6ba562d53e68f1d42e1e1d5087e167a35c07d522f87880907f5ae81b0e98adf8c3c98c65b29c834c5f88aa87f4818bb05a0063369027755793fa6ad80ec8400b0f3eb7aa2cca9038a7c885013c35e2aad001694ce7ab4a08360fdcd3d61fbbb71e8cef86153172d09a02c2e2369e1a67910abeebb050f4bd4b0c0a017f3eaf8a6739d7a7ed5693e24c2a1aeb44d22b45e40286e7cfb07a3a6834f860a63ece511ff4c47e806f56bc4622f26e8f8953bf08d2cab46f86c50af413dc572f53c191cae6324864b880d958dfd27b0f3729b7ae5a7418e2324fad00b20a092bc0be63e97b9f9630c8fe93e7a70370713aa594429b1acb05859a0091d772b42c09aa6595d05cc471e5eae447603ec892580d2aae5e108d7ab25b3821a510528805a1497bf6896dac8dccb6b1f26766e775d25a4d9caee91d94e7a4f13acbb9ff0baf379c82c70b88649eae9f30374d8502691f6bb815e5341ac308f973818b4ebf387d570a981c52e103e87601d1ad408375df20762713a0e0f75cbcc8a3fe7364828f565b2995fb91e8734f46efc47e3a147f6dc7492a817b3d3d2d73aa96000138c6288c54d1cddf481a3e1db13806ba6da6b9f17f6a3f64380297212c8767e85e98c4a9fb8cf56fd3afb1903e2ed2eb6b453085e65b75b9b9c9ed2477cc1ffdbf34c5a8c1fd3abee61aac7fa1e461c00713282ef34c61ff9a1cf9db593e3f313691e3b31382b38999ed3f88fe96d9da3a0a928b32bbd1b7930d73302a38e38ba839f11bea238a9542db30c6f053b43f29a1f7726f18e506aba2ebbc6ad4e881851c2147cea0e5c19051bb0413c60d0a5590e10fb98083b625da0540f6f0ae425263642fce09a909f9361bae6ecc93e03ece0a19f18cfa27aabff5fdd5e6f77d40569756d2e4ce2bfdd117cf1f52f69ea827d8d3c6c39cc22978d41f12e7c0aef8903d8fb720575f94cc1edc3f617763bbd8e694d4aeacafb4dbbba264c766df9770dd6c3e658369459ab987e75c4d594bbd0861c8aa262e8a609ed45bcbc94a3357909982c8dd19e31d1bb76e004381cfb7aa8c080493070fd1b37e3e3ecb4e7dfa6cd0d5ebbb8f474d3ba46258f02cabdbceb72f0c5c8ad0bcc5cc9da943712052f43f2aa1124fec38471ad6ca08bbf59fc64feaf7a9014227fc2bf91be41d5f262256b046c34bfb10c98b27fa3b98ce2c7e48962b476e1861fc7ba83911c38f66b5170b8a7dc560a498a5c83ba974d54f5481fead8a32d469487d0d4d93dc1ff4dcb67b38389be47b6224984117967d380d16665e0418b9def2d678c2c42c7ffaaff9c4d6aa6fabf0cf9a91a5808c5906a88a721b99d4ec3da4825582a4d042961b1e01c851f1c4ddc1f718de9494985036c0d50a4398eb9a7f368f8aacc2afc529efce013f01e9a472b5a368f7eafead7ea614a2c56b7f1902ceb7debe3ad4f77d3e1a66d0087a634f07fbccf2c3102662dfd5cb8c15e35c3d028108702ef6b421054dd162e4b6d0b244ed2e51df68139fd0894ead6892c19e1830e8a68e9e93e1d595b507ceb20e4dadc86e5340cb92b158da86d6db38b6e7cc391c77a5cb6caeaa02cf65a90c8768e6ad2034ac6fbce08b50f28d2c6ecb058f0b066a36b56206e2696a931fbdf3216fdf0f98a296f394da419ad2b6be54bc737a5216cec9c70eba1845c3e1248442a5d8b1ee8fb58aee9d61a3c76015ae30ab9f6b88e49c15b6f7f08c55a416ce83b5c01ef536d43162a1df045238a616cd724388eb4946fec7bd1e5d9733380da617b698ea0b689c5a29ab0f3815d14fcf7dd3d477a41b1e47351254d9fa93c82151193f189d8ea988cebc304dfbcdd99576fd754ff8909ac94b86d13fd96c4267c2aaa886af7fc0174eb3441f087b82ca987492faaa63af5c2322cff4e4f1bdef69fe5f9fe653f37229320341fa36527c5fef755d611472943d5da80d52fe03fbaf805e39f96d628e6921615c00acfcd4a932ebc6a8edb4fcc85da4bbeca934feabb2d936fd94c5f57097127c2958800083277d2aba6fe5056a4180cbb2ab4f538a2c15a329202e43a95b4b12373df2039860529bf5d583b1669a62a5bdbaa0a2742d35d35c8df9a09b8afa8807b2be5405515332cedbf4bfae7403d360d97b1a8eb74cc9c42823cea77ab3d0692bfacdbb010604a02cc82d2808376097016f9bd5dcf1b68adb569e551868134dbf8b8e73bf548a835f1057dc3b014e32c215dc77ab91aea6a866dd3cbf69f7d5f1633bda2e8e118f04e90d5ebb109dc35d41abf9f2a05bafa5ccbf6ab054e879cf19c66afc7c2e4efcf71e63e3139b6f799ecc4a25f58ec2e9d6ea41a0c2bb1dcfef509ef31ffe3da2e00568725ff7c1103ec868e870313169d9eb201dc398de43fa924ed195832648012dc7417a86bcc42c7e19aa204556eb841a899ba7b6f131d55f792e10fa66b1bbb2ab68dbc68da32cf571100bc483b3bd8817118f802a3c79b53754279eef02cef3598ba64290514b510019df763afbc7110e3af43a4336f1f6aaf7a92adce09a39dbdfe98cc970001e33b9eb27a36e7d6a271bd7e0229f025999029b1f4bf8e1a965b3fc6f70dc6a771f6c4030f6a481f67d07b657dd59a2babff6c83163ea6783e5d5ace77c1255c2c4592009ea20524419af38010b71fa1dda7ae7bcb87b8098400e8385c02d482809be16cb6c0681b73bc7a7bb29299ecf4c6709afa39f6c8e3e32f53f9ec9f155fbc353e0a7934e3cadc42243d965a516fa791839879db30a634f006313356fe5cf8d90bb635f40c051021a5b9a6bbf50be591adc246cc60f97c9325323b3fb0c3ad4247c947d6b6ca45371146b9e9e7ae23443206b949ae4513c8baa8f1d64f1e39a1099aae641ca62dcb2a070fa4adc15bb2713d77fd6a8089e529f58a614cf642ac5ee7f37252066a1cd05b06309bf0295128da7aedef76f2adafbef9fc244f2a9fdba58085e7bdd41e0cb47d8d103f92e7d4dd0964dc862250e0aa472bdd46cb0b6d9f4c6f06527bd370bd96e3adbe799a341397b5bbe820c24caca26e6bc1ac9d40cc34a9895052146c34d8e4619536df4467524a09a3597a1584b9d0de454717c24b3d180d10110dab7d321dd53a925a9ad8b3138fe1b362fb60a65c7b8fc99608188608943a937009adcf36af340ea8f8fa3352e86946c4cca3dcd66924ce58451a485d3bd7122e3a52e50980312d99303b58a4dff78dd39bae8c516544512faca9bd27650b463d228c6d555b24ab62f3cc9d2464967074a563e19401f467c43cafb4306c665fc39056626c007d4b880e3b26be512f4d83d62a5521049ac09e78cc08da12be62c5c3cefc3b3c74a33310fec7894ff69d3bf9519e8c42e7083d01e516270aafbc18f48915b6766901cccaa43acd1dba01532e8e64be8f7075a7e05295afd2d88824fc166efaa58f43207995bba226a438dde7ed5f61ff21d3bee8e780ad249f40a2150d791fb3a0cdc3bb08f491f184a417d2292947d6e0682a775d014addb5ba915a0c62626089ce3b96dfa369835b22a3e02f5882b0113c07bba15f5e6730b67bb32dd635cc4bf80ed8934e86c7f3cac11cc1477e2ff1b0c56a86d9d2bd8bf2280fbf0e02011897d57ece8f98610354238ee27c1f526ee72ecfca952e1d2e7cf12f12eef15dbce20b1b4c43c1b968ecfc982249687db0257c8067a7f498d3ac48ba84a9c1d0d449039790f83858eb6e348ada07404f421facf32a969c7f4b04ce2a042dbd75e6561acda09b7ef7a4295614cb1f90652f10e6a7240269babdf296f9b436787d6ae71bada5c06259b05ab3c544bc58b90f9f2c19fc35a12120aa4cae95e594cde58845dd54e9cd8bb41f9c18fa71dc10b0f414625f50274497fcb338f8fba5196ffe407a12be6b0dcb1b250d8e1eefbfd34e968d6ed2a251c94b34c44be66ac283e0eecb0e291b66f4605875ac42ad472018cb356927ff67da78549d37fa69015879afaa317eb988a3d846c2776461dfb9d003bd05a2fce773eb9201b251a9b9b1084832bd164b9d0fa332b25d210e0c1cc7ae735a3f80c467b5dbd1fe167a05d72ccf7a7d10270578aaf73bebb0cb63c9e0335e3b42c1e6ac8470ba706bf0fef2935810eb38607798cc1757eafb3f50fc6634013e0d99a8f001db93df335688cc27f20fa285b2d2783be2af0dbacc80f495394ead57a7d263066d3e7159b8ae143145fb66d87c7839b37856c7d739933d2938ef944eaba867ab2c53d8061681fb289ba920912bbdd8d04a47cb43617214680bb1fc63a28b93e9841490fc495617f1e61b3c44394abe0e95d8019a4b4ba21bf6f3ce6a935a6e4869cbb85439cc40209936e89523445262b017f8653a668a18aeba156bf36cc746e100bba4a217b15fd50be4a9fffd6435073ff2eaf87726d161a3c7c99c59edc0d301f584902f850745fa6ba2447a17dc2e87e7ddcb0550966b48d2b1c2d0fb1f490da95a8eccffd998b62834bf4074196279fe9a835e017db11a4ab0fce7ecfe8900f33d72bb15844c5e769bbf2c276915db73386c2d6b8708b2c82f81d0089d9f38b4003bcd635c4fc4fe4269737594548164d29bc3ae6c4dd834a0a098c75b15c4ae28a240062c57db9f03b01137d4300c7940b76537038fcba3b4c4690c0a893a5f4aa6572939eaaa656a6efb48e087fde8e671234035df3ae070d5fecd25cd537231d240514e422f9ef3ebc1a66a039b8f94b8d83e739fdb2f6d507f3684ad8ad22c86260961bc0e07493c41167ff084382cb93669ffd4f89e9850d017bcef9169b0cdcec73d4716e2be897c3f83c8e71c5840ca889907189010d69d20dc949b3eb55685bf0d060b0481121c9cc0410f2e794405e77da8442b30ca8c2e2e4c2c1e70d2d3513f7672235651c3b659cac1889593c9908244d71352331b07629c5abe21f897a12043b995f5087e44f82d7a0a52370185b02cf1821918259376c9ed057bb90cb0e28028e138381a9802b5d18b73df8e959b2c6ba34709949fab59feb6520a254c7d8f0bebb5589811034a17c00d04577511328daa3ce847324287fe3d5b88913a59614ce6122f657d5a069aac7545fbbfefb13476a4dd57aaa6b008a5995bd05e4a2b3241409706c29059033dba24277b0f81cf30c5f950d2a667ee2ac6c665d9836cb59d4ffc04f695a7a17f4c7908558ddd855850a05799c42483605e1ad4a6ea4be49bf698c712303547b45128d1263481e9c750eadd4fd19d167be3008130afda45e745dcb1ac1a14e1809379754340973ecba4534b48734fbf2ee0e89d29f06375d7e4f2f2156a6bc0aeb10d44261791cd4aa140efecce1dbf7bc17714deb2d738cd2f4b489cd73bd8a5c564b4191003a808aeb798f2e45526f9ab17ac72f5b01f59727d7fe0f33e8512892818475e0377e6e9119cf454546680d5f3a4777340bf86eef732ead377c107508547a4e6516bebf877ddecd1a593d172199d19baed9d32a20023490498e6b63e1037e8fa66a028656b2303089e46f5bb3095550ac7c8852836dfe2b49c43540c6a05a35392584cc9210010cb9e62ef217020b306e14a1af6fa0391f8e323d8ee5210283351a78c0d469f4a2276dccc1f72c0d6626652f30f49b63899481c03ac478a55ba81e0543c537dedd2f01b202393dbe31137073ac47654272c1cd5ed83330f4f6ba942149f3670f063c10f725cff90e2dbfe3cf81608c7c5ea80b506f022d8755c8ce5166da6b19269fca1a404e793159cf22c1863ada3ae146c8f46136e64b722c483360fbfcc546bd2c0792cfa37b100a804dcb9cd7cf380cd1d1814364b471d27afd36c9249ab472523875c27223a51d7812abcdf1310dae68fdd6738488aef4736c64517d881a89f772619013e786e6f19b93df1e045664e01ea844d3c032493590a0de89d3445805e68ee5c684c657ce7727416032d78e8ad76a4e2e8c87410aa654fc1a8a612779399ca18603f5eb4854c4cf8f4ee2eac6d6f4b36d9e62e8d39c25372143a0dffe76b069c9bf865a24be297cbe512b2ebe365e90c6505f00ee8ba1033b0336b1eeca0c1a89b4354e63369e10862d855c98c5b0d32d2305d94626e19e93c6030e3c79bfb2e8663cdf2efb1fef734fa3728be7d9fc7d250af0d95726bff8d0f34dae0689ab66a4dcfdb4beed0cee338eb6e718991e763ef0f1878357ab548fb40fe0d010cc4a954975ba5ec79188b2198b1244e3c3c9ac8318dfbb528b574ba738ba5683657465d9efa66561f522515a1705f02aa2374c200288de28729c29801febf06020cb9d9586a5e67ca113b77e245dbadd7e8f30fd8e5da89ecbee9241d491d6f4a6a015ab179eb1cb3a6f64029523512d7c02eb77882499f42545c1abd98c557b1cd81ef561fa54aecc8b0666c185cd0080610664a30e087a7b5498535abf3e1c42a19944d417f11d933cab10c0ae36f30a2db6d373664d36588a96a9a2e73743ab9e025c99f05dac7a4ef081dc17c0437228e9f2dbb47feec388067a9f8895852f5984808256152ed14dcfda4e66fe5d932c725933e94b682c7a9e59ff3c8d5a8e958c42fcffdf64ff982624df541531d919f506cf27fcfd9f52769ff64fd827158daa434de617990ca4f81c8885c2eb4995900e26d16da19477e02718a344420c4ff48427e5e955bd77e93ecd7b3c5816c30d6200acca6f74a7e438f702c24f02054dee5ef9ea89487ebcbf42fcbd79f223a8e98ef0d1fba86c0b27b75db52b7496d1b0e14e4ce23f35216644d0d7dbaaab2f16952dfe2c713a716217a6be067a286f0ed69869864d0f2aa2f61526a792e998af0f9e21d8a32a595cf3c1ceb7f7cadeeb80a85e328204193ed64f8b09fc81f29e832f079f01a35ad95e3f8cc4e67189abdf15ee9ff54f6ccac701409e2a4a27eddf1b3ab04b80b3174ba3c1410b9980e68f579d7b0df82bb3d39c23d65b55bbcdded994fd71cf9eca2c6b246e9d43dfcfdc78561b7201e64adbfbad8f77f86edbe2a235752ec0617528099bb6d05cfba58cb5559cd9469ab3f97660b9a3450023543471ed5f3be30a8616037411e268b0a6aae6ad1f831388b66e68151bf45d92d5b1f04604e3f26b0a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
