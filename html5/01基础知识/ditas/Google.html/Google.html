<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf4614f0712df9a5ab54c7daf9cb5e3f1eb96e815d089ecffc316a244973b4296e7f9364af7f1fc8a195ec8d03c15984afd4e76e138432045222f81df52c2760f5c88545588db07f7406ab2c3573d670dfd775529b3a492cd93af81967191a3ae152570d5eb0cef757145d37cb6ed4e5473d9332acb887c95fc48049c25e55b5723a8dad4447438a2e7e3d2a4d7421c008158b528cd56dc1542946e260a7ed3645f0ec41f7b4967640f8685c55b25ad12c00230a1ebd7856a89152ce43504f33ac82eb1566eafe7e3840fa3d1caa362361a2cd60415169ad83a8e27698bab36be2eeaf0f9257bcc24e3416a176c9aca829c440e60b096ee893d34d0b6a36531b9026095b6b3c96a85e4daec6a21f30f11a0c8b938432660e39a63722907f117839262a0efd798c81c626358289bc83362891b84ef3bbb2b13a9e1f10b1c181d9304dcc85311c8b7676c04f148246a99a6193b21a4dd260bba0c22622df208ae60939a419657ece72d0f025e8f6934ffb3acce353f0aa08c08369d091b5464fbb201953085d96fb09936ebc1b57d783e6bda64d2cb0de20e657fd7fa665ed725d2a1efad4f683009aec6ee842cd81e7d65b68ce7cb2556828f9af9a3d765b92407f1d6200fbd92d97333bf0c288470430b1850de6c38f5a8a269eb4bbe57bf261cbd233d46b6f801cd82af1771172c978a5eaadcc98e524c08f1b24c0886860209bd026ce568f712f2a14a1b63bf3b6d1c9797c5402a0053a4f927db05f4cd06add40dc3461813c28078b2c377e14b7868697fc1065724413fb7edb004b4db341d705265141f3f2afe2caac8d0d69ae402f03c10aa89ffe2245ab71d7f3b3b383628b5a223607453970eaca03d8f4b63a4f054be65215a82352f6517b42f5929593de4f1d9e1381d435c3301cb0c7f6393a6562f6ba0b430a549de8e9a6e8da4f01a9449e5549938e8f9ef2cdd893d1c0889ca6d4872fe2bd946b674ccbdc61496386c72151bf5b1850e2f88eeea1252afae3d2117dc0996131fa50750bf7bad0d2d9d0cf84b66dafc7efcd258edae450975ad9fbd0973930d745378dc39d784aca22662995fd17142fcb16367a31b937c237290354b6c41491ce1536b97c215db0cdbe6605e802116698efe4d259be1772c487d2a7011f563eaf463d5674473b563ab1ef59a44f9c3c57006c986716e2a1a6ac13731027965b6347161f44c8351b40c0f7a35728f788f7d0af861895b1913b320061634234f2db60ae05041eb699d1d7938cda767764b26d8bb909a29d46cb4f21c0c70943f2345fe4a49b044f22f2cce3d7a66afbc356542cd0ab8260333ba93f45b69dcaa9db9e7e4dd3546f8c7b03492b1f649bff0b9938e18820dca85f5dca98e6bcb37074729993c6b5c0125d23654640769d0f0d80173088b65c6f85839be2b08ac0258913f153aed68a5cb2ea885546acce863a46da7306721eef038208153904b497bd4e3273d34845b445f97a33dc816bb9607faeed87efa5b7accccab7165ef06182d841434a1281b7ca28d581782f96cd754b4e13495f9d8ba5714c925d705cb47eb75ba786cd19457a2d35e8e089c0ce2b1266a1599ecfcf8670192ac533115a83c343e16de40cf2055ce0a58fcba6445692b47846c869686c48b4bf0e8ab29d74a9ee009399d422100d2cd003a54aeae3fedced5627242b1ca4e9a7ef0d7b442a8336adaa61df68799078c819e45769b3407922a65619bb2ad8129de0c3cc92bbec0c43c7fbba52f442b34ed383df672346c69443b82a24f89083029a2bec94bd220b21152ff964e7967a1e85f44f59c17fbe7e5b28f85e6a637c82f0bb450e102249872601d8ef6622be3a74f94a34c17d49184fc6b27b607a57c01d1bea823f34174467141186e681b0bc65d82b443ef3cdc6f4fa23e82012ffe6f0372d6b24431da0642e0f639bd98439d8e273b84eb21758b633641bbec39e9553418364b3c5c46255bf61bdd61a763af1520df38c32d5478ae0488ac69e3b814382271df0c79b1a25ed24df60fcf981f68575422d2f072882afaeccd038857085825103a8171e4590fccefba6740156015fd511a6634abcd38ae82b5b4dfbf5e813aeec06e7470d11786875f6ed4ee8aad79f0880809f548dc87737435805ec999b272d42f94a357b51e6de00700a41da209fc9f2ad7fbbcb831c5bf259489d6d0f8f134f80dc6504a95251c75dd762be31073aad5376e437471b701290c8eab0aaae5a3d747b59a8c7740e2e04ccd69f73c1aa2ca9255e4563da4e78cb9eaa78a32650540c207e27a0e5a19869d7646c8e295d9430a99fb6e06304ba69674e3f38fd35a5bf6597a2a287091cc6be0ab490ff61ef5908f1096c7084be56c9c6d1ab38a792e6512847bfc902b659ed048e88bca4fc4db8a479ce1138a7c4fb84f5c05c884f1a8afac0e276eec6b50c0b8b6596f1ec2a07223199b2c836a6517895614273f4133509a2d0d35c8439b7360a9f49b150a4e3fc660d52a4e97b9bfcf536c253ed05c219aa1a3251523fd46ad32a9b55a3023e70ff2848f3b8cd73f02ea1aa8fb460f4acfa4a1106be6c98179f13cd5cddb2d3cf502cc9284b311596cf47190feac05ac0999c9d2ffb2c76e21187ad94b82929890f44475d3c015bd9f3f3aad2a312ee5d801487e2de17eff163602bd1030ac7ff2bdf678cc0498bb9eb0296abee00c463c53a2477b84da527c5d2e574b8b38f1da7d5934983202df33110b359de9e8bf75e90d44847e172787bde7560517d7058ba8bdbc878ee9d9e1ca88c43610bcfc56e370381d3878918c07d67fc8092d15839b9d98926b2001c30225911c9e51e475ccd011b88ba9082701ea208c2474837175672d2361bab56303ae5ea5f06fe71de252b7afa9553387ae070bf5675601f7ee8b2fea42d6dc2d194f4d23fcf95671b6cdff41cbbd85b6985b5218052636a118923b92aca3b9380cf0610f1966e1126ce11b9c8f5b57e11dbae4a737e9679daee39c24c9f727a34bda614f50548dff2a723da89b21224f04db4eb073d95ee97e260f5e81e1ab2f4d0bbcf56e3db558afd642819b6846b6d8ef752c89554178252d03281f857c4a07f7295d45f15e7f18fa11f77af35785b8a21aee60210ec2e9019bb863ebbe5793d1347b3b699ad7d1c3326c0dcb8feee6300d22b7ba07536bda985e66301686c2c59173897fc414dfc2f75220dedfed64efb3c5adc85999c6f820d29b9c13f47c81ab92c13838b2aa434ae84ae35dc1070ad6cc8629070bf5a9f482ed7822ff3a9a052a9632b067b7d16aa618b117c136d68d51f41cea0eff75b468cb310511fbdf9f5a21a0ae7334fe897f9a196fc6b618ba1bd9f0cfa78bdfaf3e805f4cef665e3ed5770636a3827260b81216f543d40465281de455e7971da37f7d653261ec3f819ebea8101983912b0e57e88d1f0ace8776d5c8285d0c3e3b7498c3c8edfc966eade9b78ecd691d9766ea3fc50eed5c3e9bf3bb3770f9746ad03bf94f94c6876788403b0307af7c50ab99bba1dd4855ad611afa9587e031f9361c6f7637ae858bdf5915726637be8a9d4e8bc94af6df21d2710efbdfc282e3de23f2570cd0c07b47b95987b9b8514fb9d2fc6ab2cbfa1228d0603d59884d79d0f1a2293f7c50d051c6bed03ede54733f3e3292c9ea358b704848945f2fd9fc2d724d269eb8b17dc865b301d168d175163e7df7cb2a711f42e8c10f36cf3de8e7b94e1da05854d7580f1c79a7179d786b2396a85b1d3f0a424b3fb70d6f4972dc0d20695cf8933ca894661bd4b1cca8046dddfa945d7de7396e2b20cdfdbf2d32c37b0864a9a0d8ed82b0e7ee3a8bb19434e732282c276b54b1e57f0327c1d858e26d15b70496bf49a28ba16544e341dca45499fbc337c294017ceaffc8c1a02252dff25428a80a706111ba5cb7a6d9c440d2ec0534ba4eeb4e592e7748769234ae750b11e8f343f770fa9c692dc560ca6c2f73c5a897d3b0a984098413326e121da4830d9081e92f6e96df51f47e6315b0df86ab02788b202e9a645b223d0678bab8cc60464a404b6b2e6b063b11859d495e3b69e2083019c1b4d7f7c3ca92ee523b572c040cd328fd4d43057304dacabb6b155db4e6241aa46217d4de087fadd0c1254f9f4c996bdac2a1e5cfdfa79310e981bf524c4343fb305099ed6368bf4594cf061945f6c0a3583044d9221094067f8f59c93837fff93ae1a40a7f1e8bdd578b7e5b10b373ed5bee80f473e73f6756acf672a7e8115cabb069c12d24eace4300da49cf198c7d9031e3ac3e95ac97b6313f2d58cc01fb9148495ae4dacb64d33c6534c17c0ab80afa966846368855524ac0fedb0cd27bad1cfcfe10a787da2bd878e5b5c147191e6f0ca14ec38f6fdf35152681f15dc35d6606755b4d86314e4b12f7b471d1a1a7e07481ca711fd0d49cc925caec2f9f764a386970a04390c8dd5aa53b1fc281be4dfc92e832c7010912b196368ecae866e559fc0e051e7cfc132550e7a78235812879b7056d94788183d17e8cbded16ae6137ea12b4b717dff711c3b0a20f4535eff3e8ddfdaf3eab3e3dccccff6ef4d0e0d3a524345617f2ed07a6d9aed26eee3cb12e8c6e082d20cba6580e078021c93bc46bb4515dc51c3b6fde07c1582f9a43a1ba7f986800ec6fd1a0ad5d095495839ffec1277ffa4f328302f1430217d14d536faae551a1d2270307c3d035f2e23eff60ff054a7f88d312ab87ddef6ad4b4350cdd533ab07b5ad1af69f60d2355afc70a01d601bc29da47509e14e7e14f5181f7071166a586728875826f2e8111b3ac8900a043889d6868866494a580092ba43fb1ddfe71d3f4474a3b4f5aa0670369457a5a50a8865b9e60cb8df0413ec4ebc042da060718806e06a2ce5a992ec1c9774a793a5ce657dc1a560062b56d2ff2bd5f6fc89af21abd7873c37b6cc673b88bcfccb083ad62abe06b11677cd7d1362e176843a12726ecdb753a85d7fdf7520ea4d2559b274675e145bf5087966295c43935fb3ec0bb3ff1a6089be1ffe1946c09bc7caba4fbd043f6657b9ab0fb4c7b6c472862ba6e808b360dbb2fd4c45596ab0a33ab019de9c25608e61155377aafb399c4e6abbdfebf57a5cb9c4ded588976ee9e4edb455d41741a802e77c8bab7e3d1d9d75c7f6bfde40112c84f8227efc16cdef8637286faaeb32508e004200e7fd1a3bdcc0c8ebc23cbaf7fcbb44b000e09a061aeab7883d8a1dc306bc8bb3569a1792e434c946511a0a7f38620508353395212da4e3e663b84315fe83a0376880e37b00abb91d2e9e329b2d63540840083ee9ac244a403e719470c66722edc635bc68b8755af17756abef2f96d8c9bedc29950a6e5bb8dd8b38f2573cd98291613702323620e0a321263b15ecb66c6d99937d4446786b992470f1f78434ab281a4246c928eb4678c799f58f2896f6b738b7273549454ab3bf7efd8f1690acbc118bf44db470f1a20b119a07a8e002f282d357f6052f8783fd30a498ed702f13faa92aa8f04794153bec1642910335cfab34c91522a8a188e5c14961462bd4a8c50466c16fc3c305b3abf7da224e10fa2f5b105ef80bf71354ec49da39281eadfbb84388bf9de83366a29de1245c033fa1bfe867ac6654251536c9e3b484dcef722132fd43f3a7f666bff733df912d7e359f5cee4347220559a6281499d8411f6ab8570d5728b6245f192decb6896a1ad57ee9d44a9709981ee3b4cc678a134cabb57e245e2eaae6724265e5798d9851039167de09a86e635622570e0572a5389a33a462c9143da6766233c6f1275b0455e9bfb015ff4938b223dbbcd850ffdca7574d367e95624b3d544aa3c370fa339048cd810456948d2317f5c226569a9f6580f92cbda1eb19706005b1dcceeb66806d927d5a1a289a50fe2c5187b1562b8ca1479a1bd4eda92c58ed5b7546e0efb164fbb3073f2cee0a0a0c604437acd88e6e963d57e51d82ce25df7c8481958a28869629b1f3d8400094088c7a71afec40d79a95812cb388821f304b1a27dba51feb8444a42a477cf5ba004d43817fa07820869d320bc34351b3dc3b02c950fe2e88788bfaf79863684deb61a77d948fbff5ac55b0ef4d3f385ddc110c03fbb8991333840f9fd91a800bb261e99e9eed1f366d3a287f6056641f7da4082fbcc59d3b59a8b38d3083ceffd3d31aa2c8ee70d431ffb55f99052b43a1c6cabd36c1f6d997729889804aea5d9109e009fd222a980092a563b968d5d94787c982b614fa2cfbf47e2f594626573047858c6d90a2140e7e79b76192af90cc89b4f0e1113d16f8cc77b19b10e8959f4bd5290aee2f2178f60e52f0d68e4cdec4b4a1556b9eb1d554cf1c414a3f615a2cbae5a7d31e62d974bc024faa5d7138515245b0227e8dce409fd7c2fa7e15d641516876b407f3e473867d77c2615d7eed684490619d983f6c0c28538f514654ba8a5aae239e4874ee9bd2d766498cee70318beca9c9e3aa7035567813254b15fcac65c4ec474309bf9566d10e5d185842ae3a38d8a64bcb8dfd7b3574c6a7f0f706c77cc457f51097c005f0e8080de77fbcc1ef71ecfe9a466322a8f7cf15a2db617e39fbc8ac605ce0835ef63b766140a57b4323dcde7d0f0fa282f6b73a2c38915290d6840be727da2f8f2f16682c96a15ad97041c52a7b4088fb333be7673064ce2bcf0185d9ca5104501d197df50c94f34759acf2a2052ac8d514a37792f2bf2ea88e2d3aea2dcee402ea95f8a691aab94eb4c133600167d69117161be1b536bee72f94e9865f3a827dfb6802e1366c3c638d2042434387e060b8b2b591bcefbb61d4bdf869460ea12322faac08f2392e829e9f02ed976736920ed6b5282fcc024f36e655fb24890cb050f7bef18cab0cd42e529e514bca41f5552854026805ac8edf951674bef4fad39bc9c1e05d3609caf3903b71afa40b2e41ed25a367355b234e809327a28a968dbb70eb3267083e56f90b6482d45c3d5a6bd9d36b6ebe80dd53c0f76dfad190a8aad6ddb46c164651190628407cb245d84eebfa96432168fca4eb7c3e98c402fa80f21a617e295a3c9d3c91b9004f83c4519b7ae2297cac48ed3594dd86eb6f2e1115f751a0b16ad81220156b467683968d150540129febaf4ea014caa3ee90273a989bab43522887600b7b9644d2476cb37e837c8d79a2578d5bf0c3f880898da01802e40094d1d7aa00d45793a996ca532cdf74ef95a5d58cc3915fae77ae40ebc77b220a243f4974cd6a108eb481e3d49458456793d86e48869d49bbf388bf9becb05e374369aaf79edff528b2effbcf3d40a429255d409e3bbb3c681686055175070c742bd3a84793c8ffd2a0f3aa93e389a8c99f2bdc019ade4fe010498a37f4bb389cdf3f291d18071922ad1d8ee350555fba4af8642d1c6ae41bda88e5ea0ac3bf339ee90e3197da4925dcf041b3ace80ee28549ae8598e1d8ee88d7b2083fb69ab026aa00192b3944cbb9eee2f2f8f07820618fe20f2e892ea39ad9b46d8194b9f6504d20695505b192b46027312c45050a9f030800062763f1d2523ac96f76f5ae0c99656ea1ad22ee8c28865f973f4229dc231213f3961dd2c2cb4d624143756c7bf71c6dfa5d0f56ae7124c8108e9323be349260bfc48fc1553bea4da55e76439021b6000798d8c0ff493060c3911aa3c69bb28b4b65861c1400a5f7f3b86f5177716881348109238fecf6397cd7933bb6719bb8d79d5a7e33f3e4d5d4cc5568519144843fc42fc54d2480c93448008c5b85ccbef1148f64e3e82c90aa3b927ac4e1e68d6a46cee56eacdfeaae2635116faa316f8be383fd6a4ce41ea816a9efb643767a8c45cdb7e40f3a6092c1b7df7cfbb7c744c183268750e32031262dbb65b5e101e677370996321eb1796124b7066bd0ac35c9952de64ed8fcd65ea7a5f7bf8ccdeae425a925123d27eff13ab4da45a3d2e4e1d809c304a502fafcba8550a25539bf99b1c7c54543486151ba79e1272a99d07061aaa64e7f2532c36e7d13772685dff97324640f9988465185f5ce17410752bb1fb6b4ee9aea5c831560415b28e2bd53dafccf757e88526e5e41e3ccf63bb2daa2c51f9addc50b4fed4e4108d9a01ddaef0c14cb4725363e5fd55073c7e71e2993c5bb7ad6b81ea1bcc52c56645620189f9a50716fcc439b72617ca1d376ddc40b5806a3515d445a0b9c5d47cfd824a33ee6ee694754c8ae88ad7098c62c19024bf02c17216f5f5f1627178f109f09369af41c88e12e4c20b863f9f2540208a23e8d61c98595f9dd653e3924cb796676ba446e36c938d9b7d012b12799f62fdc071fba2bfed0ae27c36bad67abbe683edfafdff5dc28f20974a04c307b3817fef0888e720e1e54d87cd3a185c9f8684eaf7a47ba5f6718ab514875b7d07d6ceaa359e70a059b3c689764176701536177a5416187f1aff5065599c178212d7c045e966168ffcc03905607931bf0b2ef51e28466b52df7fb58d17f49b20dc60597a66154851f1438e82eece65a342f832a26c75fa7a3f852c8ec519370e28d62fd04935d31244151f0bd1d74d71808cc9740e55af58fdb9c4947f1b6e858ceeea33678573f4d275a37ebf3e9dfc4d29b31bcac8e3f294fe52a6419ed50f2403f498f3e202be5c33bbd745198dcc9bdcefeaf5eac49c2482ee4b2902b6823efe4ee3f1f7ca61860da39e9c3057090b9ae5d369a9c0847381c90f311104424ce3bb5f962600c835b2097acbf880b8aaefcb871bf39baa3c7289f726503625c0ad9f4f0e50db26d89c195405a8fae78934578e95748546504c22bfb9e71c6f61a814bce401f05dbe718551be9dad6705e12934357f674e7a86df8b5d761cea77c5b2419364ea0acf07db6931400e13379737c688aaa49d9f9d8bb6470b01ebeaed2d0433265da85386109eba905a3e66bc380612c442ba280c3bc86a0e5d0b3c81ffe3741515094b3a4a29c6f28b6d07b83da1d10128582d6ba71e5be47495fdafc2385aff0b78329b45b57693e157bf2a5db05c96d6ccfa51a40a3f6b7c31141b067866a6f37a813d45befdc550e5102b0ce1ffb36f22adfba7e57473fae02fd0b5c829695953d041b51423ce893bb67e96d28b44b5221cd4fb10a20212ff1118300e42f35c8841c53ad8a010ea219f3a9365ffe75eb0b683196ac7905773331b8625ade8298b09caa2aa5a4ceed1cac2639c003a3e30e78d8c3909d133b0ed1f81adb45e0278f3a7d44f07d3ec6b9074f4c6b1698dfa353308a047160fb519c1cf36252f0bc8970ba0a4155c73254e7007ec970fd4a9325ec39395ab53a2abb5fc2dcf23e8b9862dc8fec0055e3758ca2ea7761cc63c58de3fb99cee76eb2fcf5ef8db5aea3676146f0ddc1fbe8fa0c9872374bc1d5e9d1bdc6620910d392d45878c4857f807366506a62c88e970e1a538ea423d790041d7773e77cf1c4106a06ef79e0cdfcefdbe4f69d7046a90eebe113333675035391f212818b88e0cfe59eee840491b23f0c2845921aac01c6c819c2f46ad6941a8f38c12d8aed9fa1a44b15f28cfae0d69c23b0880c6d982f7783a04140c8f990f889f58690cb2e2b35205458b4fe850ee3b55e366b1bb74e1c9fef071b3eba46aaca6d6bb955d437eb6fa9f6302394a9b13c6a4b69d7da99c1c771570d279e624bda78fdac7e91be737185d6c716d8f8d40ff3372a4354da87def6871647c91cfbaea636324b87f72fa25cc7df34b6960fcfbd63a400d45c5133fa6e24ae39e33c66d4d6a2c509c5da2f01311d2c8cc9354262afbdd118f3f652e290464b3ab3fa4b96806b54816553001c05dbee7f89e804c55efa53ac27cb7e50d804cbd7c36f9791f700799a43632adcd1a890a4a69265ce88ef6e2da09385b9a030dfcfd9f07887bdba7412f80eafefeaf5c8aac9c697982f18bac5f033586503c29adf36c0a47c53da07fc107f7ae6861cf8c7bcdf6d7568e9c82bf2f95845c6049fac00b155b4736395be814333a231839446614301ebe3781b10b77dedc8eaec7448c4b93803985ad96b16c7a5cbfe1b23033c8a77e741113c614f91c4422f23fb6d608a9d62c3fbb3b82338ebaaad80af88c1732fa85a9d25940d3c42d0c73368c56c19e1732070f492b359cfbaaacfdbd022c7df86331bf0834542255990b09aa0865aa6eb623297f05714665ab14515a7949f54be5c4e5e0f8cd1ad7820570368dea22607d20cf826d5005d133c4cee8479d158f0d65a3992bb8ff5a056cdf0991af3d26c7b38cfda0d6bd5c80293ff8db7828cfc47739a28f28dc753163c0366e4c1b7488d37c2718dcda2c03f010f8ebbbefaafc8308edbd7b9092fb9a5c5cbadc4cfa219b3fdc684c81418fc895faf94103bdc57f70e5c17ecdfab4d73069d32bec5bb012c8bfbe67bfad3c5afc2b38cbe794db6e687db41728bffdbdd193e3ec8447213d7fd9bf16056cf3f9170e1ceaf9843268d70dc57a2d0f83586fc379adca07e610840f448f992baaf1629a8358953b365c6cc2707b05ac7075422b438bceee8b77b3daf1679fa11583211122a010de67fcbed57fbd64a410191375509d41feab6a0ac1d04540dac35b80b0d87f5b9d7c201e8410e3d6f1904eb41d51a98384c6849329ac2b035897d9dad1a2a1d2f554ba769b8d15e341155218fb46ec44d9c0e55224b8d9c3ef6c565aac20be3b45ab082674dbb838a9d6e39241a2a7d38641d0190fa2a826517101cb6b520ca342b2ae2f41b78aa5edf7ce50343d126fa0a45e811e808927343296ba740b4d56e487b71fdef7ef5be7d486367a2fc7f6f149c2703cf77dd769b89f52c6c436f96d4a72bb6a5dea82eca4d3dab79d5b8c4255382417f511e3f8f0c72a8c398c82c2a4191fbd45269435453364bf935e84512e61fd2a3dbc45597e2f07b0fe61ed5f9ca46b3367c38e39a60ed970d5229d192f7d82a9ac221725f2ec4c31baeab1356bd13c184d463e4af03efcbbaada3f2db0c537e2512cd6e2c5aa0d57f1a582c240d8dad318ad36dc8eff52d79077875e573f6d680869da2d392d4118d86d9ee201c20283a94b86565a215e6f0e8c44583ee8aac2d0e09401b86054aa2b4228bb52c8d7a23c679a46f0714f39c362a0f6012c5b096967555371425993a7c617154cded248fc64204de8e6ed8e5f198e111e7f81485618faae1a680574800d90dcb9fcff1bbdf6ee6b4618c831f4e8a863165f1a04f0d4358067081862b9966e307420cec8dc570c686b5735377a6e9f603cec56e1634b5f3f727fb1a44414e1a058e905e28dface2d40e3f6f5b4fc74b6f69949cecdc37a590afe146d56f02ae8640f9304550e14324497dcb8eee617d77f908e98ee55ee362ea4e24d432e3878f07a993b4e5e5895a5c54fa88108286d5949b1d82b93d5ef443f38ebb961075c16e4e859781d248904cb24099baa4d82ed81ad27871fedae281fc8146d7e523d1e5c9163fd8f38af0704314d66be5e1462b102b7f0284e68ca4b16804118848dc57e9a79670becf8f156a8635fcb49cdffbb8b798d7df65d032935b018ea13d49f4e1e69df5567302b39af341d4b3d86b078259ebba8c2a78fabf1541ae04ecaf8d929445ae96368eb11d269182714de387316ec3d4b4b42a18a606d80904d1c287d60030cc5347be185aeb3a4c17a6f3a375b027de96712dc9d19a1fdb03a5d84bb01fafc1b97ad8a82172d7b74565340073619983e0017d68dbfae0e512d3f9f2f91f69cb47ca66cfc53515434c1dd68d5e864e69b7cb77f8cbaf44e74b67db23020d62436509de39e08e372276c6f8c5984a1ef7b0b01c6a17b2ba6ef6bbedd2e86735896af1cc67cc1d3ec04fcfdee7bc3bb72813a170c2bf0ba9907401da13f5599b20aeb48c9f2b7720cfb80cfb9e23fd0bb111ede6a498ecfdac3da2b48950adedf3ec8ee80a46a646484e901218de5c9a0b7a6c555a705b69eeba21920e4dff53c3c6e12882420bb572d25666807b8ec54a13406df3fad4d1f8b92c968e031938417efc8bf8b3edfa9060961ed2324cf1231cd2af63341e0f1ea9c07b9cb778a100e59165cbce866f5f6d646054d56c95438eb3f7f8993eda9082c66f72b1b0fe3b3b572653dcde90f406b8c80105187709ea7b9e9f5088be7e89ce3aca0f99ecddadc2e50badfa29129519b39370bc0c79be1861ee9a93ff61aecf1a4eaa2cb9e44d654e4c906cc9ca3f3c23d7e20eddfda655260af41f8ee2d3640cbf8f385f31a40bdfd5a09bc7902c0ec519639284509055a6eba13bdce9ee76db2ce224df3477abc6c50f7bef5eaad982ab457417ee2d44ced2fe035ea5710e0fab2a1b900a651c9fef262d6f4374e2c7efbc01f8bb245591977eeea59453f1cf40ff5cf531692aba3118b1124f4960b252678c9457c4521630539228b70313843a6e34e0d0d6ff541ffa2a1d40081eb1529105ae489b62a13f8da1f0e89236fd7668b86a590df3e6a699cf47e206b31cf1b91b3b2e581cad4e639c2f8687c48f0a38811f3a0e0b7971cd37ee9314f5548ba93c8c58b3b4f4106f3218c2ed118ec2368bde7ce068abaf3535ccd2023d54807d8417cd012005c2b29e6776bcf79c01157857f6db5f6f3273d52d4169a39b2aa0f5ffae17b6c9161a655d45f979ceaa870fdf9deaef473d1107bcc3fc4046dfcaf1cd95ac8c1db0de7ffd3664bfe4036f60972a829201bb38cf64eff08670b0045187775ec1d3c47971a39efe0bf1e75975c16f779c88a105d04d477832e09311ca77391e08285c51f72e3d8c41a07244059a397ebc41623629ff524ba89bd2f5c29ad385dea9ca873c98d65393eb2de4131a2be3f00a7cecb1eb50da379f22a523df51cabd9b96f352591f2fcd205627e183f5608c15cc9e16cf5a69a8dff1dadf48d3a75925b6b3ecb16745394070f28cc60561ec483074d7bd540bac1186cc9a4ee4f5d925d56573f640b52acc4108eefdd5f3d33fa609fe19d19fda10bdd6263ca04e16212bb200c3fb6ce2f570f0e9955295db89f621c258cd24d6ca941265ff648b6435b9df5a0733ff4533c2183fd282e875624c5f583e6fe582c7418e8119133bcccea7276d77f0aef239ea71ae39d531c3c3e9a146ae7b7c2e831033b8c771131af9c9faffa1af4d0e92483f17a5c2794efa1706d34926e77d7419aae28e6e92bf493e0ed7234c25516b819e562032e778f71d683e331043e5bc197eb8081011b0a6afd058cef783a6e21ae148048647cebd91c67253a078705ff517552d8581ca39a16ac000e96ad4fab5a4c7b54deff7f7065137d9a730f44fa7ad18268d0fa7cf340b0b2b5938f1383ada9e894cd4349d0f1f152022705c37eea716c9a1ed9ac9b9baa2c9d817beb54613f0e8cfd426bdd60a041d6c62e92174feae4376cd78f32b2ae36876adb22f8d86b14cba16072df3e7ac53f6fbc4a72c6b9735593ec91d2cdebf82771d3f5950c9f4fcb03c4f458dde2e4c59ce81cd6cb51fe237f5fb485ff166603dbe8db4442505f87d3e50ceb4ada56110ec3b028682320c7b4ec6c7be2d1faf68bc61f3c843019f7f275a2f1b57eb721af5788c712f6ebe19385f3b6a913181bfbb884aa215ecfea09b451016a0cfe2260d4cea669fd696404ca5ecbe4f9080bbcaa3462c07455eb532beb84b4392d0de83e1e04ba1adb18cb367fa806b854a9b103cd96ff97bea85eaa7acc45fb6196b2dfeebc0111f426e308a941a2a8edffcc3d0e9a75742a0f3239d3acdb07ec4956184ae81ff1566efdb4952f5b1c40b3a49411a9024779b599a836fb3fa70205137b299d53a673118236a0de581d529b7c037e247b39233fb14920e553332f38db3149b0cace2cdd0dce705f3d68042cbe3726a4b50c8b1d19da870925fd817ac30f47022913995e0d47c0eba23fc18aabac1ea570383c2411b3059829c50fae34e63d4953862adf24945434bdf5bbd628c5775b5973eeb089127890517b6f6a939daa5e3d11b397626aea660c4517ef4cb8b8c4e2c9c47f61b840ad4081aae02ceee03cc944d79baf72c0fe62216a8cbac0d0acd626f2ce9d4bd03c83f51e6bcf738c54023c3cc22a42f144551e7f0438c46ad4547eb36ab733a478dc1cc7e767a33e634003552b295ef11b0ee4b9bf10b2fa68702e484f956fc75b9433c2416944a2dcb4fa0a1a5dd3d294b7b48c100a45b908c3af622fe0f722d28a3bf3ae4376b0b79bc8177848a4aeb333efc6813723e089e1e4866cd59fe0d97bc4590b36f6a102e4893f08218f4b4305125435ecd2616d30328745771d18d25aeecea954ba75138fabe7fb92a66d69d007fc0b1957fb81694378ec777da5cec7bc86d932a01db8670150b56a31a3fce06653c6e062ad9de5fcef053165ea6a1a77c13983aea3f249b1535b5c556fb918b9a56ab7373f0d9c6cb99a758300faecf0ef0a0b0ce62c2b4843f7354d83b4a4c15b231889b7977a6b80b4e8866f8ae17538c8c6fb64540eaa40bf94fe37dea9fd6333b7bd3fab9c019754ac44698e6815334535291736e93517223a5379ab55f254511ba88096c0335b232faa89ac5f86846dc1e92e22cefd796ea8fd049cd9451782ad499b070f413ba9417c4b49113d067113e347e84e69a720f47895277c813e2f996ec20e1506b4dcf9a97cb0db2d12f2b574755fb2c8c571adbfc7ae8086f7838c33f62b5d03f26214db03259126e4962c30ed0d54a53f09e645285ddcdac4b74f107b46222ee30ac610cae7f5928fc21edef30fda55357762c41312bd614589b0a6517a899e56d10bc8e142e913c990fe5dd94c8517280302515c10f9d85567efbb8d7fefc28ca3420bc72628667bb65d48dbeecf1d7e5e46d0d3d3dc7204d4dc2e9dfc5f741e4d890e269b1878810a9e08b7bc0ac4f4cc0d64468ef971784d4a10f5274cb3845dcad2bd6af2893c688e85a59c9bb3de23fb4c9cc0a0b99e2832fb54a9e421a245590401c76425faf67fae10a74c53c5423fb331cfd9ceece2327923fb7d709e4cefa445397af657ae3b30c0144f045957a0735286bf91511e4c22e9450d01dbd0fe766eeb2f0f9c276bacd496b70fbe41e559cb28b96a91f34aca7eba0b25189ede807c9ca4fdf5814b8bfbc4ea1fa8deae217579b968bd8b25f02b00fab63171bba45e1d648d4a4ed76d0f2dafa6a5817a4fc75de27a3bb401d614f4fae3c38ced9bd9c40bcbb2cd2d4eda17cf4766f3959a63ee5f084a8b0e14d55d18efcfc59cf5997e83d55387927b33dba4316c796a2875720b1fd6e0393051625060afb1babf817781b4aef9209575d7417fe1251848b1ff185f84692217b1cc15ee120ef6cd11413e910d1547db870f7ecb03ec378b8cd8c531cf94bf91a6faca7a582b5b0b520b9fd49635fe33f984042061cf824ecd71924cbacd2783cef7008b9274474e02d713f4342ca94ab2932969a81a956e90b64fb7decefe9b7b5132fc2c64b38f89ad077c84f6042aa18be50dd14a9b06ee67b2aff4d281c651353a5ee6dfbf25855efa8f7f3adc1364d3bfa1e96530400a2b911c171af4b988628dd18a61c5d97a828b21da698f1b15d1e628bb417e9ba61c9c05a09b11bee2588cd6c2242fc167610057120469cbc92aaa1ff5f8d44dd200f5de9010af920ccb7eb7bcb0df38e1624a4f38c1f93cb25d01c4417b825dc693341d726344004c0e4b3272fbe011afc3d660647c2533a80056919b6ba1d99f2d94628ce99af0e8b56d22401db95afea9020a4f74fbf81b3b99313dfd1341da21ef8c8050d7cee3e4859d3d3e13aa924f448b7dc9fe3b5a43573cc3f9b5c241dbf110395e8fe2a5e6e265b0b88c0475a0cb549f28f98d3e61036649dc0aae42f0564021efd700a2969f83c65afefc621c6e51e3502cc599d6fda3d2c61b4bb69e5cf0af8e40640860250292b6032de3320725e16808b1339d6dc43e786b4d780c68318b8229e65c70563ebb133356c7b147f3ffffd90201d80f26b8eb8dbbae2577b03dca5e33a91c1c99a2433592ba3729694b45ffc1597f912cbe1ef69c78eda0823ffbd76817a80d52daa2407c55e2cb8bfbea5b41b6894cc5347ca9c8798332ddd6555b94b1c8bb2f6a26d2f953d7519c84327723dbf42f04a3a0865dd07f8e29e25cdd60e6cb8b720bd5f3a5cf1f39d94439bcc98215706c4c7f452009cebc3b00601967c4f97e34ad36732bff36bf5d5f2c4d79662b32d6bad5ac5c2c0e5d91d4640547f3d36a59f01742e755c870d312a086cf8d74ad7199ab671a6536ef7c0ff4c864eda0d808da5699d16121f41f64cc69c5003483e4a682633e7aeee9b840abfaaed6741c9cd3a045bd1c41e3df5e8a6f562101c9f7c693bb548ca96668e5eaaef1c19103401ec623e43f987886a4a7c00fc9c4090b2047715e286b5ac80b262cfbf8549d2489bf3403310eba29d065c1e3235aaaa4841d29332123419f73571b4bdb4b154870a45431e4de416ac82db876cd6df2e44a3aab96b086b147a370fa3311565977dd6a6feaee2bd97e7c489c6c8d680f611a2c3a8316bb02cecaeceedb02ace43b813c899908a7543ba822ca7f60aa81a681850fd08f3fcb8d60e8299c81e7efa7725d489bc6f54713f2be451826bd06802ea80efe7a2f4b2aa206df788958138e8b74621639daa0ed5dff984187c36d4f04ff285b2f21f34671da22cb479188973c2134ee6cc6983413092a09512021d94898c4a67927480e9302776ff6da2b615c059c45828e6fa21bb4f2b2ea0d354a8ba2fa715fd1d70efe77540fb2dbb9360b095ee294d1f2e250b82f6e321af2c6979805e30960154a26dc33a161a27e1696b35b60b3eae02726dde4ba2bd6534121132ccfa906443cffc9300dc9733b7bb8fb5ffbdaa6e9cc34e87665750de9c1c4b933857632ab894c4896a2e03cf05651fa1c28a605095d854327dbf7aa686870b39f3a6c72aadb0f66bdcf38e0b74cb19fff783f89da61f597dbae2176933fb268842cfadcf817e58ae2aacabdc2c1b3f0c8b3d0425c26feac01e1a834c727c786ee3c6b34a87a425167534bbdc236f6c0fa496adc28788f68283dbfa5bc61c541dcb344145af12cb113e1f9f17c157e669d3939745121213aa3262585135385edae926c88b223b26464bcae9333945a56175c684dcc4e11cfa3a71a648a6c886a69016fc43c092613c654b08cd54b2302ac8a96a50710f23bc811acdb93c0d7a9acb648a72ee74e8ea5b7b29ad8b10bb8b66241cb5482bb7c0979a73a623211306fe6a263c71f1934d459dbe06f5c89996ad21a8e8123d22811084ded4d08bed549c2e0f98f489d2c2cdff5465efc71c0c9375f9cb67523681f3b9d9f7ec81451062516edc37506ef4b66d24b96bf7f14a3b310393ac6c1ebb393ba8291dff530e2cc3ecc30cea0f1b8f757cef73cffd9fa1e9594e766a554e2e93b7d915f14cd3f7812f2b7b413a6e43686e4fa97ab769afc0be9d889e4b056ae1cd2e1f50b0726650f696cbb7ab5efffaa66eb1f1525098c8e9c4cb08728191d957dfc305e94bb6b90ff5b4b779fdbbfb8de8c378335efa76a84933c2bae346cffd71cf7fd28c8cdc8a2e917ec1b293b85faddaddd57a1fcf61316904fb342b4e83ed7b34cd366f770d96e854226b9e62cc1cfc029a5de00b01e6043dfd35209db0b604bf2b2fb767b40e90840f6fb487de254967bdcca89ba5e9a96b3d396a1d0867231f40e96b35db8e0bda67caa283a0c5e95c85382863a72b4f59d07e3f212ebb62526d52875527bac93e14ea18079609f8d1de8340b2cba36315e14fb21eba9470abf71cdf4c4038b1d2e5a8b26f42aefbba737223d272864f2d8136dd575beb33b04c59a975444db36e112e40205896cf3c0e6f599806c64332502348b7fd35ebe064928426b00aa76082dfc1fab422f612b796f90867c4235a4f30bb6e0d7560236a1b82d79d96037cdd23e16887b5561eac8a57153be4695971aa7ac9a93fdf3a3c8df6b06256799f06e4a45b3360ac0517587dd4c82f38ba91f00fd052a5a62872c677aace52780db7247b2b7c9bfa71bd9f2cb68b2b113e21c74c7053802cea6627bbdc82056db4d57d58a9a7634ac5d90cc7a7ea7f46d1d036b7e4a10e3711d40f14216d051c6975386109b7cee0680fc2e689a24c7890fb6f1959a70393f8ae33bbaa8bcd20bfae4dff86ede285065e1b26a0a8b25d3ff010781453f1a35417f1e4d081b1abe0e05ac6013616e19b2f09f163ac39d4be488153ab139a072b8d087dc347b7706dded855aff8d8c0466b2eaa7c79c1fdd698e82e85445bcfe8f996f66306216cd8daa52bb6f52fef4053c5c2f7d2f004f9be4f091523a4859f8d1de99d01dff7cbb00bb3b70de4b41b9bc58acb8876cd086464fff73870323450156c17264920442383809dbd25a003a894c7aa3ba348a7a91d5be3b08509e273e7d96e486a4a4447bf560deba37651ca355c10b0a0154cc63b9788ab38eb1e8a02f3aa400afced3a41f39c7b0621fbc163b72e908d201f915726a1760c5437ba7d7236df55077ba70e6315a549e4d0904bcf9f3e34eb808bf4852ebea4e9a9266fdc188682fdd92cdd7009d3034dd34306a454a15d75c9a3a40f562b32b8b5869fad7d64089dffc2af4c4440fd0b9baaf5e485e2b82530e78337b43200718efa4068f5f73bf98fa611ef40f2dcf9255a08ea7986da17b9865027ff56dac55f40f46403372c4c29d4d80ab34ae0088efb97362b335a765503cb41d6a06a7b251058aad2006d8264b69219d945ffa8d29245c753ea924aad53d070c990670d9aa98b4aa26f2c1d7d49dea4bb44d76f5c872fdcdfcd66c926a799ade1ae9f6fb93d2080f9202c84175468a46dad1f7cbd6f7bfdcbece340b4f08235ed11c92f810e6f8b16fd37a3ea9fd555647098664eb0d869e60bb2f00140646a96750befb54aedf2da2a4fe13d66491d9294f8cdf024ed8995c88eec1ac213df64b2eb61b8b2040f59d46dd39926ed074f619d695550b44be5c06349c86bff8807b6d406159085f31da972882e88c007b503f8dd3f79143881498d42ba7ad67a34dec3ab643c5c0c6a0b4b59897cb433e2992226e7b4ad46fca89ff349b2b0fb189dc067a63081b57ef9e2ff9969c0bcb685372a3d7c48e39096b3361fc70c941f1769ff4fe2c091be09dd6a76d0a978b304cd60141ebc2d9afd5133b2a6c749b445f46a26d86bfc235c884f72f57ddd4ee08a67b8ceb5a90835c54bd2ad59b51b004fbb35d82ba8a3a93ca55f563c26abffdbc935112c0fcde342294b6042448d71dd89ad4b1a487e8e6119381e482f3f8c07fa1b20a2164dad79334fb76f0f6564e29f651eaa60d1b079d470448a3b80e85b24cb7dac1f92043e83e8e4f94a45ba3cff66a44e04c55ada2a2132db59a60f0d5f2e5c0f6ebe4692a1162f41563508ef11c586c076512b9c13bb266163b4c722bc1f7d8fd2eb6acdf7a8f5688a3431fdec71a326e832238f4eb97795388e0af8fa8cef1cf39a0b0919452a5a7fbaa8460d3d6b131394c6d9bff8db432dfbbfd7faae56e940f20fb151ef0c9a2a5491b12b7d3f463d97cc2420f7701d948c6635496586e1fe161a7196edac1d868da7abdb874986ced2b9deb87d9061d074d00af22c1a92c3e19e8700cc716eccd9637c79141e1fd38554d5a7cafca4ab3cc99a905c7ab778838e09d364dd51ffe2be932d0e5ef29316ccae654f88ebd80b6380738524e543c021515fb6af26b996e3c23403ff18bea70e096b7e4028767a1a27ede745647aa59884d741d0276593b833684fdad9a674701ac6682b0dfb132d9ed21c0855b602d1cb571c06bb55d95c31ba9a931b5d3058bfdb6963391983c54d785b95b06e7dd24c05ce7298740348896c79670cc268680be02dcb35db70d2f16a39916931a81928ca62b7b605b6ae140b8cc9534d3df55f01a1ac40e7585f3efeac551f7516a221893c6e3cc81af6dd850fda93eaa93cf0c469a4b2c701a7df2b372ff9d744a61e82c100a20b101b19e20f3e79d1e3a370dc04322b6a9e8cd6c1ac2b94e10a5f36c119609bddfbdc49d6e271a903ae12031ed3237183a2f34fa0416650f46698388a117a4dd99dca424b79802dcda8fec30c21db72ef61958167e8f1373b222f09787bf1f1963f51a31734acdb60d814cdc6f792f9caad75e3ae90c90ddc28a24073ae6b1aec4fb01a87c9b23314c23252439e47d93ca599ddc5df592ffe0559d6762617e1c1b51411b48b87b6e399afbd97396bc87a44979bcf121cc853047cc9cd118491ca82e7e7fe59bc787bc5640b03d8af1ab8ac7849ea9cd5e2cbb9a1f960508c675f3750f2af261ac43f9d692cbb1513f48ab1ec5844504e5c68bd31b743d0b36fb8b1a6d8564c1b042168e180dbc31337d2f46ed4941fb9e59843d5e3d834954dc22dd4eb76a6d5e7502be1ccdab24aea1c9a2cfdd930380711eade0cd11f343d54a75512478e461657753762cb864482738e95b1d6931f6de63c44b1a839e1b41551ea3094043e44d5a52fce11d664d711becbe29a5b9fcf2f25175e52f7fa6037e70a456c7946cabcdda929a52501f6ea4e51b490f7685e672ea66a83a5a2917d14c4bc2c71538fe10c717a275434bafa1ce2ab42274fcd43d81f526b8016579bdd866cff8b552d127186a1411a93ba7a35b4a4cf76174c3599098107e3ab0bf3a8d76b0d0a6bce91075473dd6f80a89e5f2b5723bae4a785da6a2110bd2bcea1234a3cac4c8e606e24b139c6d0fbf798fa26a987432b457293243c4940bb9cd5590141ac35617b2f2f2f467e7699293d45a9ce85ed6c56e0afdab9ed462ba6b6cfb82a997ff4e2624287a93739f80cd72b220064da643f56c422574a5d8c83f285e8c01081c850ac96e895f26f5a123a26f98ca0e659cb9c08d6c3476db13d2303d2dbe1e3a6a3f293c8baf9e73271d1e5a86abea4521f9a5c91c68b12d87104b9b787e5008a9c2d48c3e7fa5994c252fa594300fd44e917fe72805ab1203b8ca6745d7cc4655cc852604e8522c0f2c8f80fa6255845e946402458113c4561ed92346b068afa7309fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
