<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74ab1ed7d50e329aea0ed96de30ad8263e147dc3904e05d04b17b3fd34cdef780039b7cf05884299f5e751547434be21dbd69ab65b78d99824a6143b20f7b0793a513c5bcaace2760759bed33683236cb0d9de689ee1a6a8d262d13f8e9d89faf7d5cd9de1bafd750d9c134095d4e6a477880851edd5de9a6ecfbd9933e11d4a90177a1dc571eade71d73a428e4bd2bef66a76ac5b41cc2fa79f56721eb4e7f4781f8b6ffd9d6cfb6ca97734a5e984caa0f385e112b37d96f5a92e469f48bd7e0386e8f208a55928cecbc6163c285a5bbaaa0206e10a8a74fd2661e743947de59daaf002821a0d8a4d6b2937773ac6f60919886fa997a411eb9239d8631aa5d21676e3ea05f5a0a3aae1187c24a83645591b3568d3d0aaccb377b42ad594ac78222c4b8f6a7c1e9faf9ecfd3dcd2416d4e37b07d2c6a67e6e0ef22f43e7190d80951193cb90ff45e95e723a774fc53b0a8f1da6ea77a8b45fd47a350648f7c686d924eeaee3c20966d20aa80bfd9e897d6e487816ca21cefa110e72b3c5dfd02c65f5447a85cc20cf825740eb7f5a321af4434178c9ab23fda3f9f09886f283908b2296f4eed54ade302cdd74f57041b1e955ea269e3be5e82d80ea91ac3bd46b1b2a783e9609f03e4a02b7aee7b30627fdbd7587eaf763a0d6ebcdeb83ce39cf22d106cc20e10ab58085c616d93f1641dfbdf9113f346acc9181d65eca8fa6e8fe3e7c8fe72a23507fc8e74222a9cefb5bd07e1aa5d3d1bacab0a9c5204e4688be099179fbb0c6d8c63bd7df80c28500ae739a9c1f34b4d0de50d9a2fe6781862b7fdd0c88a4865891aea7c87b12d63506a7f5c403021ce5dd5d6ce06848956ba497e821965a5287a98a92efd36cc7bdb53f65371e4b4ce1bdafab6f1a8231f77341dd794060a1d74cea92b53879f79b1b7983e689127ed5f9245e2fec1a524217819397dc55504254d41de417b24bcf2ce225bc569d28ef0f152730d59ed757fc4dc47bb3a0b204222deff3eda77a7d9e6ed27d0854791c2e350e292b7e0a1d58b0be02d56607c41dee5853809d7d9602db682255fb058b45fb368b443924c064dabb6e93bdea1c729aa572859a73eccd36f0ffd7cb3543d9a816605444c5756bc5deffc4f8ea109e0cb946e29df478f884e316f870572f9c45736dd2ea6c6f32ad3a78577bf630944572b236c6985bb1d6abd4cb6bd0f67cd5a29e4b1118735455787ca556e5e66b658914399671c9753f6f4b2d40e98a9b80d2e19f6662ec804cf2b366c09d488668b93ed5a191087fa53c4594014726186e2cf5d6f813aa2afc205f4041c9b8b9953967f3aae1cab00d543456ad4ad30a9205f84c734cb92157f2e270bd13ebb5690861b3981c6385d69de288b6cfb18b91da02deb2980c916d82c07b1e910830e11664a3b3b732ffd6a28a226d9e53c137a44f38d599da27a2fdcd71f4620d3a2d3f6a2ea07a69e02b29369eab660fe5895fe4d0ccf04a56781bd0c6733e1c9014d69503cf08b92a5bd251e5c39fc997fe6b35922dee7d5a57fcaadcde373c2379e7a7ded9d04097ca164e6dcb45cc535afdfde0590a39dea51a67d8b9ac4f5ca5dfede1eb9c6517f7c0742143381b49e34afd497d0f24f73e3bb06c9e88d3baa0b3c523b0b66208d3a1111a992ad7c87e21761ba55c882e2b699edc18b0280e15a1f509b5be850dba54cf4ee61f50f18e6f6b989d619529264bc9f083f2fcd4292934d38b6f74747ece15288548f3b067f9781544edf3380cf69e01763edcde00c501191922a612e58e36ed19032777986289b1065681e60e90ff1ca5a3dd85f3199bb58fd1aa3ac56f0e32f7818f0fdf3bcfcc353dee7c3c3a7196163317e19883c7b7498109880a57e9261038272950de319f1f18e35f8e38f9d130ca65c8af689508a0cae4a709863ede68dd8f33884b02302633ff9d2ac4feadd084002ee6cdc43eb23c4c3b6c7a21ef4fdd611f7f5c371d01a060fb05d8d97d7e007cfafc896fb24e8ce683e2aaf53844fb957f5001677c0eb3b83517cee1c7b420df7bc074943ae317f7a3c30d6d678dc74cc510602e07a61668d14abf0fbcd8516cf99dfecdeeb24dd7782dce3ca839b2a2758f02fbf11b35990232188b6f70edc8de02b75e23e5113502d3368667498180f37da00fe0fecd8b111e05ea3a5612083c1160748b3b36fcaaad133e4e92b0ce0aa478a2660552aa5da804d93e553fbbd7a42410e6f49f80101816103f61cf50b26b5a314f83312b7704c9b7ee41a69204161c6379e30a89a72b4f197f1eab2f7ba3a4b600eb506e51f9275d8e8c120ec025b7e79538b4b13978b3ad7c090192ede44ff22eb5e5a7ca0cd3e19ddcb3a8a51b00d0a0eb1d877774c5ca007bee10c138ad4618c97e7256602784e48329b9507ceb65d5d26de11d7b6ecfe6ff238fee77cbb60626c3604ef774c7af6deff06dadf6ccc70fdad78642f98bb847a9185dc60406e0e61fe118056c0396da60ce7ad9bc3dc78e28bc31fe479512da498926797f5591f1a94d7042f2c68a53d8ca7f575aec1248134f7289b8097a1c1171d339c5e7814974760fc25e428136d01cf893f5e5dfb3006f38e19b74ee3598ac16a43488f14361b05be8fc6e01a355a836e4ce0102a6b61b441669d37e4d95fc44a622ffef119316091af4601d290db5705e88ae83d6d4e6e8d3df65d5f9173146b60d66d66ea9cd1d3b59de47d3fa2ba648af0828fc58bf7a347af7827812354485eaae8505abe78795bf0f759ebfe4641e738607bb11bb8662b4ba875c8384c362ebc5335809bd73f72bd5ec28ce88815a1b1acefc2fa8cd8ef19b30b08a20714cb96f049834f69cccdf8375c1ec15249a6e033c351905d8113774fa0f0e0607625b61e62b25fe960f35675f123cf5832c167315194ac73c420aa48467bad13079fe26d3826ecf42f90f47cf17b2068af16012130a1fd618708d87f6f24e996a3714b3c552263f92687b4f75b565f99697ad00cf80a971222844e711fa7b2f1af822ad94cbb74b0d162aff964838b36ff478a12d31ddf3e0424b1f885dd5ddf8b222f6e09973bfb4822da98393176ed1aa363e858beaea6b01f9526d841bd0051d1d6a5a36c39f762987e3fc49a1e18337cf7ae8b9788173537d1d86f14698d97c645046756ccb6953a75ad9fe065a66fe2879d9645181857a9bef0ba1fe820260ae392f83a20bdcab357b06fa2bdcde353cc0bd174aba812ecb67831b915e2f3574a438e5b35564869389495e2ff4429264df20f016f17d3af6140ccab1ade311468b69ea884e85605423e2a7d4f5984ebfcfb1e6f3ec008f9f5cc197c1f022d53a9dccd6d1bb60586796fbca224630cf031cdb999b80eb519e0d1db72ef0c3d99ed2b3dd6647017da5d80cde0f9e2dbaec0be30a40d71e02dbcc62093032d530115d1dfeeef49d4b5f0578b16e35aa523b25fa77ca6ccb92ca6cd44c7e65b0e473a51263ae7f901bb70d39d8205c9014bc654d468c7bdc0f250c4aa10298df010e63d2718558c9291a972182b17fb9f82df3138fe19d0e38f313b1c69dcf746945365ef800de41488f3637f054e6927884f825e49b95d08c5b5cc603e363d514c46bd435457b763f211f8c9c5c40c0e618ac922971b6f5034fb2550945ded60bbed2a0e5ce478c20fc819dd9aa992e07299859774097a19044042f7878b3a75d854275f4d822db81d05819d99de6a717a610aed6f3fcca1f16148c5c15b0fe8203d2d823f94f7f20579d2cb4cc2ca4faf9662daaf4a6903222a848c766bbaa0c4dd375afa636ac7736f58b5e5d8da196b34985fd3969ef744e0cc73d03b03f574983304cbea55151bd08fe1676cdd21d3e4dbfd4b86c662b8f0730dd40c9d647ac59d59618e52da5fb12ba38708525f8102df4ee0dae12112bfc4d75fcb62c7cb2ff8c7c41d71e3f0d670c11f3ab1269e15c2258a4e8036e6bab86fda4a4ea291568e810c8f7156e270f22c345f34b52fa1d6c18642513d46094a965748bd55411719de2fb8742689959126a72cc1093bc1dba15a6a3340a6d26198a9d24d99aa2eeee9ab23bba33c3f29820e986836fac7eb158356ae7978d547e9eab7ccc6faef030e6ba6b36166f9d216c049c019059b8e1bc994edba77939881fb812162173fa6f553f1e157a2ba28f0c8d3b0f746f1ef2e69e77eb4bd3dabb794cf13d2cce60243fdc766622302bf6a3b732950d18938b84d284b2c6d707cbffa162470cb8d216936c360c2c38b5e33874e76925f8362af33973dd4ad7de708abc272e87ebe4590416612cc573c83b75dcfdeab26694906770e5b8df74a25b9da07ed6f6416bbce29b1d73e7afc17c446da7d8179a90e9e31d3d158156aa98a03690fe527036365071736deccb64ac69c7bca88cc335bc893ef1fb85c2d364302dc49cf251d3ed09730b2d5d75b6f15720ef4b715a224b5c3574ab9bb7fde70f3d051a784ec966c41142053e3d0dfc86adbdd0b52f61b92708d470a7c7c9457ece86d0e58099ef8c6edf22d451e24ef21501c599c12e6ea1c2ff2e3e5b2a1f3b9c50fbe1b6b5ee72f60e66147f1d625778bdb87174b4eacdea6d47090ba8af6c2bf27fafc6894597108e3a9d0d245b36d97b0ddab36e0c903b86dfcd205e0e9adbe598e55d5523243f4e0eb1a30be98f57f840aa228112de88b3cb41285299dc4037f90bfea4b5dbb242610e6ff94c2c6473ddc87a12b04b68b61ebf75a183d0812eb6c8b4e926851dac71a85f10cda5bf3f5ae42e9713a00fb5a97d12bd77745587c10055814e6b0aa73b9b8dc1b20a56e71fea464847061f952c9b52406b19862e570fc6247dd9d62562a8ca9326c0fec14e8f303bdc3436d9360d6f2ec406bb0a2ce906aee596395dd09466e6562a4bc62710a5ffa8b10363a9a3e00c0c2b46406bdfe2582090542252f64cdccc3624785d9c98542852d9e9602c98d878d75db7827a213712c46104bd2da347de8bae65171a9e507721221a8dc0118f4e610f8faa913ac88b51d9637154cda42681fedd2e9967149f3b4554724b94452ad9863d5d40acc72383fdc2b85e21784a91ab2fba115402139d85e6fa16cbfaabde75362993681152215aabe90ffe6f6aa8ddefa7f08b60b73b73e8571381ba28bba6338f7e47383a7a0ea0e47a9356a072df54877bfb1c877fb597f2d2813da77bf81833edfcce087ed0cc47a73e6e568c84c91c2cbdeee7be9312264fb7a697e219e75da424c5771f637ad2ba7d17ff2d1405329596cdb4225ee07cd3fed597c6d221fa369e921470049a44cdfe788e5c93fd1c10fcee5bbc22f3f7652bff849a8e74f066fc9ecddcaa32cb027f14133ebb3f6b56c6b1a5adde740478dbebdea513344ec1248dbc4e2ccaa5e691ff748579ffd2df91a555cd650e151ef0a94e68eb2d0cade63f55751ad2e4f6db895875634346ab16e0ee28a296e9151ea2658db085d67bec789b9c3db0ab5ccf5bf33069088b754ee389daea96db5b5a245959022a185f814040c33515528f5949ba213f72094434be2a75c41bfc3bb1ff951034c09d68770032db432d5fef4dbbc8534980393a52de0062e579db160a28044ab0c980d00b1bf8848236dca1e1b6abff30ae2eaf0c65264c5f37ca2f4f912ccb719fd745f91b57fd8c335b76ce5cb68ce9ec7ad6e4079f6fdde6350a2b45ecda7a9d194606cbac39c8d901cd05d6a0cae63b2b22feadf1feb0ee0125069dd4075fd7c0145fe0980ecc2bd55b14cc85535f056a41020484c2ea825184b104bdbf2690ca66591522ca0496e5263769681a88ef9da74cf6d1f329ccacbc0d0396f7717001058a7a41b07a1f99b1350394da9efde0faabd08248fd500b02fef4d7cf1c968e6d964cbc85b277477891102f49bbefac2ed86ec6e059c8caf8da038329b61f041f5dbd44fdcc32865620e92082213f93b6c9eb6284af14a4a9b90926f67ec8964f0006832659ed468c1c039d750f58bd25fbb74b42de83593e047117df412efbc6e582e0f94854ce5f97b4d0f5099d3c6a1af1898e3a4895f4b35ebf8443c394959e75f95b31dbaf38632340be7eaeed9806a2aa3a9eb1d6d0ac02c18ee1cc724805af35a8e37ce1e5c5f11caa6f208368bcf2c77f41e80be67b14fc1b8b90d5f8219e26ba1af77aaac1437765b0160e00cbb71f5d48609be76872601c0a2a06bf14463755335f8eb47cdb19c3ea4b36f0b9e441707cf1e61132229d7abb48bf05116fa5b27d1b11239cc63b0610b3b518832310b4f3cd116539127e5eda2a066a92c4da65c2f0ffe126e5f8eaa0bdb0cfd2e5208df14d8025d6e3c9e7ec7c8f073d1f9492f66c0718e3a3d9bb9d609ea725de9cc3304db5b16d8ac863470677a4eb9b96187c743feaa9a99dd406637023c1b5dfda68cd21bdee9a5b384843b368124ad19ca4483b377970869d799d98d15b851b143be89ba607b4b88e6f446f7305a8f0139798cd91567a2e67d06c5883955104cbbee9fe13aa84aff25b1c034224d4bdf971bc4cb258c9c57144acee152ce8c4d7b6260447b77065beacc822d65cd4570ecf7dd882d1af32ad141711a8f95cc21212efeb65c72bc95bbe5d032ad5b65970fbcc9b330f0db5802962e6b96f1d613d88e401fe2404ed9ab994df4c2d644dae63a0548bfdfab992c2367cb65d3072bc9c884b168a3b6a2ee39bbbe3274446f5795dae82638be58b850bf8faa622543f57ca31a851d61965f1ef8c0fe7307da37212a5f8a8d50012d7d72738976d28290aa48c5e7eadd00fe2170e06fdba7e5022758797b905faaa89a4827ff146a204d804596a8ef043dc286ffffd492b459f4225afcabfc1331b1a81f02fe486f3a90c46434f6ccdacd5f3b98d5b546d1baa0bcb728b68d1a83f4f1a5754419e6cddb10e8708a2a6f1cfb877cd040010b6171835cc370cbac32e655e5d5797ddfb65e93d92604d6b1354282ca09583d308b298778ad0db4c565aaac8f069883d7372bbb990546cabe7d17bc3fa4dc9243d52f9cb6bd1fbe8ed73f5f396ac86471d35422ef944d88679cb8d1f13aeb450ee0d84b6c1d505d9d206be8e091347bdeb89fea11108817f83eabf707705fbf2dd991bf443ad0817c5010281d5b3c0f6ac2a6a4e30474253a80a85ecbfeee4bafa75255837f6f1adc9a8697ad68ae843c7f70b3e1cd513c90366503f975ab986c8bb12526fa71eb25e8085107220a09fce0aa8d255dc55adbdb49a8d4e6d0b7f2a90d731094f3c3ea2e0adc1f82249feb30c4a9cb4ad979c04202bf30f5a96afd8cb0707f896d62c6c5c136fe62742d37969b714a9317cce85653f68a833b959a491f65e3291684d8d9193bf408dcb831e83a970078f9c789bae233b5aa66e530a27c37eecd21e7193c0242152c7d13f98a23d7272c4d44bb85c5c57af38773a4dab955b225e1636aae78f8b9a915ea81844fc06da0f9d2b8ffe7985aca806b51ef4e95553d26a449ec9a99755f7e8065db31a00bcdd357cf36513c0cd32283c6dd4557ba2b7b80d4591389cee946ae62df3c1a4d408b5c5b257de27898bb4eaaca5e1b266941504ea7a2bb37bca2736594d4f2303e05cce55920d741b95bb07f4a33e27c6fff1f6f9413fafd2c8f6aa5d9fbd60d3f8ef3f70a8cf12a23e1ca0c13fda34b9a8cdb29d7383a8913fa0d1a16dc2182ac3fc0f35dafced53e41acea9c9ec58deb4ea469e726ab7cecf97a4091e9cecfc9f6595d399e4c0690c9b4bd9eb33a65c85c650b6335bf70b90b86ab37f636d2a147535f74196652a9ca76790c5bd21d3831183965cda199bbdc9b5adbfdaec91ef6a54be0d57e324d3adfd6e05f39af9120bf90e4a1493b470f6332c977b33f5b22cce503535e3482bad47921384a7a63f26300a6433b3930a317910c23959b250b3b18feae445d33bd2f9f8854eb661cf3c607f3672e25d6a7d998add77eb4bb68e8472931b2d00712ec11d8a889c1ff1c9f528277160ca95ea10a07ddc1361cd8b3dde16dda35ea4f5e2cd98fddc0b081bea088f87d7f06d57c703d5e8628e065cfb2ea6d13612966fff9b8a15fc10acf99996946e78c2ef7a06f83941152278ad8ac196dd2858ca1deafbeaec293406deb381aaf065bf688d3c6dad23d2ba3c61334b2950c83a8f1cc4c587b42b2f1981e2f25eedb8dc6a3eaaf254867b6ade4fee1d19dbcf827bff061e3104e0a70df7815ec6fcb6e58a1fd6ee4c6e3fde5c1bb5aa1eb87211c40f0190d99d52ac79d1975f4e06194bb77fa8fad99bf18bfe808affbf789d5878aab5475f29fe4e08bc7c3b4e42d5d1cc5578a35c56820cd43a16a41009925df8a406172e4db74e21e4d2c4816100e69ed75143a660744539c0a15c3507303c1e75d0c3418440cc3c40bbab0bdca4f3d0a933ebdcf459a649ab517dfed3ef00f32d1b88aebb51636dae0547ec504e9199cf32abde40db23048fbbcb3bd630e5db29f7372d34c8af01d266d24ef8eb9dcf1375c801d8184c2b20f63509d9a386effdf5ba5585aa6a06e20357de8a5f20ba9f14be7109c048766f6b3832a646dc640f40aeac289e5212ae3b51f01e5d47d769ebc3da6833bf31755457f02dd0909bada58f86f3d61c250d3f763379b694af50dc52741b0d34853f6df4ca5c9f26514e2c838db48614a720b3b02fced411083afb433e42270bafb47b692458802babc95b865b8323f74b2b8c03e3a27f044d3ca7c28c1a964259983ae4dff9184c1c4649fdd3243ff9af23b756f4adeb4219e669d196ecafce1677268a1263f42641790219ce353df0879fecd8099acebac1d6d6255d0fc6d17872fbb07be62093cfb6a31412cbe816dc43f9d909d3670cc3d53b49f8331cdceff92a7c2937867102019ea27a5f2269859f765668dd1cd5fb22e7b121de16d66da7163f08e37570587ec696f888e5766a886febcf0b96f8cda4f05dc827812b12233213edcc0e28e9043a07f2082c4c933ae94f4d5f30564e0a320d479c30ad0acb1bf9e24456a55446d28e99c625be34a8ad294bf751a01eea0bdb66fc8f167a865554c1728a5f246bf74d035a544b442f5035943c43607b141f961324f3091665371c7fc302010adc69722d7e66a02e93186e98242577c3f73ea90863d5535141e637a1459a6303d2448071ae9cad6783bb5a91b226a42ee27ac3d7700e7c47ac5d3a8741c59e38196ef30a1d4fd1af8233327e0765eb6d911d8e080d3b25f18f4bbce41e7aa574c23b9dcefb4df193de547837c3e559b908553ab27206105627ea977955e3bbfcda0c9c0c2adbeb06d920f3958ad28d842925a956a1b364184f9e5c7cdac45b3ab564ce9283edee8b202e00e950f8f96ae324554f334e7b85d5fb9c6129a49736e108be7457b59f43a35e243d87d3feac0f9eadfdb02b1238a04eff5e93256bf95ef1399933cf0c8084e394a525ecbb78fa4aebb5c7dae0f6385df0c5e591e729343fea22c8fb3ee716431f89be066cd30f4e6bdf4cff5e9f133455d082bd135f0100c331081e82df5c9b44ff7579376ba510263fa893cb9cd51d05f51758eece004a3461e7b4c8ec42413aad1b7b62172b07c20a6eab301a61cafa51d2e8191b2a16d7bebcde2f06db1ef2561ecb7199a72f782c4b38709372fc1511fb1839139887c91aea0d7b392db81e7972d99c74baf2f3f0c2273360cb04d2e34acccf4570a68dd39cb1ce707c727854fffbcfa528e664423fe5f6f9329fd098aa8982aa21f0a170357c20f9ab267be024a8ab5bf6a98921df07ac9e75bfb0a81b94779f44c993de40e4d15d08f7a5bc7f10bb8689a93bd3c48f8bf998e20d2ca4010421bb4e609b61c4fbe73e1720842d4e5c304d2906dcc2209d19e6d499beb2d3481977eaf5598b87ac0109dcbd91e14c3f7c8ca2fcfaaa0032f74dc42a396a4f76275e678f93623211db8d0a08aebb36b038da1e15d70d173966aa44c5966ec713166e0dadd6ebf5681778ffd031d6976a18d35b33444b7068631d12ae4444e3f31b26857e56e8e3ac2e435d44aa5e4fd45d9cd86685a053373d0af91ae961be28b92febe12e7ddb097e061648afa4024b7b36ec19ee0159b9e7ee5fd218fb11aff4b70505d33b2c745b88e9390d568904a9c9ad4d5129304b61506690d5d5d89d56a8d4415accdafc2e0b88c40b11cc4302e22dda5eaf67b2c5da237121c7d4f6b2ff6a6599842458022f97b4b4c704c0470e38766a363e0115019d964786f9e220b03ce5896e49a4d0358700052e3e747f46d874188bb75b72ab6cf842e9c8135641cce64e9413c89b70f0e09040d657f60eacd80c978e511a971758ed849918a63c43d07ab2313ce65aba2ac873788203229e1c3e264c9605b6eb0bdd3df91c7bdab08a55d8d07acf97ce11ba4ab3bea3c8b93537b7e2b5f2e7629ac9f2303854216ebee29d6aa7b2e68b320a699e18d173f3e4ad58f84792117b76c9cdbf8146a15060090c2cd8e772b1d53f978eb3d6e2e82b1f518218c1d516badb552b87415b84e01e93d24fdd8bc0539f02208e2c0ab87d7317224fb33b9f58989ab5c60cdc645e0670e271ba43e8adf3411612ec275f3d4dbfb94c2cb1a289adb9d62bea01109b2ed251cf7008e6b272bbe29881852f3928f4ea466e77552e1b480957c040d2e9be9c64b9764ee6aad9465cde3dfbf4d3dbf96a0a316f2170725a4d763d51ae675e69eda67b74e856c4c1f83bbe03476ecb04a66cf7a3a39d07c814e32cabf8d37c4304af5bc8063effa49587dd37f81c520decfeea7f085e895a595bf47756ccc913e84930f74875c264dc74550fbaea8ddbe1700db685a332b15ad999795b23ff7a2d3285882bad66cb1270907f09e4782227baa5570656fb82a09924b5a5471e936a1c6826069115b73156819c16c8c694221cc626b603c617bc292a01ee2d2f4eb21113d61e432a4c1cc7fb9b2dd672652955e1dcc43d9c2779d68cad35e521326098ffe3ad7f7552939c9dcd46225ebd17e7536397e5e75921962ae619e73125576a36b2a6824587dde1d10af095a50f6ef2fdd40f190040cf779c20cd2a0739d40ba2a5cc731aeb54088532de5e5765282d9ed4da3416407e69aa27dae1b4864dcefee1df367a848993b53a3a9112a57aeb5ce2902244639fd24a9ad65497e22cb52b61f928755559ded8d1bea7461f992cd617a7f022f66def5e77a9c26af40005d6456ee8ad63c75256b81dda08210990745ae80ca377260322b5feb598230421c1de67e1a0cba8bd6e5d089caf5ad88ab1571eb4b6c0777a4d8c805a586dfcd9f31ad10669d32fc2ff712723f990b80eac41cf5438303810af333fb8ffa3adef0d6025011542a0cfce632e477052c99d2fdcec0731e562db61de553df8f05ef2f8240ab2f73cee17d55c3f14bb84413648f0c72c3c8d9b4d59b98a4276f1a550e3e5327099228379af3ce0139c0ca61275b905d77c0374cbe24b5a6749745ebddf6cf1371df6067f524f8914ed4fcbe725d4c79acfaf293dcda7fd64693b6b7b51e8968a726002eaf831e03fd8224087bebc34f28f0763b6cd94def3854415509be806ef2c5e627ce8e02f5e9a783b048b00a6226127a8e4522d7dee9db37e3486d345854345953478965a2766caea173606c07c9ead6dadfb18705a14f5bcaae602d7510bd26eedfe1c607ea0a4bfdac1f7c45375ca3dbd78c1be7e96525ff30bb45b7d666a526171c377161e86a1c65fe571cc5f4cc1bfc4443df0196adea801545695c0a0eef684bd3c46ad97b5ecfb491e4106d022450dcb0b99a44d2cca56c4734dda3936f9d14edc33255d1bcbcf0debaadb40dd37544ee86d9e9ed01c5da64376e705e18ddd0f920948b5d20d732ba616d4478fab695d37fb45b97da9e0d12a5318c588c113fdfd9a8d29e3e3cd6903465f7e915038e575834d4d086cf396b3c982e209682e8053141df0405bffa7d4cf0397a83732c74408cda2071060d5cabaa2e24dc4866b461a8d0765561b7958ab4f470e4f2110644b1355617849c15476619096305f871a6bf9259dcd8d8262ebc61318b420435227b6f8890526ba0f740cb4653c5b4b7559a819bf132d5d088e8d5a25687867c6b8f8f0b032730efcb5dfe4794b6ff8b4c5cbb2d7c7b24c6eb4af816c107bf07a10c920940f6e24746da5b6cfdb2f816958154a1f7e67652a5f734fb3683242b816ff3bff9273048e3e0d6da2e3a04befcf9c1c914d170a920d5971f83347d5f3cfe351f4fba4f3acadf573d303dd21bfb5f10b299ec20bec98dd1f2e9339a7d80e25a5ede8ec2193082048191657f859e5e9e6ebadf362259dab4cbdf8e604ec8e805884d5367d47ebcccc8a7164cdfd84ea78a28cca3500840fb58b7cd3106a07830c3d680c752847d6a272142af11818c408a2da0ca7e568d65150f5141d5933430ab39a8be93d9fc2cc9ebcd903141d79c77448725b604508800234ac3ecdf7087a8230c43e70c244ec89b85ca1cef1c14a7190e71adafa75283bf313fc336ee0372332d12f9175f292be51293f9e8fb9c4f2a3424ab5050d4c3b607c3ba59229a96672da2c87faafac3bcf3cf8ffd0bb9c852532438564966f9b3f8951bcc2d68a6ca01658248e8c0d4a39f5ac9e5b9551664e4f744f0bbb963cf8bfe3e950a8da314e5f535bce1c767b46cab8c6c8123ebf8fd9c94e2f8176a04ae5ca513bb58ed281804a8e721d1ec417fdce8b3de97362c916db9371e118b6674477df0f16198adffe0364a0dcc5aa9d713809e3ec3b5cb4da4e0e7515f095f271ac0284bac976af873a289b7e6eb08f8bfc5c25ef44c946f166fe8b38c4013a48f02715771becaffde09ef0e3139858b4b7f5b03383ffe361ffd18df9acc0ba15c55b234854fc8793cc790893d7f40e850e9009403bda299a9bdc50d7324a51fce1bdf021d60db260d8a570eb08b625954244d90a1dd2d178503df983cc0a01f459a704ca9605abb8c12ec0d8607abe70104c6e5fa4006eecef9f50e3558f1c42146077875c1beab692efd0cf6e8a288946fbcc0da2814d04d90d00274046c965916d70967b22b3e1b8f8cb469137860d1d90090f50b2f6473e24d22f1bb54e275f44c134b36967f70b8d012adf84995da19bf143ba98d3e39a16ce86bda786a72b423ecafe2aca47dee15f7317859571823e89e75f015210042c49714d20ed3c61e820a229d45704d6b16a2067979fe4ce3b461feaaac2308f37296157c76ac896e3d1977e4bcf2071feccd478de9a99dadcdf329033b1a5bd417798d8a2a696f40b33ec0d93269fb6d6f18b70cbf9f2bfc8afa851c4d3680f0c45fe5804d460543a7ca06fda043f7e7967aae11f1c0730537e8a2b6283672bfeeb9781a8601f2a19abfe46363d68d5beee18a9ec29c8bf1c51342ac1192c6631654cdf15f860ca8ce7557d526887533c4f87c32148b2703269ebc3813d9aedac05a1be9cc01dc392099936fafbbf3db6aae169a411d06d96498c2e42b257c4da109526139f754504afde64a8a7fc26b451127154d7c9283c6c1d597a3e983d6b1952d45a357519576bf4b86fceab735541668089cd27f6c186c16bf21c1422991f80433e4f56bde7b53aca404fd351a114d4eec286cbfeef12b30379f973dbeb30f3f61f9d20bfa18ef6ae9a04c95151b001ec7dd2b0ceccbee4ca77a0538dfbcfdd038f22b5a35f82e06332fe7b1239e58fe24d62d4a6bb1dbb3dac639a3236cfa6fba27ebf038877ee7afc07a7cf22f91d81d101cd76485d869df422422f3b6dac865748f0f905a63d707f9d639b441ba30ebc3636275c1604dac727e208578a81a88ea7ab0bbfaa25bb225caa69739ed49271496047c9b99b4286037724782da94eca4b974d53b8216f5ba531ac2515383dc411ffc0ace1e93c03aa557bcc4e9336b6071ee076cb6a9e0dbc8259c853eca2778d57cbad444c32325e5347a6cd63a92bb6252a35ac3ac36899cf0aacd2b75ee844b2fc8f5d575c45883253a24434ee93132132de7fd12317a98bdad4f99e9548907eac90dcce5242c28998cd1946636a6db452309296e4620efad1f61e92fbeabc1661acd3186515351e5013c311808fb76952494dd4f9998bb1f8412099a31e2d871fa3bd4f0fab5783258a2e216078e48bb3c2057c9b1d95a33376bd5d1c7ffee4930e9c16cc4294fcd4de4d8d20340042d5f9726a85d9944c324e4a943f8eb9209b57c1d22579d77e23e087de85914dca7c28e01879e280e6d811968abab8c87b64943406a3fa3f27c9d2fedd4a65045b752f6a89d50ef77d2247c794ee45f3e18dba5c5a503afcfede6255d877f6acaa137649a0134e0188112698f8960612a8dcac5eb28c9c6317484fce6a0e3f55e2cf20dbe6e4bc2967a6f8f54d972c443f25aa9c28d782cf72bb8c072d364e21ed6f307d021069aa4b07e830c3f9aef09fdc3acd7a2e586639ce802168fdcf9fa4c77b101b5eb8da57a384d3dc47ea9140b91ad7d4960c38fdf561a28afe936b17b06505e2e1bddc07de34f5c27a6133e950d8181aa627efa8635939ec27fd0c07c573d10eea31557c7017c580f9e9d4318d3f603908066fd278921796b5f3a29cd541f6fe250fa643ddf1c03864c7a55de909456eccdb5cae1a6cc26c1e188807faa12e1affde9febf6157259732ba3721bb5ce133d4e8636ba74618d612427d0d1344ab992e8c4b9c8cb2678d182eef6947b2f5f3383e553abcd679692d67208ebd73840bd9d832b324be4da722d34cbc64139d72faf05aff0259e62f74af68e06d6a05650859dc2cbdb270decc3d6dc5323ea0821aaa1c41c58bb9b525ebaea91091f56fb616fcb32f7930a9d5c421d63412938a291156f88435f139a036d856df6516ee1a0ac931d420527189637c41c891ae7da3149d6525b4a6518d3453351a6fc355055236d8fa9bb0d52aba3a2f03612b89aafa749fc04bc82ea00240252ddaee8c850cddc1e779b2a007f763ee3c8028d79e84b47d4342eb361d1b07e1449ca2b0e794b81bbe284bbeaa6da9a30dc1ca373356904d60d59680bc1e8ae008fd54363e2cce341bc35ce14391d38de890204914192f5acaca4b7a583930687ef3045bc62b39b661f4d52a311ef7d46de1ae571463ba7eb501ad2a4be9c3b4fb1bd73a830d2faa3d6abcfe78f97c88f12ee6c4b113eeb8ece5a4fc386ea80eaf7645fbd97c5b2fb92cc3290d0327421ca0a1894a7748bf9153e19afea3c3a2e78dc82d9b7e7f88d7a8c9ee2b598467a442858feacd6fc50632bb383b682e123c143b522cb7f64e18383379f125fb173a65c1f28098425f8bff4854f03c75e496089615c73137396d3c4c9feceb437d552e5fa7c03111d42693dc29ae30d69ebcf229dcdd97e81f43a0604aaf667248d5a583c892eccde9509d551898d783fa5d41c5a66bef42ff74c401662ddbaa6cfd40d0e68a7a70f85e6734a91582ec9996766d51f5db5d0b562d805c140b00c3793dd3a6320f979f025b24a2c434fb0e7172bd0cf4545ca4726810b4556ede28f293de25ab41cd1b4348ffa738846d81ed3385145219814ffbdb570347464da3aad7bebd2150a344e654dcd785de844005a94cb55084e16131dff01af4e8458ff93ef42a1e5d302fa37c675c59b5a3213ad13f2a12202e91aef3e3ee3995b30d6a3879861707bfb87bf6c3de6a5721d285c81e887571911fcbf8e5c7bbd705263fcda899ab8762bafb4d584f454285013d60abfb91a1d678902f0bda0745549c294d68bfb36ac4d2abe5a57815f50d9a53968ac95f7605b2d7d5f4733913f768cbcc3f4f2c85b0babf7b5bc5c5776078ca8df8444f71742f946bbaf9d118aa6651971c9d9519c37993a459b6029f539f14f7ab6366132e54527f712fd69469d48d8f86a3f22833f9c72bf78de888c5df4df27ab7b48ceb684ff7be1dc771677ca0030534b2b3b26dd75df1fb84b80a2dbe5de5ac97d24c9ea20b10d7f1a36ffaf8438b4fd1ebb3febb4a3e6179ac023156661a84d1908406ac2072d723d09b6e8874ae3a0f82167fff94dca9475fb9fa5335604b9e165178fd2cb8fde35f3f83e6a2b8a31ad25076b8183ca1b850afb50fe42a7e8233108f4597bbee298c4702bad8649e9e919b7f7e2931d6f5668bf8ec45ebc1e22b30a1e06281301a466ab7bd204fcd2f5f2a49c0885e493b88baed07af8ca83b20cc4211f5bbf895761952825aaf7f450eb05f1ef453a60aa2dc0382445c5a7d04040d83e38bc9386f0b53d8f326c75503cd5835872a69c3bb763caf6d1e32ea6fa199b9ef9908815c682591b36eea4a85755da4f62126d9867bfdd6b41820eb19bd9780d991e298e019dbd4fdaf135bef23365ac18d9132155d16f6c729bc5a4b1133d78e62b8f7a0556f12aa5622de5ffad1485b3b67796959162725fb2c5281118890ea42ef6a8c847380dbdab8d0919e59acf98f292979bfcc8114ad7b77287420ec9cba164fbe6ec0aeeca5d8803313e7698403da4fd003f15441999e4be1a5497c94a464f9d68e8f07138c85c8324f1ab4fcbfd5b4e1110ffec23bf966dba40badac38056b859a73ba935fe7bb442830208db1306f4f6f7e0a77d821a4677204b533f397ed666be3f6a94e67b85a36ecc79702f571109afe33b04cd598645bc3eea7ad8023e3d28afb5893d69af08f35ade4583197735718bed659780372899c99b11640ff3804e74daac9c0bb62ba36a2b7b9f3a0236364577d348491076bf9799e4aa8eb02ace076ae226b0d27fb9ceeeab08ffdcca2b81d614916c80008e1b47b5de037be81c7b85b77734e1ade623166b5169f8074b0abeeb6c41043cd88cecdeb4cdf2532b98713099a41ac5743d782715c68e126a2553e9c09add3310ff89a0670cba32d918149560e801b11f763fd6e5af63471a52076eca2e1625bb7ffb373dc7cc1a98566c0860d6fac2fde3bcfe98021e898f7a32e647e042bda03fbc92f6e17e9f4c32a4665e894eeda855139e78f1f3582c980331e8083aac0829615938b41d8deb455cc67ba10b3b5c438ea8805bd10450670e5bfa12db301cd6accdcf3d08a0b0ba013c1c7507a9b9e69e14dfeb1df9f523e82f8d0b3fbb1c289ea7b046043624548147099aacee4ba5382366395c05f657800bdb3c4e9f6c4f18823816e0e2e201710fc7c8976e41a04c96e15ead016444c7a6f9e946bd919428cf40e2431dd6712b36bf386333452519cc4d5caa8901c7bccdf6ffca20485af06bb0437d912ff521754139c991f4eadcbc77a3328a492e73606ff3f666e83e21a48caf16891376384cf7ff15a0829433906badf279788132cc2a407749876267a426b44f0c3752db5d41cfcd567e56664b71d0626187234a77b9c9d752981d1027eab216d81db27f2422de282f53e050a8c64f36630ca74a4dd6da877e47796db3843e0af63876d6032f998cdbb610793dddc928fc470f8c2a82a2cbf743eb89e1655c2086e3b73cd0e9ee32570d0ab6c916abe9af3a604da0454e3375ddaabb479f4f7447a99c11f7cf92140a722e96318c9e82076f39668a1a490d764b22aa3a416e9c126e7e94d1b7c55bc9c128b3a9e5679ebe3e1861ed3c3b81244fb4d4f3743bde3a0554d7dc3dfd9148d72828f49c02a04b57bba8457f52e3dd6b24a6fa09efb3f82e00d7720b07c99ef3c8548d1e45c9ad794bf8013033788e1c4eb18bfb5d375c9f3a65bfabd71cf538e7c6d875910ff7549c629ac11d4c1cf3ed398bf872c181ccd9013be207903f1aa2f1720b3ef3fa4ed4602054d7bed956a1444835d4313bddb6bd810b8dcdd894e4858af784e8c88719ec374a661ce99d32f8fe09a202d75299430e44388f2e7adfddec06246db1d9c517dac09fcfc1abe8d7ef5ad00710ea5277e22d96d7417e3f29bb3fbc65d2f519a1a37773eeb8bc540149461e8121b61d7ce058d3cf90b260c482d47ae964fb24b6bd1629b2c0da66b80e17d6bb3cdbeb7880ec69c9007e93f2316b7eabbc8883d1b0b02a981a370210d21222e57041feae35d8f66dca9bd5932c36ecff579abaf572abfdcd993a70d6a303f300fef5d2c3ba95322ad67499991917c580003d040b4105a6b6ff82f957307fd00b38fb689940e37837dfb38fc8f0be47d1ac3a19e1746bc7395cadb33fb9a6c69de64b0dcfa1a663eda102439ced6e93572327d5c66d5c425f9ce52697ccd43df555e9af2c578ca387c9c986abdc4f23669b3d6980a3d19f8e9fb8197a80c0d1e7b8aa843fa0ff0fa4cc27bebd718b629965705ac72e6c4fe6d198d6d45b723a855eca9490f7c632506515a27afc925f33d6996913786b2d4481a2ec24efe99d9428b03ae9271a5cfbf1adbe0c1c694caa60dd258719af383e22546ae3f3c94a90fa235e7c36154c87b0922162467e3bbc57f1c94e666a701789ef4d54ea65b87160c9fae2c66a4ef8eb70b7ce5818836aa7942be33d63e38799cc5ef25b7ac1bca6608a705d45034a8ff5eb983c3e0a8b47c5bb614617c9109d4b27d02d8dfb96e5a6ad7a2f92762ff5e6a9c831793fa3a9e7b66c598d3e30940e976d01bc08361074c7c309547e00c6ae1d675fd8f5609a22d2a0e252bb5fa2440da72dcfa5fc33f15ee4de66f8f009af875c9409bc6750a37cfd3454c6659c315580b2f21dc25bc9981e5fc50889e275f73d95d75556e53eaceaef8af545d8e020961fd25360bfb7d9477e02bbe23f300cb26efba4efc430e85e9af7f7d0c2895026bb69c21c228f0d78d092ab4ea5967dd199929afe46f40f52950fca0c0f96e8ac38e44740e300b905168db6fcc53bbcefcfbc831be3f0945da82ac997b3340864e2a3834adb7d317955a2ec684568cbfc0aebec54ce36c92af554640fa29d67ed20bcefab79632d4bf7e8cc1b16dcfd1cb1351362a79f398849935dd817804e118dfeb8903d96aaf54d68fadeb126cc0d57972d047a8118cd0ed317c4416aa0fe335c94a66ea50ef26ac4c6bf89f3c6ea7034e7407e3e69aa8ba139cd79b625464afcba864556c78bc8bf743ae4d651d2baf9c12b45276af9f745b3f59852d755992fc982f18896893ba11c03408eace7914de4babbe67e59f36d4ac8dadb61f4596cdd0894c1578f0ca743b69ec455b593a18b1f8a47c4f592e172486b97c452c9891dcf350dfd935fc0bc9d59a8a89febdf9a29155be08c7bbf53eef1c18383ff6835457ef7e59dbb15a8e9239ca11a9d4db296a535ab835031bca00d11286396a354f780c80bd47c5ce9eaf613c1f9f1e71224c169b933787ebac505c957e9fb0717161733c64812658e3bbc25b780b820e076cee732169f61183bfe49cd92dcb37b41e8303259708e64319ce2457508d0d47bf03d9715197f2810bced3ef1a916416932cc73968d7e631d9c1ba4edbc097217cc95a667f7075a4dfbd736372911e14c785fc689e1f05920b8d63c757855706cd8dfbfa3f6ad2e36a27b466593b1de281cbf80dda84ae16eef4f805f71be27e8c6a9a66f3a7a6489789e4e618e98fb7747bbc15227ecd28d4c73ba77e7e0fce4dfdc38ae4114766e4ab21bd65686a42d9ae650339fc71c48a7eccee666c5970d3a91e8c6e11cb12c97649623de4ab2b4ec68db1616c78bacc04cb2cb44c3da090467a4ed93ec718f7831ee41f0fe1b2e5219a330c1b711ea8a2d682617cb405b3ba44cc345654020bd2a1ef0f409617dd2e9976bb92474822c0a227d5265b113fd97b7f11c9ac05385bd9b4537854e9d27b77d086264ea56a233cfa429cebfa235c639a16134529fbbc55c0154c06810511816ff4bb5fc535bd74b0395b0ddc753f426f4589d823dfdb74b4fb7b15995038582f4a11fe935e6365509216be1a00512416d61fe9e22c4c6e394bbdfd5ba16a3b35ca04b8795d004e8de471a952243f6357b3c331e6f7fcd33bc7e87ea55a09da841f746053810034090fa2194b0ab05b8816ae5211d25c683f8ba7b225dd3b966840c200cd9f0a688856e37302090cfa9200db300380f8094c7363ae44e299513e3e978a42cc49d35740c7ead3beedfa2cea477eea33df529df002616dca6a2b990d1a98b8adc442a049d24f21a4720a1b581a75bfeceaabbe51cf8380a47480979e281aa35e38591917dc8180472c9672e748bb704eeba05ddb3f47538279a04ee5580c360d009880f07927ef3be04117324e545d0904cb08eb9ad98e788c39ebb32fb39ad0d7570ab5dcd4819d4c60f96a0cb57c5dbb752e7ca02c7f01052c1d45ec6caf57a5c67cec02e49bb8547283273ef40cee2193beb3500e42c354a678007ff76404f9a017ce24411bdd712fb8551804f52c109b3a100a8afe67871dee3e1b534d2a34237259935e2f50f8c804527d18eba367f14cb763466580a7bd033bdbe6583c5b3a4484cc2808be1815209ff987928530e58e5988f5ce0caf1f548cf799b03d46db15554c72756f9d72fa87e908668d5fcbc790cc9914eee29f0ef69f30387f77c5d6af25ddefbee1d0da9b242d471a32881c0ae395d56ee7b269d3ff80cab09f636af2c3a979a1d23a1c594186ada0dbeb3ea9fd5ccc5ea563b834e4903d8e7c806b2996960a76a6ed26528e865c0f4ee4166484aaae4ec4e5a243e119d992dad41e9c308874473aa3c062ef17328d2876df9cc6ad28d34cecd855b725401f75b31045ab902c33cb907fdb8fd73947c8b88b26411dfd3ba378849efcbfeaf52dfe2f7c624b52cf89fab3897ac4f8913aa0426a32e9127b93eea6ca6016d6d97fa18af2dd1dbbf288faf59f2f88d916d7711e14e1b0d4a9b3636c5788d5f0b384faf463533f115ed125e0e6fc0c8c9e1579e9ae9d54be1de722e7a722e305dcf35b11a337a77313f5039ff06de56428d3b5a050646d1ebb6630cd8952b21fd109f21d9f66b9dbc7f721577d004cafed50df738c69e6cc67b3d6b58506f5c2cabe926ee23892fb778c6208c843698674dd6658d5970628dea7b0cbc6221190bd686bc223c6f7b1ddca34660cd634eb2492963e7b3104434188cb708ede057871fa26f02712d1ebc77826d39a8669d993634ffa6fbaddbf2d9f5e38eeb26730d209fccb1049d7228406133b70aaca38f96a632f02d4c6bd127f55c670fb9c7b22f6ec42e873745bf1effb74bcf998ba0063c24a04440231252c639747e1d1b4d0ace1f37d19dd317f82553a7f00be780b5448191f2e144f7449547a0d5eaf91882502e08b71c8eb9c29661073ad19ea24b7b186cab147e6caef50025d9d90e5d9d481c3bc6124aa643f64b0b4cb771f718820be1144f5cdb9c7cd37384fbaa414ab45d2bb463520dd602a4ccc65db10461712af310ee5e4a8af14948e5787b4013650744d1e9c31c510645cb000ae532dfc8680b35abda0c995b847f90e0734b87a930f9e1e7ae810b0563c45dde55f5fd454b89400c32bafde9ca2fd4b688f06ce804c46594c3ae35374fa95ebd1c3e921aecff48ad2222cc7ba3d33d6bcaae88a1828dac5df64a9ca6ef9b18f694820a3a62948e27e6d1673556ccf6bf70cce82712c2eeb82fc44c96b82e989d50879ac9df60724e45fc3984160b05219f0e8072222bca0b550358b3821150f9bce8190306f48459579aa320a0e4b484d5e1b0939df4e3bd9932dc78f27460df421","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
