<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c71f6714e7f2adde671d741a5903af247c36453f2034b861a90e2e51f8dc16483179d05d8ee84cc635ccbce33cc4422d3820ae44a60ac84d20f556ff54ce0b9f8b9def2fcb6c4d575d8a1317ec5cef3d67220dfcb2546c712a84bd60f7f1eaf1c0cd75a75bc73d579a0a38f343ddc68afa48fef61b9a347fbc9c289ee2e26cb8bc887f6619c72631f6843580d60acd2f2a8e13ab71f2088b0bf4a42883110a0d4f2a605141aaf72e81f339b9fd320fba02c4c5b55aed94e9ebd21c4bffe6906abd26d2afe5112ee69e829c0a78cfec75a331023c875ad13a6b9a788ccd962ac5ebe9260765ccd8e84116b0e811ee2325a62d669e83a1e247b47bfec9b1fa2150e7d6d99138a2fa50618e200d4405143d3f9ce9e97e7ce39cb8c33186e8656de97d5755d698aeeb07afe21e001700362b3f244174c86b2e76b36886ebada4f6497272060f732fa38147870a4ee835c92e4abff4c5d8e49e7972d81780ae818022ce730d08580cd3f676194b0b3cfc96b7e1d563d702c22ffc5418d3cddac086e81f6d40674c024c7f97c15bd440cb35b8ebe41fc0a2d4c5be125581480bdf6985a2bfefaf6e5cad63674169cd225f8eb0bba6991b9bc850543bd3f35140a52570fde2391dd5a0b7b92107a8bb161953ef7b047794cdfb6f7d3d61a7e2022721bb8d0e0bb08ee2b64c94e31c8259865e9176ac5ffededeb42e28ef089d863879985eff59a91766fabdde87866999c1ba2185cd08a2e2a766ee9c10c35498b6e2d4cf45df6e8afce21a5a70c7f67d9c5d3926e0d01ea77d5ca6ac0269b0884f4e92f940c312d4b3543bd743c25f21e8e2ca4ab84812566650724b9b09c20cc960f8e2de4a0ee58519968477828639b4a2cdda8f3cb0d1db7afa0f8a9f24b8c0b9467a138b3edb55b0c61cc2e5241d604eaf0c2867d0955df8fc6aa3f4d1724c0fead62c8f670332ee11cdd6b79faffcded0f7d32f2dca8573319799be082b3dabf09f4f6465898d5b603d3e7490bbef6b7db5760445fa1118040085103fae5ea6ccb52d14a513aa6ffe98f0fb4a8253da41892014d830b6c8c86065f4163480ca9282f920d4aa27ebf4390f8019e44cf0de35056d1cd9489dc8a7a5569137c2908af9c9529a6b6826ff4f04f1c1079c8a1f4fe04b0155b70406c9419a56595b4599e83795d345549af2e9bcf3d64df3eb7954c7fb4ce077af493197b59d426e32ace3beb23e249eec4528d4c540f594cb9202f0708360fabbf941e518bceb0a0286b95cddb65230ea785b78a85c924a3101ef5b106b2e503e611246500014b1f19cdc32b5b851679ab4f59a4ed7e27e02bd9aa0954afcfa8d1a3842ff8614b897d8b556e935fba86d0547dde59f75a87656a5d699abde001c100201c0f7dcc0dcc65e413d5a074b681cf120f7dbace6bb4fd27e70c3eb4d6fc3cb28bff9d58bd975a8abf13aa13a78cb71eb01d2d94f25f8a368f3bcb5b0ab2e5b58065b548e955173bf14248a5aae884eca86d8d0048a88c6b549d0f051bb2786d492096119c59fb8e0e76425bf1d03eba81689c73e8e3858fab2f84ee753d1e42e3b2151a13bf37ac29471b59e592b40578036065520fc3ff742b416f0cf93c0990309155369b59fa1866903287ecf0b9aa7d108d2667e22f25afaa80fe26aaab30af4211e33dace746752b6ded7cff7d1342d9a4c0c3e7074376e1445c6e3ab415bed58d23c412a9d661fed5caac9b7871ffa9f2c9c591eabd895ad7849d265349c7fd96c50ae6262519796ef29ffad90aa6ae15dc9f3aadbb4a2698846b42d13262807325bb6d02a8edf063d1800f250ff2fd7e826ee981c7d9f0759a918c4d445d17d2b8d9c1f21313125fcf9823b55eee4b638e26f9fe64dfbf92fb05ce6207eeece35aa24f6c01193d3037d0642bf25e70b88b9827ce1d38aeab033bc1d321a1e8c8e3bd2eca7013f02632a612ec841ca93a3e4b8aef9db7ca15a98fb69f4ca4621cec5419793807652873654e57c554318e6635d109f7fec12383e91d517285b7a7fd04938cc46eef33334c263e0e13da149c047b6e838000714518f92e12ddffea17d3a4bac386139bd3dcf07cf41478f20dce27f9cb512b181fd3e87a522c9ac4da80671ccd09c2519b9f5957d581c666dfd773a5892cc24522bbb0d39b3c5aed06ae41bc5ca2fa86d467ccd04cb29425bd5c5d1b043a69fb449f41b41d2d866baf8c979d075933117cce1c10c405d9a766a8553388ac861416279dd9684bc566b91ac941ca24bb896c997bcb9360a5fd5937694bd132df988b1f095298cecc0d2763764228a310badaf74301fd115615f648ad442a31f7bfd98c7f0ffe720d38bb76dc7a75889c280502007dd1d390ccafb6898860a97dfb3ffae0eb9182272373c50d6650b34609803b198e6b51d1799726a845d4aa7911a7524ff6820db864aa8fa35e3496301a9ce5b708ce028109a9c6fc5e174cc39f9bd21a816834e376b233a9d832b6ad6756ac5ca1a1e23a7e3e49b2aaf58fb1e3db9ae165652ad460068ea0b10f5b06c65b20afa9b1d6706a6fb625f3b6d26feb9582a6e03ea2ea358995592737c240d69e158f645309eb999f275889006f515a221ffef08ec54966a2d8aa69a14fa7d409b090f4f9a606cf0b7b15ec8d1b360079bebb7c1ff0396f951b00556d44594d0fcbdef2380f6034ac0eafd0c008643e6e4eb1b0b11cda71a6d2ceb71b2f7015c439641246f21a89a33ace15b49eca91962fabfe40e4cf6a9642439c44cb3e9f4bdf31b8f33962da25212b4d546f67a9fd49a91a741c5d96acd7ccfaa4cd337f82379bab69aa3a52bf6694e29e77a60288216721e051dd3a20ced056aaffb220556502b29eefffc5b385745ba6a584b3f09a5efa3c5c518bde3457871d5cdc99776fefb932a7af6d4f9a084925cee0cd8d0cdafbd4b2b7ba457c76a8190ab5a4d402af39617639d425cb9e72295710db568afa5b7ed5381c1c69276c5daa424ff7cbd71d0e6f167025364a23aa80c5a1a959219c56e49901b92d2198dd42ddad585abb3124008af3386b39ca2a48d34f748187893ebace228e35687989276ba8addf2a2850008f8f6ecb95591f0e0507612bf0bfa6d47db86da73329ecf617259d7355b936fb04b07342512a0092539c43f884dc40e2a04c1c650f2af426e16ac8255f71191b6b75a8c193969740b6fe65a8574b9f6f244bb72b5bef1f00ef4d5473341c6326515b2f6e0b021fbc0b11b28430b52361e252c445041e19cfb782597954ee6fe386f5e09de253307f72ba8a1972ed81ab432d3ac4d9c1c800ebb1d28ffe4b3bcf6f0ef68154a0b1d2575de1abefd45fab6686b090feb2c9a64c0cd95586090ec284932cdfc12b9d5280977e7d23c7bf18137eed0744076b4db8bc160b4f38de48d9686b855ed9c4be67a9866ff6b01c39ce066e5967636af1dfe5093d470a80a8da4ccc459b1ec31a8e8ab5f7c9bb0ada52f45001c8fe79d4575dec3d4e80e155ec62917bee17cfd4bae5d3cc853aa24ece56fb116db11e839bb57607aa7f6d7ebf8f506f53de0b8ebfb38bb16b3511be4ba60dc774e2642f6f3b84880c48ccf2ea3afd4869b37239b4de4f00681f7ebda854e591c835a3441db9224b34c047e0e9bf45a6615eb2c7ff5bde2e95860ff7b2470e8c2bd811f357027b84fa9db095362697a2413021f0fdb4c4a99e51dd6e1acf3aa116a1b40972eb7a6d6c2829a0d8050be5baf6e645b6cdd448c9bf2ff8983fa6ad6e29d4fd45ecc7c884669ad882b4d3e7a0daefe274de7b9a10a9f04e76ddc41223a275b0bfe888d203fe3d1f86609a9d480a054a609cc8ffe25d80ac2c042763c563ea601ad3ca65489783e752ca1e8ed400ed3dfe9a79b78e39898713c87f3a7f7e039700aac0b20171c9f3ca9d40688c99d7d3549921a14a47d93c809f14d9ff55748309e72812f50202bffe513d3989f3a59cc281849a89618de097f8beaaf57ae65165e062ad0202268bc1f5fc163671725d7b93dcf2ae430cb8acb944366d78afe0c2403c236d4608ed37377f2c9e33e06ee3206b0a16776d74db1bbf2f38d9f1848503b91ab8f5a508ac5db84e138f4de2efefce5b2102b4cc0bd28f597ba8dabe7591a48d16333e7dbd97fb28638d8b4266505ccbe1ff0948d9f080fb9ba05a37bee702f8102476561ba66f0aed3addf549d75ea00afb56f451644a685f9b4a333d0ac8e01d0e2f24583d55bed9e602fbe17336dc6d8a89c6c271db9a679da1263b0bc51ac337393b9b3192f6dba2f4a17dede620a33784821cd8d258de89f2b1c74172e9084c33d01e2f14cfde52977ca864c6562fdec4698ebc253dfd83e2d1f2b13b245c31ba57b6c0bc569ab378ccb2f57c188666572b8957c0004e7f3de21a5f072906c83519e19dee4e0e2344c790ee6ba24b8bf7d99dfcbc66dc3310af8c0de3675d04310b38a26d6e20d0d80479a9dacf30c871acd1a83dec0359aca00f65af8bad79b43246ecfd204991fc2246a71ee667c9c0e829543a24dcca55f1fc01eb659398010253eb07e952a886d5b9cd4ad698e1a0706e415f4b47f71c29afd62abc8132fa51082e15e6f391b62fdf5cb664fdf0268b40df1fb20374dc192b09da336d0fe72bffb7ccb891029ce1b5991cc31fd1c1e5f09c1893ca247c0b2717d2fe87864139ebb0add17687da7b550d9fc3b32536b80e099fd6633fbeadacc8bbd2a7ee518cfddeb7354906656ba758061be52da1ffbf2def4616d006e88632baedf540ec958b1561dba42aebbf995961ba29fb52722ea9e381793c49028fffa4cbc0cd02fa969f6b3434ee7a152037ee070cd81b75e7e00b81ae204e6136de0672ce6d95e089cff64de2d136831c51304f12ab6ead9fabc1d55297e0cfdee2617b6ea2f9e3a3cbbb0fc6cf3c18a8772c3cb0d3a60f4fd53eaca00f48a539c6b8bc811cb54f8cfbcbc48154835418f50643ea5b32c0ba4952f67ac5f0b4054f75968a6d9cc9a87e628229105e0a91d91747cdefc3e6864ced28c063140b6f556e7926b9841747e68292e118fe10709a4cf17b70411eba52e3be1f39d853fcd2775c619ff92633dac6ba097f1ed9cc2f839c89c28477f9337227f3f6ba72376947ef4a52a73aa2848ad2341aad7f6593b51a5d34b74c50f385dd81c0eb44959828a5895069383599c38d18c2485c5b979bdfa4428c936993bb497b50d425c8d30188dcc8cdcb78e54093c2b21e041a9ce4b1b6d9d86e7ffc843329ae9c91b9adb0814c5ca4b3108b5546cf2b510ad79a17df5e15e1ada27d89fe20dbfb99eff97b81f82526d938b4e49b56c76d85f704a85950538f63cfea6010cf0073934aed2fa458878ba6e9a0dc7acf3207a42ee9963b5b3d052ec63a5446509bb158d2b374df41fa6f013e15f5e9926974986805957ef70806cab2032b1e417b22732c61bae91b0010ae95d348364b317f8204597c017bc1693df2854227f40147c951a506cf3680460cb3de6860b01f1c3613e40bb9d7f7b131109d6f48a9e588217e0eaa899df72e12038de7a1458d1cda6c540450621325a0f5f984d14b593dfa3540f281447576100cc80cb64391f9714fa5e0b8fa9ae253533fb003a594ad0c6767f5ded80ed1f8da0625de8642b29f2783672091829022d78df8324887b78738497bc67ddf12b283b611b2889ea3414c765de5d3c6fa46a714829f2a8336c8d318d7cf828c9528b201a3cfc249c440e19b7da5a53d8cc35a169d2355ea70325a753180e11eb286b3256dc39d33fa3aa0deffc7a0fb0c7ce395ec8a0b8906ad8e28d039518ec822ee9d3e6282c2de9eaa35d08950a57f57fc1deb374041aebbfbbe2e3225faadec6364f46cadfe09e86abfbc8e745d824561fc8c21c7601d637e36254dfdaa69314091c6d24705174fab980354a19c4324f8614189937878104b22b8d370639e1ffdddf23d107d628dc699f03bbf53a903be9e1550881e5cf95af48a312887ee5333f9e514d1eae0901978f7dd145e319df478f7a24414d7586de4d2d18f2d1f1640248ecdcee931ad15ffd8dae64691c6406a5f71b4cb01d00b36e900eae5df7afa83c9a59d9b974ea55ee6537e74bb4c9effa239662ce50dc3d57e55a580df1f0a8ab0ee71918b1bd9313f9e19c06da0c9a4fa250ccc2b5a4a86cbe01a490bf189ff6a62c9c609a635bb49b9a26e9a250bd1fa8761715bc2fd6a3b4f2ab1428c757e0615a43eae2ebb5609468ab805be0ea0fa146db1968b3da96b8d40014a57f49453ce0811c89541d4c7f74021f875023b5237b5add379ba16c62e30a335fc1498575368bcfd29d968520d262b1db0c097c1c1a91e8059bc81dc6822dc68b337ec539c0df789d52c6c682dfa2feeb9ac3c352fb7f06c01a062e403fc4321070b49b02d4a44e196079150631e30c9676b9574dc6d34c302218843a34dab8fa14dc8f5c720bff6e00a6fc82f2ba5d1d7c5d2138540bc4bd3269958feddd36b7680064c98acceda8706cac9aa6ef9b072e183dfcecc92e4be6a2e282696734ea7992e5de5a55b80f5506759065c23399858205ecce20d08f08607e709ee865adc4b75bd2f5a02b7e5fbf011b0940b441db9ddc78e8fa7475c5eb66498d56e80c925465028fc1607507c0443ce921fde0caa7309bfa4b6b7e8cd23ed2ebdb2b1a85d3f44061b65832528824aa8acc0fb9313198d7a3127cc44ca5093ed5848fc53fe74cc864b74928a5ab2434779726d9f8a2296f70c0b6b0aeb7355d23f64f9735441a0a91dbb1692cfeea5ffc9556288fae7b3a7056bba8b90a2bbb36ccce96c47def507d3e5b7ac10d2bf383cd4114630c48f24ffd75e698dfa7ba754a288406553a285f176bb84418190813ced846db592709d84017d1a83c99a1666ae3da2c15819a6df93199f84e273f0a0f9a262b97c7599209634235209338fbf31e9e2935768adba88ca47c9b20079fcb060b21b4acb932f72e4fb98121de4b0a26eb7b8daf007b007a8a0e2001527d722c2aa0ba8b88abbab01b9104e71419ef77c4efaa67b87f70cc4036d4a6e2330d4283d71a180094b97cf829eb1bab7612b5c395649301c1d40a27f613e2769a7664fa88018f895701d773e4085f5afe28c3b6e7ffd7eda2b8879b388fbc2d5d5a3a1c9f12fa7bdc04c377cd86cc02d120bca1648ef83fa1987c9e13b55028c9b7cf5f51885936063b68c3dcb9e045ac235d1f3cdae5f2f6aa53655c216227daa6968cb1803e79f9d1e032294aad4842f763121edc3cbf4c2a5dfc544585e8e07562f078b1e375ac178757e1fbc9ee280d5d219387327fef71061f1493ab1c3ed58a8307169392673f79dd028c3b00df69e16a86abc4ea818dbed55f08168915cb062fb9372ed625360ebcde9e45e176429203b7cc4e11c56c6155fbae767eeb75f48ad45c135543cf502e4be9821674b68f59a060ff0865ea7f97286d534cd5a5a8e788a026ce18abde71890d311f13274076ef37a91f3b9678a165b313800de979c8ae31a9ca0793ff666d001b66c1f73829a4ebb79c2b6cbafb0ef62157f5f44395704cffd90e465c890a13aca443e81a779dcaafd6a779dd907cb9d026ad16123982704489985c1dad9589f77469cb191190fb26809e12de945e15ef3d3aacfafabd39adce9a81c7bc0ea8da983f383a73da73e30738cc0973643dcb3ef8d7d2241447a577f3a570283ae7195014666c67203e196bc5ebe548e9e7fa56fc52d488797711c41939d2986f6190662c950af68a0fef490d5a95df7176d7730a3814ce0a6a9162885f8c8c9234bb42e984dc112ea0a92bdf91816d5e98834922afc8a51bfe10ed50e5543b031deb66e4d2354484db141b3c4c702b7cb6655d07d4c1a5ec9468bc1f68e85cc859a222c8163e09851138c8c5becadfbb0c1e4b533c55fba92d2aa71ff58d33d427051c03ca92fcae5dd64ef9adc738607f77d35be93ad829f7ddaad1503b1c928b1d4fe989031a2922bbada868aa0cbda9c2b802294c9f7d5673f79655a8a74231269d3a7c09ea3d03579452127d6eb9de4c0904ceeaf8696c388fce2129417e3c3cb446e4de3f039c2e133e3511caff1ea98428de3744eb20bcd24b9fa9ce2e8465c79047e8338b6daa747d6a6174bbfc97aa09aee298fc223e71ee46c5625556ce5bb6930d60f7a01d6ac0b69203140a51a06a432df7082be51de655c5f065c13605e83d99216cb1512792fdd53fca19501bf976611210179f6cc70aebd7355047dc0f2973653e0fc9e1aec758f18fef66ffb7a2ef0831dc4d46d611c0b6af75ec05e5d229381dd5a5e9736a2553149414a020668a3d69d688e84023519ba273e175e91596d95556a4302f5b7306decaf47ad55563871020ce04b1b6d73939f14721d43d71b298e2f73c33555fbb67099da5e4c937d4cce96f9a1ca1c7588a2b1a40644307c02922b758bb0d6b00ccc874bae3c3614f3c61e97d47689cf9827b3b2d640ba9878071635df13ec0fe1f3765a5b42d94f01be6839acb2974081e166fa034caf6be85941834f7bc5c4239881064742298eb55f0887002f1cc0caffa69c92c29f93df16574279af7e890a57b2c89cfdb25d8fdb258622dfbb721c5db499a99ab399d62d098c8c29bcc7583aa8f6b423ad92242f57a8d14bd511346c2b02fccb5a5180fd4c7a9babb0bf6b04287875f38334bda121a7946329d47d08cf475640ed232c0af5a6474a26fc2a7045a6351ce1e9a210f4167c90ab0b558278f03fbdcb362cd679c688283389305cb64fc87b7a4ee5be9b54a8b0e4dfdae60e03da9610273752592e291accbd256c1788713009c38968cd9dc7011bb39ea508e1892f157d906427716547f7f0f640c6a87002d757d03ff0e0beab26d9ff7c8fc0939f59e5656527f8f75f74261526d3924c4f7823f7452e5221a7efe8688914153d9032e30115a8d6928b1674b44ff46bf3166939c0db5f6e16f42476fcf13ffad464b6244c957d0ade0620fce5ff9ff54accb3c35886b89f1a3e43743575dffbb2d21dbb15a3727eb05af35641ca480ca989d6450a3efb34bbc7510348475b855a131410f988fa2e47ac0147e517a8d1954a708872d005241a2e0f840d59ef1bb13d40118213e2867f21ccdd37b77201ac72ec7309edcc63057760c16e54699ca5bef4900ecf93729a93360fa5db5be3b827a0f64b62b0eb27f7a7f0c13f6ecae5c08493908fe81a6218a14a5130c08ac3dcf9202a3cefdfe943a9d3f73996fade6cd9a0260cf15db7037c6198292bbec0ad35dee7c9cc4bceb7d3cc4f46240b621ce76160c119e4f2daa21af27c4cec8d1f1666c9db2a3dbf98ff9a9c33cf357d82a6d58ea8866ca44599468400257e9c87d0af16d587082292246b95d117a5ead645e221450258ce8c2ffe89b7c962f202a545cdf25f1c86c4c17555a3d885b94ac0cfb71f5d3f4c964e8400ddbe686d473d62191f668ad9e68dfc95f1ad4e0e4b8ceaeb2184a4917720207a071330e3ad10312e3777e27796d48fc9b4c6707feb2149555a65c1433c32590ebc74a925871ca7a62bad1a5f234e3fbbcacf4551d8c1be380db969296730c6060735b5157791c8ed3d714b23bb598f5f7927631d48c4db8dffdbc70cc2fed01a4054140994c31043148c21389c437087750de70d9109ea20c0e3698d3fc1e2ddcaf3ea416d83f953670378f728da7aa96a3f009abcd2e7e671dbdcfbc846a3d37c72da3cdd056295c594977267d339e14e4ffb1c4ab6b6c9a1fd8b08db0335786d1031d9f153e28c07da3ce04c4f504f5b272c1f67b193c99394a1905b9d90c6967faccd0b4996745644eceebed9b912e47d80e27db93e32d6e8fa89010c0bf251eef492e2b6df3cafbe63301801f5381be1eea21edd0d35ab678f383c88cc0528ae6c18992c1958f6dd8d6ca9fbb74190d3634bfad1ec6298a56a3a4b42652681e212467a8b09420a1731d1687e46d10f70311c91d9f70059a94932dbbe6308f50b7ee00ad280ebf22546a2550bfa078e50dd408f13281b60e71cb37050409941a312c9a81fd5da7e5f0a2fda9c456508f7e0842d2bc69ff928bc94a07d8595581feb01463bd4855f052e58a4bd516fbcc33ef033a42335e3f42a91a07652ffb2f3391539a722f2980819bd7798eaad47c0390604d7d3fa96315f79de16010d8592691d1bc9ffd4161afefc43114ff677106bb9efad6633d43602b5c44c0d40884fd6e7d65e76c0c3c51fa90174f46908c83c80aa25e204bb851705da9e891ddfd4ed2f56f354ff332b3ccd07959459da66cb4a5940b0f15e0172a0a2a877ae86f1b0b6160d9f5c25e038e0d11b6d2495c5d09643214c3e01bcb2771501c3033e0dc510da6734df24b9e986ce4aa9c3b71708517579e3a054f44b8a59c8e59cebea16a513606c3d72f935aa45d68d667ce640626fab41ebe33411cb81b16572f689270529836eae4b1807f1de091e0139729ce32c9f85ea71f9b111d1e130d9c0f3d1f9a716adad976b0b4cb2f19b4dc7cab062d2526fce0ab639032b79f423ad7ddb8489115ff5970808637095b05228cc8b0d12d7a5067f0a9190439718c2e2a3221a5b021fcbada0687e0690dc494a4368afa41cc30e5e202741c818bf2e409badfdd2c1e1258e02443738679ffbf90850ec25879695fc07f7ddbdda4ca9b944196ed7f165d00f8c05b39da2f89e68bb5b1f8efc5c264d1c3cecf727e0ee3420722d8fe5011f4dcee882d17cca8e5809db9d3bc362b42b4756a06b8932358c9066865776828c493d5bd99da36e8e504a09cd9e4ffa59da782c4bc7808dd16ce16429e6ad23d99d9b327d7772c58a0f0e26000e109813a508e89522a358e09f03e66b856e2fabf9e6b9d20ee8e6d2f37d69091afcb58487d265fb47351118fe16418c7f19b62e510b122bfed292bf6cf78a1f72059428f66ed4d72f5088112c46166cf95c1640985c9636ce36b5a9af0d0b2271928ef517d0c2977dc0f6f2873c038ed6b3a078b70e71a7b85e3bf424b14a2652cb2aa783f2dc4ec79d5b5a72defcf7817a66fc49cd5cfff9a84faaa7df1c4e8a1ec6bf4b5c349a859f9839709bfac13c7f2532233cdf95dc092aaddefbf561172b4515c8b41532eba81056a35b1104b069d68af1a706067556d0f134b64b8620bac3c964c13d84242be1eb85891fa3a9b51ff74ac0342217bad6eacf1d14a7b2024b95347971337626c587b69576faa8705f5755c2941a69f4eccb4d3a53eb8ff8b11c3744cd3cf20bbfe4c2cc29161cafa26cf78cef301e5506f42f45f26676c773904a5c4528c23a75190e8d97c4ae5a94df1a0829689646dc640235797448dc1471f801dab4481fe05ab434550a08c3e5a881a8a402b1bed4925f707f99717b3748682beaf1c3af8e8ca10aa4ef49b6e2f20b3e35028bf8a393f15cf9f978e5e24c5dd0b377ad382506b6ed19fe2c772ec59ef4d88be4cf6dae017469040f03338a4fe011608a0ae4c806f8296ed9f1c66ef1067967f1e63dbbb9c50412429b2db0cbde67f2e93345ce1d548c262ef13a35382f5bb5dcb2b10f2e88510db1e7bf61928cb0796257e9c9fe3e548009c35609763f5ccefd28f4f8290d7d06580f28a11caa570cf730d58f8a0808a1ba6caf66b4a2626396bdd12314536499606a1e5523ab22ba37219e6f982de6d40f57c5d35a867887dcb55e03bbdd1f658f28ce41416b87562c17a0525ddbad348cd325ed4859d1f62441fceebec50deece5c1362315a1d27aa2c5a3151052158c27a3d45276d280b2b18c3749485f604d8a79cc2e4e213db2557fcc5fad6ce0f9e84acd209d31f7dbbe2bae10a2df9b8b1cd9a8ebbe8ace3884efa5ef1f3ff19d8f3243f96229259266dc9e048461dd1f17ec950218e5f8a84d064832dd42141471a5bebc2a420e288fb4c1181c63802f1f8fca121318f94779400b64f6c34ecca6685d65712fce7e0d0f4e940e353a34795de597b5b749f6723df9e6103406e8e9c25ee26eaad8688a02920fd4c109b0484039f05e5842259c32c490469d555b3b86c2b5a6b90108caeca1928f3e6dc9d9b000e05c82822c157407b9d6f957e6fec58836b635d674e3604c16abc0bf8451cfcd07ec1c9a2fcda4510e8168b5fb58000ce63dd979a956a1fb131b05a0112483736617c0c018bc43b76f187b31d55d6ec13b706886f977f7bfbc5483284cf0592909ba99324fded487caccfd92edea9b20f02cbf026b1edcb307008cb661f02fd87e67faca88fcac39c4f3c8813c0f9894857e6464b29faaf37d8da848c25b6b6ddb5d5ffd6cc250b5e97129ee9a614d38a26942ab78f84c5bb695b7110acd2bf219cb5593644141ab9638f82ce5a5c2eb9a36081c9e9fecfdbdd05a53215ba25d95c36b5778ece180ef6a051334f8fe84ca3735c3a23e4ca0de43e757a7484b1dec5f5f62a4a6a9b13b1d3f63affebfc7ff74a34fd108591bb4a4b6b79c24922b92771fd36d2d79554d7676d79447a826928594a71eca9b6ab0ebaf6e81764fd252f28b659153cfb5d3739f0cf9aa48424b293559f2205612fbac19a632f23ede5528366e8e5b547cfef72373b8f57b1197f48f7ae1c7ee9ce6809853a179fcdbf374f2c825be48bc3eb9b84c660a8f3949f3cb1dbb1e35800a648dffd31df2f5094fda2837d0d2001e9aa7c006fe02cebdad2a6e721e7a6777e6a5df425d888f423b58bab553481bf2563f5cbe18271a398914f0add72bfb96fd8c8a7eb55a4b7065a1936bac84f94db4a74587da6ce8c0ce8c2a12a007339d8513e421660518b5cba15b861856a38a9679ccbab471f84135f736e5ecd5a4a18ac1e18e90502f165efd8bf7472b13832d5e373b8a68fa59a537086674cfe4a7eeaa9b2ef8702ab03b6a010c097576fcd93582f7c1119cbb5b10b8e555c8dc24f4806a04ec3ab994a421a8e52c9829edb7b985c2e5228d9b79f5b0fb9ca5acd99ec275bbcadb4766830475edb9bf36cd54c424ab9385f201951c5b3168fd849c10743fb7660dcdef1ce583a7770c296958d3bbdd873eca2facca1c632e01098edf5280590a3a42eaf918640ff9ce3974dce6f708239d425dc70c7a8b5a84929967e8bdc54a44bb9352b5a14be6ed0e9c8a4ea87d0c623b1437c2b87bf53cb5a525e94859ca9c526cf9b8621275a4162aea1da338e5659be0e302d5ed300a0717d7d6eface537542a44651ae48b2d9b64189bb205a3bd4ac4d1739c560161c0d71f37945cbc19f4028989dcdd8b90292f094549f1254fadd060fefbdb4248275eb29dee6dac93f2c99815d5fdae6f21716619a827de3f84447c4582896d8e05a334105697bd4222cccc1c2802072528236b90c8bd60cd89173f6725a738341056e9338c8d2d8195aba3cae6b53816da4e21c511bb4cb532035f1b58ddc3b326992b70cdcbd316dafb5e7588ceb44c0b7898e48ca2f94d1d469b31571ef0bcc3dba98a684fe17c9be8e82c08ae58ac285cca877acc090577e63db1286ac8b575ca6a3b817aefa652cfe355678b38d7abc0b8aa9ab107579ebd6633684029efb196e3fa502b47c36dc81a69e08560c2c3aaa5dec8190ebbca68e3a094a4268542f8540464b0995dacf3134b9680fbb7e2eb8bf6911b27c05131ed4431bf2d89383823b7b4b6a40bdc5fe749a59198882feebe9c6854855c06f7dffeff3affbc893410e7b20f5ac371ebea7385b7422ef8f026a114526acc0f97467a7da916c669ad13dbab4f2ed004ceca2a8acbbc92980b1cb6bf2b5b786cf9c4214c536ed6e1dd5a1e0c9d75be3d9d9463f019b61e1e448cc6d65f4c8fc5607fc1a8f09c8babf52c4991bcfac03e1b4668338e10507e851f8dadcfe67e1d99af8cd8720a51c8adade98375421630ac69ad49a93006d6b3562203ca0a0bc7ac96460bc39ee3a526b677565d7b6a28aab169a4c20b3a860ab2b128bf0d6d771891bed6d7d6e39e1e1a34773f483b07c9a18a151849f772862295adb1908eb5569369a2c9722d74e189d8512bca33f546df29f9777abd493ec6ce4ff0cd8b451e5e85246960984e83e329ea0dd1ec2b14e224c811a06765c134fc863b1aa0ab1952b39402de25d5e38f0a191362ebc7a03c96bb398f9ae6f5a8dc86a5f4fb9b8b9daf5e6aba3f168cd7c17c3e395c29d603080a179a5eb31042e7f5e3ff64f2cc370976a61cbf2286481741c0feb92799fff247dfe0f21436e8c7632988c78abeee19e6573092ba2925b568d78eed81020cb628b9e0035fa734698f389209c2c0d15f150f2aead3ad7b076ba3fefc06b536e1379e66d2eeb9881d29811a55c1f1a75e3f19c730a9b8544c2cbe24715d21cf6a422b89adca8a356044c67bc6006246448696c1ab3396e856078224dcc2805c68a38d81d149b9f0a89de99e590011bf8b10c600dc14925e7d1002de4ef6d7e1d009c94e6387c06550fae453ae24fb31d496eaa82b678bb4a8d8c13548444891666f814eb77c94e93108b556f7d311e32a64c703b1b5339730fc3f3518450286282628e3d429736c91cf85abf61d0a9f27246f9c9a582eadbddb88fbfef196292d3083757b9d3ea43aec0af59003f39c8e6ff8a9bdb9c99dcea80a7387ff682fad9aa465eb4f3f0725b7c9292fa395c4fae5d0bd74f7152fd767639cd75c93fd38afdae4a24024cc4284a351b0731ab77e79709c27ebcf34997b62de303df572909d249cbb3416ccd47cadf4249caf131911bfa2309d7287e08c4cec067e95ae62bb0fb47115d5e248ee5de52b91e07219708b10042dfc11c8fabc553053a495bf2955499c0f3c64fed0931b686d3c2789ab38a7ba19e94b2224fc16e0cca8d13f42062920688dae1f16af1a79fe2b238a417aca52214f6823d8f7009b4e607ceebf999b99733e289789f8a0fe04aabc04f88783c1c48958d4924816ed6f527b55361c1227fc1030a5189b5fbd622d30ff5bfd077513302a2325522aef64912abb89174be46fbe3d04bc3ef47f0b3a8cd9f772105303c36787cfd4bbbacd38767a9f82df7f149b5b9de2176c5918fd31a82b3e721f5ed928f45fe1bfd6cd02763bb7359ee1bc55e1b4d29cd1e46110772d1eb84cac9fd6a7f1247b70e110f421a0402936b0b3e019f79886a9d197dbaf8b2e1ee4343a903fa0cdbf8d727f8b15af818c193d630dabafdd158de7e21d10e4666834ea8c240ef6059a354a1d33d27aa0409aebf7eece00b6e65e914ee65486ac69167c1190eb4daa1eead35dc77b6d1512b50584fac6822c40feeca1dbf1735cdf2e59bb6f07d75d04edde1fdc439a47b2fd8044228c7977ce9aa5534065cdeb0576e1ffba96025c3b9ec1eecec81bee5be0784f955e2cbcd2d95b80396c319c9dc4c7e5c82da6e07006b515faa185adfb8c6b81c4940457e1596e7e62589714c76c8d9086ac1d5d833957ea88b67ad7626e842eca772a0b13bea6d6b0fed285b6507b1f95579ea44c00490b19d40d54c743047c8bd4487b0adc5bd273f94a77c26410ab763e2866a2b9a0fb918c5115bb077b5d0f1698fde5980f4af5ced720ac22f22607f4a02d63dd61a9f07868400e911575867e20718e09d8397a6d58ae816b15185b6c2620a653fdc50b741a46da19f6e51c07910bc881d74d6036cac6326da0cac44d5ad0001cb02aeb37369e104c0235773da087672e9ff70959b2b4b065ceed78cd20c411f98dc2aec439c825b8b175d1c38a303f500c7e1654e43c71037aa021f1823f8aa608b07542cad55c3697cefd3a07e7f0a5179e959f04fed813dc13f573d60039c427645853568a6fb5ae6f200cab872b6adb9fdb29f4b0a437433d29c4e546078c51f4be226fd3e25fe6b9408eaf0a1eb26e736762c22a6edd9859f95148dbba5dd8802d582d9efb9d04cc0bd38e1e45360120890988b7fb88cfd9fccbb9254c6c5df5f74d7d49f784fa02cedda4a8cb1805f141c31bf5d9b13e290bdcac505a8694c794da2daae64c7cdcc5ca2ce3622a03aa7e5c5462d50a1a3fc2da2ccdae8ac9c2e038e88946035e6b301cfa146550208dda3a178a421c236de03e4fc2a1c195b5bc186abe189fe8382f5e7163e09877423615bd1d413c27aa98e57aa638444722e14c161aea1a1dd66a01d99885dc0debedb0d8d4bbf6ea9988dd3c83d4c579a86ff2ae8ce1fe75afbfdecf578eabd9a54b64035ea8932d5ee040ad34ffefbba6bad7d159e4ed43a47c0ff012c25deaf2b842599f656ca9832e3e7c4c7d9403e17baa3696422ff492d4f50550dc5fd2d3b392b06717428df0e2d6390b7b8a08e27ea4ac313b9ea7f6b0681c6fde5b329d9a6e2e998a5ba1dcd79843ecb250134dba3aab6649aa32afee903cec35f2c69b04f33594724310b112e0731b3fbf4ee5293addf3cd84080a5d4f88bd20304c1f7b65443282d07da0f27e164ca9cb9dba1562e91f3462d6328dd3ae1ca17f70bb2dbfb2dff54c933f431bb5bcd8384c5a21ab401f94b0fc538908903140748b6d85d017956c6bfe5471674c27857b91817b726eb5f6ae19dd802e999d4b39c819a45a688ee89f7b440151d900defe0b2cfcc6f7c388b62d4b07776a310e74c1856c1f0bd7c7ea09dfd380cd3c20983f5a0dc066e1a87081efed0811de9acbbeac0dcf5460c43bae288171af7864c04f65a96e2e7dd51446c2b4c45d37de25b3e0bcc3404bf0f5bc5a148b932cf9eed28a8cb29e90b0da22d17184c1538080f0e12dfe6c41481c9d1e24470c1e4dda780014b6a274524ad21bf02fbb39d45d7e34be1498a1aacb1ac063aca8341f2f238b45e8714a7ec8028594072a3fcb0cccf24da34fcc0db3f1adc5a8c30505b86b5f12d3b940b37441c2f028122995c81438974561572074b4427d7c4f2a7bef52e3d6cc09b722ff0f31785196eb4c1a47ce60669042a162a0ac4f2ac79c5afc2787591b2047804b8b8ab2349e40ce94a456e4a62cd174db0cc8321e73bf28a0d67655b72f594c12197ae7274fc7e046f36e850cb3978e74ff7c024112b020868c53898d5b083bf93ba04db00f703fda78d3a5af381a8dd0e1bd473cb9c7d5fa235a58a89a928a294af9906d011c9b13e02545830c6d4c31f9a4c05a64f2c489c6414f4e566ec8b044d1793061a4af2b97cba2e52fabdabe4b2e76f0f06886497eefb343c437d459bf5405b9b7aa5add6d7585d50c996c1da9a6928b57f47f55195aea41f53c00ee51b44cfd4b2a98fd1a289636368726e51e95739310c090c1eb42a5124001cc2e024a780dbf5b94f001ac92f74c76e44de0c9552dde6bd86dcf8e67d647221a34dd83cb6b02167d19f492d2ed1e37595d38421494e347b3ea2d819008d254f7c3cabe7127bdafcae624920dd9eada3871287972f2aa5ea205e2322b6abf6c6b28554d705058fa7771c1450e628fd2c65d7c1b1683223dc25888724c038cd99217d10b7a9d0398debcbdb92fb1cf51da7de5e12a2bb2e1283741d6fbe2c4ef1acd839226c0dc491a2341ca24865b8f977cfbe537ab330c9ab4a8826fe57b25262f00e27feae5c9794cc8d747ce613e6bd5e31017dde9da1b5baea931ee46cf78cf82426e6ea3d8c568ca9d08b6fb3e7c3c19315e5acc95c4245cc155959bbc8706d649e07eee114ea0a54fa8ff76e0d25ca70fa8b7826aee17818ba83af7473bb05b7f343125b331f59c6e8c903d6c1fc8a27107da5351ca95d13889caa942714dc236d8759383cb95a2c4622c647862a1dc8ffd173878d37163cc776d26d3aeaeead7ca28a147330ca319f040bbc28402169c6361da19aa7ccb54c2763763acc8a44319a1a74c42f06df7bd4bc55c76270a57deefe4e7174964c14a167d9279a8fc6e55084d3d07d270d2eca350d9228e9a57efa863795580fe487125cae1f91624151a1b432d5fdfcc5143a1a8f18c4992cb675f9de4b6e1592f1c749cd8e3b642b491dfa7b0759a2b2f3be595c55ab09542ed066e082ab6af74c5dd3991952d6f12a9cc653bffb68d741d299288042adad11090ff6e9c3111c29b4239c763013a7d016a62cf711354a6b4d307834660f2f7abbe694f882812e5b865804d10cc3a5f7f86572d6fe7dd8685082b8d769fba4b4a5e3e23acd93df6e693fd4e2051167f0356d4922f17b4b97c028b771e15c17eff8b5a5310684ff6634450c7fce1bf33fd4b1ba21eb27dc115a163501969dd5db0bc694f50e5df72af094b895e4183c306cfa6a2f04be2ef28ee0bea1ce062463bd5039df8153f70b73c9a358f5bad9b5ca1114ad1894431b533d76b32bd4eebd97b1688a17a8bbb5de76e79a490570dcf645746c9a4eaa1a3db2411c477bdcda051d3562f572996b2e1f4435a4b05e53697c85967f6e752843c5c171c5d78a4847d991f947f2aa73901cd30aff64fc77ff705b7b2555f9b706c21cb217308bf592d1a5736b309cf98211a1ea56d7db11255b18cfc451a87bfba83cc3a3ddb55303ff6c824185b1878856f6a0196656656c44241feefd6ea8a28d12bb35f923b228b395dcfdf07d09c1873c695812fe0c8cdf6834a7996009cddc0130799932266b0c19806d2e508f687b473b7070157626d4adf0f504ee334bb4e4bdf133124bbecd854771102ac8562800480858f8220ceadacc35d912b04a7a3f8dee35004cd71deecd1784b4eb12d5ed47e1957fe03525e58c4f171ade32fcacdc8a59c7da093c8861ccbd7e68744fbdc79fba45688744915ce3f492d101f8118735ca60eba1bc064ff37cf3aff62b44af7555088c18e86023f14e03e32d6fb5abd041ee961a8895af1cd2986724379d94ab12f863e853d27d58b51d4fe014d79d95831f2943b12c63872d29af311bcb547ab0ed5c4e730bcd32d7daa4641858c24eb8e7cf6cdad0f2ddc9f039f55532c2acaf6c63cac38ce926d46025c1709b9cdcfe6d225d2edd116aee739b37db62da60f807db89bc25ee177b2e35a664902b64616a148dcc74226dcd8a6bc30616b2e01b75bb0fc727e0c80b315293909362d2681c1539c5a1fa5812c732dc8bac2b6f6ce9a752290eabcb5cce09ebcdc57bf3dbc2048d98ccec91ce1080e77c192de87ee526b7cbeb8f49b2ea93fa841f31099754102d0eceb6b71b1ed48e59fee22b17eb51b21a008ed54fc44edf415be1d091b13eb99ea8a4c5ebdc572de8179c628814834dc5e9361c3f7c7228597e9114a231a9b3dde3c38433a001cb06e5ea5bdc9a7e36973ccae55e8e543a7dfaa98bf77d7f98ce35718689da5b418f4e8a646c63660ec35f8ecd441a5cc71f911c4b0fa7b5403bdefa77711d118009bf487c7aedee3b6102ea11e6aab66f3ec3446ac5607d6e07213a663402a98a061e8a3a5c1204b4c47010f03002f950efd0632c5c474963534cbac789be4d6b1c7914e201dddb95fac6ebe2fa1f31926724ae0e301426a20d9012b039c8b334ffbcc55f56a42b00d620dd75053e53cee79089a8608e0ea04be4c6e20645df3fba6126f6308c6c5a4b8cc38cfbc4671e1a938a45fe59699d51017f2833abb14d589d40a31f03c0d8b9b9478e2bae14a9b784c0d95ea00ff59f1a5164ca54d22e354d6b5d575e7c490fe95ee1c9ba9e8403f87828d88d0448c08a531631ac3850c7b0f9f393efa096df3b943947fd65e997d5002ac227e9ebcea0274598690a06edc09d4bd7db0343a3c22565de80b7dd14fc0d58564ec61b1dea2afd2f3155f35c13b3aa585e318f488373cbc5b5155d756ca517263317bb42f30927d8efdcd67443175673196b14da1d00112908237ffa5178e10136613d2fb8e665175adbe6f719d0c818f35286cb9d0a22c4ce5d64f874eb24cf7039866f2f5a333ffd3f946bb163ada6d61712ea88546422e875a46d55f50100b349df219693a914e17283e3f6b0517ebed43d382cf523af95780d4667ddc75aaf182da6c5a822b5fde01e779ddf66c5e23c16976d6132a69230643874cd34ef93ba053c7e1a665022a4fc5f6158c38b00e549b49dc08ad5a3aafc453db0cc7a5c4af944f3a5b4e33450283d9911e44b5013356319e3c393c9c9e8a990c0d9d34893c91e8250a67976e38f9c216f9bb7a3ae783b9813940033d75de509d5e349aea2f0f87b50186cdb2dd09926602f8653186360f56da93fbfe4c280ec5b83132d306aeb119479f718474086cb54e5893fe461b2eccdf73156c2a5b304621ec796710333b3b0356b1ac15b821ad691fa0dce0fc5ceef60c06b7b1ed52a0de2cebdb48e6d9317a278a5a96cd7981de76af53aa2a5d9c0785041befc7687295afcb8e43af3bb8b287011d58c825c3617a7240bf83cf2ad54a0c320c2298e6796b262fbbc00857e44b0504388f626af881b8652200dccae7fcafb41a24e28362374d3c276292d18e909fc88905a3fa39800a5b77417c761e9b04b818614a749454eb4ed47825c62f4e6b5b482b8a8abf35eabea8e4995db5abdb93efa52925acbea1b04209f478cb0ac9ee40efd03c40fb07ffb6c17307394c5ed67203163050efb2f1e5a2cdb33b9666bc9ac5c94f03e816ce4b658d6347e7a9337aa3049b04bcdc6194970d0f8da47bac530706fe461349777309e8dfafba2540cd32da59b8c922a2b687bdaa9a8f348892aba133a4e5dda13e4febb4a8e7b97572c5ef682e73f98e867a6117c4c32331dbce2b1672e1ca6b300b9740696356897295fc25a5c181890885cb93b0d358b153a0a1566d0b9f25ece744f54cc2f04e9ff1e3420eca7c622aa40bac3f926eb0235765f31f6a95caf679f08e464db8205d33ac67d66bc205baa136e185d99a5903d42c659d4652f0535e7a87cbe1561b0dab3f49f1bdee8805411bfaf39570eb0cfc7a7646c8eb5f1a34add505a0659aea9ccc63d9175a56e2ea629e3d047968054c712882f45a78aa9de0d7eed8f3c2dea95455f2c5d562cb9aa65f6dc2b91d1e69b75cf824e492790229335b1ae0ccdf459155e1174759a6a50211e1a3150853d3f374360c040a8633ad73837ca5cf8e8109066e8b60141504784a34f9c10bb260dc613444b0659c7ea4c87f0c016b54f91e347662c856355492b82ce1a0801375a34a37bb99a4a0e956a83dcc65b4ed7f8e6c6b7f4554eec921e8b5b5e416c673bfafb1bbc1ed8555fb95fc5264352d2a0a668a5b0e596dcf5837ceab4eb09620d642c6be81ca18167d67d4446e627b3d23c0388179c052c0a7905190ef7429eb5f3a37003c56583ef6c3a91338399e8faf88d2b57c82b751cdd8b0bbc55dc5081332e3aa66f8aec10735c3110e8e3bf2a3479265f4a88b6a8764c5918d152608bcef9d14512807900c62b0d690604a6b0b40e9a0af6be924405a63a1c11614dea10b6d47250f0424ef9170426014bc23117db4a340fc3046de3021ab8aafdcb247887a573b8786c3a2c3698afece45d969ab9981a282f8b1b2b2b416d8c51c478992622a350d013e6d27ef8cb10c9c359c9290ac3c827f60cbb82161f3714ef322efb31c063856ce90f509cd8c188c61af9c0d65361ceaa629ce59c9f371342ffa4a3db9fc49c7a4048acacf5695518b68d5bb63b1b9f99b699b2e56e12f580960707d81ede724c4109de85349338f092dd036e801f5804be220784ba256fe024e92436a19a5f8fd7a3bcc425622c236bc4a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
