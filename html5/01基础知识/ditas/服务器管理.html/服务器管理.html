<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f0add10fb9ed1405599ffc51c41ed9e16aec862188541871bcfe15631f2ab02634ff6204d843ed7727c21443df07cdeb768e69f68bdfb783695df568fb481e4890cbfde25b372c0f669e1e24eade3b279099e62dea9ddf4a8f84463fe656ea3db6fff066446fe710c73aac4ebb9de71dfd0e5d506fabfffee7de8ba8a36bc3eed2adc8aa28f6a0ce16536c55ef309275db0aa19685cfa5b4bac70af3a4b9e701ad97f4a2cffeb82b239e836a367db5aa05d6ccffabef7014273d8ebb503c249e97ec02694c077979e019c796f190b22359ea33289f8cd6e400a50fdb56f3d0cbb8e222064f5c812417602e24e14bef3bf04f245adb42c700806665b967b08d0250d085e64868a591ba971b4e507f863b8ca2d574b1d99efefd46dc172e65316520dbfa7188b6952e41eb61f9165c4e4f4fb1c65433ecff0f42efe92a65d3b76ac8439961c72d4e23674fdb1381ed3cced69c04864d0cdeb666c38cb6afd16b6e4c726be66ed7a66867ddae6659e2b4817978749510e575dc8631e694da463eecb4ebdad5555cad42c234702d28ac85ee03b5c41085f323e930b812ce1c5a0f78ff7ed65999c33fa3905c26ecc24a871dbd35536f8e0f50bc005515eac181eeea4be8443473118b7d4abd7a229cedbded852dc87718f8bd745306e167181e08b61405dec0c0673d9ace000102fc069d0b0ff1248c4492ecf7809fed5c11789124b0e9847da79a0577274c7610185df4c9af222eb64361af6b43e0bea6b94bd6c1c524e65e5f10293fd9f914399de71da59a1e16798e2060bde8d779019bac0b0c39d4c82fe12eb328d4cfcf8002564969e66844a72f2105ef1b951c57115c78de6e6c30e03fd0a44fbf92ecd6a08dda3a1a2a20b76a0eb72de2e54d0b682d3a57279bfb5f2f81142d1eb7bdd4327e28940ddcefcae7ddd77ebdd567d10d0a1542e633c6aea689e5f03a65c3c078987ec461f3753496399827223ff18ca43c9252b0b9c5dedac768d22f2afd97ef22e9cba66212f62783f382e94d24990e31c11a94617419563567870adf8fa63dc67f24f92d9d70df6e50429fc96f0d2932d2cbed89d652204e067b11e84a49d16de30509d8389037c15e5a221814b7545dbd55f31fab1c4026777c5106153a333c3e64404204325807ab50b19db544aadcb8bf230d8b834c61b602667b3e5cc74b3592190bf361f58e8f30bc95de9d3e3fa41b4ef3e17d732880346e24235f17b964a0b647d35f547ec81a5c8db4339db5b02dd799c3073ce72c757537cd6492ee4402278ef6aa82ffde8610574298889e96621cfa6ec0e1cc182349c0cce402e9b2fba4a72767a34ede6edf5b4e3be561b22b82264a086a14d0e2c4e2f258e0dc76c297af44012713b8c485c0b3021dc13de868b83df67b39c7fc12aa69ded9b2d7b51410894af9697ce1d240ca70fce5dbc11fc17deb3a8e4d2b077a3cd820eae5309e252fe23062f146771906cb930486bff4a395ecea28fa85283dbecb6cfb16699da64eb5966f0d9532d8c707d9c4055b22686ec7fe2c9eaf38a1e9296b3e3444af3ad9477231de66af9c52f553807e6cfea43d37f57844888d413584360acf93351992c69d20fb826f3214e07259dd682c29dbc0570eebfee8091dc36a3e5f396bc50ff9737be3a0d10ac29b3a9dad2ed0c6685b35982b6b2379033e1beb3252c7858247255895bb9081a36fed08a055e54b86d5f82c7b3ce5aa6036ac3b3d1646cd6588114b1f4f824af407c5cc9fcfcdab3556aada3db598ce146c75d540eba846ce92a41c0db3f044eabc053d4d7b99afe67ab3a44cb1ad59b558e1d431604a3eff9e18dbadb9c54640a56c707d5a4d97df3d9871053e7e3665b0aeb395216035873a042c37c06e19f07fb2ac3dfce2ca2653b741a0a73c37c792b75fee63f6090a06356cb1f756786e6ecb8178b4ce8b11feee16435e32fa27b0dc5e536d84998531f9ae20c94603a42afbdd3a4347cd308dc4ec0381f77907b3d346fe6ccb2ee246770ca6392545f1f88aeaadfc145fe02fe1df6e9c2a4f0de77267e867594b1fe78ae7b44a104009acfb2fb71dc9697ae995cfc510730e351893488afee327a1965aed19a1b395a8f9f98eda500d20405bca7c44811555984412f9ab829d0e7d5bed7c97a23825cf462d54bd3bfd127d5dc050922a5d0eae6772cb26eb42e82394ed8326caf9e3c1296214014d9ed3d7462aa2a2e58da16e2652d5c9ba4bef5e424b2e5b938817359e14179e709aa1d71ea24f6d766495d6676d455f6cc979d4b247fefefbf907817a126974d6475d133d48bcb177797bb15206aa1d385c59d6963dd71c33991a3c45fc0c4f2c65cc981449103d0db8b1ed03bc2109afe58d5d270e89d1339a8166322a1b418fecbe04f8952ee482e947bc3ee29eb63782982248823cb05b669030b509fdc552987229d1ae9e5886252868e502ae1ec9aac2e7c5fc329d01b9bd98012c94924b4618387c1249584151d01bb32adc6935ec706a956f6c571c58a69a91d5381e097bb3b906b96a3c0a44420fea67dd128eae2c6c6b1f875fa3eee093db24546eb2ea2fe4669acafb794618021ef147a70b08f98a152fd4463bb7e290b9d558d90e56441c6fb66899c2798458ab70e4d9c1b14019d42a4e540c7c50586b3eb19afdad4264e535692d7860b5ea9cf3761d9840a89de92edf3839da4d3c2d5b2f597c1f32e9bf3b057633af81a3a237973352f7d6c9dedf805328bb6030c64eaa44658e05be9f8d56b0395c8a1d8f9e777597aaac4c9275410ccd7ac51dbf62218cedd9ace2a6aa5074238dd1e2f3f076a1b0e294a05148d9534593294f123cec9ea72c214936c541b332528b2baf110ecebb296bfd101bbdc0c9279121f0f992cc43d9ef4842e354e0650b1a74d7e3cd0cfb9cacd82f24bd45d80cc60740cc6efa9c237b5a73ff62e09e708ce2e419404d22ca3f443066c6775782964543661be342d9fb55cd58861005860da0bfc64bc94ef4800f71e183246b2349eec95ef844fe464aefd426838163a19dd93c06f2fe5cc2ee4b2d9bcc757ed0d1db94dc14949a72d22fe7f7d101e2e128ca55924135104f1fbb6a02b136a6eab410d221f35cea12a152f157264f297db002d90bce40e74347c085f8633b299bda8e5d3875dc3b728c974f92265d5bd262f56cace04f0c5d86a17525e2c851095786c279845db55175397d0afa0f41a72881ba86ee3717887d0d1bf53950fe3c5829cfdbade3a8539109c504ba99c72cf959114b42e330e2fa7c3c5f170e25c5298a6122f38476ddd742bbe8348f8cb1806913178b89fd8ec9ded8ba8b93ae713aed1f0b6a769082be6a7cb57d02d202fe7b4bf700b7525f8efc07fe11d465dd48153d5f5b485647df1820f2c97d7a0e188b56e5ee12f7000b4724ccc7fc923428d2b675f1339f512755306dab6dd9f863c2a2f1c3c35306fe89e7524761cdb18d30a79a210b2efc404d431d4c7bae3b2b72304e6a95ac22243c3e4ecac282a92d89336bbaeae6cf2d8bb4e934344b77407339c137ed65fcf18b4ca9ffd99ee390add4d06debd2f023f1ea03831ca950d8fb997ebb9c9adf1e41767b9c73a83edcddb4e18c2d714fdac9b06d3107d507f645d0d6303804e9e91b1f13060af7522ccbf44cbeed1eac3f624b96251f0563fa86971a56ddc8b4e81f7a0612db795a00936edfa9f3e697dfc436b386f9451fb8a51ac34e0d9ead537e4bba0ec11005da06f3ce17c8c184f18b6138d9aa386ecb7dbde36d44f99fea6a5d07292032e4565bd4f4211f3ef64adc4eabf96f6de08cff9de6db49935b3f4d933ba34ef92eba61f2a760042836bc990cbe24c051554fe358f95f51fac67ac0e952a1a7b719fc92aa5939aa5846e0c95eac8fa915ebb773761bd7c6fc9a536b9e766e45cba897a96738177020e31fac480d0b3ba5a56986ba8083be446430b8f36ded401cb867df888a5457d558fdcd3925140de75b79a79d9249dfafde0e266730029c3ca6688c0689c36a369168cca54f484db3b4577e956fb2fc1019dfd3cd6c523bf11aa77793ccc5aa84651ea87627cc326e1dfbb12da1ad6a3c8b3cbda41432bcda5f2310c2ba416245304ad1f85377a6b3e561f2fcceddf99bffa1752217d747f017fd6768b8903a33893f008e7eca8126e511b5fd6ac88263ecd6a2ab4986570624e90c26c9273460373a7e18d55c430e2ab3171299917088779f3ecf52e29e766af95d38f46ff769284a2765c48905abb0c09ba4fdf30c06cc0592c2eee7433e0abb82f9f043f6eb298aaeb88646b8891bc56c4b1e908c277c509f6a2b65ca5e153305afc43a16e7c9ed52aeac23bf3ca6ffbe8fb6c06013e75cd754a9eb0c23c8a9c72ad89ac8995be375d0d87d4265445510213c43fdde72e422a3eb6ba12f90e94d9c83d4a214e74503e2dda4ba213d36f77a26ac19cb329caa4be39a8a1d0a2686a7c7bbf061acf4b045479b292e06a43a99b33a259b8662a4d82999f12d014cde29c7e632eaedba30e359ce9ec29bee8fc6c45bab24cd71ed9dabea8b22773da2b568e7d8fe0640304ba8234b0efa726d9e0ff7d3215ebde5e5e029dfe7de605b80bc5552066f4c2eaecfd66777d79f5fae899ba4ed8980a78eb62591734d2e72258d1e53316178b4a2ee20354cffadc6b1f8bdc35b8d5218bedce4567ce7dd7d5562c8f50306c6756010464b39bc60b4700e4d6d2b68982e8cd94b4f3f52d09a45ef7c478c96d5f3c5c94820c03b830a63181c9b9912a4130fa0050ca80dceb8f4ab579dae078dda4f9f1858572303f504706e9fe9726a053043b86afb618f6fa5046eb3ef33196ced9b24cc47af03650d1270372f07b69b5feaa418b5cc4f3f8ccb0ab294e481705d5ba76c2ffab23149aabc995d48b5125e6e034790ef170830c037d1c81a478f0140a58bc0210a657a54bc942b5e8d7eb0c30dd6f2c578b347584dc4a4504ca737266b114d1a352328b6ad7e0f76af4404bb9875978d905dbfcd7f5d26f93a576f9b7f03bc9b2c083848f383e008258c79447e9dcd10805ad20572059a668e51ebd33aec43469c636edb328f47dc872220323d25349fed7111916b6e257930a3877b5314f11fcb18cef5a8570afb4f3e0fdc752c751ebe2a01b652befe989ce2498d906d5a087028ff9755f09a26f42c8f8b668bbf1cba16d9172a9bb32784564f20993adeadb825cb1da3d891aee994db70315167fd4383f918b5f75e053aeb1e09f3d95a8816971905a6a0429e64534fa67a2b61de241e64254b957bac760e0a1cac31c1d8b5270398ae29dea1f3bd54750398b66004ffeeaf84066a8c03310385eeefcb7de5ebeba54025bab61498722f12dc4ba013eeeaea4c1f4b84dcbe5c83dabe0263613e5b24afcc7aefe0948d1f949e48d2aef037ec8ead2e3cac9626663b86ed576f28e56e3aefe92a6ecb704b1409c9175c1edaa4b966d8852ad0d4b9342638a6d1aa3277bc51da05e3bffbf4d4465f116f231fad47bc140cdbedc0f340ce2ac9ec993aa59244b9abed8e19b97d4ab8ddc6e2dcd9760d64323d49a5cfbf8694fa65cf40b8d6962c9d03ab264c3dd8fafc8b4e91a9006c97ae90b62349d7ee6d251b9849835b1cffdd36c90715e5f5a62f7aa9b551a6df32eef32c832f3a5a5aa81e527dce00cd0376d440f7c685c2f19935b80ef5a6d62712387df62c645aa385d0af9f41bff2cc3d5322a45497c06587a51ff5928df7a5b505750ae0bc27854f77521b7c2b4abd2ddbaec3bf598960976bfa508e524c0d635b2fb91a354a1c5b90d9850799fdffcecdf35d7d574f81c2a582e41b95a08710fb025d04dd6eb9006bdb0c36b39dae838132b9aecab53e7a2a628c5223fab96d5556980fc9d52631c85619dab730459481bda0f27d87c396c2feade2a4f5acdcd36595d91dc677591511517464607c3d8ad10e027ea958153f7b06e205cc0402136fdbedac4ab04bd3af06f3694347af9e9af9a95c31defdd4f3911434be8a67b998b14a13ea96a8c453b063fac82b02dd50eea649259b491b54e786009d0e1a50698e39159b726ec318615acc28d8cc91b0f0bffca0ed6ddec286fa5b15e51056f7092d4f7283759c8881f349d2863614c51bcc5596572a78949ca529c2d2af968caba5d4b8c945313d790e305e78f5b3d5718f34864ce5bd573e78f994627c5a0f0d04759880bbc9a3a0f98ea9c34eefa8bc4c7691fdcf7fe283507c784c451cbe038c53362cd940acb3e5b5fa2a2236de35eb306efd3dbabcb17b4c919d1f810661966463a71cc62b9fffa7dd11bf5c66dc90700a2b39bbe31bd4028ee6500ae6bec1eb8912c9e5ab874895ed2b1c15df2b5502b54d28a86bebe8250703c46c0662aa585cb3a0930374e2d115adc87c43e77e092ef2d117132d112b35de82d2546c848213ecc252b498a0120fef577b69783a91980126b51c6a122e90732b97946089830b73de79587bc414a750fb831e0c63ecb34f68f02f1fd9a76f02ffff16eeb16e70e5181f56f2bd86af5dde76d1bb2f99d0f66125427a87732f8d9e30deb46029cbebd7b58b8b6aaaf38004868858c351f1f65d64bb0cea5dea490791f8c32dfd23944f0b67cbe1b8086138730d642f39c035bd615486ef8cb08e1914325d64f9173c6388b93ffce00ebcdeb9ffc19f9751e9de1ddffe8e2c0cac7c762adccbc92056d6e7fbb4d48850aedccb8d47f9a841f4bf6cff481eb0ad8651ffe36ea7f78d7413864ee1d0f56d06eb9f2cef3498d36382cf784bef154ed67279d30621551c5df2994e984d684139a3be280fe5b6a4ea21e5578ec808bc69cf77318ca199ab2bc687557c6b776aa31349542df2f0b81346a93dd88113b5ea759c2796cbf66485b99c121991e5b64c771b4122d5b2fe3f130734b35cbd4a3345d0f60401b7933439c87f603350e1a265b0fbbf761bea95a58d24be675fe835c68f787cc031e54e7aa26d9091d7322e4686b506dbd3f6d2d730227980e24d17d16998180e2ee964b2528248fee52bb1dc54db31174a05dedcd7a69b49a2d5f09e3b8c5daa8f3ff011bfaebc8b651772b3b9c275a9af92d9833b6571122575b9a334928dbb5ae6081347307a80dac3f612ea6ede1d0e3eaf3d263d05bc796caacfe2e39234761b335fc11b872067092a498d29c3793fccfd50d415f4b7a1f75f0b43f30af3798a5942ba70109ca6014ef7ce51184233070a768e4d51ba5519207580ea8479cc670de3acf5c24d7b5757372c15af11c277e910253662b57e9b0d4d6d80029e1461558347655f48b1d0a222e735ba7509250786a356664de254ac98f853b4da9153bd8d46de330f445ec3c6b1a64469625e077a556673d4702564bea93725f385125e1c5e662f8bb147566571208afb1d768569f126ba9e547931f0e0f0ac71725b081b758250a115c8b5945f4534635534183e8bd7e5c1d3998a783c17acbe5f0035ef62bb0790d7bb28ab93edf7089e0da07e6bccc02437496c0009d4b75e323137bd6defe6a84d57547950cbe145ec80db8a79cb99af016886b2b149f2ee510d6fb58aeb51f72cbeff7a0a5434f4bbd95ae5bc6fb56904130e52751dc5acdd16c4333cac8123ff33467efa09037dbc21f571398f710010aba586cb77bbd46de572673afd4012f80f06cb115d17164a9bb6dd032eec285103d9662fa16ae8c1989a25b53b5819c68c64509afcead7e8214b8c2fa2b254560bbd1c3bac8a2e64bd182bef3dec3db679ce8bfeacead9c164bf0bc12c4d35484959663e52d80909e355bc619fe20af349fb7779eb7cf0d20868dbfd441fc84235e558223ea435b9fdc2b80ec5e6a2c374574e67ae48287eb6a3543e2bf89302ededdd6cea9d37b4c5a618eee1f0dbd47f00f68a26838ed510faf0f36fe72860bdc03cc0a8abd3d6fe9f3f76857473a0209996edcc75fff8ddd3fff963eff48fa7bf00660b7f605c06b96102858b545991538b3ba29a5725f313ad9074b9bd0951ec86dd73e4e9c70663f6806005284e86f19ff9b70a70f741d3e72766a86e1a8ed53a05abfc1e6525f76d27896866b8a214ba14e3c9158e15c87f33cf2dbeaba4d939a3e4d4265d8200bd8edc061d3b8562d51c35fd4d63615b16495024decf3c5ad0544af5ed4fb3f59c673eb90112dce3c0c0693967ecb427ef175a2749fce012bd72b56746e5b8da3e4ce6f0a6d9d150ee92f4c0da1b0ba326e01610a65865d20c8fc23dfa7b54ba110e996d61407bdbe62eb6077c7ae68e67efc5dfae7793c903917d8dc7f4d1de93c080dfb3058b9e0ea9758ef27a6dfdcb0d4c1bd8dedd7a7572cba2d63471ebc56d877ff205078a23288df49d979652859f8955925e4703bf94bedd0165e7813db3f4f31e179e96f166a86831144296f2913fb4eab690b7353289fad8a47f34c48a961941a12fadfe6029b3c24ef70d55b65711e7c239e359248bb5ad7c2604db997bba3a3609b1b16cd5e950afde64a3fbb3f53ff7894024a8c39d3b9e171130bb377af63ab5488c8753d63426bed1a66a8bfd2cd3679d359dd483136d2bdbd36fbb75c998fb4d7893880c18181f8a20181f05d5b44f428b14d05aff07c45b5b6494d35f4097a58f1cb27769d27e2e7ebeca3e41cdb031220b9db52c78206a6da175d9d0b386d9acebe7ef36d607655190e779d3251c2d3af1ffff69a6cff2ee780ee57668d227140d9b8a32b221cf5a6668f48e6066f5e0a4b8040576c5a849c3cc05da8fe655df061bbbe3099faae5b76bbe700ef5aa5d97862f5fd6cc00629122a144b9bba529985f3eb17705d64151e74dcfd0f08a4e6e0fb907b64f5362a7985750e22c73039852cbe8e3880375ce617c2d84e13be4c0ce72ed571e046f7c7e444607f66e08293a910ef48a2fd209a6bd8c0c997a67ab43de9dc94649f49f87d29c07f8a14450c0034b1c86d1ac59ef8511b4740115d60776d919f42b6f0443b49b850c36affbf29aaac1279e84b8d63efa3dbb247045771bf87567889eaa10a1ce050a7a050a8df9c4a8774fdc4213e5546fb2cdfd4dc437c619e68381fc38b3fe31cf53c8a1a17ba0c5d1d05b7965c213514dc783ebe59b327065531912a683b4a94d0feaf8890304cda621e08ed3ba1f1781b460fba5c765dca09b5c3577fa4dd32d994cf0b62159d5ea39031afdbc43c23d6e60e0ad708a9609bdce60b348af449b2c59e27a8c5e53d8a55d60a9b85f7cf3a02c7b72a49c49818dcb0ddc635ff88d4b67f5a05aa456aa53aad27a96d1abab47b3b825ea8f4d4794322713555ba99dab4f66706bcb484337e15ae2b90b8a1519ad55391ee1682a4753e5d30a48aaa6853c3f5596fd8a728afac30f90e219f836e244732ee826573d9e082890aee27dd1040cafe06cec7fe3f6d71e5df7b80dc8edbc77584723a38a549bc11e261152277ff048e695832fb3bcae3619f6e4265951434d00026bca491a11cd73cc3f7ee84f910f11a6744ee9a3fd351844a31e6e53be0f30bad39cbbdacdd8c8e95a7e2bacc9a8e0d97d124bcb8c4d537e2fbdcb86537ae7cf9e9acd869c691a2bc5dbb4ec08532c49ec651827f8443a1eba8ced769a73f75d38851f4c1f6c241b89cbf01c385932edf1809d93b68d47d28ad5bc7f49aae2824c5328a9e464b600d626c4a6970ce24777b7b23efbbc6573165a684477db0b82a5af6e924a0141d7bc3def50ca84c6c0fc73d7ee717220d823217cdac5e1ca1e06d49c219bd816e9cba8b9cf301ffda04a4924d52a102aa7b6606a1d0d9543b034657e581441ba21aae02f3fed28f1b9eafbe07b8c8c9f24daa825595c4c2eb06262419fe2975b5f14190db4ed848c793027e5d0fcff446aff5cefbadb742aa71a0ddb196eac0045085f625b3cb59d5021fc952986eb240261bd87beb4591e5ddfa58b55f4ea915f42dcdae0e951f63b8fa96de3cf4e6ef8fcfa8bd2cea8394b6dd6027cd36c541de7d841e31f82d2b9f4740ad1b5bc22e9751e2e3ce2e2a6a157cda331f69167069073edd1df459382054d00807b04c540ddda41c467501840263711d5463839f6f9e92445ee55781d64b21263320b6bdaa9c85c911205ca5f21ce96999064fb1c9222a4263bf8c7bb2a4f490e3f728a86ac70a6bd966c4b5b58f78e7aa82dd26042643a9ee05f00936324c359c90567b3ce66d001ba34cb0a7b36de61162b1c125666b879cc70e95b3ef03f61de3cacd254b4e0a76603f05b555ce6500f5dfb5e59dbfd9f71c0b16368832de630aa9211200c10c7dcc57dd2816c4722abd7593bd6a6407dc70cd8b946f92c888de4eccbebdf34aebd04c062f46bfec44476d791e32d61866d145339ad53050b548bede9dfc7f695aaa90f9a75281ac598201ee5867e87a0a98bb9174d91057d90d605f9cdf6f7f152512dc226628b1c759925a9def0361dfca1dbdd7ac2a5913d0c6025175ecaf08a84fe271d2be5f3abdda29b2bfca4f28e923ba9dd4d99b448adf4bea29717fbbc80fc6bdba253055695ee5c7034f19faedabc5bde7007c2fa469eec441c6fa485a8cb42e025b1b5e530c4d72ec66498a42714174f67cd24698caa9addf0e9261601fb11cd46c95b47051a077db3a028983b70117ccb4edb9e3e630f0d0cea7cfdae69906897f3891c6534be524daa5c4f7517f008a0455eacd0b2ecc75d16a3ff927d42fdfa3ee5d98f000a1c1ab9d06e71b22560513732614c4bdd587e9335ec75c43d7091f628fa8da2833b63e63ce7bf6d9ba1292ead9eb9663e49a1989b12bf9036133063d567897c0130e674eae567200eec7b008a0e2bf303a1012834c0f585c4ae8fd0f8cd6a5c41b97eb551c9acfaaee83dfc47342eeac54aacc05f6b9bc8b6690fa1085053b7f09794161e2734e3037de4803109356d5f8209c073f7fdda8330c822fdb5c6f19cde888b008bc9f0fd9feda0c1b0e337737182ed54910388e2da4a9f36f8a02a301ce03f8b68b8ff6589ab379f3d75798fbb68df26646b9b03a55a4b455ce34e1392fdbed4b146c0cffb2c738c2255d34fdfb8ce2fa03daa90db4fd9cdb7c7ea11eee44c2fa0f0b3ff543d42742aaa163a7ac5dcbeaa857ae8c9588fd2e92fb244422605af09dcf0cb4c0b509984e066db3ccbb90a145335c3594347905ac1e689c3c9826a22a68585dea25d247dc70afc2fe0e5ec29ec696ae66af669dee47205162080a7243a92969a57878476e9187d2415fb435149f9e52f87c38f8987508d12f5c022aecc1f7cd5d0d1c23e4c6d0d3e3c0dac0d4e4b1d921c0af0801d81bc3b6c6abbedefe3692929af106b6834470780197c788fa4bba8ade11bdf3a1cc795f42e839dfec9764299676b97bec8097b02b00dc858ad8dc71ad41c79f1666719f1c365eb828cb7864b58d9a3e48f220d231ccced14f18c5f43df11f1564dd898e964273aa4181666dab645bee55da4e0c28299506869b90e0c197f906963a8bdf6c1aeafaa5aec13351f95d1e841e7c521720f5aad38f7862a79db0b2742a805454bd9484f6f1cc6c391f9318d92e50dd0afa34307ef83908ff77224dd6b42d9341b10eaa7d16ef3fa8dbd5bce5125d19eb7b5c25e11a21ae101bda63bdd6fb3fe72e4be32cf1bc24a32b192100f3fcfedae9e94d01b0785910081ec2d1bdccb7196a942a3f349c8655af1d34dac5cf9b8f0a502b808b6a5b23fa37cf76d23ea9934f92ef3d5ede8b10a7c01e1d046879e5b3e4aa2238c0e768db52462a3bb5ac5de91a6ae06762b100a232a5a122893d5750ddcaba7992c430e79ae770899e523519bc7981234dca23ca55d51331aefa9bcc3d4694f294d2dc8c2cfd3b2853bb6a4f22a8662adc719f247653f70d158c576f4c5d9ca436f641316d5f5d914ddf3ea4043208f86e4a209e92051075b315feb53d81caee365ae44a9e5df4ae3603c35564c7eb64bc5e2bde29078e14c242832e669b0eb5293dd0b254866250973e20d43f4d7c07dbd561b4d277852102156f1e0f3e10d48080cfa9cb8619c43b98c8b4a1d7c80c47658b594f43fa56ab324fd4ab482a466c0a4cfa8e3921d7fe209317d0687b14bf720f1c2bdad6a17e57d452bdda3a27bbc8c76c3fcfa1c8a6418629b48fd47582a1411a6015fba66859a97d30a9e96c0ded6cafb9d19b7cf9a46df446bfdd4e1f9596fea90f7d3cbdea2736b183127d962773dae877143e5396cb3b449f5d6333113bd3573cb2df7e3fbb7985c12330695786e965754d04e9e44f437e45c0fd5adfa41be773486818a9b7690bfc4e4b4c8b6bfef7b9a962a13cb151ca54bd2979cd886ee9a9399b442fe91f1888ac4e76dd115d89d344ed3f5c2cca954d1f585339985256da84ddd66d76337fd7e02fba58d528ecc26ff8443d9f14610f63241e2a1ed34c0967376169e057ffcf356cc1a900cefa2dd769c4f719537bfc02ead52e22ab8a587604760c47fda629f9cce5a38fd40a3f7e8e2f2af9fcc5d37880eaf525969f617ca8c8b0484e119e572dc38b3c660de67a863e983d9ddff666ccdd9f33d5b6107bd54e05dd1de1667e6d8a60d07bd63bf4411fc358944cf463203a46b53db147e55b09b3137d8d44800d42632147ee0827ec5f7d113f5dee6ae6705c620d74c98b6e7088381b6296211be24e17de193e89130354dcee975d0f2afa34e58cf01e13f06b016e9b19846394ef2f4d3507910973b22ea7b1122a152a44e2d2343f227f09acf3a781f60464098a1dd516e24c8c80dbf31239da6496caa1ab03ff6928d7a9192cf5de4c811cce83da2936f6302ba458c08bb2df5ea6b78cf04872a3a08ea9034ea02b02f3283d642ce5c044d3e5693d5d469ea8d86c6b367ca3715542ae39ad1edf5ef6c99213b59ce6b887df6ed3e2d31fc4449e73b1755580c6355bbea44ddcd0a05ab45f2244ba56fb4a5fc6b08ca64693fdba1bbdad08dc09133717abbac5ac55b2574e1379c1e25a63a8d1811197ac15f02f353da18d6a8f1e960beafbb4168cfe35419b7924a4f936c88c37779b5a3cb6d56d9d1f8f97618fcf890e3576265920a98f2a246701a194341dfe2677f51f73d7a2c671f2be6548271c91fa282e1d4fecc296dbe1a8fa21cccdd1182268034ba16c1b3ff5988107b44c7e5e6e72ed6ee110e5f23bd92e5cf25276ae5e5f1e8adbd6002445f6d6b906c4accca56c83fc87f7b609bc4bb54c29407fc426565d54ead8be1ca60eaf40b103247e179ba4f64e3e57d2f2c659355a3607a4b9344d2ab0e5c479c6e72b73a21ab6575c32e0ea06df16e50b93ce67bc6178a402fc159322c3d0010c9d21ffd6bddb4aac03143723c0f0e9aba1861ae9e51fc60a291d02adbdea3b9ec75084c9cf0fac9b3660fc3ca070389e409c01fa09585c19d74aeaf36ccb4074676ef8be3c993fd5afb957e0029e2a16f3e3eeaa39eca276ccff95d2cca793f944391b92be14cb399670e4bddb989ffb8db5e6a0842727c2f58592026f2206b22ad4e870c5dd2fc4f49e2be5b2bef05c07ec0167cff07f63001c57d69a7fa5fe60567f308ba14ce7344f8a8ebd50e23e8af72258e624766e451fd6ff7637738d1540185c93ed43db62a6bf8480bffe9da55b4be5346a1e53ca636b820592f316c859c3f12269c6c7910566a84c26dd551808aa6d8e9f87de54df8f2eadc4b1af554f3f6c4a38e428c888a403b5d9a67584e3e7189ca12adedcb3912910c88fb521d7e1da800643f009cdf7b6f7179d43ad01b5a6cec5887fcb5ff929254c58711dc1ba0573cd215459884a5aee412ef15f3d446fdae6247a6416bba1776855ebd73d8b29c7a5e18df6feae64fcd39090f3c194b2fef1fecc0a34ce449bef4713d7edd4e255efef01af496ab4d2930234ebc3931abe92d092c7f97c7a7cefac1ee62be35cb423c4a8586985a68e1fa90fa0941b9dc4e4c8ee4717f4af715c398b691e5d79bfb060e52f600285f166a672648087e3a56dc7ec7b37b403a4574e990bf1ae8f3a9c28d4137f51bb84cffd532af41ce8590e2730549a52d1352b14138a539efccc0c01b463aff79fc6e814e560fbd5505eb6100b8c067a228ccedf4c73e66a4b57da72a45044c218f98c45286ad724fb783c2be06262cfff9b7ca413f8d5ee9180c8ec171e20c39b9ff9033130e233b321c3d9a441edcbd4bacb99019b773ff921db7aa6999f59ab5ac36f5babf986e6483be0a7e5ba50afca922795ebf44b0cf7b557a85cbf4416fcf65068fe1bb2ecf2d494cca1722c1df567b09b85266690ae42131ed6109fc61338e930bdad41cb28b2de1776931c1687cad255b7af09420dff341f77a3c9ee8b9f5f27c22090da8095d8f8140ab3dc6ebac4cac5a640c0c3340e8d71cc78dca03e4de117a65f26fce64367130e18e3e19a6f1157e729cbef431d45b3429013c9779f809b6cf326931c4d7d6960e182951a8b7fce78f81d1cf6d4c738048ab6fc11f6664ba5c8c0841e0dd8ebbdc4f447ca78a581e24616b5194a8179f51271c7110f6fcaaa970918707b4292a59bcc4753472d294206c6c1138b143f492cb01c5b1197c73231eebab5cfd6cdf5e1925f162e67c893bae07ef214ef986da6b761ef1c54e1147fee1925c94e199efcfe3c633830dbdab9da6524e7521b9946d126454962d3841b1426832265f26279d3e996cc75dab1032fb475f4ef514f7c1c612a2a36268b1573795c6fd0179ef25b9db6a21531a993a2880aecdeda392bfd123bbe0107bc8d57570b2c2e5958f0142b47d6d02614de04faaa2b039f698f6c1fa0fd7ac313e3a301b9582b0fc5aac3a28dd3954af02d1c9a2caf155fe9e3511f161f53f47c1236133228e37ae0fcfeed0938e336bb1f943e38aa51436f37fa0858a7d82fc4b360c6b4cb4a0dd90f5cba09da3da5f73afbc65eeb896e9201641fa651e79d70360c96e2e17e36431d786706fdf7db4e24ceab6c26c5a0776b922eddd50504e63800f2bfecdb3c832131b3e846f1eaf5e50a60dd88e158ebf344164f6528859e33a595fc9f80e01e0d54bc4e8ecb7bfc49cf557e457719a4c540aac42cfb76ef767943e971a69f73344405a6d4e4f09b9b2d51d611cb9cd53178b52c995a268f528b120c9983314a0e2f333d2bde6d57fd719559a42d4d167a8385dc356417936c13388320d2175cac35be5cf0e78d7f31f4275555cbeb63d8272b2961eb718312e4f4e8638adfccadd61176649eee2dcafb6ed97e2988fe1b177cfc524d71a9ca84f026243e0ff35d68a9e02bd92e4ea83d2383c768e31f69d3b62ee5c0841bcb5b69d79dc01c4d4df08ee117de4caf94f91b32a8f3430caad4cacf3d4742cc1dcb5b5bd868e928bedbf32a41efd55d4e757d868a2aff722b7dc1d4fdd5d9dc8b5f3a84af9019d45d4876ef93329f02e7d80e13c137b8c963b6cbec02bcccc2615d61daf91518ae4a17f8141606c57469f278b070d44e4f8d59eeb8ce4c00f242d08042d76fe356a31f02b7458c27bf5977b7ff1fc6d28ca6f41a9298cd6ffb9043f13ee019d2637fffd4ea9a3f8c7e4bf922712b3e3a53da0b58b9776aa9056372f336d9084028737337349089df8fef9209f100a874507157e78a2d704b7edb43d309e3c5c756b754b144e93706d7022091f3ef5589c015a8dcf430ed3314c4898c16d05c68ad562a390ee72f693dca4f6a6db55091ff3ed32b065250747f5eb19ea95a17c4a9300138296d7b4ed275fbd7c32a5da2b914711b9023386c8213289719c75fecf34a6f12529e69b21cfe7a37669213dc6efe0559e6c65cdce5bad668fc1b25b914602e72e64f090a9c10814ec807499842077be16edc91d8bf4e026e960d39516025a86a3cdc63e7d59737a9cde0d7c32ced46c8cd44a4c70d9b4411275d4e9790fc6201b40d5e31257b829246256852c4338b96d5bbbe09157ab267bd0bc6ce0d46ec7643670b41ee11923e006241bb56b21701388f8a4009dca41de9e88a5d4dc80657acb591fa958c5acbcadace961d4a1cd41df14f00170a3b44ceaa64dc50176f2ced67ea81ac4e989c1b3dc92072d612750bc3360bee351dd8bf442ba7a145f6451ba565452d73e2ea9351d9d0bf61af9a18d1a7ab75cd9359b5d42ab2f14894427c46a4979da4e0a91e28e1ebf4ab8ec6d9cfd0753b73fbd846728bfb350bb8308dc0b3c83b71cbe6248b474077f2e1fc1cb3538794e57337979e692919ed1fe646b2f27d0d2dbc63d4592dd711fe5dede455cf1d0bff644c498e2869a43df10739607dc56e1cef88a9ce7b0e16556dcf4557e1ba99d6ccc40ee2a086853c10f514de7412fc21027a5a71157b48f9bd6e8a70d7de2744f3d3fd2cd4674673b1030fe6095577ce1fde3b9260f98305a426e1ad4541b3fc03e6fa04a996ea0937219bef66af1a9f181e5f254c9a3f7d2987434badc8eb8ba0807d084856f5492195af8fa2051b315559f0f04696ffe1d70d3885dcaf274bcdd4c1d47dae0e240a9fe41b6ee6e81ac9a95be2b5c911175bbceaa25ecf2874f2ed9b9fb945e9820b0ac6e63774673f324c49d3407941f54c3a05af21a17ca4a7bb0b9b5435b7e5d96fd48f1d7f8dd8e144215da9cc306cffd3ddc72855089528f3a741d89484234676d670504643a23cfd3a2910a113f8556a317c786f3438ea8e7fd4456dbd29495bee93cbc6fe65741e2af37763aaba83f1a10856181bb02fec848aa8fe0f75bc3580d1b8b970d54b81ef10ce7cdc11ea7cf84703506d162aa7d26f86c382940a07f401cb89212d7b20ab37d520370e22af0a2b170d699c436dda04e2e595a4744477980e26c810b3c9303fc9234faf7684c78439aafe117d6e8b4e7e9f367d7eec8e6fe52b0e4890d3f36c3fd7520640a8eea5b3bceca96b678ab3972044f2d74b3abbec7546a318217e4e919d2cde0be2c34b2b3ea58e9684d078a484cd1d2dcf9d44e94066d8881f7e83f8a2abd671596daa07dd1a2a5cbb1a76a8871503d278e5263225b39c5d3c2a27923ddf15874efb302c68ab8d6979e5668c7076f76bb9feed47d2e27a4960117b985d6fc92c48cac0cfd74373481c1a4813c15a24e37f1d727046541a14f34678996e226aa7c30b4b50422876f108b1bacfe78ad2ee4b8a74dc9769d2bf41d2767a979f394374fcc8228f84217167b0814467afa1cd0c7aa2f8d3dc9d3e1e3a61ca500abf943612a1b4609b2c98ac89878e92fd0020e20fa2bc70fdd52637adb83eb22c775cf5827dbfdcf3118c7bed19c3d7029f37e559aa1d0182b25e9aa117955a1c24b659ee920c74551da9bc55c7f925643a6df25319a08451e3dd8181a727f6a2c0a6e324f95ba8da81dae02b264bde9a6b83a5cb41f7865c8d102eebfb2f218c1af1c6c077b266c11d39ec1ee2cbd642ff82f4c1686f257e0fd1df7efe72459587f5a769ec761d815c20f5df350186bf4580b2a9d072b7b161dcc8d559bd767e2746f19555140413205fb31ee0e143ce644bbd70296ad499b18e284bc0cb8822f75fa5fdc9f76a467da6536a8cdc509d0d240610dc1d1d95243bb9adc04888ea995cb80f6c07dd735d37f928885f5fdfec35079a77ab2dcca933126f578a12e6f062c31761b8ce23afc9f518b9f4a75cda7ef071bdaa00841d26cbef74a5dc38f557b9f21af7104d01c8f8c6909e0c0d641d1a5b923c6c8d930f9a4e28d8035399d1032b0f6e678c136eed9ced9f0ce9b786224371e9f21a7e4ed1e6d279818541c96112ef34b8cad6bf114ac5033980ba13353c5f0c42d2de68fc81cf6ad260b562c1f5caa625a991e5ba9d0916bbeea10b2c3d6663d8b08ff2323695cbffab4fcee878949e1f5af15791ac0a0dc9c3bdc3545fe0b80b525a426974734fd55228d3b2625b682c9b570e9caf1ead1740a23e7007b1b03e6c502d645b35cac7582bdbb3da0cb044b8b0e07b5f1e5b6a9080687ee201d596360f9d0e4050f86714d1068198770f0ca2a6c50ec99282bb71e05e4a6da53c89418b36c049eb79d734d8d5d12440589a91f6617e94c7a43094753e1442fcb89c3e295e8f6c30bc1a90a6ac5d4333c61b0335c340c42da96de8d0e662c324d75459a29ab4140e32d6727beb196bcdc5d215b792aaef75509bd1913ff5d14a876941411ebd1ba9c06b47f2aefbaec1f0ead6e11446a0a878044db9a13c99de4d3df73476905076455bc4819d21a41f96e6ba65f740050aefed41c4ac4e0633196577afaff3b21e73494ce63eabb9ed3ca954d083235888aedffbdb62dd6587028c255d33025d5f2ce22fd4626d66197cf996510d48abdfca532f5c04709d3c830fe569934e4efffc575856b93dbccd5afc415d3de906a90c0e432dc31b64ed8ea6eee41fafd58fcae42f2e3fd54689aaa8cf7a51d59039bd962ae3dd2cd532ce1b606307c0d99a7a5c29b60cddeb9e35d04e3d90ce4253fe9a09e47dd93249263e5f43505495600c402e6e9eb333f07cada739243ce6727454b54eb9f45dc392f005ef2fe4b789f6486befba198541aa410b369b17e5efed331bdd4ce7a7901e94661edf016c57990048907985fcb06eb2291f11a17920e24b786535723a679dd7e129580d101d43e8a25c7080615a0cb293155a554ed897c8abcea630cc395b4adb520985ad9ecf1c40c37a289371dcf187afae500bb3350b8342da4aa21b93eaeade24778f8892f989423cda0b22c979728f2ef5f4da08a41ff81516a3e90ab0b68ef2c13a4522bfb7e2d27c6c6702620a7f0d0c1332b2a55f8204a5af2153d7f8f8abfd97869311bb91c4218faecd508907bfd7c2901f8f7569684ef95c464e4eb3fd066d397100df2d66e173c48bfa83b688e9413f972a7269b9d1918683dd9860c3889334b3f5e2b32cf7b96fe2edb562b94dbb1929dc3bca828fcc6c0679835a1ba97c9e229439cc7163f3fb16296a45c603e59bc31912d67a347ff03c9a380a7614c5c3479d4fbbe3dfe2f9ad169e238d82aa1217b0fd46c403c75b222f84f25af248a61ca9e9974207d69b5a2bb90ae163c46304f37cb5df8d56c89531db70c1558da28e056d70a668b95804334549a86eef2477287aec35bf2948936c43a8bfa605561457f0cc1e0f7e114be10b3069b272203a28dfb783eb31ebbf2bf193bcdb99aba69b3aa3f2a0ca6c3d74a9d27c0bb731cc84ffd57e89019d2471c4d0e8e2b980577ca62c5d072cb52a377ce064d91100c16bebbe7564ee72a744d243c41af0437d48a029056d6a78b6cd2d470d37b8534cf7aca1c4b4e22aed36b3118f09243d2c934ef703b632847dcc27b4e382afe6187cf1bd6ab9705510d58227e297ca3758fd046be2c2a5f4825b0dc6ef68bacb3e7e8f6cf6cdda52ceb78364fc3b22d18d6bf219bc31028e809bd3edfb2fa1fae7543fcbb1f98aed56ff245ce7aedfb550f50053c1f575bca7f9036198d40c09f88f4e106ab6bcc1efd49a15dd84530a6cf2dd41da57123a25b49aab766477cb221e4c14bf9cfa111a898318cb0b1d5008123e5588c4674fd984036c587ab78b19c4cbb6d990930f73cd910144bc9a77fac442d2e453dcf1152617bbcdff017eaad6ebe9299283a3601184e24095d81dd7b64ca1efb20008a8d7c107cf66b16fb909bf516b4f3412e5921245b11baf9bda95d789eead0202a44fcc0cc4181dff95dfb247d8b90bfaec1aac924c16780e2f2f24e6538a01e335f9316b4a86ee544cf3c049f800df989b9374400614751e5134102042953e6c153888a6aa10f0523ed29a93a403d7df643f7218cf1637aeae1bee135d412dcde974f6ec4cbadb996d267629298ddb64b7791f074ed5fb96a18bd4c392555af87ee1d9b693025200213fdcef69548edaa3af4b36d861720284c1db76da8c4f6ca90afc7e40fba755235e500574e8609866c9578937b3dcd1574184495e3ee7583e48b1fd21f57e63910452f26b0a5c4a0e0d8443d64fb9a8175e060515ed5b044bcb690ef2d14a4186adebc7fa29a716c9224e4bb8bd1c66f703d8c18fb9cb926af6aa70faa588abdb4290bc39b2856f334c42768f25902a9626afbb31bc0c3890f57d7797fd89fa10c8df8c88543c837a790bbc3438044b3c571e1df9edf89e98e0553d2b1bdfb698f451b0206e3f94fdf29ad44b4c6c4ddc22257e82e51b688b462675b30d4c55be855ced98114193c568eb498fde2f5740214f36f9bb0f67f63b495d91b83ffb54a1a4939c8c1da1957f83fb14cdd48f15872916b4c846c1c12e2698e9996c3f5070728ad236f2f6b1a3c9e5be7649608248d6e566fc9a8883c7fe49ff8517dadf1138152a7b203143493f4713dde3e8e80d74943260880ba64606bc06742c1a177f3159317f2f8bbdd55d68e475dbf82b9d595a328e02c782ae0fee6f3df1822d544b3b43ed7bdffa46425ff13457d2c02a3727c371c34cc3298ac88e01f07ec09aa538b35715920da632e5d74a0d4c94eec8c3a80bfa18cff431c120461bc0c7c8818cf55d33e8273713d4e0a68c03b4e7b1f5239a9152110d36456ac39b727c685245a6845a3878cae1c64e485389033f8aed5796b483df23e2c91e0a5775239b51f35cc5799dfdd558294aa9ff9606afc5e57273116f05e5a9d7f9633147bbaefa350a3c8e7cffa6b80a26b58280626d0bf45aa13a8b5ddfb4baddced37c6d5d9dd7d548d852aa76d2db024f5536b75ee82bf8cf763a930292720ea97c4f41abbb75b4a3648e799cd483e2c3c2b4acbec3259b980b1dcc9572a5e4315cbe75063b36efe7efc07987ffe3b5b4f4a38b99bce3b7ca4425512cb4360b84d020d5207fdddcb34d19c2df503423d5b778f82e4665c98a96bdd8c870e172a341e50627849353f3657107b3c7e06ea7398954379051ba9040e477f850ff1389d3bcf2975ca2c4af20e05bcbf275862081c463d489ea11e7dcbb86e040fcf765b7071ad24f30fbc068c887a259d3c72a55c0a44d751408a115764be508c1f9c6ea9851df40f6185280c06a57410a553810a492f8bc2ca6d4ebdf13a284d9ccb3218638f228e15b28afe5162ee931c93a09ce8f62c6283e0e88d119be3af2f846b64e9919201962a40c9869c4626c2688fc7d2a207f7affed860633052f19aec58ead1ef689c50b086bfc50e57a31e4a821c0501a940e8fc3c6b7b9d471f324e1a347c862a5f11fe0131d5371b6572b5e111ee62d90537dc30a4dab4d347927a1560b3681c881427bf5d16e6eabcee243fd956f979ef1385afda721fb3a9d037aa813c6201d14c0a570cbf84c661fd7a58f70e4172b18ef457fb621d2cafcbac7f4e19bc7fd1a0e9080912a4854af80a1c53fe5054c3483d4b4f704e15181b0d43392d33b5b12af41a9abd7ac1b24cf4edb2bb471cfbe1d2ddd846f7cad3ca2398d3b6954898161765994472475845ade45fc7a2df2a329fff5bd954b7dcfc6db9366f855e651e5305dfbc357b45c103b15414bde7e8d7faf769909bc537cbdc1857e51640a772faa48a9dff4450e8765bc5cdd76149e487138e2ff22d439a303aabfb7d9d63081223dd9dba339cde067e701f6879ed8d61a80321b9b87979edc3ff1a3dfbd1e489685e6adcfa67de97086749e54e279998c383b5b2bd97e4630a6a853dad6ee5f37c9bde8ed94078f08d2dfba9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
