<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f68c7515d92b53eddbf8eb3a761a22ed0093371878fba64ff1b3064fa6a97efbbd13c6138b7910cac32be9422616593bc23cb23f4e7500a2e20bf889b3e8696e5991b1472ad9b2512c3886d3e43a2431ebba68ec9813158baec58b190bde8f5748258ef61ab0602417af4e1cce6ed91f3790304f01776f66503671df5dff1c2acaaad397226e2f4a367e0a546d92dc8a491346280902681eb3bf040a43ac6d39e1ff15d598c88a4c56504579f5228b07f9b0d892107a0d69ed1e6bbb03ba15e1554b7e799efa35ebfab928438b654ddcdc077940dd74e842aa0da86e934142a2f8a18685e36f0413f372a952ba2499c5b483a84b3c73e075b3f3a8dc808bff2a6e1d15930c4b8a9dff399ec231d14480d51671ccdef23e9880f6ab051e5d4400d7063c170e5808bbdfaf7a49c36990715d556b69121a6363b3f7ec08ee3d47d794bee3f30199f3cee93633d966aa3e7f8e98221fca64846888f9ffdf44c89509d85f046e814f8da2590eecc678cdbadf90d0f4cf1a80a6c818705e57fda277ce077860a36ff0a2dc68308396e27c70c1a39d60219e45f1e0ee58ee01ba4491fa6f242d64527b2f469d83f05668fb9289785d3bda85344215370fed6bb1b6c82a6760bbe4e867bdf337d211d304d016f3f24feb124bfe299f5fe2e76b39a4e793b3aeb36b5b5ccd6730f4f1e56a27a46290f42f07181de74d6bb16905b268a3f3e4034940be1d2cc49be02bb12fbbe9fd5a6fc1d7c5580c6d42e87783cc5813d61a8b8c5abc07518bd507b28ad6e1eb9ef702a0bb30bbef5dae71ad735cf857e7e98992a67f4e9b68746422e63bbba8111c60412123b65b5a7dc11382704c324556eb9b66977166e041e0b8e158b4366a67b20f9bbeb185af6c2d59a80b9dd98be0d4d1393d0451c7b154c27826a50ce76c5206b34c4828bf901e498ffe2724e08aec93ba9f90a8ef169ddfc90745979fae51c6cdf58d3a495a4547f63d997585d783901338bdb5b923e8b70883d4f3c3cadf9e2ff64fc568d5881114269147089b3926d73edfbd2154dda288f0d103ce854124b70bd6aded06dbb3811985b3e751c41342cb3602ee1648482868b1dade338b19d67c5fb099a525ba67a4af907fee79d3b3381265bf3e5a4da57c75475fefd8c3317bf134f36377630496fd99adc21c57a24650d65a9887c97bf94f08da3a38fd2292caa617a71a16ae654a7a0e53c034a62b9741643cca73536ed10f54210ba512b7330a2892d5eb3f4703985d0e16b840a8fb836298ea796c14c93f0813f41c0bc0e0235dbdba97f4a5151d1e9f67f82527bf8898b31b71cb499529c30b98246993a32738cddc273e4aa95fa1c8972f8147d0c1e8414f0f4b8545bae8dfcb96442739565e2de4259695d3e6860b91911a9d1fec2cc3a6547e05ad845ff9b5e6c294b2c73bcfb5e57e404b9d2e3f321ff490d7e234718214b4d08eff924fd23412de4fd16d2c6fce637a74c93e7dbbe45adfcc26b6320e48a2022eb692dc487e50b40697f716121221c07f5534f2d08b0c2282e419572f9bff05e087b20e9a573300942f7c01e8c247af577cfcbb728bd59fea6ad29797ced124e592eb32e9ad1a0356df69b621633d37708fad3144ae9ef22cc78192ee5f67eb180cefd622e876d5ce0ee964891a38f60d7a051c8044689cb7edeb8690f3b6c9a2d82db2eb62aadae9b8b006f4d9ec69c4283a79adea3c01b49f3f109dca88db6cddb3c6ef3511e5e4362f45c9c6f96c831d7b9b5ccae8c554b5284e19024558484a16c6bc2b4d1eab88e84624e426f079e5670d3dacf095bf88f0ae14d5cb8e61bdfddbfad9a40a31362412869fd86eb43827277e5077901cfafa9b745010aecd80f14defbbbd73c3f0f4abdb15ccca0de8216c87523df5f2279440c1508d7b3e669fb9d24e2b478b35b3a67e001f19efea2ea373dcaf737bc19b64e845239a8abbd59de0ad70ed72f6e5fa54752583f25fb7d56f8a1b8d9b0951240ae7e84469621f622374713fac846fd8e7c015a71b3daaf50bfe56f04a99c817d1c76d6e02f71baa7553eba56122e34143661bf7da999e2619c0e058625d1601a962464d103e8c36f0e353dcf242c2e9b9c02846d7e122fbcbc7c2c65f68dae82aef89a8e22ca823538481ca922d43dc015ed581ac155dc3ee00b0146f6c23734734b32ff45b883066c681176bc8fde2950366b4e5184a2cc680565d6e25f8c942256fe990153afca84e652ef2a04fff862077c3d07e841f66a5ef91c1b54c8acca50bc6a262decc5d79a980a44270b6d2052cda3a8de2192563e1458a62dc19fd4d70f4d4c4d920b38dd24aefca6da4a376b6c73b40d81ad992b63b7dff1a8df4d453641e076a59e2c1d53fcb3619501d798fe93569a73995f674bc884e54231e7659d2feee4b5a192dba5781e9747d15970684e3e685e8de992092755e3e4e89494e66c6b97d70d7ca46a9a19d9ec064ed86ffadaf928b13f6da8a2658ea623f2ce7b597b558cc130209ef4b14f53733da1ae4eb44cb90afba628b88ac3a6d8fb8b37387a248b7a6392909179acd500f90d28ab51ba369cd051d58f5d7a3f8b11267bf7775ce15937ecb2ad254cc93156920bbf7e837bf7e041bc469362cb06cbd6625bd1f716c445ec5c5369e2aa4a210bdd897e48b94de9253418d5151db742b10a26ab7deb28a2a354ca0e659635d163af4123a02e3bd0cd387bd823b43e873f21e182c7bf3a3b9c42d684e6f503162f610e50ae7e6c7da9336f78c79c4a3a94ea4cb50b549156a76bb813466ba71b82a9c03ab1b7c694bd767a8aacbf8af28e6d2d82fa58f36b742df4796eb8ae5466f9819cdec5743c75138018cd2c752825c1db0c56e398d8bd1c7e540c3402ca256882e4b3ed711484d79f5bcc73fa1decc682c9e0b2bec702e47e1d735f3fe62155a6b43248ec9016e4044e0cf65b0c4bcc518285c30291d89ee9bac8e9d5124e8feffbb1fe11bfa7d97a1d28c138f19c66aa1efe8cc6ebbce6a37746fe89b03e9e341e657cb2f1697b65803b97e9a6d32ee7c82b6c35ad3401b1f5c1b06bfa6048c1d99632c132af7ca7e713dcdd5ce12010adb0ba0a3b632b893ecb4fb75a1f9ae94f0e779fbcbcf09cf5aea00b3d077a55bef5eb47c4e46948f2ee047a785bfea7e01516437d800edc6a45c6a327bd600b8d1ac4baf979bf355b866c17ca9ce7a049fdc966c0a56de2bbb0133249790971a34acd3e1947c040f85e32e3000c90ee113ffbb3921f897cc15c9373603f6a02d1a287e0ca958c8284c808bc916a0195289428d6ee4bfaa6fd7a4d9b921893f4bf1c49e1da1642e41c9e56b605a1953b213b620116f12939d7d32b9b386f48c759385a0078ed7920ac5e265c80d0c73e1e96ac28f6b064be45be258b2cfcbe747f5136420c658e6ee60862974b7afc147ca7dcef822273e2e7d2b4eac26d1bd8359d2857ecd727679259db39671c36ebb1b9e0542fb2b3926dc5607cc184bb799b806f2b5e649581426532ba738ff84fc36abdd74dd6844c4e107eefec72b50e37285b8974a844cfca09d03435d0b08d7536c5f34eabda56836f44541f6c1e192ac31053510c4f0cc16650d336de731762219adc6417aff451b716e6759bd5011cce33788374ad6c93c2a7da48bc2a422a4fe70e377585f7b34cbbf721c09adb8f9af3d2d5c5669d16c6f41e6b13ef01acaa412b5c6423b94aa15216ce23567c86e16c3a02f69e356a6f7b8afcb20b8c14aab3d780be61a7c678bb836f51c0fd56ac49a0270c070ebf503fe58982f7f7015068c5826cff92aaada8d47f92f5f90c04b7f49b71def4bde8789e59cdccfc0805969a441fe63129415de321bb294e7e6cf1e9f71194445be0cdd99cfa19824ddb6d66b610124b38feeecfce7199231709ef96b4791ad561ac23a1edaf9609297c8863297ac9052460fdad328f086358c74f2c6c72e362f5bcfe5f39550254249286a3ad72fbc292073136e21fbb90370f8887f408625a1c77acd809de1069b16f06765b10fba93568644d345a1cb55d5bba710d26a853dfec1d42e3317398d3aeaf45728e961505843c2e2e3e84b60bff48044511d8d221690a2da700015d3b9ee0613304bf7f4438a4b354f7e44983a691c389b9242a139e0ffd3846dcd946caa0ae2b74851e8b7321b938f9c3d1976e7e97e4b399a994adba74cc0d8ac6d2108e92e2aad5cf13f2133f188dbddb0106ebffe9ce8da239e8ff80b00e86462c484dfc355c826d1c7af7958aabd5e209c3c773fbe2534357318e7ecb59049b893efcfc4dee60e6a78edf59b4fc910b1698fad84bfd61508a5f869c6085486478ab0fbba6df6da69980a52f21c80ae1dce19d569d17f281b2c1083eb6715534494c94cf1c7325cce6bb5c2a258637a90936f9fa1eabdc3d8f28d96cd3cb7d9a8531619db91bbc606d2346765989d52a9a6aa5f4bf2787223b50766b511686fc549a31580db88ae1f3dbf0b40f1d166035739d32badc10043a8d003046c6bb8080f3059bf1c4686b111f59b1887b277ba72bb2b0cdd7a550ac08cfaf75229da65a4b4a15d193887ba906e1e9a1b833739f3ada9a5d0d303d18e4b3651082e6fb661e578e0e47e3bf625ff70ad045abef97f9aaaed43bee44d347d23a22910ed12c29384f61f1c96379df80c1ee0305846a1dc8ae87bfbf76e5dbf32a55353d77171f3e978fdc2d53ab10b7baa710524ca9bc456209f2696a962d44d810d310f99bc65e5abd15e00ee40f09d4ce685263be930f02e31d854c619b3e29ffca989d8b433b822bdf6070559e57eb27b13498a73f6c78c1f73494f3aabfbd997ed3bc01cf9029534bb41640f1cac8e11615cb8de1c1d986d1d5251d3642c9f060c27a895d77ae804277b88e10c0f8108245550fb72d847997088f537d1acd308353ebcb24811efab184c2efb75d7f4aaa34e6ab4904c7f5d1022dd6f58eb3da150f07fad6602e90ea888aadacd5f15b9ef38cbb977d4ab7d62fa396be9670a21be8c77f9e736dbb29ad373a409192bcd376760277e25d94ae24cf1e14ba33c78e7f91dfef717e534cb787a4b5d14e91712f8f419330e7f58192b8d616d3eefe0c0e4d86e729c3efff0453d7eb72bb647f6642f46e3c23ab80887b3cb2a94662ccba1e1ff69566d107f336d2534335297611f97750b10550f9af2561455ef8f1649d2acc1e823eaff0a901bb2fdc2e0e25d57a73f8089398eceb3fdaff0b8eaa9cba09c78e7cfe9a7984e13df9aa85459f4f5bb64dbdb53c6a7b197b6771ce902543611ec126a4a895d85ec84ed3619a9c83f9e49205b3ea0de20efe598a025790b6c8e6f6953fca6f08bb7bd04674bc3dd70ab2fd214ca81aeb7c7e30b7de352bfa08afc41e27914f20abb0dbb30d3fe1ddcff35160feaf6b91e7801fc4a51b21daad95aa06fec9655accdaebf9b359ff26b369c7c2092d7973cccc6941fc64a0fc4f0614a9da112dbbf6e677e1ad58d9c862e1454b85b3784ea1f576cc42b91900947ac0aba46e6730ac3201a19f575e75ee53bf07fa8a7afa08dde088fcca89ebdc3a943e1237e42c3529b8facd6c6ede07321626507ed76f2405bde0c744709ab4b6bd520dfd4909c8f46ed081439b9c4a4ce44e019053543dec5ffbd7f16b6992663cade40b46e9ce94cc96d97cd5938159854b05e19f36ede63391b9c5258dcdc8f77109a95bcb1113cf48520898e256ab4c09f69cb2da8daaed705b0faab4663acab044e9ffdda743de751dbd0e5c81f36a1af555695dcb6a8ff8fcb09ddefc3c1d58db711e77e1195606f14a9adcd1a957961faeb48088731e65cca514f9a06868be0031252f33abcd3d4f45505d82acea804c996821da5a8705076dc28d858873755e5560d7bb059470a2933802c0c1965b184d31dfc7e78367e029cb932e52be8d78517c447c380ded4e656ad1ce228bbe5f2e6638a9c9704ad6591a6f5349fd851cfdbb4d06f264d0565f18d6c7d892d6bdf8cd67f1766a609a0b9362cf1b0b78be9295b1047c9f64e3a26167725fc52eea4a57fc7dd0c88a2d29292eb50ffae107b303d39eb9699f8aa959b2b28f6aadc1e03f88a851d3373b125370d534e7106fcfac4592c5888eda0b96064a5c254814062f6844374531f9df41d085c870f299a83e00b86b4262d583bddeab02edb82c16999b11d007e1bc47513c0b61eb622cc0b0ea51250013dbcdc618bbcb5d42a207bbd5973ca0ebb26dcd7a1d97685f88f0cb1b344cecea553f02f0e5765c618faf9123d96453b0bf7a556da10c17042b8224b0e44a9733b30970a5f800b01bef638294e7e6972624f0989016065ebd6b03f52bd7d8466bcebaa02fddd2d8cd5cb6712f7b59641b117f3ec384bf24b7df8e9a7ac5f52875650bc995dfb0e7d9064485a0d66fbc6c81abb73a9c4647a2a4336ea3f3e1bc69c11e7d3425fd090915a9f49e637e4449011f2595812d717a38f9d6b4bd653d368bbb5aa987951fec65c433c8fa9d210e25b0212ba9480a3f679ba75469d244778659b5d5c1d4797ce73546f20d0b5299249065ca154d07dad961133cde552e6906f186ef5819608ee59937772651252d0a0e0cfa7cb984968a287f99be82d2862443b4db20489feb6a5ab99e8c4603882f7b160873bbbaa0b71eabca690880ce57dae4318ffd1e9e6d9cbfede7fb12e9a7993f1ea9f508da1036d1a030f428bea8a520c9af2f779ad5b78f3d16e0ba223bc7ed7a59750718f63cd143be3210e2dc4b2b07d93a70fea621965a4fc9c83a87cb126b346a78743380c9233ba07a9a063f02b56792c315fc44e7249eb04821f9d5590c8148d186a6ec36de538f1d400d961dd8482f9d75b0d431f1158835b761a77af9b8743ccbef649c10146e4b4d20870a017450b27a13f7afd7ab0ce8ff3cd50b254720007bd93e973464753d17e7f6577b383e0f85da53147db4c4e29219a7db6e12d84b8396eb6f38456949eb7a539beb39113b0e931491e6186c47a663c721a6aa5bd1ae04fe0ec90259ba990726b3f027384696058c64cf2280b42463278b5a8b122482996ea2a2a9cddd9999d9a282dfde1ceb40d3d460f1dc82714f88070d331d2251b65f90683edeca572931e0e16b6483edc390a97d30134ba3ac03a5838a9d6ef43320162ab65a4f32d99f267f07335d54d39e8c56d49cb6f1b431ddca057430c00a804b887230a7bd5b6027daacd24999ad3acf9acff54c931c938bdab0001e84017d47466a7ea7d4d271844ce47c123ca0e41c4cb5b11919c083cb21b2cb6751ebc9d8cdeb99ceac37b3ef607277b6d737448cbb07a3ba967f3a35124e31e2ba646a9e8be9a829e54f7560e992b8358c6659edd12e3596ffcd500aae709eeffbcb04bbc89aa59f92bef25dc586670e39d6a980de81d73b90a1a02d02e2fcf93d96d01b9e7ba813cb9ee42ad0bcf7e37e8968ac857aeed7803e74fe966f6f8f2a023a87389f843e760cdb0d3f4771df2a0855f6a9ce445b2102e28cd487f01e246ce3db8929fa373f747fc2c28b230947df22ecfb9821162a718be8a9aa336b5a2143d663af189b22d17153c9355d714c248eecf0b3fada2a3f1dd6a0274a60539aa4334b4114d55531d50277306210f6252f2a3f2255dd75665ca6fab03485997d6da25fcd6fc4097759e8bfc0194a65393dada636084aa35f03e327312701d2c1cf0285e922d67d85042e705f2746a17aeb2330f1375e1938be415de4cf8c7ca14c9e6cce1adc01a5dca347a4e169b24f973e5514b2796e1cf404f4dbb4827999c7c826f1acc9845fe2f36d8463bfaf6f8f00f783a59b9702af3919098032da581aefbebd0d4e534c432e2ece449913c994c090909c3fdecb1c2a78096ea752435f63a1803841767e0a3eacded75a473c6668c19f4bd0429a9f545d9375b00448f1689fdb861e5727465147fa001e86b693888dadb0d62e42c0393e073a362644e2044a8be80042d356c949417b5796690bdc0c6464749bb7e48533a66f68191b3f8437ed494eec0713cd4e2caaa95a2c285004bfa18641da50919bc37ccfa25b06636c6b6a430dab7108f3664fe4fe3cdd42c819b55530109c0f381d9f17484d57d68d1c4a45daad8509264f42857feabe5663b69a8dc5df75acd4fb3760a8a8734beb3e8b28b34bc54c77165210ff527b4b69a1eac5844b783b419958ad702a2aa25e783eef3a122eb4c8a0357b6cf3f92c55a96d260d399291de0a2b49f5bfd4cdee41482e6fdf2432972c6ab700032931feead640e57f6e924bda3c487101c02ae346d643210601418d5113424d0ba67d8ebb9f3b684afc7a3e2acc467fd17fc4d0e1811eac18cf39d0866c967322f8239628d321e70f97f1ecb7a21c121b6238961a033078b58af56f6508fb0e6ba3ff7bb7668117461a0db5565d122c11f28e299b553ff01a81e9be7c53251ef5dbfc0dcf8e01df3c835969b1b6b7e3bd958ae08d6cf5d56d210f5a53a45fb2c5daa3f3ccbb120fa11c4813375ee0d1ce5f76153ccca8622485b863add35b8bad16145808e970829000dca049a0d8ecd10a5b6474302d29fa5bcc34034d5feb658fe45fb84ede06db9d21e7b186605cca3dfab6f34b103d5c29f1c3cfe50b6e07981524e16a8ff09ebe8379ee5b46b384e04a3f718cf8a95228ee37801dde961ed65d2f455c8e7cca0902a7ce1af2a75e8f0140401fcaec61722d6c9331d38128a53437ea510f5829576951a2076d97f74ec3bff7901d241fb145af8306dc500c30ee9df696a7ad35f2d8d377133bdb4adf192a2a7d2f8301b976743f93a8a0bf97b058d22c52b9b3a4a34b2db43893ea11a2ee7e489fb92183177d388222f41db63ad6437c90a183eecc2b1194c5e813c1c6b7b66ce6c6bcb867e3af962d9e7112bcb0f4eb96955806c16eac3e975b1d51d5b828e6973d21893ba3f8db318c6aa9f55d81da4051db5f8e265affc0a40eca2447ebf72fc98c1b7f8cbc5b6acc9f2cd51097c6d10bc2725b1b42f0996f3a076e1f99cfe90f08f377d2754831374dc7afafffea523e12456cc0b249268f4143d44b3f2371d025803681b8c9195ffa0b6d9042fed2649a44556d07204e462edd91556a61a97ddc503c7df277999a48028d472c08559f35c0fe080b3d26f01b04ccb34185a9527c7f0a688e0ad46e5c4eed184f852a2af5528a78470508f02f89bdf767cb17fec3f6ff64321d93751b6eeeaeb445723d2afc7fca7184307d33e5dd3c540bac2f612d446ea931a9724bd170128ff02092e0eafbd7f0d64f5dba26ce9e6e39df7ab92c8d253f8d9696cc062f8844018550cc57e2a5b5d6b1e8889c32418fbdd84910d9ecb63c4d02dcb3743000ebd95844788a260ca2652f0d29dee6d77e5e98cd5311a70530a29a899da24b234f0a9c7efc6906fe42a219db745ace09746f7952e0ebb82134ffed670307b2431cd8c0e4dff44558d83e5c0dca62dd5b1e8d2874340d4c082dececdee48c9a3dffe03a3189cd8bd5c13ff4a77196b96032cc5d9831c7692108ac5b057fa5565d7aa95bc385081fb680a7915033775124e9d9efbe414770e9939efbb70288e98794dbf4fc3df5cb80b2f8d4d4795ba0dd8c225c912a7c7d546cb94d4f57160d153c505ee449dc7ff2276af28f038ce3c0b5ba781e0d7f7b8280798959deccda80b6f55ce6dadaa9f7057b06b5ffb49b8c33db418ade96d62262b1cdaf5d7e7d032b74a50a7b867cd3372dff31943ef76b27b177cab110cc84ac4f6032acd3befdfe0f10de36f8257c1cd8315af34975e53e17895c449c359e79dff5f280bfb77e108369b7f11aaa38e8e2ffba46733c101a4a5302a6f0cddb7e11307c07243ceebe87465a7f8875a8f5bb20210c6896ea71f54805b6a1bd9f2e3468e3cd4dd077a3959d06142469bf7e5dc2e640953baaf91e53a6ad9aad9510fac354ab18c1a39515ee88de8ff6ce398651a6d256efa05151d5b54978180eddefadfb394d1ca005d07aa2c6bc382c822a490f72978d3c2d8cdb56dd2cc733381b5d17127cde0ff27c7100180636c0fc3d166de52ec90554bb0cbd0e3246beea22cb4d99cde1d18eb151960e7b1db0eb11a5bbbd89fd615ef99c5a3f5bcb741d76b4ae5cbf72fd47eb03333d4acec48d8ff1c1a3d01d5d05efac46a1b14108030365976bb0ba4633bcb9454ca3e7ed86325ce863a3cc3d07fe6423f835f7c7fdf56f609258f51f7284b34fac87b61908b7d62a5b33b5dd9ac3404717b3e9ba8dfd165a4f49c4952c66c5842397cba2e7983298820c8df38e161370625de90dec24d7eb8deb83e049e6333ba2d4d422db7bc80c78ff415e0495bb7fde4cec51e166d3964ab292e965da7e613df0fcbef439b62ae5b06538d217f941c7073deb8b1017c9b85c8ab1449386c6e81f60d4c53523f76c6ff0c13b6ad4b01d3a68c05b733d0d1f9acfa84948c74b37a5036c558b2c04ccdd76da99c66735b56fafbbf3111a60ab8aab07d1f7c9a25bfa3047fd7625d75b59f7ee14458c62d220a495937f6048edcd31c67d7d5a54d41e0da451e037380be83189c5a610b33bf0914de9328a616deb68f2f216b273f07a7944906a81a1ee611596654f60b3b93baa8f4a8ba9d25fba98760731a6c4447e572ad7476ea4abb25e14617bb28826b26acfd726fa264ba3c6c184a6b557eaa6e4d5dbaacd7551e02a688371f87451e59432e25e6708650507cae5899e7ba9a11086440ba068fa89e57ad9cdda44d29a093a23fbabde807c5add52758a9651e197f27cad276e59e5722432bff33db5bf754671896dfd02ca5884afe07dbe9aa266e3a460edb8aaebf5b45245c8684e2a490c961c7a7e4994c32649ca590a56a64384ae1931af508aae48ecd6c0f35d9ac41893f162a322088c3b77dc76e0f6f98e8816e384deb8979b3074f90753a164d81120f7b5642fe24782ea8a75bba8bfe28f374283c99839303d82e01c7d26d4ae6a1dcac22b30ad6ade8b44881ac9acc5844b562804e848378b90875c21de9d5d359d04fb31379e1469b23571770b30ff451e26e8bb650e34915a4baa23da834c2f39b45b39211315123af1d7f807036b2eb49f90fb83bd083eafe0a42cb064b5d7529ed272b598d3881829aefd796b949da5a019b7605705356cfb33d7ca13e83966682c01d5bb052ee352e63725f163427bd75b68a6503fc0582163e659779ce688d6d861820385d663dabdfb905cd52edc0fd525b21d3a83899e3e0f59452b92f5b2615b978c01de297ee375d42a93d8823746fe4a790dafdb87f4bc6ba3976089c222115303621493214e3ce649a6644cdd31c781daa585253f95e1f28812dd09a5b341a91b3a9c0bb516a67fb5d8bb931e8edf456d2d3631e70044828a31d6a2f645ece5faaa27773c0763cd8b0e126c92e864768fd4f86e59d05bbe4174d8ec1389ace94464810ae709d5a8de16ff0d31bb48fb4fb9ff3167dd9f777543cdbd39d9e0833cbc6480def5471fe64430b4dff57942a21feeed70f797fab3a9e8af6c8ee03fde13076fe9faabe2999e2fb867fe880c65a8470ab24f7634c7282fb2b4b1c5454dc00ae66bdedf272387f2df6d8722525017b3519535cfe9f40ba36a8958945814bf5ebe19995bab475de01b6ebdf5d9e4115faecca64644f0b1864480fb31105f1e222a1e14d5b2d3a81b1f79dacd9241287b8f95223de0ed70caf6504df52ec4a18e6ff69be6cb4d9e7f1ca6a9d7a8fd7fc6e55b2fcdcf26d4ebb6530f26f85ee7143a48ddd17eb5716f12fa85576b2944d236b6778a08aba51331a6595d2f7804a303135aa27f76d884ea350a610e5be3c1eeb65286f449721c4a8c11122234e275014b680d5b31cf7cde29e0115e6ea1f0849029c1e41af340524c4863c0cc6b24ed56873b94f794fdd09126724e99c8c5c0160536ad316c6fc9e93de63a9e1745dcc2c4e4b51c773ac0d32f89a4d971c398f8b8111f323a63afc29541c88d47584e122c4c276f96892846f8348b90e5704a3131eb43f6281826f7342089c7349eb05951e135162d6ffe28ae5d80c8cecdf599cd8b5971c2a820153dbbad9a239a631c007a689b177b042cdaaf317263505fc4c79df16aa0ee055e25ea8bc4315a739553908d4b747c20e826f396dfcdac41fa99f9017838d2cf09e6fcf11c4925bfe10c88a227d2572ab4e56f0ce21defb14588dbd0b4f40d0b5e6b5a05ee09cbd6170b5bcc9b49e164e1fefd0d1f2e39a37d51faf4c6ddaace0bfc96bc35457be45a4c34b4871dc58adaea087e2b6b17d5b260a1e4db81ed2f1d857eeaaf76322cbe8dd0d5b3c57a4317f747701d96897b7fa8103a2d293045fcef6e420b2e2d5a1d2c009afc09270c5acd1fa6f7994c4d998e5e4c90de55cec25627705c261ce76189ed697cb31feea4ad4245b53e27fcc58232da06a9439e122a89c18939c4b3d0861b97cdfda0b2d4a3059ae54bab9c7ec358f20bf789aded296cff353b43dc828e40cfe73e3e2e221db079b1f8fb61db36872b6d86bfe884b0750ff58cbc0c7cedfbe1a4f5b83eab14e578789e28405ae6cdc54d204724f1b3480476867de13c072caeb3ffacee16f0330cc890aba4fc0b97856c1afaff2860335bea9ab93945d07450eff47f73420f454c3ad26c8c62d209567b5ead2aa91433975fa1b5204c01b0a897ac8601732c7ae416f24d5c97584e24c1287fa986dc68c880a353b7869b3440ffe6a4e167aeb3c0ad91f15bc591e1c808690a4ebcdc0af256015b5cab8d6a3a875f62ac46f10aac8d2772f68cb958d1bfbb9ebf68d2ddc774d974416e3ee1b36be2e4a639080334c14bef7e4853cd2d4effe5d2bfb74ff237cb7dfa2f9c73279f09aa23afa6c9ec92424b35cadef691f622575e64a4f7b77f68a3a77da9cd129049db23e28902863531be677d505d6877d359ec979208a88a44c2d8375d7e0c4641ea360da7b0dcce7ad9b415933190a42a8a2e8deaf5e75ce5de664e9a631c44e9baf0c38900d3e4b859e2ac761728e92b380000bd5cf60fd9c1cf66d6ed98a506c07536481e5a46a2df48d3a712ae252a040ce2c3da4c2aab657c91c568815e5c4b6d3ab3c67093082eaaf28491d550b4a5a5714a634537cc819e7577cb0b3fd416fea6e51bd40b8c766e443d12262352409df096420c61e4c3e62375419c2efcbd36d6c73cbea347dccdb4c833eecf8b6756b3d7f0c86a5316f8da716a0d378d372b68e5a32b3fb8b7b8970bb04db2ab2d2375e3b635bc954a50e7840629c9dd83ab28a3696dd6ab63191dcef49fafb4ff7f4763f191477a173caa82a11698fc319f38b898b63b5742b19b61ba11996bc440023c9d24f94d6a7da51fbbfd09c5137eda02feda55ff54a1bcf9843ea6a3ec63732aab28037448917951d776d5f6b4260547d7f2e161f027b3772d7660c0901998fc55b64f60668d7da41e87e5cbbc4e5f5820e9244391a3d793465296227a1e70b0c62c93e0e5aa3197f57f0303de0423e85176d46c563f3fc3a8fa47b6e74bf2e37858a467dcb4921a3d86564e7fc1d7e72903404875dcb6f998fa775152f4fe790485ece13ef99836789bc74ca172d585bdde3cbb2a2e0cc3865b90d16f3bee985c6b5eeb1d35e9659235129827a74fd768b7d37fafcfa5060f6405883f8219d87598830bf4f1e7d7c0dc73a674884cf452d12d3ba4d83f3e3a31ad89085d005d98db1909572bd3b007a66c51364ed44662629ad8f5c9423605ed3d00c7675c913a79c5ee8cbf51f57ec8a15abb41028435f8f630aaad1164beda23498d0f8cf50c2dd60a9fd22a4c14a2821424daaca3b27876397ef3ee2f4a9b3438e5750952b651b0285c96eba2b6928bae91475388f87006326f859ccd5dbc845bc3d895641eaf8cbbf5375912232b2bf48465ca1252f6d71f8405e821d1837baa6ec987be4ff46809553f8425cba23e8ba54ce1bc47852284bbcc38b2420ce037a03901bc24d84c0998002d761fd22a50de12b23d24803ea1c5491d407e94cca4b6d90373f8dfb7dbeb60cf16577548884674ed9209b1a235873a6b049d01daec23ec29caa8a257881eed790c75528148b777641d85daba3a3bb8bb0c2e9e8fa70f235f95a74f5627f547bbef1569b487f342931dab4ae54571af56e5c91b9a2a7fae858fd733484ecb527bc9e1a3d247780e12b8c5da830b7480f8400d82d8a6400b8e487a219dc148ea69b0552e00f914accdea364e8cbfe76826feae5f1c1b6a1dcf309c32092091c6eae6b16fdc39156982b84daedc85d9e25e52bb6af64163a2d16e5723e6e48e032c3de3c7bd02844652de4cf0bdf0c3baa76e2a3234ac3a23d04869928a7502485cfc49d4914b009a803bbafcc801edd7073bf971353b16b37369b07e8488113322cee5b694d8d07bf9e112edc8d66397372b8edf0599834c10850a99f7ed82ec223948e5d35468ccce09d6e796585f6bdb40934d37a2fcc5663695db18e0789d5a9915294ecf2217a40aaa7f6e9e1bb2690165c3fc977e1647a9c072c6568e3b856904daf928ec01ec059b7c27e20368390161e087ed93aa442e362c32913865464af92bf179fe44af160f90bbc87a181c365c0e7f9bc0e491f2679553d0a51e8d0b0b7d158adc24e6454840ef6a166e1dc0210677c36a6532b331b966010f79e1795394583d3a0c08a5e35860d13c5338cac1cdc39a5774c2251e26eb05a8eb73f7c1614708a270eb123433803a9b0a76c5b6404cf58e752e6516996848ce105800f2d27e753f9a5cbd98a7fdcc135fc6894e88324a8699f2b0272698aa78fe99f7376cd7439b240ae81f0ee5a3bda73f4ea9a1d507e3a4e2fb1604049bfd6775f134f0c213d0a4ec2324be75fcb701f56e31580f616fd05757c1604fb705e01e5a219212ef7445d23f8541be6340da32af6a2b9eabf86a425f9b53f42c1bb62d4b49169fdfef5b2b1d462d4e84b90e45e04f9b00be327677f53ac6ba67f46e2b5d61b29adfbf09a88e168a7e072458f8fb62a0a04a219d5893b044abf3e06f59b0065932370c5d30acd432fee61cf196f13a7ebd50d8dcf5f1292ff58d8c72a017c854a86dfc8005355579977c113d26a24d1ced40b5cfa9f71096e08e11d50b3e5d51090c8594d049eba59a7b4a717303a22013cfd4f295c25719fe59885c62e033095f517ebf18ba9be8159fa5dfd8fc9e5d66b551b7dfddd485ae0e76476ff940e8167fe4dc71cda2ae690df0cf18943e2762aab83037e23795bafbed31be09e5d3c513680a8cff3c9cf4694edcb1574ad5ef3083f5a52683078d3baea575db932a46773b7a65a3f88672524a0a974949c10fcafa74d18e473445c2160ded7bba84ac6bd0f2be6c3e14355424dd4df94b7aea7478b296d88294f44e2d38621d9d46ffac7cb4c526fa72a03ff04848cdee8440eba9d765b4ff9b683f28f4c4a3d4d830524b805bf85ef26f776f874285794f77e5b1dbf0ce9239005991189cc602207003966da4d4449a57f56d567293c5a581720f1de37720a6736cf94f21969bf14fcdd8329e2cc69ef2ec3c7819fc66a513024e3ccadf84cee3a511eaf4416ffc11ae049c1f8688a7e1e018825c14b131ce3bcca1bb36b7cad64093b438a0a11d4970840cdcd002c37503a31ced2e989595a8562b232c2dc7852bb44e1fa8d56431501611154a380cc3ded51e014a68573f42f4bc90d1c6d3e745b1f325b69a95c9a59e667d17da3fcb7bb55447fc123c66804f6df9cc561373f4a4f676d2059c001b2450c8d381aec797bafeb57449c55f49287c9c8bdef4808837131ef725fc1e23ab87d4b624b55965dce720ef911f8b9e32bf4f0e8e1fe078f36f8f537340d5216b50418d583e96b318e485c109953166a189d51701d644a967caf78a16286e474e9bb36283882815b749e2af53b00bbbe26727326470dd5952e20481322d6f8aef382069cc0d2ac510f50f228b6a467ded295ec4467b4a29f16d150e44e3b150887691fe641887d74ce02b06986157352311ae6e55d8a30e28da33b1a88d3ee3bb7b44daf2097c0f7ed4471d2379bea0d0881b17371a3669815a9982c88964c22be58e604b4be984b2611c25f15a6533cd31259a38bdafdf81ae1df11be982380edab3367001f9d5e8b5995084856d28ffea63cb8debfe7e98e39064aba73f5f9e61ba8339f2a880f2b319400146687ab2f2ff0f2b553ac61703aceadb0f4d7aa5264d7ddf1bf7e69a51248b8a681f9dd8b4d6aa25a6f88bfb28ec91676d89a0cbdd102bb2d9acb498823ce5c7059c12f6b9b9f091cb4b63cfd785450216fbf70af89825230514deec0e52fb44c0f385c67ceb5762a9c657c8e68e847023fcbf01199c3713c5d4b20fd9640cde1ba0fed4b9894f1c79c7075d802980dcac652b1bea426622cdc8d4621d0f61fafa69b327356d26dcd07431370664ce8cc646f9a7ce6e9f9a4d218e6f1021791f1a3d6de65ecd9702e57763e9dd68d26503d8037b19b72149e642a70914128a575edd9f6fbde9e08e3fabbc2e0f0bde2991bde20701b975b76d66156e3d42dd527952fc0d155c6fc87102ce63a6affcde87c5b2d6e9217f6fbd0b516db9068d000d247157ee37eafcedbcaca33b2c0129883fe0c2068d9037a421f72f831e7d87823b9c22f00def05aab5130bc74ec48ef2603b74aee9034b57fc9dae3cdb0efbf26e6fde996cbe3fa43ea35fa463d75016badb5e3b440bb46d7493256514d038e75c3588ad466258e78d30e951ac94c6bf35c200f9b6af169a2f53a33dfe7161716d421d584bc8ac8c7d9c73dd03c6c4bc06a0d4c295c85ea3c41b697f130270ea49d328b10a4c7426cb41a730de284cb2c6c9b55797a7324e496c13c7dce5a4e5c141bef2d0d307e5549de49c3350c0ad761ff374fcece9c092a45e76f8fe14651ed2602c72a477149e0bac8fea8d76c6e88c2fe18c2a87edb8c5d85ea7e99edaf569e1ad0ac8bd0d19b5f29d8175397e18e8c5d2caa930304ee66118e3aca109c6e20313fa4c1dfb7f38271b93a4a773fa7abc0f9fae17a1c7c4cd50a030b20752271d2465523b4f8e4b5901d717fad8fd20c7bca157fad55333dc053dd4de8b4009530252c42240b0e2cc7825c602511b4abc0d35e3dfc86b5d7a666def7c2863d5d011d69dd2a0eab5552f5ddd3f8e07781e3d1a16a8379158fa36e0193d15fd1412a3d05db13f9d633d23c3aa5d84c626748bad218a8cf42d7a307374862a5e07aade4dd92f63116c476d2a0fccc36a9609a83dd319d99a54e94d850b3927c8aa54022efd6d8a17b267fbc183e1fd6ff9294436af22645fbacfd65d5d72846f3c3781af5f7b1378972df0daf9ea000a3491a9aeb01a89f4adf0073c12b84af5cbf524e122a695b7657240de358b526dc146ee5ccb5bce4a9fccb0ccb73ed3189608139a664276abe305135c7d63deb3b817023fe0e1dc135893d44748444bc197dbc8baf7296d40518c4187840b5063ec3ef07cb6d1dc02f096641740a304d1514a2937c6775b1c73b75005db16c07ad03bd89352fb984665f49e1a90c0c5e3d5ec0264e861516c194e5e586292eb061b0bb2268832b0ea4ff1c5f404f18704d246549ff5ae8857eaeb5e6a6ae48cb3f28310c457a9832ac1901846f7587c39502151ef5cc8393f72a544a6cd0833ef9c05e5bd4dcc0ad749b66b054d2b4534e285831d2edc99eb4494a1a5c23f87e74e2a556208daa58f4ece4755f2b9c6b618d30a34d5eb56a7097f5809eed41a9a3c87267ace0adb06a094ca2576532f95a7c051df63a224770561bb31c3175259bb7f3684b11bca05f39f76d4fcbe916c676e68622b9fc4c541323f2c5375580a97e22f150196c1f242b126460b990e4d602c86b148d8ff220de2101e07f4efbb6b14ec2062cf01f5ad615b29050dcb387d6bb0351a1466ab4c70ec299e4596deeeff47cd27ae8664e1c790d07870c46dd9f5f7174b588167096a7f75785a8d470dde6b4d1d2c214c037b570aba2f1a5d00c987784a037926a4b83b613772211952d0ca6c13ad6d5431cad2ee34b3a8cb8f867212fff5eda6e9066e78c3c5a3481d59822b76b338dd9cd3d2dae248ca07cf130812b7d0c1248994327524412eefc27b9fe787e131550bb433306e1543cdbf070b5628b2a41c04a5c1ca7e9081935f64861781d2d11e5e061812fa854ea0c6133579a3bb326caacfd277937b493c8ff297d3766896c86677e2aadae513da6c108e7480e6a6c247236db0a2670a30b61e83d7ea77f9df4729504ace9026d0518d6aa1e50940f3e718a7b281b5a63c8ccb8b14ff15598f5d72e2bb2499d59f8682f5dc376358875e043363634ccdb274abfca045ac77ebdfb9b47dd95c5b8c31947820c55c7a8bcef992a7e1d47a3ca945a66f3c53529a00fe5484013fc41ec60b371968a004e7be7f84b36dd7ecc866ebbf397c33d02fa83d89c83ba2f39b105ab9d24b14ae0d8466a9875dab7997d443c1bf47cf763c956b942cb2ce96687d5b472b6fee41203a90d64e7e04267b1d631a7581485b75c7f3bbee55f5d639b8659414d4cdf95e6bb1da04682c23196a595328b2a4e931f7c54994f43766a6268d22b9a88c6f77e3a928e4b6f1d8fced5425ec93f389013b3c829c0a7161828c9cad9b95aedc90dd2c9cef4d151a31b3e4a4832762ec7cd5373b1bffd721597b019812a3914d03064062e968b02d2aa66d412344a50605d0ad9cbecc850bd4f38d9a8a03f47bd3dd77f38588030698f388a42e26bbc9b93b47a3e6bb0a0eb9857326d6bbff32da1a520ceab441ecd55af2d4401f0bd2eb8961764e9e74847fc8f4bf75874060e15b67bf71a18618c5c00aaef7842445f07013776ebc3b978a11a2cf7b5de3a75fb5358dd7802086c2076dcf5a454539d9797acf15cd9ba534ca023ca5d34a2f9cc38b036c2d217bcb4bf7273c9a6e4cadc6ad7f615c57d8602d367a4924c87b6ae78973ed602e382de78f8f7e90d282513e9cb28cdfb9976d1be57ebb0737591e759816c0c86e27a0cda0e4e2f78e15fa8aebc3969c89dfe511be1e6b1ce3c28f154bd4665f8be468f995924352aad94488f68246ca50aaa027f8bb6c815581335e5d4298d6cfcf510770871ca5197c5f736e485434114e8d7fe26d3210957b9f010e8966bffc9e959a2a64a398671b12715ff991af3c02ab8ea4f7190a78cee9b954955ec476e23d4dcd22881fc5156440d97e3e67222622c38e0e3566f170dd70037e3257299f8eef2395acd34d21d842828a5513d0369cfc077bd99724279b7f6b917f8b076f5b9ebe61cb17a884e3412932aab088ed1a853ecba226ab0bf1c74a29396cf9b343d5ba5af9ab22a2cf99fe6bea2910f2eaae1fcce73cc0084fce797cda4b44bc603e549a53e120d41c797a7624366673e44079008218f1d2598891b6f9624349b17380fe6ef3efebc2a9971f2e1b3f38bba4061c6f1cbd7099109ffe19c4475da7141536cb85275727def9b32a6fdad2e536426d16e21d475aad84acdb5440aa67cef904fa925f9a2ab879893177dafb6b3d8de0666c1bb2bd593cd5f360beaa60ba16d925073ba68140b1a49f9e88151bed569c8ca0b01358a7d275953156622c6c5c048e6e2937c6fd817145eafbf0e2a7269963b28cad58c477685a614dbd5937955d569d6a076182903127985f99e3711c19c84a82f21affa00809bd0f4c0aaa35b02e5dc78dad363869658dcff3272e129aae90fe1caecc8ebf91145e5a243d94c6d5124e9b63b0eaf4523577537f60c12f98f0f1fa9d880579b2cf41fe9496bd4f8ef5e23fb864b576e813b5d3839a966aecf972af1900257560c4aede8b2ffda42ba49644396604fde66de2abbb74bbd03d81452958570a04e289917cdd1f4582c22769f1c5eea74e316668b9d2c90eee3bd7515908b60829bd23dd33931f6d30ead319d6988a5b563a97fbc6e88448c6df062249e43e2f3f5b961b3b50e53d57fcb91aafd628929fa4839e35bd9db5ca1bf9b0972a41285845792b211d701650ae9468db51f7e3724c6e0fb7ad8c80c935bbf4795020d78925d12ff3c0a4f049ca0046b8776a69917b8ec8f6494b9fa399094d29aa815bc694f76ca6f00a342f427bc03fb768453d30ee9b69fe0ddaf5b8faec293a04570a63b0b57cecf6234595104c296b58b0738d1f02bbbc197f1f2d302337635f1c74d4c56363aaf39429f398a6432f4b193ae3fdd5244fb73fb86bc0f093e7be152ae6e513885d2563240d839969e47b2c7b4e976958335c35a5c4ef6932865b3fb331eb85f4836be4914f93342a55846a6de19a60d933d0ea1e54b2387a375246b47f6a88d2e10b21df4e926c74602e62e58783fd887953afbc6ac953ac417776a8f75d0d7254b56984c6ae28dd9126d827d1d75370f33e129d01b422452b65b9258dd65dc80a9e9c6bb8a3fb5ac106d187c1d751f1160241f7bb7a8a6169e60501642391a1541c8589c9eb87f3c90548dc071f05086eae1180851c2c7ec3252600e098e51389cc222ae238735dc48e85dfbf574876abbbc59dbde5c5154661ce691915cb7048c73964915ecb137f616510003cc07adab71a9b0f3e57289fe4530d8908f18be115c0d9267942838949fd2e5cbf696a9e561ee2067634479f1a316ca5de4ed109af84e26168ce082a6a6c4ed75f644875d08114953eae577631c0a38103870cad601799e7eb63c40dcb4a6a738aa2124996934774bb7478817d71d5f0c3dff1f9c15aaf0bbc18c3932b337ec71f8d155661a33821f207021e04fb3c7bad8d274a45d023746acfaecaa6c27448cf70e732fac5ea4638c46a900fcdf6e49d6d4b43957c0a5593576fc04d635fb0574d323017fbc7fcca652c5cce13e245aa1edfc8bf135b2fdc711dd91a0ce8fc2117719774963d92a1b8bde1d11b3c09923de0e8187376480fb6057347a8c755a44ac195147a88874f6fc5789cd6de9f35860657052826dd6d18edba6d42ec92aeb05ec418c187a96ce5535add4358e5e00802e8adf4ac15d151c9ac678461e67a64b2ced27a0302de85d840f71e5652b7ac6f6dac2196351b36355ffbed9114bdf1ad29967967027959f3163b88c89b1fa0fac984f3af490ab07af5d7e6d8024ed61ce594612cf4ff7528a10dbf2e200af6359dc71aaaa3ecf1898e3200ad42808cb090afaf0e92237aee3537371e8eb22d8e6aa5de94d8c912ecbfcfd714e476a8ff5722735850fb50f30919e75122729bf102a8cb85bd6c464cacfcb75d522db2ba7130b30fbd84490641b958828302af74785a67b580775465d0ae445ad9cf7b7012c214c282e7a90be853856d6ddffb951642a202779d1c28128170c2e659bbd55c86c39e105a6c8cdc53b3c4025cf912b805ee885c5334f5eeb8f72d62b153d7746aff8836e793bac7bc09d4617ccfe4323f37f4c8412ee9faad395316481bf4fbc0295c42af3c6e0f3ada3f5523a4689ecffc049a78fcb1f800adfe00fd1d2344e22370112e10b745a30c4bbdc3cbccf2cdb15c2ca979ecc7522041ac05d519b479590804817d846b00f6982359d6006a20e681224beb1e3ca654a65e48d4e5f4e5b957378c951a9cd8d549389b71a415ca9570143d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
