<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba47b87632cd626dc1202677a1281a603bb0e91f1185c85d749c41dd373fbc48a2f40549216dca09d2c9703e92e2a07785815d4a65bc1ea085b1d17c65e01caab72394be584154b06607e7c57dea5747723d1bac051a0b66bff27696c9c6c9fbb46f3d481cce6aff0fcc5ea19daff3f85d770ee54bebbadc65518a11d441d69d321ccad3c13faffae42120d2015fabaea5274db9cab67778af4c012806f91e63305bd2249b2b2915aa742c47c146da3722330950e8dede1f035f740993c9c03c9d91a1c360466c4fed806e775454fa0065224fb899e2d5840a9ab4b27266ba48de9f7743ec27b77a2db4ac0cb5f4183a9afd5660065b5def568ac5c243464ebb1e5fa6886f0fab4d1f2a6d3572b97bbff770a3a83adef6febd2b56d08bb8535ff0674bb20310882718dc43b3e788754b3366d427ea4711e963f928325e8017e08a1473cf2edf8485f1f9d947a4310071de2ad0e8481e369cd86cf7ec2633f83e8921c61c4aca24429ef7505ff5052d86d84cd616117fd361cd9c9a3b64ec927759423d3261a8f46b624c5d8fe65e2816714690892c218b96fae96877a34bda45a5277dd887380edc22915d952f2fe4536e5da93db37f3a40d03979accb89be6ccd6e3107a7b0f2d7b4e682342c1862b479c3771e3fbf31fdc230203e80de2f9cebe1e9970e0d53d13da23517734c5dadd361f1c4d4bc7c1a55e03875615e969a83366b1c2e94a9a843a22afdd280b9005f97dd67d33b346bb08b7dfc6fdc993131bc8672a0f5a2a5e7b56bfe643e264e3028b679e1b77cea0969aa103a27abaa6e8ee6ed43569cd648eecd000ba8f3afe2772979459c918f0650948dff6ae40b314ed03055b1f89cbaef836685145b9b1087eb390ec2533850affd4fb8d31db29b859b2dac735bd79c55a108ce4138135fa539f398f980372b5f2f66e8becebf281e827baa36b078d3ae29a52675a412e0568743d9c55aa5ff436cf2acaefb938feab8b70199a1f328493d4a9978e87c24fc39d9ea9c814d9fa9d80854c77d15e15b11f7514a92c24df9bc205d4df66e74d388d68775729dfbc65c03585627ff38fc7f8dd8ffcad655076212e7d7c3ce800c0896f537b5a9b194208399845f2613e9995fc2cfad2f03e8d4eb903474785804dad9a474cedb017b79c68b847f5933e0e67ed41e994386bb7266b56539a7385518fdbf9732f5ed4baf8f65a74d07c075f641b2e0e3d8924b4c3de9b314b5a0859323db94884d4db83486b2711ebdf37014543df96601bd905ee47141ed90ed9e2d0d3311aff0b36707ceda293389d01c1513a71a7716609c1533ecee3d56998c05c9a77f1fc9e730158a334749dd7331060c66c753d5357453505c07243f605299406fce4ae8dc1ecb971609e227defaf0fceacbc992e38a328d7e7bc4d12358dfde0cf33ee786a7691bf08893bba79d086990567e4ff639ce2b517806d60e89edea6bcb0cdfab8501d0958d34a3b561036f4b87f0b2053a6f6c9e7aed255ba2237f99a742fc7d6034b4b252731415dba55b96b0c78a5921583b5826a77f1e6405047d4787c8f9eaf75291314ef48e3db983d28d6744deff159d2334127fbf24c70fb06a42e43ad299160f7199f19702a94aa10f77714c49ea0f59e190fba94fe51e4363983bbf52d7abd0f5138dbbdbda434bd3c69181149f814c461ad427ff7f66dbf8dd4d398cca3c213c8fe66a596e9643212c99f48a94e3bdaf4fbd8d948f3842c54d72515b8f1f75ee5fe19880b7fad7deb2e589b9a538f8698595b11e1dbebac9c1746457bd93ace0be0600db1f4d9f8122f8317295670b9385a001095abc0f9f792bb20d15d26439a9f3f90c792c384bb75f44b1f892a4a144322a780b24fb34c5d363cbeb69ea36291c02cbebe5861498f2a4905f8fc475d136e0ef8c941b6112e1123037d248d04405558365084c5a89f19cd542fdd4dd199a5159db6bf1035ccdc361a00b6ad883fba4b9e6f4919d40c70a6faa132519f2d7978286d4c710859b905fa554be19d090f70b6db8076c1d9fb9c93927551011215b6e12f08d72df310272cf9452edaa8b52b492337caf13f0e8af97e01f8f51af97fcb9edebdaf141f18e1c8f4d1f6711ce177019b07c12d03f50d72499cb8aea6dc4ac0318d0d420caacedd6a822d7d3b4784ad9605a83ac873c2ae9e57bae7f1203f7a4245b6f3da710a888531c28782b74c9c3c6956fd447dfb562fd890205d3b1aa2f460e1a2fbd44f33f3efb7a20592cf82b454ea3ea4af76204aa7dc8f9b84a319df55d453bd44b0de7830d585d6726f3d846ca8f9529b86621fb90319c042dd2c8e4d7c3b2edd7ef51e3181bb96c97adbcf0598911a1ec773709a3e6452cf52e16f738254dabc3e73f95085088665a76112f2a2b209104e6ef0fffe49a4801284c0cf7749d9c3d9d13096b6e9432bd45b404ac26c04b188b38107dadcf472467895f18ec3ed6fba618fc06d8d791635d313fd6d0e36baa8b56280f80b217b274b2afa41109539c13336730a4a1dbc33dfd1503742363a5f11a2c5f912f5d4a1173f98125b34dd1c0d5ff8d466ae69fb299b25998a33465cd0c1cf4a87b605c8d470e45fb68bff17aa82633bc21ca36b682966e238159acfd8aeba1544a1bf6f1b16acc5dd20d73eb678769acb47c8ff7340ac7dc9b604bd0b1558ce33fe666f46e45edb2934853a21fee843681f122d086e8d7f06e8f6bf6c980d58ec58b6dfa5d72a4b50c30ec71fe7b45be453d7223a5a527723d0a7110b01f7766d70c1061776d70f5aaed2addb44220cf47c38c45a16d5444818f2433e03cbffb7aa1c46f344b700b46b1f96069e5765c2dd3c8dc4b11d03eb82400eab243ce639e7df0d90306b591d2eb12ff18269e031b318fc1dcd8fd13a923f1cd1e73ea439bca65fd0c71ed9d12a955ce7a6ff84b9ae1b9788e220b07f9d409232cf5b1db8b58cc9a2ad24b4479df67bba481978a7012040773bf9d4e04d59f4c04d6b09eac10f19ee7668fa20611888622cd4c0feaea9f9e26ac5d2f2aa21a8ece6e56a54892527fa73a50d8d303e6b902f46e93b7c8c95a971beb6c0aa9a8a8073fe4f8d18d9524ad1efc545afcc72b0378811eb23558bdc444baa6dbe7a3ce1178c0ea6b4f2fd11e018d736c2b8cf06f7be3e0ea3bd6be9a41e1c7387789b505a4e4849447cefc143980694f9e934535cfa3243d900d5470f51ac2d61c77e8a51bcaf16480b3cac69e1109b092fe6d59248c3cacc197c6e55cf43cdab35f03b131e17740b47a7ad722819896984277f1c2c45251266aaa60df7546c11076d3e1dae95b8b2509f32be1e57f12db6255f9419731a5f3d0ab0faa3ba8ea497ac6f84d5d0eb60afea995b740699bd940dd79c7d8db11b665fa8494bd27df7f8c1f065e99d0a68e59669fb2af6c474b7bf22e9d836bab40a485347aa84f7b7cbfbd624d7c1d5de0d523932086f30009f306a3362a7a90846f652ceb3986ab7f26e2b525f6848b5218405de1a46593533774b7df04ee0a51a362fefeb385565a473c473f8cd4479cb059b9cb576f93a215429fcb05055863fdd31532339484641eefcfc25eadd0dee1eae048ff2a1ec9e0d8ecbc8c4ce08c014c816407c3bc1354397bcdeaf00e2b49abb917c0de680c61d8d951609a1f28812cb70907c9ecc34a868a59d53c2704f820996e91f8674e42bba60fca48b33972c610ec9d352ce4f82d1f3ab599081a29b588cc473177d11ffacae3bfb321f48728788a042a792edf6cc9a5bea6930c9af8ed9aa2e089ba65655716b0106aa7f0aaf2b4ed454f92911201bf89cef59a777c56ac549d0b117828ad3c3b41fd02a6364078312ff65811aef3effdf7f63992cd0f39e3c0c78da7cc3c7d3ed81c81e83f2515c1de6aafe18dd9d957dc1ad7e9b427380e61e1bed5fb4ad8252f6059893f6195f76df383e019d988bbdaeff7e20edc00a49ce2c8d6f3dec6b6441111f0b3abda1b21e132beb73521452054010b652e2b9f934d37bc643595cc70423965bdaf826ca6f52f9a44f71b0c7e7253fae64f5b17823f89bd75e29fc207e7e88987b0b4ee5b6fe8c9de468f8b422b60daef402093f131dbf86443d250833affb2e5b6f62e6f4690ee7f54b48a00611ce86e326b37586b5b4beeddcee0a23accbea1e4ab54a1d6dbfd6f7b80b92648a812f66389d1e973f32cbcedf2100c97e6dc7f806e43313d12ae2b054e25f0abe67fdf15ec43729ff040a8ea44dd64cabba7c2afe5ea623e0db9c37d1705a005959e592b5be3f582806cb176ed9ce48127b96b367af190ffd9f79b4e8302420e62c49e5bde510077a39e46c93584947f91c598b66f60d19e5a131c9cc4ff05e6776606a6eb9839716e35b7e6f27b8eb534dbbb741ed1cd941a1d6072ca5313b6af491192aa34760c57862a0cc1ddeddae22ec58349a225dbda6d0daef9fe0319a4ab193c9363b53094f61890155cf9791b83ab7fcfd3acf75a09c52425c075c8b89f34b79f254677bcc45c0419fd455da807eaa85bd4a4411c918d930bbcfc6fa9625b216ef7753a194dd48cea36f1f412a35c49ffa334890abbe17fd1d8e31833e414146c44074ef1d833e1003416258c71e3d92e60c63c96eac3b71d5ea58cd6ecc1662a64e9f2884ca1ca861a5af2762231710cd9be3872b51b5957e81e2e9129d676395facd17ad7083d9cc2e191729525af3a6e14f2833808c16b990f0bd5e1e68096f59f2788b24bd5598d3dd0c7d8f5c250ad8ef3a3bd6451d4b5d0e05d63e4663514fb882575561d443acd8548a532d614af672c495dd32e3cd944c457406b1b428db8f8e813bf75619b93b36d5b30ae77cb3781d376e7dd15ef0c44d168a2e6fdc3b5c24e5e3379fe3b55bc205b31edb27532cc0af32d66575eb9ee60aae15692ccc3902d10f18127941dd542cbbeb4a618bb8ca0c6ffc674c15bb2968b4c1f6e20df0f984389ce51bbf854efcecf8d5e84ddc6119eddcdbc956571d911396553b20a2b2332addd6afa7b3a8b2ecc1ea172b07dee75042872efe76c262933e81ee39124f00e7460bc9ac85b49360bf47837c35f35c5228c7dda3564977389d8c0f62238235db66d9ca88302e73b9457723d3a0d14298154d24dfdeba19d7bd012e9e06c1a65bf51b596ebd0cd2b0108b16cde93e45fa3f09a7602ec6f319e964c57a6703c218ac23a0f496e05f9b01e8ee547dc1a13b0467a7c61e063a9237bcc814d178a74c69b357d823f365fd4e307e49e29ce3c934ad66f43225c8c76d097ecec09572ba67444f5c3ac3281eedc6a18281336580a030e44939b4be842e9484f4ef49dfe073abe28e4ad9a896627fa4b883f020bc293f3fe376c8a1618456dca93c6c2d0c47df609b66d87c8d8553539cd109fbd6f2e3d1d34ce64ff409f5701d3b2627920fe7f8646419a5913a02d5eefe0c463dda536c373f994301c1f7f2a7a3920c9a4d8ecab28baa4e97a3d186098753f4ad09e4b46bfd8c5ccaff7a6a5988a3b9d2358ee7c7815f3c0b433403e390b1147a9ca2e426f006fb3de342def8a9272f9db7175b5cb80c76a630ed020e792674662068c0e6d34d3d0298d49209feb5edeab1c66459e1206196cf822ec347b37d75dbd108f6124dff90ce7fe4515171cce9cc9ee4a8895e94056c0d7c718090bc8288f2a872297101c05d9caad5c14f0b7c58587ec2057344e5d443eb1456fffb9b317aaddd847d86532f9f4aada47cd0889f487e2d8f1aa769087bc3a40e6fdd1089086786b6d96ee128941a5b4da8eddb1ea751fab26339bb5bccb094eb97934e58dae49b9300bad0d8d4f85bc327a2543118fcc7a9aaed697683a65509ac5590c995d1c319267e66970a36e8bf8341523a2a92bab55977cab3ea84154831fe176ebb7f7314a249659d7fe05c482c5f0e39e05b3abca24a2690c4cc36c6f3e54a2b881789954adadbe868e2d4a61691fd3843533785c1d5ab9ec279a818510ee6353b78f484d72d192583fe66b8cd7004699a376a21ccb675a5c3443820d1b849e0756bcbd052b6cf356879d8d1dc1b8b9e4e8571bad4d477039321bad1a833f0355528afe0dc8f1083a67a54032921a97661751ee3cf1b20fe9b743d2de48f478ccb4a908fa3a39f3d8ed4108c5bb6cc9c28d80b2bda1bdee95a5d28696077a16b61db0e3f2170106f52f1b4e466839832afe090d2f79384ce6679f39e75ba30c0337196313bb41d0018891ba57a244b6dc82a6292a08bcbd44d7d87cf513522fa330fc01d064a14a9d7d3d473ecf9188c69311d3601f3e40fa808910903d85896a2389737423b76db3484ecd44f15f2227e398b9e5813e33aff697722ee884b274744e08341b8c13be1b156eaa62df28375ab2dc0a12b38deeae706f61b44877ea9229c4e3bc513fbf87337a707061100913c9e4ec2e83c6d6e9c23dbeddc92539a39717e5d89d5d67eec8e61ec1949cb05d51694c76bfc24b50a56acb602ad4b228629fe13b3ab2394f68ba63fb80e82fa26bc0a621e3b48af10628d631295f6fddcc820e89fecc8fd538fd3da689c0069da90033f893a6ba67d443c423677af8a74357da29e334dd75d4001813873ff1a3c3d96a368ae57f6973971814584a4612df82019c92f4c9f28bf3b6ca1e1f302a2050bb09c544edd9020c4c2b4b1f9ca5bad923ba5c68a5cd0c23c75d103193abc61fe273dbc66e3743a50c22972ece554931538f85b613b50cb622e18d81a686b8a18a7d8a78fcd72adafc8ca247ffdf883a14474f016b1c3c03f0caf4b4ead7fae046f9aa99b58daa226cf56f3e4c8484fc177c0a4a2afb4e047c815489125b882b2ef072d6f6c24825a87186f399884bb846f8be89527a559bd91d27e6473ab45dfa96cda8e8857f8a466c9d1701ebfbb67e2b5a14f7a6689209e48342e1039151c65a4c4cc6a4ef595abe63c7124316206ef5062f9e1bab7b474a4484f87b31d3280c4daa1075bd04cd3d73cf63ecec3fe7e48d7a818faffe76ab44797715877b2f23b96c59e0c92fbdfe31e63ff1a68cc655981daebfc3237cf81510af8bd6934d8621866b715c9add1ab4860b6979ad1cb21897d8a5b6d714bb09faaaa83d01d964ec68a4e9c83031675449012a33ea3de7eb36eda11aa4edcdcc3a2a24391c611f4d710fbf79bf8fed02ac69f16787dba80b94f66d8e7b069451bfa29e6f416ec8cf9f43b45de02a4bb679165e8af964998e7e14a1ac37816a0fa28c7cf625dc27a1b923e60f3254c9b94ee070ce31dce884f5291942027df30d0102e28d2213a46004c96cbfbbeb4099cc622caf16713411046577c819322c67120ea7c985b1269f1ef54226bb5ee7a2f0f9fd4a443694509aba96310eabb6ba67020c7c1ea0ffca6db27d93a3b3cddebd847b0c8e028b7daad554b93e322da54fc1205caea19af07babe49b6b9437fa4eb1a1290e3405a756756a8c4fe290588c33f489d4b50dbbf3de7fa275276a328b44c8ac56caeac82a5c42dd603ea2d18aa5bc804b5604a7945fe50c31a54adfb4e999727e14fcc970fbba87b8c12a5197811205ba6436c15a4b39ba9067083c46e7cb8c6230a60832382a2548f16076c247ab19423a8e583a0e5a7aa5ffbba6b6c4e4274b46e82287b49a04850ae9c7c6437b5ad22e1e0c103aee72d99ff41f5b15184cf074f76cf97424874b184969dca71b9634e2808e1cabd6cf5592e2de648825d69ac645ebaf07c671a06f698d6fc3fe3f2e3a1beef792ff59a12541b423ae1e1bd567758528db7d9dee7ba60545b044e8ff927d537763b7cc54964ea60a1b4149639c83b3ee8cf366fa5aba8d21e2e207d9bb824d11436df600f7f4cd809b96d13f9f62493dbb8c74a6e21ef761cf6b00759e0e2267075c4231cd182ce75ec6e98e7d55baf0d1f04840e895790bf8782aa72413e012e3b080c384f62efab05815f2f29d0a7c26a94c28740ae78460078ea6664d3e6d8b1f3aa66bfbdffb397961ffaa755ed4694d4882af433fea2fe94353b567794d77829f3336ff00449bc5e0690fbdf9f99124009eeea154cd21dfbd4b95087b3668ec3572ce6891c0d46253f4f41fcf16b982ba9b10b8449761892b8d0aedd991c75aca5204c9a9f2600586b98de9d9751998a9de79fc8d667569b22ed62827a6a916d97525521d9c9b674b532c9418d0132015cc83aaa9524a3365c9d11bbd711eebfa066c5fdc5e1926124e7b8e189aa875bf2b914f394ad826ebaf121741718ce8393b03ec9d9587935ab1909b7777307db20c857fce5bda4374e08bfbe7bca76c84ca3b66db17cdac5cf8f839c76a61d8237230633dd8622408a07a613cd43ffded3826b936100a45f856200124c85ef8f1c29ff9528f450d5b3b234af1c0681fabdc17e2fc34fbd608dcfed5ed41cb744e3ff6a9cc839705e8baf6ef389686735efbf4201cf61a505a0c9a21e26018bfa8673068bf030895eb5711c5bb846900e6897b48c984749df3d986fb5f08450bc1f1be9fea94e9cc679b8579621ca87513daa78335ab8f3250862a22420b23019ef1558571dd164e053603654e4332dab3846d5af0c2813533e696878447ec4eb8e153b2e94ce71802bc20f68539185364d74c685ffa2512f86638606a395d31d066b0ca220e2d2d9c935dc7a17fdc4a2773e61e69e98d1eb4874fe9a4e30b129ae5c375008d757e8d2853b77694c0c6adbe7263a4301ec78d89e69fb4173421fca5a3a3476b8760b8029cc67964595128d428aa6ca5ccfccf782133fac75577a1153444d22971909636d219ccef3c8509aa1045ff202539f0e20791e942a50535c9da1ee1ceebb30c2c82439b4381e0ce7d3bfc3cfa72a09a9d2aff5dd71ce18d5545050a90cb8ba9a513e69585eb00f157aa4a5d48f8d64f493902b7b40d5a70d25e4c29bd833ff32f5b008ab0e62db2be2b99c69971c45dc3eae5570121b61be3de21819900eb27d57478273f460a06dff1b9f23583102f6f55ce69421c6c549f83d013abfa0766db700f6a2ddd67561cbe500276945b62df9458477eba74adc97684f13f12f50a151a7c3c0d4b2b70f571e89648f67315bbb357cef31e7b01e93bca221d1f460f3e52e9ec0fbadd72c8c86b7dda17967f0f53264f522310fa5e74ec02a56e9ebbbc7ac1bfc29298e67b8a4c7887ac94cd31680d4a59d0077d5a30d99ed745a6902a5591f37d0744b3e8c1eee6928ec3b981373ff7e515e63997e7824f9b8c3df27fc4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
