<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ba799ad56ad67b1eb62bb83ffd2abe0bf369e14002cd4d175c45ca922dfb57f20509abb2aad7536a4d16924d5012272ffdfb2bac6fd33fd401a1306ca165f65a4c3608a01ad20ed46713f2e44344565e1e074d1cd384ae057088baebe6b8b122e7cae46f835c5c3907ed94073b6c6f4be07d5a296d753e8ec3029c5574db292730fa6732b62a55d70f0b8a005a3b7a23ac0cd0cc00cb0230d4104e8fdcf7805b8b88dcb437972f252af44d014f7620d430a594746ce921a5b61de436e772a990b9b37209c4ef1e5aee1806d3d8e62ea68e698b7d0bd7a0a198149c213a6153d8bc17d27b6dfdda6e4831bfdb6317438b6791fc9e86a1579a22d38bd5f4efc9a7597fd30429f4d02846e25cd1243f6099c71c8b03d8c6e823cb76baa556d5fff3545ccd51a3004fd286c13a137268f408e1f11e04118beeac5bab4df7109c5e862ba5131425316165890e5bb41fa0da2a1ab788f6b652959c5deadd27c9a60c84665651697acdc0fc690384d4dc427e95887ad8e731f4977b33175a2d95f3396426861117ae49ff01f58aa42eb031088481639324dc3bc3f36efc1f2822e400d01a7beac1e4ae172156212469ad3fbe1fb23dbb4d270c330139d8884b066756665409981b1ca326ac7c204bf811ed1e6e4ede0bb12c2e69b61fa3d3dd79ed5ddbdebbdbd26cb987e243f66b52242909a4858f69c562a61d175ef70d57d13fbbd548b8cf33f67cf58f11372758c0581c7034de5a481c2d80d62eb9402beb8f42d7fe6fc411327dcc14293f3344f0b736573f8a25806b98eefda55c37121084d378bb8ea0d66f23349edf7baf5bc1b4b623ed47fa0c5d3a6260a9e340e61467762df9584526ca00ec71fb976333dd7bc6745102f4adb2de7db10cec76ec79c24ad05647150287057e2cab971f096814145e326377d2f6465e692cfb7a89185f6f681db6f427d7dd13a02c06d41176de897d653b7af762ac6de29262d8fd6cd6a3b4404b1f813fd8992686b209e772e397e9e85dd48c538b20d5198cd092aa8a6c989c454ed8af373d955e111e84bd199fd0633ba201c13ab1682cebcee783ebeb552ce6bd622010d8866f4babd46b672a99f8af206612e648ace829cd653c7ac779cec948a7a6146fa67f7e0248fa2b76b82906bb75159ef937925da2064405f80f4d35e99af01d1c97d76ae7b5f2669f224548a4e5db0fb0636965656d56f979fd32b7146e5169067ca58623b5401779c034d45e13fd235f71cc66f4262248bfd7e3ebb9e3bf61be48ec566e489aa860db8b9167891ea35be78bd1d97bac133328dfddc9fb6b85a97333ce7eb215b46eafed77c38d3f25eac5bdbcbf4a18b9b13a04828fd0e99fc42da3c679dbec77a08304cdf9b83a1196ef086376223f26477210f7f14c4075a802847e01c8b3bfe0c152a9e071fd89fe705fc69a110ab189c29790b408418136ad9f957866af7a7f871a6629f5a0554584d61edcfb3cf20b7d5eda26a07dd6a725046a8683b72467fbc87df37777df682c10541c9ff78a26018244a5a5a7762b218f214c9be6015998b8dd8acd43f8f761e7bb01350fc7b99cec067655cefc16126cd2d086c271ae08d3c019b847a740443dad6d1540fff71df762b92bd23d825c896d7efa2826859758a1d546dc30c65ed7ae57851fb5b2bbad55b52d91f3c138de125ff2c4f3b42899ffd93680687d09e3fb005274c8b643e17288303189e1114878d3ed5826e65246975c1bdc2a54f8bcc97024384244174a4786111d3e3588532b6c033d7b0c7ba37faa39b2705adf96abc91f4b4194f0cdd95eb6d4d86810fb0ea8fe1618c8377825f58b289d05215615a98acef7faa1ea4819fe189991d125bbdafacad84a65014e83f00cdc86b5cf97a11eeed0b2bbdd10b86ce05ea8b44e15e548dd5c3743da7a53c804781034ea84485de5e55d5b23276fa344b271d448094869a8a5e9c88a4f4c462d8f2db925a770ee730707253d09977c3071d5311b169a4942c62fdad81954646c6e4c7fa2d89a38a72c231ccb4cfff98f5bdb3d050f36724c10fafed570c5919c8bc2c2eb48217f7c558dd0c1841db78308ea0bb0ffdb45d785cea6450b2ebb62734432183079cfe8fe7ed27063c0078f68e57c7dae53f061bee39a6d80140f4a0517ae4bac4a98abb1f36fc7584b23647625d71751e09a82074ec279da56c293eb2fa31fd5af944fdf238c7f09a24f92ebe717b5615f7a381773d3db4542dff6890457ffd2599c1cb6ea0ddd0269924cf6934493ef8acd9d347c3696d269162f09c5a2c787d6fdaa37a4019422e92a58cfa45ceca23ec33f20d32430fe60a87e2f02536181e6ae09ec24f9148664d31f6b2c82ae35f578e9e38f6c8081fb013c76015981d8ae5009e2caf6f3d6f8ac1426594a229e3a574fdba4c1fdafd17a5c5a1ca0a9ca91d0a351365eac6d6509947ef7f6df639c31d90d8aa59b2aeb299be2b106fe06d3cc2568075746e63532857267099660ba3c70c7eefadc742b140016a58e3a7ef499439067fc41316df1bdaa0918fe24eb45a7760f4e841cb97213a5f6fd26580bc263ee218464cdc4c72483ede0d96a629ccaab8ee411786aad8ab9e828d8e5fb0991748694634cbb9b334f39af6c90a14e5edf3f72e2b2a7bcf1f892c405f51d96c409c0d3ad5c450fa1c61b6ef1186e220b925612fbf6818a00cc02f8b7fed75fbf410d4270cd4ace221e003a4945ea75fe907b566933f99cbb9ae1593de312fbb915cb58d7b679073f617530584b76301620f1d95291344dc5e3d1c8ce9637b2b88094c22be78cebbbee5e1d6361de9f99af18e00b905a3bff79ee60205e4519b685318e0298fe2b7ab0c59e76e6290d0af3cd809230504cb94b83e4e355233ed3f067a1ee3d3b9f01a0818cad0e9447a93758b2e6ba1e5d368993350afecfde4872741345fe9b12df1989815945c64641fdb6087dafe58ce07dc8ac316c4045656507e43c1a31063744471ce993a396bfd44f9e8117680bc80881b3725ff17e967409c33bc0eb79bc98286cb0d0ebd49ce510aa6f1ecc1aefe3f0354aeaaf8c7183d3f908525ad2500e92b77cdad21dfe17ae742879a420f8915b64c0fcabc60d4c0dfb60db5a194791cc00f0c74adb3c992bf535cb53e3ddfdb54d1ecb045eda447244c1eb00d9a94d9e47d74123c893d83b122899ad8b7cbf295c3c9e2f22f41be9dc9e6d4916ecaa720b196130296b267c0703c671859e9f5f748af3a99938458ee1869ff926829a6c5f6bf4600ab0880bb45974f5ff641084473ed4a25cbf2a65054a80b9a20534074007e028eee334a00b5b2e1de06f98deedab86e01b0abadfd6c3460f62d0a95966121e6ee0c875faa225341da418fa9b35b173db610f64e292b9280d5c0c4c074b23066493f00e418c0786025b3f1daff8eab6d6ca03cbcafe6ae7ff6e369432c3870ed3418c695e183df8a5322fdaac9f17182a5a7e0725ce74b153e614124bdc09c3d302348047d217641b2708dc68f3342cb5697cdd9891559e60b84cafc43cf96baae18e9fa18d5612094c66de1f6ac5a570de0877e468b85249e025ea4c5602d1ecfc418f053da55c17662ee9dadb7c7cedf8c393e75edad446e846030ede3de3db985108047eb5cc8a05da9c934a024439334b40f2a095b393e8f0f61d79e86a03b7f95bdc2ba59fccfff2515fb5a880773a588f0caab42a5da1e6a68eeecc6ad62574980ae9273bf6cba20b85b504561aae6e4d7c8455bc882eae1d6c484493411b7d3056e0a4e66be4e171b6815d2873438920bf78ae9809e9f232346c0a6ea8697128974604bee2693e9440450f57650c7ab5e143369c45d7e36cb3618fd86fa931ea26b0204c526f5e573a15b0ed829dd4e86c8f84ff0ae81b63c94b9985151a66f45bb380859471120f39c7640b5e2153c1baf0c1d1250a3d0b9337d13f878463f229ccaba206be24a1004e2a7065c37d00c058db782f112ac37626acaf49a734bed22dd46ef50bf9c362316bee76a3f153e73644a4fd5ee946ea1f17729cce88463e132fb212913ab9632061dad6c5d95d1fb107b990966d6beaa637b2014e6d1a2eaaf8f006683c25d4230d46a6e76e8f22cc2529a29e4d29abb88aea9bb542c42c1c070983e1cab10f6a637745e183e5401b19f52ff0a8ccc167bbee9e57346f1e3942027f1f73e4ee2630ced7b0ad2ed48c1e3497b76ce2c0af46a835a16ec959b01a5d5629c53f7c8a6b2b21843f959323d2d073d57da1d73e8d06ba40fe60b6cc81c33d9f27ef036165ea79cb64702666700a0ee29aa7547315ffb40242b4d32451dc2380f375c8953dafad103009c275c2bb342870576446b8a46b493074f9158f90365d582a608f8de76f35d0672696548fcb9e8247e491d445f3af070f055bebd14c8ff475b4b074eadcc5e99415671345845e282931a8dce8727e3cb74f3a6280f056bdf2e9a1ede48e8f7e6b06e5e5cb6f21f40ef186911424b0cb3cda43cc4eae1bc8b15cc8fb7ac3a847b884cca22c4718235e0b73232f26501d4b4935bf46d621ba838c328838b9117aa9edeac0d74cca8e2b0efbe1218da9dd4f41c10a008aeed09e8c7e85b740ede42641f4148dd442a649bc3438f0546dfc8d67912f24b2bf2518c433484e8b247e8d32bf808121fad34da8e86e39fedcd2604a77396bd1849971acea0fe877058c4fe1e07e2e091d3b0ea7c1e2044b6b358de8fb0b6da55a9f79414c07d14dd5639dca8c9e63e1ab2f5b063e429a09e85b6b83b3d4f2dae0f1e5fdfad54b74ffa4fd0979e1248ffa168c1580b1e59708fbd2ab91e24abecb0a577f0f973bc1fdb71d63e368c00b6720125c85ae1e96c7f85740c45947102d8a5c69504782db7510adddef00c04d2e9d57225c1cb6930e6e8bd947762a7c66fea6f8393c33ca31908f3b614ebc9a7b8a01fb309e0e5c1a0f23ad7329fe646f0e4d2687d6b0e5af1201ffebb0e58aa333c13e69b0988b5c39287f7e5d52f016caba978667556603cf8b2603a2e1e41c0ef2dc485db83fb2cf8b5c29467415a454d3dba5fa0517865aa215021656698c7d98582d32fc53475d4a948175a74173276476ac8bf905bd92c76246eae0bbf9814adb24c1629efbe9b1d67b42ea37a4913363681c810bc1d270c565d8d27b8da4afc5ceac2338a6c43bb31de0543740f78ab22cd9b933f1350fb2212847621446cc9a99c0c554ee9ac8316ca17f82d237b1ebf17107e01ace097c8c3556bb03096965b46ea3a63305f38b0ed4afb8ea39949679e94c552246adf5f4502d28c2a615560381f847c2eabebb643221ae77d16e703532c730792b5b4cce5340282397022a85764ebf622b2e2abe4fe0dbf9b3e14844d63e851881eb31ea2473add5a957a2a207a08534a8010b4aa8db760a31c09f3cfc09958dd24e54c6338e210c99baa9136de5d5bd9f476354f07eff970b035ce6f9dea39a4948b8c8eee0633ed58c35e3b7a2bedff8a4e7bc25fc5307819be5db5e073b42fd6cd5d6af39af50a73b0f5cfc774de29f86f865f3340802ca067e978463beb60052f5081ca5dd536ae0edeacf0145ce2a9e57eec9af34a6d74e31c4a67e68cca60d16527958d01cb32cddeb64a10b3d92394516bb7fffba3ca76bea5603a8668532f2062b60ee2a6e854982ab2a91f259ecbd0eba2f81c6b2d3d95c35ed26a344062fadb7680248c753aa4c6e5efba7325d4b3ec938ce01530c2d8bfee4d1ec460f34db4b13af0e99bc9562db30affa3b123dccaebf560095ea82c47bd5efce16ae792ac1fa6be2bf4f3664ffac8d614f3105095a28bee3f1f6f49ddf9bd67624a36bc3ab4dee2b878d46fcd1f73bf465910f0c72fe90102ebbeafa8d90b8750f5767924ff3320e633b1aa1296b703a08ef7b3723a593b0ee565593c1fcc23bb59f9bdfd7648e9ecc7233a79133211c71573fa89203499afad969c2cfaef583e36f36abcd8bcf298acecff84837baf7fa45743300955e2521bd2909069cf5518c1c2a798dce1ceb50537e5f1aae8f86b32a2c5d14a00b5dc2dc66a8da1078af222f778c31ba63063e7d36a04ca320d51711c23f7c1c2e24708519e9d4d8f33d0531ba3f4b406ffc4693d5a868236751f9b720a55c298530fb161f742ed5f7c860782652ac1b1459b36ea06ce5592900211f47446b354e440f1bf6e768e5ee65de8365f63c9fa661f00988997932936ed825965048a7bdc7d2d4d62bee96156b1936e0a4cf4f048b4489772ab51f2f2799d030c5f8317d519136d017bf1bf26dbfbf850be9a7af404f3f566ccc6e6f29491bf4c76b7fc85a44e77d1faed92dc9a70a9ce475532706789f26e72578b0938b956581b8afafc6d7ca879e81e2b6821e3acd88446c97deef9baf2530bcd1d1a75e5b7cf0c726774131d323676e2bc0cff5c7f63de8d4f5757c25de612857cf8d4f66793902f7f5bf582e5b8c801fee7bb196705d69c4eaed50daa208d9f335f3ee5df9806e593d267d3969a9c0c0fbf6ee780a594e6a0529c5793187bf124db9007dac55c75c66ae9cf8a7992be9925c7e208d6bd42b67f69e1845a89dd650e9b75530430ae57a40f3e188b9eec3531f3ee2dcf206139338cb0ad7b39e56333405904adc972f5d26dc810a3b6e9f329273e035019783c31fe4d00ffe5b26487e26f31c1091cfa61805d08b59df3b7a07276292eaafd4b296e69c5a531f795f976f25c49b0aee6838399a2be5963123d6d47ecf3ef87aca9ea229d8fd0277bb30a8a198db075152e70bb5296710ac90e3c056730cf72afc3083498a86a0b288389049e692193dd33e1a8afc13f3ff0ad32f41fc132249821d0abbe0f83086ff53978f53ae573e0954159126da5933717171e5f412bb986f71a9051839f97c0faaf463f8b92c4e07f36f274800f95a0779c16b413a2538f4cfbb3966c0e07491c780917d059b5a39d2fe8d6cd5542bd47e2d7edbc2687dafd92bc516f53d61c4c54bcf6b55eb9338306825eae7d8e68fe0ae715bb828c72bfd135b069d57737ca4f885da1e3f9ef0261450a4812f80e78b006fc5c35d64ee0180d607b8b295b129e1f559ca131dd6891a9108342320351f27d27016d1bb844651bb9975137cd579d16457c36400f8832634d6fccdbaa578167a9b1955194949a11dfdf245668c2ec63c8c19583891d6ea0681a9ea403468521317e198079752fe8ffcb91edff1f5bc5541c116e5b57ba8e72439aee9737f023b14c650ca00feda82bdf7baa03073aad99403951323321ca64cbc30fdd059d04c2f1018b7439fd878d35bf79fc91ca6b768af4fb5f74b401b1d04cf809cf1651fc0bb69f71d493c03d4d87839bc6e2507cc081a51eae25d7449e624559e4c98b3d429ccc76da9e4bd2c60f87e0542651fea1e09442bedddb6264f3137e7a1bb9bcd5629528e18866840c68a2f46feec61d9e0a41ea8347fbc31274641a9c7f1b8a44ee9a12872307a9a48e0e31b46df334d2f931fe91564d1d81e23b526a4fb1e2df4332d3b84371822769eba165d4d26ce6344eb590a2a6b5863148448259c44a98ff851c638288c07b196ac9593347990ff5b6efa6c0b285c2a41def755bb3eaa9aad7ce47bb557f40630254255731cd559104e768a7109a319a8ac1a3e59aa1404006f45acc0200c672f9b32b3766d89a8bbfca74d9b2d9ea182f1180ed02d9d6957b0c73cb226a34286c4eb6ac4709d902c39605ae5b3c1159cbc607158003d24570bf58ae66b981796204e20052a0e5b87ffa999a2dec287501a9d7477d1bba1f818603c0915385a20afb80604156dfd19e2867a5c091b434297adf6d2defdfc96dd4d4f64f0f62d0cc9a5bf0c0ddf9ddf4d3f94456eb30c5298cbe32d5e6ec418530e9ca40a06b345291b1814dc1afa735cd4b9d76186b16398dc6aa6bfdcebd65c28a348431346292078bc40f9134d542a83f5209051ab895ff9f681790f1d22ebae5cbd2cfd754233af9aa6d8956f2766038f220e034aeda954d862f52fd3654c73e0a4caad54373c10f0d414e855ad317daea9405a837a886d6030ee2602465c384628aba056fa9a9d2e2933891f432a537623046fcf30bcb245d7b04480f2d5a888ca89d1c165867ce50ba174f4694371c0cc1aeed1db89a98b5c57f011c2fa3ba4612affdb7b4e21f6521704b4052a96cb5e19c68ecb53cac304b7ca0312e25d65ea48ddf9b1175de2fc0fa32c6bb099056d2e013e720ec25cad3e2a9e9bc0e345c1d3244709da792ddadc7b2204f8a08dc00c5595a6f4b82d23b6d23fddcf1be98476b5022d8a349dfc5c3e8f20681696d8a2070cb9c57028785203230d9927407a680dc881f23187c3b24460964ba80b0690870a0d421d45a6f44d5ece27d6f26826222684db8f95fbdd23ccbf6ca559459d6d3beb6cd927c1a7b245031289d97df04c10436ec59a3646672bfe5fb1529d11289be3b65fa17faaa9c643353b40c34de0c9d4d689a9839962ebcff5487f8f8ae30291dcb2f9e9cc33aaacc7d8b7f62d9807426205589ff501a7452b05816820ddf5aab493fb04ba60d8aec296ab0d9651d3c935a6666489920269a8e46f551bc3af69594ac1064b951315731ff4cff8423f13a1a726dac697bcd16f011a8f38e42d0c659c568a6c31e98b4f040bfff0ba7354a67aa1dabdf2878d47352dd068e8d45a59402757a417788ccacbeca4488cb7c84bab5b43c96fc515f2d5a9d32f8b0763f0dc631a14cfc0aa7d04bfde5bf25c0aaad54111d483ad140fe14947b8945912023fe10d642077da5069206072e471867d55a9b98cdab051baeb377c4c4fc5cd2f798fc3e78f73c3344f64422680f765c5b5f67b3d3182890708bb81dd2808c4a424b3e71674d8c47e5c784413ebba9e6d85eafe332df0101aeba3fc5ef46d79f8b731961878cfc12d451d4431bd42e2392cfc2d153299964f25d5859e1361ba55d4e286a53eff075b6fa37febe8afff2334dc7cb98b9d2a1f26e14808183f31dd65667326e4fd27ca2536c43fdfbbe90ac86e49a515eac82078146ac4c2003f899c30725b5298478c866259fbfaa7aea19f2f9f2806a1c550c09c47b0cf7e7177347a0011f01ea679e1528a042e0fc0d1eb84f1cf5a1aa46bc95dfb75dabe6f9e71962fa884a0f660c1e701ce00063aa8fef5606995a8b4abce1f33aaaaa18699d75999e0da67beb5f6d1e57b1aa2d94eb2a5d3151a40d4c8806f793508335fca3b3506ad7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
