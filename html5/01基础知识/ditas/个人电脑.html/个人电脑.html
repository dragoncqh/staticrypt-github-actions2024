<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d84f84a06c46358ab730c3d75b42c328a2d43cfced8da11ee7da1bfc7e6e3395021e652fb5cf578a25c86ab610cc63172aac06adcb7d71ef61be116f78a5a203f77465b04cf525beda7131f9b12e60c2fdd9e26d2362f3d711f47c18911bdba1dbd5e53648898e559cb51f700eac80c20f43e0c69849483d35093e1615454bb5616b395a92642af473feef36f0df41298af1f49f89bb57c345497f5e2075a494416ed33ebd9b8c9474c8d795fc8cf4ccbcdb9151757da6f3b7feadf710242dc7dc146d22ba3c2b84f01dea30664ba99c000f659d86f0a47dc8d98ab6db0e05f43c12741fca4cbe58b48cd0d026157b41a90ed5326f96189be53e68dae450ad66aa91b324a41564e179da6a84647454e59af20c2cf987def1542297c6203b3bb81c14480b0a55ca0bd64a3e2bf17e3870643e95c2d67f1d27e59502a7e6c733743bc07ac70454879c819376271d61e3788bdad85890bdf1d3b14b329ac4cc2b5e6d36a9371de6ba89a2402da863ad78b59131bcb18b702c7e1e861504205e625665388dea535355a706341387adba812ea06b0e393432f5227c9dbe742d2b86e672b35e68b9749521aac432d0534ad671fb19246e5ee818c358d99a8259138fa2bc6121cf9af01a3e4f6dcbb0de910eef2861d4fc1bdbe7bc1cf8c848f5b256f9a32ae9677b8f6a62c004c742b9097f6e24fe27bc0cd118cc22d30928571d95ef38665effa24591677f80d9706532f879adcd5dc5fcf09f646f33581771b7024728af1496d10fd1107a6e479f719f29a2df2db9222bfc2168b5a808ad6a68d836a096c38de60777bd2f537d22406560455b7ed6072315651350547573be93053e0e23b699030cc659fdccf5bf4422748c9b74a07691d248911ead133955cb95096f38100969a792394ceb1beb5f54508930c6020e3bd061b6c4d0bbe98d9a198134ac5f69ce9c3ba24c0e96aa92e44999d0580df8dfcda5511cd1eaa5602a83783ed77b752a858ea3b4c9c01e323b8535502652f42c66f7791bd6fc08402a761c90846b586600502a0d1014534848ae085c1f455f899b4ca6900d37f0483c6e4b7c7d0f0645f5f9c53c639db14fa55355f884b0c0e4e56df6edc5f6a0a691626ed5deebd3b27c13eecdcce513fb86cf3f518d0ef7ad59781aa04ebb39b9a3550f47e48cf26f0468abec4deb133b44c62317d686c16f505097de7c07d20e8d9ba2cf8a90042af86d55376043b7483191f1d54fcdc3c7ac23dbdbbbee4f539de86d3c35cd633a205e751aa5db0d957fa461c8525758280ed9cd9bfd4499c6baf7f40d8e76fed0197142372d942d1b832d5d43a03423baafcae09dde97183298b3c009e87b900ffb24aa9b23369a631052d974fd409978e7b99de5646ee5004e763835c224de2ba4ea9ae4dc96d4a204b53e73182ffe8c63c2e47a76d6ba63a89ee7961e1b1a0d76917bfde823c073964e91aa8ae0f95aa95058ef944767cf2180af9e76ae06c6d6ecef5c3c6176052bd9ac7e89e9d31de2930182cb2a7d7b17c2220b1a2d427443560f83c98c9e2b5b3b66fedcc2003db64c554f3db6eb3bc7612392ab2bb6029434a52c738059b5d6674b098d4fdcfd3ce0ac6bceeed00eb613fa91b07984154d557fa0bd800baec63c2b279a31ff0b2ce98445cad17361ad3ecf0f4cedd872a37deed5216c340a92739725b75a1167493c58301c3b89d5296acd4f5168d24f54a4cccc05fae852e112fe1d9594828b1168590745d1ddf599cfd194597cacc5d86ede6d06a9234cdf413f75346fbcbd17220637c49abf4a5fed297d9eb3e5d983adf71cedcce2130968030f8a5e38a90de16d66b0adc0a6d8341897a8bd0c54a68f097c6a4a7efc6320aa10536729a7dc6ddbbecfb5f880a5db2b54468f58773ff2b13ef9938038b93b67dd2a9bc0b760c47f6a9003670558a0f5859b2982cb87f57a55ecdf69410048cbc99293b9ee5c577d8f6975298099b1eb77521303fdce9691f4e93af88fffd29fe4eb357ddc72350c160e0e10031682589face054ba98ff2a222f793cc0c95d0bd77a1b71c030ba6025247d5702400b5f811179eebe28692694c6737f0389a35861f5827f55ce0a437620e60dd391c98e430a4f5463ae7f479cc08f3624d47e0289210b81523a0568fabbd8c7b137752509bc5f3aa74733cecc3bdb7fa5d6896f41bffbe205a8cb6a89b21d834bdb6e82bb72fcf99fefa8057ae83524dd81755398fb9cf742a9263d133e3c3fa2f238b5e47543e7e17224ca6bb8df925247df21afaac0993732334dba5cf404f6797e6a18be0de7675ac0767de40ac8e91626195d891c8d92a4de61cbea26bedc4fc2615cbc2a840b57eeaeb11e7a0f34fe3b99f4eb11b541ac03f0b704ebc1bbcba3fde961b9d48bc3ad3b8b09531f05c343c30da18caf1c14d175bc13d629ec67e1aee3f4a35c926409b4c54580c349460731fc83a2fdeedf483d9a4f267e2800d526608edc1c4fcd8aae93e35ce1d77fb3b189bf0339caae95a25f43ec48f4df6d6d44ce4ce21454540eb6b8451feb881dad245bc756b4ca0dc3905e204e53ba62efacb343d3af1f681bea69d289587ab4c3d18d3563e48081ac1f7a00ca0acb0c9217376bd031c51fdf549e2032cb77f624cf340556b45bbc8bbef6a2cb0670dcf6393b2966a0e5d95d2ecb08982709fe06a79e6a1d64189e1438e5dc252f8249d2b7481724a756a130864dcd47b0738e6ce359c446085ab3524d5ac658ad8e5eb29e7c610c6500f7d4c50e8a08287aa6181536ca8e47b863a0b42106e21674cfa36570060190791cc6f13ea8d2a4ce8cd2b0ef66daef065133b929e7f888ce396bf62272b573c8aa4ee3342ed01f5acf594af8fe2a2fd0465acd5350942583e014700fbcc25b108851bd60de5b6bdf83cab54369147795dc71379ec9cba65a22e800f20477919fa0d8d4f93fe11de0cc125bc525dd05b266724fe5af428ff089c1be07548f0c4cb0cfaaf771177075df4b90d25dfeb91c75f14b778d4695796d86d4cf611c2dca901939528384370819371089c09da167a69a4e265c3b1349f0e1c9d2779ec7ba83162610e3aca3febca978ec4234cc74cd7ecf44caf6dd719b6abe544234af76e29a6611cab2fc918737f3244d01ce955d5359ad603ed5b3ceb7a4a8fcace526ff3303fd9688eafc83f7d2006ca830c954bb69455aad14ac99e092ccac3e6d4f5488a58dc0c8e748877a5dd0d8cf4fa2d46a064601c9255bdc66f9a1b1934c682d1999e5f20c9d7839602a0c7ab5bd215d55651c986833c5dcf8216ed746436aca29cc82d8132d75fbfe48a440e45c5ef60968942d3a5ee001edab6b7f722a2d77df4e181bac36126612976edcfc5b309a5e6a3739813746e6c1c3c63e50fecc0e8cae3806cec3ccedcb9259b2493bca5a3574fed5c61d4b863824b597bf473e298d27e71df7194b852a6a930778129e24b0f58b0f624d69fe1167ed5e6f01e6efc0db2ad8d590a0f2bf4c3a44a64b724ec3080815431cc349b81330e8af4a36ca494858892ff8c7e661d729469d620ef2c12ecf058175f8bcf873af690a1efc785ace20668426ab2852003f7f7b93360d231e6e8b4c17bd821cd16a63ddb89860c338c8dcac09464e9e2a9af2cc838980ae8615e7c3f9d8078f75d2e04eb4435412ed1da55586917436007b6e1bdcf7761a2275754feff53951d63677f9ffd660a1d587f0b5a309a783f425889cc87723c43b16acb23e79afcb52cd35f69663bfb8798c76ad15af321f569081dc16ad1926bce7c14779fbef8b9df7348cab64f599cd1b349c4a2b3c7062a1d2bcdd09472f7c31f54444a9bd92fe19a125950fe6bb73e7b92aba1b14c9dffe132b8d60ee2a04e940b5e550a52f6da802ef37d724cfd1643035cccf25a98ccccc41be0074fbc1bf015f5cce59b9665534cccb1e4817fad4032f29cc0c78794b42dfb276046ceffd4c986c48f5e497637b216a208ff67be38755311993c7f6187db3c5bdc231b46f19391cad528f7110e6bbe75a652e7822a4e0a0f384e6bd47fcf8ab8fa4f7d64ce372778ec26d12b4a8577493b304843694fff7b29fefe818b93f56e627ccd557a57c078b4f991765607ad9b89bb0ef2ff99ed5ed417c293bf0f0a6c5365858709167b1cf6763e6b5be2f16358b964775ae2ddcf5fc2218be9c5dac927ad59c85c39d718c34585755bfc880bb8c27570a8db4a8aa830613a060cf973702c002719a11c1c5442eda0aaa7b24c6c31ade13d0141a0a941289f4a7756a3e39882b04363076ba5c79222efe56f8a189d64166b8e79c6cf82b9068589b161e86e741c5f5383ca6e6910f00ca8ed194512af7a3d43aab8d237a46f2cd7652a91e0ed3357618a55c8249060ddd5b310ee1d2d8b57998c96961ae6767c5bf91966417718302bf70643c807570bed6486ae8dc6a51b76c1f58d29a5b6969316a30843608ad53d5250e624f81762cb0f2243b1355bfbc8d99154d2d6d108a186564c2a35b557113b9098403a7b77aa9d1d3d59c631ff9814eb07581f599775adee0033d37a233a5b0df1d49069ad8441187d732cfadcf9b328467e7859875bb3350dfe01dc895a9ab0ecf597803ed89254eef2dbf21ea2d37fc96db69d00942a0d4afc2b37cd438e32bff5666b34bc3fb3c367d9803e2d49c0a044c4a634528f8e55c94d298e18f0791ef0be0dcebc0bb5466985c8045c80452776c83c371a206020cc98ee18ee0b359cd2c707603cac93786fa16138499955f86b2c7d0e8b4b42e15e8b9fae3cb1b2e7d6ea4bbd721589bb6dc365cf72179c6ae6be4358840b3f910ab74ec290758cdd6e6c8917bd735c3eb0b20aea063f63bf09fd3344749c174c21073d315efd57e695a8168868fa2e6e1a2db837d65a131d3fbd515b4ee83c1c108c758f84ab4144c0aa75a99e30be31fa5b44b03baed51c6c4c6595ffdddedffe5a1073b7b0d13011a32669e7991d9945786132d2ce88af5db46058edf98f52c543d433219011e73f3cefd8bab0c45ed13663ede3697430d692597a1c28e91d49b3085c6d64f0a3a1cd246fee1a2543c770c84de2957a0a469460054a19f30f1415a39b6e661f7acd10fe89f5cd66a52f75e23359a42c6ff25b0169fc3b7d4e75eb25d797b30a951ef7e5d29c4923e40cab84a0cf93e9a8b61f838f42495b87c2a9fcf264447c465ac7b669511c85c370500f7805ba393de6ccda38d69932fa9746b362843f2ec4c80271802a94127f17f2d32d38ccab62ef6a1a375e3ab032289248cdea31863de1dd974ed92b87be6d4bf2db2fb51ee719a2c8673e7a571c1a3de153d144b1420368eed6c651e57b27a037e7b9dd599d126d3a107c16606ccd6813bfc75f601dc249c3062c48ede226a7d0bc7bc2248d82f5bf713f69be50b21da9278e63e3ab3ab9edea231803a36a11ccf756b0f95ee30df9deba902bda6da73dd7c92da09cb58c7f5473856f7df201495b56cca97f4994ceccdabcd94bc4a42f63d7bd775a147a6790660d93f71b08165f35acc18e8d6d3cd8bbe2f5ee12a73cfc7cab484fa0385cfb9034edff611e70a95166f42b9f2551f52632e47992fec54c9a3713576f94ff49e621fdf440d32797881fe339d6fd9c2f235f9406adf94f81ee7c38a083db1a4ca61fada6a0bc321fb71cfede6ad1c56a5b138c6045d8588064ce99c25ea76e1aabac120bf08c548a14418da463dab22a1cbb9a03706e5ab241be87dd07fb29c11d5dfacefbc17d94731c9e4663cd149db2fccda035f9381c1043bba2aa26fa2af65282353bd35605f4f1144602ade84d39256c754bc6f55cab8db2988bff974b5915cfcc67464987b3f94d3486491590f9eab3242bf1f552b050079fbad0beafff771bbc5ce9139534c28f3e2429b7d663dc4d41e266cc5186e6f9aef88c096abf061c5572645dc440c04d5fd2f41cc7d05bbc9b6e7acee69b160382cded5310196ef0858ed5355613c3143ced627d29b36400e1fe88d2d0f83fbb185e79e3ee4811f3941b9426e022225636117538f817ae1214e29fea139552a31df530781497b3ae8d7245d92737e3432662697793145d76eefdaa68305360fd819a305e806ebb78203b9868db9fd184df1e139d8ca3191a59a1aadcef2c861b4cd99ec7b5b6b40b8a14d479312ab0edab52136af8384730278d61cdc707bd26371cfb17ac193e46cf681fad352e9a927a43ec8586794744157b98290f661b3477ef5178bd1ade0cdda668ded2fe1dca14cc2c2df7a49b19b1f31d8c22ee4f670ad39a23a98a50ce95a1291e1baccfa78083a2e3b1ca5b2f09bdbbb37f8fee0e2d98601823e4632d153cb4ce8efb463bd787bb9327791389bbb323ecf3864e5eb4a686ffa4562f384e6a9b8af3d5c6231f597d2c47af6e395622a96602bd38ee346516651b581a6e08ab7e9c2a88f369b0c407a6ec427f8d64e9060bc49f7835c4630ee0b86e4aabdc09778fcd0378878892841bd3bec5211a09815be2a847e81376164dc4b5f6bb9dcb97cb109abd9bb27bc739e788723c5d0057336792827ed76023e523381067e587f92217d4c92d72b9b7c746ab8cadb9a89dee8e2dfb57939e6f15a6e49c243fdaee175e35795593eefdeea9a9767c4745ce8d5ca10d556fd8239895d8c567f5ebf2aeabc6e8a7598a16e72c1ac1d6e9e88f1a13297ba8d72eaa6d94a3ac4f33a13d90618569261db6d2b27593c7f6abdf0af4bffed014aa8283342bf35ee2a8c479712f5d44d447acd3cad2b9ab20d6ff489c67360ba01f8acffd4ca95b71668146a747f71ffcf86d06287d5d8376fc2054099f757a145f3c6dab5e18b0e8942d14767f93b0343a0aca5299a02ab68389b4154e77dcbb769faa71539f15a30257a8ae8cfc39cf601881f0445603ec057390b4a6455ea22b0aef1e5dd12fca381eb00cadede7df4ab2f804d70d3372425fdc1ab8a47061fae20c25066d038ea46d6ba4ec1b652b2d090c2e5003a3d1c01d04efc43397839738d1ebb44dee1ceadd85ed672734b795fddbb36388621b946bff972dae87b8460011ca1e38332da4e6b5c6dcd8deb8aadde73896f93d73c8454c1ad55c7545f425a435d2724788c80c58ef46ebc4caa3a4a5e21cb72c23bf2ad271576436cf07db7a4ffe00f19996d5b412a95292037c1f74b5bcfcf96e497895140548b3df5f3387848b762d6b0adc028536ae66f6e199764ec5c4283e44f48d975118b79beb51b457549481ab515a5e941818feae2e150769fccf27ed26e93dc54ede607ac0629d7537273d298bb167e81547442dfacdc9a24b5d42936ad386be36e9460841d4087a1729f0d4a95d5a8c13d067f42187452ba446f44ee5e21fdd4de8f26ee7dbf2a7bec1d911d1febd2cc6710945c899bc292fb8bf4ea6ac69b43de211924085ca4bcddf37aee97b24f8b071cd1db9da6196c6f42740cfb52bfc025e2e8d301570b8de149bb4416027131381218942b539d2c3ad9a362ea8f74794bfc190519a4146af12441afc93983b0e73717a7d07575b1426f76c6a894edc8b0a4ff321499f222df533a1aa635783168af74bc8e8bc9d4cb878bf6b4b8890acddb9ba76893f00cda7a620158e010137cb1d35a9c8f206f18897aa3420860e6e699963923e9fb35546b89bd13a0dbc14d8fcfa4e214d12943c1c71ca2a1a8d9b6f9b76a64ec15983e47a817ee9df3dbec1aacb8f2619974f6f783923db90958b25cc9310637c2692fed69b3b9d5f0570f1a881432cabc05068f9b68052689844abbf46b86260a64f057180764e7272eb7af93895063c322b0e7e0183f9f0565faf28c5c38abe2499dae515c145092501903ba552a91cc0d977ea15e01a294508ddc0904f6091f5e994e452f36dbf0e3358908257775fbf84347426f3022adf1c1eb14c4b0adfb4b5991e48d013cc19d3b68ae9c96e2d53dfb943a10ed3eea2a6a33c5bee320dfce591eb5bb52e5df3c57361ee5fdcedb78e9133c816557938d12202da9cbe4b3b876929c22a89528e668ee3ad0f9b7f10932753f71861b2dfdb7ae57c9926ff3b8842f0ca6393c10e925b4aef7435797cfda1763fdc70f207d14a20071ee066e038a32a5da7e9638168c174005b1d2a3fa68a24a0d8c271f6e525422e662484bb3f6afce530b87db06fc33961e51c119ff0333f37da49c57e39bb4cc04aa303bd0c9de173b5d76062a1992e46db7f995e2811fe4897a6cf72bc92f41a358c103d4db7cbf420a30945762b0c3c93b803f1740922ed9f2593941395f99ca52417fba838bc061ce3aebcc62d3dbc1347c4abcab29aab0ef0366f298a8b5b7f0c0cb02d66859a5eb50bd24872b5dfee09a911df927d7219aba00ffd9ec044e799d653cc0d5846cae99a47df154616665c478cf25722816e9a1a49a4f83f3404e97a47dcf707067987e1d535b726decee82ebaf87ebe76ceb4f3787702cb907caacc5c601385511202ebe20ca75fd7ad397dc0c11c938f438a9b92f20c6449099c542fa367de775ec99ef43139bdabfcc1eefaa3ef5d1a37b779070b0d28ed909ac98e1208f56f824896fdd41aa37294b3145fd3d95714d8bcfaed82f4ffc90b9e2cfb71d9c8e33651c8c9e0de79ca9a8b1ada33755c2e0288fca48cac719e34a7e72d45e7562e962c240d19d1b3464ee515626ae8633b94d544173357d8ea7a71896a15470af0bce1ffeed4135bdf45e9a0c275c1cd84d8fefc1178b3fd81d86190dbbe52aabdc99ae90fbc342626b638143c3a1a42a67a403e0fa64e2d800c15584ae543f01d0708904bda6d94bb736b7f25ef4fe2ce5dbc71a7cb9498c59dfe3305d56dd32e7ada4ff7258146ffb9132554402f8a9ded36149c09f406011f06980f56269f2eafb764cda86c3bec29064671e5164ac347a5150e22d0f04fd217bddf77792f9944f1336f65e5078765d66b81917405c33fe4ff0539caa9de70609fb95b0355b59c06a1ac0095c18563fa7b4569514b592f65081b3a6c3ec57ff29104ae75782f8ab279929781eec04e6fc77df45a6bb74901d2d0ecfbf2b611fd5fcc63d1aa062f0ee6bb86f412cbc5f260d573c91d16cb5bd5383b5136f3099479700107e24ce78936eeb707706deebbe994e2c806b1baa44b073bca9497ef8e5cbea19baf218e34eb86f67f1e18e7c14bf0e4cfd254e7d6c03ee191cd6ccb122cc900fb3aa425033e67efd1f7ec1f0ae1dccf35f0590f940a22083ea85c9dfc78161f175f04acf7253984a1d4e492a676595a8a0c0bce07a701e4595bfdab5f1e51924353727f0b993468d9edd28b60736de4ca5b122da6cd432c899589f45d63ed70c8ac311359e91e06f953d573f51b83e6387806212e86e2b5ac23d3d96768f5359bcafd8fb066b9b3e7f524297115caa3e77f12e3b8d22753129da5a630f4c1d9c55d9c643f8aa858e8d85827106a12b262522c46c5377062f05bd6959f58ea652f5f9c5ec450694edd9bc257e14c7a2dd111a1bbb8d93d7e64dbe7d515652e227101e0ae50046571bdfb124e5fa747f60fa2066bae750b08396f4980c88e6703780fc7b54240da79552b8cdb0ff1183458afea2da41b172992c1e2efe8815bb7ff50072766878050801135defc992645f3770f2237a70a39861b9fbbfad1be3b3831146161596a7931cea6cdd0691112692c31c2e0dea2392ad1c67cffae0fb9acd134d93af6839aa72c5a29bb09dea845675fb45e363877626bdce20bcb81c8bf1c88d5059e5899a159b3e4dafe9e9427b5b53b8df677117bd0459ff739a1a15e4c2ca2c4d208be15ab933e3b167c497fce2e594a972e1ed57fab83bdba5c423d6b2b6e28d4cdb6ec77efdf820833efaa9f1895dece35cfdee55fed20f459384c4b036491a2bbecc4153812f3da6b17103ea4649bdf29e00339220c47a1a8cf92e1dfeee870eed0eef30c7d8807ebf7ebb6d2340981fe6d47b0825dcc610c6f2a6252dd983d9efdfa105b3a27efa27f64b1cba25953116e8d34048be2a83f693cfffe1b796885e4697e90a30a1fc33199242184e406b2e81075b8f20df25eb216d79502186673219fd911254801de80bc6fd7f0e9f4a44bc993e24692fc24a08d5dacd693e651895be7979d5e0e24e689d496117ce1ea3cd4fa393a87cb19a9094c8ef1335c0fc7cf772569ad2e3d52d6c1b5d31ee3e7e51c8b90b0970df7da0d662a19c9db70f70eb1c3d7d738b60493cc22c4a57c9369c2713f6b9f37bf8d2a4b1546a33910cbce0eebf003f4a01af0451b3e3bd4949497aaf784801f62585473f150ae7560af36adb259c38300a4eb4974d70619e3475e5c21904bf6477c72d80309e56c9ef6303da3ad43d4251e4d70f24a645825b74988d6dc198842d45ecaff3680fc3c10a79d9ca96158a451481a3b7384a680594078ac31f258cb8eb09d9afb6e9368666be4e6e592ec2c26608f00bae1721e2294f27e8790ceff3f83642d458300ed2e6d0141341c16e24e6a8778405cec2f4fa31a234d141a76bbea0a42638ac23f8b663a12e1401c7d2f262c35f49e3c26556f8c650968257cc4755c35c1ae5e8113a462dc5b449d63fc21af0bc7fb3631be01afda1ab41e6adf786d203c66a7a0e5d6dd95db71d4c19938ec98180fc974cc256762257329792a002a8eda6e56ad874a195ceadc3e93fe5bb08ff0006e39b5ec32e688eed3da01b3902e221dade9edeb4dbf75ed84eba9dbb0a2e647c4c541475ec9a8b9b4c58c6a1d5c51d1b1904912b427c730cf88bc6296b78526329cd840fce1e0c30fc6d870953e024d91740ac65b998ca8ef62eed64b56246dd0011c49df676035cfc9b0db3cf39310ef14ed3fea6c5b83c38f379c2d25e8869aba2c78d2aabd953b98a59c660925c3f4d14fddb677fbae5f13d70b874adbc65aacea618dd8e6db5fa3a143d16800e542ccba49f8f6a1823da771ef92cb832fbff3aedea1247b29497cca546340a7e6ac78cc94ac5b3a38af7ac137757dc796c1cd09482e4709fd612373cd84249e4c85b31054a0e864f280acb2164ecfe1de792763605ceff8511beae8f3409a36a8fc1ce743446b3d7efd2fbdc29e1ebd6f821283836aed3e90de322a8634ff01672a7631f8bf6b6554a43e369ca3bdac24a81ab1ea3a3fec0ed739ac94d56751d04b36104be230abf16d7aec383cba079f4e87a760eeb8d431eb7c8124b8603b3a6c3e5a0be36f944337e4b6962e769f19c901ee554824164f07fc8cfaa8817b9e2b76ff20742816fae9a0b247edd7e3c3253e13cdbb43c97fdcfc0c25798e602c7533defae909e7673a49d9659f06a5553e79bb56d9a83d5113bf63d2a926cc5e473fcff0d113f09e404293d0577017cad48bf0bbe120dc7d8c288d2e3785976276ab412d6e9d90898cfb14e8ef44c32d12b9f3adf7f5a25b5a3fa4bc11e61784d63ce3a199522274915089daa7ecc9cc69b01291ead3e4de238ddbdd3fbdd3fcf097209b0d40dd7a459c8d871c47e5b7d7f5cac43a66998c8a31ccf58022c95d86682fea4f351ac92930f62d050b1661ab8a432d3e7d8dea75fa58c4a00e6a5e2edf02a1cd14d7f257ddf747f2aed21a068b971b00f5cf3b9d0c617a7cfe211256601b96951dd4752a385ad30c22284d441b06f25d72600b653b7812bf2b23aa818a5f3793abed349cf8d2afdf43e8e726ccfe3d21621eb1088300e42d1ee5116fe7bbce42b9d72dbdab5e52fb66461d90ee2ee9d2367125c5f653650b2e5c79ad850a196f636111252898a9a4d12aedc697c245957198985a08e960a052bc747b58d8912f0508ca5407d35c8b5dc6bfaf3ecc53156c0069f2dbb56cfca5d5d5ed4a9c59588eae484cb279b7ac6bfa5c33f314d2897ae60b3f23e9d87e9eaa8fe9eb2efe28f64881edabb40cc3d6171b4ba3da3435e22af969e28574670f6879635c092602e3aca6d9acb2a016a990d61313a0672da69e6dcf03cde4004b144619488a66b4783e7ff303db0cbf0ace8acfd56c7445b4d7e61ed6482363e188d1be2cf55aefd51958ddb3b3ae60a7b03f5915383c6d7675624d493fcf9821d36a6d25ca47a71770ce075504fb56d74561b33038dd2dba9d3730459cc509ea17d971bc14d4c0a8209df6a73a09338088560b06455c6a56e1282a55d20b01c56f48a65720793f7c9869af608c96b4b19589a108d93f0478d7533dbc6a32d405ec8e2643be570610f43bb935321f131576fe8e9b6194cba0231ec4b73061845a6103227d27de617e3e5d5b84aca76bfbccddced09fc3f816cd0985250644d859b6640bdc17b4133b752065f92eb832b0f256c07cd651521f6a3ec7c5acaebab2e190e025baaf8fe058ae743cad1a3aea56f1eeb7c8867d230aa1ecf4851e5f48d88ea4c47a503916cc8aca04113afc6e214630369e1dd5db6bfaaa390392a0423322be9727d9403e467e525b17b397e683cf34e0c2646424a7d9bf0d3b32d6bad54fb0979dd1348107d5ae36a8755d04f838750a142e06ef459deb293cb01b75551ebbc65d1e320caff46ffec3827d8fdf3d3596c69fa8051ccd97a5e8d9ab530ea92a0bf64939b32f281cf87ed02eac97eaf1a431ea383350be6f5d253d8b3616c8003f435cf0feee50c4d74972177c49aff635575addc2190fa585e8991931df4dbc83b502ddb048ab9b2589b49ad30da7b66ad80e3240dd778a114f9966d4706cac7bafc194339256fa00bcbda07e3b9c79979fdba8dc290b479a332b869d51a8a4696810a8125f1984c14d0efe77dad81bfca764b99d9d10b2cb420460ff8abf6b9506b6a5ca28851e0ff05bd26bfb6d980b52d72eba09aa7d4d823968ba62edb40a694a87a2d103dc93d82d459eeff32e81e3a3c687fa178e7115a131fca372993421508a2be92e49604e550906083f7c9a76cda0f37420b2de22de345e497762ade706b3ae27fcf41ea3b3292c46691b87c9c83c8abb630ec26a4a7bff9abb1706d71ba0f96bf9e38d13b68ecb130432d1d833d8b336fd813160ee104aa9de2dc4a8afa9e8d33234f7e5231639b44809819f95e4c2197050d95464205856717b0fe3c0fbd171b2bc8c058976698088efc49b4ad31a5d2d8ecdf4db735c936e493542c6ce6f3213c82946dd5039467191de573a66a5905e6093000336a03c6330ea97867dd48d3519dc308d3a6fe2acb71a251f3792fa216772517cf7bd01fc9efe9c05057b8b9dfcc913edf965b0abfa9e917c2aa2d0f40503c3ea460b5a7221b3d3e5d688331031163b9776673624c2366a91cddfe3251edff8cc54fdaaf16e5bbc0d02c3619376d471ad3b029de395e2ab74f855d1b13a4cb16289f6e430393ca609a4cde50f5b2471fe4399849cf69dc0558c678b492a133c5ecb762b2bc626932b0725f32ccd936f1d97af579efaa8b370d4f0850894f284ad751d7b3a8df293620c54f35f2280949d61edab340c19eda41924edf0ca0c45bee20efe4f20e610fe3f69aa375d9ef903aab14967518ee735743dcd7de7fb376f7053ceeab01f7dea9a8b9d8a606d54883c3d042ef1852e737a3acaedadd82313e97cadd76219fb5dfff3fca5f78278addac75dfb41a0d3d81326cafc89ada475a964ff5ea4c695b7c4aff9d13da6415f784a9cdfdaba67f480e0822f223c3a27824c15741cf6c2a0aa9f2e3f542b60308868f2429312736157be9e6fe1eeec856e1a13683cc964271dc78ae27217bbabb0ef2a1820f0fc6b55d0eea5a61cc8509ea4c94c653052df6a7c21d4c5b02b6d53c699ca1fe773b6bf042141667503086cb406cb12d8fa223108ee7143ed8a154622afc172c0e5a935b56b65cb21436f0161e612c225797c71e44e514dd0c0b020b15a17c0e65a55dfd4768973496aa16309a6defa00a3e57cfd811c3ebb50a00539c74438724f7664a2347ffef7aff165d39e6a699eea58931405bc4e4e301a6510dfa60d2fe7db62e2ae6dfa245df79d5102cc3ce429dbc5e7e4cfd4b4cf642aaf7fc56721cf24bc8e773d18f99e71660a3c6e0e052cc19de72ac945f35f9494c22c56d6898c20a8fd5b0ef1af83014ffdb45f17edc9adde26c7c52a0d9cd66bf54c53b939a7d69279f3580083d76ca36a3ac5a7b7d3db2ccd73cba5011cb270969be67ee8849c22f18fa0a4234059748720fa1059aa23262d6cd672fa60e35c37d374d0f009f2fbe754477c3d38b7d71240073b0c24c3ef7a69aca1efaf6be07c4253d3da287f36060b9141a627346ced337ae787fd26d2fb14382033cf74346e5516f9487836bedf924193f13076c175af8027f7612af7bc7f6ed6a68892aaa0b063c11efea9b695e643689a5dba03d03706d2d6d04b3b2c34fd882625ca10ae4d5fbb597e9f8f8f202968cd18c623adf42d70710fb9241be5a26828f1f4229f25b162943b22747b1d12dbee653a20c9b8b2763b90ee7d052b0b250d91a8c7350738ee00948d2aa656a38a6230b4a10d6571eddddc59e5ea6b1f6001a188390f0b6a469bcd08baa07e31c962857dfcd5d311028a621e796d801bbac9bc7a636d0e6d6660d3bfac99a45798381ac59492c04b41f3bf18f333beec00a840cfca42f289cbe29cf24a722c9a41572d674016374e3cf5f66be4c3e1fd474102f97572933c63c5ec7a1fe8143d1a29ab39d5508738515fba78c30728e3cbffe3de7b71b669f5deb77c9a27957f40a767956ce53fdf6b5209e515802ff039fffc236bc7544be8c18795f7eb2a4adcb9d901b765fb4ec68cf6173a633d762e51ecfe25c0190d641b45ca9a705f06d0e577b80ed52cb319f6cef3e6ba2c12f97799e6e19e87c40a54a2377799be743f74445db515f4b0235b24491acc4be31a8fe25cedf8a932124aea45607eb7c18d0b0a9eb1cadd78b782cfd4ebb4f77ec73820b9c4c7d9c96ab5afbf3521f1c1c7aec52775051d9ae1f08c48ad6affceac2fef6a929a7cb9fc40a8852baf211a972cf52fb3bd21c4c08437ad9590d27ed8bd9ebdf0a14570045e0d82831a0bd3a92e7e86b237ec6dda13f1ea3134c190c0260060b750ba075a076d5d2a315fe299f8d34f9ce43d0062f62720364bae3983e180c268b2fc767dcd0a1c2c610767571e156083ef51c2ebc3a6bbe4f86bd5d60ff707be237222edfb70ba62c352b1fc15d541a1e6a29fc975dfab516a5a33bc960bb0cd290de3238b48299bddfc27642337baa7093896a76dfeac2800f1d9dcc66d37282874dc1818f1e7562b48035813a47691d6e0911c07e8ac38b52c6681277d4513bcc7159eb961c9ee53d7a79bbb5998efa03aca83edad5f7efa9dc104bf74a79f5d7b986e88af65a5e5bdce544a2f51f599fca72f465ec92bd1d4fdd0609fb0f4f9c3b96b10f77cf1ebc8e20d9b55ab2b16abacf65c84877e186b8de2970b354f65e94ff10e32f24bdc22c1a82a085d68c8b19e2b47ce6c712f034d2f7855ce99c6a840b330654e873008cc27ad4406c2f373234a0a4784b7ff41662bdc35d1a58815bc40879fc962cd3a2f5bc08d863c71ede700c0dad83b92168d0aef6d96b988c503e03f0b199c25c83913392d69ab4fb39f791d0363c759415d86dcb92a4e6caae9ac7d4314c663bbcabf60bc9e70408ac8910f4f2ba11abb087871326e61462ddedf09380238aa384848df06fdc64e7c3cd0948dcff56702a2dd0444a16867293e8367b68a8b08601d7089cd7464dab1d86b89ed487d01e3d018e2321bfffc302f0b916acda559c91a44b859f40bdb61c2e1f28a5108e67def51e5ccc21f442ae1e50e3aeadaad31515624ee1db3b44e3e0d67b546e5019c708b3bb1d865972eaec45827dd929751ce32f1fc8d1a7c8715c0d0efa6357b7d49edad3f9a6e5e2ef180eb10d08c908c7f243fde4672eeaf22702ea3c94d523ef3b99cf88673c44de738098feeedeb12e61f1a27ec01413c85bf7fc29a24b3c02b136832a942183cd1148bb4ecf5f7c2b8a656cc342a4b6ee33da2e647f0abb10d8187eb8e1d5ac2b3e7d3a36672ff632aacab57a69cc19905d3cb8f9ba96c1e78ac5ec7ecb3214dfbc7d195d1ca5a184261f48a810492920f4a477f0f624b7a2ea872b3701794142b8e88603d19c1328349ef398d30f764a462d23e82bec828100600efdb43c3e2c9b6ef172d594a9844103fedc20b35c3e4a5c51bd9737a2ca806659ae8a21f2cf444d233ffbcd4f59fc7c5363006750733ed8976788f49528227fe7f91f427c04c9223fcc47c536a82c687d2a8fe61af546b79041d5d40025ae58c41840c8a5c4805792bf7eba7455f7eefa73ffc3316a4f57fad6d3275495ef14e9945641a62fe9a1e460740bc18c5e411f8ba4c12ad8378886e28e7b35349eff4481b2ce3def356873ab9ec045734291f21b9278ac3c3f4e22883c72480985f3667349a985700789a89995997a338d811ba6861243cf15780d583cc5094974f823d70ccfb71f84b2188fe924c8a80acafd3bada3e265eb78fd95f5b7bcb9fedf09b69eb54154f97454878b957358a4b6756e1d83fa7679a61208750cfc1c196fec117b2a3e22b64cc6c5dd9adec4656e08062493143698831ceacdcbeb5ce113675a4e75a9279f4545f65c122de93d3831f5aef68d124c51f74cfe7d959524eee1d1d3d29738ae9f751fed5834ee0d4f9e152b007061a0653c59d1503bd9100228d9a55e6d50ab8d3c7897c436b73be7e2fc497478edf9997fae7916cb61f47b2f51cf67215e68ae50ef625c057c7fd8d6f5fd1b68b3eef6087ee150e20b665f662c49dfc9cb141edcfe52988633ef3f44156e54d31cfb459eb220c470c1f69602498193e274b4cccaa8ab041fde9e64931ad7fbd718bf54e2bcb233d1ada218af0fb50a6e974e2b72b3af3728fd9ff84f22a1689941575f24b12f76c4a23ab13c156c22780b86de86153748f5801aab62a0645d4bf521e9e9c2486b40e2d3fef282fb02adc3e51b2255f101311dad3f17c1f900fbfbdade6156bc7481bf33564a7aa5b82b2eb89d9baa56ff8dfb697c2207eaf5f34bfe75d8cea31e2a789ecbe4e67b087bbed22aec855553bb06ed13d39263a1f4ecfb7f9fb7bf7724dbd91c965a4a9bcdcd92eeee8c99d79cdac9a5ca8d022517f0bac62f6a33911c991bde2343e436e26f2f5228d2a311866d2f2220165817a6c91c35f74662c37bf8b3c6c9b0b6372ab66c5d1e9914828dd228f809aa762c58f3002c20b7dc862bf1f53c4d08736ca574a9c616f38aeccc2ad1a0a0081688f2072bf459caa1d3a5fb3223ae6e82b11811dc88f2e59900f53dbce826163c2e0f6d002409054c5d4e1feea0adba11d78a791e26a0bfa27f936ae146db38ab59240064e2ec8efc4f93865088f533404ab4d569b68c9ca303b351d64b33341ed1a5f0bed7200b66fe04fa39ff1d63506ed0fa710a2eee42deee1c509fe96188424e61a50b82032ee2893efb8534e4eaa76235e681367501df7c6147f3ad9184868fed75c8cddb32fd9130cb0c7ea1f8b96782ce10fce76acf703fc8279d339e30b38f916123357f15fb81f2f583b2815d470f8869fc69f0f9e7e5d8e5bbf42f5e00d0c73d35b932accbb82029363ca68c431e7f3a3b99065637b1b34dfdf11aa5fdd37d5d405db1f2e5446890c901cb3ee4456e62a021bdb447734bc8b3539986405a7d0335562b5b16ff76079e23f3bd03c1c527232b6e3de9192d9533cd757ca0fae2ee8fe21ed67b49d4bf869f76b8581373415368d58e6ccc656faff4c18125bafcc26355444197de6dfd8544c686cc46a40ffb42da4e7cb96655b9f7b1d1e8e23d98d48a37e8a402425fc3fb9f8a409cc0481f5bbe6e1d9f1033bd932d97d627e13c121d41ab0312aae9addd72343b24354f14f7d0e15c083b96a1773d40813c56c0790b3d324abee70234fdfe0ea1361a0db0ac4f3efdb03dbb5517652f617c696390ae737b42ab4472d103d186a7774de9c649b4eeec7fbad29002f8a3858decb9f76b3f02c8697960f99bda39af5bd853119d102825c1eee7f7c10ba001a64702a9f996f71f2f5981bde73eff38f9a25c171c14e850033654c9ee86ba44991f2a5ac90e627633972961c47596c53fe2173d0fdd676e2def2aac495f4e0b3301483a9ad2488d19deace555daf12e838a39114dd945a798157e07f43e9c5fd867e88c6f81f836c0346af07074d2ea5102434b5b27275c53b9bad295fe711f48564386e5e6e465d5da64cb49688a59074d31dd752e2ba0d23801c1149dbc22c465e54045e9bce2eb7f1801ef4675a416818cc77b0940ede58c08228604238aafc918b92f6106daf904461e9dda0f6dd3be86811d35e8ea6ee0e94f1f9285ce70df704620e9226e7029bad94170d0428e1c92030a477b73b3f8d90e130cc26293deee6b11d246765a85b2d9c0596c4efa7be1e470321482bfe4637bbcdbff5cb4154504464851cc1bfbf8c74b8a806d4f7112f0db220f6545dfc80067135ef913b932adba4d528f736039ab555516d65675047a431d7347906944625ab9b3153fba646757bc75a347848b7aca754152c6b28dfefd0d45bcde02cf3752e02fe41f2dc90ef859ae18963f5d0d8fa01990a9bb037cc07670ef627ccbb984220118f0748496fdcbca2ac952ba09a85992628355edf4d01ef035fa83ef22461f23955a12186694d19cd066ff472ecc3b4e403433185788a119ed225d8130078836f40f1fa5f38eb6f6dd9078966f019575de5afaf295f23fa638e2704032aebe012b21c6d91efb7f3ef65bff4c6de5913a79dc308eb832e5b8b9809bebb292ed363941a27ac42f034149198f95251c0252ebfb8deb47d4ff1f3a14958ebf2f7cb6440eb4c918b0d9b9204ee45dbfcc6a6c6792271b790478202d17824f79b7cc3f62c55936581d19633fab05264640d5c0e088e19789fe91dff4590e3b136a89acd157512c88e9f574f9b7fbcfbaf8309b421e3f7a91631367b5eb47f40ec84da58e79ebe25452c7fa6ad3549190073237938e2cca382342e82f2c15665fe69c1eb0880a4fbc769f299e9009bcba065225d077993b631a3c76dfae58f6b776930623651c676dc262f53ea12bf94b8eff3b7be92d5df0b6374af6d0210537d2e370eb7cd9efee8c03e504fca9c29213956ec6abbf00939d9dd53000391321c6c09f83b12b22c890e6b3c87e8548c8854bbecf8b9d1b9f86258786c6d638c4311d6f5591c139096afbdb0fbeb3eedcba4ccc35808f3e1921587a86cb90b18977ba08a2c009e4f18d965fd539d20409b040f4989ef76f8b99795f7011b396d934aaada91e90fcc1c90c185814d27a671c86fbc06170523e61a3ff94fd25edb6f5300263f750cdcc3b29c1793f7bd7bc6dded11f6ca294e7809151af950b693b361e31fc563ee6d395ae33771e18c40598fae45406acc9df3b455e8d8251907410baf951c9fdbe327ab49027c41d3ff519c46d652d09928f6535b5a36d64f71f9f905af0bc74e4ed36504dc46c6e969c1f2b40cba60486a313998ce348800f59ca5238e72a6d41ff7364cb604d294606ddbc85e5c6324e17e38fd4ac25346bf0cf5903a8e77c3edb7e99d4e06fc6a2aa4d6d2ca84126f80e2e8903d95e508627bc06999c692af0f3df198260bd692f72837406227ad8f5d05e61e51903e9cfc82a968ddc245feed35aae09e357e310383249030c11bf6ec108eca72eeb251f6693ce19e62fbfceb75d340ce52744f48961228560d2f9d72e32ca6eb8e6d1833fc98c0b31549dfc7ab07a5c83f2ce7f89740d0481e73cb2ca1f761b9d589eb2b5c3a25f717f584e849e36cdc2c81b5b3bffca02fd9bf6a642b71bf8453f1c126245eee0e311e5e3de3d557900d8f7175138f4abe673eb4d8c399107854999858df9189656f1c7e0bf427e8a5c2cd3b13d39833e51f8bf6f0b7e191c8867c39737c4be25114a48e52c8b61f4c54f89d6f423ab609090d4f22a07a81be4b0b8c0aa1a5d8648346e99437a7533902c423721c8148fc75dcd7e38738380dcef5aa5c089659b8e56ff75b30e52096a6127944805bad6b1607da096f5eacf26ac3d29743582a66e8235b2c7479b63c94f73b367b552fcd7f1947459c6ff2edf783203f2b5b3eaf692f1802ceb77b27a9b5efe5dffd8a189d00c190b2ae28e47258596ae2bc21ba87d756bf55e79801671653a98eef8786e54070b8e1fdfef855fef9353def7a9735b72f4a6893c5674a5aa9f8d695c994f4be2e0f9834698570273053bc4b4d70ad32bcf713ed03f0a895458f4b5c8c2d00127567f19fe49e45176369993f9dbfaf9ab93145530015f4f4f560ee22d0f39a0d1c5111b1e1321a97a64c93dac3941ce1ae973f5d41098c381ddeb3f5434da052b8fa28599a374b217ebd5f60908f98f6f99c6eb20bfeb6356ca138dab22bed25aa8d0d2e98e86cebe4392091a29939aa63fdee9782e235bdf4de24c49f4313dd41df0cd2b421be805e57092ce68e236d54b778d51c0008cccc131107b8fb6a29cbacee8aa0f8e69c3faed08d064f4a2bfc895964f0f1aab272d76700461ceec34b3256a67ce5f7afc8944078a613b3def368c21e063ad669b98acebe2afa6610305b844aaae5b02e64514c4750abc02c89f76b404f065c85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
