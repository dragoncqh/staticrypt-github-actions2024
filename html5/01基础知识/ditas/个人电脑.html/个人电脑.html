<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbfd030fcd0a227d509b0a4e33ce610150ef1eed0c4d704de3ca2fb48a0b0da5ed3b1a65196b07f24b89b998b2373e2a6f8879491c04c7685318fae76ede5568e1ea45e99dfc0816bd545e1a785d3c4e4ed5105bb418954c50348d0183c53c059bd51328d544d9f64a0723cf5dcadf8f6e0ac664d2113360f6bf49f960506ed4e291eb5ade03060160cddf605632aea35be32d3ae7e422d9ef6b7dbc702083309cd0b62f76473145a2639b77ed74f19e020bc8b68b45560b63c8d121070f2de564d24269a70fb0d18a0d119ec5cfb9fe7467106b207e4cd06c1442fa2526b19259cdab4ed846921c7281c136b1c65547dcba716b85a4f294cc8a147618b0191e400aa460b1dcbf69775c8fbb34c3854babe6160f51dbf3dbf73cb8ea65d7439543e40844df75a0427eaa0a6ba93925540be02c11de1fabacdc4ff3151e1bde34271373c2bff50e28a2e1b801229b6c5bcb347c29421b19f909b5411c9635e73cc06a1310871dba5b3cbcdf2ccea0bbee2b3b7c1cbff7d9983a59a5d3e70b229c57f3cd5fb28ddf754275e81957123ff88ac572e5fffc0472b3562f7446fc881f0208b954e59bcfe0bfa2c54e184f7c2d9a43e57769d5bba602fb329312d7f4de4aaec1322ef7d4b2359ef7b270531f2ceda6c1bae64abfea77b1e9724b357c06cfa545ec686a8d9a35f06a495a939c59a83366d1adbe50de5184a0412275f1e2ebe2ec1a7907e0658ac3a9202314fbe28bdc7a82877c7986a5d3edbe37d9e1fd1f488964b1c03123a3cff52e08e9586de94268169c47a7a827fca9f312adee37fc76dd13f5a7f8773ec92c6874121376665d30299f19ae7c625c516c9bdf47e143a6ec1520ac1403ccceb07b0a61999fb3caea63aa36da814592c067c083d9215a1039033990a1c731b97ac0842fe55d3d3464797e7ee83f88d8d78bf571b5597af10c5481779e345ad9403b60de284d0fe2bbf23e8204e0c18897ef9a53b7742c861329e04cb536b6c7ad06e9a1233bb378ef59b8008c95dcfee775562256eece37895bd57143610503b9a1e73a085a22b79c1a4fa6868f6b3bf1b4aaeaf29997e24c7a5a9cd4343ea6b5c23627640fc90e300cd0c9e52a4eae5af620ab59dacf5bf2558399cf93d0c24da929412ba200f1d803b21307759c3346dadee883954a3401f876ebeaa12a71ac87c18d670f37806b49d59e14a32d8ea3a90342a1ba85cc1153e4b824788344ba5051d1c04545382ae9a6d89da3e764a5aa95f3616bc126ab8f964d7a1c31e2affdbadf3c74e844408a1c7d482e3e05674a1a48b0f55c20fcdec5539e867d76d40a4782b805f071b5766ff6495c12fc16e60046eab97ed3fbbf2d5ea0a38781371617234bb8659a171d66d53e221cd0c7b54e1ea58ea45815a5154b33ec4642c7c14aa2f0bc0b8ba0d5080e0fcc2296137d991f091b7c4568a5096ff13638e27c353907ead712370036e13412443275ad1465e7f1ecda37ef5719a0ac5032473c5535efd640236c59fc638973d399dab78ee69248644a801e213e2d6ba49212028926f90ee0816a2e0ae30ff8daee28f45047161ce1c82e371c85cc458977eeb2fafa2c8ac586d11245d944c9f277fc771f4e432e8121e22e66d0032b3257c14dc6e5bf513e0bef80fac84df3930f337d6ec896abf65a4f6424e1a22ac1ba139525cf4b6ff073fad2c48a429ca7951b0b27a2753d62fb357161cb49e340e6614bdff9e0649637af27bdef5d96246c696360cca364d68ac0a89c0afbfd3902b73d2fc389f7b703d0a86eed2482c18c22d7198aa24713d3841307785d61d857e861e83895efba8fb36b89738665a76dd89fa1bffd2f7e66aaf891a56cebce39bff5759045d97c8befc3fb8b5f82c3287f05c932bbcde51bbc99e7d91c28e7a9b59a2ad62c79f0855183e88bfabde89adfbf98cd1150ae4f790b7de8e977145197eac6c394b4d6a292c322fd81f7ca5951f5b42297639f15e474d7adca265fca030f9aba601e1635875dc98691052bbaf30c0d68a2ff21904a96358dddc9dcb8712a204e8faf75830898b5b69716d4a0396b88761da8ddac66d1a7e8c051c07ed3a9b4d0a99aa09eb6aca2c69032f6317a22b52e2de2bc3c2058297d83d6870b39606369a05da503b195b2bd7bb37b21de47e62c1a0465ff43a94d1c83059ab7ddaadf7d0e5bbd2ecf627edfffd66edf3ec78bd368b34278d05fec3fbae8a0ee09c6a9a56d1a62d139d62e94db410069303c941c66c613ba35cfaa0058c676a72a65383adce8ee1375c784bb2af70722a2c620cd4cfdc536d90cff52be0c00fa4445aaa13b011d87f8b542d2efe56e0feac05de92f40d5a649c0ec055872514729214a2c283c1acbdb393f5c03ad6d0fe25afc0730358c6f699e5588d82e2e0361093ba7919af54eed45d344c61ad2ef60d9b4afeb565ef9428f978c57619637b183c4201b4a62fe485396b6a07d55aa4669d0a994bafc76ea04a2f951afc08acc4c9cc877c4b06f17a01c6100a7adc09179775bd9a9887d94133e548ae9d4db95b2eb883fc814d2191e7449a86b1d1acaf5b674f068331b685a7e90f68b8a454f34086fded5a14ba63756ff778bfab713acd3082912d38b5e017240b790fe26a7960e9b289ebaae200e540874db66efa72a9b9bcd8ce9914811530bcc9acc44d68f2a40c5b20e6bcabaa18ca3356984cbb40621d3d0264b7f12f12589b677ecf8404b8fcded0cf55ca0af17fd1d39a006cd5beb6951c5c9dc7ee45d21220aab1b0751c9731bf863890977ab35d6f65a526094967d4837c1d537afafb43b26f3ca8ceae72f6d7c946d6aac6094533a464c0025f6316463632c7b7c78dc0ec7991fd0dfd950357b6b8bf1132c1c7d522c2f4cb70994ebd2ddd4c4bfc59c52c8165ae17f44b207461fe2def0145a7903bfa653c0d8c028a36d18760798bc8cc543c60ac03fb9ec55082d21a2028c1f8b06831fb0859c33268764ebfb81d0f2111bf1c292b082fe0909b3904d13534137256f6ef9a170502d30fa9254408114cbb9fb5fb3329381952f072c4a554c9b39ece8a299ae40b8e7c34b7a11237c1fc74e795089a92fc452677f1cfec4657c36189a2859dbe44f127a87a617d0248539c007c4615a2be7737a7d3dd60bc112c963b8243cb9f283453b47fa1260020c6c41e35b16fa203a3f16d3dd4b704bc49b5fb99be02d5464c9cc639c9b8868a8d927f19027a4a8cce2716ca9486f581d25702d9a7ac4fcd3683d5957f8bc7f9eef86d08b16b5958d17f572eede8a8f6926661172c803c697b11df19e032cef5a1d9c91c8fea78f0a0d5c460ba262f8aee4c7b7a2f949d09c57a74152cfc33fbb370ad07d7af783a0ba8b7cdc1a095a6e549b97cc24e42039496a6ee8de0ef6a1d7323f8dc69546efcd507934296d339fdb312c0c213e363411567205a92b58bb9b32670c22991db4a28a24be06881842d1ba15e3ec8957107361f3c68a305059597d610a6a54dc5162e9db7c36e982ee922f421ffc55bc80b3daa2f6a6657b52d73037db31ba34087a02e0571c2c77e0e6db738a41a2e16e249f9afc0cea4e2bb2bdd42c99ae497e0ac718b23180193bedba6dab8fcd270c696e480017e8048d3b398ba36896b2ccc952b102f897337065eb53d837ff80c2bf27376be91581c3431d15ded619a71fdccbaa6a3275fac7ef9f60389229ece23bf8c7563f40e7e07b504e076d5d752906bc53b0d946f323354efe27f67d9ac05386842b7d41a925aeb78efa43b5c892659dcbce8c65e9992f6e94c13903907c37032a5362dd88f55dd5307fa4bb5a69bf6cfe1c3def7888f8ed0cdd39af23b71b7f378e5e4c67022f278cde47ca2c722e117193908fbe029096f494918ce386fa4bdae84062d8fba4846a39241dc76ad513bb84d0c0d5d5ed2844a3fb1147c7aff638c2a2ff2b9e2b37ca5393e040db1b447fe684fcff9d6954bd7590a208dba24de9ed2704b9a71e9c9d4df7973a9a9f2cd424787f5ce0d89adebc9c086a2a743c75d6b2a7c6d6d0284a956bdf76d2d809fe9cbe9408117dd18ef156c2fa28136690007aa6f3d5c700f34a22383214ce4ac629b29e54b809d758787c223069683fb15b9d2d24c5e006c3045cb32129310c06576056f6f95bcee0c8425691b5e7ab89053c344c11012f5575cba3070164d3cd093499de09c4168033c42e27cd1c5d76ebda4a2ae47837a253893a993ba0c32eb415aca4970dd531366e5dffa539c102b43deb4e707d878ff433adfba4c50c34967bf0c4238adb6fbd9916faa7ec7b8c838602679ff6dd1022eadb89f1697cad73cb2281de5362d59c6147df2ba1a9e609e29d1c8bba7d72d737f7f2e900ab58b007989e9646aaacdf2607012a9350e7baa75d990b5a629caab729ddf6fce5bfb2f39c18dddea92cc0f2ef4e0c8ed59a2bbfdc024b0fdaec6f9688f76149c49c8fe472985e3329d89d0b6b9699f55197f486cc7d28afbf55772f46cca4e73d574e26cdc2ae0496652a455c8e7394eb164a3ba18411ec7a041628d4b1e556f9f4fa9b3e322725d7c15a7b3800e0460712abd87e9f1cb0bdbcb64ef07ca6f87026e576ae703d1b4bbc6f76facba7c4d0f0b23f76b14aa43f545e58e6d4584dcde6fe8285042438df79e4de43124b708cbe5ff12f4d521d1cb4bdc91381f70d5973a90d0ef830414a6ac016f6d1b2388d4af0ef22b01275848c8214c5942d14fe062035814fcae09065dc641dcd5f4f5e03246c4bbf9c2f9989272d243d57af025e8c88a84087611fc9c4c6b0588a138b423fec697aa62e7433bca3cb7bc96d7dee290c5b99634d89bf511b4baaf8daf6ba08e4e53b76e9e6d6524e8fc4776a1e0fb341e4c901c8be6575dd5df9da0a331a46ab7f8436ca8d821c379ef0c57da1004f65299dee6e3c63e146e6dd427f66b75d7e6cd7d07abf41c13725aa1d85412b0a9e86f4db49c2f0921eaa2cd91444d7b69e18d4c1a528dbfe99a609291fc7a16098174cec480c0d4e58d46d64ae90395ca139c8073199bb2ca9189f45c0175c23e6cde30d6bc5756ff7cba9c1170376becf76f268d0c58b45594ef962bb007eec6e6c5f2e71abd206f50f20a941a974bf1379797e0d0060616022da8d076ca42a58e0d0d03456a91b5b41b2cd6cddf6ec5d807f09a7e81e1281847d5bf1cddf12b7072548dcced1dacfece5d73ef96eccbf81f01af53d9371dfb32114a399976f5a92ec53b515209ef14857d22ef1d8b4ba7b9ebf5bc5335ec26d5dabf6d445ffef10ab6db0f64acc44e736236984a524d82c36f7587fe183896f8a110768d494073a81a7b2f89cf1b505a72dd0168d53eef075f4320803b33710d4a20b11890994508f0aa1a4681c1577907aa8b72d8a7803eb54315dc911d4983c0436a48d73c0a49949369d1ccdad1bdb2a3cfb6f7a4c319fd40cf8dec41f130c5ed1edc26902fc2869972d78cf0c1e6bff0a802846d5ed78b6e7fcbfe1186bd97759319e698635a395fa7df1e22f7f179ee9a3dbae535f65d9504ad10884207c45c780591052fd39482c1627203f570ba1cccf0ca130a71546fc3fb22bc20afbe4494ca9b4b6eea5e76caa860c98c335cb6660a2da8087ae59af086eb7c3e634be674ef96dfe476798ed8172d2aaff2b58fd9fb3afa42ece518fcc2e0ab1a1e8832f332d11febe8f83f77df9e01ed04e3d8a1a6450e795d434a7b4dbb4d4536dd5945a589fbf43e5836ddfd81e57d95444b336fd4968123dff738628f2b52366192122a7128ab2e59ea27493b7c171f0555dde022fe3e57aaa68d2ace9f35f974583f8f8ff545709e3eedb8a736a1a806275bb157dc82033a425eeb3c05bf0526da5dd7a8aa7ecc618549fc57394d99cd7623f4cbb57a3239f633b2c8272c1fb18b2fd904797b0b9804e8b52444d91e3181fab63094711af71d7fc122a81967fc82bb290726cd1c9d0db2037dcd05343c4ffc2b2a3f1b94153bb584941606ae2a7238b9f4102fa044c330d6801a1411bcfaee3ec9b2b1cb2eeeecfe87a2223199ae795e111ba727d21f5a4488822a90654f536f16415e28bd593f58bcf80d6a658be968d65024cc3a0d5dc17e5918622f7cede19be1b39caa6d79159b41a79c1a61ee21bf391cd0e7273c833e67dde5a45a893abe70ef0b4c230afd06acdd725b46256bbbd2a34993f9340ed39fbf9777569419f9e051173d4f7d60bbbaa3f57295d4d566c187af0632dc97cc97ecd21524cd0b2e324d071a3a0ab36eff9949a61d3662d47bbb87e69d73e02b0e42d810efb0ab4d77bdf88d131bb80a582e913e0bfa608a1f338bc14b31b75b21a6850c565fe8c368130cf8c697091f487f9a348920697c2b54d9778133bd54cd51070d3dfa342d7fa24e64729483dab085148e7d35a0599bf5b33ce668d225f1c07d535a1d579bf78a63f8960ef899b418ee142a496836fddf6e93bd97933a39e7bdb158bfb195c81d66cad8f7d0afa4986b06e8fddca2db0f1a255f865f82275f6c091f0c38dce992acbabaaac57160c9cb96d4cff21625bd9c555f74139e03d7165e046bfae3df0c76884e938ed0609d83a6ed289a433cd3ba32487fd9bd4f9a93fd7847d114e3454f98e8baef8a8750cc402a03722e420fae9cf4b527f30be2a48fd07f0adf0a3dbd4929d60b3f1195c761678cac8a7025627dfb8ed7d72fa1a787da3c56857afd97a5f5de9ae196b5b92be230de6ae71e18e673b59aafac77823b2bfcfc26528aea11d3af86e30adaaedc595ced400667295cdeecb6d66c10d422a48dc75462a5427aa3ba18883a65428a179996c632c7a0a6867f56d6b1249d2dd6b25476bf10d786544e4f4cebb28460b3ae2a377b09f203a4121d4b77c554a3d15d72ace4fa7541877ea45022ec6ab0d7680dce1c8890684c575030b1469553750eadce5b35f042694296d37a01245f1ae842a5fd5e6f731dbb17a5103886628f85f5b7b58b7745bfe793f5d1e5cbf708a772f39e3d240c9b5203a1fd373ceadf11515b74307f1878ef43720e1e71374e60faa1025ac53bb449d7b3ffa227f8e624c1da8408433289b36c8f19f9b75232e4e86b0c056a5318ae6215988a43f086029b09ba3d255f059a90fa6188351b90735b5c09212168c6e61d2f8593eb797b65ee382df27c0a2f51e54569b228992779bc43ec81c0c3b5d15505dde29237806eaba6e14fae7646b5dacadd696af53974091ce52b7296859f085af76845e8e80e9ee2b0d213f52c887dbe740606c9e28121cf7cdc5e68c9b9495157b17cd710cdc8fd86cab896888985bbd7c7d73badb5d6011d2dd3ac9f26af1f46a35c4f2f75afc154c703fd207c7d36e85d6b631ccc82ceb3409e43df41f03c8a3a83296b0d0be5a349ac2eb2d5d6f0d89de693a4593af1e024556abb1e3de49a03908c31be790a7f91cacda375212e7a9ef66341d15683f0f540c719b93303d1d3c310a4badc50dc4d4afbe0500369531ceeb28651b99875d0a81391eea3abe87bee4c99dff5b9745a12911869107f5e2bdd7e61f8af86b4cebe762e88984e50cc4d43db7b759fc5a5ce3c8f29ba22edd95703ac14728a509b372f99e3591038b9233f64f08ded8ec4374128aa35a7389d7d9a3c60ed91382c7da08277e87a3183daf00a28c6714fb7d0389cd042f5a651706a7c70e724c8afe376d73131eeffbf0b0dd4840cd075a0cbbd3db75197a38d49757266b64adf11980b1144f9732c49918bc998397f9a04386c3786775a05c25c7efa6aa869c51d3953652db77de4b6858b675e7fd7885961b5d4384123ae039b330abb7db75b37134017daf58d2f80ea4daa8792d3c07b832786daffd481321b29ac07cd8fd8ed45301b6f53907ef19869ca310a29a321e4edb47a1e974285ed1beb75c636e70f36db5d81b0d39a383276ac289b97378c26a7074a012455853a068cf5683ee8ff088db4cdcc827fa2484631203e36fc0da97832b4f8a0c4f83825e5a972e63aa9b01f3947b3320c53a994043be40cc405ec9c562bf024943b9ec8fc5152ca2d03b61719f04b8709609bd41896fd93ab4e6ce2d9cd5b80c246bd8a1e7affac66968e9b61973f5c39b487c7d191d2cf1afd90199ba1488217730f0df4eb9a66c06078c89f6ffc86506bd6fa85a6ae699d2a06cda7ba96dfa68e5a606bde4e85431fccaccb1213ce58cd21b180699329d9d1de8c5fb286c68cb12476ee9afe569528b2832dd3a087352127f07db26beb5684b1cd128a311c3300d5832fa6f9f5e7faa4804344fe9a6cc2fde5886af01220817d9f618ea88b65f1e7843716ebe2a98423796b8e09e67c4c8f0f46dd10964e627343835ab7b9ced1cc2bb9e065c0be3aa21e65cae0c48c81ee6f1926f1c8487f183fc1789e88dab9b98f042cc8e13a7ec6a87dbd49124fb5f5ba76c669465b1fe2d645019dbaeb25658d5b9ae516eb45cf5fd9aa9c1a9caf072ec96c646c486503c2332994e30d3c371ffbe9a3a4e31c4563ccf4178b428d4ce4e9691bb7329dae6c9c0fdabe5233e2a2041e1c664ca584fb47a48e13503b04a471281159c42d51bf96638650a5d2143cb2b7567415932da714de594c5c72c539755dfbdd87bc9d26f7650850fb6231ebf37d0d4f7eac00b927c1a3aaca8786b205f07a92ad0a96a52b40a3c988b83aac752bb32fda3d376dec93c5baadf665029851ca24228eaff601863bc9e4a1744cd31fd3bbc818a1786db421ba592de92bf8d9b2c940c17554e249460476cf82815ee7553e0e87ab869febad45f77479feaf3b478d06abf8585bdd3ace27801077b9b72abde9dbc5d744d956b2f0e1a2645ac6599bd08d90a9ffb7403938ebccab8ef381a41eedc642106ad9d867f786192e6ecba37adf53fc647d4f7c9e2f1fc62bdad6e9ef42927385e11153db878d5704c33410798ea0669d0c9cc38920f8a2e84be0732f105129d2798810d062720f6bd3097949fb98daff28ac2a26b07e1613be6c89c384f6884a5ff25b3b3fc5b8d4c671d034db4d170ffa83782a4a5af8fc7131a704bbd79905482a51920cecc7534580731ea1a7e14fbe930a9fcfdef6d6a8b420368b8db03a57752bd2cad7ff4ff126d1f77fcac1430a308c43c10669a92270199c065b5154c5a7a8e2b80116393d2360743dc16268cd82b0d484dba7bc9426ef8ea0b269550c0348bb8d9f7cc889b79478b99e8f32ee84f278185f58feb4a2308c4c05f65a854323727d04c18b77b7f0bc4c2445619caad77d8ee3fcc5f5da100f0434c116d8f938227caf2d801647df84684397ea81c79c3fbd7518d6f14398af0d280d699b51ff98483dbabcd61340d38e47a8e2717b0b1b93987ff61f10536a6a49acca08b0be35aedc72c5cd195f496c021554c0460e45797930b48f9382e79985e1998adea06866d54b2f61d97ddf08d1f50c43a49a45c7b7b927df25b08ead14a57fd9fcaaa93812ba56e0ce159ca9a3b222afb5c2e0712744125e2de193435ddf397d459abbceff68ab6b9a812dd2c356e80787d9820d05fb89e96bb03ad3c7d7d3636789902cd64e60edf3475c42bb8c60a4704d7cb44c6d5c3ca71d4ecadc13592565d4815a50db3872e0a9a9c7a10d61224fab918b1d061242dfae9eba8e6e2d4a18da0fdfa9b8f6d1fcf00ea992cc8b2708eda2142c04b191249d0fdee6dfa03cea4eff07f5040396ec3417904613bc83ad69f78bc7561eec09beb5f0c90d14289a6765450c364c607ff029861af6d7d7f1c659a47155d40f5d8bd7660819a82321230e3e0089d035f2cdbc275c7874c3fb33b8cf9d4c38ed750b847edabcda998c24c1430bed6840a0fa06986d0d732c6ce00042c5824c47e69373fb912669582988ba142f147d5640b67e7bfa704c0524cec78c5f87829ba6a8764ab7ea03b37eb5bdb661b9f61fe4c713b276e3bc10d01249f94719c439247d66df95d8f0332b26deacf7b063bb2bc7ca48afc419d9f691c76f80ebf298450add41d2339cc7038f18eb37c4aeb2e78fe306eceb6bceec23a17c993e9b497320dda331b30120c7784cd503f8116d86ef16c6ba66f567bab90084f384f051c0ed2089393a03392b0586d18739709d04778b65adda53953bfb7396838f9cb767a7d0cdc6e6187e4f2a1a552f9ee1608e5224c931de4c7722d319964d4562313559ad248132556020c3dc7d052c6970e386912dc4e0f7d1a3903409ba727211095a7ac88849378e269f2267eee70f1fac036d8b2168cbff6dfb1ebaaa32aa629f75ab020e62f32d35e557d5a240376d07afc1de130ec9447a369a48652fb65cf635845a4a23f53cc8b071ee31396d7b1e370b633fd17bb32d87e4298c82f2c6bc55eb6f369d7be5e7fabdc81eaf044d08c2f646ce0b4160bf909b611eeaaadda776254f908b33b8c912ec7b46bd659c98b4dda810a51a74365ac46daef2a49b994478ad44245669b81743ec4f473c21001374fc70976c5e34e3de61ff75f8e5fa8e03fd37e17a3a61740de93f55bb86067c06a602e1826f6b7600e4ab34856e0f71a62fd7429e312068d88db920c941a8ed8bf48d4cb0597ea86ad5014e72e3752f843e56a137b9ec3bea9121777896ca21b0b77384789e951457dba386cfe48fa36f19f935f4c10ead8071cf02397c496aab310931b03848210f8237747b2dabd2c18bfb1f34c8291565d0d98a75c50ac210e9ba9bb89b17a1dde7704c2c4951d8565e90b320a14cdcc3fec405e8bf4cbca5d52c8e44a205a12af9992a2d8754ee93206e30fc7812ebb5c1169eca1cef354906a67690f5c8acfeca3f1d3fe830d49d07128fa2875459db65b5b19a955d1e8a35f953af3899440a79b64fec86bd70438706addadd719049f583cbfd484d7b4a7669627a1aeb1ef582bc1b74c50cf5531882047debf681b3c1e8a307c2de3c8d1a85d5a95a206e6cb6ee93ad3c5dad14ed687e280e1d297d509925b353a623e216e124deaf28b8174fdaa97e3d8ec5198a4c81cedb25a380613530b662beb53628e5d76034e5f1ff6130d979fd2f2947d13ddd0a48235e6470cbd93c35ed7bcd66aa48106e32d035cda431d8cd8232ab72778f5876917fcca7a804b86af18609d9f400df4972396af6ab092cce435d36c9124ff765f070cbec2162b505f7682b7199002a1629b85d4870e85b2802c610c17e506f5e5694c5e19d34a1a34cca1487c2dea20ceb17363a370c359a91e70a0fa1a2ad2e1fb9f0623e24d4b5b9da73d845ae650a617afeceb6197c4a47b6f46b95aadb6b196dbbbbb72d5214454b3e72a2079f46d5340a7bfbb6f4e2b9915f0c33f69c59df08f1f9146a8eea1c9e6a14a5fd97c7b4d414a3032595dd214f06ecc965b4e001bc1f99900abf465f5535a7cbfa5a39e69d34256897dcf0f67570dc4938271d9e13b5a960723a0602b82628975334cddac32e686de65c3d6882183accc25e64dc40b8b2fb5ed47816a10467e617036f7b979fc377385bfb830d4185b8effd0e8c3af0d07ca92a9da204305843e8083652475518835f801878b425547a4d13ab0d01ddbec14f80a339842e1da958404430d2c835893ba89d664d840dffa199e77ef6c1c87129de92825affc97e695b4f6cefc08ba46c715a94c2bdb6e9bf7e3d732777ae680575fd6770c2f43f4f6c4b89796dedd8519c96f96ebc5c9a1c885dd8ae92bbd4e20abaabe7c206e5b5591761c836d6ec98ee890c46294b66efa6b529c0a5a355d10033a07870c23f22b3b5659dc0935206f0a66b97a439e221b30c00a6f3b80629ced61d236cbedbca7bfcb0e4fe6f4d0c5cb61e06358b7355ed0efeee4ffbb1b83a776840473242affe63739b890ad6e2df9411acc1c5644b87b013130b5f6fb21134ac2d49279ed402ef927fa7fcb63691d19477e310c977374beedecf9e5982e8a5ac67bd588c85dd538231cedfb1e76cdf690f84700aa5e07ecf4e9871eab9f3ed88329524182c5541bb1d43fad82af95a7d412f334a3cacd2c3d55c0d748ea6878c5903e09de816f35c6eb5c044eb1a7b481cf748eea759a2f3f54e1df22ad88df054b76c48f1d84770bbef39e26ecf1e61b330495a6c32a7e2b432a13049dccee0d934b914613c8ecf8c652c3dadf38a112316600bf0675db29d06ce9e30fa0b311de51707691fb2ae28d9da064bd598cc31f942fc43c8b19ac21f33f707f947c2bc339a7734554fbf563bd09980e7abc6d3be4adc35d63eeb748bcb66a195a21f8e4825be098d516792edbbfc4cde61177046c794de5c1c0ddbf49bf6aa1069b3b0a540a3a39ea8f0f7151b0bd3957458c215ffe9c3ecd12f350fbe37d40563727da43aa741d3f3fb5a9b4029cd78c4cef017db76248c916304d2b5b42f6a2ad6544061c812f3c012a3a346fc04cc8868a7bf8bba59a8dfa1acf589a73983506d671457cb3e8e9bb3ca89134abd40eda6409fed52f927ad6432dc1dfb124d17d21ea40e803b5093439fe76d3d231d5630498dcf946186e6989095000f4fe28a2eec85ea8458beea5b8cb12f052f51837638074890dc5b09d2033070a10d145056d431ebaa426607782a4acc1aa635c4a72fdaf06489c7824e7228e8f98cc5105ebcbf32bf146dfb8d090e4e5f9e5fdeeb8f2168bcd399e7ae2d83c2641fed3a9024e503d60bf53ca8c6f6e701c44a2d9a68866cb9181f72d4e9149f0ca20458078610348b6513e8f51ccc79f03f809f2d13f7715fafa38358e235617da1cbdde4d5e84a6e5307a84398fae36c2ae789fc0f64223bb916e63be70ed9f02a7c17b8440bbf79ea1d3c72fb7f12257cc6fe9de5bde887122b03f4070cae2043f1f7d25dafb34b69adefa176f0dc0776657e3f56f6193120b1c221f8e499afa64dd8986ba16995242f4a12f635f274c5a0070c478f127faec0ae71f7cea602464744c0483461b96627fce0130681cdb463412bec04b31c5c5cd895fb0f1df466a1414489ee7a5d33087b1ec6693a6568f8041c6fa75e38aa81206539761df5d333153359fc9e506c11be69e7f0fc3b79a59f91c4332e5361c77687395aa4fe6a4c42e93372c95cbf9a262b225a23e8bc0fe26b2176b9b11a3e09e255ef75fe1a7c469e167fd745a1c144d4adb1d1a81fe57b8de682ed8bf05347951a1b3621fd73bef6e79cf9164dfbef4867f5209eabaf8f35711e44bba3e0046e44d2c5686ce7ffa4052841af88edecb03b82bff999f02bf11e8233c590c0fd449532d621e18482ac1c80daadc04d7d3a28f14dc2cc4c90b4fbcd50d530140149cc889821b460bf3589723b787910b7b76cbf889f1bdab14a6e58579d12ac4362ea84dd74f504db2fc5be8439fa7951619ca2e6e09ff04fef7569cda770975fca25120d5de917368610bc08d8ec928f98620e08fe7578101f2be15b2aa107c25e2aebf368ee66a17944b8e7ed9dbd8c7762ad8fff53aa27b06fb1f0cc70b696bc392d1551c116d9b72fdeec2b26262e1bd1112f14b922c29bf9051406de5c521ee3a0274d5062a144f4e2351b44756530b71770c69c3939eafde5032be8a308ae6a5b01e93163eb91e7148a2141326e1927510cfa0bc671460eb33abc70eb9a712ff14127eae5b9f2e40c6a0cfc173851797604d838f499cd76bd1a8d753f84e9de593a84d2d242fe70d81db38e6e760f12aba1b41db34f9c76d2cb96ff524fc8ba63aa48abaccdd546f11e4bd48bd9c6afebf375c9adc5f6c848fe4d593368d10c8920fc4e56a8a6308124e3fb264bbfce357fb9b6dce2aa2a418501e2e34e168b6b80d8a0edb6cd703f7b1e7bd7ed61a086b2de01d45022a09c16e35fe9d22ec95584ec0be8db3072872663d90ddd7c2539766ad177736887b94f53f1994b9e8ef5bd5dea49cdb074c52ec5eef3257d4e7662fa3e1150b6255c6bd51d4d041627de2948dbb7548dc42454cbbf11681b0aa8762dc6ed3856b61ba069d54c6006fd70d8ca329ca1645d96337238671322d89bd5dd6f524405c91f74305d0d4459cf4a1ba526a907f29437f44c5030e9b7ffea040278b8556ad714944b6e2e022c92bf6b7664abffc2efc50d065cfb55238c8f2ae7245d9f6b4714363d2e91a4643c25e25a61280a7631b0dc0c015de6b6ae0d51106be597b23ad52d180a54fc2378125d0905b502390794000427b955cc148cef6060ce237c19f5740a327ef678b92254fa219a47ed17d1fc4a4ca363e220cac0b24b3cfe9d10de718bdb163127bba65f938c1a1fd805b9b07cd8336bbd60240cb34b4324623623b9bc4ab8db69ba0e9169aa0997b0687289aa2a1edeb2c0b4c196aa7e328b6a9d867d95024c42984d85c6758ea7860f154fa8491b744bc4abe040f8becb30ca01d93cc6a880161df911a7fbecc999f19a3b26be143f30e05197dadcbb389d7ce446336c5addca6b17d22737c1be5e844d139ef699944981d31c823806da8dc3c4d6ec3bebc5b0d5a701c59e6d12da3391bec8588195446ed7ff2d2dbb951afa4b159a73518aad6c911a7678297d43cef29c497081e374aabbf6f0101224b17af89255c5b18ce0cdfbf4b78da2bedb8c400cd4cf2b92e8eb5ba9a69ad580a5e199f945d7a3565e6f2bea17964b371e89aff1808d9bc6cabb4bbdd691c1507fda7a1f4c19622977df32841387240e8f913b6ebef2f92daef2a500d44dce2f8716f0ba9f8b9cf9f515fefb37badfd62744c4280674f79827ce45c36b512153a541ade6bace2cf0158a155c0302e0c3f65fd40d2031d928105d227743d0377809060678fa840b0839d34c53751a88f16cf19708f65fe6c71e2296bd6bf84d53342666655bf710fc86bd83655b6daa232b24e447f01d88aa6ce39200d40f045b8f05e1a644e2291edc579d1fc10a39d72b790ae546aafda6000467c95e79c0acdc89763dcdb44d91e101c76e2065a4686b19915da8cf1590a10bdcc4c2d7af92423c384701c848cb9da52605713703667e4dd6f908d274da7e9dffad7d084e430e8198cf6fcb317e6b2dcb372ab25700a89c525b640bca0d7dd836fd8bde7323026b86ae69ceefee72d0b9c315fd56026b97818da1664b231e5a3196a096f2bca39f681b7c35705d9c1d11f20b60d8b2644b8c447c848c1b5d2be58d1545d108582ea1ad76375ec4f8cbfe81df3c1569b647c92675851431c7725ab9976d4d68d7dfad03e2ffe334b6ce7655b07930d6956b32063903e12f8fffb22f0bbb36d76d5eeaf158c9b5a0168829f691b0691af6130ff3dd29b0aaa9d4b2fc3740f1f1d82d49a7965e3f48182d0a487c5f2d6fdb526b0d664ae8513c3eb0e4329e999cfc8f05d1dfeab68f171b7e2cd3b85db1d8829865c02fd009227717bf7af5849ed0aa981a4811aabfe90d32d0bd6651f2730d2e647d12dc5bd282e4d1e772b5f25954f44226afd6812f3ac7cde6a46a544bccebd7ba9e12f3887652eba8cd158ab1ab7b19fc1ae080f16969ef3f12ffbaa168878b517cd341941b209866c8b7174b845fc53f87f731c9db16c6262fd6b6850131275d33d6ee808620d8395ff4f311f999eb39af905c21eaf98557049fe931ea7512bbed0dd25a203456e714abd604963fff2675b727c97dd9d523e11b53a481d547c10576139c461c51bb4e3750e393270f1cf9cdbbd21121dbeff05bf3fcb6bf2dec60b09276516dc1cd2a88c582e61a32e2be1c5c20a505303cd6375d08ce45b7f0d221a8bdb3afb91ce3af187ebcf5f2525e2ac5355f585334bf51f2f491c098d76a6df8f39332692303ae013fd2020053c10d6d3b79a4d85a0ff9123312499dd5fedd6505c2c37c6828f28112571859ea98aa10575d80141328876b35c17e0b12b42110d7d920345368d340712a4750bcfae0bdf866486f4a6b4e8246f262c9237674f67cb6194ca202ec5b8c7069e2ab3c7d17452ca8eb2f76d6dcf9151622c6cb85c1aaa4a88bfc2e69e98b74f7c8ee3bd33ac003131855ea74ccfe81bcb0f9dbbf679491203e2edca612bc1f9af93be758aad74bd8f983fcfcbaca01013619f3d0e21985bdd38fc874f88b4bda963303e5f9b2e2161c0bf0a38730b5e22f71f693a3c91fc4270ed78e5200c399626c5666eb9b3b7c9045ea2517d35c0218358dd6d9895b39225ae6664194211f97cef3f85545570cd94175afd6bf01d7ec3ca39978d7c773d8cc0b372b5087d94ff0a30d62a2f94da274568a8ce023ad71aa816e7b8af6e936ad7da744f9d33c5513e53c33442f397276b75ed9454fb9ce9068c60554d27ab305072e5496ce889f63d4e541ebc318658ddb882c63edd4d45e3a5c704f76f37c57535ed6ac81266d3a3ef67adacb550eaf3868959c9efe214af4d98688c3eda73924bfb3732f94421144cb049d3de15a79d4bd9fc115d75e75074d9eac41bda37d6dd40a6d73fd3be76ec48749bb740daeb705900aae0eab0469277ce131ab8f56d044f56d1b65670c0cac95005a718df38d896d71646beb76aec14ef7a2e1eb8d577d0671d0681c5544f2e25f275f23a502ad087d4726c5da32b70fafb86f75f989d1498956c7665cf22df4488f2ac17250c6321df6b7ba12381230903d23d3d4d4b59da974d61f8be594836dcd1e29565d3aa8568184293c5f5573e225a8ba677ab0a4c18c397aa62188d44c9eaca19eec9096bb9c5980f7f53a4b14a29dc0958be9bfc52e2daee373081dd6cf2bb1b2341000904fff7545b0e7f253c378346c343443dfb03b47aaa2b8cef48102378205dca104380545b5ef5165e50a3580f53889c2512b021f1a03d6276d93feb2f1eeabb3533acc4874417a85c9d6c7d1e6fd1b161fadabb0a21bd4eff38e777c07df7b97d83aaadae36f3cfbc41a0c72bfd45918fa771e8ed3754a8f1b4ad85fe3740136bb082f48594b2684146d18dc75421c09d8944a9c6700299470d5ac10b2f7610d3fc4143568c15f1d7a95b538b52d190b5e8b8d0966aa423d784c39778c0e16e8a491153bdd6228e8c749ab4c8dd9974d771657aafd1b03db466f4673215567bc0108eda6bace024e78c2eabbcfa1c3d93af0fbe19267e1d1c22dc25108723d5c7206806ba6ddaf658a37975109bfcaeedc0e6c51442db537656458fb193a589241c2645e4c793b8dc0f251f077be2047496f3cb7414288bbefe4feb0147deb644ce1e92ec9f74326e75a2b910b6547cb956793e9c4e402cfe07b43c5d7d57249eeed431b8a4442048bf0677d8b7ca8b8e8ba56de16543b939c2fdbaa384cac8e7a5bbe0a2556d15c4eafccae4511aeb7a70c2fe55184e17497419a531f556d9fb394c261e292c3015e53ea82bbde4ec7e70713907062159d961b699aa555093e688a3c8eb7d7c0af6f50c4062f3739b63bcf3b97662798b82ed6e0b11cd489e20d423e674d5731e86adba6050247136f2e060d98ab80da2a719095fef55e06a88c207ab2704029a67217c49a3732d4d1de8d03dd6149418489c46b1a14d7dc380b31b4a504b16342cc1f36b647f50f4e11d1019dab0ba1a6646204fe340d5f1d27c56e2ac032f9a83101d3d1a108545c024ab38c6846175ac76492d2fef89863261be089678bb02f42811ccf7b2d324e87f17985355ccc23274013f19859efb6240688e814169bffa4975621950b26e9177af86012d3b879a3c9eaded265786f3369aa63671c63bf4b7736e7399dadb1946c7eb50a21d9683b3a2a907b8927370ac7e77773ad74cc75e26585dd9b64d3bad6b98071b843953499dd0c4e4f8a2f9902104983bc0db75e88ecae202e2beb22f770b3ba2ae5bfd3a305bf902e30c387731b2cd7e6e1ecafe40de3f2d5b011390fcd2f53494e6e1e705874a55dc0f27641bc6490b6f538c5fd276977bcd984a842c313b4145fe2aad802bf4febf6a32683b111418320a96b960ed5d172320630314d9e0731e75c3d5b502a97c244d145b9ac748eb818649649269da290c58816c7c428f9cf96b938eb0819469a1fdbe04637eb0f5933b7eece105f37c1a631cc6d13176d83a09a1c36d47f2e20bd7568dc0effc57c1c89d370f6e1ed821c2b6211086e2c3a0a8eb0aad0e498f19af71a2616a18475457b6639d4c329bff9b1b5ba105a0fe2362563075df704a5290bbc24a1cfdce41ef262c968383e126508a55ac3f0006e059c807775b47a0b89030465b8c032ead4af6a0739497422f892bfc8e872b61f9f8663c12e357f6941109f1d851755012ff9d33bc43acb8779243e4fde396cde199bb4c9b2344ea431bc5689edb6569946ecd820d3f534ce2a5664af137d488cf56881bc1299909f01fa0f9e1e9a2cdeca56789d24ba3b53e6885865a8a5d70e8cb0b6fb5059b04c904e6c4f882e6df2b49a21b8ba0fe0829e45bfb95aa4e8ccb6101bcb629282ecd4e19446e5d5da322aaef42d18b768e472d3b610dbac93934f4c93a2cbab7c084b310ee9868e97c35ce01d6b4707c4d9cd6a6173d20871cf5d207459c4977937fa0bb96bcf78c3e74af26c111d5ee87b21174fedc650459a0b40712383e26edd0e5f27753e71e72b073d3c7c8d8831616be5da5126279e938757eb9de9bfd8e7a6cfcd87065918a814e3e98343444c21612b1eb66ade481893ed0bb949a7f0f00720e36c90d4dfe888e1521a9572216ad0dd1dd2f30f6545411f4dde35dc5340c469ad6f86cb485bf69977abf153aaeb1972d24fb4443cbaef860be4a16cffb3646a70426b1ae4870327256dc51cf59bb7cd85d2997bcde8ee945095e21159096fbd087a73d8a1b1dd522fd77ecaeadc2341a945db2b059525d7c3ab6274e4f364a06c3ef4de358a75a1c4554f5268cef25cbee9d891e55c84a94421cc4758f784ea039ce403769896e72d9762d083edfbe64250aff0d815866ceb810ceb24205ce14412cc3fcdaced029b35d6e1eab91a7d4f8568bffcdb8f4ea433b7bfb50aef31c430ddb7bd84dff0b0ca253fa331ed942d7d510c9f2fa87d197228e2562ce42f9b294c1fd48a4fc68de845ef3e889f1b9672bbe87fdda41e3aaa35180abc0ef575dd242d267b71ee0760bf3ec3fcbf4e8b4956315d763ad47007f23c4554ee716a405ce270c537ade68af39617b6306eeeb7af791a1d5ac7339fc855d7aa188e025a26bc2539607b0d76b5308379759c89efce3c44721a36ce74d23b9fa02563b9b8128ec9e4302959dfd915b19cd7bbb25e13e75c5edaea88b2e307faaceeb454a1e7a8a88a13293d6c34ac0fec5bdd40f678dd16193b8d4c5f71c3300fe8505ed7a9936f92a8afb0944a147c14d10d2a78d8d960c85c24aefa2ef6189f1fe2dd44b6a04168d42d284aaf96d4c179da910b70232a98272c5edaaa9360551f50cc83846164f08999c0bb24848e5ff550494ff12475e99632a713bcb3b8e3f2d92f1916d69e2cc7fce01795e1101767cbdd75b258d6e42238059e8a1b6f1013d1af4c12ceb9cd5a5dfba040d634a0c920cffc9669434ae330276545d4cd27065138f2251c65c75510a4553db39957dfa2bcf8ef25772c3b7cd5a9534e735809e5100e830389daa3a2f38fdf0d6a4c9bab09348b2c8c6c9d196360b0ad05f1fd49515d8883d47f39fcb7fd4c8cca747808afc003acff8e594ea8ac03d13359cea693df675326377f4f13c925e4d75c12525e3799d72cea189e526c8cd2e20cc9776f1cb948e625a7ad12a76a0e3159bab44bd12a77b8e30a1e54941f4e5c6e68066077bd7eb4482a17b4ab2c881044af8642f65f4be90ce429f2114667b7d32ce8e0738deec2f4b9929ebca433806084a8c01b6e0f06b570e1d216a312ce06dbda4fa86020a65e74f74be79b97e3e2f1c628b99e62ba8ead0a2904e260cd070422ed97700fa3e1c63e0ec91d7f37c3c03c91f1e385b1b0366392c75544d7977a8abd4b226d9ca57323116c247d128212bc73b03d943c2eb6a365a55a80298214356b9091d7863f33e6e9525097f65a26c94273fd6121d1a2a3354c586178f8c18fd0a4e862b9412a47c23981fb71b4d402848baaacb32517c2e31450574a1e1a27d8197e789893e2d911c8a7ed5abff501208acd041af6b6b3d103c4580ac03f563f6bb1ccbb30237086700f461aa743185e0456a633097bff1fed62679223ac9f3bf3af18dcf850cffd1a68545c40315396cb4cfd015941ac8939546770d804e54ebc75f9031c68567b8c9171170e4b557a65d3b03f2c0cfa0aef01c3fe0d3fd53fcc029a98a9d6d553a8e56381b5502537c8b1230d995e24264cd56a0844a70ddc57da9a5ebe948e8907c8cb3b08856755bc0348f890b4ba5485aad18644d971808c71139dc420adab44a5726d635c615dc3ad408cea5435f92021069c80c86608b3609bb9f6afb5f795ae5c49b63726f3ec3a9a5396df3b8cc725322679a9b157b86a5fa612d07407afd5088c6191ac62e7e059831ad14253a161f05d5d2a8843948ee9cd7445b3a318fe5897f4e999dc511b93574c4b509a5ff534930755a08cf6ba6889636c9860c6aa2e5e5b6b35899b7c065ad589a07e20cc479ed5e00780a6d317f56cb6617c8775d5fd8cb64e5ffc8967b9926758eed1af9073b90bef731224e7b8509823758fc3c357f76928d55cbd2f044a69cdfae21454fcdd912858a083d07bfb6e4d19d0f7736fe9c7d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
