<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6cd1eb1dedf91af4ec91b36b5a6a507b23c1f0ae91932136c3f6b1a948842ebea5a88722da0102cfdbdb634e33957da867ba6c72f7f71bcb5de7fd4518cdc4511a1633070bd1ea2e224a36bfe7c4b7a1b3d6d4fb8205fdd36d93abcd4b0b41af9097555582392327e55d837133621ac4e080955cfd93419cad6bb8fbdb1c0ae9082b3127f3a4d4d36ef3f0b2fcd3fe42ba9271930c4b72d6b15ad8430de0e1e9a4097e3329e87df565b8c3634023c58ee3753ff5841c141922d639424c62639608a3cecf4998bfd89a16d931a8e1990ea35b20cf6a80f516e9964d95f0319d31d8b900b8f4d0ebd1655d415dad46b1ca0c9b7b74fa6d864ac5210214a60ebb49846ec11149d858cad065fffb17dd03e2a8ed3fca3002be76d280dcca6b2c2c52c0c605ecb9627b027d9de6ca84cdd250b0f9c94698859ec8cf5b74b6da206f18d053f09bdd9d25f15078e590d1d75ea67647931e50bef9e834ab7dbc9b975f17fd5fb8b46f66399307e23f4d7358697f5b4d8ea1fc7c6fffda228ecbba9980bf60272faeb35cff25073e2702a9bfd780b3ad481e503193852ccc66a343735b470f6f19df855deb62ad90d55cc5700557172067be1ecfdb5aa89c4f5c8734bb204f0345e28e880eeac256010a2ed43a86e2ae6149f6cefb2b557cda8ad62b0c45e07711eb65bd8f7784ad6f0818d1ac746797a0dcf63d0d92e95fe719dffdde8249b9a44e040bc2d913bf4b017ce5398774095ee7bc3ca7e5c7534a313479a74bfe9480a0730e9140b306f16fbc9b4b4688deaebecb1aa5be740c3967c7be8e9f35c10ba7aa622d2bcefb61cb84ea1a7c36544043fe77a72781ce5ce13dbb698082dca354022b4094c2b4e9599b1774554033b4bbb98a791aa7d0f4a94228eee16d9c2980b50da560f0d59fd40fdf095767aa072235c344fd117ec8205758bb9860cef9bb7fef4d411044f82184914c4fe0a6de86ade506e0f80d796997aae582e8175c03d93b1abdef653cd3130963208e32daef40cd68e09089e4b74b688cf9f8d0cff01d8b701e63284b8539f92e6e3024bb6707df5322c8bfef9ffcd0d4df70f9ad84c7c33a4e4ad6f32a0e20a2a3f86a6ff2cb9b73aa40d003ae876ae30ea0486d8fd34957df0f342697f211f7ba545f3d688cdfc7b1686b8f7c28817bbe7a1355cf794e83011fb0326e2714d9e3e744b96a7bd6d532ed9a64969f953f5d62e77aefe422fbc96ee08421919e34bfb90610f48d3cf4927c3a696ede957cc2e292cc8e9228f8daad464511f45d272bc5526816989821bba028b782564014dd45d06920f14617b48ae3c765c01c7ae92468ef73fc5737d45b6f8e6aad698ed30ba9cfabf89811143780dd537f14183f84b7a2ae60beec49ff1c60eecb629ddf9b2798249ce940b4092b21ac1e3ede38710a3705341efc705773943274d6f12b0d05564791f286b785c67f6746690eeb4ac99de00a930918ea95747e09f28f50e87a115d57bbc44df585fd4cb9cd1b08cbd7b2c06e4e3e9468edd745bbfce1f2480f7ba238ba9194ac17d390f35516ec6b0e49ae40f33a55f0758095cf4cb25a0d80efdd79812443b709ee8d464e1ce5f276be034b931ac703533be06c551cf1964546a4b66c4f44e31aa07a1aa159362dceaf5ada2b1d92caeac2743848a82419d36870a342cdaa7d85468b3e58e512640b62c8b0e6086f4c6ce063f1d1c5b2368eb370c239685daa1a6b2f2ae85871f7f8191c7331ba1744b580456071d99cceb199b58fc829744dbf56d1ad30d270d97157a3880f7e8168b5565e5aa6e6d7904187aa59ad89e432900460b27b451f1800b0235847aa501144bb3ad4a9bbe251474075c4ba30d558202c7510c27750ada73eef95e1483d5de4f4de640a4fee04679f409a7b9793d43c67e485c661e1bf159f8f4b331b222896955187e08052125eae026c0e15c65d1b4f33c4ef8bc7846c55f485db7968e7e2730345b00af1ba88eb52a5803dd513d119fd2623fc97758f7ea97df9b6678eaa89fd067d00d0833ef547b77f910713d75f2c63c2b8af6bcf48469d1619a6d0eb56fbe2b8e20a4da34666213b7c97c33cd0577c94268dc42c67c931a2a9555baf9fcbf68aa147b21874ef73fe035b37e03556d2346615febece93dcfa24352284d01ec87ea45b8d747cada38ea7bdec7ef8d0ae2eb33ccfd26849b6c703af18306e9feb07fbb883d0cfe685ea88a92588ecc963741192b8f5afdd5bdb75332a0132d56a0df987d490937b5c489f9d85e3512a983e0b56f0ddccb3995fc603273dade8f5a26e202642bedb9f20b56c3cc61b2b06f58c4d11b87d4c3a4c6554d3146976ac1418ab2177212b9b8eaf0f0ad42a7df82af731a9dd51c07d1261e08c965f504bd6a5b3e5782710c1b42403aeca752af32be03d36c770844eb2849f956704353b592356cd3dcfd11fc7e382a3f9d2726cd539819ebc4b16a192efb770ff122db040d856366650ed5cc80b52e65802005d8ea7a372cdb2bdf8fe138a5b7e6090a758a63c2e772391cbb5ee4b10350aee29c9264d529785aa119cfa75f83d7bc9b0e03095b95aacea77ac588b2554481f2b53fbdccdc4e864134c86528f6dbb7e8c0de5ff9519e9771b2e657a184b4e2008e4ba7b0dd854798a0f0a1630c459dc94a815d4fe28b24c79a717a1db5bcd56fbbb7e3dd7d5ba60c8fe8604edf2941e5d6b0854cbc8341fbe5ec29bd57889b37d444bd47457747c133cc1a68510bcba73457a272ffba02bab116ecae119003fa57305bc7c805b4be79b10f1b43e8e72ba46d94174b5fbc8aed5d94b46d4e43c9f19036f9be44c9b8e5d865f3fb74c698bf60a803e3d3b0533ee9e9193b953b6827192d3cb7b1117d05bcabedfeac2111cf3e1c557d3f11f8ffe15eac7d706d74d489a5dfaec8f57e3f4b5c99fcddaeb94deac661d36c9f39424e93828ef5a534706cceeda3404653629c31807eb837642546062378d5e9c2ddd84889d39e6242459acdf959def28a030ceb0eccd9d93000ba4cf7fa95735eab58a5059fa267d3e9d7e1a8141ded99b081c645d9b5520c2b73b55f2726b3da9759f3df97bcbbe3054e3103fd9bd59b9d49a33787084984e4a9921e113bb0fdec01e60feae827cd5a684655ca3a6fe6be263633731fd6fd5bca676a0caf68a9db2e40c5898a42da5b560951bcba0e0ebee6f917d0b1bd7e93606dd13f0b5ed9ebe62181bdeacfe42d84fbd5c2bea86140c9e109a9253da54118193b318f042d7b9e8d6e9f8e710b5e6b8a5d97e51a944bfe2a162811c2aa0298692b23933312f7a9a5160890d983078c4e6ccfb0ead268c6364789e66c2fda31a5ee049dee3fb087eb69f6e0f6883bead1422a760705f4e89d4be6c6f217b89e8bb0ebdfaf72eb586a33a13e2c9ecaa47278be8de56625d385f84b85e9f3f2d12be70af85cd88a6cab263a758ce42d589dc5fefbc3ce59315aaf1903e5d9ed09f97d5a354494fd483f5a569d188ac89fe4af1484d42dde24a1c26bbb611935615da4ea2530e3c15995df76c607fc443b16df704b05b4c6adacd00bc22b42885856ba01272f58766ce474e6c6894490e727ff9df46b1a51e81c702bef5fdc00a7f4b3eb23359a234e49f0a155fdb347cf8d01d6e7e21e8dc5d1e31973dfe7412d254a21abf2628029f24d02fff6fdc2315bbf096b2afcc4930044169a6b73afbd8014a3b51ecde69d7260dfb38e5e1ddeb506fc483b95a7553e5a3bb903d4d895a90acd068d83f3430c0489f2f46376888b7318bd37d560b55cdd3184d20e3a24a7f543c8412cd54e79105ac6f0265517c36c3abdc38f3de675467b4b6b2919313c13fff5847fbd55cd9a7f7ea3a4f7eafb6cc71ead14f73628760918b95af50bac1718cff8d933b1f8b0ed10b712844370ece13368456c7b117ab75e468d697efd7d38b09d00b0152c42ddad0fd89feb038642e5b62af0baff7c967fed30e7ceb9fe40cf790d1345866984df0aa12cdff50177e1fa2370dc5d9cadd112b47b188aa10f5dda3d1f604fbcc40d52b0adc9b8fed08bfa5c29f85e92aea20137d08c36450983dac4540d5f05c85f8787347dc06b9c4ce7b20805367d77620217a65cab0ea6820b334231dd3548c20a148b3e877a2fbcfb1faeff0fb0ef8a92046f37358275fa4853c4a39682ea9a6c56651c988ebe2458d842c0a9e42356933bff61d0a63d10af5a52b20369b40a7478fb3e93ec3cb42b6445788c143a6570290bd25662652838521d75c433653be483932f113cd1ec1fbfbe8923e14dca7d7bc0e50e734ce02cf149669f1d3d29696ca295f42e91fb79649fbcd2acd1ced31523b378d267d9ce7eaa7313834512c9076c07b289f98f8f19575645dce7736123ea1bfa2c4503fab9dc0f7129b2fad4c1286180431e7ee3559b985122ff1665126c475ae93b501abc9ff84e65ca3131622bef485c81e59895cab7c2dab57bf164c8f44c2f0ac7101a8343d57e82e40c7778723ce691fccfbe8c80e9981d23cc32a699c58ffa57daab7ee4557dafb77eb50a36564b02fc625fcefc540556608fedb4d5c965bbaebf7f18a029d2c2d8d1afdcc6be20b3094ae974703a13dd86cd413f7de788963f2833c785b05a598e8472b11363cee7238e54a87b084eebd3c6b687aef43e1ca40c4ef13a9b84c84d7820c7b404675aba1e9e9b3b5849fe19be66e0bca823ee1cb7301236bb72375582d3c3b159d05b84960f806f22d4b5641c5cf20c9e7fa4567cf0379f95b3e4fc4b73cbf7ce07fb4f80c689c31a730bde79ea1d8c07ca95dd1cb1d64bb30fc7e8be80eb1f2ce45386eaccb0e2896c46729925146798ebdb9d591b19079889821f09587065d43f5ec8e5b889f988ebaef417a3cd20a686abf46f37b7e770b7d1e21d3c198c40cc843761b1aa64ecf44603f43011e3331c8e57c1a5fc18e74f04432e59e8a749c6d14f657dd724da56d487d2794ae4bb18ea2d59cf458126d86801de89a6295bfc010be771f2b75dc6b44ec83e553173c6179d9d462329d72060221b37632bf8c6c4bd3747fdce6e27c591bc1c13b42cbf2e1f1f7888b9055619987a53627467c7efd8e952deb0fae0c951690c6e97dc324f28d756787014128d768e3f7016908a00c2e59d49878496c37f70bb60d8bcdfb7bd46239145e284ff6dac0d06adabdbb64c7db226bf3ee264a11aa82149eb8bdbdcc8a24a36744b2fe89a3fc50beb0e60c665d0235fa2dcca1495eccc37a6c5842214870e474fed1803dacfdb0d4a3caeb4c7a84132a598f82efba33d238d1dd5ec13be6d761bd1ea9399c8573f0ea7c5f86cb2b5e5cad01adcfa4dfaaa96c2ab80eec203cd89aec6d4697c9e8671f3ba1960079d11e9a37f3edd0f920ad6e0589ff7ccde70ffc6cb8691dad6055d1a745999c2105ab648284003e1d735b335e0aa704dd7b0bcdc06136bb50a6dfe1c4e23da7dfb52dcfa992293ce851adc010770e4ea9b9bb2e2eca383f9ddff72ceb6fac4ee1bf2d6c624156785dd31348cd46d385d3f8659acc6b5124e39988c0517d52d4f4d787bc73a7ddb1e906b67f3db3bf6de430c185cf6acd14d5ab944026bec54213817415c789284fb82432b034d10a4533b376db41feb89226eef31551db987a9631703aa871575b8fd97d1a7de48e3e3060682a56cf7ea20578c78bc11287f914bf277fc70242704c7e3c86bbd7fbaedbbfe5c38c05eac4bdb12e4b6b4b49231a93ee89ea26f4faae23d8452fb547e3b19355702faba22dd952146278503d324981ab9209edd57b4390d97957f9f73852fd2f4ab2b551f5bf0cadc96a650c3d1e98484cc8e7ad065d454e0e7f3da2e468846c53b5c58fdf16db7178780e798bae924b8dfa2fefba3a02522604392c16ceab78c170c26ed7060b8f73daca35d607bb7cf87f9f08d88542f181934a38758b87ffb9cd43478a93daaa0c79cfae9160713400522096d6405e856eda1dfa8cb8427d327d10b056a1dd6863552c6754c5905de23ddd2115f7d57d4ebbf1dd97ade5946804687b575bcad8a083b7799eb5ea6065dd09e95d85d868dff9b5b2d99db77ba22cb13e190d4316d799bbe42ccc3f0a9fbbf55f81a8f781ac309c914acceea5794a9d9d78915ed897716c2ea7e5bc9f32c74f2cde05144e8debb306218996e7a693da42f13bdf23173be44b56a08f70e3404f360d75103a930fc82196e397c7a511109c9afa560dea7bab356b3de6dbcf45f428fc8123e5fabc761d117011e5598f56373b2bc581e453cba08f875d824e7d32785403b146a410f08cec22555e015e9cecf1a166b3cb01cf84995ee2c3361a8a4223a1a6565a40d2fc13034bd424414bc56cf07677d638b4be528fb58007a252c22044b645639ef57bf6dc22e8cd99618ed0ed073b43111f039bd8c622f0e99ed9e21f22844ce502a04a8b6e71a3cf91cd3c637edcfa8485725c5c5c315172162caf47ebd9610c76bfb670472eae898d0f3afcaa947f4fcfa030cd48e3fac5de512b33b50e71e643b00211393cb73cad68aac921cd884b8c7993e170acb61355876a89562406a4e88197b8ad6f9889ee0ae1adc97930a366e6b846d0cca69618436b433bb0de78d617d5dc49a579ecc41658e07bbd4b55df78897aba50c86c5af70802bfbb9229f9d1f3197998005b88c7e61bed89d97026525b3f4b7a0a63e8614224ac854069d5d88922c66c8a8fecdfc513f74bcf1aa1d566b1ee2e361e2f72bfdd98f8892f91e1f059388b13b1778298704e17126a97d1af87a3a92bdf43d73a43b2b13be00a72417b2a0b78b16fa7533dccb94b15c4bb13141e687d1093b84cb3e6ac25a15e274abc9efd739f2d4322a3cf5b54b88d321c577ff9925103e3518be0c39a3a50363602ada685a5018156a25c7e8cb9ef199de518b87198ca047c9598c9dfdf7c21e4c810a66d679c290938a1221af33597643317ccc8d2d924bffb4206b8780810041391d0a1dda2a39c9675832e416d5299e845c5b842f74735cbebd887e5362abf2c2a80a97412cb292c3f2fda17b4c8fb463672209cc90ef6cca1e49100c3dbb3153f8027521ecb8c4853f70b3b3b58552895c879b2473de80521343f2d3481913f79a60729a57069ce15bb71c31fea2e7f7b0d35d14d60dd9d4644421aa00fc9d10490ec75d197cd93dc12fe7fdf59d0f3bc04a1c06751920699e7d3ea585864e1be847b38e94242d0c48913345020c98727ebe4b17591e35634800e4a887fa18abc76a138923ac4697ff7df64fe18f64f323dcd39c5b121991d34fdf417a2203efc6c641c5058a016064a1d53a54c4237514f92ba2aec041f4f0d50b318eb6344845feca1d992ce125866a76fde397a131588b8d14b225ec12d553cb37685f4bc98c6dfbdbc86e12d606ed2a1b05757966f7265739d0ca236eb6878966c8b25fd2e5031e0d96e77c551fc08033738acc75e79635cfb186e0ad605c053c5c458bde912dedf8bcac053204fcfe7e5fae6dce2a2b1f3cfba6d2eaa34622f347c6f9eb2e04f2800ece1d021bf47372d039fa544bbf4e97b34e7fa194a02644163bfade948e60d384983032abd14ce6bf44f07fee1df027fb3c1b5ac7aa5ae648414e82ac5cd0af61f908c35a02584c3f7a3c51fc58b748e8394fad39329a1f081227e8bb25b903f3c49f54cb5602aee41c96f6ef9ab8f17061e8714acf1cf30bb48fadad69fd1436d1354c9c11b0534877eb8fbff68167b065fd208cc5bf733526b6743f3b0593e164b2bf37a8b3b83bf82c8997d69f8a776db81c8a467447bd1993cecef35f0c373ef206225b04b60dd0e5b97a1d916d34ce672a333f23ee818eb9b2d8876d92fdbb314bdf228bd9b264ef2c35efc6e943ffed88a7c30264be76887ea715fec7eb88fa6a4cb8f322430eec091628df8bdaa3bb068efb60382671fb5cdf11f452a67615390b06d20421960ba9a581bc9c590594cd5ea27386099115de5c9a2d5050c925253b53956b2249906e02b89425763a7e7bc92976f807277ed858513460b95d4747b9b000d22c67b1e1ff6a6ae22ae7f16548e424202fe88250ceed5c3b9a20b30a3ab840f5ce90f726d3aaf8a72cbb6c11a57bed70de2e57c6d3467d0cfa6bd90acfe9e601bc69805107c37080533a34ee5fdb865a7b972bfcb37dc51b693be4279ad8767308af602ea224b0d8f83ebb34cf08089712b5e4c5808b745833ee769ef857fa1a920cd647c475be55503b7b7389add6d86f7945181e17a1e0d6806e0a9a94546b3175dcd9e56d79421e06062f46541ac1320df8260df3b8df19bfef71dfa67527d6c7e9547dff710a379edb79470f06efb5f4b1efc79c8a3df3feb1a7d2651af6e97f2050362033eb05d89baf7fc335b8c10059f613d9647b525112d48857259d6a8a9f92b19e088967928aa75f2a21800bf1dd66492d79ff7746c13dc560f4fc376eaf9962a8607300c24407199ee82e581c4968732e09dcfd0fc0bd884884a6bbbf148921e853a05d6c8661c7db9b94a9b18ea15137986e0b085b6be0e74f7c7a0949df07e4e37bf3b868e12112c34a596bd57e644d4b45c3e25bbfda14d0f4c92be7cacab6cc77ee898aafd09dcdd90e0ae5f179d940847a906b6fdd0f305197bda933f0a4c5843c500cb5af8c45bbb36127827e25a381e287cca05355cd2f972408ad63780223226450a8846fc57925060fcce443498e81bf220db01788123d98f731f61a7d08dcb9ec14693cfa7ee5a7f72d54ad37800546ee3df210b9968e57092b1149c9e9b880840ea21c22f093de7ce26e0659688a5601615c10bdd88b543525f25ac540b30cd5d0a92a3530152923e1f525a4f9b1b80892433d8e0ba98a690916e18a86b1da8c572b0c648ec4d354f1d588daf030025c9357c58c26bf0df984db908cb7d00a6782bde7d6ab69d48da9bec0f0f6df511263f658b415f14754d6c40aef87eda846912bfa167d5307637eb43ed2f2b38c1d3f7d41f05bc676d3cbd5a30d8bc4fd1885c32b74fcffcbf87f911e21d272d9765e946f76dac7019955292158fe98ce4d43bfa55675d3e7f1545b44c8df07f8f4a71778e24f6f95c010b5c87365f2a6cc3cd4e00f339099bf580b116c8e5cee73bcc3d06c792b3c209a2a0536cabb46f1c4d27281db66cbe167cc102d589a1ff035138c79d2a253efd0839ae06cd379c9ae403a9cc9d5c5226fbb342b0cf59b2b6b0a9d9a2b8252340a2558631c76d69885dc5279740666aabd4d610badb06068cf272dd7b1acefa1131cc8d4acaba7ac86bb7af586b5964ea6c53b7242e97c0950fe4f69e6f87a24c52914bddd5f74067dbd5e192c9442b2998d37ed7e94d2c14dd5740e43dc70868c3494585c85facac83408be73cad48e6153db9d497783b83ddf45f377dced658b310a924703a87ca7b1ea6bd8094fa7dcdb48d03b3fed6a35abf41b92e1c767ce78e8f754a38f971a0119a8a2cfd2655c8e6fe389abcbe26ae30a4949e24d053b6bbe98b372273ac8e2a8cb2ab81c1fdb23ac712528bafa7bf946ee23ea759886d94e038256bf72991b6974fdbbf9da35425caa50942ddd8f7573748963f02d44f9fedda8358ecc95f5532bfc14da9f99aa4626b20b3f4825e147096560939ace02ea638aed7d8a249041fba315f86f0d93f691a1c840e08d03501d8f83ef0226a9b51cc4a31caba99ab3d828201816882db13682d77c399d79407f42b4a8b7aaa57cd1cf64365a44056a4d14bae79fa70fcc0c5d178d9ef6971fb59e2f3e8877c259abdd84d14fce2ae8539147bbb6e045f0467fe25f3e521756e71eeb4eef1683a5768ddf328dac4671357a6eadefa044f63edffd50f1f1fe35e16dff94a3c49b4c78368af77d6959913c22284de7e38bfff4ba52920d83db7a9f105e551412a269d15687ed989d9ec09d68ce5420fc06b11dc56ca5b9e33f856cf3daca312b0da94dd15a242d0fe6ccd9269da11088d1520ff44313fd133c527b9d99951d41d8093776250df41c1c59004eed24571fe98520a7469490c54399b62832b377fb0f68092d8a919c09a245a31c9043bcd4cb3b0e65153637572743dc30f42ac1f2958a782923fae3238ae3b1ef2e5a2401629a60e444f0dcae043e6ffa66848cd29c4356469e3ab69f53493e25462faf0a5d910a5abd4ce65d8af85de16f7883fc95db84bcae8cf4d6ed41d234ef46e2cc6aae79d3b583536efb6aa82891b4547d9fde82a38680021e145fcb203f62831cb179934c74d997ba904a6b25f73be6014f81a9de5829c8445dea0f8d0c6bbbbc720b0f75b71186c49e44fbfbaab3b394adc5efc0ef3d31d5f2fd454348bd8383c6268f08afbf28f16c0e4641ecbb9cd9e83791c60567e3bf575ab0fd151741bc7bcec5e20bbb59a225ec9ca45ed6c9be78bb6c3b93dc41d8f82366296513df89de387c618a8e6ab396d85d6b73c8aaa4816e02d427bdc1caac65452289b50495d5f9464d82c37b60f1a9a758ceef471f5ad8ef6cedcfe63762219c5ee74f70e4c1d2079600eeb1a0f8d4d372fc5cf69ee237dc6d25fa063bc2960492bd057d465cf0bd5c8048ea1d10768369acee8508f3d05c01d490104508de59a4337e204e7c3d77746616fd766545ae16bac007347103fbaa2ea4a1e7deb7e991c4ab5b4e1b39e37481b661a3edb708a091459113428e2c2ad8be57db835c7a38e17f7348a01f9b03387fe3ad53411720a6951dbbce4cc777725f641a6d86ba1275039a1b82ba322f3008918fbeb73b864b35eb7be48676ed1c0876213d5b69ab65e2421761d9c6f6978ce38b040c7ae04470c222bb5defd272104ca09cfb994b2cea0ec2702dba9465059b3e55b200b0b052c95dfc5e635a39c1a8a44867f38832ce47c54a13b326d605e1c294b8f320b3a0f6efc181d5626a760fd221d15b8aa629c1cc9b3433264a8b21b7768130d9dfe4d74f93adb71ad2fedd1f872f7ed0cc5db4b47d581c2fb54470d98f68d94b145f8b54392dbb59af9168e7a83fb7d3906d8b7168ddc517661fe26325f17e83696dbfd7a6f06c3349fe9e42375455b1c17728a9a3a5378dbeacb4db8821101c96db718071426983489438db02853a42a7c032563fdffc6e213320787304b72197b792c5b01637cfb86fd40c1e8f8d2424fbfdf566719d25fd315aae998f338809e72cb552ebe31c38a5b2ec0b2520824eca758e947464d471b7b69ed9e8933e21553a7338a65ece1099742ac10462cd0d52261dd9af1c4318bf8f2ad8c0fc89b035700adbde23c3c02c29909de1438d7a5d171fca69ced0a4e6402cb5617145a97cf780e84aa55938d65342a7a82f0268ead2efcbab6de247a17e482692a3713d7da211dde7ad31a7fce692e93bca286c7e33b8b178f37dd8c25921e383f92ccaa232d1f8e3c60855526bb8f871f583d58ffaa9bcc86179151e2686195fd84c6b591c9fb6c190465448e3241826584385ec1e95821db3b4989886c1e948446afe177dce20de1457f5324ad0dd041433130a7b5cb462384555561332bdd6baf5f7155fdf7b37a74266b8c19aca2823b30e908c825ef20d335701d2ebe8a815c142f759fd278cf218231357f179a618924851dcf9a5db6239410e1154f1e4dc4af3d0684f2c8aa178e70c7b62b18bf279f231c46d91f0afb7e891f023c86ddca97cf5e620e0cc2c7856ec745b03fc9498882bdfa7763849ccbdc8594b0c7b9993ea9ebc3c20d66b7c4299337fd8b6aa51f0c0c334807dec686685ed6a3b77877747be6ec6575168237868d02974ca1fd58a4adf7de2df91a20ee06663d14c83822f529f0d0f2908fb96412fa1f4486568fd39b5f4e589e46f168ba8844ade03d1813d3028eaf3f62ab3d1442ed39a2f674f8ce3a9c2664a75dc3c48c04b40a0ebaae5a92d087e7ae69d55d7ca7e881b92addf62e4ab0f0b5481d49fdd29601a77e40de1b2c73ffe047a6239a50de9152027a77af2b194dd4af7f567fba3820320485111c2bb0f0fd825754eb415879fb8e091a8eac8df8def8a318e2a00a895b963cbdc4bce7989e2706d79d9a56e6836d80718f7a801541237af185a2960188d08ddec740c52922dbeb7fb68a5fb95129c7a5e4ee91c7afc16acd71ccd69b9ba9eb2197c51db73f09d1b5dfab31d64712cd88b74209aabc159de0b8be9ee1c1e7903f9937b18e8208dcd4a12c5378a7a1c0013ea290d3e7adf6f5fdc48c6cba0e1b0c30fc530429db8a21c3355fe21d389e89dfadec3cea3f1579d4e8cb2e927fffd201557588ab38460f475ae0f1f9b6168e4947e80d5db9c759e9297c3fc4cf8af7bae68cf35ad399fcbbf83e2c389e42b578828e49f09d54fff78b8d04e14ca320e65376ad51ed5f44847eac4255b564df29938514fab2ef44a3f6b6928ddf96e3860a066eec724dd48d28b58281b0b1dab51883aeba4e2a614b512e45485cb0333dcbe118782d4baba6dba957251c1756e5e8718189242fa1e5ce87d8485a20160651defbc3de174a64ea93bca5caceb37b029f6ed29e9f0e35d284506ae728ab006cf0da419de17753223420f3f002f12b0369cb0133b2be8350400d5ed9d2bbd20ff02b0d0d268beee6d94d35ae0f514785634cd0ab18ec77dd0db7ab13879ba4a2e3bef94e01e2781474fcd38396b081678b93737a22b495bd3cb41d9da89b93de2860709058768d1245b70d7e65db10cabc59efc117ba2733588215cdab406e846a477b9dbf96e8e5afb80f1b0d58b037bdebe87cc7c72bacda52cf2a4c806a21d055873c257104dc149180c1d96abe5cdfaf8c4aa29ace4a71b3113aa11af30baef0613139fa1a1cc53b26453e6f3478f304f192588917f754d9e6c6e665a9b5d10c73c5782189573ec2de8cb954a1f2a39c212e04c3df690a552c378aaa7a55c9105a73f978637d16478bd67fb35d20dc2a09e2c9b0d66aa7c36a6a4a3bd758b927cfbdd52520177aa56aad07666bde2070f29266976b5f17b5c276d9ffa1e07b0a76457e3b82edd844e2f9e3a8797006555a94f731ccf07f6e4e9ec93856dc5d8b465cf90315187fd1970b06e5d17473d897206107e4440f14d2ce3cbac7e5299949887f2c15c331cae4173993284d438830a8c49d6740b5242ab2596780f7d0744872aa6297a4edd736d2c4519922cffd5b73fc574f1067cefa7cb5be9acc010320468311ae98d7dd2b21db9ff7241cf1995da102588a1f6e01dfc82c32a1b70dff4498c6a4516e4d8ff23352ff477653408dd70002e63a38c1e3d51a99694ad13884bf0720b61405599b2dbbc380948b3c4c27dde54fcc21f41287611094f5f2c034d5cadce9b65043609ead1567ade1949524af927be183b66df1453853d7fd0dd04312056228b46d0c7171ed25179cd4c0ce6b0ff275348454538a21d2bf8f91f2a8998b19d7008ebc3d8c3d748134e3d90281bc4460c7721e595bcf1d13b91c53837f2616a2070b6c3f21fcb0f6512676ec8a76a7c037e69dd57320f6057673c119b99c60a8ff922fd71814fcf872b98a0676807d7da5f5663d62704c444fc1c4e083d579104e0979359cb1f417f0f36368b97a9a734890918edc0cca4ef105f1387bffef11df7f605f5e416a973ac3854fe89c2aeb527e7452cc04d67141ad91ec13f6b564ce7368757e781642d1dce93f77f9635b08c175ed081346a75bb184defefd8dde045d79ec4ef3ac0f9770bf93878a1936f9e129faccdf4e35c71bbe14f8e79b0c629d233eac2d6e6d40f864eee22d598cee6b8bda20a89500d2373b792e966f84fd9157f10919c8e7852ac5bbfe1a1493f179d0ccaef223c2b1db2e201d1b42cbb13b5fd6a8e5cb1326c49b748690c0ea3ff51d159ad675cd26d3e97d404a5b05ee96b7a6938fff064069d1b715e93575adbbb7b830d58f3ee87bdfdd8e330b2c158574e0624a4f7f7391d35ff4dec2f6777a0923cd2f4ca7c6f7ac41487d25e73050a6abc13daf868ed0dcdae64346fe3ebb0ed100a82bb0d9489f234a91d223bb46a3911070d5476424a8d0cc87bdc711239a94a03b3d83f3c8b9e92b7c2b705dc8033fcf1b87e449b8905f32487df3a2db93bd6b98d6296be7b27d4b01ad1a9cbd32495f0bb40a8e0018b1e1b2c8e18ed1a3c3c89a5c8f5afc9e4bcc31c5b823e518da76c77f5b08ea9d149a698ad770fa49039ff35e367f97bbf5b43915ace1b514b0c329022dd8c20a65ae45c12e546853c0770a4b7960ced09b17c08c9ff2a1dcd13b6fa0e839362f48bf25cb725d4e2f3eb955325d8add6e8c665b0420be88f57a4e9f7c0f00253b5148e8756de50d1bf1db8b553016a249ca0c271a297bb3cc906e888c37ddbbfcbc46497569a3d956a2c70c7bce3eb4dec0a357d8a0c29bab89ef5c07d9dfbfdb843c594ad54cd2aa24f8215111fe4fb3c4cd6750853d01009cba5fa4f96eb120a1d6307eb6f3c7c1f47691d71f2bd0bca73254bfb93945b4cec23eb9bff50e66bc1b5f356517c49817f28ad39e4d9018fd27a1988ee3c97a350ac229bd658b456ede2908e5becfcbd3b0985e342ffa9a775406fcbd385da527156191bb4d58b11dec60273cf2935d144cffe06658e93b171c0072c58ce42ad11c1228405598f978073e723fa4d31c98cff74cb48241c3651f722650778cf5060d4d9d06be601f7a6d4807f249a4743cc84149415ad7f7f2758a7aff1c085f3335dcf6b834444539221acbfff5c4f91dfc4730b6ca8f2b4cc210adb90a66e2851ec54791c16f3b2ded014c2dad6fbc517ac7a3c10d70df4c923664a7d52da72e17a00f23df91f4e0d38556f9985b347f0522cdf0d1acab7f91c8f16329644d4df7a38ffff2cda6a2f67e00c876068b2a9456784705238c78f9cb50e82895c0b8aa8ff01e990a53daecbcd2620c3065f5d9e102eaf6b1b1ddea9e8b6ab745677feb77ff683718e7893fb98f6ea0e84125c9227f19686acceaa1515ec2522e2873db2b83abbb77565970aeccf9879e28213436aa390d2e407b67f9695d7678973f42928330be713d01812d493a4ec08fcb7148ff2c2f234b59fa45acc0371b77d7c5bd348b6bd2d9c82951a925562ec2ad202dc9b0f8bd0cf2bffbfcd979ac63228d3dca118ed8715d227c5d908f733f47264c3d5fb67452605314d610cd4828ba34fb32898e6e36fb04f66b8671319cd3afb068aa39a08c186a066f9286a8c20caee7a1aca5dc90d700deaa84c1784b2d8f6e72a843e68161839e6dca2e727f96eae9d4c57419d9f20cf7a2ad2d4f1c498327b8a29cdb405f080b6f69da3687eace740d6fe6b735cbeadf4c426f1d9c2d3649d9907cbeed8bbf17c63e1e1c41b5f2d8ec84bb4b59f737348d18cdc4804ee828a62f31d4afa80e9a5eed60f4a2d48495ad14721f0d00dda6b8257dea3dcfd873bed2026400113db2c9b00222a3e0693463c947710f529d1ab0948621b6fdbe222c25303760838adeb22f096ab74bdb6d307fa3398f3db965123ffa9c86525324f976e7427cd5dea02cb12ff5c5b060b98865f5fdbf585ee66cd7e620e31bb0fcea8ebf3b100dc88520e123dbe59b3ea52714f5e5832334a85bac1a31cb4c8980528e939693ee6d9933147fbd6546c722bc4816482862568091d628c54174c5289aec7ff31e80ace908df3d1ddc75a6fc1f513c8d71d7866e95483e40a92dc70e712e8df69d80032325b820e8615970422fd872d39988bb7ddc56be5c057e2abf3abb480f19b9d191a0ff4a345e0987bad9625221275b087a66321400d024fc0edc57a7b9f5b8b67bbd0c83f9da9411df4ed2b0fd3ef1f5eb18898c1ec28d36a9c33756763c8af2ccafe4f908d31faa302f038fbfe5bc88335ca884bab7060ae369b7c7c82eb763401b78f1e942cf1198431b3fdd3e374f786d4058c3272274b29784c8dbbe17e23900567d3081c71b53945e840849446f48b9656f0a95526f3f2539f2eeed307e1bde800f14b1b73e32b4e403cef1988dbc4b8db9691c90e356e2d1ad9612f32a61589b3137bde2d3552b34bee1dea6d025bae73b507431da460d2cfd15cdae13758e091c15bcaf6c158aa446f860deab97e33bb7254dff4281b4fe95f9d7fbfa1edc48bc3c4f2fe7ed30cd236934b46fb3ca681104857bbaee2ab4a61c1be13e79825e492819697a6c1dd3788bb543f3426b6edbccf15234f070938d0f455cd1787b7ec68507644c2b3bcbe5556141b8615c3b010d2a8b61f47741e8f7ca2ceb0b68a3974ff59a7da88db855a7edbd7f47653d5ce48fbe44d722899fb656cd78cb5098274d26e8404863e74b9a80c6cc2bf77b8e42e7ce5b10df855a4d2374aa4f3068958b6a593747769eb1cb8fe5ae1ad3a03e30de5d37b7cbcb330425774f0ea7a08f806394304c396aea704010f58c305d8c8d4cf91def952458618c9db90303ed87d40250041795daaeb03aff183fcb9b3ef9d4b22f081046521789ba02db19e9bff751db9674a2a0c51463a92cf821e4e9c58476dc2a86503a64af90ad4dade056f32680b863c863d682ef9c90d7b0f7894df30e7104fac9399ffcf4e5ec0c123446bcc4821f2ce2d2e0ef8a20ee1380ba219fb12c4c8eb2e037b12f0bf0f9f5bdfb43082af9d4679497bf0aef3f6d678b9bbc0aea7b65f1dc4e133e884664fc8be63c6781198940017afdda8de4cc5a723d7e4221123eea3311a2493a27229f0e834e95364f705641ad5383fd5cbbbff45ee6f8b3b35c6d3f54a3dc0222121c3a4669997be0a5e5b43466109019d8494345cf38e4d84868ddb631825d0a4264c80a1734bd7c44e488e8103dfd9726c9304fcf6b9743c56a193958714c97ac296e957754003cb627e30e8f27c9b05200f9e95ea09730bd6509c3c8f6a091a7e1c5f1a78681080badec369781dbf16d920b9bcf73812dd289c1877bf47ccf8f30e7faa7d5a9caba6bda258cb912d5523f13e308e96a05d6a73d11a8a1ac71a20743ba8efc609ae6d979c03d5f519a9fff8f83f6ba7f5c1eb9ccd7bbf496ac7ae484d22a707f84b8621c09afadebedf3d1af69cdce22cad1c15e4cd3dfef7521f1baffb49ef4ba96d8494efd22973b85aa8dbc175a5fecb68c7e99acebc151c741dcb1e8ebc3b93d28815d53d2c50f97fbabea3056ba73bbeca1317f88eaa0eaaaccbb490c6a96c9fb52ad9dc1e9f54816b60966074c3e49ef9e294290d19b84500efc81d7970557616d7681f137a3d598afb85b8a2f06f4b41899c5291713b147ae039822103ba2574a3d1ca3c582a48d29ebc37b1e3323a601d27b584df46f466c360102e6ec1e29a8e336c5076d6b7e503e4571d807c32cc6bbe8d9995c354eead7642622eb3c6d797b00fe665b2338a7fefefa8a7c42700f5d5229c64df3981fc370cb5858b411ffac952ce74ebf0813d83910e249a94c910a04283ee19369ed6e3a8c081dbcc7664d79d60a5ec3259bb1b57537459ee9e79b3b822f1a69caf64adb6d6daae1e3ae9ff7e169705606f9365e1cb4de1bb4d8d4f76e04a4e29de48ee8b51276e3946f3ceb02e6e1ed4d832dbe6ac4f35cf3d445ecce9099c7d7e59a3af363224c5734277b610b6458f543d29109c4fa7aa1ece0511755785d4913776b1b6a1b758638330edcbd22e7a1fbeec9b31f7f8bd9af691b658ab16bb2d2b9230411150057d0a908a4c51e7e55e7252c4955da3a14a9e2beb029e505d0e12ce74030842c234ab37fcf170ee49f7ccae86ff22c818d5fbb972c7679e6885d0842989194b77666a087da3917d4c74d02010419b9a1c7bc02ce7e0081ef2fb6ba4e9d4d49eadc636be2dac456d12613d6449e8399a3ab260cf0808a6ae9ad817162281d4f0eb4ad46bedc3be6357c361c19b2367b941e42fef96d55e7e5e724efe6bc919440305adbac1e65b9f0d6c4c0206c06a31e4a21839657499ddb3687359033990ae662efe8601ad228aba1a332df706082845f8a537e7014d6a323fcdc25f5ca24c538a2d953e73646ced559520b54629a74b60e210d2b3df1ce4075da09065ee2641f8bf2af8fc58d9c46bf02b1d268cb809ce7672b836ed92fcd73c074215ebd28fe01146b6fc280d65f83a6c6ad0679c2b1d9efcca8d1026bb7e33e7dc1fc86a3297c923753fdce50b897cc129b0757d53bf51de01c81773f593763140f382c15d79308225b92aa5616885dfeddaff892336c62a210f75ef059fcb5b7480f062a393b9344ea28c7ceafbd1cc19d97ae08b8dc5fa3e4228876e3db082c78bc4f7f4b2a3dabb0ddd229aca081dd1b6c76e8eb83e872ba20103ee6e4652378dcfee55068755861abdf75913b17ac5ebb5ec110651da504a973973e7a04df0a2eb892172471f5404a1f47490ce0dd90b15d78050273235faf7d41b666ccdd3c15db4af302785c107e9e593cac63f4e1d8ec237ae757782d442c2b3384064d80325703255f97f293b0867239d6279ebbad69840f0e226e9946931b5aa07a9a154fdec5a6b5c0259826ffcab5504f9e39813f29f11c2bbe6b3512b0c8793131b4e170dbbe47c6f8631ce73b09ce2ef6604c35a33598e7d1a3c7fa131e720fe85a15a93b266855f327af63875f1d3fabad96df29d5dfa7d24853f8793561d1145a85ae13c6f7a20691f96cbea15c34b365cdce875619d3a50436146b6cca5404d3e8bfe7ebb0bed33de5d8ca220196875a32b3450921ad7f74339e44f53f765cb6c85b9a2e71a5f288b784d465a85d63b5b5a5f4d82fbbccb7c445807a57cd132dfff4bd059e7cf088264e9562af4584d66ce4eafe789fa857a41b472be8b9000ca4abe05e2912afb661f3cbcb49360ae845bd1e4c3520d33a78d640b93f5588d28335a8eed48f9044a456b06e558c04faafa8039cfaaa52f1eea46a18ae249a2ff5aaea078785d35339e3d2e2fbde5c6c92e9dbae33cba112540d49cafdea95d7399429dad32eb24887d993543dd6192a504407e212bb5d77c81ba2a5fb9979d333bd59291d317b5896ebd1e0b640fc882b37962a68030bc6ddf3ee23cf8f6e947e12f06037912c91e407ad753dabcb10fc6210828941c3866e58f30af7cd28f2020d44af9af5dfb0936c82bdfe996249ef3bfa00ed2db2853a0baa7c5665931ca8812833ec3a197110dfd80b02592673ced567d9c37f5825f2e049a03dca3b4366554e52362be33e88838d1ee975b7bbf20e9261c73ffbd808f389696ab763e8a0b4ac7e5ee8c5cd9d8032442952e37aaaf494da2c73a85b2a7e7d398ebe937a19f7ea752870850bc0722d205fd8317203abe2192db4e214952db7f728aa690897829ec37df39b25174cf6973dd8596d0c6ddfcec5184f6addb0b651a1a4aa06acf1e582eb12fc94dc559384f9a77ee04ea6bec0c959d16bc28509e2b03d37b820ce7deffbb05ff474147dbe7430b17d98a794b345c969347950c61b4c727ca7a569fb97b7e6516306d9490a66cd42f68fa12fc8828b3b3d0363ad460a425c2e7a0330d3d7b6d1b8de440283590f6e4eba323448ad6ec4eb24b9d701b4c016ab4cca6fe482d7c1a37dd034a17ab36a8efa51fefb047f2968c2c70c959d1c5f8b6992890bc80d16fd42e2eec1f68b1343ba95746058eab8f00fecc914483443e96d062450bcf5042f1af7bb300ff0c227561210e9b03e4b699a5e31377ebe908101ec78ce195c7a8d872f4bf6fe81031decfa4b26038def2daafd0dc8d6e39a08ed0c29d877b61dc6ee7836c7e366f20f0caa150a3578775724ca5ff73919e94379d46ca075dd4b4c5598d680b977c087f73886f5d6833a49e16a573b8cd0bc5c530ded0d3799832dd3b96adb6ad88bde9f893cdd104a4e803484c05caec8c3ac4a3d607501f968f2f80cfdd81658507375b0ee5f989d7aabf24c1d933058f8539c672759debddb02575bb87fad515e8d626c954cba5fc251d66e7d9ea14e771fa1a1add4572c1f956b00272e423e46c7f20af9034d91bcc026d793429af90c62fd74c26a70306c0794dff6d812a1031458682dc26035d4e9dbcae6890cbf95cdfa64a04b55f52d3b4f3150f999c169b05e3bf2f57d65f28544cb93e91047d87782250e54dfcb064888ef32324f9d86781247e6309ccaa8b2ebd377933f7d0817f7f5816de02d13ddea7847fef88d36f5c9d6124a43de989d57bfc75d95cfe77f953071ade3d73c8bc4a843b7f6132bb2d692a1f57672d9b2399266dbe83456ce449516728fff538f4a2dfe1bde269268006868e09a7826ecaf583e0a249bbf426a27a03d47b7067c61724507fcdfb78140dd024116ff153d25057aa4d98e9f151e2153a18d5bae383308a3933115d9e44f8976c98e8e1192b01c44eb48749d89d4e6b1c8968827ca24d8fea22b05b2cf4d6888ce4d5876419611679490814363ec49213156cb501d26e398c9d933390965e8a06513dbbc065f284f8b72312cac431b33e80354a867301e9f40a9170c3a18d3ac892d7534c42bb519b3c106b3ecf0186488cfabbba90398a6113381ee76dc36a4d0d8ef14405e6fed6f296be37f20bca63bec1079e20afd7e617d59fae15df33ffe6d651ddfbcb38839695bd0b5aedfdf94f0b98cc568318dbfe92d4275a86693ff948b6110175922ff82f8b473b515d7cb34d14d4bb0e2072842","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
