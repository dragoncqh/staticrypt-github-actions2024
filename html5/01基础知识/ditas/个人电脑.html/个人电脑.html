<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eab2955ec404f52940a4433ce3557ba5ddab2c02185786c70b20c69172ba09f16bd9ee9439c177e0ed00fcababf82abfe84d8464de6aae9d51e14fa89434107fef3f2301623bc25001a7df11a2268d897eb25059fdb725b2b4bc0caa38739f0c2b73fd3dd8e0d6fefa32938256ef54bf4f05e47aa90c29490490838d37cd1afc88dea9881d13df2f3fb9f4e51979f86e4694b0357efb8785c992b4673c16782479087cf441200e903e6b78e009a9e1604296538982b9d94d2b52ff63c1eae86a1e05e3a72226f6609b7f0228947af5927993383425d9e940b575c14466c6cb0f9b03711a6939f52bfb5167fe3a2cd6802e57bce4624e18673a89de4c346c0d9999e8a475b55ca241a352c75b4991d3433702ab6afdb98385ca0f052c5aff8f5b3a542f07067202159fca1a5873b1c4708e240be1dff93709aa41461202e54809d03b80c15da577a59cb546fcceb1ca75bbd09c22e5e10a7c142299b79575900e673f47098b6e9471376f62230039fe4d34c1958700c97f932f71ee88fabe80c78cc4c2bb1b3012d340e3e7da0990b3397e8e41e8e78005e497744319c46f0ba7063fdca4354c99192188fd4ef6b84189d842cd1ccecb384d5dfb1d852bab7085d9da13e151206e4e758d747e503eba48fec517b7b1276210f50653c39ffdd383942a2485c26f2a7f35e64b6f6ce66068bc623abdb7b77dd76b3ed705645a7453f172053e053c9dbc64f886bef5ba16752888a6d387de8875252114ea6cd510a70c12256dad48810aae664cc3407dde45debe76fa6a498ee46214b6a087b5cc08877f8a110f48bb557cdf3ecf7c5ed86d6621f483708c23caf816518ba93a0fa1bd1035b1b51da8ab91a1d63313f8c403f1f6229a091f4d01e86cb0202183e9c0ba776fd85fbd3111f26fc60894636a9dd727d856e47a81dc48b47ec4d7b7ac57daf4281b925ca47ef510832cf10741d0d793dae4c777b1fcda4fc3c8319b026930cb22d4a33f77fb684fc9dd2254a56022195f497970bd82432072e239699049e17474709c6fe88870e0e6517acbf07309cb3132e8b30333a0bda4293acbb3ae0bcf4fbbe5510ac512b9fa02590edb075f7f36edbcd3a1f453e4fe74cc9b9ec5dd67134754198edca21d9de2199171feb4e823bf21322fc2312b353797e85663bb5974b1dfc178e75ad01b6bc258fd55c137f29f7e44cadf39ebb6cff7bda8ed2749be24ba3fa914a89cdcedecda1fc6fc26ef61ccc105be89d979b29914508403b5aa069208f37a3b694b7aba4e07534562639a21521327c613df3038d03243ddea661e680e1c5c35e0e49b48af8ef769d64770c464b4dc345a1b27b3c424c30ca17b26d236178e6758d91bf924990dd004dbc08cec37eeb3cc954b4f98538640db47e3c1f81050fe92d94730fa13a87ee213789e06980e6282e6b29ecbb2875a456e06810e08fd09ce074b6f4d85b719469013fe95e79062743831f914bdb749172e258afe8d07466eb83db8df92119b37ad71e305e1ddf46a1a6b45889dbf813b562c75126b6603870e42a7e1874d2c18b30ef62168773a108c8117212e73d677a06ed2e16ee4b3db6234fcfb10305d8ef305996daef0f2d291704455110a99f03cd595d0370ae5008feada1897eb505e1ce9b4e2937a2a449c42d7556a916aca3c07d3f4deac1cdc2ddc44485ae905fefc871e41285b8b9aa08bc55bd31ddc62052eae718d4369fafdeab0e28c2dbd9c2755a815a8b6e1d6b39be3f3b67f26d55d936983f677ca3aaf62e9102dd69ac2705a17ebb8f94ee24ad610f6001358c22571f2d47debf6a4da90c1a89b645ec412180429320679103cef304f66fd9f2b7a65618ec53691033a53702072d49dc9d5eb9917e7688f9904ff7f57ce97d9959194a89ecd7c049658743e15049a6175cf6a766bb33434be238848a2d7219e72b5ac27f3044b4a124b94bafc45091ea935b115aa13df99d42cd415e3ace03c0dde33f2cb453d09c3b07c61ba01194b3bfe9ab4df4b5880e88c298d265646c29341678d0e9556ffd5d34112a7629da3fcd7aea864515aa990cb641b70c9b5ce2f3b586c13e4755a6fc4d39576d4d7cd98b64ba4be45005b341efb269ce249a13a3b9ac3d0e2ed85f04db54968465a6ed11da90ed1b884deb05523a0ed49fdb0a1834885624f6fa394968798b3eb29a2a07841b28055168bf3bdec2425ae01f5964d5eccfc4611d2e01b4eecf0d5a7eb37192c0e6fd5c31365ee4129f3053138d157fb8a67c1368aaa1adae069099b621c4af12c9aa782a6b87ad286b6d42e8483f5f42ff7a2934de7d45a6fc9011ac2565b635cee37ad1e0dd08966823afc7af7ef555f0b37c510279b808cbb7cb4921354babf3026a73be62cfa5f7a5e82c7490d52f455ef0aef2c40956a1f708ddfadf43f1ec518ab7be916d9cdd22fd40e2da539722b6b350a43d29cdbe6c36330c8ac9e2fbe10dbf3453896cf039a5f850d6cb49a9d3c3dea0faf717d912d01cd172005703ad3cb006d9aec9dc83aa47e27800d6b24f12799a3dbef2d9dc8eb83af72208502577f0b93162250022b8211f12ee22a361fef6ce39bc376e38199d2f0d690ae517bb31ba3417ce847bd181be60a497a861df22c6dcf6a600da99c3101cf4122502b075b8e0bdb934ec0aa5eb5b86aa9e1163692c4525a4791f2224e4a510a40bbd48c425751ee5cd550acce172306ce250c7f39bc91ef1cd1cc80fab721dc134e84abf206a0510b8e08b0fee20bdda63f215a8cf337cdc74d8c894cfdd48eb4ccd2354c601015e6e797da079c777a97003904431940e896cd7581df0344fb2b161ecc031f4778291dd4eb59b5eb5b67a92c6f3fb622c33b5e24380c0844bfc5afee6b000d938af8f3093c1b4de062936550a6928a8e96742bfe241dcb10f58ea3c0d8139fa249ed44de46334bb7727a981db1023c0a7566baa2d1092ac67857e94ffbcf20393a3663c24ddfc03974fa61ea0bc32f3e144e3d972e4dd2ad2177c0558ce19692a329c20acf46ee24f4bb2cb5f57dfcb383e5e3704a45df58df6b0b24c621feb2de1b4bd0341a1de49cea179f0c606c2ac6d14450b10a16b35538ab6ef3169e634ca5599a8e87e68fec648e51576cb9510805d5b9828aa2c99dc907bd39714eaab80909d284c288eb329bdb9896be45f4bc2517feb459be20431a5060062364d08f7c91b8bf659ddae3b4528c82e689702ca5b8ba74dcfc99a293b20c2e4450b84a70a0d2ed35f3d843d519e706e80751e34e25ef21d2201426a5d9bbeb886f2a98ced74b58df9bf0d258ce9f06890d630a5c5d961592f008a7c98ce6afa803709f5cc7c54cb667dbc8907c27514a368a4db7e4a2d860fe493a4b9d5938143da8e83e1c397b136a41dd8e01c449e3d4ca9f9a0b03c9bd90fc08b8d303bda0f2939a210f4b0c2ef85f54ee3b25b352e8fc3fccf686231096bf3ac90f7d5479992ca2c99fbde869291e6f73ca7c3d01cfed823ae9962bd3a2c3567dc43bf68caf151b3f03ce5b1b9cab4ce064c2c5993c433c0fc04ef32e74b59c6f243a74e4d8c356f6a7fff3c535de7b3619a04494eda32181bc9def0fb40a9e09d3efa414f05af60a6e942a6083b8aad7034353d4e69028d07f78e841b01b9f7b97a645b5fc99b5708062537c769b8d93cd0aea67a9993481ad191d09fdb893a8be8c739bd5266f4ec247802a79355ef07aaf16010821d75ce96b8e52edd2e591398bb93d0f9a2d44769bae1006b35af99e5c22d9d53fb96f1859bf1a7068319e0c59691bcfefe0aa002b8108ec61143e0bbade934d917c38d23033a335e0b8ab1923761652298be6dde80b42d2b7247afe695f81c3aa392b7b4999f093f7ee4c5714a77e0e48221d6698b3c58b6417e26898c65846c62af2afbcb473cb2251e147c387b32dc097a98da6d68087ae2c716d2aaba627c103e8dc265d18386a241a9f09026b5fbae63145d84e0235f843edc3db5987a24b24a618a0c87a0352424ad5d61219517924212b67e214a3039d333e16030a5d40cd255f0e14b4c520b255125a277832b245fdbefe83bebe04df4e513aec494ff5ba58632012b7911100b222570ab6bc1ace81492a0b1aabde54d17aa792b45b25577fb9f28b16782a15bde9130b3cdf9164cc916491798d2ee01999fb1e25dbb0f7d51e921ded7987f314fe6ab7a051260fbb892146e5cf529913635270bb24445489b6af2efe4ef9c5a4f209cf9496ed61fb3d219c5d12599561164375f479836613f34ac1d6ac3a39c24566ff2dd31b0be53d6b874800858f048a2103c2bcdcdb2c711d22cdd18dece937b73fcf54000d4b1f76421c9e4c1daeecd9893e1899f085329d9ac8d16a95f661d702986b404e43a10237a6edfb820e0c7946380104923d418d09550a0f215f775966501e258ce5755fa61781b2b3c526c3ecc22509fb83c93069023369d4d3c73c57a4593ce233236f47de85d6c953468221c3e31e8183f62cd9e3890d1904bac255819539fc7b3b854d8f022f57cbc310d673a91e6c89ec930bb157bc99241ff1c2de3cb219d7dc022725620b79c414934e9b1945793db4bf7e8248041743fb60fa855e31673ea391c9f2c4641a7649ab6a2cf62987f5e99db839bc0ddf596f33aaed1b14f57646eaed936ec41c7e7588eaa5b74bd51806b967456dee7d576184c1b73daed2f60342da9772624d752550d1e10610c34913098fddf1309e746d1a3aa765f57d26a8f6e11fb9ee0e6cb163067b4a12b8ca266153f746eb61c0cce9e3e7a5f16c4aa6c9006b7118f2a912cf0d15f93e5fb0c19f9618f2582ebaa8e9a0d540a02925eef8f55ec38f0e479d5231bfee048071d0c9d31accb2fcb396789ec6f3addc437af6c3ca00225258f6edb9db88cc6e0c7d67f31e57113fa41328d66d7094b0c67c48f7c18d06e9860ed8e0368513ce9860ca762ac3120774020f650dda2afb9dc6abb3f9399f795b0736b74f909635e4da6a07ddee8334e35a0632076be8f8f7b6ab669aec9a77354f6790fb9de6a6c6c95580066b31138e4d6d9cefbd1bb7ce6d5b3aea46a2c6bb0c8d057d9ef89fe9cfe77a59094522ed23d3b2f91abfda74d4461dafc07b3266175c7f30d07859fe10f7d9541a27d4d2745a5b7ad9a2ef6520af8c7cc2909f55f8c0489df57cf83b7bd3e4e7c78a0bb3bce480d38ed4bb8e58e99b1bbd4126d15ec15fabea461a97147121145ddca694b61e7beac84b4e0b8e50a92c89fbd6c5fadd45f7a745b804f3da5cb19faf120e2f980de5ba9f547339c7065e5205764fe43593499111df48bd33b17d446a7c638f50c3fbb7004f0f922949c0b0f4f377e0d5bb2bb11e63c5cb10d277cc2a75c2e0b55e889e652ac3c7679716819f56967505323e0fb3be81200f2eea707ab6a6636b52df1969a11d6ec4d0f26adce12be66935fc50bd443cb4ec7850ba2fd4c7776e853220b28d33cfb82a6b161f87a1f2a81ec8a83225042a0bedab324e901d074b404f8ad44e44bab9abb6d19de798a5fbf6f6a9bcf69905530892c158a48cd44e1d42078c81f6d15d15e19761cd10577219e95ce786f08ea24ef8cf266f932b7b351407c73cfd0b953fcf68846cbd4d204baf24ee4422f3c4e465f12df8b471322cbe494f0d6bb369decff3b4f8de171e3be5a4e32c43bdf037023a98e075a4b903306b371e346ccd8b8121f3e032f9d8d15a6e4bf9812663e6db4dccf5603102c80bc1f24d299d99634a18b56f37e8ad3e44cb79e31d176d165344128ab703c0a828afca8f0024879e7fd7cab08e3e284c0352ab46e6006f8dfbc3736c7edcbbb6f130066120907b6cf7c9e30341dbc04562fe1f322f4742526d77b41fc0f80d9a58a80d574e33ba862b6e0740a52927ea3c48fefcddb7f5973c4771d75a13267b58988b911e1e2b3ae5512d873375d1adcabe672d5514cca487b1ef3bbfda83c44fe9cb7321788f17083001b7af2189f41dbaf7a843cded6c2df28b1ae7ea9e2c0ec5887f526fb02b742807bedba632f29b744f47714bec33e17804d1d95f8507d1028c15bce5f6ffb6268f21c9cc9761d166494ca60cd3bde38c2e6b9840035843ce7a6c6483ff589f07c596c1afcc72bb920165cf1afd464e49f7aae614d0194e958fed8b9b3028c903d317c8a821ad56cf9b0959bbd185c14a6db60b63ee2aafa4d67e84f675204c3e5688d1751627c23f59e040c1ff55fd970eb5a5ef7d887f752774d2a6c8d96f648e6d7c788b7241e7d57fbde037317a0139e61c7e6b60fb00482b659c34c6c773008992f8c75d02bb5ebb9ae2cdb2d47a1db39e793b60d9b5ffc209c46c1f00eec9d09a467b39ef12a1fdd41f505e913f80ecc7456ef7a4f365b1027563ec7614c0173ec09f500936cff75cd551dea8610cdfc97a7b4b5f5690c22beeef934fb2b63c311835b1c6b9b19df661f8917aff50a2c0301095ab6a7d1209b709c5b1efdd79ae09485b8d519ee653c45527026ecff8ca600e0d561973cf5a79f64574db6c85843d9d17cc693bbcfad6ffc15a79747d2894d4f2d2480b1d8c05b85233709540a9efd0b0882261aa984dea576a0ac6bad0b63175cd735dd1aabc47963a2a85a570f6f053bbf28c8ef34e69db755786e8fe13f69f58d017153511584587e9fe554192b697107e5dc70ef0eeb929f8cb5203cf7fd606740a06e6b3392ff6837aad8e3b9faa08bbb98eb9be157f57e6fc1aa31c6ff17ce6bba2bbdce5bb0e70f7236991a0791ccef7c3510a1060d4be5b0aa29e358e23aa0cae1998883fbfc6d88e6dfb4555d49724942a3df2e03f963134b6e24dfb1b6b5c41f42160b17b8f4baebcb3c78820e11622b7541bbc8188129eb80bef3540076700dcf46169811abdedf44d017946a64ca0526522ca91b694af32ce8ae6690bc01d28cd6b7b1c1fae7a290f04bc83395f58137d8cfd4d842e8ee298ab63b12f91d06b344970fca9587e027afbb4a9a3cf0bf4fe3cd348ead887e03d474574eff4e038bbd0c1d78491767bbcdacab8af07de58ccd1826a08a38023ccb034819a38b4c7c99c50e8acc0831667a2c124392e85300cebc0fd67f8f08b99fd3600158e79e66aada3f7a1bb9540aba1cf75210f9d9661a64ff4e92b605698516abc488f7021502297ba79e06393074e0509f7fcad8951e5a8671c9e74ca65d7747d41885e2cd4d408ecdffa629ac483f03cfb9ace815c7d9924b1062d8fd94bd08222b06f74946179c6f855849d405836aed695a60fc218430ae7a9584a627a8cba22b019e79379d258c2021d94cd32ae05334f985adcec1e4c3b45de92e0270a0e1b089997fd047d26b1b1fd852982a328b83ccf5b0c9abb812935c69ea086b69b81668e1f6e7e4adc30b1ccbe0c796397f340017704622ab1ddb480abd81196fd5f971838c4a0fa9d67212edb35d9042415800c679b4c24640fe84bcc00566d2f43be073371fd6a2f1c3fced096363b7235cde28131efe4b1d0b60a311f087d633bd255e94d3c30a98e7b07fd1b3503f276ea8136ab6fe6f57de854f72e7130736a9d840fa06f33eb453be80758ec772a9200df570b4a34bfebf9710d6e2f7df703e7b2ee9a46cbbdc1049e0f4fe2b083728ca7c890b8f38383f484493f24eba8c7abd104310007da84aa0c2bcc5333f6b779b02afff3d61c3065bb6e271da2ea11b946c7ec7f38fe7934851e4b0c52fb080cad4c2ca533ab1097d2f5478cf24231c3d423e8c48608c4a1b73cee0c0dc2d88fe49a600a8ad266128a4c902fbcf0bd575f9bca2a81295076f18e33e49eaf1303aa81e38ded00250c024a199ca8c5bd96e57512672f32c7a910a86f5b099b10eeb4728901e753a927d970eefbba713872ca9957f2bca27dffb286c2a3989d74e2a60fe97b3dfbe20fe5f1f221f7bb71c8cb09a55cd94bea4f51192b1cb432cffc9c6750b3b7876b9cec4133a42066b2bf9d964ded44adb3df5bc150398e5f7b674045a81ddba9aa7a0bb50e2a7df7b0437c69fece544498eb22c2b6fe243a02e59dce767c78a79b4003292652312bc6fa646e106837357da6c872761a289f3da6b8d4ff71b8faaca731d82ab0668b918e1698252ba483e2037554d7e663a105466b19e0f898784fcf92d77c36a75b8c5ac038b4cada65e516128c77f36a09cf0923e3a0ebab2ecdf043cb0e5f7571434d685137bdf57bb2e12eab9cc2043dc5ac261c3219d1b0be17a40e559fbf48bd2f4211fa9f325c59070c4e74f68d0ea56014b7c539116a895d08f43f476743631a91505265697180432aff65c8f7c5d04dcd8dccd88329a98cd396e88753156808c1afb02ce00f75f9c7580c9c3c0d3308208ce26a8815c428ab6eb8fe28ba429c19809f1982da0dc7f88a88b575733b53f09f16ee8289b84d5b8bd2c42d8539094f4f8b90bc26caec456f203d89d526d41eff8942d5ebd05fe46c4a4556571273a96baae6f3170dfcaac9bd4e61bd03dccbd3e61e21298708fae69864f71a64283df2bb7e09489a7e45479d11b618e62f61c9bb356ae9d6671cd5fb31d26e56e4b6436bfcf115c1f7c29f8a900b22d6885a1317b2c2edaf9c6ab79f0d74fca1eae0b3b027af5befa92adc700a53d034c7a798893d1456d4b96eb8612869f8482d68b55b07a0c25583ecaedf45f9041b40d59ae18111bde326be2a5f7fc7b52ea1019313c3741d532872489add0d52bdb8c2aa2e62c7b250c340b4be287e7cde62f839ca8ea7ee7eba35f3c0869606ae21ca9d018ef8ad68c3f5be5e1e54f09c484ee278853e95263269bd1de7e8124aa16870062460facb8bed419ac68b6872df2e2fe35ca1e8d3f4e0a7a66bb5e73ae51af732c20473d97da5b76d9b98c92004d71ec2d57e594ff06032795588ded982bea5d05de89e0e1263d4912fa2616131c3175671a456e16656ed94d70eb971e68933e441794ddcc143f0a43598aefc27584f82755486ddf1fa868498a15eeaee44e84e2579e268343cd73f1e8d78812b19c02aed1dfe8d3ae49abb3e5cbf28121cababb4a531d23c03f189a3738a4f458b3942259c156389947251070345ab2561020085edc686d459a417ef8e28299d1d761d1e3a5b4da26821f93e1231a800955f9702426be5bde92fc34abcd57b55896f3c851b951782d2a48d19b3ab1a27e3780678bbd4ddc7a1a6def6282664c045418dd5f216408ac332d930682681f9ec2d8d198300d71cab88a770dc95c4c29ab2fa563fccb67db05ff5e44f38a773709892233b530da4feda00fdc801bf0a122f412593f4b4e7d3b088e3d48c6b4b98a10289545592013d99713bca8f1d6138eec64b18c72fce007dca762793b8aadb6777a91d655ee638b3143e7a6cd7802b52eddc9cc0d87980ff311a06c3de4d8405bc91c8e4142b64a900c4e16e18b610218638af37cf092d3643cc6887f602911b5fed3b5580f1c3a20f4087d80e182fbedfb82c2b18efa7066e183e1b3f86bd57a65e86da98cc420ed1ab897f70d8c80756a2b5c3bc1ddd8e893c3e5c5de7e99c1d7325b711695ab1a5119d092c805d12195600dde52fcac62a272e33850a0dcfeee7dd296a5359268174cb0ae447b0da1f7e155e6a0cf5681cb4e82e3425f02f89f4b72667242ec2b31a94afd0f2fd7ebea9f300ce694041a2c918f8eac02a949474b4dd5391061e2e69f7dd79242b6c47f95d5d4e3fd8dffdaa4e2aa815b95769143c2c0fc1313a1c47b8db6e83c4afa0bcfd1484a3fe290345bb1836253da725442209aba301c70414a305c1d576965e6db37d1e2d61cf240478f6ac00f6101f0a559102d040a50724dbc436a2adf61b92734d45e1a975d2f81fd590884783a5037f31e382cb739e375c7c105ef74a92823a00453f542e3d46d4a4b2c90097a3d36c98bf792385b3e491f915e9579bb96d1594bacfe323931373014f961c98c85e95b9e78fd4ec5a8d6c15a3f56567e1bcbdf524554a4ea6d4be48381e39289bc6f8b8791f63599c9171cf2ec190803f7901cb0feb938583824dc714795d8df220eb234f9d18b6f47313f68973435ea43f5425bb378440f3507afa0afba59888f4b835bfa1d4ef195d9950c5f462d63f33561328a533fbd8c91f19c5e1e3d008b2ddb896e3dc65cdaf9a3f3f01bd128610e5ca3dc26568049fd97bd4ca1554066505d59bad31cec7810148892713661119b28dc5efe82cae381146bb748b895d6ba457414c50d342a70450734426936b2f63c6e598e2ca25ddcbfa91bbd78e86d42f3d087422e952849e6f1fe3df1ff538c7edfffdab712c774368eb0f4f2adf10746b78fa0388dc58766710c2275492dee1b505d42f34b1bd5b19b949bb80be936d222e49b27ae916561bb843e5d02f9710ed8ecc241b581e33f90649c246da6f3aae28043ed2104eadbbb65a8c93a2bda1a56c8953876d719a68d1f94493b6e722901832f28351b27b9a77d685df891e9a18d76fcc23d29b68a9fbe0c22d7e9b7b1dd5d78d52f41204f931cdb82bada507cdc355d30b0ed5b10216a5097e29f27a19669cc8399cafffee7bcdba9e3909161baa9ee70c3d8ccd7e8f83b113104f1d836f36fc04d127fc67a3707688234b2d78fcf548fe3c52bb6d62645c0822ca347f9adc121baf3f57e473477bd2a0f981a122644778b692424068e0186a0897a9bfaae564674fca190e45ad5eebb267494abec4f5d2dbad40c2b1d2680e688cb22aa966016f46a4af9f3fb357f7a5b219427c56fc854dc47720a25d79fccd154c36b8ad66adfe3823f048e9445b89110f7d573a12070cc8995496041350c4d12cd50ef5733841910fa649d658a073777108577f96e8df96662a55120926449102fb07da6fd88c80a2ac1a130aef8b405f2bb6c69c24d0603f7d9e95a8274a9a5a503e650f6022508123398d75f141435d88557ee2c06c710d046aed3de4eb1862f1daa07ee58a9b2fcee19912532e7e0bf8d462f3a404c23aba727aa55d0e2acaf9db334af0a1c462038d144062cda690a8614a9e907bbae44f939fbe5055903dbad9f9ba9157bd5dd4c4a39ce7f01bb66faaa96b62890dfed77f22c3a673841199180316a7e851563416c8c3f167ccfb8ffb339bff35b25245fd23c681cbef061b02e0e856263da29a1c67c8ffe39c93c028556becc7b78f76da61b525576c4cfeb70c1cc24dd048f399c7aa3c21f321ffee0d902f0533eb763eb486c15912c916c833f7e8ac516cd364033f8e12a84c19eda5ac0d597ed73426c7da1fe8088696bc19a904302626f739faa6273ed0d7e0e1b403b5111507d9e035e2ea9c70d64f463f34b02b6b1264bcd1813f50dcfa29e4b7cde186571e90f7a5f145182f6f1f6a19f53c5f07136a15d5d7977959a8b3ee095db05440ba17989c3f2bc751a9e543c9452cc7f2a5c294077d6937995b8db2cd433a8519604a53eab97a2f05d5d080cbe2ce6b616a7c4ad6b383026ad13eb2f1c2dfb1a67e4dfa4089984ad3c102ccfc4f383136bffed9505dd4ada602d1e6125eaac93eb1feae2fed346cdf108b92b28423a1e11b11b5e5f5b2c143daaae41e7c8afb1057b9f802088b084f994fc14f4e144c747d3fd77bff10a661922094054bb349450dd8a2576c6e132f519db70d55cae56dee1412c838553888135b1616ecae6234a64001f0c58d2965df44d0a5783e1f006f43ce6b88a4791a184c5918930d85e16c5018b29462e699bb3a6c5cafb47d826d50a0519521ac48cb320e00a285baa2fac33ff0287e95fbde4c8744374f1a2fdd76d15cdc4f03d3d8dd367afa92c75b1674398212895ea81d85da512773c3a71fd920a86735de00ea58f56e477d9b6df4de5e8ca845aab3594aad0ce6678f4ca613efc4fb809333a4f3d3851ee34e765a42e7c0ef00b1fc60cedb4510fba856906f214fb4b1b6fa90d81accb17347edcc8c614c35fbdb6aae670809e41abb208d944c66f0780f7cc3308cf5712dc0161d9c6a959599f36a378f37720019f45370ae87597b44eb279903de27915aa2662ce0029d83076ec8a4b874eaee886f0027f581d385cd93d0cf9e76087e343cda60e7d64ca7a1617e82087aa41c8e4acf20ee788704825e676e23548745fb72a58f427d53d2b15b13abc72b6a717b8b4d09f05d2195a9279e94fff2bfe8d07a91b135e2228e106e927855207cdc87562373aa0c17a512a901225c9017e7710a61872e1c9d8948f4b4c2cd9315d7f3cf66e27b42f57d14f3f4d3eda15fb903d0d8645c20c064977720c9e3e04f6d8ee32e4fd52ace93ba567b9477128af52b3d8a5aa17ed74faba91d07a792d5900c447eca563166a480b6c7e3981fae25ab395dc74fac1c3dbb6b467ee988189ed9cd35ae9cce34a95d3652c800ce25a36309e6e7d8be8e98e3d7b746d5af7d1d11149b29499a19ceb8cb5490288fe481c7c1feed38bf563622c09b1ce993cb6a67ac12cfea290a8c3e7a2574d07cb597075d360e8933c402fadf87ab2fb737588ea15ad30d5ac599f68e6856ba52af0eef1650d68379d728fff8e92fccd2c95341af9ac88cef4591f75e36c1c5b24673969c017d7381d318255c75e8be03413a08433867833f4c60486df971b9ebc606e37c4f1ab3b005525f51c1ce80736a385bebb26eac6be6ace5bf0fc77afec448fca2e89c3524a5fa4679084ad56fa1115cab523952367eff64faebe590445db5d96fb9247ca7612ba400699bdbb39a86cad94bdb284620b62da1627a4f1f6a723d0078bf351592bc2705ee129b4136b9f4406bc53f991c2d557b8979a31c8985467847b2d45e3fb8b38f0ad9ff2262e23e7275c1ef13dab569a96c481e25b4de93c60897da8709dc5346d347211e29e17aa978ceaede57b84151c83083ab6bbbd7d8fd0a03e0344a04ad3761be7cd7fc9a1e44bc2f4ece37dce10bd05dc4cd8cb82942509a07ac3d006f240f5e9cd76771872730384582d139e8803231d4bac52c1abce510fcc565920851574b2a6805252a1e753ec388a3794673e15253d15204d5e05e4969f70baa4520c809d20fe2d133574982ddeddc156599e8748ae60b72637558e5db47f49e74ab39a7c9e62c8d46c673ed5d296cc9031610c52e388b4b54bcbcddc61f696c95c7d07c72f7d74af9ec7e8a1b03d1c5c0d08ab94860b2803366e60b522b1a34575d35a095fe8ac84f9930a1c81f590ea574ea5e5f5cb3d6adafc20644a0a4ca3056d7bf77aa8f2afe442c9ddff06f592b830cf0852c600f4232bf9991a5d9a2e58e0442fbbf73dc623af06c59ac0c2f4ac402c5d1a30dbc596e701e9726e317f6f25072d594119bae7f55847546039e8527fef21ac769a2ca3df48ea38bab71464b1118fa7b51a127404a08e3c9be299e92afcfe8198dc66ab9b862b5884f9247d3ebf62d5f25999c0d1dc35c9c6cfc06cb475eb11501ec775b4a1ad5040eb79ebd5003e829f34aa20442d188c8da8773515e8fc14a05987b7b8a05b3c5e0ab94747d020fe5a5971518b0e1dba356ad0733eedd9bc8b3590f08a8c8dcdf982f3c04ee8754e9b1303f3cd200cade7f044c05f47b22f13c6c61dfeef21378224fd0414bddbc66a440765046f3e2ef075797b4848c8637e6f4bf8ffbc9d92f70d47ea384f40a8a6c0082f50aae40399fd989ced23e70e116b306db3ef16b22ce98c033dde8c0ba721645984f2e12e7758b826845fa666c169443fc2bb309a93ccd513c3dae4445d1b69b9a83184a8fedc4a3ffab025f50359f89c95fca67cb413432a84d3988a40bc668d749f1afd91a8f7d76c803fca2ab8b2bc04a120923dc701733c25c077559c5618ef88050cacbdb124fc8502bc0dd68fb8a1e5ef1f51654c1d3dff6c76ff64483c7dcba8f75230d495ba8ffef16a7f6c3765b7c464abbc722c86521165b2623dd1a7d5ad37519467034c5499c9a584727051b68448aaa2b3e5b3db1676d4307574f08ad20ebb0c8cf120dd94107c122c62c46ba66cc90b47744e6de1ac45c0c583122d104c7b3239dd39a4f95975d8034974c4fae90552987460ff8e59a0c3d46d3e1a56b17807104bccb6b5e7864b0d04b5f3afbc01c94524d9d51cc811d823d2314900b80977eb80f2a8f377fb1fe5e117744b87853a1bba6462a4d824456abda6f35deba017597f957b6b779175c873eaa2194bcfce0701ea5ceff0e6afff207b0dd09d4ca378da3da00483f88bd80570a1ec7651901fbf308c16af27ce22164580127d98219bd2ae8b77c28d304b5ff1ee7f96f93a859e7e2c3bf1b470adadaa73d5f02a81dded82e5cc8228542b24b38ebaea9ae4d34c2968a90829bc444ab9a8de1a2f3e3174bd0c327a27c221c2484e3cfff3abe289e977e77a76c23ad3306f8c719c17f45577f1f2ddf24c8a180153b25816cf9098ba660c417777a380dce2196df6a81940311b67fe2895e88c54be2bc469255897a2770b3431c183af20d131de3495b27334269f4d77d15053afc8f77eba9c3b4165b5afb90e2f73720a661177cf078948dbdffff391e501766546dc52357c25cb77f51744b8f0a06028cd8112e0f06cc80a74d952b5ce41b1aa1e32c896d026033dd41f6059dcb5ce73fefb399c1b41cc02a750188d4f578c53ce2e3918db6d7435f5af61f77bd18d70b7805d5d98fef1530dafeb99fd7b6bd522de1729ec1ccc97d9e3f4f3c951681c7e5df3620aac847522776de27662e676f0d6aac1c7653bc00f78c21c4a2aff65fbff238c9bd49982b2a2c8f1be629974fe75ae6a66f7530b46b8a11fab697941d92bce6c52864e715117a9e1fc698a8ff000c3df334e93e973a531985d015b025bcd10ad28fc6407c8e4cdfc5e6d8922bfea1ba6d62f91924ac92bcdc9d6fb86f01d670d063c6862d3f9b7fba5045c9ea838cfbf8aa8ee6d43ce03e2eaab7cefac7b19a4e4f73d36e000e03acff94c88d4ffd4e2cca84b289ee0529f1ad82a9c64e1f58e99e7c98de971c2188181dc574615d7bf74de270469a2252242c5921d6dc0a3b95f1a078594702905fa30d3eb008ac8a1401b033031a72ca4b35f9efed7f7656e8abf314c3f2454fa0b568cac5cea68dcc61fefae5efbaaa1496989289f86a71bf2bafe6a3f34d64760e631031bac0158d3f926284592bf416ac55086e6b8dc04f2eb78583b0df7fc4e4a15fe4636069f07bb098959c531fcec1fc82686adfbd66b65dafdfaf1fc0cd74152b11dd3cb727ddd41fd29f7208f9fcff9964967f8c494d54dcc5dccbe503926700b6d411103dcb52c132a322e5d4d6c8fc00c5ddea67202f46c8026a13e550f9da0ec3b9ba55ff68644e4a5c68d827bff8b6f8f3d5749a74915a8c09e8410f549141294957e78cb00f26bb7ab39e6f1a0d2e8f435bc2e1e367588cb82cc44b13e891ff496219f9a69d62cc10289852c88ba8207aebf7b27fa7ef442d599f9e741cf42cf10c67c91c91813bb1a1e9b65b92f38c4cd5e3d8d0d06f7f79375769c7ad52315b70e2cb2b1027b6289f327d6e225352e22b1865cb73ac2d8f1ed5adc7fd9f26f491a6715e134ec918aa68e557fb98616aebd2e189ace4f70b13bb9ba8984d99a8a54a768bd4012be45df4fd49a856a06ab841779dc1dd514657983c1f7331a8456f29aefca04c21bd463db7aef5d24f51b83482b3adc1dddc6e87a76b8159e3ff63993af67263df725b963caa966db64a0a0bee62f08fd032d80f51b07463a282abdb4a2153ba9f959ec156783ada7ace77a96b908228dd5d8740fd7bf7218034d7b90bdd51a453d66c9dfcec3ee99916ae949bfb2aa51bf6ecb4850b47ca13ceb82aa1d25402cf72c3bb88835f92a513ae27e1fe677f32b5e3172512063b64e5fae1ba09a17893c87249d74314541bfe04087f37df7ef0cf12ff41cd46e772f1d98ead8b87789ca74fd8da472b95121499dfe4f26ce04dd2c49f42f2ce2a736f7bd0e1b701e5a4578a7f065fd7f9e7e81c0af1389634b804c548d89bb6700c1ea9f6379e1513705ab1b607aea645c20f6a372143b4a66d0e4378803e6cdec10875a180636ce4fecb76f45b28d769767f56c94d0646b2d3bc7f998c69adf0d6dd0b0f494f7b3ecb8d2891991b2a05e4cb9de1a8bcc34c3be40846a59a0a81f0d0ade28590e6866db33792a97d409d8fe08fd310d142165cb3803423594514844e85654b97c06c31efc4cae2634c08fdd8cd1e8483683d36d99c98f998523ffbac3c104cd89d3647518c248f0a2ef2722a5317b9ded2428d89d06a791d9645a34e9060f93074368f97bcdabe0c70c63d921795802a143ce619a924354065bc318f7f0d61b1a843c960748d92de5dbb5fa55816fcbde0f53f0948945ce7f3d31569a26b5d96ad9cdd067a25a7446e50bc575b258eeb46e3505185c31f39301bec443b2fa77bc5c50a58c07c637f67d856ff4e8335c91c378815658748c471342736377fc89ecf4028fb17d3ec660902df8710f5938c949ecab6bfa7a43d7e478345757fedbbbdea6a0e892282baadb9098fc01ce4d2d598d14f286d59be8f05c821c5811f14249fec9299bdf10d54d5c75a8dee60017592dc48771046c871ef171e4b7092d6c68af99d8881e8887c26f82bcff2f270494fa50b42da6fdc03ca5b804b42eab4bfdf92af3505404f69655f3a298066d7d87ce0902867f4e26c7a973e1cc03e5c7df67b7a44eade0695e27544cb2ca26ccdab769e029c28abf723c76789fdd25e7c139cda2bb7f582d516a65338eb11c52ad7d3438b6d386c9fe1be0b2cdba2cf85955419d1e73a553b4677024a1dd2e2472968ac7653703f7c90580c2c7ec9287fa86b058753031404e299cf2d910259bf205164b1cd00464251027ec865c8d3dff7363ca12ecc504e0e91c2fe61c0b6f6ebbce80383f7bb1d1b36fc8986f21108dae7825fcc9eca16b3d1361a48de66d6b73569499ff4bf4ec59fc37ef311dcfb97633ba9da64c1c3a8ec676130b3af2a5d6d7be2af174e409fce026bcdc78350823801d17b3f8a8b7da064f585894e086b3189075af0bb117c1ca754f6c8a51bec74dd2d811785484aee160502483934507316ee05b56278fc2420402f13e424d866f7f31166e87c9b1b55db0ba8b5e3a5226cf7f5f3321c8e0471b5c790d5da6549f3b9020bdf28845875f05ae751a447945c76d4cf803cc1a4db4a77d4ac96c153af3c4eaddfb3fe93237ff5442888b73b698d89edc0237f0103e63177082119d0e1be6402db94b84177a9ae842a283d45642d0f85186a04742d6d7b1461f256b77a25ea7dcae47828ca3309ff58d7c7592fa9a2b5285257f07bfd02cc01725d7c817f2b73c72d2fc571386b165ddf68d4609333e78ee7acf40fc880dd7259138264f9d9293234fd4f3e550c79538d64b49516735c02af45f73c81d4f1a03911dcc704b442cc86842f9b879a94a437b8c2713bdf96679a833f396419e60b75d34f762aff045ba8f75e06646ac6a2a1e719fbb2c544a581f13f1c1e91c3dc12a2f62223b234370a6571f461ab667070123c6a8e9393f1e6bdd86a4a0df0e1f8fc00f62ab2f0e3158f772282e727d5baf0794cbf47eae0126042eabe882125348dda0a82b37f2fb92f546441897fcac612a421c19d9cdbe16a17d546a1487fae06ee6b83b8e7a5ce60cef9c9ad1b94f3103ac9501c9d814776eed7f85af155ba8d7903eaf00598b2a8f7b008885fcac5409d070097f9f138a7ef39f1e8f4ca26cb9b713350e03e1b07f356b93c62c7c84a88468f5c76b545f0e26ec576db1c0be8dd3210efd7ed4772b9d98528956c4943df193080d7be2ff5213a398b805c162b8803921ba0e22535785381fec840af06739e3406df406602654a03068c887944ed44df2a914d9b02d0ea065a29a5194e8d09bfa930269461a1c6235b8d219445c847ba3b0bd800e021a337fe51f9963fe2c094ee8a138c404174af77d75cb249e1d5979b019b565c3066a9206763a27f5529ecab7e6184c210884b62d2d9a3486120dba1bd549a145d6a892db1120c48bf915eada6474a597ea6a5bb790914888ef678128680e0bab81b0e7d4140ce3cdbb11f0a1eaff14c71e1a169d8f7c76c69e727da1869840e56fb4747d65a19cf076a836b19924af1d95b9e7f25f5f3023cfe4c46c9e65f90630614b136a2e850a8daebfc4af545e98dd280ff4a16e7c2ad4a98ce20ef4204e810176921d54a5b6368edfa82e4ae825735d30870cdf6e947030bb4058414d2f8b95c7499cf813ad405213ac7f64616417dce82e54d15332867d3e8d57c7d564a2cd120511aa54fc77c63e5affa39d90faffc903ea97a8424f19c74b5c1988471b3f30fec815e470d93c170d3aeab2ba85ba514e381e3f524da6dbca726a7b60a89dd8dd78aeb4b32994ee61bd2000b8f3440f62bc7a3474dfc69ef323b6421a8ce70e46bf997a5496f19426258a075737e7cf4a180c93df4e9deb3a33a3b61ff99a7deda669ed49c4062422ab33de546c3da88ac40737d6b662dff7a3cdb09dc9c280ebd098c20b9e99585af414f0de72ccaff93bf028c31b1ac4f270eebdb302536db23d6713b1900ba7d2fc14b60e948cd0d171dd103d467fd275a3a24659c56f6bc1d25f67929f9b437ba58108cf8213d9f5917a4d913766be0c87d561b33c91ea411d5f3de5225dab9c01d6579437aa7968d96dceac22cf41cb3846d8a5c309140d19923aef8fee528728d7f3d7bc8416680f6f56acb8811dc0f557ae2c42d3282be33da2b7d046e399df18443c0ae6111f3403c8d2bd16d8a7574f0389f2a6b46d0ade54c3d85394ee1c3865739d5823c6aff9a5fcf8d789dc14801caf6f7f7a25e40c7d962f7b394dd661751306923229dac9313298d00c5cefad1640abb13a6bfec6a1b93a29c8aaeb8588b3395670488453f5a698e53b35d2bac997cbb9d9f79a9c94419b27fec93243a5683a1f33c64589e014808e82558b8c78d12a26f6635521234d0107912eea1c77f5e85d0f0957a7a1427a92a7ab5472e860c433e2710bbb20111a9ca064c5321f6ba789bc886ebdc03de3b2271b849ec5867a78ef704bdfaf0484d596e8058e3260990515af413973d5b21e0137cb68f0cef618b6585270acf6fda3e94495db5104f77c24feaf69014463203d8bbe91e0b077290d64a57e0e370476dbb5251b7f5b821883b7f2092356ae0005ea966f2cccea3646c1aaa36deb04c963cb63edfb62e20ca6b0fe01add85b091435cb4ef5a2299578b67bc4a075871cdf101781d8ff436b41b47b11bfe634c6ea284f9a4872c9851c364912522c3b12f4eaeca80c6d49d66acfaf14e7763a4369ae614102c63f6b28cfb07e9e3508755675a1cfd1e50151ffb2f1f421eb47f8ee71b4f48068cfe6b588d9a85c58174420c7f6a767df31e7b6be5d8dc471c3d0d2653056bf26d6ed9a79af9a3fad665128ee20faa657067f562e90ebf369cef78ab219c4b7b83531628d8d69aa7ab6fb381174d7b4633c0f780e38b8e3c3950f852ea2be7929a2ddc4340cc4808af1d0bdb4370c922cebe9641df6c46d86f4b208754d87149498afdc8d6864e1281ccd47fdc9f680d87ffd7ce0f1699fbe3171d5dfc7897b4842c752ab7b7157f09228090611ee47af4ea3378ef4ac17d739c4e2ff778d0322b8b77c5123493a3b1b7f561cd23129f5f7ad2bf184b14db78359405d96e8d93544bf6ad1c12a44d48b9f22da85eba33e8e9f4fecb96d8f1670c3c766493e5321d55c121bdd903e3b97e52903083424e1039e7ecf49e5350d1382170b728ab4838ed39089139d05a9a401b2472b338bbc392f8d79d47f25f1655672815c39081081828ade4c1a048e763fb19de37464fd404125ff974a39770dfec89b07fd311cbd7bbec9cd41a60c0d9f727d0c10761a9d4d1aa4272d5166e17b0b3322bc6de251359817d260b6f6b862b1e944de2a1ca9d9ed5ccffab6f64fc46915cd295452bebc1122f8a601d16b04b5c9b743f71a36c212622d5c0aba3b1f261c823913d25d450c1cbae15214b327ff9a5c5dffaa508933454313d248255c8d969702e8f473286faef4ede34d7131ff94b5958ced60d619477a8e4da668cde81f1a28c796ef30f7ee07d38a8de85219fa56468dac47566d24aa3e0310f5f71d409580aa5e0d3100444a352d0fc3083dc36a9aba1ce7280d4afe4b0349c0c6f423c89ee7fa61303b3cdf684ff4ab62b4b948077e753dd2726457d6b12bb96fae1368ef96a5e0d3e38624b69bb7f3be3176428ea53ecb05584061a9264bcb503d4b218cec1cd42164b3e2abaab6e2707790514d5e4c83350902cd4de050dbd3dd33030bdb685d9e8154b0bff5bbf20cff2b69bbcfc9b7d439e36a14a4d0a906fb9e5928dc2242a1faeecd7ea7c934b411f87c083958e6d462933b403db58afa0a7bf77d064e76f97382c7109f5f5f5e87ea94eba0bbda144ae0ea947ce95ead7270f4858006f057a8ade7699eca3b22cbe0ca853e5c33b8f90a15b3cd34a23ca19e8f6e00c05c66ec797c481beff705e7b56764317a22fb85c9831aa373f135786a64976c52766f763ce1fc91fe5beaac855d147698c553f7b8f6cd450748b6c7ea1e63aad95002b07b4fb7c325a2e1d46b387cfab9d70a1030c54084d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
