<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e13ac8251ac4056fd2e32e4c371bdeb0820c6fb33b1f0fcc4b8c67977b55a46b1e9a8b53cce5bc1d5cd2d6ce97d4f5ad460a10e8cce63fffd19378168cbe9a82af542261f9d2265026cef0749e34f1587af215d2d9d945e76f65e0ade36fe3972455c0fbe4bb2acc29bb6bcc91d7760cc86be1a6630ecc6639a9d6208dfb7879d1c7acaf156d9415910ad4f499996c984711467d88c42158ff26fbf97e4e38c5325a6108cee8604aa5944292824795ab9d2ed14bea9ccf17042a285604fafb21741414f5c645cb2897356ba00640484a74eb30d6f2aec4d7201bb821c3790de2ff839fe5f9814b4f4b85263cfd9d3e91619d9258f3995270bd2f4728d99213160e6edf1b50be1f605dcc77098190f54d4a6b9a0c00afa1aadbf58fc9cf735b13f9bcb9bab272784d5c85979cfede7051a4e0fc0cae1155e93f4d1a3f965dca84c3181f9f5d7f624e7209624fb11fab8c167098e2b9b09aa0b0383a0c3df4e12d5942bc84e401b22b2d458082c74cc48cd15c1e1d3877db06339a77b3c3740b363d82a9db7bcce6e9434fd99d273fd5dc55d4cdc44359b333ee971932ef0978340179f3e4e1bd765bcbd91c15a09f10fdc1dc9f8bb4085b27066e0a9b91dfcc27292d30f6a40b6023bfc0389ca98dcc25e7d4a781103267f3fd0233fc99afc559417ecd327d66777b2db5e2aee26e7015e84dc3dd883a8951e63569404ee219cd2313fd121b2b14ac370b768939ef7819fb37b506ccf0582860f7e342c1607c2740be346b5b7635a608a5e6027755ae5304955f42008b68e531c3aabff8fa0b0f4abc68eb43b03728ce027ff5d95ac7127485c5a8beac8763107b634a600e8347bbe1750405f6bb10834408bcd7b992a3f48bc5cc0eab3c18b03dd4239483a8aa3dd48d6414873684ad94006f68bb4dc7c17fc2108c965791a925e8bad6cd22a040c2f4443e52cb9a587e3a6f97fde18f6594b38d781579817eca75829994d195e12594853a72b81f2323b0582d6940f6f95620eaa79673f0b886a67ed55c06205252a19e1eec1a600c2a5908c8bb3d859f004d8f73765a010ca1c017c9336fef964a8de32b32fcea46d5010aef9ce898334ffffdcf309f9a79f9c6df03cb38f60b52b9481d7cc6ca8c115d585653aa334a973c48df0839dda7bc8604213d4bc5f784173a80fe561110ee6b298ab3f7f7393d024d59168cf31a5676a4034a06e15f2062f9d47890d74386d3f07b3547989ce99157b86cb39d9996d394d59cd7bff6fd95561e08ecb3479d9c30df979ba185553c169aa8b2165eeb0c57fc7c85f13d058fc69ba9cad09d659cc174b4a0e20329a9ac1b93806f46ae8522d9638faaa09ef85a13cb6e6edefdcf3b04dc0fec2214c1edef3c0f24098111a79d29981710d69b1de77927bb5a6b4956f3da167907e7b022cc592001b1f4b22977815e180af48ca725f9fea7cbc8f98641af3c3a021f1b0116aef3327d12453fa97e01a9b1be712e6cd77ea8a39ae33cedfb93a8fef665175809a013973d5f959e2e6cf5ee611237b729f77fb395bf1700663464f14a8c109896f26baa3f3980fa78cb3e88da0d919084fe32e62fd73c9b5b1b1c50c6179c7b8488b7f6a487b0eef4799e7569c4278ecd1e7f86055388a2838e6a7b362c56a433fb41a945b207d675fcda831fa26ca6b29e546a9fec82d45094813e76b9dba0a2eef517b11e99f41f54c50e7729dfb77da597b50cae0d541ec1405cb0734cc9c0ace02640404d93007b61b1f9ea34b32abb209f761ab3682e7e24c99befcde5bda544072f7fc2c8fc05f1390ab293081305212682fd700af9dee407b60b2b84621d7be5af36d6fc5d4a6bc4ada274b29527f6b8e4204bc2ad692978d80a954f8719067d3fa1ae0098950740c8356b5802d7c7d7bb93d72f4f064dd650c6e348d470d0da85b8497caf0024f7e653e4ccb3bd4ba90afd8d2e1692fafede88d1a22a63a36df6aa458bd75e5cbceb9b591c442bea4e926283cfdd754584a847252d0000f75e9c4f7b2366570ed4e8bc7d33a1a1fba2de95d730be3f0c45db269e04329327eb2885323c025378901b8b4e6ebb87b9d2a90d86b71022c419dada9509fd07903efea9fa012da66becfa927e6eb3767be303343e30d3ded319a2492aaf62ca49db203f49002cbe4c1b479abf56f04c165acd98cc0b8057cc78258883445ed47282ef26296b106e1901953c64d1222327adc068b222da98ab0af0d6faa960f5b9c4c67e89886a0dafa18901417c21fe3f83f3ef732d2b793e1433972ffe56b5100e6df610e76f5c2bb752edae65793f5fbd23714d3e1fe804ff065d3c2d1dcb71ea25536e85190611fa28f4e73f694181058d9873296666eb290784795994c329943ae6b130955a76f74d89cc658df8851e9042e5f79b35bee2d7b82238407f68ed8a87987808c09bae81548097f880c14b80fbc766251bcb4161af4e4a21c54cbe60037d7fa05d07ba758dbb45f512019513fda7f8a48020cb9acd0e1b618206ef118ae095940a643736375b0e6783c18af123852c6339c09d24417c8e962a083e8f335b0998cffd35580a70f2930a2caab3e0eae3f9e26e5560acf801288cff6c43f6da4921fe5e3addadee616d9fc20b55e8f53a0210b113371c4bd121c1a99a36e2a5ee1ca14c56fc4348fb51b2f85abf072cff3ffede960ac9f805f4099cbf365aab93813804de5a674f029cda1517709350ac690dba0fa0a5b25e9fe7133c32b02e3996ba30e46e216285fd93115c01ee9835e3113ca9c3c675bfa0e0899e3bf44117b1c3deaecc7ed46fa23bafec817aaee15ecc91f50e0571d1d4517debc145a1fc51aa1ce9079dc6f306061d775d55a09b72b9c66831abfc0c20135bdf99ca9d1545890754ef681264a3613086d19aa0c1f03619d858e7560e8733a1ff24883ab2769da389a10a8d736f7485ffabf5f6f1c4a765246a4cd09772347cf9a4f4e248e958839c92d833c9dbb804c36412d0f0733a55cdf5e19976e8cdb55b6a8bdbb3ea066f18b2b1eb489e3543e7149bda312f33e8a43ba044ba0f6218ded6af2041154f7a6b2df8fb46a9eac3e71e6e815b46c3b71fa4b8d82204727960e9022bd01ac31b8b2d5e399f76a07ee41af7c72b0e3e35e12a618c74813bc086a77717265ee3bbbebc6817e30bd70bde44ed3639999c6fbb6200503114d533e9f7726ea9bdc5753f910d9020558ad38c10fab2e5d25637103079979b87117626b76c6b3b4eb12a8730767dd53a58e085d2fb2ce80efbe4241f74cce9ce38f292b82bd44422985e56eef072ffd81d24861e64e8e444d78ae011727825b59c2b575679c7f79df1e35026eecfc1421fbf2717a22b2061e56525f79ed55389baafe0f7b4baabc9cfd582fdbc635745114cb7573d49859efb6baf1c9604577ccca7f91515fe9837809b565d5cbf23e598ede27b7ab3e1913bed7db4f9e960feb151ac4ba5bfbf594c892124d8da9aeedead50a7bee5918c8194a72c5c07ec68167a68fa7750cace8396d15ffc26406f270f4c6e24edb867cfd147cb11a64ed5f545575c7531597254793a81ee995e791ce3d3829d412181275e0a0ed384c40e569d1a1b3b5216a42c8c470029849f65eb09b8f8931bd3bc44fc979df97f09bc5e98a07e946dcabefda81613de5e7043d3fc187d251d1f049ef205bfd3823c3b584803c1b80334ac03d92e36ed0eed129476c61e8b5164963e1d37b7b8e2f58d8716ce3188bf21f8373ce0a26bdf0acdced7d5ceedd6cf221433599fab9ec43c215264c84b5a4a4b46b595b2deaab3750a860b1871f60de42721fdb1bc577a75ddcd79b3328c168676ac27af3e6c2600c81f5836ed81ae0df80eacf3aedc3dca31ee80a7e746fb47f8149c222cff16b46d9a17d0070f86d61c310b18aaf6778f960cdb20171b6e65007d089f7d5fce4fb99d3d250ba02019dda6806b3107bc08895c419d24534040c50d0387995912180bf33a71f5fbf02268b240eef077f09001b7fd435ebadf49932d4dab04ce6b7d7c654a494b3c13990b533bd8b394d97406b45afc9c4a163c9e8ab2b4b220e3153f639bfdcf154471120821c4116f39cd4e5cd3d476fbedb39657a44675c4717f0a5ae05031de77ba3b7be9686b2ee1f778efd1dd45ad0a5bddd33741214404f67d41b47b02ee9ce98262c4041ed56425f0452fe8d168db95e65eb5b0dfb9366d3fe817b2afa8cdbbadca9c1659a501dce50fe46095db0c70fc22356ce347c76d4ec74a23268bfe690546d8d2e4d2f7bab569d03699957a9b99114d9db94915968b5a6e89b6912fba457d13710e40d18aa26319eb3998ccc1388b74eda970a06e461cc1fa77c173e810e8d4f4d6e1baf46090c2a1fb8bc7782b2168e3223088627323fa43d8c545cbdd997837307d5b57c8c9cf99f5f78ecac4aebebd5487ba1ad0445d80dea65a5b3d9ab8a5c313919055f90071d12050e4c8f765e9d5e96a59d42f07a186b6353855d9d04b7a4ed4ed0a4f06eca028b33f891c66745ad51b156458fe9d750351681f18da0f0a5e3567333a01675ee4298fbfd47921c87c101503ce6e621dbca6443edcf587b5e814c0f70585ae7c3b69ecfcba22be63c762631ff909425ba9534daa6f7de4919b0c905e9967c03241c6ef33ef37c760de669e4cfafd4f981da798c47f53599b95555b9206642b41a5d9e50aa1a0aa0424ce2b411eb43e9c11ce499eb183eeed984ff151af6b713c9410a22165e7faada554dea123eb446c3f1910efcfdf03901e564edf3d6b2162141959bdd864f347929f64221e71f710cd269ba8fdc35fd4b8923930cb09285679d9d7d5a17e2c9c864435e656de104d49871344e8e89167e7480dae2cedb261efb4635200082b8b2058c77029e7dd1d2e51a330de29dd8050d418616c9c50788305f7a52df530470b27dd83356cc7d6675faed9a25088035c5059c7f1bee4d8a90307b6b0e5eeec4aa7a12870d73cdfa6df8885e8a9aebdc9ef3d8537bbff1474f672a6019ab9fce207a6ca411d6cd6d17a23a4a6f93a1b7efb739a4414b6ba49fb84724a3b1400a10d38b66943db2d8bd0d80147e948787ad368cac86f9bd978761a7e8db40ef4a58634a6b757d443468a3f8234575bad1da8761cb15ce7eabafd11dcda9b64b591b83ee80ddad7125acf1d0fd435985b783add3c23f4133b0a47f6bbff7192b9c4db97d6b78d28d793315d351514f217e92f8c5176be282e2f72e155bc926e61dfb16ef027bb35e5d22cb8f3de17dd94f2107b7ea33d26bd79e9a1d0f5908f31c81b26f7446ccc96514cd9e8e3285b46e7558c675138c913bb9ae7c9745029a50a3637f43a49c677c3fa3b875ea7623bac0b35c4348d7b576f1f5ca29392e560704d2f8869930140826e9ea1255f4aad6a8bfd9bbe03444c469be454ef4113f919525a234a7d6fe30a90b1f9f213e9e191fd79f3a9906b1403cc11e24797dccd854600a0f6e39a5a0d0d739d108e05b85fae99d95f9aaa0e3e7bf5ca5fd9655b8f445e8bae3f5ca1461b330981b53cc299f3d8d2dbb2f61929311b20adf4fbc009e68b00b1075bbfd50e1d7d71db41b815b14fd76224df5186b73be1e7e57d6f8410c5ba19828d03598d6360eab78fa798a3cb61183c92bf185c581d4a8f3b58c28d92d8870f41fc6211a9a1f6e10854a4bd9edfa97a3ade0fb9cc356a8d21712368b7458c67ea298915f4402361a3c9f37815cba91ff2a7c37caab3b8c8e45ac434027e6ec921b1622f889692ed8fb1533e7ac649ab6ac147ea4185c34f76b8808e3a12442105cc2e36cac5fc2589e1f3dd10a5481de278dfe80505abf348200e173a4cc08062b327dfc8c8eb22683a9b83eb49fa08040cd14a920c0f01d76ba1845a2bfea688f6e7b6920d1d5d58f90ecf2cac7cef26a33607d9eae163aed729c8603c704187e610c2debd29d54f44b344fd67a5484b0e00f37ce6a5df559c1e71d702230007ad5281ff377cd750cf7e11a2099c73d021d82e5244d86ba835324794988b10b5429afbe0bbce5a0d3c2b0be7a1a4bb3c18edeeae551a1ce64a2240b62a2a206ea5232d08205bf8934d0c3b7fffc5899d81c90759d671fd6eaea8f765cc2e09cc79b3b53fc4221b1901a4f0290e79b2e9c3c9bd1218daa6edad45b15eed1032b3776ecdcc4ef93bbc7301385d16a354379cea38c2be07ef1f018271b8f013c7027d8ded90b56336bc3a654d38bf9c928ffee6a57a5aa3a0d1bbf4d2789b8d58df447a5776dad14078e0c10a874d76a7c0c65a106d732e87842c02bdbd3542e6ee43a25803fa3adffe3be9ed5d08d6d05eaf677adfdca5b1bf5ef1779dfd2a6c59ea74fb96129915dc57a2fb62c49745dfcfc6dc59237c791e7ec58901ff38d1775b93901a5b89f235511eb934705b665fa0a5a037d2a7fee30c3c726dd3b6f4d8c586cfcfb80d014681820f6e79b7d4699dd7c63695324c297a17aa5174e8a39509f145859b2f2835c7456f620f1fd5e51c6697674c47b7f1d122b6925545e2e55e697f9e430178d8c060a14df974b7c34714122425eb08b0f3a0f00bbd3cf26fbf6d04317eab4f0bc5632618b15e8c3fa60312073d91ce9cfd369594a71483e9fc22eae0703d87154890bb0e84cdab45df84da185541e5f8fe0e16ec4a6bf0afe7a65501b52155478d82ac2b6f47c72ad949152a32ccf71c8a32da3f2687484865140faccbd702d1778515f74a536003d36a0651fb5b404345024bc34f1d182894a0b2822c4bc9ac29606bba12ba1852d72330ee616d858b8e7291bce4818c91c2bd1544f7c2778ea562217298cfa627783e6339091196c16b896c17d899ab942690b9978d4f90aa6e9155873f46a39c91d6cb1c85ad149c98c3ce4cf9258f8456c4b8205861c27ee1a2b11201ad668ffce51561800840d9dbb81631fc4ab0f898aa51981a21ca42cd073bc1f2f5695dbc0e7efd0c9195a6f5c5c03638bd03994f5650d3a2d09f05a4fc90455dd5e03325fa87c54d4cd4209d77590f775e16be311c2504ad510c7f6263064180b7f49f94ad1b0ec99819c96de975be2737a16edd75e5b5bb3e236ebd072623f28f2619d73180f603968e493dd89cec2f8d61762c5d744c2fb6f95dc1d174c97a41f418ece4412d7c6da0fbd24f4903ca25d138531612fdcb5977d3941a00454b8cd3a45fd8455cffddc069a639201e0e72ba2592514dc7db5aa556fd14424c19931ee706954f5b27c407a6237b8df6560c499d4b82ea82e882ffa252db3dced8d2f4f827cf09e45ffa326a0b85a237574387e316589c3ae9dfb673e8aef687fee0da2ee3ff438c530b5ddaaaff79306e3f4424354427d3c85f3422e61449989cc6b1d32c2ace5d03818a93a67282f98c3a298075873f3e263c645a5d58da0f0d17e88457ad9827c6d66fccc4a8872c5c4b52b4d2fcaf3be1cc634609afeb17b0565279cbebd1809354fe8972e67dfb25176cfdbebe3111ea7f98d87f6cfaeff65fac62ffce2af7dc6d6255cfad06fb17e343004cc3def21ca01ee973f219083d08155a98bd7a04d156a1ae4ad5dc3851af339ba5e162dd1c2fbd25847de0636dc2da8464230eb480fccf068a180bc058a8cdf6d89c4049d9bc637f3c4033fae1350f72b41c97ba3930f3f95dcc630c59679751be40caaf0eabbc5931bddd9be73c964ff2fb64afa0828160509ddf0d3ac2daa78f56c55ba8c8211bafbf30e5ddbc9fb737842df3ea4d80d4fd5d31a041477388136973e51eea32b6c511b90c3cdfaeea5224e4ec5f948008e995aa9d1847965b551b664ae361c5be4720c15b6aadd0b17a481965d8a702d7209d224f29d4361bb5fe41dcfa97f6a7c367b8d27be764d8c348a51f8d4c8387dad3ddf6de391f2b71ff9eb20350bec5d34bb9fee9688ad7d8a85fe2447404c3b7b639bfca48e6f021d07b787749761ba2ec89f7bdc248d490e2d2da7257ec66c86bc57f42620b94d3e406744b96a389094931eb6b60aeaef69f54040c51090abe3be79b097f5147a365dcc9c1e73a5a4021e47c54327dd6123a4982ecfd44f482eb619da0a0396b21c5e44e871a5d7030f393d52914bf714eac0b84fd9298c69d8424c1b87e8d8171ac5e5c693306686a2cc5238830db6d6b819de94fbe04490430fc0fdf0f6c699d4b07eaf939f5428841b1e67162a05cfeea145579284acc836190e77ad9add73a1605be6f70986a865967cf3c60ae3431fda0a968c6ac85a3e873f214e8020a9ca54eac5b8cb941a0bac05651a3d9f2c1a7bd73d79fe6a60136eea2ff00f4c5e99cf10e618aa6a539e44e5efa918e37216af72bf88fa45cd72f27690872571030f5b3fa0f82f428f8df9ac77bfdc097bfa877afd147afbf2897e5d65a07ed92a573257fbb7f12c68506a07e0e2d994353b3766f56e72d7d6b42c4d586b9fa1a0acd57c1ed3b061bb16e557c4eef52af77cbeb4f580d6bc3b03b13f4fcb5eff807618ca60dfd009355927ccb2a2e3ccf788d81ba790f2f7f73a2d4bb0cde4920d1294b130a63c95a53b1c7d493592cc78c23cd9600425d123aa819565019eb021c855e1c6644f2b495121370be4dbc2f9daf4f237d624e0fdcae7733349a760bc0f2795f36961bf3be3c5ad040e38ca41db11e0b34710832daa60e746ce7d6674fb48c496f2c5700320fe8392fe5775368f44e2cdffda261246bb978bdc7261ecee105c7d8f5fcbe28210e90d1dfc72038e476638a7ebc86a3aa8c063b8191eebd229d2fcfd0992fb3f5af62061632e245f44ee3d1cc7a48a3abcd418451c74988784927e0369d537f5306b468566e78067ea2c3d25dad9b89c047000931305e6840914135d793700c0234ac9eb7b93ca0f0abb5079a4c5bb2bf8602742151751e5aa4a7c05386b6c374c233068b0d2521baf755c01193a8e58498b65e6c92b16f32afd97427f9383c6ea477f90552dc8ec9279942f8d5e4ec461f5f4dd8e62813bf72b5643d2ff3f9f89db19a2bb5b0824d53fb332cc393f5f9eb87879fd4b4d66be0b57fc14eb9a735482973793bf46552ee19240669486f4b88e1bf19983b4375a11e8b2e9abd509838a8aa50c91dcb336460af720c722a98bbb78192147fc7166770a835b08c2338b493010a02528ebebe009d53b2223b837bada6d56869e19ab0e9c782203b93e72358a0f3f364570a1d4c0e7d1fd74aec82126487be193f7e56619c48eaf5bf2f6ed9c34ae7397089fd131119aec944933ee132fcf3c94cd30d9c92e0966e73c05c2c7ec2b89ec1cddf31310106c57c994a2572427ceb5e0105575d9a0042cc3536f9a667d030d807bff71918ae4ad50d4274f3a118ffd7584e50f30bf4f9a63898cbf18eb8333bce4b5f9ef40fc680dff7f9ad11fbf0ff7f96bc5f4ebbd7bcec4fe13a6ac07ddf63d7fb6bbd4fc3a72cee9d685638af8e300d7692dec14dcfb9fc2819f8dcdd06bae6e77025088f49cbf331662ecdef70ae934cf97d0798965f573618fad4cab5cf52fecfcacb8d70a1f369e92e8e370459d40683d37cdf67e33fbc242e28f783d263f68d9401e96bab946ea9de88627e3d29a3cf4dbb1108a68557b81040afcade7b8d8585e5dfd63f806aa40d50fcadd13aaf9760181e3c23db359fc2c77e5255b1fadcc2d78fa165aacfe2cdd580d637c201b12e5f79218cf8b068b12cf78ad7830aa42f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
