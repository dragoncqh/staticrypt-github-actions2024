<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b88168c997fafa6ab36e1cb2e95fbc6ef2386be0e2c8bcb784410e618498e73043ae42fa77ebb8d44528de4bb34a4223d9462ad74b471b08f997cebdbbdc3dea0793974b3f0554b130424504b258467b47ca333f00b4e9c33258bae2a957515107ef116a171bfa4775ed5620f86bac93175186f73f7d54c341dfab8ccb8f744c6dd784fafdf87728b73d0f866a97fe7f1934a19017d697403d9565c9f295167b0284d061ccc9ac8bf22f7d207379a7b73b9bc2a4b83e78c43fb55fad702d7a5b2e3e540630b8265ca2ec3d2eea61bff66a6621b8ae7420dd0ca231c8e183c128532bd7b359efd9a59773f8a25674b2babc9ad55bde9ef14e5e0812f1580d3cff0cf33a1ccf92cbb00ebacad22897215c1c6cee6831fffd7530f1c7908cc8a97bca4eaaf172553ab54150cadcf389082782174b173fc4fb15e395bf4369440c7bc266177df489ec002a83f80972e5af9e187e491c51e5b14f68443723ed2e116c1fa467650a87dcace962b2a057623a60e2bf7be5df917365e71b9ba0a6e8772a6694b7aa9102b678e6b6da6264cc58205737589b5af27b583da5bc7dcdc173ed79edeac2ea46bcae5aaaeb2934ca5579d8d95608bd45b28bc867f714d963833820a6b411978caec8290a2ae7994fba1ffeb37df03b74034d59464a62a8922ab7071396cf685bd4b51b351f286988476a65646c695c05ba67174f23b0f2158752b65929e88d58c60835b151ea84eba28992d850e1aeb5ae25097e66fdd9b19d0b7278a4d451d09a9474b81bbf80bf62915f3f27c690d70c3676ab1a177eaa94fe7c12cbe3d3ed7a1bc23ce264ba8f5e578c32bdb236ad874fcb3fdaf342fd4500a0931e8ddcc232dc86af95431e413f4084dacf8468c19d3264c44f541a13acb3f5ae7fd156de42a92d1b8895b3af33cb0dde7e94fa47514f7f87119f6692b120a6477420fab19ee75dcb7249038c4f085d712502acf51b85aa681162c738d279374ce7bcc8c5cdbd7e58c9d409c46a7aa59046d22f33b0860bef865e0ef861c61004a5b7448af4f5807f90ce93053e245aa9590e40583752bf3d8f3f09d4c24082754587d17caae7f5f1d5f8d48ecdeff0d1af3e17a4cda3b28fa2281d369d7e0885682ec9d52867922a220e71d54ca2c803a9afc7edd41b5b3196e07b611a74140d8dfb34786add1c7ad4570391f012ac5b38a95a24cd6d67d76613d841aeb3a941b785dc56f906db42eb7873dd2a65e7445252ae522735084be881cfd02429cc8830492b40b56375d610879425783756324872c48c97324c55d509b3cfcb80bcc6ab2ae3faa6460ca3833120c83a0c1628a37c5789594d9a9f7c95ec763482adde0c0401a51faa09904acf65293124b56d5bfa1de21ef6b083d33459bd218240b293ff196a88e6c7628fdda9fc2fb928a53ecea35f8b735c41a1e7694d35a132a3db223bb36bbf2ac6651e6fd61890e706358ee699ce03b3f79fa7bcd1a220897ac7a0d7581ea97bc29923c8f5a6b68b1b9df18d5a9255c3db8789116256bcdbcd6844dff40be5188b4861b535e8e1ef5db67e69a191f4e75a9c8075d271124340e1537bb22912822054212dbabfcb0e402a017d444d19879a88c16da475cc2d1a4fc00df7df58e1a8c1271c0bf70f47f8e6c21a28198a245fcf2ef517d6d6f3e42a146e147b10f073c445502abf2f83bc56860e4fc7867fb79813c71ca69b496b431d4638c78e92a9bb1dc331d84af631b58fb5c1fa7742221dd17f0b2198ee3a9537b290681bd89875613eb12c4336d35b26f69d637d5356783b212e764928f3ddd30b900acaddb84b832543a40742f680e8d0b66e90e0cfcae1ef15535ba8320c0d5964bf2dbe13bad0495b357830b67664d00aa6f6bb10ca6ff3f92280184318631e7f6577756492e1f5e3953a66781937f354674161c4e88bd80eda6be8e6b4124de8201dc4e7eea54f3c59a794849b08d5e68d365fc37bf595c0f539afa7d7f75fada477da138b677a5fc230c47b470ca7ab41ff57f5da1813bd3d13fca4bf2cdcdcbc86c43202bb7564dba6caa2e3e615fc9a22ee9c175e06b29809c1526973adb3dc719fc5d6efc4f4cebe6f743e1aacec2204eae3a6ba7b62c868abeb15ed185d9a0995aef04f7fbf287c65542d03c831df5b2bcffe5b1e4e9c2d6bd4be5878e2ae72087fcaf62facf1e848e2b0b3ecfb88d4650ec6db47679888d6b7b050a5cd33d1435759dcc711fc47f4dfb52474bdd2bb617c9953629635ef487a31b5f310502cdf1e61fbd4c12d8ee94543b67ac9d1cd862eb3192d7d491c0e227e3a6839238d84cde3da47ffb4bd1993a8768f0bc38373843310e558a2c041adfce8ba4b9cb341307b4ae2fb28ad2eddd73f631db0fc1bb2f847d3e52539262aec503273b14ff8b59403682cad87a890b9795989cce3d8a0a2c36df8fa74f3ed4de31eca44eefdf4273169ed0daf057f25d994cb5eef721785492289b2876b84a0798410be508be7dd8d81d366729654851ebd67c44310bc4427d06f24bd8eac0bd7a1499dd69a3d5859b3897732db0cf40acd564130f1a670ce486e2bc7f541add6c5424843ca70973cf33f5e51b296447f436c8db60d08f823744bd2d0e6e61cf568865d447b6ca0c6c3e451e06c27a01a3bfb3af9d0e2ac0fb2589a007ffbbf54ff3dd2daf5ca10915778ce6f9608a4955a189310e05cb0e418c46c052e08b918c783b5986dcdc75f913997b07717d17436874fcd25317426177c1c6c95673e77c9d0bab25559084e0cce449aa9cdadcfbaac0559ed4db50c8c4d3c59daf3f0e318303b4c51c2ef16504829de6a4fd40f13bf9d2777ac4608cbde05ddc0949925c78a3ab7f38b7c68c10f02ee6f031e184d7b4340b56f0ba392051d4b98884362828cf270f0d1f82bdf37f599d91ad0ae640351278afad813a52f050011f1257031c35a6827959b4dfe61524b38d0a60167e6e1d18f2ba1fa2bc9feda3fe18263fb321ce56332f0d2b8fb959a7b3d0b020642606169066ffec6b263a1c5eab665fd4a0329a02ee8f6e1960657a2e36e318dcaa07f7365265a5cad5f99eab8eed029860fd4e876ad19a85dcc3147542eda92829d14d4f03442d260303bafdd191392e43f26b558c15b88b5c0d6f0b4142cf32fbd653107303c97e67dc306791f35ae80f8da0ec6ae612d236c7daa827655fefdaa2abbb9f34895fbd0bff7dcd405634cb7e54857d335265e9b9a1dd9c530370143849a8b2dbc52e0d2faef8a46a758b9011ae1ee8d4d247c58d061ad02e36b74ae5f35cb2363f40662c0d94539c52c1623faec35bd5aa2881e9410dc4b5de70ab382dd4708cdb081bfc5605b6fbf3bfc30afd59567d0a9eb821b318708f262318b400604d710ddfe15a2b415ee34f3cd1d05a602371ee307a22328f356f203b4507df867fe477b719ddeca19a79db050d03b855322d656a1dbca8129da903c25c8697cbca05b388478e3dca29701c4b0e155c8e54bc5d3c53e0de6bd1cd6673054570d3a029d22f7e640f09f2bf90f9ac8ded39d0f552f9b665f5a42318fd3d8304589b14ec03561c5cffac0e760e42b3b192994478d07b8f9b1c60c815c7443af778a3721bdb01dc889cc6ee88335cfa8891beb111eb0ec22b77eecd63603a19b6e136432fcdbb56c5b27966ca88151569d2f1d87ef4acf1b32d39f551f716e7feda48c58e9017146eadefd93ac0ac9609d02b362fd662997650e54647fdb613b55871caed3dac876ee71ec691f3c8248d3c2ecaddbd668d9d2300869467e228263d69849a55c5d14be8988ae4d27b64ac5b62a7670a3417f8ef63abbf4a0a38426647fd438544a01287ae51e9f063de09ac7f6fd6250ea9b15ae0c068c7be62e47361ff3ab1cf27d9de3b278e68d34d231532aa2628cbb1f64d03c4a3f8c7f1a86a5bd83881a6083bce8ace3147ef50357c44bfd08201b848aeda3e569ec4727e529ba23a2b40d7aa428b34e8a5b7ac0496fc00826429661fadf8ee7623bf7e0f5f19f911227616a515964617a7ccaa74b435015627d45c4e930ded758b915525702e4d349a94bfe530ac73cfaa63c6e4bfb2d0fab519585c4e634d4d36b9ce6e43964a1b793379fbf0c9fb427c7a907b775f320b7bfa19067be0b51a1daa8e6c92bcd0fd28e517ce638b3289b0c28003a6f3025db0f8b69ef93d6f0cad526f19087a64070402edfde1c4a836d7ca27775c7e57150ed6a7dacc7e8e849bb8eb13f91cbfbadc9a079e1e8a9f81afa3b0983bcfdd217fd241a4b4a54edc86541ada209db9b4396a92a19ea544c2d42820d23ac95b7440cc5e74b612959e61979690617f298b2e062d3c47a0dddd34a3dce20a1696c4cda02a3a1c4b085e80627a1c5af011f3b28bb39a481b05c32025881d1d4126ef2707279a12795c63267391d33666628af383f113e1270f7848137ee6cd61daf5cb7ceaf086432ca99fcae2edaefbe4d932358bc4911087bef8e9ea102788663a40ad5b9f782cc9e60e14381e94ce2bf031160513b373a86527b3c4a89743885c30b0159875dc67935ae2ff054880de7d4f0adb8f2745b2e9d14e76e3d2fbef54c75348c953ef6f28e7202e8f9abde8fa3dd7902532eaa036ab1223016554fb9dfec28b6fb45d2ba074a754705bcd30a0d80d5e872dcd81ad34b09e816fbdede2ca32004b5b0c29e7029abe4c0c5849ef27421c8b41dd788de09a2374b7b03a3360dc2586323583bacaf1e3543d0b477e33cf7a98f91bb0ed34b0163eb4941a95cd39292131689e2c01ec44f0c7f0a593859653a3a74dc2443efb896a6de48c760a3e341996bf65e618036c2215885fd205989e7e9cb7193e42939e2649ca7339055f9253fd6d70c969f31a9457cfd8ede47245ec7ce8889cc535f5dd848df6566312806338fdc7bf3c18c0966736a243f3ff12036d5359491d2a2103fd6a8e01e8742da2e186add3f9be84c24d50a9af60944c7e75ec0f47194bdcaf3aea853b21430096d61ef54f7a0325593c0ff24411c6331805489ef85bd98166e9caa3a7b6c50ee8d8a2a90e72f008d48cf836bd785637a6ae8a189b80bddd17ec9ab3ac084864a43643fb66835a6256ac32dcbdd4010768289d3fff50c5552de8799f1a37207f3953edd19964cff2992ad6f5151e78af2c65bbce27491de2e817902bd27e3357980c3eca010e7387408626035633c5a9faecacc2fcc6b955f06af46421c7ba34fafc8c5eaf8b2c9ca09286693a4c0e130c17b85fb1010a394e4982068adb3c924012a658ca43e91bd4259f35f4d96c9bc7c85690583ecee8dbcadea0d9a482a5b9d1ffb483a9705a8ca2b252589fe36633a0658fbd3473e6949bff688ecf832a6352a69b870dd864ddd3167c57bddbb4f299aa13419a8d68343f926904c0c3f003718a3cce7f4b34aff6ef90b63c6acc04b950f750af33da146de58907ca14410554f437562f4a76a0185076de84bcbc687f65ede3bf00e66aef8cae2934c3d95880d196d4bc67d98ebef1093c5b8d73e339e9f520137357a0ccdcf53367185189935ceb75a4d8f1a146cb40cc55565319aea1d4c99501563669b498b29331b20365f81773b68f7d2da057cae2fedf420a5892dcd529882e9be74752fda035c6deae5bda9200f45e93c6dcb74d34720863df1e34194bf0d2aa17ece69db26f30f32a17c010f95d66ba57a161691c584b94aceea1d1c8df301100ce1ba8c541302bd601b343db663956ef8395690a82007134f498487118aebee932a52ed5eee6d880e0d5cea9ba59caba3545d40c8ef8f07433d874964d055b8d46a1bb7a12109306d06e2422f78dc38a23b6cf6fd73fab65ded9c4cefef97d9cee290bc7383fb28af2a2fa40e7ed80404f653707efd1e4b017104b106ab7246eec6234e14ac086596678e9e110c48f6b0259208a300a441c9df688da9018290854c204ce4e4f6a8c77f64aae1d81124aa97cfeeba3ffe0b30054beb1637bcd0ed3dd238c5f0a0f56e23fefdcf7da3909f99e2ea39d715028972d275ad4973d0e8e885986468443b05773a24e3e8fcf60302199906eda057c8640885f68c03d5f0b0de6aea65fe2ea2595079090578664ad688d353c1b42818fe850e8ae12d0d5966a1632535ab8380543ad6807b1bf64a7057f49458320233e6a86edac1363e7b4974dea9d92717f3a0ea518f35c28b12fc1afec5ee1ecea5e648db2f81649eff2223c47a1817d382185c334207e35811ab61af04841fe0fb5e6c80e759c5ede5fb431555f6a831ed6a3f717a7ebe718f8cd50656792d59220822e6b9761d27ffa4c746e3b8386a415473e2159045d083138c730c99c7aba7f8a49fa51f30b643e7fc4a6ef4bd946d061fbe50595740d6c118259cd4919693f9aaf5f0e6077e3e3bd9c42d25ac1dc648f71a97f9cd5ead60d48a4920af7997b6fe803415543f9ddd20ee4d939220ad5b0c881cade019c41e5539fcfacfbb0913210dfe82ea22381c00e7c24f089e8aa0aff1d2aff8ee812700597db7b93de867f2928cfca2a0ff1e6cf967055cf240aa416f21248f09f24fe6da708a1f4e1cba89bbd3f3a2fa81064fe1d9d085c12fe41b1b5f5fab560714f3b69bfdde4095b50635db389f2ddf72ad3eac347f3f49cd5ed1d47630c9e70c2696b9d3968aad6c87ba5234339ee18167dd51c07dedd0a3ffab5d583c712302dc5a0f64f87848836fadc72551ad0231c0f54af20d887bfea9c39ec8e6af0d6141d600d2c26ebd3e8f1a04f3ffba8bf7e83e6f461c06d9ee834a6960887ba6576d07db6c1f91eca7c49418fb0f908ae1736043f9745dc5baaa448cde232b51a755a9fb7ce4362773d89859e00779b8805e315a313614629f43998a4bdefd0e08b46856d4582ffdf0555a5613714f0b391c03da06dab6a0363196218454aa976d1b95c6715db10a3d58e03001c014c9bcc1363bb8ae5267e4fd97f3ee413779f1237149199c4d0bc5d51c108bf6573f88d66d64ea7a8ed046119cf5af3243e2c372724cf22e4144e9d9ef0e771b310bd1ce0105c8cfcfab4b06a6c8daeb811ee0174a771b2ead3ba03e21969f4d1f57dc7028a33c0a8dd907dfcb3817584c63e924a0c889caaca990cabe13d44660f61bfce1803b8eecb7c743c0c689c7b0724caabcd37bb4aa7e666ab251ffafdbefdf4812ba7bef7edf5367269ab6c441c208cbe58f9b0b9551dfb48c790f8fdd85cb8295acd977435e25dc7d0f4f20485e86096717e339de87eb5ef7d25545e8864e54f905912fd609992c7fffd91937a6b5270d5076f305ecbf2a34115efdea9eb3c965afaf32ef381d79da8c38a32b2b71ba32f19d1391eb6213bbb3b38903394987b9deb716ec14531fcf7b63924a9888e27ca9f64f13bc1c8f61db6acea51cc3a5672fcd0a9724e8fd52117e9a99444532d6481368036c79fe4efe86d851d6260fc2e55292df30d59c2f955328fd4614700de5c37f2c7fe38fb1dfead83c107d3ecc35b2988ec993dac37b301c7b81f0ab12d371d6dd7b960ccc8b462c4ede18df69ef164bca625f64b4837bc42613a155a1f2aebd82bbe450c8c2327410cfcfe9d26576e823e1959a14889351641ab3563c05f994a2c4729393907616a688ef332534c269d8ec603cc408e47a5abf15b26ce9eaf4b749c10341ff57b9ea7d83afa6e2b8622f17d14136cffb6ff9efb99a01ce23bbdb65a0d69ca456baf265066eb4e4a1012b79117a9edd0e2577cf15d0770d46e00778e97e27ddca7dac2c9ab4b84f984c04ce7e6986528aae88976833412812923c2f92340b0806e0f19dca281b523a19d9d06694613cc2df9ab2f5f8c4ac5f752cc57a2f87fe7351abbb168b7b8539ec86ba94c788795dae8bf7bda317c7b7f65f340e97c2103bad16bbc82cc5333be48146118783e9b6d2ee44b253688b7c02925f50a4da292636cdd5645167e7e857ce8e035fe3ce2127d55c5960a0f503d12c9893364bf1629718c43d5c75af780b3d2f5fe0f2e61a6717840fca251b457ceee4603404aada785a56eb968bd1711be80492debaee18537124ce6be611512b8a5e9b5a9eab9ccbc5e953165ccfc303becc643138837091b458c2e5004b24d067f95267e03996dc15276a1846798c9e2fa3cfa7ebd7c83b65f0a4adfb56e99581aee781b6ea3d643e653f08fdbbf8a021fd462548fe73328b5e99eac403cfe7711ed794339eba5756e039dde094c05de683f7dfa63d2ecc8e01c94160bea37a0211ca78c8791953eb6afb2b0cb374724c7f43c19bdecc8b220e2a7b9107de3c0841e581704ee96b7297b7d2c6be1dae3407bae6e3e9f07bfb2963068630d31931b99c5ecabb7ebd0caf39bed9cf1d04ed8009dcfbb7658cf922113eb60df7c5f20399b67b54aae1fba68f7d529d6695ab6b1b8229e4a7a2cfb487bea2ccf21208f0729f74c7cf779faf151d8c67f981ba950e75f1fd1568496fdba2dfec3dd168d284690754b06aef02179714062d14e6724910cb9dc995266f7682167cf2f9edf1cffb97308cec909466f0ae200c9385084910b09693043c9a716c530e08eb05f57872c01a8cfa7fd13d545832aa896d60c18b75b25a3f2ed2191c413b762c739061f4870aad46c74f29f1b9a8e11ce13744940c34f2a9dbbcb8b808ef4cf84d9d922c039522e53fc5629e624d223f36d579f75012f1028fbbf7d88cb86339bca1a318732fa492c6ddb62f573fcc02e1453b4cde7a2e14521a0a126688baac8911f23f2d426ce9727eb6e20db631be2a15499870d8ccd5045e132f4d6b84a710493b53def052d46dec3dd58fc09c23cd0c52ffc7656117cfb59a8135df8fd1c33064e15fcbf2b133459beac87e875361e5499bef985cb16ec4df0a843feb845546301275983047a0ed4fd7482890a1506ef121d8e362f28cc46b992147a7c528f0ea33365f92f95896abe8440601389358dbd43f90007546537a216f97a84f996d2e3b129e866e5e549e12015b62419ffe7557e5513cf559425b805b5e7f17e60c427b1384554c78486d7cbbf679d55ed061f8cd9abae3b4e1fdc746ca0a64d8c73a351b242017adb2bca33f81692f1a01932b0283d1e44e19e69555cc7526bca62db9a301122b0b66e5c54195f0d706f4f32408deb2674a6451bdf8f98d6bf13902a3bb9d0c5a486fd65c26720f66b2c0d2355a26b6d3a8ad4b2fcf14f87a6e614135bdf3f9a2d304d9b8d44d05fcd86201c200104ed8fe565f5ecb2e3b4602512ac9dae0cf41f623c89b535644c9cef1e9a29a55fdc3fc97456a8a76db24cd747f8f4bd8522230af68a087933e177a526e623d1cb1d5b455a79b9693ead1f396576f23338b2f3dd5cad964feda6371eb896363f97cc106ad5f5a09bfdd26d04a102674cf764a105b7e5d4530ae526014780012e1efc0833b2827f13141f2adc9ae5731c5a17f3353a0b1326d4ce6657b19ce74d815da302e9aec4938ebb100841eb6980395b055b4aa65d1633675ff5d5cd782e6080a1b93c107ff28fcc7f69df278e9ebdb2fa57d3216c5314ab352efd19d95e0914f8c2c60c348b68f35bdad8ff664898e64e626ef1bfaec25a014b9272fb06c513ba305c728d27922935f3b54284b38adc2d9cb8775793972e676800c5224b88eab7f828820edf46b0151c053562979cbd800882973df9a9712484f21e52649912e659d32a2387c43fd17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
