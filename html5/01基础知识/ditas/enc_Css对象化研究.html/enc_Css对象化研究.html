<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44d884b6cc0910dc1730c3f41b37f51903123d60b26c4ebbcaadacdfb6a57bbea576521b141e21936f984a4275174342e609716804937e3615da3ffb97e6a092b76b433a05c85f0cd7f30d82e37135d37d2e61d9f529d39d46d6485360fe52690f94bf3fa31a643de6165d47c0aa2e3547e97998424ddf248a55a526cc51e785feaa3e0848dc9f6b851395d5f47aaf271e17ae0e73f3ea68cbc7ab7e6408624567db89392255e9dfdc21eb5ad6b2f60dc8bce03c2cdd521db702d931c1eb1999c0dceb114145fe024ea3e7d6321c7d2dd67edb55dd146b66f91aa311788b35509641ff95ca379369f2b200ffc5b006145458de78c5b0f61752a3929c84b2935315ac104cfe4cb4a02edcefb30ed145c2c2a080d4b5c151ebb047eb91323e681802ccf47a6c719920eb1cfa50e11b769eeca344fb33d587e07f960dc86d37470f2f3ccf4a15710de296cc0de271886a26f37f220bcab50608651e892567a7a655983dea3601170525df3c3d6b9702f0c1d5248fec604b0aadf5df6d7746f881ed205c4145b9c2e0c0e258d357293e980f14a40f6e2a35046f4fce1aa2b0928e80c46bb05d32b5013522c80c1005243c55087c09cc8229326d3382993b2b633e0ec069dc56b7a2c8ad6695e2b5d61f7082be24a3ffa42b2ec4e9c3af4833f3896a590921a1015bb1afbae4be44d2ddbcb5856f395108a06b4bcb33a00655eb973dd31e1a1274f065da25a609ca6b2dd151df5d6a5f60fa8395f4fa5052457e94acbd2242f90ed12897df324106407a4656864d4f67ea46ede4ca2446c66e98d5b8115bd7761b6789448757ca1583a42b57210fbe9bcd341d478ea5319850989e46c64b41cac0836acbb392c8030f22055c6fe178eb2459dbc9764c7188576dfb8ee58a6bf15d8c7106983a54576795d1be8e9327f6af0cb2a11ed5cd1226ea98c876311b40e5fe71845acc9bb7122ce1d0120daa8c557ac644001a1964a5100ca68e59da23d18be86f4d78137436cc0eb9e63f699b0e0a015726df82b0bbe9a6e2e29dbb9d32cf5c8ec815f8ddd89106317f34574ea71aa92e6fbd2c02b2431bb3772e18253dee8f692305383872288aaaaf23f33b94c37d95e5713331c426653e35989f9d636244a6d8ae5fa6bd1e16a96153b398a2b7f12863568312d909734e899593ac5dfcbb14afa75de449226e141ff8344e2bdddc7d2af4cf7e62cb3b4ec2355184a4340bba0a63b8f0dd65008047f977be8344d5050f209a15f18266e4af47b48ee4e4c1daec18b6ed7b180624139eb62ac23c0c1ce71c317ddd51ceddf3f2c0dac36ef47ab90f1a7515604429b2eace617332ffbdd53e928c7a0123ddc58cdf8490a012b72710268a5c2f9974a0a907017b85e81360936d76fbcb10734e0479a9e9d3dc70c4cfdf0bc6005c1ea224959509f55d4409a127bb69806571004492c8fa27e928cc407866cbdf2fff45f44d5500d9b44a6262ba52f89f9a96fbe4e334047550c6e8b7bc38b5db72d1a07a499beedf37da97be18c66c72f87f3790a044a4348a4e9c9f50820de18fc864a1d5f10eed50b16f5b3e9f015b6e355ad2408c008eb08af9076d45928f0f1630eca729a58a62286567c4a9833c56f30ad4cb74720ec99215b235908778ea2fb3ee492ae0060f929eebd9dc050c4f3fa5e5a29b84fc95c621801c3185f29c79253eb7fa78dc7765c9bf8085c97e9f65581717bba1f3d95aaaf0e02b5d3fd7b1660a42669e9844dcaa41e2f9ef4042caa299669156bf037b2a2126d24e2811d8e2f965f5288416d9e08ca9617c56d39945879de4487b82f2ba883a9160156751e437f112681d174a02d725b69d6dcd5a2bbfd0afffa5cfb6207adac0187a2871f353d40c48ff6f622f8c196637448def9ae470ac6decc5f0054ba5b9e8a1d15671a75ce37e9c45b4ccc76df8f2e9957b5fc7c3777202714b78351e66fd11c637b3d7c63260ab4a9146181d460f47c666861372696c79b16f2adf165176c5f54748a568f43e65b25a16b9ecbee71ff56a499c94c3973db4f2f67c8a948af4aa19c7f92ebec0a5730f6d6a62c3a21cf185d8b3395e39082c4d9c92762c0616754b1ed91cc5997d6261ae74707ac8c049c209708a277de5c76fb35c6b172e0bd1a3f255aea00d86adf20955b9f8cbe7ebca0cd6a6fba6ac8fbb463086f2b5cc9a82210e8c1a91029ee99ba307d98c3f85d7b9019c37202a8fc33163923d6ded72efec09621a5465c3035da428b94e48276a7abfa38dddd6401adbba9bf498acfc667099997eabd8921a7f537d37ceececf9b33be106f2c060fecac68ee6672e4acc71457e3bf0fc0fe4f15fb24037f4dea7c547663c4f49c08d9db506382e920ddb3f508786419f09bbd8f759e29803fd93f62a8b18727702b5a131c46a0efc834a187f6ecc1f39c3bf230e07ba54741445b919606c7fdffaad3005fed8ea0f80c6db5e8c5e52a6877607dc6295b620fdae740036a64b450c17cb178c4d7d2fe889a443caa9a14e4c7ffc3858cbbc42975d880d5ae092ef8c0ee0d0ceb5f76f6233b29924954d5e46701c93944de9f44a4f1f49084a5737984e331188dfa07b2b4aa97d0dbabad016584677c518ddc39f4704d812f627217223627100e4caa120d2db08e9f0ab2f1f03dd3bff32a655bd952be6dfd02d7e0066774e77c206c8b83af5d477f0acaa03d1bdc6f42f87104af0cae5332487ab131c70757c42f3a374351de0c28814718e03849e55dae8fb53dd9aa6942b746ec840969a4bcfcd04b38544faf587218f2dfb04366b2888444e795ef0078256b834c5cbbcf0db56b5cbe71c58f6c165ef6e6af1ba0798c2fcef05a815b05e1970b71d514bf0a8352221dd83abed319665eba3dac15684afb09ff803b776566671ce363c3720f3ced85f5be9f032fe24fa22556e5ef9af071e37a25161b1944a2e33f5ca2b0a1bf9459357f88a31ba2dea0a581ca33a4205cbb63ce9be6840d0f2f4620e625ef0e128ec39942205be820d951592b93918f9bb6747497e26d54f989e9174ac6842a51b0e74ba32054092cd91d9cd57d606c2189549ff86c6a75e75a1acfa4d52636eeff7100a494fd1c1d6c83a1ad91b9bb87e17adb5e6a21e496db3932fccb6936be0b4b7b4b7c4c8d9cbc8547b46d1d1d181f918479cf834182cd0ff1c60bf5bf8330e069e09eb0878c1cf08351fb621ce67226eade1be9a0d5e035e7aeb7ada36100b944a46a7762630d709eb37a5903c9ece52835e288445457df0b8a4b50555cb1cfcc77a54e918bee77f9cb97c4a8305d7fb23fdb2c35d42b70f7ce60dc27276ee81953b01631e51e51173858dceb1a20dfa28b5814e5c20cbbb019d93074835c9e0439d3981bc72312b540024600f931a466c0f9875c81f07a34df732945d95b6b0cbbf33a1e00574d18d3f77fc3ebd9be0c92ffb884977206db84fc8fc29c1453237f7c9a07fdfa8d597d626efc19e0739e6975fc2e3af21a073830fc31560c6c2555dc37bc57a3bbaa2468b515d2d68216a956422fc1a8721f922a0502341b1f66088e2304c154c5c99138388122dabdf1353d570bb9856274f7d409e80ad7dba28f5a60a741931b4788a2d5f8102f4b70b8e76bfb76df6366841f2044f55aaad9f57a208f5df7ebca8660114e2a4125f3ac27bdba637a0e8faba4e7429525250e1ca52c39d1ed21db1295fd253cb96613ef6f176a8049b3df65f8ddcd84dc8379675b8baee83c007a29717b66e02205c38ccc786965f283e02e8aedc66cffdeca48b2f7fa39f39f14260c90dc4ee815e3a117022b8943f156d4676c6f92c72d3b2b53a9775c784166cc43180fe2e3b8562db39c444ec6d3c4fdc1abdcc13b8408b6b36fbb31f4e28d150c9fd4df8a13dd1428c617f04958bfcc0ba747f4d9da172976a68b0e1c9ec332e03820d7df952fbb9184b3a8997caafc243876de52558f9c352df9919f08169f46357326ea0cb4be992a9957eb4b6f83dd064e3589933a54b60484c92190ae93d708406478a9ba21c756be4dcdb57e9957c5e75ef137ce8cda51be4200ef8296fdcc15ee5038ee9ba767e7edfa9426aabc75dbeedd6f5770c42a18d9794e5e05a3f35d3a2045bad65ee4d74d48a15866f586cbc5fcf87887e2a8ebeef2d4fd1856231877cfd2660965c2190421c86b77ab3f88f310b0ef4d1df8fff4aa1997e8468fc50a9b760174f956310dd8b2d834e1220aad99637984312f272adf58f032ab65144f8615a9c3ffb8235db90b6173bb87945032f45535d8de6532d9e48c902daf9c2b811a67b8e359b64d2b8a0d246a1ecdc5d9aeb989e4f81f7a285d0fb671ed567a3f77c46dd575f1d36063a97f706f271cb2a4e318ea6b964988a874d3b1eebd3cb3cdfd31f4c91274f193a1a980d1a88b333be5136e6ef3e6834c553824c817fb9dd605119e8c5017d5be6b3194d85d1be9f5b7638e3b9214f569d927a9191e31de174bff272d8e8d1e9943aa00c4159bfdad57164befe03f151a51533ff7015bb678f13d208a56bf2ef9bfe31ed87d9504392af693274b22bc78c00fcd56dbb915249a0c0df87c46e6d317c3188e709ef8fe7057b15abbb1c89b5d0915c4a34ec5d788f38f2ac589d0071cf19f5ed0d833488c3e63fa85438b8c01fb47246098f8092931a95470268dcded61e26c25d843e8421479e53462ff2b8103fff1ffae75640f3f65e9f6fde0515fcba7c6ed09587b55eb2a627c78510000bb6045fc3671d29d915cbc872a581fa70c2039f8db71169207c33ef9f4d8f983b6f2c2b3854a1f95bca15b63e43afd9becaf798d759432e00650d4f587765ff5beb7fd80cf9ac7802ca65860411850aa6bdd5b8c10564b7eac2391f15525faddfbd385cbfa2f51c435ca11047b541c94e80917aec01023fec3ffd2ae4ed3360908a7540ac586c0ae85bb3ca8f390be5f64493fe4772eef0c682ec769ab9ecfbecc8ba6a8a50eaff6ef433212efd426c9b8678eca233a920ec02ca19d431fb0238fde422905ab5bd0bede2fae692df323e04e8007ee4ea9a47efb15418c6edea12ae532e9b3d3ac8e438c23ef7f453270f40ead5ac7c948af951b3778bc2cd48c37e83feb66c1e93833b8686a8696e76f1b7ff78c90f7e622cba15a012e76581f8c24e1daea1c06110ee72ebb66588252a4cc41eb005517d610bace63579874ac6100b00c7574509a20771455d9d6754cba943ecbd3ba618bcd6607436d18ad5c9a7d07ea17eedf8daf10f4993fac1a06a35743af63ee587b07febb4e0def86967d004d79bf4b3d97a3d18e451a8cd96495a1c123630f8dcd44554230ed43dcd15f819e36a3d0089aac4dd8245c49b7e4f4cfe7a8afe76e7d80eef5e46ace4c02ad4ada7555bc36136c274449621c708b877ce284945e101480ec46815755c9b2b1aea68b1847c4aa6d6acd537b5fc813ac1f1aeb7823ad3a115a2ff3a29d92b1634dcb9c1caa2dc79691f18f5afbfdd21729192c9ce3a5cc9236bbf8f62cbc2cdb212ce897d82541e81331115987fd74846e8b6b4d1b86247ce495ae51643ac7ba5bc7a0495578d6a85610303d85f74a22e32a0967614cfbda2fff8b738301fc5b3135026c9dec0fa35017d56bb666347d7529ea18aeee7f1d74c0667d905daffd25fb6d0923fd7488a51ad6e3922afd9679e9f7f9416d898bb7b44a1f68599b5461611c5fa2087113ddf6500b4cd4c51ec8e6a890dfefd95dd94c2eff206ed8b08a4bbafc43072354203fb550f9bcbdbc360a0d3c20fcd77f456553cfaf5f3feeee272b4075c2303839a4ddd865dd22b1a66943383cbd8a55ad7bfca5963722cdc9bb26491f60825f32a7ebc8e313d600a354f6de6b849382ca51777106d76b98735fd731923ce6a1445f59a89a9a50317817712f48f0f1df54c7da02b61e2d71f50f2ae0c3d18fca88c464947f9be2586ef47468326d7db498273703861adb3c95e2ace5690436d3ef2dd3c677592f318b67ca4528bb361d04f50d310ff7627984898fd459978f3d9f6806a7a5739e1c760fa2b7e3caa49bc76715985a13ecd8104050c07ded9e3225d2c8aa956b693a1ee4c75087528095578a289e56394878bce6f1cdd827852d4c982c5e651d6e75d4d6c99046d44457662ee94df4250c764c2438f3733b0c200cff242cd3ee3fba7bbc637d3f8ad259e47a072ae8b94c17ae83e9493c5dfd0d8830ea2f531e5f67c89f7534e5f717c28a1b0ebf6d40af7bb605f17a4b02fef56540d7437586fea538f3d3aa1d0bd9048c2edb6e4db8483d4a339ee9af45901889d16a65194072ba10df1c4d437b541c57c2297a15525e44990320dcfa0110b66a5ef3d0a4ab633d19e4dfad10c4f0a33345eadac23f152d31243f72fd1683e3da4ceae592d47afa93c7f8f4f7a6eef294108c33dfd8114c18b7c9a4b25a702bcf2420d36b2b62e29614b28aa30a46115e7aa171e5659957794ec634c85f4d6afb99848cb2214840d701eb828b83eb3c45817322c26bbad9be7ff12f5e2b3e129e4eaa1be527cf1c4e507caf92f887e7ce80cb14cc1fa850bf47378c6df5b0c05a3b41f9a6095035bb1b96c6f4f1feadf098d50a48d9be0b857a9d04c32b607d702c7f4e126cfa2c0d76201b678068500b633cd621d63cae3737275f1d2f92d5d1728cf51eaa895d582aa6ec1f40d48554a0b3ca42ca08e2e60c1441b48ebe90097d51803ac68339e997c8158f94a60b398f353972e9b5db9d6137732af2b44c6efbd4c3f110e5235ec797eaf9cb3b09a7f9ad3397c75cc8cd2bbaa32a3f9a047afce7273727e09e490f84fb5124cef6e901a57a8860d14a66cc689298d8769d1c4f1700cb9bcb740c9c1053f2d1082a96d037f64165d631049124b021201f92a5ce58d09fe3b7d4c0a1bae0d8b837a3454f2f610ba52ecb13b212dec520090701875a1038f6a3badb0a0103db0c320b310a9c71217ad42e731efa5c65eeb1d57eb0f9e2c6b0d00d8a2ffaf646b8e84a0d70518695255c8473291a32ae9d734f8b0df8d256b12d9c44bebc5e369d7de1754d99e81a86946637c97d154e38c58630b50e6fd73c16e41dc77aefa7558dd473a34b87ef5882b2c82fd8749b32e2ecd2f9cb6570229a0939ac162a2976d2532e9068744aa5b6ed790bf2eefe136b72333db5209be9ec23000237589ba37f02160a2e1ebacc596b452455d094b3caaefbe02dc59849d28897f315f9d3084d43540f0df3366925fcaf14ac44d5225a5334937ed2fa3c5fc2d9a5fd7cae09773410f8e718c3fd8b8d2d21e5632ca3082387a1c6646145e661ec772d699b86d0aecb3b175884fce64e137e6772879eafbe2bc1b1c773a32443b7c56e31dad749feac9afd211d5b8c9e1fb73bddee5169a984b50f94270b8886deab89748245c532a104e380f13e61936c88f8af70fea56cb662512394385a8fad89d0a3d629bee1311d920b585b5a3732f5d056d624d8a89524cc7665456b56406ea0909c42a6768a5c1bf19f693bef09ae05c1165750509278bf965a37753659bb0d443d7cfbb7ff77a3a61879536ca50af62c8f959ae4a72f605b7b9e19de61094e8a244bab3196835e5bbccf258a5ec348716aa65ea49f164da166ef14d93e7727c47fe8cc8e06cd40d51fb9c655051fd236e5727c7a926c7ba962a89330e8377e664f26f20e364c44d58037b735bb0bb4412a6b10523c039d1dd8e89e49a0af065cf9367be78926d84ec94c84af3d48d8ea82a2441c6da1594594efad9569fd77b1dc6f9cdb84348fb5051a3f5df5030ffdfed0bd59d169aad42da6b7daa5b3096666184e04bcb9884fc2a8f4044a5c0f4343d3daf37f51cb5e406c93a6fa964230f99ab3fbcf825e8c6186772f2e06dfc6157592f9f0d1eef39dd601abb0a751656f0108f25b6e6ed9e9ec7839a19a71dc67a2d5dd7e6532d04977f18b3dccd125824f30a5e0d6854ecaa5e6fd229679d2be5049538d595dd6cc2f98a01573d4c743882cdc7814e91b7e28e16a02121f00b319a4f0493124963807f9615f7bbb38e1120cc5f6df0ccfbaffbed976e9f2fad2e3edce13c053c154fade590f2ffd6325477a28d4251b5ee7c0c35cb598e0d3e9d577891a9edb6b0e34ee21b8274f41be9c1bdebeae2e68c0c8ea7cf194e010bb7086a4f6acb0590e7596158bf840e17e7ab789a4495a0b56a5ff3dbc8873ff00309a82ddfb0865f8d3eb41f239369a7749766bfd3cc2df0d0f1f2c0e3091f0c0f08dfbccaa2f85c2b7faeef005d14a46b139a0bbb22a567ef72f28ca7485f5e3d052ddfa03fcb39c627d64e57f775a9e1e06fcf2f6eecfa6bd04042b37c4373a27bb8c2272f9c675fd9061ee5ad02480d53e3e61ef57c26c60b1dca354aed4deb0ec28a1c43ab58343b778c0c45ddd42cb8e925e83d992b2aea0fa332ff631de6fe394b705bc25c689c92940565b8e00019ac6e76ad134c283b4bb4977af1dfccdf30db138d91e18de901ec8ebc27b6c83bfe976039b85c708dec0202c4ac97730e8bebab63c99d91115346529d4572e3facda2c7f07cb0cd342ce0e8d082a194c34b80be9dbf48a59b3d6ea75d4db7238adcdbf412d5f793c8b73c06d5ca0d5eead34b47c9f641462f574413aa5a4c5d67d946293c7f2f37fde62d7e888d163f29b37e113a778e3d27e2a4baa1ca1605d1fd5657543d2d14ebdbe07c37339a93f0b61076dfd3b45f1e5c6ed15b1748150e211989cafdcef6dde673cc6edece1e4a970e0266b5abedccd030fd29a403869f335ecf9d5428eed2a0e33ddbe1574afc074f558512bcea5918e17fcb0a28d3d2369f4dd6c589c55d48afebbc92fe39de48150fd78654bcebf6cdf422ac785352e5360488c27da5e8d2513fe8692437e46870d7d96deba79c09c19b12e9b82d17bd8f8993cff7ab7e56ad02ae11418c97e68b1e62a837fb1c27bb8ecce42b889968bbc73fb666f84a13245a4d7f5f0a3517ad7e850380d46fd5d7d91e3247e00eaaa54df6c9d7aeb0793f9c50b3868a92c17776f7df20f361b7bd3bf8af7fbcb697cf43f3ca858e594df0331983254030528c9d94dd0530473d58e698ee18ff4e461e0967a22d525ff978ce45d618d57701e952d484dc84d9f1330627cf2bcc252fc3a281bc67ba61b779b18092335de922f0caae4f025aaea5301559cffe724d047ba08825ec98436c83ba668d8daaa2d86ff0f7f2dce471dda77ba5025588d92f04ef7b7ffd64f2c1bea3f31b58bd9e415b3a60a98e6fbc4ae857a1d6b5035209d9676fff5331f71d9eaeb59812dde687b135165d3e1767bf9b0ae925f35f2a7cc4dcb0283e2c189185e5669976ff8b5ba4ad53d2c636e25e535c973d37a2d01ab6a1eb41a876f773ffa7f4df7b9b0fc358e2062e5016de1016cfdec21f80da9b9ae04a72e9bbdb19731cecb626f00bb735a4889a07c415127e316b75e6fa2b8ff4deb00364353ab4d24a4a4f2a0c9130ece0bcd045d40e137e1cfc273d130b23b1ee2c66b1450d009c89f3b7e6397389979ae314269b8b24a1e2a844b49a9fd669d9f698faf65dbecdeda01c6ff7897a91fa0b5bb4742e290534c81ab7b10c8ff60ae62a4d9d36e844e6511d606c462f9c9b8f980e22f4bd032266d6c7e6f3249e27fb0e52e04e3031b7b84fd03fea8ab1d6a8cf72a2700b0bf19908397cf28997dadce8bd4a045419e1cdd74e7088","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
