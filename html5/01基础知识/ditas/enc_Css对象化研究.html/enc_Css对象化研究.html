<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08f64de6e1aa767ba5f88c9aaa51f869651eba80c2897e8d5877e61d70d502ecce4c1dbce9a73ccd4549ed2d9115e2a32fb3b1ed7473c5c6805888f5c2e002bb8db174737548773971a5134c4758b906a529d8b9e4c5ddd9a493aa531b7f8c66261d9256e8c982fb263186ae4b44480c8f0e30145c301313c504b3b79ef62e332314fad2fd722a0966b9513770400d40e776ce4eea1fbc87c0a3ee8c2659480a451d463d28335b781fcadf6b4eca2524a0f70952fe96a1c049f1a5323a5bf1f5900ce428bc8a52c46d1d141be63f127ef6efcb352da21d82cbf56a31cbaa4f9ffba688983afd776aab6cb257475db0c0ecc5a37a0b12b9b99d058b0a9ad03edcd46a72ac49597f195074483d740a23e949d42647bb149f0679979b353f641786df3b4f322be0248e4ac83fcc3d326b07f31e82d58fc3887dfbdf2f653f8999acd8f0f8151340965babc6ff85fc164f2005c2e938fbdb844a0ee20d78a5ac610dc43485c067c7e20dd80cdf26e8e3d1e32885bd6eb5a3dc6ea29a3c6e283b69151911c33353e82de7ad8904b5d921c3fb7046bd16037c5a308154df7c5032347b590336d9b7cb624643b5a66d48f8fc3e45a0e4b4a783cfc3a236bc1146df71f78c62131710c1e28a623f354b44d9a8dbe553b883a1c262aa3cf2b5685b08017e9d2a6d432dcd15cc15d83bb9591300e72c2f785864863e09ef2819c35f86d5bd9e3cb86f7e3901ab39bfe8b100839204442a10e986b162e881e73c24f56580719c6ba46d3a81a3e5cca0de93b67468f1ac407222fbffc3f4bf6a1fb85cdf9bdf393c7cc61e431eb75b64d79d4907bd1877edab69fb5134bf0ffa4123800202e1df0d0b2acb72b2d4960063e0d76d4a8e07d2075eb67e7f1f2db66817864af79ea1398f1ae46ca39dbab771d7888cc945ba5c8adacdda36c97640f245e23e3df69ac581e0229821bdf63ee00048d20c032ad1307d9d5e71e938eacf23844d6d763da1469045a14cafe816e23275edbe53ea605c1f1999b14af26f7a42a7b2b5cfc432a6a0ac3266ca9b087318728a5df6c930f72106b2c189290e1e2d9c0a9dbcc1178f0599192b8b803d4b55628226d61b0dc6c53c871cc9abc8fd34dea61bb63289b42f89c9b5d24001908a0750c33c541d559fa4057e03037f3f7cf2cbf43216ef2f61fca4fa858be8b0465bafc6efe7e64052415c55cf378f2843caa573b273c1e9ed166aa85fb122eadfb3f4c8043b8c4b34ce2d4378ec4f522593b01cd3f8fcb002db0e5b79f7ed126058bda1b8c2e72c646e17e7b953cd831025889933df6fdb55ea857cc0f62757aa082bfe858136198a94c872dc4ee6e70ced1ad8e3d88dd5374a691ef0f1f4bdf54bbd9b35fa73a8e2e5735eab2211cce25f9b0aabd44956e0e7fce5e77ff87ddd416302ebf90ecc7bdf2077adb317b294c84ca335628c33b12a62fecc5b03367c7cd3e0d0945ad353454c4b2b87ef4ef4019f9ba8b4372a356f21f14c47238b761c7eae8c682c5c9ecebc021ca4db99d1903b29ff92556b9a385de265ca93df8456c6c89772bbc50e099ef964dd4197f46dfb9f287b7fcc5fe8816db824c7929235c50bf25d188b0092c12112d1fbf7d83c0f52ee220e7dfbe7f9f72cb0f3d5fc0fcbab92acda7161dbaeb711fe806c06900fa26b4d9b598bd89f7c7639bad901f35f4723edf9d7c4990e50115ab82223c6d35cdf12089ec67e3962d35d67d3dc323fd9f00c2c238cab9f16dd27f243fcf957dae488d3bdd227135474ecb393c62e90d5bbf84d2090263fbc39af18e06f7459f9bfae4bdf47132142e9de70676f54f40f2f953312b445020759915dcb161d9417d283987428d34b30314dbbf126326094735964061c4b843397f0b5638ff71832843695e893e8218c8f4e97f4e19ac9b61ef5e88538adf1c84bda634ab64fa57f1334fea59b1417f15658ef3edfef7a511969c2fed8409a482c4f5b5ac0072a20b262557b7b9580743d3e2560cea3d00d977b773f15b2e0f9deb94df4e9252fe10daae815ec9799a714f949997445027b91a5d952a78ce57c1968c08193c24234cc28aaad76894caf7771425a99337c0076fd0a45279eb02e79065ee423cc4e60c74a7bca41729534d3c8572ac9cc1e8ea344db5dcac545fffcdf6bd02d34a5fe4b152ca22bb851f7fb197a79e0a7a9b3313508df3539a7b560cd5f69175cde47f3e41b9c12ddcbec6b761eb37930061d46593e3c8a99f7e4bdf05c2872e09de1914380e8397960cc7d45f2cd496e02a21cdb74286a8de231289d79618ff080427f28ba72bc6c418a761ac27578ecc14121a851b15a62306c014d5856f4a27aa2cfd9b6b42c66eb283c56a7d61e7a3565af428eb6994c95cd0f236a7f49289dff9a1ffd12121072b42e7d5c077029dc9b69bdd556d8aa0c8da367570092776b52c02ba2b0cd389c95501235aeeb1a1e5dfe0a997927ecbbd5c04c765bd763926efbc53d326b0b25a00879b5dafe702ff11aed83de21709e755848c2dc7b96f26a3933b2fa3350744a93bfc0d11d27f9122b2da54633594265132bca0e1a2ccaf73637113ef62a05628fbaad10a83103638a46dcd3a4c12270636281811e39090451bf2a247c48b71ffd3a73bed50219c6ad84b5ac8d6fd20cfc06c63413e558f08c0578f2bbdb810dc7c5d3f77a5a3226914d3918fd0ce29bd37010a0c1f84b94abc84d99faad0d6839d2c05a899dc2724679fe59795249d6fe9eb49d76da912a4b18425ccc1be3550b5d7d71f258e3cd8d4680e63a67ad13db5c9694d59a60b9844582592b82fd869f04d1b6c089874b3289cb2462ce3623018c8f5f484a6a45d5a55d91272dc595c952c0e14710e32b11c20b90c8cd9aa4a8fab51c90400f55f551c7fb2578ebadd50da7846569cdce189bf986fda15acf7ad0c197a184b865778aa512884981fcbc64ea063edcf5668fe82f96605b1b0e1b126f9e4cdb7dc445dd9b7f27138fae756b9fc42af1bbe1584651946413bb67a7b5d1eae657f03fa9c34f8dea1dea2d1244201c2b6634e912c1d5ccc0dd218712e1bf136c1cae219fd1d7f1d6d7bbb7e2dd627f872b5a56d401ca8dc44c1b149298181eb96ff5e55c3b1ecc0d56e9be8b88889b90fbb4b34942cfc68b375a80258e7b0ba1670b825964e9ce672b943203ac480528d41141770f4467fb5da596deb689ea3e472acba1f628b18da2f863b3555f725145aedc800948233430a70f46b80ea204e10c2c464f125c13d24014228a654aaf91d1a677cec49bc63eb3ee564df9291fe19db03060f6df557378ac5fe15ad0d118ea14489f0970c06610a4d602f7931d9ee4e1fb64f05da755e1c0080e4bd7c7e2af7910de6f80322af1296bf2cd4032f8245edb6440d9fb56b2a84e25f45d3edf7daa29dbbaa807db7e06c696ba730b06b14851237fe40191520d10d9b6ab269fa054929e90745b431b68b61fd2b0e290a7f339578379d11cf417a0a200f7cceee6a28ec94679222eee93f0f925f508ac1607def3a680937c062d4e325c15e867bfbfe31a778c01932593e9f3cfb8e5183c334711a3f195001841fa439ed3dbd06ac86b254200fdea07c2acdd8a709940a8147f8b70f32cd0f0fe85df84df5586c28ef7188cf10613b9f019ebb3bb3cb81f51eb548f3f900aa1fdf4312ff8e5b9b684e2182e2876b67e3f98898646ce6eeca560e8dab61b63285797306a968f3219fb1cfaa246d25eba840e8c377b8ae4ccda6b3a72c3f799b7d8e0aa15765f04d2c33e75f7d6829416dd0cb5a2b2dcbc76cd24128bc131159d465e92fe408b9fd4ac454335faa62006f41db15746f01a4d75232101768f732ba01096cc45305de425b8169f92985615aecf4216c77997a9c0596d9570f59b5dd9804048b2627a9a3b97855527051a97cfd9952f113da0f6605186eac618c795149638c46c755da34923221de9c472c95d0f1db2c7964a2505655b4d91f0920b5f5710046f1fec91cf24c5d23c793affc6e482bcf6f85c974c4438ad502d13d9f29b87920e2105c9618114194e2875c42b235f88d1506a91f57c3d7700a6c243232e320038cd4a63936a90aa8d579e4d4f897d7ba334924ac9b809c321de41289d996bbaae8e5df17ed3bf34f64a986b9bd6366fe8955a62bddb30fd666c7fb5012b62bf496e1478a76320618ede27d84715bedd897a54f48894fca84e2d347a51cd5cae7ed37fd5c3a7d0695291cd160c50bb3380e94d10851817d9d53b560ad981ab6f3ea9f817a96fd2a84282428bfecacb8b23ccb753b39ce5b8f15acebe009918875f9216695dd4990a210dcdc5a9dde75ce7a50ab1fd42807d6ea2da677cbe37ad631d10abf235ce5d4f7232171e3ec0411ec59db1130a20179282d63b9f11f9e0cb672470d825d67f359c047303508722982db48c5cb09a80d5f82b8cb578f36a9c58e68fda7d048cb4dfa7019bbe628335277f6f6551a8aedc3c32b6bd1084d1e6c40654801942b4c42b4b2184f8a87d0c4f4c660557247c95c49c2fbf8d0cc06287ae86a927c9ea5587152b9be035578909011e033859964061645d7803fa00f4311fa2d04a40254000aa60caef58c3744efc5a00aa39d7a9eabd1d4264039cf1413476db810542edc11136e622b079ab82f105743193e2c6c46315e44bb63152a10b7c522190fe88cc9e9c172a5a09ee58efbc5f850662fde11cd69c7688c9f9a99a7cf93185f3ca1481b2973f93e3d40a768a9f733dd5245e805182f5f9482e1d05a4d799b8cd57d6d2acda5fd6aaf209f8e6da390dcd10174fb6d5bed50e9f3a568e3d4629e7c2b86cfd11922f5f85009fa05f1b5da9144695720d4a5f4cc457b48c33886da1ba0244def13df038fd5754f805feaafa07b5e670d782c9b357f7c94098b7c43a7103a19dd6cbe383dfde89af19a733228fc241c891545cc6ea52dd868dd34e9d1bb4bd14dd1f57d741f655d037c5f21e74541b4e09092eb2ce4cc460d02eaadcb6a94c85e466ecd342db8485a8263d593e1b478591e97ceebf570753782be30b8abc0df505cec17bc83035681ac19058bdee56c4e84ca8e1ef48e7d43467b60fb707107915e8c57361d9cdaa9c6ff3e23c8d129a1ae320d43a41f62af2350ccc4310197a57c4935977c25fdeba5d978e5224c2590252c2e0d81e5982554a5ccda12309152cfb96a917a2d1d9eb348330b00b07fc9a2bc502364928cc400f392f64cdc89bd43912b355fa208c87c57606ea2457c45cc9163ed2ad93dc0019dd01fe6eea3b52e93391d5e9d29c0f343277b732fb80f596a2153bb3bb8fb2914be7a377ec9d9694177d0fd9e3c6ed9c4e1178cdbed255fa8a0e504472e32ed9055886f12bc25a497f8761744853df0bb847b6a9b411cb0a58966b4ee3271b9a49c8a07807ea5fa565fa35ac3679624377f710a02229d1188125fecdd4e2fa508831f8e6c3a5ec349e9d0fb66d4c7a357e7af6015c142ae183ad207e6b4776ac3b58f0c1133e0f283ce5cda3c9ca6ecc17c65334790953a35d302994ad2c98ffb0b2e1a67ba390a358a4ec45b8facf68ece6f87dd6a0e47235643b3bcced112737ce9d4906dc059a2884386a170cc05f59568270e3647d2fcd431e9942ea67e03ff3bf1b116750bcbe49de212032790b073398502bee493463cd096dd06a54128b21ec228290a1a3b774e22043f92569ed768f89de56c93265cfcb9242c9c01b69ab6652a8f65c5ede85ff21bfc978376aee35e466bb7ae645e9cee8dc5163a93a8be77ddf6939e4e0de1d07f2d4f50aefbd23ae029eefcce17d7b2c8eeba0e5b18c934a3b6d4776f02161f54caba2a55b8b4ab901cc2693fb7a58ddbca8c27eb770634e8325d46acd1eaa35d28e95a26a01b7280cce2d190e352fbeaed5ac9fc4852e460b8e1590448ce3a762eff1364d960dea5eba90ec59ec1ef490b2d0c9c50db12ca49c37bdebfdf1d0c2e2bfdb8c0997e85791725b1bb741c1b99ce02537505c64f170c82ee3b7a5a5e8b577784f1d19b00074b859efc061d7483f935e67e64647ac71213a3316cb839dee78de29732e1a39d277b2c0f6449f8089aa517580c49c32aa3e9b12aea83e05682dcfb064e1e4ecb5c5309b44d9b100ef91c2d17fc5a12abf82bfd6bbf3f248c26d15bae41fc509aa431062c4770237a3e86cea09e607052e7e57619b655da544225b7babc8d4a94c85289c081968d6090d83da7c94b8ee4bfc8a9829e7ed4f21253b5b7d513bfcff717974f3bd580782d51e0d6263ed1ea9bdb10f7a85b65483f7d4ee047d88dbcb4a7eab1a0a67750e8048729a47437d91dda53e1254326e0fd9ab511dc3a8c04cf21024228a29a10257a3f15dc4b5e7dd94e8a70f1ec3531ffd85f04c57b3e61c670fb6293516f342080b613ad4d57a84754b8e62f772eaa59ffe7a466b4c1d33499dde1c41a694a5b95526edc68827601217f7e2adaa0b797fff745a81ed624e5ed7424482e60331fd07b78e725cc15c85b6c4c608b9afb0106fcb8a68dc683f290ef982c64cf0af1c3a2892886fd377760a5182b3b7e9069221457c22f9bcafaf5006296324f5c7c19f6c2fd343841a9cfe6a80566dcf78ecc3b10d5816ae0d5ce02300f6de1616deb15d73a35a481faad7e1aac06311a184d734b85e2e6393836af42d714187bf8dd2934eb2f09c2419f75fc82eb49b0e5ef81859499fd68293fefa5154240bb41b5d4dbfae52793f7a4b36b276c48751551f6385d3e496765b1f9427d59b6283f897a14398bfa2aa4515f36dfbf14afc576f5f7f4ec6b7084aee1fda542bd14f0684721014fde892d13ee9b31e0953fc167e6acf603511858eeb0aaec1f382e55534020817a8877e84c95dfbd3b41373c0771fb7be8e49ee8bfd58814acd8cbe993178b1eb7e05c28943b885d7ceb28beefa9f2f1cda88cef4ad2ac69c8ec3e22c9dc2b3b7cdc2362a2d9c29cfd3c6609ba83c04bebd77f1dd6029c4b334825e42b01846d7171f7ed6f6f1dd7fa044ceec8db60cbb7155b41630dc1d56fa99af91ec2d8d53e7d4cbbd30b385ff9512e32d88bf1fc37bab58e9943fd225b32be189b67fa4a493e07efcd0a7cc418f365d1d500cc6e2e3c9f875cfe6ef63c43ade26b66767a7420fa6c1ab62185a2c306b3aade06852ee18b52ba8f9fb70afaf8e495aa6bed630685331c37b8003381a5f022a423260980f73bf295a0bf697fcc652b92676172e81be12f024fdda04d5b139d7686c34ed32b9e6f648ddb23452465b7aa83a91ec4b2a4b56308d8adec03062458034c6627c5baac2f56be33008f68e987882764e6853e33a8504ac1a27b57fe30d9357a489e8a0fa3317a9974fd39d91421e0a867550144274e637b026805736f41ff22554cc5c2395affceb8455c71d72ef481a9408b5796e9182671ad02a9b9b0a7b5d3b0174f09b316631e3e6b570c62c5c5af853d56ed4b51a85b5f8c20e8c648d406280a39e25e810ab49b98417aa020d367f116382d7cd05796424a730808759a02b1c21e5aab571b47b40d3c050c27407e713afd1179db5627e6654db2334ec37a063119b0e26f00d9949d9f3694ed83534da504d5fa39a688ddc26faa45f498cdabfa3859a7e9c9e0117a7a6576d52ef2764020a55bb815d260ef146981f64cf38288245f6aff082a0cba059eb5b3fcd5ed64b76a43e6e6045b89a93dd68185b706e32e6cf1e130147203b0dd1482a63c03d2d6d03773cbd1b47dc48d7d59a30a4e563997d29e47765496ed13bb2796196982884d80d0e94ecc9f6bc82556eeb833099adfe9e387a01614ed378cad3134903472294755f71a3b1234b0de738e57d713d502cddba9342d1099d3905b1cef5580c42396b0bd94dfaba6e87fb6796a4d11fa5884683446aacea5c654328a9ec9f4af84ed1b4ead03e7ea8ea8b2635e30979eea1f3756bcaa38fa6e12d40854c04f53c73c8a0bd2b8378ab1529101a03a275c7a5a46a05e8df08e9694968b8765703f2d9c8543e1b2fdb7a0eeb2e49366a5e7155b34216c7aba0a4a32784fc198fab6be7657d80e7983bff86042e89e7cc92b80dc5612f97fb2a6668327c119dbc31c8f9e388caa7d74d8f868fc1b63b4a32ed03b7b317fdf9d45b2a2059abbcebe0ea2c1592cb08ab7659dfa3315efe71b7fc9b99d675f3b9da263334ffcf31f59a01c8da8a5fe9d487e5b8f6394afe13ad88e4af29764166bd1a75fb7069163c2acd80d5d32e470a0311f90c6f646032016500656056cfb795c317573a65a975c7d0877863871a7383a4d2c65f183d223fdfc0668f46bbddc3ea2f0a1ad8fc9c358aa0ce433e07d953a7a5681d7fbca8ba705efc862aba1317080463381746785863b72fe57d461f27689d0032432826c37d400cc78651ac787ae49ab10121cbf185eec2149600d5ae132c10dfba92c71d6c0c48f8b57910dbbb809e39fab1ad9052bb4edcc5e687454a26c19446ea2fada43e0b3f0163f3dd8d944c5eb265118e90602025f0b6a8a210dfa8b0b86171bceb8b292812a79724abb0d3dab99f8caf0637b12d39071df69ca5a6eaa5a8af23c8820799836d4897ac74e217582794e2b986b342ee39d47aa31471281ce20d7e886627ab0a59e65fc805be611d933f60d18ccffbcb63c2522c8fbd7d6964869e50f185f2015d70c06fa4f12a60ef55fc52651a9c22e45dcf95e5f8e36ba604035745324d2208a9fb73d5c533e08ccf23785c1c5f21643770e128c81c267547569c49a4c9896830bd428d5feec1b1580137c483d2f4b6f55ea44b57775632924960762a05851808a8cbffb41de77787d283506dd2474cff39f222efd8bc845d17a046b97be4f56192dbc20ec09cbb4ec5ede94accd1eb0c58cc0b1565b785542e74d06b8ca827f38c4d4975275e1eb166225837fa78d5e44be448e03065dd61bec311a824bbce683f2de676c70d7f2adfe6619c5862ab17a6656ffce944360ba8143f7e3fb11d3daa1aecce8cf67f0ff843b408df69c7c4ddb893ce31621a9094b6edde53725327f7a60cde6f785382ab09b70bca7287e211a357214c1a27731af58e93c73614747061959923b9079470406aab4a970f565632edcea56d35d4bd73466da4fbee90b2bc6758d6890a80d939472943d702ff6940c269b5b662d698680b702020ea81fc1d41215b2fef509c87a92f51e739dc3a8eb2990bc17789c10e9a7b0898441ebdceffb62364864b8a11ed6eed9ad27b9955e32dbf1e83bfe3b72dda108b6f78d0d752c4ca96f86603ecd4a8864326a1f79530a458aebb42ea2eee882a937735d462196190e6d9bd2a8d20f9033fcd8c08026b0f499943fb34fcea43737dba37138860859c60cb5d957cfdb5c6577885d1b2b06519ae20f48fb93a31dc6e06e5e99c0a64f401c29bbaa4c488a67727df3020b80b76b532eb3e145ff75e4b6b15f950a1456497222d5cfdc7827e34588e252da460d94c30e976bff52040ae657e1f64227bab92ac941cf4689f40982871b284078400c6c6398e0bac47f234a589c8ce93d40190115ef83eee25530e7013347bb27e512e05c54a55f1cadd47a72521c37479c6a4718433e5ab39ff5fc0b6f59f0fff4c72b2d0c3d97cbb6cd80dcdcc73c2d96aa92b7e093b45d02705c9332f6be2999b0a458ce821c345b4f5f34866a6bf1b4bc156b7e86fdd54156df87b46e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
