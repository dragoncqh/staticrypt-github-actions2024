<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f268ddfbb384e7e13d815265cb04294ab54f05ef0ab3f31aaf03ed021e9ff7625e94c57d1a658470211a44fe5b357db5c7a53bd4f68018918bc06f66c8ed75dba719e7dcacbc86b42d875faeb84449c590c34f32cf733110e74a059ce531dd52e91fa2d3e3669fc57e24592a59f81a6835bdde4147c8b911fe6089b447e3678d53aff699546281c085e23848d4b5a0ca5ee8e5feb97c8ddec812d2c3e9fbfd216ebb7540aeb94c21404ec11a9c12ad6437b7b0a9a89d642b5d6ba2eee4c9b0067155f1eef7f0d1d67b765690a0b0b8960c380cbd06d77cba026cb3372bb0cb1143a8a1d1227b6c614afe29e0a012dc0c37833d3c4e146c56f3ef63b3e09eecc6582daea30a3ae94399aa6d55755b6df03fef40454e9b54263108f42bcaa66ef430dc3a5e602552403de3003e61d2d4904c0bf01e20c9bf6f8ecd3f3ba7b508e531c0430836c3aef04d01ce8024a70ea4e04ef27e31294474e65f67d836485773fe22caa09d78f32afc148a3e675c93c4f94bb7163e65cb2d851bd236f2aecd59c80417c422a3d0462a6ac513dfa7e9d6c443120d3deb38e476bd8ac192459bd103cd4ffbd3171d3ec1c40b3e9ea70bbe64b41dbfe13c28537673c62eafd29157be0f0a4e0c3f9b1a7a8b72dcf3770bda615b33d99bb18de056f1958ba41feef344a985355b0720eb925298a818df8262fdd5d610471bc2577c28e78100626bce58f07b02c80c8428ab80ca1986fb9f4c237025cbd636ac82151ac14c3141b4d948bf806016e2b16724564848f35c78a33c55817099bfa94b0fe68b9c14c1d9cad6d0a334ffd195db0cd50f86d978a9804d9f278bfcd987373c2ec32b0ae10fd62bf6f9d7b3afc7594db7a9169c85c9bb82e923d412da97f7ede150e7d042797583c90c876ed1c6fb4b7a5ced7053dd445f9b62134cf1fd2f1ee446a322dbccde8c77b98c1f3c3007bc9db929e5de953bb05e59ae714f84efa48aee1cfc097dbeb2e8ebe19f4d39654f048a2a57ad369147ea11ef86a561d3be0d11e59ee367a709a24214a3fd441fa483751ee0eab57b7d8ebcb74f5cc7c7ac493a6f36e92c94fe9d20e6d71307d687d539aedb283b88653a702dabd21f0757e34131c6c9b00bf107b30602f05a92ca1188f91c29e120a37686546336f66d1ab313ca3aff15e5874189775254080b840a96b7b7de022a4b2a628912cb55d3aa33e036bf61d6008c516a750474d3ef2ca613094f1edcfcdead58c8b39680daf448ebe28d70f3c7dc96341cd738c000b1c1f1e93411bf1b1843077607d37d03f23e76edc391cf02939a2d80d15398563e1e5d3442fdcd936b36242e50a5baf06a07f300fe006378c96b74ccd57eb2df4a72a78cfb43e5507369f3abbdfb824028f9d334c9cc22820bc22980196562dab2c92d0cb416aad6b799493bb0b08842a38d55102a4061adcaa2407b1e117a985ab53876d5d44fe0a60e6cdb474d538c6af6e64c159d9ba53210cd5c805b642a12910e5e847dde097d330362d9db8838a7ba2cc2158eea5e37476994c3275f7479b112f910aecaf9f67978471a5ed96d9c77f9f480481d3535555571ac76245ecfb923b1ad5d8af588bfc6ec0fd1b23838572eb9c3f0b56a2418f84468ffeb2894ffe696565ce1adda2d4cb90b57c79e14bac6ee666a9646afcdf03ce581c6859cd066eb0c12ebe45aa60f1952e70625985ee55e7f2acb984933497e82ea4037011eb597e93f9afde0906226fd23698dc60891f8a6327e6dd8806ab7af9e2cc497422c553362b5b05ea1a6eb2be0bdcae976593909f94460b014b0c48dbc1eb5388ffdec3e560ecbe3f02d8d2eed95344951039e0c571cb525eada8e4adf717ebfaa440c58ad7ca7ed1b8c474fb6c1ff8bc9a2d04fc3d21fe2d53ca00d2012a5c19790f04de7592fe6f7f27820891d8e5c27ef96df4622b7f4ea0387e22aed2b2b08bb0a65b269d2d7fd487b6e02a52dfb36fcb109fed461edc40ef23f47a2798c357f4a4d20b5ab6e59be6c8a391ddcaf0b391557f0dadbc58e3b57d756f2aee52335e8a954196b83aa0e8eba2ac20389efe9bf6a411e698071048d4a39fcf5175f5f3db12d8446c56126eb76e533cce9014ba3c9fccad020870634bd64f8f5eec6578caaf149a7178a118380f55fb44bfb1dc10dcd68d98a54524cbca8129fce815ca86a7a52251c7abcacc68fb9158d8b79a21ce148d54a64bd1e8a94a183b1f6d267eb70c4274caf19c8eb6c341c39cc2de291afc12b8569d7bb58f788afa1d98c704bdf9d7aa2d7c3892865e5b70509e01de940b702d5f7b1a1f986bda1ae2db24eb0e9b936abe43f8d3a94e20e3137288acc8215cc1b6d4092034cc47beba68ab8ae0516d7dc53b5e11fe1555b8f12085a1b87f108c2c0b08123be6703e5ee7d8a7f6cc81005e8581c4312421627d3a8dc34d202b9eeb8ba48f84dc36bfaabde889c873b647515d8afb88ddcf7dfdf728cc94f370bd0db4cbb16aa4e3e6c3bc260224bdf7219c118b91b070a1600c2aef04495d3a6ad25dc987da1d68f1097f65c5f03ae9c6f7ca179085c735989073ecd69f52560a17376f177084e7f3c0cad0d5b241c5d6e4c8af2c52c3ae6e6121e746cfad2f22e5380b19ce3b7f7bf095bff2e2433b9946d5819269941e9d3335cf01f5fa685aa2876ba7788dbead5270a2b1a16d6b2d5543f9c4877da13456af37d2182cf5f7ede196e4bbf6a7f49fe9e9a630c9439a4934711802b8ff13be9ab33b13a02b11f14540061c33b50a9a7a80522aace4e10bb09e197772d4b10970b14debe23065077f7fd99b7f84457c60092baaf7286ea21d1a53487b635ae7c35641828f9a9e5a88812ade7424dc3d09c0f8044b356234e999ca42ddae9b27fdef4676e1d0a71fedd19691f69eba6894bd72c41b6546f67383cf5e4b7b9abfcb88d91d86d090c17a798b727b9d3b97aa78a7eae11710e4a3b752e75c47851d96e4809810f62864d754ff52703c6543ccd3365b7ff58875c9803a768b790fb2d9796bda443171ec8427dc93b6f14356c59fc327e3fd1897782d895d6ace4a5ab30779a5edf5fcb4090528b501e8d7ff4711d4cbd58d84b07ae17b42a3a54be21fc611cd5dac1afdb2228b3ee64ec9f07b175d683fdc557393c350ffdffeced30be133b526c499373408c147ce903bbff263baf28aa746bfce05c111253a38fd5cd77217eb3779da0fac2837f4cb19fcf9ae47779d02f3c230da5039b02449029f1401b87f834e3a0255a5987eb64f3a899888d8ac55269fd90372c7d2f8ff250cdfb94a4e2d40f604e37d3c43b869f90bb9ccabf7337bc8008850cc0bc55816944c3ab5e469b9423dacbbde0cd9532f3ee0a3d75f285fbc45a08ea3549bf52015ff58e93f448c3dc23f5386db697d9bbbb56d6ef69b8cbd72b84acc94ae181fbb14ec0528bdaa67789316d91cea298c1f2a745c41d7b2086817ce875c51b53bf8ad78bcc8832ff5b7fd5de220bd32f9d84b3e9a01f0a0cd25a84f5c7a0a5f1eac104a2010d7934511d59c88ff5cbe9778e903d3b8fad13a067bbfecf594f94fdb1a5b1701b28d85fbef8628c7ffb56cf2ac03b19c472fbd98363adc5f6ab0f77921725ca3753bfd6571b9165ccc2b5dcb7668dd62a8d3d302fe7282c3b3bb869a9826b75c39d44973aca7e7c3e66092c9daa4b6bbf2d6b2a947f97eb37e0aef1eae9585c3834e0503e06ead5009428fe711ae9bf3fcbdbb66d226eb8f943cf1d249a7c6abefadcf08a8ee433baa4b33dfb81a7d2014760eaf7e2247c35731f417c2016b10a47139447d48b7a173884ce4da441f77e8661403c3e548afb1870f0b994ca470abcce264275b83de50def0b9fea24aa39375394fbe0847b18506d66753a9be67bb3ca0cf4dd22caff7558bfee2a6bd85f1ab391e2e8d9c0d7f93cec6de796525d542e1ffb6d4c93c2df6c001c7d82876b72e237b62ee8a7a2b99f5d184dd66e2a50f2b96b4862e59d6d99c8d1eb1dbd34c7e29a9fbb8fb01ee2ef6cc00fc9a47bbd56dcc73121f433275bf1e54083a5bb58b00c2dcf8aa046b70941762eea98c11b225550e19c12edb3807c1bd13cbadb60cfd0a52de180a0cb53534bde1fdc7d01aa49794f75ae641c076c938d714c629aea9ed378bb2189d729267642c324b63bc4086ed0c1a14813a516a174b7249ebd96d9ab1e451deb931250c661a6f6c664586cf10ae44b383e3e941dd72442f6c0fbed9909a52778ddb8d8b4280eabe7055853f739ad5119b8b457517d14513b7c6afd95d6fc6b3e390317d9b04244a18536650d6f052bb1070ea3b4e21604865c1c061246e0bb468c9ec888330cfb4f08efb391ac0e7b6eccc22783f82f0989e5a66fccb4c7004bbeb93ecbfeda61848d15c9fafa17fb9c60469345359de7594be8af9114d8d64967f13819a4d2654e9c5aadceecf6ee32ac691b9ab9acc1dfc8aa38cc04b7d421cf51c393960f721b065ff06ace6274055b9a307d53d9386b2ccf86590461fcaacfdc75be1a256405cf56875c8e33d4752948de8eb48b91b3449ecd77dae658270ac0eb7c7363cff6246ae7af58c76931822a78f11c5392f02e6424979952d10cfa172458915622b2b68fcfcfaa258821cc9bcf7fd985fafc239797cf3902ca6441301b9c188d5433cbcadc19a35a36037ffabc0328fa70debb45d83c616366ddb303f38ca3a8eb90efc3ded18c9daedf79198357b3c72d34718c5a18758a9d7fdc268c2e48c1dfd8cb40cba0035574949173becbeec902b3e6a4174731032ccdc903645d08452333d4c9c0e63ff61e1f6143aa3b4ccb4f56e16a812bc9e158ea50233c516b81ba6c6ecf08dc336452fc49d2b9f92f6f6ba01a1803d6fed9586a248857be61be489fef11b53818d990e14ff1d07b082666760853849205bfd1f7cd83c58e698f704a0eac23a004c50891807700c4f16273738d0bf95c7eb45718df367016fd537cea23377681e326e467f9f0c0370a65ed4fd9618dad361af95e230ee097f57ee82e0b409f7df3f5fa5ce3b66d0c8896736b595de0f0c564ed65394a02a4c7be14d654acdf9dd43330616ab29bb429200d77973415bd07d81e6dc3442643d489e200b3aab3aa93045fcf2c8f3c762cecdd455c95eeb098844604bcfbf1d5e93f3fecc28e4be5cc978f762c87e49c56906aa6f1f7262fea70af745808ec7f85e865b9f45ae3fe3f1359a7ad19d535be82c6c0bbf01d26dabe3f0e606caf2648d5221eca210357f5ed35f5e9f5f3b626f112a5d3fa779d4424549ce7ddae0b1ca66398703438865b440a1a25e52add2767aeabe007774e94e2ecb17557ae7657bc1a982c9dedda3f3bde7b1e1438d397950879e7a6e5796e49c042d14541e511c78a0eeaf0503d26f7099dff834efc0ef378f7e103b724e032d89dfd8123d0f42bd52c9321154c756683c2d3beb2d0c586fa3745227dd7239349ac0eb846d9e1ec5d1fe7ebc1866540b4940470512e8b6a8597ffa2fda594ef79ce29c675635e0f726e694749c9b3b2f03274609689bdf18db847009c1f79cfb5bc65e384f3b65452f87e01187b2623d05eec3d6e0743d5d157021175f34ef79eb61cc1d3733669c8b187a3ae65e075f518d8da49a3993b438beb0f1c9d679cac786f4a539334f8a74f9b6c0e2f46977b202bb0da6b32ec7d3af688e5126fe3de120f03359c6f0c27f9481fd0882b675f696cca81e340571ccafafef104f8a4a71ee247cb0b3d2416690c6f120b8aea181c28b701ff5d49c6e4f8c156fbb370c9e99e181f5f8eb5114f733e1c41b618ead304df5bc89bb9b86e0cd144c84dc2abdd22ebfa830df046644c7e499640909350cd9eff126d4230f8998715e99489650013602aeea911ba56d4a0bcae6488ea68d4de2cab957654c5dc479c31bb5fbc0a0e0e3537852424d1f0eaa161be77169f6da029549f14271c3466f8f75f80b29e2d56a69428589175b89cbf00a2a935a979cdd7016504dc5cbb19c893d40da003d56f9d53e5055dd4ff22d1fb71541efe4f8ea5098f61ff6253d909f21febd659382f509966912a32748526397ca873273f448f9fec0a9c920ac753f3c55a2c3fc4955b1941c856b7f033b47a0307c50451b4dfd733a95a971d48eb6c2f871490db93f47ada59ef2de7333a766ce6a3020bdfa3798119f8e6d0fc185d04e1388e415cf531f94c7161210d8796be2758d66b823720aa7e47865ff73bc430359c814d3802f4b3431accb0d65a966d16a1a397491e6d1693c58e1b44f460a90870db28369d86ec31ec02d9cbde6345e259a854fa025e4741b9f67faa3133a1722c66b02370d774a09e6b0193f4ffa8f1c5cc632baf16ddc5d810699e4933fff4e4ff24620b6e1c31d9bab3543b80a81456989dcff484bc34f5f3a9200e01c82a710bee6b0d8a258a434d467b42f1b8d8864012a36b3293490efc7dfdaf38accb0c863ae9f440bc9860a02e0ca258365fb43025936abeee3094a8714eedb784ca8a0d8d2fb7afed9abbc9ab314b88f1c527622c9e061b066d2c0ff6618dc1219f20ebbc67c7eebddaa3a58ed87973d983a59e6c87151f469015a7fc244ddfcbc5037acf94535a6269561209b87832e6b72bac94b6a34cb73a1cea0d6ab39679a92087b589bf0c711b9f699ffa353dc18a2160a928b5ac4a98d6d6f9a6f8bcfdd2cbbb08974ad9495baba3646f5574d678418b05380e8df460b82f4f4488d6dfb4f0f0e4cf42572b796a0d858a384eef9743e802916e3f6833091b76f374679036168870f6d3913c5dbadff8d9b67c1542af1a9f8c01485d986260eb167f233d561f235fcc427180f383d0ab8d55bca9ce4208091f28faa120397309b473e405f464dc213b741dce8cceaccd57f891c7e92b7a6d402572e8b05cc9ba6b63db20fd0ba53ff75c5dd692a38f3449ea0dcf320ef55b9cb8c1a0977c1e06159747d97d037d7b0c36bfcb681d63077a0ed4f34c5a64557e0d146ab2bd91c1a650dc026caf2c514c5451ae005ee61d602bdc78dcc4a9be2d2990d1d93355a83eb4859e3ad1e2c36e7b46a28749c48ae8e01a6cc7a9149849a98109c3b3d3784f575963629a43f274158d1853f7035a64f583f5f1aa1167afa29d3c0616d231162b70b9f86baf4279f44abacfdd2d12d4fc7aaf1a5c84177b9cd83d71d8638619f58c43613ecca5125a37c756ef38fd3dce66914db17b019599d09181ce6a5cf7022d7a4a5c530f36ca73cd11806ee62a0af228ef5f91794bec9a55d08f31cef7659a49c082261116efd8bb780cea5834f5941e107a5c9503eaf235a73ab45f653be754789a4986fe13e3dd56d2e52bdff41a402ceffd6930f87e758357fd8af95e89a3e641d336685bdaf87e66bd8183ec78eb28dca61dea4312f5734f5254216cd0c69361992f979bf4688d7fab0e95846a5e3c05d394e1a2de1e9a1dafc4cd5a70e27a159e2885a0e6964a4108e743e6f8af2c76f541be4c25aa22fbed0d9354af38fd998bc17a76c6f9c8670e7174fc30d05ea9fbbe1f9c916b789af9b20b1cf339c8524e82bab9b43b32935b5c8cb86c32caf6ccca8acdce63fecb215d17f4fa5350d10b1632f8c58a0f1c27d2df8c1084070fa56aa3a4e1a32901f6bd13d6b894c74d1e793c5dfb62d915e5084ca99a6e57e9afde840619bcc966744857311de79fd4261d83be0b38b52ec0b479b77c0d26b7fd462d4086c6b0487dc371d115e05101e7583b0b607abd5747b0d9290de9d3a918ac91f499e253bcd930a8c8cadf2dae728a056ab7051c83e1576cc6823eb423755d87a2073100ecc62fecbcf0e82671407a9cd87b5cf5d404c11a825eba0b7e86d68fcdfa14d43b1e9af4a2eaa310f30d40fc64517256414a28b3699451d6f76ab82d39ed558a01fbc7933245d78bdff17d9fe10b197b6b765144c5fbfffbb3d5377d236797e29a6e85c8bf3461f129ee3d6624e5908f268f27c1b59cabbb8a35b256a9b444603fe6a52b941cec5ae943305fe38906dba9e913db7197de9fa25c4ce0a607706bca73d0ea8c5a14baeed2c8af0c1cb4a46a1f7b48f960f09b5d4b0c33bef40560e2c5b6ceddb71f3ead49ae483afc0c5946eb774cf3d2c0ab690d31fa196abfd409e54ad9c03bc735a6479a5b8f8a28b451d1df02ca972ebbb850279815f5ac23845c5214c73dac73d0bb2dcb59e8d1c7954b7af6799c4c106f1167b9159c149a8e8e299dde34504e8690e13966ff5f117d9a5072b298d3169254853ba522fb04786f9af9396ba085c31b117ae3f01fccf9bdf314cb7943553848eeef25da4e1d3e23dab18dfcafb196812c484c52434bb6ac9fc5ab7a568ac6e1a0aa31f4d76ea53fce6c18c24299a9a5f52fe82a80542f62bea638f755dd211c12d88fe451675e5bdfd0630149bea58ccef4e6e9da2b52e7e1a92f5ec73391106199319eee8759182ab35415fdb0d4189f6d1d3bdce09b6d9255d68e2e5081b82e0d3bf85a8b7160f03b29ba964987965cbb247606f155a9d650a80bfbcba1733ae2fe3a641f1b097e1675b64a657035e920a3f946f1fa8ccd8c8bb36e32b352e486b77c9e91a238cf1595a4cf6fe9543d1d806ee3440d8986d4ea1f29729e455a86a862855307b1dc9df65321cabe82d45a6194d1218dcc943b1dc38b909e910507020e8b11205596924af96f366dd9aeb2fdd33dc91e83980d75b8d02a0433d4da9a8050aaadda03c6d1c649c2009c069322f0b7069f1296c63adcbab1a3af76d44fb41c5260ec9619396c8c18b1c8750a53712b39bbdb9d696f6e10714e07b784bacb7200334319cce2021a31c43f03c6225cd6d66db3942f22aef1b964f09b9c08f01830bd4ccf615c5b0a489c201d9b08bc2393f6a8502f2ce89e83b3b0e04a202ff2e9474d69421a0ef6f05bd6cd47bb25d44c319776ed130fb4b2d3e39ee7bf6365f0a9af78c0d6c124f962225bfe664a9e24f1e72c0fcfe75562fa5c5375ceed322dfd52680944e3b267cb89b7fcbe8044f737e777a6eb535fe08a27743b9497b978c091234466f3dba50f4ad4350411a9f4d9dea516b37c3799049f7594ba5bc60088c21b69ffecb2335912d6235ddb228bd95c99f9d28682970448f76488314f4a2097af80a2a3a2e26b0f33b41b622c9c32409d436abbc2ccef861cb29e255a9a08d6c9a9f9f4258024d44882bc8cdf02ae88aa2cc054d5e50064b05ac587c5796fa0ce1170d4a9226aea9108179fd5210b06ce21d0445357c2dffcbde22571dc602cabf3ffb8daf1b5a3e47ae1e2e221b6c1f416c19ab725e811367bee6ed601463689eaa37ee4f1b8b72a6eaf15b333c380028fa93f4a8391957cddfe33b845d183d0138f5dd1efd3e3555ab04e71662234a49c8757c4c064ff47bad6b54d429c0f2f4b3cf8fdcd07838f1d3d0a756a9ec56316039797eb00ef0527a2dffa36a970eb4d2ff4634d546194e8ee02663cc0a0ed88116a5b909d8abbaed1b45a671777bc2eca541547254f64166cdb52d754e4a17fc55c10283d400639533685136b92c5e2b321c66acb00ac5efa14487565678ff624136341b3ce7937540664ba565a2708e0fac768728e95cbef76f9684fb708abd9f7605a9152f9aa9bd1068953b38ae44e8fb0cc1571a473f5ced0181205bb483de553d4511e26e84ba18e41213e19a87c8ab8b1573949b78a36dca6fcc31762fbff0b360bb06ad5e986c84629a7bc51c7eb02c5d37b21029a405053be4b5adc11b178610c55d55fab83b444058bb6bf4e77505920a54043e91456233b247595df77caed4a2ede30fab75113bafa0e52698ec40c734f658d844519f4dd69da7a5565ecbd3db2fdf9e738c228110824a9f7664598767255765143639ccb6289b330223881b2fb69c2120a900e4ad3813b29ac08ba94c5f5e804379894dc6c1c006a9641e12b41ad25953a32f9198f6b6d422d3bc2b72b62c13ccafe4366a39867cca280bb5a7c360674f8087faaaff68b26af9a09dab3ccd2d4d16b5295296df4296def3d2a8d3f1fdfa87137f405bf49a5e964de26af52f48792ad4e1312d4b92199d5e6c37e118c6ee3a4410a9d8a3efcf4462a744ecac3d21127076b7c434073280a7e30bb842333a221a2be7b8abfea39694fb6470d0dc63b52bc11abe451bb57437a4e8770ec638816b48c3d337915d40d5974427d5565e225994fa50fc2adaeba9390aba828aecb5ba11ab19bd00310a8c7893b75bd40f07b7851e3006cbc5edc78d12de93deca7be5b533d13cd036e8258fc14a329ee60b594c5bb1eac2e134e9930f0d375a3be422c9ad3c1d964513ac318dee6988123030a2f3ce3385075a81dcce8fcbad09fbfd9948bded280d0330d84938eec54aa3a4716b4cdd2806a8a23354ac31dd1a942146b028d9dc9fe71e8282116c114df3ff10ed3b27ae6f72bfa90c637cbebc668bb576b92faf0ead17c42987a7c9ceb09208eb68e938b2b81f7892a335f107bde2dd7e1d45ce40a166956b31eae119064ad440fba8a8e18868b03446b80ca1e71ef8dd81b533fac75d822f95544c61a1e3d6be6ba44b5b2dd4f2db5623231d5d10493f8aa13bc25a4ceec0cf778bf2e34f6f98fdbda4c7d7e9740b76ef6c7c1c1982a7b9e5472a1a7e5ff7e76a9756ec486bac4549906fcd6e1dd8ee4fbd6f3e27fff8ac5a0b323230701f888ff33a01da6e7e48678d8c2dcd594a1bd9ec1e2a17a34626d2889fc5671337b1323b68909fd77f3b29ea68708f3014da8150a4848736ba00a545bab7146a8cd026425a56ef0eefdaaf21fa66484ed1af13ff3ac020829fb4c8be58b7a9cf79e99609d76c2dac08b0c3b8f158044e0607ec8805d27a6595aa218d7d53c8abc0b35c11d82217f6f5d1ed88f939390174a0c995c245a9c63f3b209a43dc3ab9e2c26904cf43b3f8ed914153e04f657300e0829ec03e738df8cb28c8c45d6a5d385dd9fdbd5bbe266f4d9febc1e91235d8f9297e04dc1b97607ad30ad113af6b454c1c6a7260c24d8b549be476e4f0c719f7d23052673815e3c50adc9028c410994e822c1f42560c419e2edf5ea9ed1867de930d5704e3788009e415fdb5933747b78241941fc0da8650237e5c6bedbb30b02efcc0d4124043b356fe98a08283ebd48799321716a02d12113c8fee97eb2452330edb5698bbd8616f86bd6ff9878ba64df06883ae3b6ed2c544ec8bd6abe4fc0b0bba071e92419210f8f2361741519b78ec046d878d8d5bd954098b8046eedf75b17db36444d33f52b2fff322cdaf953889899c8f2985645e2e8670649a2e14e2cdd563b6877fde6d1f77c8bedc9875d4db822ad0e0486755675e79bc7975dac4eb1f63218ae61d4a1038b509203afc67208d05feb275d355b70b2734fae1ef8136000ac96e98c2eb3870002ac4bd46b42ce7c8a710529c2cedab967b3e36480c916b0f83603bdcc526f87ed57c3bde1fada6edcfeea5a41ea72cffa5e1bc65cdd31f4ec298e7eb433e7ad6d7c5f21e6116a74cd91eb3133023cfd64429883fc77a1a18b576e5a87863c1dd3e0f4fd8d9c37a816e7a63264c577e652d1c6d38c25ef70ddafbc6897a40a06913af72869f136621cfaf892ddadca9963e5131ef658f8000ca9824ad2ca54a4b2c585c2853e2f9c9ccb4621607317560b8c26faff9e30ecf0c110430a449ce420f7f97ae3f655efda75276095c73c2d73d5f92d1d0ac169dbb90ad82a74f0515ec5554ba2f079e0a26ce58c3baf9fb20733c7d334b84ce2b294ce90c62296a539185d54d75b9f5d05a07507a7adb022cca390c1c6442af53f1ee8ce3a52aa1d0bf29b537d5ce3ba81d83ae784e70597e99d284d4f90226eafa4359949214347b611f9045bb008500f27eea825a82873b9e86ecee3a8fff9ae26c39b72b4e148c00973c9be809374ac5c8fc985d8ef3c764cf8daa0704c01f088048d577125de8006060f03c7e96b269c59bf7db00de3dd4f7cfa5f01c946a9e0f2b08f35d678d9eab5d8e06775ba268ce45977ede59f245595ee253364510d9d32e8383960f1dc8cd3f4d76198dd556fbac6ff388efa8e712a0c1317ca7a495db09257d7650f85613f1bef7c20b8921e498579de314e2575537f9650e6d0998ea4757ae766375236a0f3e5c2edd09b55c2e25b1631acbf8814ca869c99cf6ea815d8e58d0018c2a84bf7118d1a64fb0eba4c02f245af48853f8eb9006194a4c2582fde327f200435f262939badc992d9484446ecd09c4c91b05a8a1716a474d7c80bd2e71095afc4561cde4b38854d893c25e513c89cc17f70e9d842ebc237cb829b95babd8527992df8e19cb4f7d307a0d7a0b749cc358ce0cc2c99b69a8420a41e37e1abc39f2571ec7fdf10e2df95d2ceff70ca514831b0b430b85191bf02e7499da6925a25f3bbce11987d3c7a09d8240ae92a5b1dba13e8db8d79391bdf723c1db1ee885c61266e0178e5adc59e033a3fafedf8862c97b1d9fba9e97862f4705f0a29080b885b180da0e4c7b0c4f95de1cd21788ee1eea1d9c9d9389a59c7a1d11fa156a5d86b997e07cb7b782e19063d02a125778babacfc14bdb8219b8fbc7549b1171408e304e17f8da50425fd9c9c0ec1c4d069abdfd770324006bd523a1a7318ac278ab8e4893f91c1670a260108de8f6d45fafe58116520f0f3a50715e783f2c56e3873cbbe83fe490cc27048b27d0e7acc8c7e5393f4a2d22163b37c3be50f6fd648ec1338895eedbf043dc56f32bf7d0364f4607eebbed9953186bde758e98bf17ff1339e4fff7c7beb5c961e4f76b82db2cef558c7a8a3eb6461ec3772692136b37ac2e77b33d483d7062050914a0d95f7d6d16f3f54ebc2be8099f9451bd50a2294e545a4eaeb4ac5b9f2dce9c8c3276788a7986f0bb1615e55bfe4d5166cab067a802cbd6a0104a14654a37265956c1713d44059320579485431eec6fe152129c0127551d08de2e7549da1e1af16661944ec41e14137c10c92625641209c9ce2342fb9c4da6d27f81fb8301348c6bbf88b674423b0bd4faa470349cd55f487a6fba50a1d3064b7442d87d3aae32917cf25e3ec8adab4d788abf846647bfbe03e6d30bc74fe3d81dd7863e4e7bd493cff6e3f035b0d6cfb23c73e615efb270036b7c3bd3bf2c26a92355490896eccf191e901b37af6c11d43aa3ea590255c0de6d9bc204c6b83d541bca25752836eabe505ccea259d731ac3ddb76586c0d8c5a24eb5f6258ce6f1c52c643cf2f378cc9c11a20ad1338a7fe780a92b2bafd8601d9dc792d87499e1858638f761ff3735a5ed45a0c890c5a40a049f6efe3daf213329c0c66a107236b46bd0ba3729b9fe57aabf2c86d0260bf6d58838c24ee63752ea5810c16f9417c385a2b090b12f890931ad66ba8f8f5b71ca72f659b02834e9be13030a32747a4b6c32ea1df74f109b8716004640e2ef69fb603340aacbcf63468892d0260c9f8a33ab50cebba0ba32b1eb6118da21beeea747b41d81c7109c4364c5085b6f7498ddd50542238d8640adba6331c4f8f018d713c33822dbebc5f0f720fced8695005204383e0725a0ac160012251dc7bfe9fc6d35e8c828aacdae66fd097d7e057d8b9731b9a091fa3410ab105e4fcdc594b87544bac7abbe514970f9e4970c8a84a9bb8dd929aa1052dc41195dcb4a581d746763819cc26bf237a702c2d28485f66b8b504a22696a5e7ab786b89437bb1ac804757a8388a16a43d3ff007db2f68449cfd3a4d11ae9df993fb3d8386ccc89409bf588866784021a7db6adb6708797a012eb33e45edfada335aab10b6300a2cca357d87b9871759b8e61b9d8a8b3456a30d13b2efcea2378bc2c933dda4e2dc717afd9083bc81986f63cdedb4e20f6a848a93d5f16ded60ae53dae75dd63ecea74aef5dcc8c405a74133b5e9b6f4ec181be7b0aa266395a4b6d511ea1c694ddeaca1583a07866ec63289d0b3b7d8d37b18e95e5cccef58f4afe081970b0a5ff74671ab6e2e6e92c8822688d182bafc0434b7bc6434b36d94f3d1f8be9a78cb4c24c0fb1eee4b0c824be3528633e62485f5142aaf4b12170b6b2352e2e98312715b70a885669540081cb13167b97473f00602f4be6bd38f870b690906082432d0ece5380a79a4a5451397ab0d9c0ee09729b89f7b387707e785f84d2d30f4ce5faea46dafd18033ebe4d897468c758cfcec84c312b8c21ebc9595205fe12b96912cc463bdd71635465ec84e17c59a5f912b882327fde6683e5159a6d3ec49f25f8f1e657707dae38245f524b7fab8693b143bb66264f5a58143f0834888e8dc93328baeef4e6a2cd2db279038994a68582ad5bbb5cde3f628681148c753161921631268f4572dc587796a4c27c901bc1e7c4316db356f62aeba774f9df0c11a1c47f432636799dda31d21f4ed085036849bdc63d76c00aaa19ad4848384b92fc7c664ea6831916aab1953086878726e7183fe206680c8e44a754a12bbadc3f4b92e820d0fb81d3b2382ab104a952b75506c4c3b100f62134f7d0458dcd5d57f4ee874fc7042708efa5dbab0c4ae3a834ff1c646eee39c5ab31167abe8d42ab1096218c73d86a17348e3984ed4d20408277f9fffe0a88e3aaff7dd5af5e004b1712afa2110fe12cad2e6990d539197be13723a8ece24803b18469dfbf66eaac3bd04d928ba3679d15b2de7745a60d7ef8f14e828602907ac7300bc2d38846f9179fbf9b0f77669cff414bdc97c772bef476874a32da02cbeda182a25b7086f0a753ef1766065c58ea2add14f0bfcd8ba9aeb3b7d55bc0af50870419ea4cd7e07ee30bb0393baa4f2417dc7de5cc772c3c23c65b293a27e19cc251bddb74790e427ca161dbf96cd7f140823c1928e906d4a179b83a7c902891e4dd07cc5349b906b9ee25e515b4ab6944cc07982fce4fa470097ee85666b8c7e341e2e57df4ac93c35111c9e70590d55ef1ea577a3e217545066c27422b56f6e7e579008f0b6264af1cdb30d27c16bdb72478b0bddaafb4064e77351566e670fd5cea2dab60db512520077d7460361c14dac31528cf272f1f6f0d441528b7b4503810da6be6eb9157e9e6d0bc80dd7a2cda74525e01a6659b17d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
