<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0d9c0ab2f0cdf8ad13956859c63e2abae2a2554ba412abb96a1f7a64f86f42e81b5f097dbe3765fc7624b173fa6d62f900732ec72d6f5d2353b9325ac340846e6de905b2681ef29f69781f6c1191aaf3936c7849e612ab0da11f8ef4f9ae61973831aba34111acb0e326e40a73b7dc79ae9deb4f5d65b1ca345d2f8626e8b3d83aae5590ddd9c793c55b5e3f2b0813f9ab0740ffac9e4ddd501d76f24e1a87c730189ebd22fdd62d5fe1e4a010571b005f638a0f627739588e64fb8a7b769df760ec03c105481824f5b70226f177d833ee651260dce08c45b72f0aa4e3dd26658a122efdc61ce0702b2bdc8b077c9074487627f7318094cd81a9ba7053e00433d9a6b1189f268456d6107d530d52d8cd6cd703e985c0161e037d6c620ab106eb10ecc1fbe4d3aee71ba3d11aa78589fa34576ea7a0045fa5efb9dbf978796f2d854e05e46f12d0728a2c8f124950e2ff2b819b3ad6a4b32ee7a822fa525c93be568283007a4ef283f5580216c468ad4954cfcc201d9402a835d823a0486ee6b78200c21ad0b6fbf00f66322a633639218fde9d733fe52693a02fe2be8b938b63a1bd11a0fde011b7cf9d256e5b55462ed67718d7cab06e130abd3d530edd1d136cd64eaf2a691bd5cf243fac9b1ba63cf7f5b40108917dbc4c4a98b095195da26c57841c7e0f258da1ab8dda1411b8ba0a12ce9e48f10ed9fc0acf97e93802a3a8a28fa658fc993a87136214912dbbdc9e2b09456e6b3cabef4ea57485622023ce4e37a6a38a0a465913eaf63dd35824d9c5e1f580662e71b06bac6efc0e74332cd60c633f6e19ade6b4975f41843c28f210b5c4735346a3d4b82b990926c42d626c90349ef2fd2f0c8a7443bdf1dcf9302071e755d08442288ffe01a385f4b5c33c2701f34e75b01a58d4df14a7e988a6de85241e1c2dc1f448567693f30fa239f9653c71cf4ccd2480c803c56df7b5535f05a17b982039849aeac710a5ef4293879ada33debd86bb3fbc2fe0c4de50e970c2fcbec6de489b1a64a5fecee5316d6012922d4c7802e2ebb41d9dee5453889c5c7cf3bfece7ef765d0dab8a20e04abe44c42e3e79233d4a94b16da628252176187e97d3014c1ba2932768dac65e391871f465d8acca35ab0f36016c0d1a30e012dcc6a8e34a247f7d7c3b5b5a69571bc5c5dc7c885f3b554e5287a8cd265557f5605babd9078d2d20ef898c3c9ced9124d7dccdfa6180359985ee6d81fc1661d7ad41d1f06cd0457c96285401b1de5c572b5e4cbf05c96e76b466e1856f23a3272cab121243b3dc383965cc5e53a0375630fc0d9574481fd9e6b25262f4820ba9103e59f7e6f030284df41b01315d516c1deb3bc99a8720d6950b8aab2e6a093219147dffa5139945c40a24bc9457471f319d077025ba8341c86d078d203ca9e7545392970f97d43995715e9d0860d20808a5be4283e5c5a51e14893d6b108491b72a52168462c0e359c6d964d996b6b7908ce755c715babd4f5d0afb24652ff72493396c9d0a18014bea4764a2b5e312f9baff796bddffdd685186454312bbdea34c96163703bd977333e5024deff784db7897d21b13970084dd4a951e0de726c93d4daf8d99087a2e370f20c354834744b8ce5fd923872028a078b2e752ac20f006be5dbcece3e94a18a15b64107c5b276c1eff8537f390fff689aee7b39e41d74a507d1a6d494dae3b30aa1b7ac35176ee2b7a537ca127b8c98e8e28a0bf78483f21e41a2321b07956e9a1be7e7058e55b7c7ade71a45a07ba4d2babb2f85510ca809d98f404510139ff8576f79e196a51b7b8e00c16121afc9530d74cf0f46894aebe11d8d984bdfeed224f080f108d395d4a97cee7d1fb3c10e973a9cf9dce2942343acbec59aac8d12d6c94847d7560f2ccb09cf23f035a9a50d2a6ddcf9f6c90954415eb8d95c73b8e33a57c2652a3fad80b6a96150e942e77fbf47669210b15c77c65f8037bc07c9038368d99b1e50dc5a6974cd0b318663b6479e3a1b95cc7817f10c550f1b6fbdb2117fb6abc8fa8491c2e48f43d3ff1f9e52a83288b0e2550e3843911b86d5f3f289fdebba5442aafa3f72617b3d09b97e9b29248e73ff40e10fde3e75ccd2edf13280a7b9c3bd093bc6327c55215ee4f6bd9a4e67e9ef1bed2e2dcac51179a51a33005d3e50301213c2a0696092a8dca2ed2bdd9f06200a3b105038f5f6093819d51b0adf82ddb1e6207effb4ba9167f86b6a6e4d66b324ea522dad432343af861f49f73dfdf27b0f9031ac8f7a9bad92e257eb5874871aacb055a5a4a25c3087ce71a552d618f8cdbb41b2e28a3e84cc15f44534671c029dc5850c9ac51f15b3729abf5b1595436fa6fc7c3665605c95b149db143123f08ef97e6525e4cfed26f1949ae864ef0ad49e9d5ef99dc02d2e94270570d0f78c02ff320bf05a067d127673ced8965e826aed0ace7cb438ddf543e23e9cd34c51c5a175627a1c6bb47c8a72264ed52afc4340b60eb2110fc283a7a61f6565c7675c7c99d70416e49c15b1544da357862b27640b86e191593c00db7c2cc26d3cbf6fef45f5362962e42948554c430d56ddfdbeab5ab9bac920f121025ad603ea2f7fe84df9d3197dea703299ddfd1c2d2c4581f744a9734d6fa5bc59ec4ee0c114a28845effeb5091daee5549e79581f77aa32908dfde0a4159a9dc1efc0a4d58ca043736222082bd73a04d2c43a0f2eb0e51a12792c6d8374a475a58ce8adc0497f94f327c55c91a6fbca5eabd587322b3a00ba9cf3adb60b3cc1f4437a4f3a1fac43fc133a01bde77e11032f3c721eea4f821bf8c26f069b4dae97f5522fd140d66aed018c0e7960995b31cb38f239d7054c5a0cd19c186885a47270f43432241fe79089f8e0d88ff0c26a4ee2314b0be33f5558f562418493543ad3e5533f888050069ac059945584f43a19ee8f522bf6c4b62faa759d300759f6101859d6a8dec20dc72d61fbcf4e8504c0e6b45aff0320cd9966dd4e4f317832972e8191ee78caa56f946d6a35c2ae503c5e8b5b6deff55250c9942a3643de9a24c5f7e96537e96bf36002f1b253129f8c6d77d8a9651966b7d9015eef358593ec802f80ecae35acb7962846dba6226e6e2f50147ac1adb9841546390afd5cb8847c229e91c09b5cf90b1a517538c0f6a19c9eb9d1afc854f3006c820f96f0cc18777dc56bad3ab8a3d27d70a8332587844d97158f6b3f1e90a845d47a4259424408135aa40c0d745b95c696abf85f44a1cdd1a10b75b304ed6c985cf8f19c0a38dc67ba9cd089cf01893f6c00942bffd3131797a9ba1340bc77064ad95cf8d52d9dd32d889ae67190ecd4922af0dc17a3e10656b8700480c1abd2428a83afc86c65d48a0f6803c7e62eaede4ed51a30baf7ba3e6a39a9ff4084196ac9b2f2d7039a4d51af0a47629b67c9360e7e1c9b4f8429397930692ca1dc25a344b58bbff10903c944ed23de8786e2b5660a7fc7156e00718b31a9c9a99bcec65cbf779ba31c7ef77fb6a944851ae3e727920f6173c8caa2cfbcd2e3ed32ed615ee8071bc9f483c0223648034747ca4431b585d770ac436764960f49db1c3cfcb0da60d450c5df2a119b10eb6bddb1368248cd5c52a8e37307d811731de88dd269bdbf17bfbce43f8c04af5f1777ec5ef81bb8f2a5ac90361b7e365184adaf5c22f525796c54a5c81a1b056e3d7f9834a07355c6862f379c8cbec053fc1373a79fd596b45c9b878baaf967f787cbef6c2680a8831a009f77ea8a4048233a3a44dc49b6b9b5332379db5b91aca3fa82079d191a2ad83913cbfe01bae1118f9405044b2d377aa2e40b8fbc0e125aaec3d47a9751d5b855a674288c81f3b15839b940d9835984515075d60e11c699f7d9d20a99b5c1e8afb5749845a3f7e7b1d109107cdabc73619434e94d3901591dcf0323736ce78ebc9023e4b3af809daf2a2c879c58f2b2a5f605ac3cb4752872f2246467cdba30fd4c4ebfbe5ae756540a2c3c1e7540fe11b3830dd65fc5fa78ba7257134baa0d0a63296f21774445c89a0e57ca2878d31896b17bd34bceafb7965815c6fbf7ea832694e76842945c7889338fcce018ff19a40cd8055e872a3719b6bf8768bdd999fbe4932b1e2a51e29aa387f5063e614360fefe4674ff5af1a434df0b4e767ad6afb3629c0ca297d8f1dbb19e3f6b3655db3665bcd72a66a9cd0156c9f8036e6eb04bdb253659691f852340c44a42c5822e9b374b25e03c1c002ecc796ce20d441703e1954724965fb742cbf848455220ae0a88d312f6ad5b5fa1202f5e4d5466f545895a6c7be774602ef308caec1e69fad0a427ce18351a2b00dcb154507777ce97afcfe68796385316387258c016c0bcf39dab128bc4f14c2f6a1abd07256dc70d69ca992a8a4081532b98fea9338a9614bdcba33b7fe2af0cc091551fb99419f10c097201faa5f73a85f0e0d7f9d7ceab5f678bfb05f52885be2033aa21c7f46211f41a9ce07dfd2e51057cd67981edb852d1ff616bf3a2078c9e5424f39268772201545aa7982a46a3ae98d08f4670a685619c2484bc7672cdf79b0ef48a61a52352a1d89c5896e927e5b76d89b98dfbb6a51f5090cd5d03359c0a2b7ddec864c5a64f0f964c41de2f6087abab654508d68da8058fe1a736de67a17b3e2b1201884a9c0551bbd75fed725dce206947059725c48e149a4d24ba7ce5a26005dcdd18d2bf16b29a50306a9fbea6571be550bba2ec328a8774671cae4df378c3c7ec4e01b6962859ef56dddbd4b57b32b41da8bb7ff5828a28e60d877a0a04660fd96fddcf24bf316c2888920929521c3f531d04c341cc2fd58389cdb3fdb970bb39c6992a734da09c894a76ea463b3bffee18e9c6e06b0b4836644c9e3abc33d02dc50371630e5d569417113888649685a08463911e97499360e4dd20f15cd64832485551134bb48bee461af2172dca670088cf324236e0d9f19ef2ba9ff86c57e9dea41dc474bec404ad3b566d2020652073ef87df6ae852b3f62df407d59df00a4d548e16f9902b1288dd1dd4d7a8f61343c0759bbece3be1380f08b1ebda805a65dddb0d5d74a6467ea357a4a235e7e6914875fecbd51a17c19eab3d0310188c3923dbfa2dc1d0b718c9643a89caeeddbe89410a8305d799663a9509a0b7d548e2c0e811e1b61a751b85e93ce689aade83e173277a3b3d45cb6b13a7768c556dcb3faddf7228c1e80d6cca96834e1d21889c65b81fb3d79b01e5bb949b1b0c2c6a06fee762a0df64a5b37e683c5bb9f18a59bc5162ca213174b47d85ec7d0194153ac43a56263d11ee7d48893242ce91d82de365d6daf90122ce489b920d123d1243431e43f65a030786ffb0911b7ef5efd9e44f2c3f389f02ae75615a55bcee2d3921330af6e15725e4499060f320d76ad442f87d18ab293efac012640a1b897809034a46758bc87acbdb28f6a0418d8977cfc46312f33782a1dff96d608490be9b72cc1b3bf67703ee90c1ac9b6553890b6aba400717a016a07d1e8ca746bd01241caa7e20d60191a34d6e269c70fd5ae844818c9f59b4b309abe4967ad26c5e878faf041088008ba56e3a6fefee8db98e19ccf6963efd22ed6d91f1405e962e50447e7db51c362550a02c6e35eed8fedb5e5b3941e0be5916c94a9e752fd85b00b99fcd95bd990922d138c3fae8d92235c664b9f6d87de1745601f28b33919669404f33659635bfc3b009468243b3fc25d493c6cad37a34cedf9660a2c60a48d5a6c6df3326e4979c509d7aedd56a2f147f9e68e89e71dcddd2db16ef6c5199317ca462f7c602aa545f0083eb5ba3e8b7d5926911aa5409e6103d6371eb2af1c87b7b7df847e47dfe81f92fc20b30530a52222ab8240e4755fa394f005a38ade564eb29afe90a50e09059320b4438662f261b16cc7405ce42b21ad0a05e1c65e0504f3f25fa7ac44563c7d03e37a405ebf6f20228be5b0465ff2613352acce530108f739d068a53f795b1d2591966ca36982289e5cb56a501358faf7c304e7a847938584b5f5c5aed8861a00e901f21c6ecb1295ce5b70bcf3a03cd7d2adc9aad347b5e039e0458d29a42bbd77c99c586a269c117b3d7ae2fa53dd98b9a928122d5bbbd36af5092cf6f5ca134250e26eb656356e888f04e3ed2dea9bcb8bc3ddf4a0ce08951c5717acfa98bbaf569e0a751aa66b9bec2df3c1432f1f9fc2d899e842b9412f87e53d6e26e07d34725c670de52a0daf3150306ceaf7c30a985a915afefab975d81aacee9176089a1dea016691bd08b12d94d837167a8957e372f6a37e3ce2ee4f7cc31f6d0569a07a7f8628fcba505bb2a6ea00b9758079fa7fa7d8538381cf93b412009cc0d53ec27f9cfe14640362a9a3ad0788fca0862cb34032650a6cac9b89095d4557874b334ae87b7119b65fd5844471f62c2ce2c1e61d2e49c9807a390f3c3ef0e7aef6da0b1b2fe7ace61e97b282bd753da46ce83e74407a6522912bc021fc7ad53b3e552347896c0a5f830856f2577fe1fdff5b3030af4a275887f03f4b84558a5b5b778c2b0913d600851f75077dbae85365ce7eefe2f4535b2828cebe71cf26ff2c069fc9d31f00d9322bd870057bed32fd44d91d171676c32f337221b623496f5e4b622afa9695ad1ef7850559d4a8a27f0746e136eb5fb97b7946010f8ceefdcb5b7a108383917abd83a35d87bf0fcac9f2071f8760dd1c3d45850c51ef7215a908ed5c90af00ab9e7d81cbed261ebef421c404e130d1ff9efe764cf24aa25582e061523d557a2bac705ca372fa4ff464318fbb7564509b79d145ac3f69d31ad96d5e9f045d042e8981442dec5a3f0596d0ddf9c7bb9c5f170c4fac6ec77cc70b9ed3f45c3541ffbf90e0d86001daa51fbfc482b16ca7f419df0b30a00bd004dda0a9291efdd8fc07022859e282a16a8b364139242fc7e36526113c8361971f1519b20f1fe5d42fb389dcec0948dcbfb7dfcc777f14d15bf30599c7803a107222f2e0093e4ee26283a996481d113fdccb460d3db7c44ed6de0979eab7bd9ab2bd0d3b886ca5f4f1b087912fa26115c8e6616d2e1d00f01a9183dfdb163f02432ffc51e82560704988a3f560b732dab958e15ce10b23f3e66ce022390d3d20bd3b9c1a28df0440e89b73479cb433e9cc8aa5a093f937f745c90dfe8c9e2beeb44368a5613c725184dc11eb21ee118caa66990fc26746c9f2951fc4a89e7a06be06aae62dfa576b91eaf0834bb4224141b19873f6521f0fa31c2d0985e9ed74ece0d7862c27849d2f6b31b90c586cf09c7135c53a30dea2e234773a7ca3eca406ef86189fc9b6f7f1222b2fa800e481a30936d22048ac90c268ccc4834a4b540a9923bdc93fc539567c47ec48f5fb48bac5afa95fd58e983628d7f6e43b478d90e3ad0285d3f0e9ad26f4c884fefbf270ed720e47f73948ae7e23d8d4c6b51a04e4cd76c503053163d974abc8b6648814bed26901e294d49214387385ca496826da486b58a5799a469a80dcb063564b78f703e399a4c46079a9bdd402f27693c5cdd6ab355f2d95589a90f330724f069386bebce786f4f764becb08ae537c36fb959e06ba6cc89b06cf0db615245170ec32e905b70617c729a184040a45ef9555072651405760820c0649345fe44c7627f460aa35e1f810e119673aee66751798ef513433f6fd6930f10e329a4a380354e87f7d444ce13e299c7c3e8ba2a3c9387c98cc9d8be5344291c943cf581b0e20e613b51fabc53ccc101cac815b669ea9d12e8c74f10eab6db9e0a15d95d897dbff5d117b476b0b8f078d2ae64a65c95e0c728592ee170abc9a5c0f529d3a7af082edbb22d0d48f203ba1cc82b1ad7b17d19b201532f0e916acc69554296c8f594229967544325d3c914ed8b115b8ed43ca08c92bf7056f14251de57e6a718e8055fead84c883113238e5b0236ed7f118368edf319bffe2f29fcd5b896bf330e024fe1d63f40ada7173376b64d53e7abd6bc18c3df79e4bd8f396e680f31207d095354746563d8bde36134958cb782f9d7e0a61801f45b5d40c07b6c3351322be9ef4d6526d42c817e1a2f3aee3d71320722151917b09ae9b91b966d47719db1b13cf7e4ef18104a0ff6311c60dc3228006411567c487cc53f61ecd6651919a7aa2df9c459631b8043a3a7f1c8fc0df1b90fc990da67459cf50cd3cec8fee88ff210df4d80a64ec6f4b9566c846baf2f283fc0413f876dbcea9d08d36b9caa644932159abe67493dfbd17e498deddd6a42cef8a6c746947aa7386e95ff8bc7eae94c81a941b248a72f02fe134491f71ffbd80a01e4e7035f4a2cb1d6dbde64e75f141653b9a6e2bc81bbfa7481c1f7bc05843be11d3fd7e75a0640a2114a6812a8abaff1e8c75ac28f2cbf74d3de1846423b48cd5814cd2b9eae651b4525610126b82f9c047a4f7b3280345e1cfd248ac4b8bf9052c229dc260860fbfefe7eb97fcce4c2a932c30198c7b2e76ff3f07aab9616e1a2a9f4570728610815f4523aa22a7f3286f11a7324bca29c742060f02af81606c59c967927da485d06001e67b5132db40afbcd29d97223a22d9c950bd67941ff384d081b363730ad40baa6c0ed405403b973438713e2092e860e38d717ac96632538ffd561769488561e407b2131ccdf4b4455c4776de1bef29ebf1b3de4b3daecbc6a99bffc6d2e4268731d2fd7423c430ec77415bdc8ba88fcf92df448dd85fd635a1c03d79d017b265045136217d26f5550268320ecc4d89511b7ae6391e0f53f271200a56d9962aef363cef764ea8e26262da8810dcd9876e2dc94601928a60d38f9e85781a0ca6d8f30005fbb65ad4a4bd459331a7fb5a0fc8d3c0bd2cf316275ff19182d72cb7692216a01640d375d60b4cd0007cef8e3e787bd8d0cc26207fc7f19afce7c678bfe3a49a48e3aa661fd912b8cd6d4910ee186bba6457fe68a4fe96216060716471649b1ee04428a9feba520505afb9dfc5878f6ac2684543e5e36af0f311ab579e1160064202a3f41fc951ca2803b146683b3a12928dfc013cdab98926fc5de053a87441cc37f37abbfbd21b20f0d9b4607ac64b46c4a8dfc09e7d232f496230f65e531595dcdce51df996e8876cacfa6523a742f8a944d455a43acb9d25afcd75d27b5d82e2e7ff94fa3578d683c057042442844ec76d289df3a00cb9253d2c6102602ca4b701d10b97fead22430cedfd2b54752cedca94aaf4e41a2024d3e0e9a06143dc5f788ab59d05c626553e2e804210afa4c75f2cb80812349925fe61dc15a3ffb4f3bebe8c974e209fd8ffde214d10e8a469f64c72fa117778fa92df5c676c130895e353563ccc7679df957c89de539756df8607e59acc310bdc11dc12555d0848384b5fa252c159b0a71fa45d056494e0c690010d3b7fb16a8e617951c1bc0261306c0bacbe4eba3ce179b3822c02c8e2dbf1a7b2aa3675f2a1237404fdf808f2ec785d4b1bef01ac86c4bc657cc40fe24f40ec5aa2e631c6d28fc449d7cd044fe998830a06ceded35a253df7a1fd3f4fcef65da66bd3e05fd64d7f9c0b33c4ad4a91a73dd10051964f9fc71cccf8ed15f18a1476e9dc422705e67d21df89b87a22f46b4931602dd38dff46fd93f321366b690d721c58e6c063ec3b885c03ed67c0ddb574bce927d34789f4c66b7133c8d0ba87c1b22f3e1165db7a35ae213927c01dbee16410a83ce515f65f2cc54a34ca6b32a3fc48683dbaf9079b301129eca005c00938973e282a9d20bb62f0e9380bac604ad822db66cbd1b87fa743ebd75ee81b2e503419539eae2cbbb04d90b2172a980d29b2902327e4938ffe20a1c9917c170d91279b20475e8a5f9ef3895c2ecd9edfa3bae733d7094128bf2c97b15a85ed5280463a741ca0e9d54202015a6d8c8cff69a5d1c99b33457dc2b5927f90cfd2057c6dd4e64f7bf4853d433c73631c9281e4a6e0b9876c1193af789bd321a409bb2b7803d2f00f2edb54aa4eedd2a2e6fd0a3b993b42dbf056758e37afcd4cc264a16d000fd610c15c1adbad6e9e2b11a660c5e1bb013468e47d20873c0f67beed7074b02b255df99b9f850e51c1a2c220db9b1378100a1f968e90a8f3ebcd25c227c03baccdfa0286697ed569cfd1adfcb4dad2207d5b21a97e1b2e1f96e83eebf4c6cfded22be7260601a92076fcd31a8236313dbd64597691041f49f1ffdcf31c4473ca4a02a2284f9131ecc88bedd665bbc49628010eb8a0aded911707b34e27ca4f68f4fb7d6bb8493c8e7fda6026c76c6e45c804ca51da8cc6b12766251f8f5b1049bfa8611a3b87026a5984ca85582cc5eaa222c517da614a632872e54c2ac00fec7fe08f4449d32bfd318af9a9b6c53f99a0d37e6ac9cf0b79d8e83251d525e88359a6bc38e9896a1ec64c6fb00041d270d6ba0eba06e1b0ec1457974823a748a102328adaf3427675be4196b4167376045e376671c91ecd256b7fea1331da73b5e30ab9aa7a2c7ef48f6dc24bbf7c702260fbdce83777928b0f56fbb8fb1ed10c45e80ae574658753e554b79155d62664ef5473123c1f01b5dac7b199bdec0d4b692ecb556f4d9a4b903601d53caf80338c713a5e3886ab7fa5149da2ee37b62e65de5ede83626f65ad3e4a7585aae33b3e91b4703137a09f727f395bd600c4005318565758f158f3f42416d673b4dbe90d0971a4650dc99aedf9294b962ef8260351c2ccbed6857da9825ece344ca2b8b8b9bcdb0522c2f6715e011c1827ee9c1f2636e5224b5d509c31910f21d88041b6c5d3d96c79b6a44b580441e94276f29a82b914a9dc8cde54a9fa196ec081a373d5af1c42610cda209332e8a27a7d343d8971bd4912956c23460748bd01586d65f99937aab9d468fd3374049afbaf7037689a7cd9a6ae797b7466b598d2ecbf1d940d51cdc4ba02e9d5e8781949e6fc68e48793fa1289065497e09bef9fe52f6946359ad891b51ef6c5c68d82af0cd225d27a2adb243178674e055dc5c87c4567f409824f00151485fd14ab95d445a020891984ad86b84e059df2ae6fd03d673d69b2c7b069b17aa0448812006df3db10f920b5d727e24ce0ed9b619f803d1f27e22f621f4a966df532cce510b1843885b8c43acd86c13e61378c0ca295c59c51207df71fb30e6c791381b5914012a1bd47bd8d91dbe55c9eb7808b33994e7fed047326093925d25044daa49544f193280e0495d7f51366a76d8d429ef30ab2c5d54bd3a7c93abb080e350a2573f961499a9b0f0850d52130462cd53318da071b17fe347c135988ff0109b4dc1639090e4354b06c80ec788c518901889e2842b12666e49dbf8e5273f23ff2b8547803bfc0c6aa179568719ae1946e88a03344406be06ea899b2b7640314a1b321613a1a78f012c13100c9e6dacc022b17f41854e7b7c23d818061e5e3158c8c2c6f933100fd7ed5a802d403bb0c8d991a55aa64506dcbb9d7239d465230db6f92c3b0daeb5b2cc05dc1420312a96b46a5c867a811088d59014c78c78accf1cdddb867a90e4d1fe1955f5243027ae7c7df0d19f83e32c62cfeacc9a74275d2af5db1764087fddab229e10c9482a668092aceae12eb41a77bd7f999dfaac11bf4c27bfb19cb2772abc0554d0500bc8de9d7cd3c29c6e17821aef3a1ba1e2e75320c01c6694c8f88384c9ba3cee4f2b2d1d2608c2e6897ecb286382700e96806ccc8c5ef765e58309de1afd932e8a7b14c2e4af1f8cd189e8f59ecf44e8361b3ad37f43f97b45062fbf5a35c72a1252033a3ea5746b2eaeaaebc2ff592b9c6d28448028bcdc6e13713c439ad981b1c77f13d0e706c69f1627bae431ea6a71c0dfe48d25d3d3111419ccd1f72db42102df41c05b115502440aafab0c323a238e788935436d8670778cb7108c119f4db2eaa8c77d4fd1eae322affdeabe53d678d932d365ac9d5b8c608fb3205530bfb7f3d220133469a51ab0ed5ec99138b3434e91b834dd9d9046c5b369470255411c9c0a0166bf1b8d7d12abd0e3f20f98518dbe6447685a832fcf5e34a56f21004b719a59a342e83b236a45b7fa11a1785b1d08ebc80182220cc2c8195e9955007558b30b35a277bdbc54f9b3d7dcdbadcecf3cc6ca4ec0d3d72b14ead6833696682d3ca3916dc4cdadfaca1f11779cd38495cc0bc168113bcbdc20b22bbbe2c0f49a1e0822850fd3c527dcbe82ddd960b156064ba95b90b9013eb28686ed8c476d44030caa62ff6f7168000bf40a76f9de00ffe556387faed6136de77ad0eae66a3c3a09ce684fa44c41a8e26c4648cdb98efe8098b5597d99bc69175e061ac2893bf44eaf6eb1f4d30051eedf19ddb6bc9f915e34ec9c7462a7dde2b0c0f38440a4c856bb478323f4c33bec5f441bb2394b8019c4f16b22d18d6bceeda4be5917ca3be418f8c59d775e51a9cfc8f0274f7ff8d7468975bf9ecdf1dcba482abf4e31b7104b08ca54f182bda88ba98e87a3d62233e24c5aeb3fdb423f627622dbd9afd45bc25c3b65ae9a34536e889297390137f74a834ce443824fd66457a1035c96086f74f0ddccd3055408e7d9d63cd32c606a2bb96fca31a4a50c70df3da0b65badf765b1139d0415e2dc4c6f98d40579af24fceefd16b65cb43847e16283c7c71b52dbae8b375e6be45d60f362d404057584c29bfb90bfa821b8876a560971d59bd813c7d49792c29af78bce74a1ade3b63caa76a5f6764b92ae5abbf7b68f32276c4298f4488f24e2b091fe0ec201d307a7d7609e9ce61ddb6980fddd62ad938a82ff1f68c4f3b8b4c403e20dec352bc0b52938f5a1200dc9c2475b8db349b4d4ad2ac413a1cef6ee7f4ef6ce9311a8807218ace4de9ace77eeff8e995808cb44662df87b37ea82b2e430da6b7e627c026491bb2e065bda435d66f8a34b24f7661d2e44aa876c32c2b597d4bb3c8810a248e4b27be2a8195b9741e98c8f30c868731d7141cec48f366a323cdd6e3bf4d0436038749fb39ba7d05b675239565d5404bc6904054843abe18fecde9c3f3de1bb775ea6530183c352d46bf317b9ecb6337de0fe82695623de528a163c8bb11a35903d4c05b2f1547eb570ba20a7dcca6232077885cda456bd53617e2783ba0789e4d3376e484c032570e9e554b51ebc9f8e706d8d7687876146124d70fab5ece860d4369303880d4f96361770a45146c36c6d5f6a73560cf1165096f0c1449798e861935cab3b1edbe8602c24463add16065b79560af25af975b67df4fa9e0cd00958fdc018a2005ca933dcf909ce913da0281e0e79cfb05d8e12ffde1947fdeea81b55d54c22e691167c680a99019646bd609e57e75d0ce17139b7328a52286b11c265a55a9856d3dfaaa52ba11282405fced1dd4e307c9e6f5230d4064e94c73b05982b53bfd2289eced5a22cd15cb11931f35258e1eb4e558710e60f910b9227ac9d5be38a2eeefa7e02952153aa7f99e5f315fab8bfb0f27cf4f2254f98a2d23f7d82abe68be0bf20db5c799f776b135dd68cd2c4fc7eeea596ceb72a4c3d81304a28cc7d2ddf2bc29d994d478b04bb8a90c351d19bc104e7592981192a292e513170c2b7c621b8e1b679e566006a327b872e4bab32cd7b774b732c8e93a6e5f30d0ddaf3858959e51c9051627392de2691223ab81ab1014885cf5ed9f0ecd434a6d100d67a357a9805decc56f395ec138ef3f1a1350e9ffe94dd52e45f68b1e0a603f839b04678b786e878ab74051c89c022b4a3833b00cd73f8c1ac5dc1caf43db4e36777e632dce573a1f73ae9c76d191639026c8712e0aefbf10ce632feef086b5866d0374b5acf67fd53694f833ddae694b7b586797b4ca3d1dabb04490068e16e9422187e6fab1a2337850c384d43b9657286313af86eb52b3b714af2c849cc712631572a1a5d72635c6fbd661f4276da85e685e2233cc9db9e4e1e29d5a9177d03ce7e0d5b6fd02174b88df031ac6267289b85d037d7dca44c26bae30354823c52f92216c127200714e80d20a17903c73b7de826cae10b374f0130b19a66eef8090b87cb676f949e07b3b3bf8d8bd91711959cc3d38810611d37cb286e69b5f1953cc38f730f1611cc4c0046ebfe63181a6708b7a50ae7ce1cf6fae1537c34e17ade7aeefa19f633e8c434ebfa0eafadacdf5b0a44d34ff73efe3beb829ebea4dd152bfd4e273c0bad2538738933b7a893fc4ac1a6001873bbf4bdb990009b74691e9a48055a2442aef25730ae876b8f24e05535d4aa1fccbce1455a42a71dc0a51d09a0af96eb6ba042df00c853d7b1f79c8bbde905aa322f62fb5dad5de3150daccbeaae4d3c8b4054b59e8023e136ae7f53399a20dd48136ace4e4a44c1083b35c2eaf59cbfbe1ca1674bc269ca66e640e0785c0aec90319e04eed2b6730bf4bbe1cf775493abe947e3c3e1da5778663f254f66c977a677c972bca5aad62a6f6a3c55d145f82e3dfce6d6d55a42e50addb7ea6a79377726ebc3a45cc3158204a6efca6084bff58e461dcdb3cce039c6dc47f3f59e15c988d8e9342495c9ee5985ada313b37ded65ced014d85b2bae36ffc39178be4feebb6cf14630e24874accad3025ab4d1d44367265cab3702b01a810774ed38614b6fc1a57e46ba9357536436adefcc6b43c969a9a12b99e9b31689bd17e14ec23c3157fd743dc4c149491ccd632cac8aa9f3c8f60af1266be3bb4306c488900130033df587d127b5e2785f91fbf5db0f7fabecfe14c0314ddce8b25e927108e6f52f3df60e6b1b1df3b4968b97445c9e27a3c6d18a8fe1290cadb3fb9d636226dffb06a7dbefa72a75f1160b181e2f12211380187f98f8f8c59f570440f9d6f116aa16c978626d9ab91c979656630b9cd3635f92ea1ecbe0cbf0c3e03bea06fc8f3d22505ae7c511054682cd6ffdbb10d8c235da6af770c1078bb57290bcc118643c09ed1740172372dd15ebda291ba7b31cd91d5e56304f64774a2142f001ea9ae4b218d1953872ab0417a5fb3d0d7f9bad05771ec02d12461687239538bfbb8cf0b5777b297a26709a527dcee0150fc3de15cf147e63946e26e1bc312990d537a1f81abd2346857bbecc490e2e20e85d65f0f0c0b3247f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
