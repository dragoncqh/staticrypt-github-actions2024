<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f1ab0cee0d4779a9ba2ba68e956e6c1f6c088bdfea1e8b5c02cc19a78b5295d12acbd673788e6156a2c58d0274ba1dbf721073f6ba3f9d487645a9dadf0b38907ec7e988f6e50aa0e168578d46274863ff50bdd27e9cadffd02ee4cebcde971460f27786bf710cfb497b3722cc130039889ad168b91d78526f270d9d984a6bf5617d1a1b6caca68ef3a6484dd34c4834aea8579335ce9755f38496e976465c5359b65ff97645eea8c21f5e92d9b4280b9c3e3ae650e3e18665285e50072f1dd7f56c646262adc2fbef97170b59239194bfd994c8c3107b08e7cc33adb28c6ee328c1b2e1543ba60c0f86e7c0f8e29a10ac01842812f54ea4a93c614dc77a9325bb818071f8d27b0e242dcef349a74b4530a11b3537031541b6b5ac97bc5dbb25736fbbdbe2576ed2266a4b4f4893209b292a3059cac3b1da6c5e83fa40e83f8cc4a845f7d7a7576ad838ff46b47bf2c821da81383348716cb48ed33703bad6d5a056bf69d11138bf245636ad1a84e7d1098c538e0e55fa24fef5af3e2f705e8f2705f53ba5ed95d1bc4425950f2d96205f48cfae35d532b79189d22fa942a4d4410e48d82b423afbf499edd21aa85c41550d28d00119fd44004f40a286606c042f3b2fed055ed7bdf1ca64f9f028e44d9f62098f9655b2c702396c52961f4b7c2f1024dd286503a4b84bdffbcea687cf949172fc8f437bc8a4e75a75f0ca2b956a679e95cc66327a1bdf46482f3c1f2d05ad5c00146da22e9bf179276c07c77f151bb862aa17c7b7b7abaab1b6acd8001d2c0bb112c2e1ee81acf84a5f9699b3bd6954528cb2f04f34a7be31b87f464e572a4bb01e627af0cd4f4358ab538cdb9e45d3b55f8011b3f558a1803987a0b5b51c32e6fcdf638662366866bae7bedf066a06c6312a7e56eabcb9688703a7da6542df9151290eb3f10a3ccfe1accd483da393899c26554ac3ed7eb77ed5869cb1dff4b2de3f85fb72546f08825f8dcc845ef5eabb8c169c0be6413de580c0d362dc1cf5a85aae3b58823986319a36876510070ccbb096d3398274632a57ff016390e057ca702c231f829c8a2d75f5a6cff785ebed69a63841ca61c9cc071e4c290e287ddab624904b5159a696670bdbe1b3f340a46d3edf1786fe4402b4f2b468477505c24780248591460f93175bac2ad87016ceb3b0453ab9918f66661aec7a12b3f05ada1577fd840a080f85f0d5cb1f48529471ffb69569069c23656e0959a6fb490f2c7e611a0450d71d274509ad5548af945a7c695cecbd632d0705878e093a2c7311f37954016cdaf0dc4a31a94ed8fc39a4c1cf23ef2a3478acbfb6f636f674894a8e28ce4b5c0f5278e334c7c05ae9604415c17c3b3f6a037c657232d08490755c7a91081bfb43385b23b0af05514def5a37bfaffca300a298f4aca570488645a494bc071fded2f142214d78fa35e5f5dbc4143bd423e1bcb8d022aa3373048564ba531fc5fc1284bb08d432865f0dbf60d3894030b7e7ae95476e1ac6d1c2abb4e7108489365d673c6e8c6ec39987984691454756a86d640c772938ed80e4a565bf8e36e05f120abf9113cf83950a80c770d557c2a2c4bb63807a753aaa324549b2296da0af69cc1b60e1607ec09b0b34dfc2f586ad3e9b5b610e74eb0beae442d8803459b4b6816e9a974c90ff20da1f60025e27b874c7612bf0d72e36307baf72e07d60c03196b4f746bf99b00d94283195bc93149daf881908b32cb9226e7fad9cdcf7a9d0f92dbc2bf6aa50a66a29872636dee08ff4a747ba7b5fc894a374b2089ac506e26a7778ff000a1032b7a2cca7bca3c86fea99cdd2eded3553ab76856fc9314f6b625d992b8489f7ffa38aa1f27d45b1c7750011773a487ae446875f0cbeff91517511c0676d5da4d477874505db5f4631e4968ef5baa3e9785f8bc64ce0d94d79e61091e3ec9904cd347ac3c6023b0fd4e6750fe42ee67016b7d87839cd90c7bebe58ad86805cb461a3bd029ed4dc983f1d8d8206e1744e5925bbf0655448afdbfcbd136910a0da6307bba614dece8af9dc9038d4372d19ba04c77a61f770097fdd4b9f17ba67da9e9a20fdb46d6dd0e6c675b26341f0154910771c57af4b4977c3ddd4725b6fe9f8f8fa9e05dd652d04358dced3718c1704e90efebe63b4f69f2e495aa6c24100b6a3ff030c9bf77f8bfe91d71174194f8604af1747de82a9ecc9c023bf2c7041023573ba30ea74492729b6253568834123d4800855193ba8c899a57619ce65ed94d5b95839a2322e386f87c92f47e869d9f84ab0a26ebc3fad760fbd887c21e856dc796fe99eb54fa48c30393b382bbb82b883ecb29fb6cba3339b02a885373f950441dc3a1084b7936ca5aaaf0ee9525e874bb3793b97adcc98afe93c4c4207f838809048e389017a816a62acf653762ede519835b3915aee3a8eb1108ea5f907711901a3b52981067ae5f2f8c0038218d6181235d0198d2cb412a4e46efd092329090ff4a1b0529f033af83aac30cba852c148d6a886affc2c32601c80b23d9dc55eb3e581f57fd8c0e02d04607161462170c7c54ceb807f9e62550e572e3375d170ae51ce11311d1727d10912865a405b3c47644e228992f5b9aa88480ee79a2f4a627d23cc27e6b0c7fb8372ba28284bd815af3411c5e7998104b194003069f031661845aec2866fc118ea7dd864fcc9d9a59e14b194b77bbce574cd263c4efef7d9929a792a744638b7744d28349bca5fef56a699c1fa41e2638aa0d0822a8be52d8f5b9282114c84ccdffc56decf13d170454b8d5beca1cd5e06059ab77a6ba9812527a2bb6c2967b54a914f0001144af8e4e7e05e7e87e4d9056d974a64cc11ce5a55cadd47a7726778dd74fff1e2793e45bf4e75cae5cd419ea358738bbc2d9cd3047639a6ce84c65390ce83161c963ae753d1707c3d840ad94111301a15898c97899de7e691245c0b87295f5a9357dbc810f31a34800711340db5936105fc0a4e97229c80322ff34f971966a6c010522cab39af643d38fb7af82c45755bb2ad395e38f587850aa4bc00c2586b57e386ad48c683fb4275e23936a68943b3bcb07369edf4f10f528be4f1602c06b55953f12b1cf603cd03c61df40467b0fdec29a607482b94b0268a80b844a96d2b2465cf9077eda9ba8ab60f7071b2a35602ac4bc50f1a13d59a6b0e2bc3f4ff25bef41770031727d8a817ef3dcd10e651e9924d307313ff1fa93254a6e7b42f50b7d5116bd7797764667a08c2f34d7017f3495556ef1e9a2ebbe966b907e23ac998e0fada79ea07b8b51f952715b6caa10dd8f36b0b2ff6ca59bb2439e1d8afe685f4c1ce4dd383177f525e33bc4890e4ca7814026c7a7fce86da257cc9d90a19fd48b5933a949ff867a52d6215e5b539ac8071c9ba7f535d3455e2a1645a0e9b692955b05287ea926531d326655b086792852552f35caafbb8ce3f872146c7db7df2b56f307eb317959112e2a91bed65d27348d36595e040c56623946d62adc72b25db500e157814564a0a751019007d5977d4a906058b089decb1877941b4c0cee9ecccc74bd65f0a0328ce1b4682d463b34d5ecf0b7ac67341eaad213e3a5168eb16c2f01f8bcbeada56d96fc85e6407705ae88c13886a65320535d901ec0a67f85b162cd23881b86733e6fe2fd269ee579fdf98ed8b647ee7f472f64d45f8cadb07c60b36bcc1ea1f6909b0cb169949102ddab5156fc717f88cd8e96fcbd406d3bc5f14ff8f06a77782f4f9aa0d2c1c392b36fbbdf8d5b0381ad7831dac5589f4570305a36a3176e79bf1e8593749717b15663ce7e9520d0def14cbac900a805650df81930ceeea1bfed89dffd1216ce77bec6136fcd65a0af9ebc864f2ceda5fd63a141633241a58ae0c49a635be9ee05517e247fc281f210f84660c5475e80ab8c3dee11613b303a8dbffd4570fca40746227fd48e9fbc4b4c0d823c648a30cdbfa868bf8b034adfad2d98c45faf6c524291e354f5d60017303f8163a4effd547dbff60ba8e5af7139762b03a2697a953cd9eae02f64bf599b10a6ba4be5bf7e4bac1e096f9c706a7aec2552383a0172473de9bc4c27fa36571d0cc8de61b67a8e638e15ec1cd8565c1e042f6928a558e74b1c5d75960572e4c3ee09c2f898ff24beaeb758dc4b786aa82e40e42ae72c83484d623bcbb034f17f89d25a588934426cc186ff7bf802c25fbc717c40ab83360bfcba6a0aadbe4f91aaf9a7445ec9e51d67590b6e15974bb6e931a5faaa926a02cf25bf742f3e5881183555f6be9de4d2ac671d3cde0c65e9f6240b2efb95cad1edf2b40451ad7331729ad38ecc45b312346ae81b3bc0620263fcccf89b9b2e10d8ea3f3a32d3de71d05aed31ac300794297e23b4f82dcb0cf7affe9fc2f829236f12e7d8c08b107cac9531ecc3eae8cb4d6dad65186f0d17d14c88cfbffbd06f117931241a46a579a2b37462dd2a732be40588b04ee5730f4e4ba051247a242532675beb9db15c51545bbd98dca7291e0955765074259b137dfdadc6fa6a22917b1c719c86df4fd67c11555976c461e34fe1a96cf200e048d3b7bf707c72b5d9271b8c25a4960ff817c3fd38834248aa21f97f70467d2ddf595f3a99ec75224f366150f1a5bdc7c14495f2c275fccae976c5ee1348ff94c4f6b96e84303a72f79f68fb3edf5182854fe19effc9169f7b22a5c72144453dc57b4c405b1a141398f76c0ac98abe49233be87cbc1f7bae2a2b5508f666d6d7d3109c665ae9f35831bfdd480268e93d34c5d785b89f8c5814fe0f180efea779736aa8f7600b9629ce5ed92c51ceb6142edc0dc860ed225731c710b0c724a89269ea8025f32f92a5ce43bf3500960f86318490dd93ace1891510e3593b166e9524371fac049f916ce9fcff96dbcf3ede2b91c13d33c3443efe0953893207bcefc2b23650fd6068d774b930621279d7640ccb66a52e9f9b142b1721200f57659129c586f165112d1aab935a7711c4294ccece4f17183fe2690ad79fc03b16b34ab9464e79194a5e43622237882bf4090912178432a4876d769bf2c3cb26d5fd585cee7a2da7872b03c3e3f6d37d2557428943b0d37a56a1be9101a437ddade7c87d2246d9577f1ee77fae9d0fc7b813d7700f20e4b8633bcc0385e2442ea146054985ad84acb8548cf06b14c563e46eab6c8f15bfca4d716b8f5dbc8a44328653235d4f52fc82edeb5b4aad78dd3379283e7cc77c68eafea7a0d06f74734408a9c45abfb1f47fa091334c988d9092261e2ad87e9fa5989fb89473272a5d228f05428080dd55fe79e196e64729f5ddb27cceb0374d4016751777694684e16952b8d145726d28d5f3588bf872ad0cb2a283b5530141895c22581f1cdf7f210e6abb2aae33ca7d9814a2cf88b4974eeccb8f93f9f929fe70d3e01da079631bc0f8dcef812a7e267941ec225ab21c766b06c26729f1c95b4261581420d19ca44d91896e5f6fc83fefe377f81f76a4f51f64e6cccab268e719fee71fa841ff4eb1f3373a8554b66646322e898ea92417a82e754cc858b4f54aaf22e594d606184139bdbdbe8c26dab93be464351f466e8d97840e8ee6d6fe1528b12c114047fa44fa4e72e54d7ff3e29b4b3f8df65a1f43169ff18f83b71ab39ad14b177f322a2b5b146e866678fdd241b0e1f8e0cf2ae8603f3c2e7086aaf9600dbba41fbf5274114cdd03bfbc899cfe9bd38cb503100124d944dd978986a8cbff6255d796297244bdd91d3f7793fbf3bb2fd1c77b9b1e2d46a628697311c005a5a3bd3e9502c40be9992850c3af8f94f73d97f23bdac05a3f57b526d01adf6d9c08807a8ac338b06b61943fc0acd827939859bae09b9bc7cea72d2c3c03283d0d38370b7642e61f2887a1ad517d199b9c6db4706bc6666493c1e587b649f19e3fe994809821a654b26f03fce12aaf2ae27eb1d35a52c997cd10ff22ae41df25468cc279a9cee0551d7de06b81b657d673a7b27c5dcc1091db8a477303dc82d5ce6d2d541dd58003e92f1ec9dde35c35154a5324ae5b9799d13036d2641ebb4a88e0c643d549522cd6cdc72562f5fe2962ead8f95656a0da4cb0d9d65e3161f0dfd4d9399bda33264fff6e2529084070d3b164783f307d0069f344c651d888bd9f672e8da1adc1e59945cec7d929ff013eb61e73239f21444cd4cd2b3fdc602d6b77fb9151396b778b187e81b9117fe06af76ff067160bd9dc62ba93de30ca806c121300b59801da83d87d7baf6733283a0046814b139d7ca541d065bc04b5d31b8d522b70361e2f55d82d6815df52539b8615bc6f8757889baef53d7da93b0a36d0067631221453e3bc4a4158e13850bb510452565c1b9cb82f47fde55b34481d2ae94ebfcdb162042a573eb001ad1a508d2d72d4725b2eff64d4febfebc18604a1617ba1a85d93ad0b2459a20990d92328ac8007c5e3ddedcc5ba2cb0968201f41f26ae180b5e84510f3356691e8659ca640e028e2148d36792e099aa459b8676550002d6d2e2145f84917c9c7f907343f51789418c3e036f1cbceac1a452331884047d1d85be5d093c0b81da8939a7bf3dea0ebca676dd4d7f20df99f66644acc339e8086970f3c67856028896d72646607322ecdcf7128aa056f3acff7712e3318eeb113d40177f8d37905159bccd61084060d26d585ee9b7a2c1090628d94e85a21e55f31a517cbeaa69d1b9cc354447de11bf0a9eaa9db5d90bfce596a4288133510ca95bf9f85445cbaab7f66143b75530e8a1b7369252060e947ecaa67430651f5d892565f8bda04e2bbebcd10b8a24b57853877ddb13fce6a2a071b1cc0cb283809cdbc9dd9f507ac1155d0c430ccfe59df1e64e4c926d56dea47df644b9951f84d45189545bfe5196cf172a8f8604494901f2aa635e6c7843ba3cbb22d531482c15bf59c0c76580fd3b03566b5016585c72d8c45a9f7feb14c5697ac063c9e27a2f1d097e19513a5c37f98743e3e2adf3f814def518a86d3c3608ba6c0ada804a696c666768ad8699d7564eb64aea4013312600ae4e0914d5c17db51705d6eb696fd88d2540847add7da1950a96c1084ac6054088b09715ae3720cce8509e0f0e27ba4f087b030ad722453618aeb04a62a6b95cfe693ce79872e91c544604d1c6df2abb39553a7117e93c70e5d29299b6999776f632eb033e11466b52a347eada4d8c7fe44a56671c34c645582fa213cf5e6c879f0eeb28b6a69f5b15b0ed49326f9f3e2b974bb0051e0ef6be6c243edfd773c71408bdb93cf8a69e1a58e266351e9fa1147edce57a9e8aac12ee312f03976d80ca2973ef2e2e8dd30935132fd5c4518fc0406414e1521d60fd9a6cdf6b5da8419d46449e25e74f15358910bb5e4316732ca638e551c131c6fec376f67159ed9b83078f1d7be67ddffc488a77bf49bd148365e94afc4ba6e92316af9cc21a38404d82d59c78d9c225f37a960399bf6e7f28d75af6aeddf5021f2d098c604ec80afbcf6ce5274b5c1518a697d36b5f563d51e6f6e18e1a6998ced1aff4b06e5ea903122ecf7e6a6362d011e5cf170f8b34c39965a4cefab5bac35a0f66fc83bff3947905d00410c2747ca891a7f88f3f17154611325ffaed226844916bcd72569241233c0720bbc0092a52011c1a89eb1799ef931e57ef60e8f7e3fc7274875f76a73e0ffb168539e9fb340d022c97a05a8e5ff2219068de4049dc6e73059441a1e0e6f2bdb0644160718888ef4c92aa1d415ed6ff41bd86186437c4a9968a548f38f87642e90e23b5552fbdf2acaf92d2d8219c01cae4008cefb02036bb8589336533128b978a122ad53f78deeab9af31d6433c621cbac5626afcecee24f13ef6b05c0ad72953abfa81c80bf8b1439b216395192631ea9cb786805fee0df8744706cb5a45f9ee28c5668cd357a9dd62e6bccd68f973cb7cdf1eb321275effe753c4e877a1a3ce8e3622474f0a27ff70deb226f68f8e87f78e4aab9cfb7e116fbcdf3e4fde9c0f58fb31e84b28b353199cc92c30bf972e1824c21d7809ca2ecdc259c42bec1194ddeec25120d67eeea349c40172f3f04a9c345a62bee0f232cdfc4198c78eb5711d72fa22ca9201323f3152b7c72350d2c9fd9fcc3e60c6f6ff962da3cbf14b8747bc425a4fc7bca11f2d0659e01ca108dc49c3c391872d38d08b66c609b5737079c8e449100f437fce1a5f05a8256f7815352cabe5508d40e8abfc1fdf607b693691a1492fd07d3e71b30e6a8cf357c7a38fa4d42abe81537826881d4d90747a147948dffd6684c0bc5e24b868addd0d4ee47e4a36f84e05b55675305bb82c347e9fc087032e1de05b3c619afb2ecc4d8462c264d4213a475504978bd678b1d403ec00d6fca7c524a7f7254e1d13a765e5f7b48035fe4943a1533ce5453302a68f78c7c4286d566fa32176876349616ed34c99b27368ef21bbe5cf2a2c717c0132285d8163976c9ef1a7ec8008140b51034bf1a8151cfdd04c1f6175fc95ebb36d03754805d2938a0cd9e5c88c33acaac3bb27eeb98ba4c326e2aa49fe9256edb411613f8c9903cad6be563f8bcec2429e6e305efcbbee8596d8d0f2c7e22fe0688a310b4d3428d7ff65a0910a3cc717ab1f7cc5db18007b31fbb708245ef235592d1352862f220662c0ecf240016682c91b899f6848bd245d843aa47a39289797d7b4e2199fd054c436e6ad9507ee23afbdc30899eccf045805c6197b2cbe6a05371e57747035de5b209fe05c28dc8fcf678d41d25495f00d2149ad8d4fb348c6ec0493ac7925dfba29bb2b050819dec825996ddfb743b30e294234f58d95286fe8852c16ef2abd291c7d9535903d3cfb1a830d4fb7106b5a551aeea4670414e8ad57e864b68fcef73fc1b2983b38a3cf3eb8c767f4e7e4b85dac771c642e2d1a36c09e1417454bc3e9fff4d3f14905d7124a43b3df97287481a888fbb7746893cbcb0b0799b57f13089aadf3161fe1263fc53e1f6aff1b7a50c4c5b9f50807734bc86209e28715ac4791760e7bcbdaa044aae470f76f6b72c6eb32ef633ecbe55af6a9e523d60a8ab70e5783b29c35e34143969aa041f712a30ba6f75280935f74e7490f3514ec64cadbf408f56f34f7c6bd6ef0fbc95632d845aaefd9dca0513640227fb135141b702b9e0d2ba67d0276790366d50ce7ea93fc830752bab5a44961d903eb6a315b9652a64213f4cb5c03c8421a214b0412310747061e3da6d8ca8e81e9e94ae73b4eb1b34909f4c4f1756b9da83a4e965b69ad0ea0ba85398d76ea65f4e9cda3e69791c53fbf03467181181339d35acbb5462c63f158300327f10ac41d901b2657c3f1a879ac89018c1325c82d938f94d0ce3d498dcbb1a2c74a2cdcee47a07306714c22c26d85a2d911c26e4a48b7017c716cf355341a84baab45037b32afc008bcf98ef95ca70b4e035855d7a9732d360d0563d8e93b2b50b5e774b42163f25a1eb80a3fdef63e3b42b776eb9534540d22bf96e0d66d363e84488d99d266422cbfa3b2f320406131948c5885f98eee71414e148e35882bf31c32d2c7fc1292a4399e7b873efd1bc7d26f5042fee4a9245ad9db73468ae992e11ec659c693aa720ebd2d8c92a3bdf1296395277dcf3e75f1b5d786042f856bf2e5dc782685eed0a1ef451964b6d937c42e2c04dcba20e1da84bb2f115536da754573ff3b47d4a5dae4d548bc54ab51a3985e9aeda7c634006f9a26238f9adef3c46867367c988772bd43e45048afb9b7fa05de8f014eb78074451ade07f48cd122505fa688729b14b3b851955e442cdfd79c40f14383333cfd9d47396bb92a746ceb928f6312dbb95b9244ea815bd16d92c285d2e5a6f1b27f9534b5c7eb4ea92adb24597631aa7a4ecccbb5bce6f3b0f3b0294c6f37e3a27b58b18a4d7e4e9f1382e8d538cad5aa57780100af53a3cd4125170e7fd1d956cac98153f8e413ce8df8ab38e3441c3a81ff1cb209fd360b767d4665b7fea46f6498eec8c71a4eacd81fdc422205ff7ea8da75e3431346c90837561e5e87319e65e5f9224cdd54dc49b2fdd629cb9859a09d5c694efe0ded9fa512deb1c6c67d6a85eacfca100fd9052787b6908c16c4e26af1505cff3909411ead48543dabb95afcd3338d52548ccb26487727ecf43140cdf4086545ceca2d679fa3b5b50b1fefa8ea840e91565007e7885a0680ef258874b40cd25994184fb51eaf2d93e9d4f4c842ea09559068e1a41ce5ebd7301576396b2f9dae196361ca5fc65f99e717bda7849ffdcfcd809722663bc52e7bc0e9fa9dc6f1565f36d679b62d75fe9bc27aef71393ef877c63b259f29349879e8fc516b0ff0bd4bed379b08a7318ddd23659e8da76a8a73483e74d05659f3eaa499af6330a5404bd52c7a2f430de6635466638f857d677748209848f14333975823bd2c6dabd698da8fb975b7cccadebbf134eeffbc1db9fe8ae7f2039bc74c6a3d32ebf614045864cdfff66a32c701c2c27386e5839c845aaf592f47a2ceeccea2e5a58028bd271fa1feb25ae65450612350d904e94317ffbd9db8ae3eaa21dffe75f8b3b9da5446a572cf3addd1be65ca89b8f112acae08e44914626f96fb62b4e70c395f6c388083d00adb3cfefa875110a2eb927a238a93ab24e293f181904793a631847adf83c8eeb3bfe25c5b588c21dd6da1f5ba7405ecf531ca46fc58605df9a981364778aff8412729e0d9880cb00ecc241ec12b7b759f5f3cd560fb6c69a2fde6bd40412a64115f63bac0e912f0b00016ce2283a48b5da7faa72291b7ed75e31d103c6fb9dca871a814dcb61fbb9a3be3ad4cab878fbb95ae689106c8fdd8a272e1ca8c1e39d81e88b0ddb3274ee1f6b55219ea271662a8183a00bb71cdbb57d890b8c32c7a6d095ea9fb98f8bf66b7c85c87b5eefb2281c416918869656b606ef8dc85af21dccd9c22762ffad9eae86290cda1c5005724e66850415424e459fba59477a6456f60e1deeb4f5fe89f06eb2d41fad8b2453903548eb090e2fbc06d73ccb3a801a66335c6f9446cc9225e4a74918788cb92c8ea2ea54cd7088590fcf7ef0826ecbbfcd3e5fabb178231bef99924fb74df5c92d997194b6b1016a6c7fb0105217ebb5536865e7cef826188550494ebcf0833fb5a8ac49f0179c058a3787b9b23be07d0aa77cd5e2673905bf047ba7030c8f38c0fb2372bd24f03b64959a62f6e08f6ad3794fcd8bda505e0d6d126468bd3aa9692f966f6bb080681ccaff46651dc5c9b099d8089658b3c063471e555a5baa162133e596da7eabdd132779e6504f51d754a8ce5471a606ca1ba68502fea6ff6128b0d5d65e68fdbf8a06f82a27f273c4ed09998b4dd2a402e1c8f2bbbe535ee794cee8c4db47552878d5d519e25c3a22b3d44d7867fc88398c424d8f460ca4a6073701712d13c624b58ce613e650499abb55f2d907a3f17802bced2966778514a58c104acd8eb965c303082f73a5a38cbb12a21d73d585f4c64a4ca833c2f2f63f9e3d9eef41308afeda5f8b439539c909ace674b2fa0452c82ee412d9bf9fc9a30ab36991c1101997a6424aefecca3368727bd769c89cf4f8dbc5b5aaff1cd5a1aef6ac5931de2a92ffb19d7058224f53516ea93f6c02bf21110b13221c720dc668d4c73bc2599d02eb4377c76692b0dce510c56702f9241a1a3a6743a18134bac588a4926c5f1a64ff8548dc6ff11854022cc2c8d4b68ff8f13d54fb658bda5a34a16d229ef39e84419706121ebbb7c2fa1e5d7fcbcdf49185081d09d70c671e913e5b9dac688415adbf07281b9ecb9671010f76e18b2cfc6921942b7115f2ab921eb968bde37208256ceab95ca5a68ab500e8a156260f0de5902dbc72fcd188ce55e12d0a8f7140440f374034977962d3a64f100934b3917c93661cb6256d99d5b4011cd22f455c9fffc2b3cef08238471c88de216574b843d41a5a649750d02d68584d84c23092aee20235fb51ebf25bf9f031e39c5f53172e096aec9bce8bae58e9502f1d44fe3b4a763e7c55e60ab36c742d28cbc382ce18cc7cfc7e1720ffaba31b56673e570987433a5b0ce61a42af37e37c0253672b605bdb949c925739a7d9032ad0ba41695646b73fc69cce71ad6290e72e4a5d3fe5ec2898a131c9c6ba421c4c907db6c89c059bf69766cc4dc63f9e40c40a41febd7df7d1cc73a5d1e1ed30523126d51c997b4d1b3b2e591029f1ad86074a7dc075afd46ac827a293cd5cf8a15f7c1d3dceb35bfbf554aaaff7893d65f6d5efed989a2e2a8b0de7f1a784ab6e428381da1cbe3c2c6a77341a574f6c865b1b6bc82aaae0519b294b57c82cb047daf1337346e3b3779fa8561d4b30fb4e8f8ae3fb10ad65e5edc876d1a4e0d755d175de2285698ddfa2ce627936fed0a58ecd69b22c0a884eb60eb6b75733b79b126750ea3c6ee5bbbfee7efe92635de1edbede78941e9acdf3332116e8c144c10a37aab3e191c11dabdf5075c4cd8f9e6e1d17f158a0213fe86c8ab0d0845b6fc888a5840121cee7f6f4b506f59975f005ebcd49bb25b03eadbf8eb9e93851777fd67ba1f044f1aa06fd8dacf671ca940a0b151996782e176ac28783b24a44414a55abfb9519c62a79bd5a5e94608681edba76fd1ee72488ff6627572b1d5738c6dfa03fb7e1a643ca13fc5ebf7f4b8dac728499e78d0cf019a7a5c9f8a05c23cda439549edb0b95855033fa7593aad06ad70d7e1123233d725230f88c092398c7e24b2abf5848b973cc28e8fe6cb2cc592b6e5cd3d3fdd4f4e2642e3d8caa6de698e37abb4f52780987121d09ec17fd2c1d327cb41d90196e7b4d58c3bb62baf9d3f579ff116c511d8396d155540f939ba83fafbd6738edc00868e548bd91e1c5ef6c8f3d83bb39d76892df91c6c2cdb8438dfbefc357c753ec98c8f05750677eb2c77cedd85096a164b985ebec11bb1258169771774dcdb114868cda250906c36e67a8751c2cddfb7676d615feafc5a2616ae438685b3c9e8852b91d072e36a8c313f04c3e7126d109bb47b9eab3bfe44630f2fb4e50b1845d9fb7b1d45f55f3ea261466a969a524791203cafb06d066d220e63e68f5dba5da74dd2ea02f392cb914d9472ff224f07f2a1c0f88209ea0d327321364c5d2cb8646f99c17ffb2fbe2e9c2dba246e4e1a5eaa401a389aa03ea049ecf685cc54c75f93e40b3aeed960860deedf8da6325a8bb37ebbd1fc619fc8142a598b3cf57b5ea3d9c6e79c3617f48c5369b45129153b0edb1bba08703382d2b44e22a37f18fdabb497f449c09c845399bfbb113f94ffa3ce2297ab500ee081e12c400fda94aeaf968b76c0839c1b1f9f1479079713de3da6dd5e523f5878547bc1c4878a65252a47bbfcc6c51db0ea15167873e3cb4b206386fc2ce60593b49e9e983be4365257d0cd4607e2b1834dcc80d71bf934d5526a86a780562b7f865bfe4bb35b09b396249caba02d4705e3d7bfb1458c1eb3d80f9d58e0e0468f4f0a3fe20b02d3b214d2e21f446c1d96f749ef563219e38d8eb696f7207a5a2625d5c232c55257101b1375ba106b9dab7a24c58dd46012b4d6529e5dd46d2aaa075e07fe6a6d82d4ccd2ec9a41cf9f3bad78762ba323dab6c6b409bfb70cba6f7525b6446845f361d3bc66b420e3ff3c01b1c11394aa1b342d54d0b16424e234143d271852ac7c5ad09cac58ae64814354e88669a377011b3374e8ccb590a1ef45dfa97a2271b46c054266fdf531098cb86ea3caaf32b3f89c1ddaecec6afdbe8dbc6b535763e67210af18b6f2309a73ce6910548afa196271c0a270eea43498c07ce68da7f0d5645508195915342ff27fca75b1f721821c10808e6cbe5a2c126bd44b77a8353cd2d43b9d2dd999a51bde4cdf8f17ef88c0a8a75707e260922e85627aeb54bae2bb892fc2d5364531738b2be8ef75c32672ee249bc9ed13a1df5584d5af98e3f92b5b94ccc170f32546c26b2f63bedf8b6b230ab0655528f962feef6190a7e661ff68b7c89f2069bf807a112520dba80d819d40c5662d5aa50e864364244f3e6e7b773515400ee15dabc44d2eba42c0b7730dea82ae6d2efb09b1bf43641e1e14bd9f4a35bb64e127346c6a75619c270373f4166b74b1e37d8b8f989cc6dc8bcfdfe5e93e6e7ed725a697c03aae3328a8470e48e92d72ab37ff44566ada291bd99ac4bb558508f7c3b8d1097f67b44899493f52ffbd1258220d192131e39ec31efd94590d98979fd5463ce6173f435f5bc761ae1b7b39dca2d96251abe7477398e3644444ec47c74781565beb3d3b8304bd1ea05919eba8490f906919fa3f9d418b0de0392ec237997609ca17b9213f9e20401b1f1d10eeeb55321fb3eeb3e5b38d0b19b741182307574d0db07af959fad9156edf1376c114af203d20fb809be7527e47e3146794ae4d3d597228894aa4e4a4017089932d2743569fc4fa3389a72fccbe7929ca0b64426f8f1d7abd354b16e94a430b637eeb4482563e01a8d80c54dc5c9747f7a0f5422eb405d34392f61914e721686a966a4e1954e7f9b7bf8e14c34606871a9f2f3df55aae905c961dc7adbf8d698259f10c052c6559a1dda833896b1b5160646cc7d72e365ac9489dbeb9d0fbc737e3ddd6a59d03f802f35013d24de65d36eebcfa2798cde2d935af6126c99e25e47b103ef7991b592e63f5939c3adfd0a4b0463b5a8ec0d5f67a1b783f0d5b0f45487c98aaf93d2dbec0af130808e77751411f40008635fe49184a100f285f6a543104128f111a252ca4534cf4036135156f24925899b0688eaf168273beb4691ef1f9488231ba46daa4ade49a45ff5791b83ed16fc6884f986b2196b0cd09af234d30807cdd704eaaeb325769ab2f49606f569de768c2aae681159f4059ca8d4a2646341781363bd0285754da576f85cf85b59a1bed89e3638c2cf181760dc2c9eeb2f48eb5c8cb9989d6ac95b024ef31226e05e146091edf97ba51c93c6510e4f09c12c5ef17ea3d6c976d00fd4f2c1c24e67fd3838cd6d075a75a440a3433c7921ed539aa1e45f0c3db9b9484d071e7d187229d65a78a00e3286c7c8f81983dbda6d243c3d30e863230e7190e293","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
