<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"774c339249ba97c6196f33d27da1928114f6e7c1cf6524d469814623185414f0dda6758f039f1bdb1e1b5ea3835972e786f7d49b4328772b0b2a099795d3ab3c3a8493a84ec2cbf944512a3417981eaca5cd5eacc72394fecb4efd781d358debb588ae96c032606b58be6db33a123b2400e515a3649069a7c1600be89ae25bf9d77a16d88e340bea5eb8f46f692be3deed43ad3051b03efc22c7c5ff03920c6bc8a7b9da4b7f05f13ae342a7b1b20f8ac194d60f2c5b7e36d8eb24187d3b8ee1896e4f25a7bb0933eb9c011c1cd1d128ee817f38443ab594df4433120050576f850f97133f5538f5e6d4196736cbfd93f5009b2ba8858371addc2ca4f9eb32ffc65acdb1c111dd9fd385061a4bbc270445c3352cac75f7b392bdbe19e972ab815bf41e9804f396bebcf208f434033fd6b3fda2fae55f0fd8a1b0689ebd8a203cbc863efde68b1ef258eec795a1816c00edcc9614386f147bf18a8b66ee2db4663514a8ec50a65a1b7dfc1f48d267d1190d4791b24d2250f7eac5aca1518a5a5f19ebe2c100f081bef93f1dca5c12080c01f8f97b20bdf9a337400d38f62d2a936dfb5c7a0e4891bd0bd7cfe754cf9175687e24826d48d6ae8a549acb90590c3cd923c2ee2965ec47b8f9f7559529df128bc7455d071367b1093c71bf62ffd2b404868b9868759710112f189f1c78564435ac5e953bce9e47066a6e3d1494a152a7e3f6a3fc2a4351a419424340e578e1a9b5aecce6e52b2b906bba6d2f8263d6e30ffd361dc3c03964f442d0d22a8bf9374f699a9435e3cba08c0bed2dee1675989869bfe24d8119f5ca8af4c3c84f9e86543421075a8fd0a28fa8a5654aee84d2032e59d48f26a1542cdc7b1eb1225540c1ea9c913035427dc1225b6d98f7540ed1acdc80eea53ffaa4bb850f1748662d87dac1f1a42d514429be934423d8da376792bf92a11ce7896a5d4a2b14f6a2b9c0f75ede606ffbd40d51783f7ac5b2b96032caf92188081bd4a3ed3eb48702221c5527b5bfbb74b767e5d83552ab23b67debaad8d149ab226ea1bfdb8344d80344da1e57ffabd7980cf4dec75eb03273d3728f5e6e8b170cd5fecc2ddf952b528265674ce31088d0e6b9a1c0934602bf1fbd852fd28337c62461f225df3bd35bb6b0a80c07e2e3378905fd5e69403559909591246de92508f1d52816e8cd4ddcbb98dabbc533f0662a344cfa83e1c9cb0a2f9f9a6df26337331999570a9b8028faeb3b1b0a03ef961630f430514e443f3f9060a8daf510183a0dfc8d1d744f5c0325cd9a24d6b1e55390ae2c30571303b13a910b593a3a94acaac16468d7eb9d6d676347a8a35ec55985832c31f87996c5a643cdf51423db9d09d5d95914f6617a8008109004236427cff6feafc54f8e17fe95951749cf2afa4a076362b6fb292ecab3104639247e155ded3b48c60e8a79f9331dc30715e6204fa6b96c96251686f3eeb3a4a1cc311a6312d2c20933f64fa3c0dd5869766c85b1844669dad8b59b79a2e8e938facc6480cc511678255a948491c659e7e59524a74465434f17431473590d501c8c14ca5202335bc330f3bab5c102027c511fe118e20e8ce705c32c2002a6b453fe75e0ecfe5a45053f8c68747e6b6c9e1a6a53acaf0570633a8dd6dc3486f2cde4145e621baff74c2ab31ebb9a806e44cc69272acead3dde9aae45e3e0855d0cd973c1ac9cfe9465c17755ae0b1dc21cb829e052f04b30f97d579d7281b57b3ad29a9fbd62384a28cd950df4d4577be09646295a39103296824d595e79160f13f43cf5199a51940a3b6d9c3108a651ca8d9013d7e907f7a1a7ab5ed3e2327d1649a6b1f0c1e3c765b01aaea152e47de9e37fc12945e14b1d5196d0fc9197114139a90273c5b4d7455e4af468ef07cb77694eb97ee2648d41d3752c7851b79691787faedde52057a4c392913880ba92e712897b6ea8d4dc6b01bcd7abda25b64d135312c81b9cab015791d945c68da50365f9e17a1657c21e2ac3368e0688bc87f17c82417e03b289c8c900475ed55d5dbaae14354cafcd800b0455911a53ac5beb24b5bbe170f95a5e586e7410160dcd729ea89e4dd5d9b15d5b6d246899a9e173fb7f478197bcbf6cbd66467dbd0a0e8c907cf48a4bcba8ef6de4115f2fddbe834bf07553748bf867174216574650ec0617d6bdb9650edcd723fabc53977e2cfb04ea5c6a83f40ac63efa5d35612212c33e14f48aedb1078d22846bdccc11c1f0d2ecc68340a2830d746497d55baf64b4a71c01e275cf6692a22ae7968f4137ab1e298c665fb30aaed28880cb16b4f9a1ef4e61022eff5917128bda50f0603d4a0b7307d69fe86d43d95772e88d258cdea882d8ecf2e73ef21101dfb5dee416e50674d33a2aff2bc5e3bc0efa508f84f2c7290696e8702108bca8885780ab75cfb264fd9c40170aa4a1bf576a7b144e472d84b0e258a942a75f83fb8d862f8892f6229dad908299eaca7dc50226afe1d9c90c2706428e668814dd56ced59106d2bb10974ac9ff3a4442f14bcf142d1a32caef1a92bbd0c48b5225459b0d5857650d050afe9b3019166125c04232797dd67c11c53c8814f726315f1a18aa9a2cb9893b829d7052c42f9e7e40932d5c8da39385e5398bcfa45638874e23a00979ba70f1da01f09f5258b91e8ee249e2aaf9c030599e5ed3be059cef1eaf5b785c54c713cb779c4b30183b201da0860d3dade7fa3ac76a7e1de28388718e6af7be410b2cfdbab8f20bf1688b01477a6dba76cf8ecf78ca48400fca01b504c5180300a9b3edc005e5c279f55f80fff5926de15f2df7411ca0de4cd7db852f6e891205849b2ddd29a62cdb36780fe64c253cc37a46163d8030d87ea48100d26e429659e11eb50435c892f898dd4d731c889db1570a3170a3e142b44d667cfeffd5ed5140f632762bacf255ef108c18f8d1982f8dd989b44ba700aee249638281917467a54d454400d5b788f4cb6f66441778a8485cd764b9943af9d87e2e0628acce76b7959e4ed151dea42213061403be61a9d7d57b8587ac178e2d1ece626d41f7703760abe8d39a81d66a11750478f0a87f6ad5bc4eaa284e43af6b8253446ef35fbd6afdbbd4f2b5ec0b2c7785aa1d8e07522e4e4e3ff6627bb7571ef3211849d00538a771cc8cdcafe5ad3a860d1e299f5ab7d89569894cd539a09d82273fc7df6867749a5816fa9eddc850121919a7e3400a15454048685fb2bc291598d45418bba244cfda5b33fa08cd718277a5cab3f0992f665f95ced42084460d9e2d119f95b3d4438adc9ef0ab3cc07927c67b0673400e69ba704614df2fa553aa4e19722fd7f068a309622124644b0205e527900fa8689ba0b8a44f6ff5140c229786d2bc46dd1378ef416e7d52cb9dde44afbcf69652e4c106218ad6587faf713f6a6104fb1601cb36e9703972f6a894102ba9c9032a9fdc595fcc56af3405642bcbfafa2a34d0668bd75adc5176de27764f89d2d04d0cf594e12ff0be8e8273c33d7bc66b08b402bd7c19549d9800d5e46f42bf29c1271a193cdf15267970683d2e61987a34f75b07feed267b989a35e67b7672b1a3d3fef175d434bda95ddb8179205a8dab96332355010b92826f03ec1317cf8918dbfed263f4bb459a0c52f84dc16ccf58788865308690bfc6da25282bb2305cc2eccd4ffb5a6369437085e18f26c91c4f90fb2aadd84d86ceb6fcd6b48569e962a158a5989e0015749070292c35f94f67e19450ed562a658fb877fdb9316c05a8c124ca09375a31d360c5c6d9e92bb8f67d03d55e7a421e7b7e83a702be145e3e572854f8753472f95b22ee56fbb8c8f549a60acb37eb82cc5fc981bc488e31a13dc4f6232c0d045e79abaa19d7c2d278f2565f0754440b210914db55cef37ba78d5cca1e3de1d0ca226cf95d279f42b304ee4ac147c99b40181a3edd4648b2e9faf5acb7923ccb083325895e77d5e5bd691120e5148c726f7ee30855fc331112e93ac5537ab2f12af40746473f7a15430ee2140aed61d23b7ae1b44c0f92e7e0326845d20585a33021efda5028cc3c15658daffbcc1dec4cb14ae013b9a04a7291efcd816189f7bfba8f81792ee34674c6ad6af6a826ecf2a7dc3d649479914fd58f7d2be57025137178c7dd995525eabcb82dea57b53e19902885aa3b996e704b9e036797f73b18bf39911b6a717c68161b9842a0d18ed504d35bb2934a7f078996c6dd2a1789ac69ec0e340471b6b50b579fde5e4add1c7f5e2e9da182dd1ea45bef3357172cdd6678a0cb81e54a74b487db51168f899c8ca2428fe8b9b3d7e88ce5aa98272af753856d46df4070f9f61640ea0e02ae831469aad88fa105f581b5f665b7613844587703ed726d6c4b8047a19bb06170fb96b02ea6ae8cbfed9479ca003012a9e2b82094922353c70ff6f0f459b82010f5e993ea8f97bed9026a60ec1d622250b98d8924dede12afaf24ab97ca012851e0e21441386cf891916c9d7b5b5db9e164781cfaf1479e655b9ac278870240a64ba6b7e824456658869058ad0a08dc2804ca0d5e2a29bd755d15452ee9a0653e2055e085e559991ddbdc20c4afa0ad73dbabbcc0478e9d00386118c5d89e491848a66ccab950263ed980cae7e7e427c99eefa31ee3e26863bf50611bded5849ac64baa7bf9ca3b0aac77cca2aa07d93596e6ba78b8a134b1829736e6b27b24450dd6bbae2a9a15c08c1217ddf9d26c5e456e61e89dc7c0b3b3212853b6b0a5aa1da1bbbc0ae0f07806210f1c69b91bd444a52f91c535a12d6d2548adab946e05df041d14ab6363ee8b531837c51b6e7e1d084eeece8ea6e6707de922a9e35e4289f0b87948ef48a9023914a6e54344e9f9d94e96a9773013bdee8c2df15d94f5d25950a7f13a7dd2d49eaeafe00b9e5ed816998db898422722e218937206ce43b459d3009428152c7aeb8b55a2675733fd4a5afc4ea4851970ef8a2f25bfc6f3689b621e9db391958492ed436ed057af805bd8d44cb9362dc40d1be753dda39a90e956c38c8938dcd0ea9dfa54ed15713ea27ce7747b8cf06df3421564957c7db782aec28a8254fc40107cdade81d934d063b34aea1c8ec83e263d74475fd6cd37605f713eea0877bf6b0d87f0aa8e45e0832b8e240277ec8dea7d4382cb7fbda3b675fe55352b224124e4d02424c46c8f6b910c3401d3d0211ab82b7e5c94106a767c15f7f25e3d30ee6a911c8dc68b4a96707bf8a5fedc2d2a9d11414ad1c9d3c5e680e9a2e80a11f1ec3a5b49307bf24103068a0a73c935ec408acc233baec82a4a6a4734f39b1ee1ed41afef21a8c931604c85bdf557a795d83ddd6f5c8aa9c172fe9a9b2971bf94f93bcc0e258b18a437c4cf17b63b22d6f2d25af276f8dd2aa4b6901fd7ff39a9643496d7f4db86897a36793633f28806427b8a0c8902fcbe5366f4e40667dfbe1ac8908a40334b4acc4bdef6560a8b8fd61495218a05ce3a4ed1d4f1760508d07fabab3a69583ded430818e0902129e41628611401add0699ef5c7aa8c0cb23733f83fbf559388c80197fd2314edba17f694041acb0fa93c06b4c175d98923b373ee7c5a34e389aef7af156e0e3da4c085c4e1226fbbbeb980816481d77430edffe238b70b7883a2a890d5327b0dc530e159811958edaf3824d4c0b8fb0223cf4f35f575d8e01e7193bccbd6406ef66d15a0d9f77aec29aeb5bdab8be1119a860fd418b3497f6338e79592cabec2b1dd91e20abfa8b55fe05688c359df6a7f16235ab13741ae856bbb230ba31a08e24d3e5932bfe8f7163623df71231374641555703f345f78617f47cb81b15edd88270a58b0b68b6ab49338979c88dd39605cbf112d2a3c79f23ff83637dc9d0f6b4d5f494884f7fbc0ce3526bb70f81c17e74dab1be09d09e7b7ed1caf2cfa46d7bfaee34cb4e1840c8c17e1ddd7338a0dc8ab9e001fcca8a3c068ac15b93ba93b5293b2d5521998188df4541038ede47b71cb29489189fdd9d71c3de2b22204bf20bcd310f6c2d5a6c6415aa069de8bb1b524c38d67666ecb03ae87e2c72deb466e1eeaaaa60c27e9191e60cfbe1e911be0dc922833fe0f48d9b0078dea0e6447e769be1892dab5e189e49af489ea79ac1bc2ab89ade0b6378da7bd396073079595598a2b4c98e98f4ebe8c69cc4d7242932d90cbc2420cfa28a763d630d928237a0a961d40d4f3e9d271a12dcdfecdb911dc477a394c0018b25eada9f664aefe634b13cd3aef8b9d817cd3e09b4520b5ac56fc3c9b5fd1594d08959049ff82d8bf087f094d1b47f7512f3c808f1154c9d6e3df3fe9ba6be88bc4ec6a9415a71e6ac86296367d07c7a30ffe35582107c2816bc6bd6751807bff8ebd05a2e95b28ecf696eaac1dd877a035c6eb3c61ce551d2df604c05c8ff13affd8b51ff453aaaa1942e3c43f4c5cc7061bd54e5742b8a5ccaa39cbefa1f96d6cc2f009544a24cdaf27f0220fc694b09cf3538aa9efc9ea8f7d2a5c5e869a5b4b5c43bfaaadb6a3141fd76a9eaaadda2e71ada3b2c063355d6f584c96b8d4f0442c22014f1f8ecc028e067cdd3d7a71f65d697be5f110e4b55a9b57d1d68bc21dec8b18855e8a6e56a3c01c714534213d8009fe1af8706e176b192ba1f55f69934cb119d933b9962f1421f7d065e57cf1da653a29065ac033bf83b1d3315bc2bef677cc28fa17ac93ff34ea5b5d5c5c8ae044b67788ff0c085909960e44b55490d666b8372054efb605bef14064557d24bea6e678061ecef4331387bca279d4bde9716608e64373a1d0c40ca03bd86e33423545bddc221bdf922d89847d839eda1097cf1c3dabd690102a5efb724beece8de7c1869ee37c18b6c5b484fafe601927c42235147d9db3500699e8f46466058f4b22218b4e533e3bca61ce578c39db915339e16e0c4a333de33e47bd285a334752d25087ab292fa5ad5f410bdbb49158bd18a3ca2e37240f8b9e8cf5805f424f13cdbede58bec6ef5b0051fe503c9a3f3014e9b0078d6abdc9595d6c589e62282bf5463f3a43d279bc74b532b38da18e80edbb16d79ace76202f7dc3490053bd951569d6f7e10d6c1a33ce635dc6654898fc4fca55583bb62335bdb9da531ba0f43447e724f1cf90cd18cc442d6666479dc6803bfcb18cf04388d503f8e31ebad7d5461e13bb9f3cd3f862385c097fe0800f777a374e96a425981451515ad1bb57b57b7a79f4a0a37df76585b3def0dd3eaf76a4053ec902a4891cad440383bbe66cd1b01820e0ae6ee8bdad1fa829877f1e29ad4c228c8a92dbe667bc56dc6a47e090418f1d259209261f1c57bd5e63e369d4c515b33e66ce1f70971892ff90fbebfa69ea835f05f83dd3414e19c8087ad2407827e2e5bc19efeb689ac565c08d9e766e7ec9a9dec5380fd686bab02058479661067e044a216a65cec0e02d671da9c792472f902eec575d274775e329d3bce457155627bb3f25b1a295541c447eb1b64c84b905ec4cb9cc6ab875b00dc0e5a8b1e7e29aad41c9bccab657cf5693eebc9d26cc5e4358481036392eec55afa6dd437a0e857b94fc2c4f065cfee1696a12ebfd5507a0560c048c25fb0d18829dbda57f0a736a530e99924e98b6b129fc4dbed5c6e4401f8cff2c137b92f976218a94d525f5f7bbb7b97b03d026ffe172ab50ee232663b3b550a7ff461ba643300ce214f5106b0aa2e61eaa0f042d1f4833b5731fd553fd191f1fd64e82007f1fe001c01d840159271c5c0faf50f865ba3054de1accf4264a5a7a8d78b10f989d6a6d0290cdd7bc3a4916e44bfb35409ae714724b4fa1fb98f330674c312c58272a5511d9d92e8c1d102234a8d477f04a7208696c1c72bd59776a66d3588151bf4c466f439d364a17ee445fdf05a36131e96c985b1e541766b8b91f266d9cc36712be69362d37a794e1b73241f820c4615aca371a31912205eb6523ea20d347c327b4df2f35dea927503ca52a75a001b000653013d4164c67e7582a5e199b4544058d1ac599a660390ea38e8eb6baf5b63f41bb99f9ec7c54e41d0992d5f45b815d6206ab66783ff16409d2f608498572a5a4f0645f182f3986869770eedd7b53745990df8eb87aa040dd51490ae449cc6c41b7e17dd2a765c230b61b6ee19722f0367910d4cacd64894474a93b587afb041d7e2fc255498396b792592bc5e93fc7d761bf5aa8513c443b4e9a96c18f4e4eac138d824a9225341de403caa64548d62664b87adde96199b114e35d813643877c8b3f2061c510dc6ad3f03bc025df3ef899f150017f7d2d3f3604f7f7da6530057b5ae8a24c46614319ad1c4045ad6ec5fae43e91e37c9fe0c20063d2320c8d1b98b2ddfac3c0f32f355257265089040dae58a82be29d646691a870f5685add85fd517f4cba281f34d22692a490272c5b935e5b4ffa03deb2ec60d460c5637b6575606c74a95033d6f03d53292f6abe20a1045a5c1e4cddad33285e55ee86d53adc638e3adf924058a85228cb9e51b14d48d1286401c8b7076eea01995bde43ab6b4d23aa9a0a2e4f048046756ab61d1c75cdfad98f25c8e4748efb9c7d0f92b90a7741ed8c61a0777194729e3dc9dfbc6e5ac0a53508d024182ee72a1860831a70aa00c764826cf063f57c7afa42005208ec1418c262b81a7ede1c0100fdc3d844df3d841fa4d058a36efbb235e268140861e4922ad9cd49d5b79c9f58c0af319c012b4615686952c3aaf976407375f2d026dbb57b0c7478e7fcdbc9ff6ea2edd35f18a58ee1af26fed4604cf7a24f25de21c16da5ce9df9f14d0dbfcf0eda9592798c54e1ef3cef74b9cb5ef18da7734158ac2144a511e3781a1c2cb32fd5085fe3a9ca9cb995a60e99d42172b3f17a555db6295e3667eb8f7269ffed327d0a906d9311a4b47a71024d97184e6fef7db8391c32e4ed93dc555cbbe205c8f7ed28b883b1a0d945aebd1589b24ae4fe769baf60d8822be6ee15f8d30d4b723900c79b8fe0b24242148210f7a6e91d987b3a7fa4c612785857c28ca0c775e592e62a7f8b866e98429eeb59f4e582b897563467f3c0644b2dbdf26fb304549630d75de1973507f08c5bff9963e67d9fa840b58b39d656c46e6ef8710ee06bb519cab0c7d5c4ecd27fd6db8e90f5770602a46e95ae733a5f21b11f7d221e55d9566cfd3f529cb25e552b1102326aa4a374454591a26bba82700cae94c9831385de8b18398b2dba76f90ad1bf51838a4612bd9c2bcbe8fa58ced51cb1bb558231ad64e82a4427a7dcd506572a36fdd79c8828f7f07ed9446d803e90039255e7200d9dffd75043b28fb5d8c62e96640e0c68337b853a965cdcdd8b7ac0ea3f6f73a64371d80bfa1454dad63dd04e3a6ec53c096761c616b4c1f31ffc60490d6299890ae115082dd2a64d9f8b7b3559b820423da38654c029db683dd7ebdc63a2968c98c5d89b212f48930f0f86d9b16c73d81af2536df2aa64364c5692771211170abf9a05e958e7901c708315f84afd33cf0d8b03cc413f39aa99c062ae75ae9d1c8b5cba90168e1fe8c852e9f20db10cd2b45f1ccc2ae1f177285ec2c35bbbc3698c1d0522db343d03bcf9f6c11eed9c8e24c023650d4d14436c2d370b89d0df7e1b01a01e53e2222b6154eaf7b63e288b60a547441aded3294d5471d10dd3fbbdb62fddb012b95afa516854ba7620637713d924b24be53099001fb156ba0dfd4209faa5d2801b7f80eb9048333d347d7df34246673ae063fd8da6aa6896d5a30ae678a8523c0c05ca25c43210babf6a320625e3a3e9a0a0f84cbf3ffe2626eaaaf1367472247e5f8b274156bd468b6dcc8193c3effdbc721563aebbabde4da3fbb37808b1ca2aaecb6ef71ac98e584f8c6f74a3d7d529ea22336182987b2af74922a406097ed9bca7fb1cbe7a823e29b2262cc2727399ba51bf254996b84e75e43cad403a2cd8b65e7b6af20972a179811d0f05e11fe3fbfc0911eb6f4ae9989ae5ce52d0ad94e25492adf11f9d93ca711e998a4fe0730d9efa56ffb77126d0841021fc7acfb6ef058a56d5e412f85047dab0b22fdc362fba63e5f64a8c6db36f0a05b5404aff5ca9807f8674b7101f5099ddb203b97fe369b05c2d08a07cf166cbfcd106274ce76d31e51c0754fc155e7492da45b7769602eb097d31e092091a132ddee1665fa57ed20b460654376684c1b2da350f696fec4fe92f450b9540a750ff2c1e22088bfbda3bc3f920401cc93e9d9116dab511ccff987fcaa68ed878af9347ab431bd6bed01fa2952bfb0fb020e265af3efe6b5208135f19fa1b47a6404629b97dda9440da5f95aa4dd767cc50d9e8f7f3f45293047812f7eddc690c85a651e9ee87dd23f765cb8f4c0255808d3c3c70c8aba5f498a26c8d23f2216c121019ba0d993cb5e6c2f822aab359c93de142ecb7799df9f2246fdd1f9dc841a2454dced90d5b26c6c9b51b107244f4316ce87c40014e6192610da47a4609a9a17546bdd018b58201ed90c58e11b4431e2ffd18cee419ff0adfa76f3fc55e006e81839695d78e549cd51372b51d82f38a48f5d2b2438a0a7bb682b204bb595582481ed9159e24ad93ab929eb542a78b6d923986c92b3911ef05525479e6c430ff807130c70704476642f856a47aacb4b62359631a3b5860f64dac9d85cc46795c0f0fa796a703e331abcb0b065419845b0a1a2326cdea09013a36162d7de0cd1d6f479d55f8e88506fb05fe5cc6b095a4463743021e63f39449990d6b809824db977cf18706725ad59d2e477cbefd5476cb75021218ed04b6b6c508db15892f7b6095fbec6d71b592a2c0f7c793d229c1b66144f9d74847522b61381b99921bc3a57a2e5c3d1f1969a65673623d2f5f7a071f046bd6b51169ac3f3025639b35863b0a1fdd365a23c3cc264a37cec6603e238bca412ed09325cb50d2187d44f1010935bb28f8c21a34741c4caa6a54f6fa292a3151a8028daa82acead5ac7af3a891a9922ad2a15cd63bacaf7ba68ad5f67b4dcdd3e19183a0297b7d6702beaafbb3eaa719a19449003221341f3e403bcce95d18cde61e3355c9d48617dbcd69d62a7b3fab9a3643947e6a3dcd2222f2c75419ca95256038384439a1186998e00af4bc1d564de9ae17106944f9411ca00ee42d053037d7075d1fbf85ddf521151b1d5e47d70a00c36ac7560ff07d530414b8fd8cfeef7c320eee566c032b268d5d1cb7d8a38ab12d1ab5c02b5cde76f00bc9b7b40e23d75fa2c90e293d7253900be84b8d8f00021ad0ab95781b4aa17df350f6535a87c7196c2edd5c62e841a6f3ea0ec1fbd04c2aacac232eb143a5d83f251426895d8ce6a6c8c0b32e60e8ad34813d88139e3587429100ced9356e98d6f47b4452a523299406f63ef2839bae2fccf3d512d65ef79c05cce256f9b73c5554356da499e2b8f41dc47b565a51240ce4e700c21036faa0c455065848bdb14b57cf488f61350de9d211f34ca415e22ee2d7c77fcd17c6f2cbcd4b0637ae4cff94a1ecf73d2ec1138dc0fd4036dcf03af0084d38edbc8101d2bf82e12c077de3231a3a77ca0e16f393ab7bcdac517767a1ea8cf3af7009eb1ee23cdf9aa9d9cd5d1d9184138a49186d13616e48d4c212e5d1e48645c07c45cbe16bd96e742fab4cb20d1f7e42ba6c0641932ad8f0d9d745d20380f8d8613d23bb4c3855172a5d4b6662454ba7ab9b9a0624a32f3732775257efcc70193c61afe2e8e7cea1d258506e59b290c3fa224f2f315a600abeadb5686a2f4b98a0717eef978de732d25a4aa5dc5f58bb8d39ddab8611fe91c96d0b6aa4a2b47f0af81fb046fea71c74d6ce0dc987d41e3597b32ca0934c2e59f953be06c2d23ab572df1bfabb2e1b05f949b17b34d064c78547b6978ea520a1047d619ec27c16284cbcfc62e8b411e3e9adc9034d0c23aec6e8e72b9a3b65752ff5459838ff0acf7e75327b43bd8e68eedc66f107f6b77345dd48d89d39da9be838aee62963de067d8dd7c61dd1538ca39d3f4e82fa5ad751dabfba2b2437b31aa097794758669c9126768c7a38a9bd4f6d409b308502f4192033fcfb095609033379d291d76b08b98dbdf640a870ee32a484d4a6f26fdea20de4e97d00be011e10869c5ea0014a6af82a76caa9ce62e0e6c998fe440cc7670875eb9dd0e8e2b44cd16a781feb03ea96dc7397a2e834b73aa1cc03dbd7568d72b8467571286197bfd4a5f7a210c67f4d71af02afdb8d3d053b5430bad8f6edfa58fd2c5ce1c3d4e3e8b36e48c844058e60d4d20d6dbed7a63ff10d5e5809da119eec3d8c69496029faf236e224d4297edb016165d61880c72f985f3667ebb90b3ba56f959b688f2d1e9ad0e23d1911a05b58a869d866974fa74c73a2ddd189460e5ab2a3d1c4b7b11b45d03a63bfdd8651423427334fa0d5220982842a90b6867206f494272abd87038be2c7b3e175a90993a3c7f21e3d40f5a4c30944fa722e488571ff7628c9738005f7f3d5fdbdde0c032807f5e60bf2a2e848de3d7afec2ef79522b18a85833ef5f60410c48bf0b0c3925e8a7ca11bf41e806165617b61d14e0063c203ee141f36013b0d5dc35a894786486781afe8560d93901c990ea68df1512c29f26dcb36fabdaf4c587462b5dd371bb868e9560407495d67dbb04427914a9f860dbd98d705e77deeb4de2d1764000bf426746c478420c013d819f0447f06fe37342ef7bf920e6871670b27383f24135293cc51801404e8c6ecbcde94afcaabddb249d1b4c64db8fa02745a60ac90937e181ce85d04ffa1c59fa27f97c8efa2a207d7fc7d65064d564b12184cc6ee7c33bc4e92541396c3a969ae1707fbaa1f2c1a1449f2134babaf54271885173ec20c1e369ec9bff3f69a8ecb2ec28c43452c11e4120d2b518832fe30c7b73b8e49a04f824271f03700b4d70e7bb68018be9e953190cb8b974170238c1ef286a650c7724df36e401edd12ad12ed326c5952f80982bb2da371a92451a7eca594778672e4f13d4c2bfbdea8efaa98531b3b5456cab8003bed90a652085c31a2c02b06fa55d6145fdc5233ddbbbeea1be465922c6feb96b9f9b90ea542d55a75152cbf5f25ad7d20f7af69426c9c86643fbadc1011c3b4b2627f41be3fb445f9739331a837a9d9e2c2d4c8c1316148089a358a68878d2df8b4387dd079554d6fb0c42eb1d446dfc6bd3c583131ccf636ed4ced4c05471d50d9de5cdba8522688e26c0e6db1ee3d69e45208a9e57f59f636d1feec7f3a6fff229f052d89be6a65e7cf591a4b11e554307ad76b84e7e6b0f69142780ac9849bf02c07441649ee66087bcd194358f65cba6a3c562a0af58b67be0456cdf994cb405c81b7f0521d76eb43a0930a936957ff4a5c46a80244636579a747e94c578dd4376100a8f73d7829ea45adcfdae9dc3442aa0063621518e176a5f4756f82d725e07f6b61fe35505f44cf8ca615a47989083be738478ea3549ef2a083593ce9a543f2ee006b5c08f581be73cb76d462bfb691568cb1b82ab946f0c5e0e8d64d94f6891059e6e974c35f45c22ea236dda686b27ea85e7e92cdf4aa8c1255bd0c26383c2ec0e77ada2cab5b72568577629b2ab2aa87832cce0b6cb099cf34e87933323a161656c7f2553ad108e5174289ee378550cf408d365b075f46917345a3c149b37e47272f7a7b7f70674d39c97b70481f613a2ea98a314c010cad3cf548e4fbf88b4abe6b2117a7608948ed71f565de5acd96410eed63d572adbb37c4bdca8500f626ad00c93946f1d1edc7f73e7d7ccea2bf239fb0220b0f358781ba88c4b295902977b7f6a5eaefe12c078e95c530f260cd5bf9d196152836054e3b08bbf0c4ce874fd2fac3a9ca390b04815c8c410aef91474433f953f9241f7d1fccccfcbc648f4d24b244ffa401ab53ddc9a288c4d8a1cb84d9a7c2c828a8acb621751ec79d1ea4ac6b879c569dd9a44f2c74d496692fa8f01b21facd09c09642d8afc9b247a2252282a3d9c68d02abcd5d64aaa965325a025c2d83390eca64b4e69fb60070768f3421b133da6bcbcb964190e5d9ff44eae070a1ab7177ba12779c228f50c4af4aa541cde2b6ff8d692922670d779552063afe443d4202cab1c72b1dab93820092bd396911efdafce62597fadf0c211c9fcda2d2da64381e9a3d84f1a3ce529ec948bd0b5f72f001b114a34ef818be7716034e6924ff42fdf7b7cfc215120655e70fc2cd3e7d91904cf9dd1ca2b0598a8f62fd0c536cade9da0c946035658b5093ffbe22d2bcb3fda93bd1ce741df366eecf932598927b447745e4e5646c95539d00340d9c776ce798501e3cfce0ed3e31048efa3936371b06c876d197f666607ef09bee1a892856ec1554fae9b0b4e1e55963f792bf750241b78a87832d2fa57582f44573dbd1b2e88a4bf40b0fd61f32ae1893b029c430993eba453757f6a23a54318447640666a3b90c0e05b846bf4ef1a8d799e06f953d248538fb1ca1452d32ed2f4087fc205557626ff125e88005c23037ae6f35adf3f343cd0f08f9793740eece5e50c437b2fe97b9f04bc07aa12ba07e209b93d71482af1b4a57b3773f22e6151af17ccac94640e83641a77d497762f89b4c031e0c02ad5a5377635ba1fda06ac26ddb62a5b7add099935bd88e213378b47e924848db7f994f70302277788f4ada993494b0d8b8165a1f0068e06fd76743c4ffd52152e18205da2828f473ccdb71fee795e28cbd5ea4dba7dde72c456ca3e1b847d1efa81c9a16727837dc51708b7df84101fe6313ca84bb7355cbfea1dc40c872af223d80be0ab4b83ca3122b49be39e17d90591cc0dc210f73233ce950e1f3eab6244c2e3b4964731650e7d046e306d1f4274590bdbe018c09621cc039dea63f8e054f490b7e9aa241862c43985da58536110bad28803b6bfe450c6e0d6fc81920bef3f279eae945b0dc33fcb2471da974c0fb70de26e72b7d8ad4d8c5668379487bd5641f25f70f102ef95e489378e652c3ac6d387691217d98cb7b23e660b7dd57ae52afad17b8d2998c215687c92a677765b71a632f064030fac0f3877adc92c452a712ad169a89b5fbaf2af668a59ffa3e9c00893e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
