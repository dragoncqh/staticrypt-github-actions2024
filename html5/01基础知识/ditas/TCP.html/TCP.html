<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"238c7ea3fbb282a66931005f97a3796fac7393e4db77765044a73d1249875c1d41acfa56e34a4ac0d3ea65f93f6269eed641fe06ea2363b1edffeb3709ceb2757e5864a7f7c63959143866fbd6ae7c4e3c26f30e99232afee3aecca5cf6705add575d69f177f8a0c34db30046e953b2539bb0885a02a7d4ebd9b2a8fcad6785660f2123eed96f7375ea7e84a92b4ef0f542443324a559b35ad11342428ebe15b9700fc41c64763d473214ea13c0c7b3d9e6fafb987a73cf5253dc6bd63e83d74b257d5f4d069166745a2bcccb48837e8161497dd90660056f9dc28ce04d887f58bca47f29e1f74fcc73c2af8e4cbad97d21e0e0c7b6887bcf1aba766232710a51ea15a7c24697cdc9122772d8623374e1535442bf9d2be3c07ba9f5a5e010dd0296184408b55e7aa754dcd028e81a3612102b7f033de37467f20f4245508489d307b97347c1e11a3007453863720ab44fae2597294a0d4222b87a097833208c3e4c0e8840ecd6cde605bd4ba4bdf0fe7aa410c3959cb7f3b1117df072f6ddb8470999490e7c5b4e29b0b6185967a0f06e4145c08025abfe1d81a6847ef51df112825b4285fd23d2c2c18dd4a358993940709bf314df52cb73a695706550a3964e077c90e996b68b217d59a755f0366889c3baf30dc840c6c90df8600a576210cd99520babe6dbd8f960e3a5027b3d7e8cd01af316beddad3ac864702c6f097f4f0ca404a9c10d2c00994bc849c045d3b8348c95a2fcc06839b589025e46ab681d1e5b2651d53322e114b883c58ff463aee7999d9b6215b36ced5693443969a2c075ca880b6d200a199ea5392fe99c8fc469fcd24f27e4372eb58acc08658451276537c868bc1718046c1af2f7b91a7fa7153dca93349bcfb5c419cedcb4f4b909c59cc968213f3a8908559f8567bb28520daa448a96a8ad1aaa469ee7140db282ef0cbd80c32c02d2de8a20e7252d4251b4207c450f6a3ff897b308ed7e65b0a74a6fdd2f70d74648694fb8fbbc8970c76bafde6eec8a4b024df214b11954148d528fe67bda30c6c21161db6d79687c804b61c82fb4e9c65ee9e3cd7d8d4598ca8093d98a8cbbeb02021b80bd4c192b7243fd1b6e43d2230afd96391e54dd8b10a0a0f291ea7d69e2cc8f414626278ed36278991e5b9d45b9bf98221b696f1ada7a1be22635c66610ea9ae6efa916eb3a494318e4c16ee70e243a0f47b51abdcca3ac9dfd8c38ed23aa9b6c80765f6e7583246a3958b766adbb88bf3c0d8d1b456370856080bed8b986e4799588e78320ba1c28a3145c1a722a551bba03a69fabbd7b97258b0f2fe75fb9be2fe092c7ce8d0275564973aa9af18af5e49a7a3b21a1fdeef620b10021bbdc369785b557c2b388d0ed584d719c71bce23cca1b7df0ac2fc0caaa98c2c1714494cad7760c38ef9993eafaab71ff9c6454157ec5a40d9ab134e70befab394efd80c043a6e8c115106651c41958eb5615d145870cda642360ca115adba48230643ac292b0bc79b116d33c7b9c4c54a2f8f854e9e103dbe6a0730d1cea4e91001c2f1f12c9c19c27050c30834419c552c842b41de178dce9c3e098a8c56cf34554f2e25c1a190e1fb431f9e6dfa581573ad6a26105968a9c2c3a2eab937ab52e942bfc85fa844c51f8efb5e87a959037c723b6409bc1cbf999d795c35930b9b252e606d076cbf3c35584ddca0cdfb9635765c24bbf17ec1ea92c20c807a5d8afa3c79deab3d0dcc09cd96bc1c5c77b71c7597dceb6ea68424f8815f9030ff6a1489c745d2659eb3d514f1e9c2141d7b99cddf847036615e27d75536bd15e94c273a4dbdbeea4553ce616edc3488b9626f91bbc8f52a377dd9ab1d7a74e689ca5e5a657dceb7cd7e6cea413ee6b77c5ac6a771db119198446ad2ccdd651604d7789bebf47667b3670d763314d91224d69d660807f711024af645a2a8038269ce5457e6b73a317a6a70e7fcd02f556bdde53c661565cd76f4e6274de9dbceac7c3c6eaa5ffe4657b9b57c4042f021386dcb1909c4a696f8079cfe67cf3ba1522e1c53388ee0d9d8ffb14ea83f4fa5936ae1efda042722a8355e998b02aaf72f23072361a7f531b356162650913a990a6c125d15f6d0eeceb3685565d35e20d56df91cc87aa76d56235f5e162fa4bda86f73bc6b23910eb5f422fc2e0d4f3641008c3e86826843876bacf48fe502fdf94f597b4f0e72515220c0200b22b4d2780bd66a2641762531c62586d5861d7bd1f101fe9d218a8ef59895bf1570967d1916c59d9b80756aa71642e367efb3d106905b6099b120209b97e7960ca7710f253d51b49941c39c502568a6e2f9833defd854188a8ecb19ac8bf322826815dd9898b072620faefb0688c7ff71ece93b6c31006b951a016d6fc8efe6125dd63c148aa9856d9605b0c5729437ebc390cda12ad6bdd9852ea0233f912418382b9220bf2803698d278ab945ca5e60020bdb06978cd34d795eca869fdf193774f7175340f8f4a417a1c5b0b3bd9fb96b8c52a0c22118425a3cb9b00fc48836836bae5f9bde950eab10abf800cfd9cf838fba75f494c333fa5e3de7d1bc8f997d3c83788f4c5c30bc9fc785adecc084e5c2daa302937e07ed65f27e7a92587474f9edfe467fee9b28e9406245e483e59a52e9a111a7081daf68d7434d89e66c1426533352594182437ce354fd49d2bff374dc52a6bbad8b135d65260b05d86b8ff2e63dded839abadf63ef3ab823c701280ce667ed6af0f74170e1b9643322df2497b5709050a4a4273ad1564d18f482cd62a1761b39bb859ca88a03b5d767cef150083155868127afcc452b169f510aecb95dc491492d3524a760fd76fa9a036bc5613dcc43c24d03413f8130b20a6bee7a32f5f099f6a87c7eb5792170a9b126fbd961332b504dbb4e49b52c8862cf8d694956407e02d1ea3f4b2c436ccdf3b5eb09a269bc897301c20487c6d8264ddaf39eaffa5f5f4e87bf8013d4de784d306bf9ca2960332ea0349e7be78f9ce48f84502b03db4406a40854d32e1dbdf4ce03745a097734e038a2d7d87272820219660e518b9662d04df997894f51038b43921605017bc91a7302e3a61af9ede254e09b21a3eb3e538e31323d933e30aac4b026f0ea3ecf1ae14865a7e1b3a459ebb0822709fdf962f70ca52321995e93716401e6d0f2a77b5fba8307db483df932d370c9e732fc319d33ceddb3fcb8d0ce8e2d22553c0e495e2c2f3b98456c5c89c16760aaff719e405acf0c0298ae8b701bd4556f953e6f65dca1087962f4a8c24bf3d0cecd129dad6bb5cc3c13dd0b5dea26bcbdf5390ee2e837905bfad3e07270eaf10dc1f4de138c1d21a1395370f844b548567e875ed10bfc0d89c4cacadeb02e6a986715f6209fc364a86b4b6811249b4d6120d1d40d4d593af95246b1d7fcae796aad42185951ca1d1485602d3eb926fd104603e5f9fbfcfab78177c3f1014461fb08127a18678ab3a8d9bf3d9ded78c0d56bc399d7b42b488f4c3dc4dc6acddb2aade0fd5198dd2c32883655f09fc77e6c22879517497e8f43bd54e180e8a0f27e832f563ba42845f55b8b682b2dcf2a3d92e5dc2bac96e22e441d98a847ee3f36f2c038a17877ece24d9419256ebb69b4c5854adb2599f614848fd5fd36ae1b07c68d54132de2ca8b7db49f5c5a80454aea3a70957526ea6d465399ef0509070fd2ebf2f828a88dd1c7c355e668c59f95bb54779a7fc168b7ab5fce295db16de791f93976cbc594e6d978883cd8f3128299698cb71a9218dad37a9dda254f6b8f66e78cf02b053058e254bcc6dab3433760eabe50e8a1488be9cb28508315fae558c370070d9242c9557a2abb923691bb203f8c283095a1699395561ad66a73e41c5efd5a5dced150e043d891a0ecdfc0af9123a68f54fe5411b3d633d7513bb04c23ace69309ae4a4a42010a71172b1b06d185ca2bc59b0060e97c6666535eeec2436e7838087a0ffb2e487dbe428af99459f7fac50bf7be68a4bfdb65454763e07a154d487ef829e72505f2f36c00ccfb05e37bd75caca1126376425f6c43dbae13ea75072c5d613164b6f86c47a1588984d1c280916211dd40fc3746a217fe989bd33d414c8c4b352634bfd71666cc458103ad9d7acab226213ba06985becbdbe223cfd6259165ab21a07511a2215d10b5d592596f5d17dea52f2c0aec1fec0083b796d209fafd03bb7a269200ffe0f1975bfae446b26336f12031724c9736868cff59984de3f98b0396f48951b545883c65635314f4fef0f257c75f1ce7438c43a6714e18c5d40a541846ac46f46b62a8a8a1099b67da695a704e02f41211572f008a879e62f9586332257fb9247b082af9966c907f2aff9fd3d591623230faf935716e436e9918c46e92d3ab90cc02ae24511340b3defdea5e28e927afd6bf423c7c23a5c0721e0aec8e1d47875af0db4ec55e2f3de620157f06f93927dd829cf3824316e6006dfa84a65555f682f485619ae7499ebb0c82e0140fad3e9e9238d91c8bdb79eaa05146bc45e4438b13f056877e21a432835390b9c20c0df78e8554aeabac12b197db3d978e404c6915d54ac8094aab5543c77e69c8a9bfd0cac57b972a091f96bdcce04d7340a55906055e45656196447614918a7394f5f36604009150d06788870e7bf4d9bbd0d7aae289284452ce4a4794183656102ff04c652be9e34b9daeaafe48e928a805ecf6de1b00898c9bdc96c09be05f2a63c48b4ddbc6c3209eb83831f0396f7b23c8961a2036df5dd3246a3b5ed126f1afc41da556c0228977eace3677c0d2ba9445ddd6af251b8d385453a48139160a79298f07e78e9ad99cb76354f615fadacd7cf0c8cd81ecda14f2d05d632185152392fd748b76a9c5c50c45519d2e876ef27a6fa52e603d5c816e638b57ac73e045e3cc3cb6a9d4f9178d15866302bc5a2f11179f0354892712910b98d8ff75b2c2aafc966f30b738e996358ec57e20364c4fb5257debe6052063d9b505e44be02116b4ff3a291a31ca81c1c247d64e5e2ff3b4df84073115cec09aa60445a590bab6c82d2ad0b71b0d9593953b25018623b762992f2528d6bd9d51e763e448523027bb5f436eb78b0632669f202dd2c723978023c4c8dd1de807b21e5eaf4a81cc2deeb3ad93ad9a5886a8594ad3a2067d864c2897fc1e3664ead44ace37a75d34b8aad54cfe2b69981d20ba192683b6c08691f6ba1eb53733a6acc7c762880de2b613f8a33437a2bfe526e820bb323c20ead2143a2d5a32676234bf5d51cfd57b45867c2316a2a447d22b352eee8d28d783e8249628f1c19ac175a1487c8b6ca78f3e582d52ebb3c37bd94635096d7dd00fa9a203c926d5fd30a0537c6d764d3304282651e571ee150a7ac33c57dd4dc4e323ecca1621bb1e416ae24e38251f0340150f9b3bcd6220f0803913f51eb541bacfee0c9a3c2117573837a19ed8521049d59a651f9ad95369651926297a21f1ad6b667bc621086c13fb26091e6bbd057addcb613ba277b6929884e65502c04c1955b0a44ae4273c716a22ce14114561a7a49bbbfcbf14d98bb81e616039fd535b1f1c027383ce7a80690bbeb6f55c6bcf6ebb171ad49c24e5b6e91e074028d09e57621fd791cea602f3d3af4e85150be4477d2cff97dcbc09bb17a4052cedceb4c748c12f3ef58607f374da1306d56018ce084f6295bc7ee977c142577515259c8d9247ce486b1cc6cac5d3f4fb348d2f47b7ba74627132801466a9ab10d42b0ef591f57ab1432e75520a3ff8217fa6e68e187cf07ea33906d6c9d4a42ee6c82ecce2b914ca64e9bfe5bac9e0e79a18614d4965ffdaece4b76a146182b1da33b38c8529548964683b340a1232cd2e2918f8dad9b8a5d2d3d2bf2f2b47c653b0d4b428dcc21bfea8cb8f004c1fa47acf282cfdc9c903b2dc26b8b59a3efc4eec0db9e32dcfbae83b494f54f7c57af288cde4c32c85e17ddc1046701c0f858c078731d108185858780db9c8360e0d909fdc91ac2cd865ba85ad78d7b54f2f5cfbca1d23ff566fbe0b994d241a0c9c6c63a2905a06417b105c2ed963256d38a274c2dd2530dba23af2548efd12d2c2fdc0a8f4706b23508854204de704c84c3c000e0e4eab9f4c86daf2c93c8b674ea15c4322b1f15bb9408e76ad10b924eca5d1621412de1a1efd8997d8ea59d87b0267a462273e5ae5ec00dc4f7fdfa793949f7f30ecd61276e561f1ae77c8e15f3dfa308080542c40ae1232f830abc06bf79c10f1ec96d9ab4e71cd1206ccbb6c30eff2a2621b90fd321c2ba1b3fd91ebf677f4613e34fd1d82fddfb06140dd2b3525f8ad73da628bf702ead8cfceced48e4e76c6fd476ae1d3ace3730ce21f0460b3899e3c1c2972261518a67a1428e9c0bf383972e34748a78074f6cfff2874569c6b26119040cc153dbde8ea8b7b319e22c987bdb6fe0652f46a156f522e9fc32571d5c3088ddb269ccba8b17d1911927dd3031a1a39acd047e51846a08f03ac40cf01025d82e4dea2d7cf2fe4f4a3019bc0cc8e4a1da0862536de816b0b66b327db7ab5d81da877061794e363bc32619196d077cd8f6b25fd00f723cc6ef50096845af0dc4720dabe646721cfb67788d9e6740676af95cc8fae1d349e33178dfe05e93f17066d1aa5ae381f3c4931cc920de39198b0806ed1157077ba7a3a1cca9e80fdaa3bbf67f78099759af4639c4ede4a16dd8724cad88b620454e61aa1679767406a2d89521105bdd9f2f152fcb1115e2bff76c9fc513bcf22c7d344ab8c13e233445128e2608cec2e21b3081fc0aa7160d6f935d92680f53396a23113cae0be530683808eadc2aedb2eefe2bcf1827edd790f0917f7537159d4d4c11cbfab3ccafca02d4f88996e73bdaafaee1b23723d3b35bc82efd449d248c8f5a38c39b0cd8a013ccfdbb29da2c629f0be4ff473114a5c35c4d93b0863adfb0abf0a7a4aec70876237f1ac0918fd3b5b33476cdd7a7a2439a57e9ce8b3d827845d01503e83f4c5fbdd6ecb446b6d647c6a54cd75a0dc9d354d2e1f9b5560841fe37749b17cce530483921758da2ef0e61ec11730bebfd872f83502d64846cf5aac0c702c4265dd68f63ab830630e52fb6358734d8365fc11541fe678f430055a9c8c79beb3a086e74915a2395aaab9f9311b9ae3ca09fc19abae87ab6a2259c0fd02489ad4faef7e738b284bac03b5adbc6877cd601ea0d17f2f41b76f8d3637c4c43dfd7171e9f84a43613e80f8fb99462f841a549a8b71b51df532c23f84237418fb8cb1a0bc36bf9377469aa0d27a0d2f237d633a22f476a38d5bedbb04818fe7d372f00a195499a29afab908a83f4577aace00526d228a1a432fed7236c74a35439722bf4cdc0f92ff861850f0ce43b01faee5154509485868a3d86e6336d069d3bee98a34ec29b547841c1ad2da88aab0fe647d638fee80129472e4208a507027e4eaf99ec898afb9f0a00c022b01f6085819314c836e6f87bbb5ab0396f0e72e7f6d816dda7987280a016886eaa2a40aec25533f71b2f90e4abf6e4fc7ac4eaae31d84412e5fd0f2e74251a7d97ce953fb2b0d9ca96baee1bf716d05651af34cd24651ae19b173deec11f7940b3c4f16d3b682b7a7f16b3db4ea5f5677d292c1562c4078888878cdc67488f2b0040a4abdc5c5653e1b719bc2bd1dca20a57854dfb4b92b11d862e6de2ac365258e52f8d5d9905efed0a8a3bed9e89534a5e9222ffbd454d2c37e00ad6574312cbc0274756b84338849bf559b5a90d2d2274e32feb28d553fa9f860b5347f938096cd0a56e5627231546461b9b302db5c1de8f090542888f2669495f105074622daac6fed857a061c646a6ef0cb909d19e0c5973a0cad8b96ef6df59b4a4ce06aafcf1accbde965f92339ff0a58555791da46eb79612b3fa5fd32b4b79f99ac021bc302e66d842e052f10bdbe2b141cc45c9cfa8bc63ac943305423e502562ea9f02e58010413858487221162288d67f5fc824c6aefb497a4493621fcb0513114f119529cad06eb5cc0dc268e4ed3e4612f83f84aa6f110376946812902b05c0cf026deb0c0190923a428d8aff3db9821e91aaba8382a58efd1e443f7a3df9b0e1b5b0eb7f340f24660fe069a2d242a46ea599d9db8543809878c21cf6d1b8bb2e9f11ee5582f9a6c864ca5d291a0448ccc46ad21b5521a30b1e9b6300077fc9ad4b564285ac6460f3be93b22f20313d2d4a48b48fa27feee5a5501dbe2808d5c9d1ded05daa20d6ff089d6ac3263f16463678f6853910035d7b13b18f22cb7664e6feb760416132a30b6fde18514fcff7251d999d95f46bab0cabd475d955c0769b94b5d98b8092db98619f48c71b14967d4020f25c415d6d1f764ee2edbc878997af5c692d1d35d4965ecd365fe1a3a3b21b1d6ffc9ebf3d1bf32f77e46813ba7c0765f400c45029d8803ff6cf985fbb4370e8430d440edb95bdc5b35ddd44d7e87010dc9a7db6e3f6a7f537b2a1d6bb099b13a8b720174a678d01404821749b00a431b3af2ff03858b8b6035f0f4860cfdfc922c25de64e4327253938b358520871144cc5c5acf5193b82766cb687e0894f12da6d76e967b5caf409a5d8886064416dccf3731196fbefffc992366d981eadf5f32aacd2a4fcfe319f011384f65482842ef25699fa45e17ff3c7a5ab671195caf351cdfecb830265dc53f3d9b53e281ab0d20a45e7d49e777aa34d55e8e7f25a09ca85aa300ff8847dceb8464c97c5ee8c6135f7b04eb0b3b39573b52edf6dfe87a7d06e7762db7aec78e746e947ae3f9b337753e96a04669af84e37366ae8577f947c0de1466880497e0d387f24d008df0811190011ce17937599809abf94cfda581a7f7aa5055f754120fdc45d3be4c1795b50e36e52e604e57022cccb03c5581da5ba9e0c20d02f2e2862620c14706b3fbf18c5690821bc8f23c069fd6c1f4072fb4602d2a2af94f22d36dfd3595f4b98d4b25828390c0eac3c1dc22f86f109a49fe41b25da1e13e39855c428ed6b10cb9eaa0df24771e453a5531f42ac23a1319bbf0cdd629744a916d368877638ac399d3a382fcf4353eef3d7f1e337ff48501d6083da703010ff4c3adf3ec2428a8f0477df408d6dc5fc17a54e745bb60088265351e52b4f9a194523da4497b71240ed896838e80f6c5b316ac8e402c8cf974e5593d712033312807a8351ce323007167372d513fa58c5c3eacd43e4075e0e7ef7a5d5c8b098a47f32f650d8c499168971b16a8d8fcbfcf2eb3f34583d2cda6acf6aeb285e5af661331e99acaaa0e6c77bf579bd57e438d700a3babfdd2610ada3927d9d09cb2d514fc3e601c52c6421af3ad16e6708b98f2014e9365d94f5889bb2457b2e8f639c02d44018a070c88a061872892e65cefa1c5574169bb3ac0673b692f80778acdf820b56a61b65dc22da5251fe75d67abd2f7c87deeadf86ce5d699a07f1092da40a3b633cc5841389a9ccf0b8c55d09c4c09a7dd935e0002ad5a37504154d211a5c8a7f11a82ea150b4584d6b1a5817a876e323eab3b5f7c29b743664c55ff860dd956c38503dbcc7d7af02a912a5c128673c6f8c3d8d646402da6a4ad5dd18e9ad4f1e3fac3a078dd914cc490006d4db520b174124dbac04ad7330537e8f2dd305dc1742743ad49a6b1c8e0ee53f627f09afc071526a2de90200259709910c78ef0aca826ebe95de616164fba82c42bcad3dd3e6b0793341e30d8dd7217f14d23af496dbdc91a3926264d724230ecf6da5f67206f528a079668123ab917062fa3c4c13b05ab11914a5a015d01b56f50c8a7565077c4098a9b4c102e51c973a98b25558820120c97f2eabcef17ae942dc371b9875fc0f0b6940a3e8b6375f02a8f79a46913ab6a933a3e99c16e7abdeb4119693f395779bedba9a0a4c1187239ee900e55800e7e5020f4b412443461779ce6202ac80da0e35e53dbb61c6d0d1d956a81f33be90ab0a18ad03eeaeb433035196413fb0aebaf582857f50bb1fb8da6a9ab9b128d3fbef72802a28c9183e6c8b06739d53f1988c32c5b9d2ad1c33e7f4280329677a250d811b0bc9d15a2b0a377eac321eae5086200a2fded72efb80a13e4d1063031e43661603e0ce5353496594e0bad222d11960bf69d1ea8ba4c7ddff36c6a0d4f6a4125b028227f921c375c7866c3addd2e294fc57e0832ed9ce736724bb73e15b961ce3237018536a6f4dc704fe684d4fd9054459003289f33ea2380480560da9d1ae6d461e8017e23f90008ddcf481619f150cd6c725f1afa187e8a66215d4da5d528a33aa63b1a3d45df7cff4712ae6efd4c370c9f50f96425576ecc4ac98d8c05c803cfd4cec5aaa865f18b28468a71722d5561fc47508bbfe503aed265ba1e1e84e00973f7ab34e34b0e1f896466310128aa72c6057ef1bceb63e16593eaed4f35a957cab72b2df94c7fadf00b5d6259a131d1d503407e36646c9315b817275d04a9f3bcf4dfc050f20eb34670fedacfc440f27b44b46cdac8203b94a2bc6481b9301da491f76759290646244b480fc006fc90ac29cd59c5acfc7ec755b0928b0589af9cd6e39d9c8fee6363acd98056f56ec33689cbae0ff0120d492cf6318436dc651f894a4012f8d7920b70b253d2635bfad4bd4266ee711d2958c291a2091b8a450234587ae03a578c40fda12d02e4f90a225cd15f088ffbe5c4636c267803e5dc38d70bacbe42c5d91f65282472cff22f956f600e2dfe34cf9183eeb565ac0bb5df1bcba40348acfd949d0bc1f005eaf17eb3acbac2f1ed21c2828f5870b914920f3b0609d8cd6e44db1630d28dacf4215e86b8a9ef49618c7595653bbe611a7a837844f312c1ec665f0b62aa252fa8ae0764a2687166ee3b91aae5db4e1b2fa7bfdbeb2920c8fc5c875f3740b2b0ecd4fc391ce92e3db0aa0819ae5bd0ff2c32b964678372395d3a2ae4270c2e13e5e715fbae94faddd7699b405c4e2d13d67c7fccf50bc657ad0e4559f2511f53c7be832a27262040d84f415d81718795b2325859cc32b2e0ef188b38c36a5774fd57d9d0d1b32df0c9a0b590319ff8d2b434383687026a8c289e7a82c6276a71c8ccb5d747f9c5c85afc8f133cf1bba7e657dc72b580525edf12eecf4a112c24a3a95df848956dfaa743cdafc71095ea4b070ecb77cc961acde06f757b1798840cbfb43f0f1907386407b3765ff78f59e21a86817828549fdf11b5699d2a72602a005360d5962df5b1a8259a150e779eda58c22ff07d71ac4a366b53b49442745cb324debe06407afb6337670c81fef48fb3a04e89c201816f0462f6e8e26e91235b00dc872cb9727b5dee075923c418875d44d66e1105c42061ef105d163399aadf1278fd623c8fd88f0e89c728d3ca2e428d0d7cf989960bb3cc3d71b0a34259ee12e1424eb981de90ded34bd3ebcd55363813e64e769cafc2753898097e964fe984f22c9c526c0b2b9a828ff322529cecf251b57a6b20276e87e588a0a74d3dd14baa0511390c71e3cd3342cdbba2d676767cb5ec9b8fca3af8abdbffd6347091cf34d01ded27fdb95511e8bf33b45d3b7f035655d06a77b804feaa714589bd4fc9da36416a76f1bba1d64ed5e00548bf2871d7ebbb82e461d778a342e701f9c86bec51907b406bdf54a91016dbc6c48b9f864196b6e5a0de946b3d9963002805e902864d241f523c8f8b979558af8f543d4fc349ff7e2a02e67859e29414c6093a5550c80b44718c2f92ddcbab637f96eed00c494c085ca94ef3418ad279c5e7a21526f638ba2700ec8967ee5fe93c84efce124d17c5ca99db8be8c56122371050b2d09d35100cbf855d6652eb8fb329e925c7335cbb925aca659244cf1bea8a2cf05079dbc989a827de413cce58acf1f00752717a8550c27c6615ba83cefaa1712c466ccf2821e6af33540341f7163972503bed0b0ac5ccc4a8b26f5b1c0c478c738b8224d42c8c9a1ec6351df363e75ecf5fd81489976c6187ee27a7698a3b8e9ec6dfdb97cc65e17199c52ac1267e84c489d02e886c056e70654c75192230de69e4e833ab53e7605faaa76b6eec8404ec3516defcce0297bad09767edf7c6be652c5cb7835f08827769f851a21a115a3e8b6f3ff3a6f1a763865008d7daf06bda1f34bc0705b4d7add89abfd003a4024872c438ddfb86fe78fe27d9602546799bfcb207b3467b53158a7d82a5f56def8b548064c0105af3aa73dbd760cd20107514a1f261b7eda4abfaa36b28ba7fa439108dbb7c7867044e4abad34c7fcda8724dd3ac1052e8b69024b896aa98e652b181df1919e4ae5656519a7bb6c92d189ec7b9a7f30d58725072107b1af50c6fbb5769aa33418e42457a78c875d817cc2fce2763cc10558463001164157dbb07175f2c72d880ff8830160112c06c18f5e42d6834877410cc82c727f62ac58f350a3db349e5939a153bb4a7fff444c8ab9bc43daa9a3dba9da6ec58254c84f648064aa895bae109041583a2cdd456275e0330167c55d102faf667a9e7801c94a58888f5b50cb5f6f437ba552c52cc14e21cbef38170e5519ceb4a91068e658f7de3f43604bb42c5a4756e87a01b336abadca5b27e67ec0097aee707210cd324bb469a83891fce136fa90185b5a463810f5a00742a8fe41e0ee9eb937c2f2caf4ae6c922b7ff9f581d1c2f270c1612952653b8453881ab818504f16851a0627c7e77d51e1b4005bea8e918182a42b1c4ca87607becd47f192cd14990fd05e75a5b80516aff621b29227f617d8dac5bb565a24e89cafdf70f4dcf3dc5a1f0d09cdd4201a520b246b95f29a2fff241eff9b6d797abbc4371258557594942ebca0a631bbc851473e090f733585edd3fe4e0983ba0b8b408d647669711ef8827ed8b87a4fc61b4aab2c95dce9923f2d5317ca5bd6b6fcdb311bd8884a0aa8393c58a1f63f11bf3ee8995d81fcc4e310ba2dadca45ea7c44392401f98dc231175ebca51c72d8401fa2e7429fd001d29882d5b7330f415b067f08cd63e297cc0a48e7780332eb487912c0e32d67173e5158f57e19bb5deb1dc512730d91d92e79d1dc59753e7f09dee2d5aedea9cfe50611319068d7ba0db3def66028b1755369872c079f930d5ae9b0cb144675c0dd40db74a8c89a45023088a44881f5362fd5d6ed7ab93025c97f9ac5136f580ab0532a6f7f13a1143e23972c70172baf24437f1efc45a8021ffbdee06a00bce22839c34f8851df8f718242cc6489706ae1a286221c532596cb8d470dd8793a0e3fbfc9294f94e242d1e3cea8fb745350c3fcddd092e6324d2e1d10ae641b418984d3db684c1dd4cdbe2e7755e6860dfd03949d272497713473df28b513205e8a1d97c4757504338e324517c9158fe62ecac4d392cc26d6f4669d962d1659cd7c62fdebab2fb1590b57ab96f41f829104a1756e72fa52ee327cca3de1c4b765939163c78a384cd10fc818ee3e92f995291b56d5129ee2755083290a90938f2fe203a833c61ae54f35774e7706087f239c1642adee6626e6559e6cd10c83dcbb1541a6b3901d5c6c63a17adb0b87a3fe66fcaa7f741431b1b3008711f5894f72cf039f4b5aef2abbe0961d37213d4420d93ea8f43977940fff2bc919dc9bfa9f2f803fdfdb6642abccff9b13e9eb24704a3e704bde0b31aa52ec86ccec64755ac2aa0a2d2d30d8c73234e6b48132b8002e23555372b165f01b7e0ee3e6fc1fceba015bb4b6e42c1b0c36e580c4000ec54b170864c8756fee388ace36f29854f059d568a4dcced0045ce15502f71dba368c775b380246327dc437ead9fd5a1dde5fc657d77c134f74625754b06347bdc4e0b64b22a99d50ef685439454116196cb01bb19f8fe2fac86df40c267a17ed2965cbb914e8b8294eed5df2282bdfc53833ffe2015ae664ffbd05c15359bbfc888121b973f84066a738173516b054d70c8caae9db032701b11dd456f778bc4f6d96b7eb5036708e6afdd2ac9377837d7b0e6c7fc6c1f5f80220702d313d5054e945eb43e5ae628890cbb78cb3d8a24654cf7b428c31ebf495e19ca7e63bc9cd2b267ede87ee1544c03a5a8f53d326397fc93bcee241227c7241a24b9f6a4b770751ed585d8321fa6132209a9085138ed8b3d5d778cbba05b787b3624ecada383e8b005d885e952ffc8d5a55e98851b6499659cd03c469cf20bbb7d3cdb024596d14e97bc07198fc6e5fa32e7d03f8f3bee7ad7bd97c7da3b3a31ca84e5d01277c17f18b1b0aad9d11c2ed667ff58c834be549c5970da27c5e9d2899bb8ddce7bf5162dbbad1c857970d358b626d7653487d6fa48d9d6d2943d3f2fa1374afb12a16c0ed3a237a30db3afc2585bface4107ca6a4174c83c868da85352061599c0a775589db1262c16d2470433fd6fbcb80b9ff9a2208c53626cb5f318ead473a805510a4499aa47211e6dd42897127f0cfa0c29a609e853a6a3d8d1a9bf4ea88f4c55753f2a5aea80ab4da6606e779a8bc50e8f1d2534babd433a7eb0f545f65dc357054c7679f5dd00641fab0f4f5fb61314238933dc0bc2a2a89559660a0015143d4c3f525cbd37841c6424bcf8fd02124ec3353cb0b1892c919bc837a5f436c64c025f3f4450a5bfdd41198c47172ef7797f394fcd8f2cad7b145e6ec294b1bcaa3aeaea2fd021e661b706eda48bbbf5e63e2c3130b42e318f6b524e93343d4aa2b63b020a1741b320e1f97ad90b8667590297f0a439408f36c74543daa4a92f484d1adf8d3b7cc8f186aeb3a0984624627b00149c0ad5037850d835759cb6ad8f1f4771ba9bb3e09b944d74176bcfc3422fc573b9d3ea5fa2662291bdb9729f00ae28bce14fcdcd2bdb33b1b215e564defbd3ced8f12b3072d6e563890f4b20812b3d594ad197d860afe1351356f20ce1c0796ba8bba53f442f741c56b7ff71d6fc12b3c1e9c3ceae51fbf7542db73aa1f99ba13c59f84b2979c67a890ffd7b50ecfdfe76e43bcadc854badad3f66514f733da5e3ac50ea2bdc0acab9be63a2670d9505d6f0fef614cbb997b3d7624dd7137567a97def62ca0842b04e0fbbf19485f0dc4f82641ed140d96dd61a0bbd1de856e12","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
