<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0003accdf0e99df5dd264da67222fc9a60d44e0174f6fea4cb06bd58c432bad3ae4f1fcff961756812dc4df5f6b0f8369b6485424fd11777cc38293e4c643367289edeb72d2963a5d0560c589b6b62a1f8aeeafdc93f7f434e34627a66904a3dd6dab5974e38853f4e30746875d75e6adc098befb6ef5439ec58bad4e3274c0ed73ae724c0632e8df63929e42a445f4ace4803d84c4a590392332c9f23b5e144afb7287585528d4edeae780d2957287acc3351a42805677ed8d37cd616898df703575ea021e93e8eb01a0b95932d95ac76e64500b73a61be5ee96b1c03adcb9e4a6bd7d918cb1f1a9e916b7b9ba569876035044abf4e0ed5220aecb69b24b9330a725b0842f77351d9f6b47125a3f8971427284ae5e7f2f0616629c9b050a1103d775dcc30ca20874745bee41af27eccee83982bc36778e25b13904cc783c899f7dafab588463a3e9f47557dc9fcf58a50c04874a1e6ae9112067688d3d696376757923950c1489c566193f9a7806a223239eb93df6abc8793ccd7c7e494439bea970acf975ba5e6d5c2dcacaddfb00669e47bf42427d6fab4014d48d2a6d0a8f3f52915ab7a09c4ddb2ae70fa1fdf2a77b88e2edb93cb7314a3d9a699baeb1c5998e0d90ce44fff5b7c7a02a1c213478e78843ad642c5e80f835e3b351e190af4ec48097c03232e7317d89b21ce831e755c5fd0ebb91393eba56773117e971eb062fd96e8b0033985d7582d1685a91493a9a0eee07017f8f282c47f98247c0bbd335406c4ddad8988701b18841b5a580238fa96fdf68101614e783889fe1d3a4d9e69f98bdfd368e8666c2c8876320f0ea08cd306f0f422712f9a88ba6d9c8f3748e4aa56cbb053919e9ccc8553789eeecd54135388ebed2a02fb241a7eb3de8b2401b21820357079c4ced7abc574bed2c2f1d540eab91a3f301521183e276e0e3639ba2d1018a998f4e3e867c2827ef8a7881a92e444bcc5d7afa6fdd2142864433448c14c1c1a62b28f1d2c0ecadaa0e7c7fec161309eec8637ba339b1a47bbb46fc3db9eed42e1f85160d79709a47ac5854dc9afa1e10885cf3fa133841625fbd511f76bf4b4efa5bac45f463a5f56372de694a0df83a7502438d8f6a7e440bf715ce2c144ba65d57b0a1651f1f4ccb31dd25147d4e37f40543831ce652be6da96c7faf3ff4c530959c4716aad264c587465eec693443bf1f8eef4f5fb1ee5d61a566f59f5af10d35c4ab081420570ffb9440dc27359fa8347412abaaaa9cc777f862b9018d0cb8c167e329327db65169cb59c5b1ef72d8ad7d37ed8fe0bfb4b49f4872757a393bd4c051ec0c8cc74228268fe73c055fe1b9dc25c07c0c7153afac4735c9c6b65893f4d431970d955ece651844bee38642f09971fba80d0fb69d409a76ac94a39f15a990303e54b7395df24b139b589e9cca2c7126e030ae8a8b2ef4172118e98a79fe5a2db028418786862f0c51d2765e31559b82c74857c0c4d1c5af0806cd7323b05a645cfe568dc0a191a1ed057e47356bfc016f9dae60b6266666b4f91b92858c2bb5f42e617a06b5b10b623cca478097f7b5e3d313e305f02ac9d60d8f8b356b18bdd006a0e8c295b5a223dbd622be48ef3d7f5eb3f9840e51e1fa0a2d594cba8c03b6ce49392099540ea8cbe0e5685f5058031555c9c59513173238e2537cbfee319161e2e57cd18ea24018d81696dfa579604ce38f845d982f040753da647c3fba7b79ca09228ed6a06a6725c68f9b324d192253d3a053aebb8fb81fe3b22f259b29b18a65152393083af4aadc40d3fe24198bdae4c3640c8fa03ff3e07a7eae85c0de26a18e6c8e6b248472e16c9d54e8e5ef55dc2e12c588a9650aa569e05257d236b39b0002d6f5a7064811477559839aad0fc5a1edced9bdee91b1332dc967e8f783a3de118bace0e34f84a7ca5b988c30474b0d1714dab5be954e8fd6682a393cd9cb94cdc8e71f3b29ea5452f7985177064015df9276a4e0da728a23f43870e5f8c171e15c146ab420ef5add2f2a10c21d674f8ab541558022f04ce7017283a492cecc223997129c94586a162a3127ae677fbb410251e84a4bfba39e0dee231a6159d78f7ee649215b4ddd30f1e59e187d0e794c6827aabda0a4d975848ff8fb8a9ccfb31039eb6b16e473f4e9d46fd215f91fd19db1a6cb067eaa435cf2a1d8967248c9d6b2d847ab69aeb7e653bb282fe081c87af2eb159b38957004109db1c15c1e738a9b448bc7c0cf0b8540cd99810a3b7ec1db9fe09e69a786f1959303c02a2b3abe668bc14132ba0fec278b89afa4d4173495b9bbd953e2dd241c05749191ab4c5070e60911051594020e4b4ab02ad776a1ed5b204bfb69177b4e0762913eff895999eb9296e760ef397f18315919e3cdcdb7061bae98a5f4b2e9f2fb8a5d4de9a6d45eef60be4c5f64e611e4b3d73728d551668d6162fe215b7a8a8903ad8a4522d2203b680f457fdd9c34868c3f71aa03832c6a3c8459d3203d4cb4df15acdc54c76c792c9186ece91c827854ca57a53ba6f609f6401aea281da5004a12b9be7e48d45d836aa31323743d4841cf2581df2576699380ecaa66b71866f04099f3a3915c4e050aac8faa1747741b09a5fcd359ef0569a60f52964a48c0bc3708a9c878ad5cd4d68256beecb7e5dcc3851e0907d5219499889b0f0280069391ae25df13e09f254d80f66ba68f2b7119af75e31c61cbfce3d38c9b05771251cfa2e8c893e5a4f53f5cf3caf7c38b118c7749a66b8a0656c42839d5cb33399bbcd85870b2846e8f481b05f5806e84afbc6851b82d5f3230a9ff7aa0c317d28c1bff7e2f778abfdea0567cf91e52127185b29f4ec619dc38573f24e10d2debe8b4b12b2b7cb6f9dd82057d45d8f1286a81b0d086f939f4e7b2c2236f75aa4f00259c6c1013d44edbe284562b60be52320f00d1e2ef355dae30558059ef43fb6eb3c5953bc0c9e1829b3ba132534a79038e61e137c1583f789b85d310c27adfd83eecc4f07a6e44ad2e9f57bc6c6023e4f05941245ad27345c0d327c54695a182739fce15fc001878923b485fa2fce6e3088030808ab6fc6b8b2fd4242f845a411c36155f998c57388f42674a1f1e970e53db422aa17ad44506e3b92b5d74271b9232cde900ff95bd7e4b297704aad0124cc59ab4f23bff12bedf0fd872917ef0325b0d247ea02d52e110aa9b24e78feb7e62e0402d9e5e472fb1c784d3d6e062b0d9b0eb5fc80d520dcf56cc8b0415ba0a8f85364458c66360af4eb0f3fead986947e97775b294b0f4d4e1175ad632769f84bd1cf6de1abbe0528d558acc9315aeb31e396e81cb532650d15828c3dab26fdc22809c452dd3f69301f4577b5c7d6ab3495ca8b116f97961b5e7d5d80ae0fe9723b6d9dc08cb37b79c89cdb140127a160ed630f6423b1834b68252b668af6abbffdd57c00d573bfa759c02600b20dc1f14838f521792e55f747a7cd90513cb4ef0b4fdd55231403d30517cc78d4429b72abd3e18e3f02c7ef9eca7fd32a1574557a5e896c9eefd786f4f62d097ee2139af8ac8654e6e6ecf424d6b602fba5e271db079fa7fa6aa16d3c4c942c1bad6a990feeca779b9e926607b65f2d37508d935027361f2274ee9f8a1889caf2f190d50df6e9779e4ad05ebd89861c1759124490b5fc7a95508f134b9a231c87825ca8cbeeaecb6a52b480417e78ec60dcb2e4c3aa9b522cccf9782ec23fc53510e8ccda11e9c9c5de929c26f6c902600abf4d20eea18fc23575f624595d81d88fdf5053672100310a0365c823e825c08db80d974a429f6bf60c4cfd893d48ee557f2c9680704021813e28172ac94cdb8bf0108ba7af8c54407eb29ac1cf9f3b3cf8054ffe536b779c88bb9ef4395b80a3a6dbf8b59ff58c2140959339565e5198d21ee241b0f622f88e10d0eb44f1c07cd5b5944bf187d607e930e76402ebf6316cd9c3e8b321065d1c5cb1f4a9ea499be28a7a9d65a409c60d4ccb4072a30c6bd2e0542892d937f5045ea0cbf861bf46a27f5db49ca2232ccdc337896069e9968da1fcc23f3bdc9f238c29d3caebe60111f9972302275d7a9f3e57e49c1ca196f97d1506dd1c3189818ac489183089dcef9aadb67a561ca26ac2aecbf3d888301af66742e837152997fe1ebcb48a9fe4bfa870e39dfa3bd9527d35302e3f37e53bff0db8c2c88446f44595ec2d3a53f907550dd5b77251e9aa64433cdcad8a746f0579b292726d8682eb792c95115aad250e7c00f698e5cf4d9ca212551ee3b7de056d9ce4571381c660916c4f2d9250cc8244114f2a99598661c14bbd9197d2bb0ee976d619a070e78bb2fbea2dbd2441cbebe43ce7e885db17fc1a27087a63ea2f33baf11a63b87c41bb54860352cdf41527e619b758a1edc9ba384c60dc93b28979e64d3b65f5e78d9b00448d951f3a67c3300fb7c265dd74ee04bb4cb47bf185a777dce83dfeb285ed212c2bfa755385c69a9f0b03f49556eecb9779cbb99250510564f3d73e29fc5da3b408471a480bfc4d498b6c49f01b3afc0aa12a676f89970995924dcf107526c6ed6242ef8be1c54d03c6011814722186c157a90682ac6588d697c098a69cbf00a084d9d1614eb52417a3300f4a76a9150a3418443bea38b314e729b67dcb4fd3f6e9c6af7bd0ff226999c244c8b30566ee277cd802a604a5b1732c13d9e2ac21ff2f4dc195600df3e1ce85f5386212e3f18cd16fd8b10b3dee19c9c8e761302e5b7155c1fab55d84776f59e2a5eb538923af64b8362ae7fd02f0d5c4b4474d202b642cb9da25791759657809ddc1105271d08f7ea44562516c2391d76592e78f017cad6c757e40cbf50b4e5a502442ed3ea91f831b6e0c1a8ca9689c754f5b71c40119ca06f6da863089c7c7e13c9bccfed4755a772b7cca6a98ab53e819231af709c048741d819d5c063dc5ff4dbb45532c3361ea222016d402803d5b46a168d4ac16ec4018edf7c880ccc6f2e4c028267ddb4e09fdc91e73cf5fa17d5a838ee4c79ecc8c1d08172eb0a02995478a09e66794a2923c248b7604c7a5d0abf3e0d66f7c6a974e9badefb928fe3878ccac1f179c3ffea3f5e8a8750c55bde1ffc2d23b3ec58b081860d09d8a9a2bb24d3e5604c5970e3cd0cc39811894d01ef06a80f72e2958d40226db91103fdd244405c9d380a7856e1d40f9226b4714c08773f118647e2d61bb66a74ad69ec1d02ee72c8e202509e0cc70e3037fed4ba412d4e3cb75e8f9b030c40ced53b8536c6b64cdf7efd2b72b59e017704969cd49e2677d61683e80ea15e995b8ae56a1cdddf117cba0572c3e14abe7443ea711f118485d88d81b194516a2185e6419da21137998e4acc2f0a7d8388417fd413aa25c9fe2e4f8e05fe0dbefa06a325e47fa4ce723d5737391065d1c87b0dc4d670f81387672b73d613436610a83772f5bcab8558aa90327b096e914fa87443eae83c9511487d3a491faf530a2bcded62c48d04e150acb77ad87b1bdb168fa632e4e4e056e8ec45e5a0b2db41c74b01c3ec7f1083765dfdd2b37a452f0d52a6b867d84da8d7dcdd765364d49cb407bb8e66e50ae0bac47bafa0bba96fb64470525c8f75ef05d9312d05d004f3392ed617299c44caa684a0ff2324dd558594413907d848418d98a70a2ae88b9d3b6f3db23bec58dbe93000f34ebe338953fea4e7885f615e3b5526d44d7f56f1cdeb584ddeaeae19b518d2f7b596a89a9af811e896c0d9449ebeaf278c3a70419ca9bd6dc7ab500b4b21082682dee3f4dc4c18b10e650da1c3ee52c88f970c9472afc0420b0d06f490847dfa5364d660c2bbcc903c651a87cf3956d7e42ef186c9b7bcc0c19c1948e89a4096a400cf8f1a5fed6094b2962b194809a1f27a9cc656246bb8c518e84ba96558f09fbab8c006f72fc6db3da41d48e9c6a989303725a5c97c778c7d593710f538ec4ed1f5a03aab582765fac0ea6c6892b9c5b32aeead4a83f49fd7899935a8f0fa44633465e17113de0f18914ded9445033cce59ab0f95032b7e401a44f3a68d7749dfedf63d3155400b61f2a5e9382c57d4efa5a1f81bfba19b392a5520ef3c72e8efd068fec151d10dda53308dfb1c23350945351d3652d7551fe49872d01896b1c54ed693189a020e2b311dddb7a1db9a0344b845dacdf076d69247871496c48d8d0b5f77b991830df19cc99cab15c621b8ccc3e2ba8c1b231e2cb387e6e58f72a2a76a5bac1c126dc9d8f5d46f854998072e7e0f6ba8f25ff9ab95cf818cacb03b0435a42ea9074a57c7286ea2b6188658844763c34dfc55505af490fb1a7b912170a4ee530bd6415dfcfa852026ee8b3f8a5418e8023594284a1df25195337f722c1de62c13cf4dd96f64af563ea18ec303176589c1ad13f7d944b17776a218b142652e40b61ff932b1bf5702fc7f0502cbb2d3f9d46c7c3be4bc35a33392ddd9dd9c4f3ef5beca3216de6044e8a46d801e597cc8be23d1283237e047bf743b82038f4221892106ff43128764c418a46973e53153b19c196519583d3df8bcd17b990df7eb33a8077655df2d03418bb18d63fb818a04256c723e16afd39694f3da898f30e6659344181293e7221d87ce93ebc5a887da332154b7a531a5963b129f55657f5ef8fa2bf75aaed2d59d6ff58affe3387b5a0501ce6139a6929db605953105b784a0a0eb8fba1f90d9257c73c4fe5d52e5050a71b275e2163bb9ec97c0c1fd38068f37fbe0407c88063e98ba29490ffe101fcfca5fe4ff12df198024820b116d6aed01af0219cb54037ac77a162662649b5cfe85f2827f1f4e74bf64873a7b17bef2081c8af68cf159cc015dc832704419070d5bb29a880c8692596534b80858705e3639fa6f84bc2b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
