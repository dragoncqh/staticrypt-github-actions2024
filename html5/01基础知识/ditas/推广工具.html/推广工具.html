<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11629a32baaf51ab9c2e5e4968844030d6fb0fb0cd443cf518d891b32c62fd7d5f3476f6a105bee12fcba236742b7a48e2f7ebe44381744820ae2de0ae53a4993ed62c636a807fc7184661bf4a6a83189d725d86d7443a20864fabc42e2c6c2bd9267718f9f065d78e2964e724228e9f4d09e538b38131184b7afb2e44f8bfafad57d925a1b34f6bded85f211c82446215dfbe32f31ad7c92c9a08b71e5144120b866fcdd745d8bdaacfedc09465b6f8c4f3d67a3dc2e981168e64e204eea59eb210193867e5983ba7f8ce868101f86036b543e2d8d4d4838e9d4f12e1b7f902e1221203db66994dafcdf3ae16d5167aac03aa3afdc1c8f382b9bf09dbbe21842bf3114b85a27533eca9cb13ebc26dd2ac98aba85a5dd21e4db0bb4797af9c7ffe6a43ee382a6f722d941d1d826b69ff4c7d76b63b8600f0598283c6f935f4c76a7a8bfcb8635faae445b134fc4996a2bf8dc9e5e30ef19a5356b5c3d30cbfb1f453acc35e5911b934730ba9637bff70d2fd584118ec16b3d253fd68b488de07755e3e3b2b89f1b0f393d72f1060d02c0187ca1ca87d7f4b39511b9b396145de2c8bb024d03febe3229ca893f8414cd8d40ef8edf0f54ce77d29106ebaf933b1ae997225d0e15788aa62bc8530cf8ed6836523e23ae3fdd1768a31738c91f235af46bafb17058fc2ec62d38500b8a004d01f4938c54fc90a5e8e068bde42751f0d41bb45d31a21187ec30821daf36c9a6f86affce11b36b50806279285ea72c3c3b506dd6b8d9f66726732efb5317b2bfe16adcdad5eff5a857abfbfa28eb03fc94c96d331b2840a36d8cd0bdc32fb0faf0758f2acafec1e468bb61b9e5797d7e527e0095225c62450b685683bf6628ff27441d6f5573ab689ac01d7418af7fd5cf5e0f2880897d06fb1aa167e00e212bbad72b98713b9038b6f42c3e02d9ef41cc756c2488cb0c169e980fad8ef29261378d407d4dff79643963ad5c1d182856254e1bbd2034117c6f66ee591e70481fb27f0887995fd48c01669ed33dc0552071fd37071fca1303bc7ef69898162a6a8edda68f779eae12077f75e51b9fc1cc7662dc9a7ac49b6c962b4e342c75a1368a456dd21b6860110a86cfc5874e2779f6a48c28543cb5c42ce40225c9b9eb7dc9939814e6d14494e81d8f4f49e0d0c082501b1b624dacb8ddd1c4fb162e24b1bd41ebf4bcec9f1beb8d19bda1c860e9dca5a8e33da87b83b845d37e9386e75215baeaf7fb9638f741832687b4c1f22b04f54ddf8c3f54eec14bc7495a7c4dbf977f74f726a5162f5bf3391a65344f2c78e7c339984ae67c6ae8faa42e8f7fc9475264204c6cabcfbdf751815e284f6b9d7bafefc3115b7b3af5ef38f148ee1fe918f5582c31eb81069c7bb232da8e45e2fa8f26ab1d9b0833a357871912d05384cb58e6555e95602c19456373ab71aee8d49f3ef88072344b7601b621e15d31c502b2d52ddc07b5b36b69db96476f14103078de8bf9740ded8bb8a0b024f41089d93f65e822291b96eac515b53dcc1fd484ede269d343abe03bb38aa2f7e120bdf270de4e3d49e65fff13f7d817ad27b75f661a82d6ff5456fc7946d5ee9649d8c9da221e671b1124a037475251370a8c2aab2343b05f36cd8cd5006311ed40cd430ab3e1d30b08179601b7672f58b37037655a2e5dd4f969b90f342f4cbf9901cadd9a00a21b5bc789d3a89d8db560ab4d9876b2205c6f6e3bc970dd43dc8330d4da76f0cf9d0bff17a88a0425ec49d134bc681b48279d5f9b9a2f87286bd55f656ce57454b1ed64d6ea7a53fae3fce3a9f008362926178bd7427ae1fccfff9811a0c752a16a92a91baf00684e7d425f9b24b2ed204f9471cf2c890dca557155f4f99573d556b0989eaae55d843c6dba446febb4d7ccd08bcf59ac0d9eed2532fff91d680483d496d1e930ed8c5bfc88f00bf68bb1f0ad36ad30962469970dd582cafd346358047b4db35303d2d1f2bf72252b1dace39eb65917b35f92d1c674df4b0332df64f2744767fdebe621bb6ffe5854d0b5a9dbd71fa8ee67ac0e344a2188ccde80bb432b94a021c475b3e9d87e0b1a3cc499dd356ccdcbfe8c3adb942852d44b24380ab51faf710d3197c4806afd872ae174bd4cf8ff89e5557a6cfa150fd6c2dc19a4d202473d6cbc480f8e7ffa52ee12fed6486f850237c139072315cf07e79e1e7d60af86cdcf9efd19ac436f7ce592a10e49a196ae2c3bdffb8882527934f4192b6d7ea841da5c044945130a8814967ceb84f52190261a67049a14a9fbc2a5bf0be5f07e3c1f76f6bcc5fef9a3120e797c2b83244ab5786fd909cfddccd75aaf75796aec7f29a8ca858f5df2f288b51ebbffb9794bf6f32b3eaa94541e10e1dbfb8e6c9962118ea22ab9ad24daae58c94c291526601563ec76e469e8f0e0a51fb58c096dfd0ad9218804112e044ebd53ad1ee540c7651f4b2bb003111c5d57016f5bf8b4b006d89d0e9230cb62de57f6c08ea8c23b5dd317e8d8d14f9ca2333c6a7bfa5714d2195f97136a930741d526418d908e549474d9615e5916eda27ce3ae9f15e732e02336c1a9d1ad4a3562080ef86414826c9d052b7442b48200cbb2ddf11e784b1e001ecdd36e48b14d65628d545437698a09e6e3acf2ad6ad9f19272d48717561949b7e05b75b2d85f04f53a1261bf6c42980a59469fb81343cb2e6216bc1a2b215b6582a40a28b9543010d1090a1ea99eaaaa9fd4aaa175c86c6e0ff4fae6618abfe9202ba273eb0781f27393c520a8e9b5e701f75d062fb3f448bbb3994bc2c587a72976e1a5718328fb190b74d27aefa403bd011c5d8eaef9bce6a8eaabde00eba44cb0edc2c99ec9bddace616684b17cf195e56499138b519463a63ab620b5229672e2b52322a43a1345f9576ff60c72341995a622bb9f6c64c7ea4e55d261625a1189363a173107b380b087e5c9a9b90af1135abd994b140f46acbce235f34400274a411068938d9b289eb8db7499848fc4de17845c4364812ccf63706251d49cbdc3a1b59bd5e8f5938e114e5140399dc9d6f95c83c4151cbba3031f9d907987c21f08bb40d56c376cac01bf6cb68ddd92820e27e5e9cb33009ab75d3378538de1c8499e4ea6c25e3759ff2f0cf42f7c24a8c93df67ba362021e622f6b7864e6feb1de5daeb33ace2f1d35c03db923bd00f9fab5e8faa3054b211185174ba2a4e023586f315086182fb3fdd65efc14aa2d8504762d6205d4a550830dafdd581c3121cdfcd43af8f3a4bf8f163f56e9c97199c6c4c64e8031be42f8f07815bf8c7fbc34999e0649a3a6119bcd9c8246252d8ec2718e14b567fca8768ed953588473fea2881b759250537b387b0ba6f2717267278c55e531b4a42a39e3285b3371447edd9a5dd52e1ed09dbdcad01756a6bf77285e9d7e8c5fe586760ee827e50501ba28e54bbf3e9d27988454a580ea7682d1bf03410e45062fc2c87eff29bb1faa32b14f6116305150a7facb0fcd4907449cc3b150bf2ed25fdeb30d8fb055836c23ce703841192d956853c13aa9b9bf009da7293a8039b1a802c6d64119d667f1aa80b3f760eaf272b3c8f2abe52b83eaffd4daf7cbccb858da54c296a240fc08244df1f6599e3c994a31dc05ec39ad8155aabd49233428a7d01d1e365a9a86cbf062136eb121c8e23b926ef4bf30c68fb4a8182228305abbf76e4408c21d22f98f1628d963d805a6a70b1489991f3a3d5337ebf2e55ea7c570cf055cb33fe13e53906f776cca11175fa37b0613f38317c7237bc5f81fb27cdc8955003570c996693ce3d78add4934f90d7fafaa3147a6b1ffd3fb585d5230c9b2669a79a1f34bf771cbe6c4330050645fb9451378ecfada954f1bc281bc64be21340f3d34dc2de0a5ff2a2a6314dd5f42160718ddc134072eeb863c58bdac2419b35f69f3a6723b6cc0ef6b6a98c2a6288babe2f8f0b5e661befb5f1bddea06d1a94b301672d2ac8b1aa0c37cace84527733b8ff52bff3f98b386e93ab06e8192bb308d80e8c37da553f602bc45d9704111c1f1835975e7766e21af9844741aba969fb17a6d1c456cd205d2438b945925d532a90e57e45dc002b1824b23b0721616096c0efb558f8fef3da82b994a0320188f5086e35fe770fff217002033452e096208d7243999900052044d579d5c57a8ed280d524a7e99fb9d0ef8a5cf989f976bc63a26a4695d54c806475f8068b4b635f2c2b0cd08a616ee56a5d9986fce5bb87747b4fc14238ea7b3a80f286fa38658fb28c07f96970793ae08c8ea923fed7127411216ea0647ebd92d5fbc1a9392fd4d3976c95049de71eb8a8be8d93859f22510fb7ab98bd7b31912d4b425f4365d76ace4bc8cdec1afeb1c5202641230c66fb9ce78ad3cac589150f2282c218092c2f20dddb106687a099e4454fd66345bd59d840e9ac8468c11fac080701b2014eb61166aab174a458f9e33cdddb079c427b74ca7a8c5133694882aadbcd87d85acf5b028ce6d6076c0ab83e9efeed58e137d8647bea791963e874f8fc46fa9ea91ef2d5325e0a510e46a9ac6fe38c24e771ddf765c222a78e0d52ef37b8820002be0801455b895223a6bd1d65207dbadc1f2445889b5b6e3d79aad683b32c2df6fed746f8ce78dee00f145847e06009495f4cf16627ae9917ab4e85ac409bd3a2920f1ca8092f9cbac27e63132a08f3d2da67f3702bee9fe0e8c894308f23498da2001e2c3711b05f9869c4913b574c2979f3a7b798038d9cc56d57b6d8eca7b4d7aca7ac39c4f4403509ad085bb595500673ae575c123ae42aeed2d21f5dd8dd60160f31229faff959af72aaed92e2b4e80f4ebf936977255b48e7766b66035f4c5d47e220b78817a1a8991aaa564b68cd14c3fc38eb7538201fb5c05a0e14f815aed9e59283c363c39248aea5e37cbb9e9e64132a8277b0b3c3ef9bc0bc930eb324b3ebaa3e8fe56189da2ae7d2f372f239cc049f496b807ee6f0a964e44f0425fefe118f3c9f1cc78922b0e7ac60c4086a8ff68f61c44ba4ac4d102197259c5a71421736d73da3ec48f8eb365af212d980fd7e5705a2c98001ec279a508fdbb8ab1db79911c4be7ebd1c1f4f8b1c985eefa99467677cd139a437f94a33d9046e331f3877530d19da9abd676fe31570d15c2abfe00bf85eb46ddd6e16bf1fa316a347c712fa3eda449d372c271603466995654b0960790a79fbffaa16045b3a1eeda619563015c266b43233912a16a343aeaf8dde096b0c7f711ca2492a5af60be41e1ba22a956456da4f80223999bdc0f267eb4b6e3ad77c08d2c666869471e0450f344f82b0c0d198a6c43d228313dacbdd58125049f282b0cafc0aec5a7605572c2b9ee63226c770dd8aed01fe8c123efe1a6821f211477319c718f47b482dab03194133c9399b6c36907b17121e7c6f06b07a73dc4a3069cf92dd755af8d83610b78940a839246eab36cb87b4ce4945b266a054f8f623ce397b61a735c1801d6cba50f8f0dfb70a865fa16817b6b895537922c2dafd298e017fa8f566097f8432012ea79c031f4cc8b35307f1b75d1d95ff0f0bdc0ca2a8544b20b157a473d93cb62035fb47563de8fc360dfea8f3b14455a6c327a6e197108b1dd5b83a74f01c20bb67dc38af09437486d01838b45c10eb5f1a254cf8c5821d3dccb64f1ce4867a6e008a3b622cf8d52dbc6c8b11dd6d2cb2e5f802c8478ceeb68a369cd4cb85126f3335607b53f5434a0e806e2e6828b00d1caa1a1d23e538ece7490b24a945eba8d9bf88ec25b393c0be961fc65069df4745101aca7b27f15429a2387259f1e5f4ab6fa8637eea9d1434aec5a98e809639fdac0bac65f759e5ea7386c686fc18ec53ffa15b2482121063d01b9d14b2c26dc71d1eeb9484a4fd83eda9371c82ab9f83ae42b696f8385218b5db2931c99bcfbdd51eeed300f900dec5192a1dcd6c33b2c82bf661832d213d4d9f7b3200494e37eac04799b3910b08937604cec91b5df5b9481578e29215a9cc7a8e8495f63698e8311eae2dcf43ca91e94e8dfaa6782a12ed33a9c1546a48835581bf41005afa04de0667c4f775e2b8150f0f6737272e59d952c86838a81ff9937ae1c89a15b4a7d3e637eec88a1be328b9a1077797e15e992bfcddf7457d5cc8f19cd29d9180115c23d59aaf73a4013ea56a3b46354a7f4f380ff3da2ef7d6f7ba7473b96ff521915175f7b563d9f77f3e042dff5bff5580a7dd0bb2c3eed5f84d795e54067b222ff8668941ee4a1655aca7d86b68e114dc4e53b1fce1428a1908a123a651bc160c3138dd3131520e89444d09b177b65349b1745b63f7e211cab0719e073d5d182b3df38ca5dd9132e19f3bf76b541e61c384d5ce41f124d9c69fe54ccc448cd5182ac9d5485eb20b48636b639fa2b3fcc6bfd861237410a55bbc306447e4c8fa180c54695554b3f57adbbf151d80f60936e31abd1fc81bdbe1d7ea8b3f472791bc66974426e09c80c89413cd3be234b6c4bc0b613e8a37df187851c37b470f34ccc0cf1129439f6ea749e73bfb45f09c703af8a225e176108356bb4bd8d231a484222c35ee7fffef2ad3a38086958379936dd87457b865d4f651cd6769378db44b89d3b196d19a8a85d6941d9c4a0cd60ca9be404e2c508bbca315f720b17d7e0f8c0110185556f3ab09c9f62cef9e8d27c8997198453543adc440b35ea70857cec096cf0da532e43d592c8f3c1eb73defa8cb5bea9d7c1e31ab141f42a4dec2c5e3735e2ddcb9d9548a3717c74fb5ebb27b52c7f9d4ceee93a91e83c0ddc48cf06d25fb735870cae229c4ebd7d240e07e4f382fced5cb0201b24d82fabcf36f88736cb6d1916f04d1f13688760621cfa7fe0ec37ec15465ccab4122f53257c5e956f31a4635a705e06b3ce034fc5b45c2f861d6d263716b1b7e8573eae302513593b08c81d22df08540ff21fc74c157ab9295c95193ab7a54ff876ccec84520e8de1c99c4ff09751b359da17b7cc41fee76100e18e7e3ec92f7c09ff73ad4f23ae0d9c51d6b6ccead05799c1d06701a1d84e6427c8b65775e81c2079c6fb1324a9de299ffdf3f79a614d59cd9eba7c7e3361954ddd2c4a06d36bdeed0c0df052af9829152826e29b38125e82a3472c04b1d2ef491a521cabaf051cfd204a849ec0a9d4d32d4ce973f54af87274d15e234e35d6e9a37d7a3703c6beee02dd38b9d7728b7b77596c3cb61081fe67d9b511c2e9a98df99ec99f13e676823d5942c7e8db7ee77631670f5e18cece8e80cf830842434d5e11f1a3f98d75892f187970df56217d819e2fe2eafa9cf05e139c81e130d41e3b11fdbaab80c53107edb547c7ff8ff670cb6998e5735f4838f05fad32f3745976572a3902f6fca29da5283ad6ca070f1982c40f58ee41831092cd64431b199c75545262385565ab9083e14ed48ec9a06aefb281521a3fad9b5b2ee939647658cfd7d2fb691ebf70d17e74ff7ee358f96ccbf9a0110e71940cc01dd6a4a7c25a789b4437062f289ad4f980e2e0384d87287b059eb29821463399d6cb12ec74e5705ecd3719e8998b4c69a034e41539292234f6bbd1fcdc06dc77e03623b75044c6f5f8fca0f07bebbf50c07ad0b0abbdd54ad8e90b0c4230c54a06188e70bdf2978a6dc67a83b38b82e2ca8aa7a0f826b36214341e0e4d4e93e2baac7aa22aa0b630dcef418582873af9669106ea8dbff2e7ca57bf60efa38f76751f78eac18f182bc57c74667c5cbaf3d4304b4899a874f9d4a70adb28919527006d874d8e855749f7193bae4fe54ccbb1a46af244e3167f2702a1f8861a7d976ce900e4030719a9d6286eb3c15863d9b5370cd108b36631f9259be8305f56891a157e1f0deee7309f2cdc8b6d5652f31a1ba7c2d36850d37efa5e5a366a05997d7e80c79817ed5328468bb33ba04dbc40a78dc3d2b6703fa895d57e1e0fd52abc8f0e571fea8ab2258bd76a095e4cd95c8e313820b3befd725f6eb34644c3f889a5d73b8539ac95595923118e979ed03a3688ec90a40c0882cb2783c363babae9eb5dd42ba94e57ede2d31df061daba28cb87f4a1c991ba17d608c1bb1be9ee971acb96cea2df372d13be60bfb7c7a138db8dc54ee5fde7c54474c0838e465cb9b502206c603d0cebe95c4029eb51c9ab617c8b69de526cfd6619501a76aa68c27ec1bff5aeb35f5586f21e1575d9324d8ed6c1fb7a9264fb1b073ffb43c673343876b7d36124f2ad439f75aee3575abccc2d703c4e51135d4527e3056d1371eedbb7bdfc04f0a0787f41ce3cf4ffd4dcc22797746fb8fe659607733bba824a888bda976dc471a879f5985e856cfe8325e3b9e38ae6be05ddc02a703a4401abe859d52eb309e9b1066d42e1af99295ec7862e8dd2c3403c55ec7bb31b71225beb2be51ed2b6c081e70242cc090ec1aafe8207018bb77fae6e5f6b3ab8bce3ef416e4b2d36718a1365c020c8b15f067ebf0410ddf6924052af54553f9bd24c142598940e21e793626ae9c8801141a6acc7068ee33646767bba18a101e5574238a0346698467642fccc8decbba573dccad2450634def89a4d9b10d74371fab3c35575d04ef4a541bafac63ba8b46166225da72338286c332fe4fba0df147e289d56856c6a52a0c786b9b67ee2b11ce644d9209b125b2dab563a66c4ac7a772c6be92fbe9c550ce5eb78cf43d2fb85476e69c6e803e3e7fc9d55a65eb89df93be27d0afadbf9d51c8506c3ac49ea22c1fa68c0c9412b40e6b710bab268475b68e20d1fd11b5d8da90c623c957b510eab342da075dc2851edba9b6619a1e280ac043bc00f97a24ac38bd363f8af9482a7663749223546f5855e029bfe1ae7dc3e85e25bb96221e9cc6c70261180f485007bd22249716597c4a5d11e27187681e8ed7ad89bab2fb92e748d2a935b5cb7c78a9d14afcff18f247b5f3173563d9d5ee24a562ba35ff2594d87347f4566713170500555b07cf777fa4000a2ea199e609eb0ae2372da4fc86ebe8ebb88f6bf1bd2597517521fb2517e3e2d87cef3003c07f5167fcd7bab2a76ebc26f168ab96bfb7c5e19a842128c3a590252711783ffee10f80890facb6b366c551423f42ab49054b3cbba4127cff9d36278cec2c7e510384b6b7dacfcbde1b2a92d30d79831c2d06f3582b00517c2e3b2a6a62c1ef40e7c592877540dd05720edf4cc844f147bc1c0af9d9731eb0b36509b309a818267d7debe1b327a01236428e4a95fc8af826cbfbd0d3a948f8c6e8904c0acb0d133fdfe0ec44d73dbe76d64fc95f466108ff572ac62b3e6fd3e488587b17653f94821b3be30eae3192563889d973b4172e70134596a530a8fe2d4e0d5c84e51850888387bb9753cced755183c033fc9a3ba38b886f2ac2033ee0e658b1acde30f1174bc922c948998866329f78bd6609fe9194b219bc3a0cfc2b156eb8e3253ab0f858ecb83a234d3b3701afe306dab91b9eca066eeeab46185a0d4e5c3c8645f163f18734abb9f9225f8f882ff0d032ee41480a74051d7f408a109c0e64ab5352d228c8cb1f5c98a6b1527839d4ec887267fb51f94bf30f2a5936abf9618fac8493ad0a7f110ced713d62b14e3191df8f13fb6d621b6fe882ef472b425f07735c72aceb19cbec3547e38ceed27cd4be64c8d580ca88781f50ab94dfdc1de0083ca222c7933a2fcb5c1a313b9541c8cc803201dec3f452da5957b57c01808b1f31b50802c98c85ac4c3f5e3671cf92c587f35b6576434a9e2c07a5801d35996c133f7888582ad8867d02d22369c4ccd5c4363914913d0ceb55b482a852cbd2ac0cc118b13a39b2b837e3911bfc185d0be04ba3e28fb4b34c00f80202ffd559e805c8fd7c768c82e0edd8b2731ad9dfc1fff2669dfe9cd2371aabceaf057117a85ee045224d0f2e5c8027d4337ce2f8734e6d43221ba1b80e7fe9ca2da8985daf8a6fc6ca669f8f69e6aa06b2e7c075106c2e6a23487bceea57e2639aa1bc9d33fab741b7908fa699f6e8c9438a964ca159e4c03b5f6c9f17c311d59401687b80f4415aa6487d814a43bbc7a799967e0f7f60a41fbc075ec064a714dc1c8493b767fdcc9af8f53bcab091b49bd586cda072829bc852d0db069af99403a3ab5567d7d2dd4690b5836b2853fc64cec1c5e32567d572fed0a4939dd58599900496ddd8a4f9355543cb8bd656e86596d96b76f46c175cdad287fcc1aaf0c1a6478adedbdb13743ddba222692e62b4236682bb202d196468330493307d4baf22e4135fdb6af5f6956c84fbad3500693c84381ac8b0846980879f72a50edb9f295ffbef885fb76d434a6db472897c5b225c4ba9753df8f138744a9c85ad57f1b923836197a22fdce4eb90acc4459547377bafb6721d676788bf335873fe6a0321a20e1ab923a4e3faa414e99dc050638e5f073ca489a1f3ac44eecbc5582a79972809bf5dc94dccace65944aad428e45b3cc68d87536688db6495d597dfc237e4fff09b499e221101129709c18d40a5cf18aa9ff23c0fc314658b3f185c978d601c83a0097493124223d55109b6e5b45d5e69ca39935884826f06af64b8726ed5bfbb558ea85ab42558ddb430209b7ad69c2808489228989f47e942dad4f896f9d8f4ae584f6a92c50c6e3043c283acffcbf70935f7bbc0360271ebcb8b827b8d867d478162e5d2c00b33a2a8af9f32916d718fd1d84f4d352a118dee60648ddf21d607bde5f30353e1af9adbc86e16abe96041a4396f68c13c12d98f1512a5aef398cf33be1a037d4f3ef50e6fa50d6cdc70ed1833ebb4dccd857b769f8d68046881aa5b20d539a534d0cecc8e46a0caf741f7d71ab4332146158f6c94a2831cc763326373c75ed6f5f3d8d4ad4a33d81eafad5d7a748156fd1d586b40f1b04bfc9745c6f7bdb48a36a0e046b0e3f006aed06666319cae523d017d866d6b5302192169a58b46e26c3349d19564c4900bdb208d4e1c93676e8899f0e0f6614a2f2c9c72271e6ac90d227a13dfc563347f9e0482169760eb9fa8c1ab7fa32d286860a7045cb77fbe078665b1ef51a9b77881b988f4a380ee1c90289554b967e20bef8a521d030b11fc400097ef2039e53d10e32cc75d8359a0ef09efecbfc745d2e2090130561e03441ec7c38131cd0df3588de497b46706038d76a9a81f272c7105e2135bd29b22154a5c5b7c6188d1c30d24da802fc5d69b144f1b03c008c0ed1b17729fafe23bf0eca92695e0149d15532cbaac03a89b741d2b8b26e5c30dd67b81f7e2f7b82b1b5af2eb6be76afb9b1f87e9f9a3f946fb14d679ee9b4d2671cad54ff27b97fcedde27f608a11a718118357f7576c47ce705f6603eea2bb459bffb413ef9d5f8996688c156834eeb74433763c25c3ea2635c9a556e661330b5911534838846de7959fa4021f9bf956d8a8d1f38c2544a4eb2bbdf0be6e4b7bafd3b024830263905177e8c331ecd811a01d1cd79ff127840f012771b570615a2ee92856b2d88c5689b1b161fa845531ad701ccd194f1725a3c4231172b909effa3defdd055d01e082febc589fb6b80e4dd978a8f3490849959084a0799704aeede980f57845e7e41bb2855154c83fbd7733eb27f17191273396e9d0d7c87b8722afcc851e49a8ae669c240f8286ac36613d5c58c34e05ad291d2fb337768b416bf35b292d3c08702b17f112dd1479a1753774305eea63b15516009e857c0ec7e25cc1b1ce6c41cced4de83b00d3430e2f61f1eeaef6402788854f561ad1e9278ccb341865a0ca87f1ebe94a1ed49726ecb9ee8ba601534fc0143f6697861c4bc228518ba30f33c4469c466922d657d14584b6093e54b1e34382de921a4f1e121adfce570a71a0b90693cd2ad55286b675898650e25cda84c225959619d82cf2e3444999210f6a3374acc0f5c58db77700b3ae2b768c58955115bbf259e28672780381f21416906e0c0b260cf0ea04657d763554ec6230e678862ad7a9a82d511091076cad591e3132eb03f5933a77db80534cfc33edd3c7c553a4f8ae757c5c5febddfe8c72be3687d10b7fc446ce825eadfbd8b78294ece257386cd85d2e11fcd5f62b13475bba46baca784faf27a4ffa6769a8f31f83aba70ab115010403604e0bd936250a58bf935e3ec713cd235bd4bda6e5441dbbe450c7d9c348fe70a402e242283a78590fdd22d628a7f59ed0aa9096597af901d9380cd06d37261945742d13da5e911c11af9f3ccc5a339e90f226d635a6713e47de107f18b1db78e487da26117df16adaa62af1177b96c2632cd4bb45e64294fc6830530d35a67ae6c398a5b25c1d86095935d56bb2f0fc5b876c3fc93b0781a09cf1f5452573db4f2f4492db6ab6b2420dd16f18e77417c59d35b4731d0912c43d6cd88cd3e14212e9e845dba0b8e1674431e779af57bf4ace22d1e3b2af8e4eaa28a532560daba45b461b0cc78f80be29014bc34757c4fbbdc6d7fb5c313b0180fd95d3980f9cc1f305a29068d8eeba645d956482c91ab52797601fb56ce23f944d65340906a2af280cdfc44e5d20868b3daf7407463d9cf4d867c45304bd752f61e0b940e008ff013e7afe278d890d25cdfd425383f023b97236fb06c98dd97c78ea42909728bad9caaa6cc02b262f9082df7dc304444cd919f4536a36d2caf635c198f89be3c606a4a8aabb9c0cd84f58dc8c0ed397d2fd24bd6375bb9a1b948d69e621a82e964588c3fddc83bc1b5fb69a88fc77060f533e2a03a197451f50e5f180dc35c0e989e9f89db3b0485373689a5f57cec82174976677fa3ce0dde0b1689590940d9cc7a1f10d89e62fe8195834bc685797a2fe91de5049ec82b7a0648e9e11f2f8946c1b481ee5c0265d9e4e466f4b4f5f19125c24ff854913928196f45d96a348ec0bcac9db56263e33d26c6370b08f7fc3cd69e0f454b851c2632134748a55db4692a2f57b1727875decde789cd65918a23ff4ec1aa2ab9f1b4abb2b78d87c35bf8b65592b617522c68941a83bf3c4b0e99e885bfeb8eb6c91cc572960e2898898e0deabecfab17e4566859e6532dd3030e3c2acea1cb38b94d5b6eea0d951e73c8c77b984cb92693f8ca424e80eed7a508e63341c5457b688017c6aa4a4922a391bb31c78da27a0fdd436e0168ea6c930598b5c19c7ceb31d610c7af54ee053e8245c127bd1e288bdcc1a888c718682745f0b915301514bb9dba13fb6702d6b867bd6015caf45d812120188bb95b277866147c7f9babef6f340ee1d73f56570946b36748db869fa971da77249a2941a71723a555b689c60d6ffdd9a202c857d67d07de1ebffaa1a6386770db41197f3bd20231cf221470a67313116b1b1e1245e178997bd8085df926926b09f4108545f06689a66051a7f56e3b182d45ad8cb4d0db23aba264a750d092ea0f0deee6ac525bf26bf1d254619580f4a0d5139fd75a4cea2fb8215cf503f4e42df108a62c70dc041941ef4b383f420392f826c412b2f0cc561f4cfb76f12b7a3dadd4c9daccb8c088eccae2766d83b2c4e8fda64bdc6aea6952d8c2394fb25ae63f5c95d4471ca1c1b8fe8f0db502e3789060d6c608419f6bbf6ca3d1f59cb1e79212c0a74d34c3b6e5aab5096d8bfe975133b7f7275cb75313aaa61d2bf4c4b10ed8b234717cd021e3a2c04dddd721d659502c8b75922273071aab08f63e87087ed670ffd97abbb44501ed631b308b75ca6b913aab67223a5d260cd0740a9cd1b944f044121a367e29f3c115924660b249c94611844e5f5f66be3901c218f283df3720aeeb9816ac560de014ba53efe4a77c9ccaebd49fc8e1416cf11b3d5ab9924b2b82b187bee14920fa86a356ab816c7bbff53bc2293269bb1636f2040de39e651cf5f847bb4c5dc234be37f61e446f6cec55bd275617d53a2c25816f177f3ae87cac354b89c67840a8497cfde744e4936ae116c357079becf5c6fa8605d0bc6b4f2eab5f6a28ea45fc0722cd12d36aa6f00dabf7f08722a1cc2b3bdf3e96301ebd3ffe775d539dbd67ec73a8bb76760e1fde4ebd467faae30523f498ec8793ac8e296a27d663fa28c4f80989b5e8f8ddd0aa56cdcfd06fc9a6109c543ac21b59d2cab7e9e1d817f555dad1ad11e530cc0d6562203259e3659c36f2e130792bdb85291a13e0b335dfc37756cf76a08cd0b943b020cb1a9323a107fca8f963d9632e0175de5d84983c42bbdb5204dc1cf8d5219f3efcf50e1f2883165750d423d71dc8977bd9f50c43ed4ddacba7969a4ca208e5bde19f0a4971e8d38690e9ba73db035f623a15b8d1964ced3fe45b87d8d040de0d2e91ad44e59c7bb4424b5b333f395432a72f05de8180ffc18d27517ce5c6192f9bd7f2403d5a857378cfac5435b214b3b59b0a8f356959694fee13dc104b60a29a5d78a9bc235471968084a69412c23a28f3da2ce85fd1d88101540b4ee3a0a6aa62e1a8fb6bcbc8f9c40dcd8b9573e3cb9db01b4614d183daaa0cc6b343e4603a379b7c1d7022dc111298f0549430af6df5a1b99ecfd93adcdf05a779f5327800b2a9c0e662bcd3552ba20753be2a8ec9f2d48e7601e90f429602a5b796de68238cd83f028cf6d2f1c6fc544ab0326dd683e390f981127010b0f10a6e3aef4f3bd639ab774c69e94bce09e9cf1bd62690492cfe8bc0042d88e35d3409f6264eb617aee76d36361799b803f8c3a830fc0180861956da4eb8190a14000165bc752c885023d36e5c29e94b1585263e5e62edd020b2265d853ed6efb1744700da75e86b6085823d4f68d8a97ef3878582246961b029868571d4869ab6b72ce9f96dcd2ff8cacc039495ef58e8cce4cbdd0294d81d8e0d89002bcde98df6f0e1b55a1f8f5a24242ccc9e1c5670b64d90face4b61ecd2fa3181ce52b134af8fbddb1cb47555fb43ca3187724c44518106dc4a076ff9e68d935a1203314da48f99f2acc4639006751b0f14b7779b443cf9d71fdee776100c038cc71c65d89d5ea4a696f13ba59a8bf0c11599a56aee98eab23a806a86486c3376ab9d579a2c809712cf415cd6283cb2218b9f3b41064f72f62b5d32eb33a083da582ac3f76861f0b06c8211b366f0f0a7a499e405e8653ee09491aa4f32c69caa5167737e8a3a15fd84edf02f74efdc70cbcfb5f6a5588178ac4f2db9e6bb7f9fbb4eda5fa869005e038057dc55acb87eb2b6e1efd33a0901df5cbe9aa23245f5a2b4242d8a23bda93a8d72aba58502dd4eef763137a05cfcb0453c9785aa440fba14ace41d9e930a5bde195693bd52c37407ffcd18497e81706f88d97551cfca3bf88f637f235a05cc4e32f03df42ff44003ce1eacfb85995960b22c565ab6009fc2c654cdd0d82e6307a996466414713b541b3a0cadc2cd98713a6a2c2f85591582b57082b6b14d012e2a0d95d67dbbb90f1f93701ea215940544a118c908eb004110b5f7638bf538d3f89ed4f471333d7f8ed8e048c579f27c3da7081e5de17b872f14699fbe8c5fa1072976ce336fc68c375e5561cf4f10641681776e308616a09f383bf3db23905f822567ff0264bce1e290f71fddb8fd6317864c44b2e462a2059f8af222e32dd592fdbfeefd0cd2849f904e3a607e027d77fb8510b3d18cd60c182e9a5e67090bf5f1b4d7ac96a9e43fca704e5a03bee3a888266a27cef22a7d4f1b9d54aad9d14fb4c1c969a209e3c7638c62d0e60cd9c52b7b74ad89414ce641727b8f76b85dcec9483b16de8dc131f3429d1f6c3c0fa20794ea1730c4ce1eaab0ee16f7f3e2f98cd1f8995f812d52a366c550b7171a7fdb10565bb8934560fa10b8412ef7d30177064a7c92f67b99674a51b63646c04b65e7b6980ba130f6cb8ee524a5f7ea7c137ff4f842d356de20e49bd8818472da4b2f5f05ec789fb926d0ec53ccafa5cc76e8a3b5b275f4d933e7ebc0ce6c24ce34cc3eac68759793b54f6266cd91ff5d5097112e445210568a8c09f0bafbe24e7b026d1bc146c76780c5b73c33ef2a6f4ecebf1af55d836e375db0c495501edcc6fcff61414b8623c2c2d50bb759fcf040dbe55468d07f798c9822f4bf00178fc71113e0f6bf993f783ae06c6003425d1787edb56221e0774949b19f6933202f1a8e8f6c53d28d4866e02a0f0d09cc95b00170fb6e4ce1f2515366a705c5eb542ce69aa59471ed2523aa7f14e95611e34aadc48d204f9a0e663e449cac266f67df753750191c3445c15e9e088c0a89052bb3aaf171b8143b47adfd05c28287daac38dcd0162b6e877cd9716dc172297a4fcd9afb7358a78a0ed748d8d7fadf2f1b1e89ffe310995cc0b5715f3702b4556fc6a080d6c6a5d8871b7cfbda8e012ab4e717dbeb2d671b7c7a052bbbf3fdd215d11eca71b911f2b0f3bf63bfac5daf2eafde072c7725f3211fa58cf2a96690bf333fd0dbe9e7b0e0d19fe5c04f937eafe56f0c9a534d696522a3dc20be86c5e6337f727aa3b94fa504f049ccea158b41f37aa42ca1a81aea5f927f04e166974538aab4f10e064763bc9c15690c703503d98f10aaacd9672d8f19a63d2b0f4133a9c114371597824ff4df7aafe502d8e453d05ef5a28e9945d6232bcdb964a6a971138a524fcace6362a1cb9dbb8aeb3157087c3cf125e90e86c01c6f998a677e489b19fb0e00eebdad4e3dcb32f67851238d0a07a59e65c7dd5d82d10a09e620da25dfdb39e294c2ef6fd0fb329b83a79d93a364031f49a2fdee7c87d10df71fd1b281ee8dbeb9c4dc8c021efaaa681a48547e257171419bb43de83fa67b50d96eb9d6407b7bbc7543ff95a8051638475c04b86baf28b02dc58426c6218b47f6b640cdf600c0713a967844b7648fa2418d259611f0debce0af99fe38ddb48e76a628dd3c87b07c49bf75e466f9341e5b8f8e0165c473123bd306f2fc020abd3c66c60030229f60fbed7fb6291d6d0ebe2f98b3ac38a1794e5d7c97231c38c6e1c9e91671627a33bb92bf62b4dab1ed47336a4e3dc21e992a5f3b1d6e613a96fad3b42fdd5768cda05058a3a974e2bec80a01d9b614fcaeeb3b9792c875cb9b8b6d92fb333a17130bc552dfb9c30c93c4ffc03dd7a4e96b1dc434dbe68a0767dfee0150fb31739d332d629f3933f0291ff11aca7646d86ea6eb566a59b3343ab1fa418c103e2d7fa6925738c5148ccc1fc77c876e61ae88b2869406cecd18623b49ea5e72ad16a98edb3da0e008949d3ac8d8bbd7035e786f26fce3ce58d6c9684fb20f4a80071d8d1dcf216036e38bf1e543ba42bc75eb09dc139a86daf87a8e681952bb365a97720f70eea94a0f4802edb10c999caf8ad89c52a4a87554489e5f6de6a5330d1b5744d41df866d58b261753234e5495b3c3735bfe8c81f45f9d09e0f178e9b106fde42ad8b016ffccc4bf4bb4af66485cf32284b0732a77d416153dddb486a5601d1e72a7a5cd4440b71f79953b93da4267c45656024ef19e4ec6bfe23971e32f4a614ac32080bc1ceab2cf3d172d886ca3cf1de0618be8c1c63c6624d5a63268e98f92ed0e03ad7177d4fa89bbf0cb98d67544bceea0358f8c738fa87c8d6bcd988a969571888ec79d1321fad80719475679a761e9aeab9364ce2ec7db472035bc5552c13411ea1ecfcd8539aac1bad651e7da82c2ab7da5486f6661ae55cb0688a6f7242e237830ba15c3036eedf1958dd4ad28ca995acd12e2bd4a7df21cda8cd9d43e44e69f56eb922b84919445ba8f513f13bfefa05fc3b51bb1cd209add0a92bf25d6ea74d98f5b0fbcc2992af46161c2e5e258937dd3747a85625f8c08668fe76f83c154e72a0801d71ff9fc2ff1b65ae8dde121436774aacc5cce509c26aef614af08bc4d94cc24a8317ecb2ff515cde4881c31658641c7f686d458fd9d4f0b0065fde27eb052f65762d676a0c60ea13a6b8924ea794abd8cb0bfcac2ae3c25aaaebc7c42e8fee323fa6a96b06b7330a8a1fd3ea41502af8f6ebdeb670ebe4d89a45b391a9c37326a8adb69fbef357a960d5e6f592ada7d5787cc1a5e7b711c107f8ad7412694bf835206a346cf48775b468c9e7a145db507b46c92676e49745d2a951a7e7703bf1864f2673509adc3530db8c95fd5a7572351b9308af5a35e1c58e7ed9dfab86e944269245daa936f3bab50c3eb26f08350a2b17ae37775c5b2f5170","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
