<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b23b44c3f37b3e98035517f83ba90eebd0ab070d8841fcb0569ae4c737150b4ec1ca5012a58e4268d12c7c917184fc1645be64a4a86d300af14eba1df2ccdf59328f09fc8e677a038d8850a6bde0557bb08e71b90e8f5ea7f5cc997c201bcfd694cf61b5f5509cbf3a322b5f6710f50318555a32dc4ec98fe44de0524e4975f058394827f75122139f7db60251b1b5087377e96d51eea6dfbde428a5de3f0bef649c2e78722bb8fd1117906c644bf833b1940df5384219413e623b0d48104a0f2e204043a48e11d4a32efafdc08d0f7271b2f315ca679f9f2a1dd90ce18e56c40da00f2b792b84f89440d823b6f03fc9d407de2492691ec3d679133fb362bf1f3d15def3eef694e8da1db417c67cb5875fe93278117863e62c14495be8ec445bac75c364361bf413682f64572de208b7237bff82e5319fc7ab8703486c19f17a3ff7a92698a77e2aced4ffec09294beb8112a80fbf0711fed18615cd89fcfe9cdad14190d9c988e31741b0f50e541e1e84d96d682bec1583c643aae077f52c40b8e8bd8153f97033336cca24334176cc7cf15a6fb921a5c44b55183abbecbf94fa1071497362b9e5ebf181bc077b330dcd9e0ac451535260c3b2593f22d73af0a1f742d8a812a74074796d319be0dbdce9876b505daadc6e39aabeca2386f85c7b6a76fa84f7b667d1ee04e92a818b54ab30c09d657d90edd92ef65e39d50eeaf86f8bab4263d3548e1e89d19fc162d0286f6baf493334689176a1bab0c5ebd0d03decf6ff955bf8a22e773ff7530fdaecc21381d095fc9fba8134bacc192aca3bc992e0fad56c657e008a43126be80d65164065db510e67a7d4f662123f9ed1c01cb1e84bad77b34316d41e6242b2f097fa1afe5d7e1fe0fef449641f7648a2f2784044cd05fa078acb18227d232e8a8ff906d4f6d866d7d96a9e0969d32fa7e24bf20e108ee516110b24f7e5e385af42ce592b8a313013e0809558de56559fc8d450328fccc0981f7b01fd2b6b936b0e80a073a058ac7296e6c72cdc284f281970ac68dc59f55879a6b14b79dd170b497539ce3776039866e6960c6532ba614d78b227661088b2dd85241c85ddf4eb292f65c5abe95c1e0c5c320d9ebe19d8718ca8b62f4695593b8bfe5c976d616bf988eb76039160b57b46ce1aa0a7eb0227657d5bb871ec62605d7c34cdf533e36e39b2e61c4e139975d0cebc555c22b9c4c945398540ed9936a7961292039ada59125c0ad6ac0d3e59e4f63ba7d1c803531b8fdab47a8ccfa1ee8a146996126c157ba430e4e48b78e687d4ac5740bb29a30c3930bd444b1f5c17782f6c5a1896021fc0cb2c17ec94b23c8fc5476fbb7112ad8977245ec26ebc3bfe00893873acf6c1a3dcc1ea6d23474733319cfb72d73baff25e23246f68953bf7e2c2137cd661cf2dbdcdff66c547065712b91fdcf880d3c569cce9ed014979f36ca7994884ec0ce7342b915fba267c90c40c5610a92ccb37fc83db7f7e47ce604b103cad663ddde3ab05b01d29a9bbaf0e628fed762ca1b0ef25b8a46ff23d3bd367aee2ad6bf509721e92511ef727b702c9b7d2d57c2049eb354fd2fc6790b8e9e817a11414fe27e0c98acfa928324bf716fe253b4d8d77ba539a3801eb46bac229726b3714f9cb7571123996b3b52bf0e1779fea8b5cfbefa7972c63178d62fe47dff78c65958cea07ccfb40e0796eec021a063e80ece5d46233068bde779f0bf4f5a7a4304f9e5ba11b9762d2f9594088e3cd51bb9eed66ff65c8c7555db8b8b3e45059ce201000aa2e4f685cff01c8f5bc7fc1c8ac4b3bfac168673a65bc209ea55aadc3b5b82640746f2c412684552d3d5746b12516323f8fb46afc94fdc6ad126c6c71948d1697fe4bb24966083481d29c3dd0d9fe773654a3988764433ad1688e777026f3a7d29e2b637bfc72f397f7900e786bfe61b603dff8f4197fd37c26ddf9d62579ba68a5e55074725f21ed3d35193911a5743403eee45af41502dff6281c41f47637965287c6dd92d42a405269ed29bb241df4182c5f4490b162f1509561c5de8a36b18dbc52a5dfcf9d99e4332831f24e747ab8c9a326f201216b138a75c5cc0f5b002bc24961d35824cfe9d9913dd752df38297aa64eaa7c5cdd944bacff9b76ccb0f87aa52cc303932a8748885a7312c444850712694729885eefca64ff0059142c694f4ae443472587738c77ba1f6e972ebea98203d226dbe4d201c0ed54a398c27c2fcd9264ab40c1420e854d15372bd9c2405c4cd46e6f36f746d1324a3cb20d3b580821f5c64bfa032af978cf637a2a223d27ae9a34727bf7c995d556da418a8cfdd16aee520599a18e4195ac01c4ba46fb3f77824c23402a97710b60b98213b9227f04049897092b5156234fab1e50d4a2e8fd5eb33d7eb578d0006399f44cf89edaf16010df2f3aa0a8abfbfdb7b988a2bd70ca4d6951574d2ad3b26e5d22326a42e1bb3187ff9aef38330b30023dfe45d5f10606dae95a3773659d6651ada955de973680a7c590225aabf1eb188e730304fc532932c914b6fb392e1d9446703a231b3dd1a43c9dd50cc971f8752e0ef14542c6eeae609510e2fd109a830d3457c5c6a037fc03230cafbc7d2de419e7c53f64123d05d84d33a8952c9525bbcc4730f449373b2b19b63f27d117f3fcb3951bae2c8bbe39e197739bc2b8acfff2b70b15c242d7a5f74eec7a7d49774e02b845bf062c222ca59d66436a4ebb0e881f4dfda1cc24111678bc7d10cd2e5126a098610e2d0674a424884ce36bbc12927796735f9190217dfb16056c6ff1b29ac862f84ee3123117ab7916395d00f56d5c32c39e341c0f4b584c58ea3039ddc21c447c89e03e46e3e8483d9d128083ec9921f90ecaaa93f589019b47081dafa891ef5f963be4156a27cf4b2ce9ea2c3ae9af6a01c154fd3019585a6c8e1e732aa62fcd8798dfbd02d9a916ad604e48738dc43406c7a4397c460ffa667bb11985a40bdb89e10cc51398aa209c7bd0e1d74939b4bdee0ca7bdf2be54b8711f93a8f6022ffbc412bdc2c782e30b7c15488a494359a9a68e6b76179bd9205d96e9b03c6b6e37eb7d573dbe706ae118ed140e6fa7ee0b5539e97bd7d26cd32a0f488695e64c14197f23a2e2752b8eb5912a175171d9d7445dcebca63a98c5b20fcceaa38bd956f1bb2c898cb4cabe4ff9ad71494fd6cc05f0e7ff209bde4f364ba73c879301923dcdb2f06c1dabbab5f13e6eb7b625340c223dfa8de5852b645686fd9c6b780f76fe168efa8d98101fb740748128c6ae5e93b83667249d574fc67a25b9aec2c687264ae769f1887d5707ffb9b44a46e55717ddf1ceebe2d0f51d57440c80988aa36bc6a20c98f1596f870e0d022dcb7ce198825b5b73db1fb6af39b3003451ab5d49b72a533867c8e0d1f44527365e41cc09ff03af48ac02021cabd77240c0382ac2768e3a644071ecd678b6d0dece79a887b190019fe474168f833b974f49d4a1c1b01849d944db483c14cce3ac992199738219f20bf633992827372c4a3b5af9567207f71ae3be475d4fddd8393ae20b02fcb2ae9f0ed8b0b2ebc278c0dd55f0078f3be9d426dfabfbc44850c5a6e68bc3adb8c88fe024ca5fbf85f91ccc900b39e56009cebb041157a3467686eb54d71ff09723c75ab357b32b20680184f20d835405dab66b4bbecba8a7eb5b7e9956a9b081f5a567623d32b9baa25f058a04e100dd84ef73183e217897132ee714cee4fb8c31806411543f3b37aa07a731bebedb1e0fccc33618107dc2a6ad89cc538dab48bf267bb2d0a5ca880fa0e2efd1458abfc0003ba8ee7f0fbf16d5060f0b5347664297a451e391053440fc92cf8efed61387eb3ce88b73b33117a9c4b4234d6d47f7d9127ef0a5e8d474b61b41ca0283b767f3436f3b6af9094196a5cd506c5731ee1fca7e838cbf48655c2e5e8c35d9fbf6cb314ea8883e1683bcba65fe5006495cfed5437c86dbd8e9e1593a950500b6962ff96939e920052dce677618ecceb0d81fcf4643389ce3bcc92f5cae399f2085200c959962b4eb2e20b4ba2435cbf01b61f7e701f59a02edfff0a32668f8399867c0b83bd389b13fc43260e80805af4b86d7f20f6938d32f8a416aacc1305789c174c180daef5b86ca1ba26d0dfa201e9f78e70a08e8bea548560af1adbfce9a07a59fc32eaff28a0d6517d62101c2ebd8e172afdc9aaba4af77a808df816a649802ca7de83d14c03ce60bed34161e6ace696b0130fccdf9e25cfee54fe3d649edd594ba2353d4dd9e4bacb3ab5445ad0da3b49d812170a0d3fc0a841ef4541fed61d79ce1553f4189586ab759d84dc840679741f3637676ef2dd2a6d491ecceade46a44757b1bb9b269074a93649f5d247d9591a5f0a0507397f75e8f0f54b345582a7a7ea822f5831ac4172b03b23bd7447b557c3c1479eacbdc8d0eaa6638bce22beb8a3a78f89509da7b11dd4d3a42ff3f92fcdd805a8285c14b692edd8ab4e599517858551846403157e82fca1691a37324cf15d1a7f9b313c373fd965bf0aa173e54bd21490f829866a59f698ca0fb36f82d922ed995ba52e120d4dd0447b47846ca93581195754f863744d13b75370ed57e81cae5a2cce23d00c7c3510b0e8443899e6e52902ff1f5d55f6b9eae45f1f604b89661ae8f94d4687d8b5323c13013c0bc391a00228a62531d221092702982c82d855850274cde7efc75c3029c9de176f59712851a1dc3d493e18299ce5223d597e1515cb68fc59c4e104bc06a322f105bc7d9668467928c3683f49350c912dcb9477c262c7ab2a0618adea0b87c8be4c8c85eca95ea76357fee96dbbdd7167b3540392ebd72aaf3f3e75b926ae2f6ed0661481b21377cb83c161dc44eb75c0f3ed149ed604fbd77fac22716f982b3a550cb65f3183973aa84fcc9552362cb7a1522b0eaef4a8dcb3377b2d4ef05182e824f3019c0c607b83524c5b9fe611c499d38832c4d978b2ab1dc939ee8c7d9f7a76719878e0ab59f722d9583435c6030e1c84a426e7ada008171f741c63a3caed411de4bbdff0c14861c32726de1bd15413f08d140a6b554c8cbc02d6b51cd8bf5cda68defc31346c7019653009f203aeecab56f05129dfc5166b3562562f9a7e892258ea7cbe1a5b11c4cd62f213aaa9955d9ef4a8e960937474b7eb349b5dcd66ff6a39329de940cd272405135ec57a0335e8621a07076473974300431f5af33a2ecc51b386ed71bdebe0e5e8510ce8b883a7e1b59f39f920def32da31f5e1eebedb631c5823311b1e8e10d919fabbf27586a83af46421018cdeb989dc883a274ccba65a447b142b858dfcdc3049ff4634d9ffbdb501f77c0dbf19b4f358b77eece48b71084225adb6e9f7a9f8a6d9c9c1e1c71f102f60e77a59cf10727cfec8e7ec8acd4dce07be622e990bfea020b2041ac87ce3639b3de744a89400db2d6bde865eb8fddf98e3d443e27534543b444678d03ca645f9447a4c87e884d438ad0bd4d485e7adefc09e8b18543a2b0162fe870a1cabd59f2f6c7e409af8a025abae4ade75f58000d28bac54c363e0e60c48420059c1ae3ba52547693db9b5bf2920f9986b03256d15de8238b1f32cf5d71b255db5a54db6e8563b04f1f64b6f7586863d3bb91bba349177c47ad5d7e7a1b64e2144c416d0621af884525c9fa8302234cef1e028404c24b1d71f08439c3d9fc99765123bc03f4fa245b2453997ed43285110615876fc80cd698682538b7afe12016211485bd61d22f57a30db52a9005f0787fe4b34e2c14e8736a78901b65ab8fa7098150663e6e2daabcfb3eee57bebda1e03569049e315811864b16f47e63697e71dae817e77c64533989b42db29eb0b3b301bf41dcebda876e1d2e6f9cbb2634c0c8fabbcd0225546e4df1b2bcb7063dada446c26857c7d5b587c1b676bd49125c7aa6f76580406427a38c80ef904607e336cc93235f48e9ef15055c811f4e1cdfdff2100948a0a71d0ee740cafb774c62aea55da4e3827a54b2e6cf0fe5e6c6df7e4dc123dc57819ae8af8dc3e2b882a232ea8f70d6907b2ca9d51beeefe6e0a1a88650c4349f860a23836222173b136e818a7414b6a85b1d3f8a0f98f4ce05c3bfba24601174c24a13ecd2745cf0cc1630c92aa10aac104a7c7a4c2e2ea023458122b419f9fbb976610d63c22506e899f6dcb9b06789777f5503569ef41084d6aa95d2f27e01a829ccddce41f7abcff0d82c8b491200e169687042ebd9cc8812e8ecd2d17c401a410b3fbb494f0489c0676baa563c175e79f913be2c83aee0ba633282179d0a1f944596184454ce933b1a20e2de129844349d6f18d0e248a401cb3d10d7abf0f9ee3d94fd2645c3490ac2a168e0e17a79223f34dca70de813fb628d884d7a81fd035b465fd6f87223521bf6d3ddb90d8913bb77d67b9b02496f59956793f87fa331088e712d635bca0fcf1bd9a749e59a05dc5ee81115430771275872ddeefaa0fd53298db66d28cb7517dbc4d9aad9e6d29e7576c61e44cfa154c1df893e5e14bc394972de11c956bfdcca6d0373071f24bbb8b24f6b2911cbeda340f5d618e483955b0a41b5148ee0f213be5eb745ab1482897f5391c6e0df89cca8f44744216030cdfe64dbf4e6e7530dcd23fdf78c079771b9b9545abbf3c126f60175e9e72cd873a19ebbdc21d3e66e4f461bf195f2e1e0534083293f8a7b79cf67ab3d09993264a85dde4326da4226b9b99834126ceac3ab80595fe736de1638d7c6d75598a776df8d6f0177cebd7f2d24f3ae8b3b85358ac9e4a98eea456df96d92d504439bca5ca469ec29832fd9eaebf51903cd2e90b29a8bb57fdf9c8f45e46a3f0a402166c1345c4f1dcc2f5b4b7eac6732ee3355f8dda04dbedf58108787498717df9c6831a5bdadecaecff87ae392f492fa94416a7a3c77ade3d50e8f9b5a722bdee5ca5f0f9a2c07079e51bbe979ad29b22a23922da0e311b631358937957d7695128c1eb386cd6da61fe0c21556ab9b907fdd163f11abebda09449e9d34a6df7382c71b2814a37b3b4f165417c889516ad1f1940663c1f9623920a4a868e61fe767def1953c350db929c6a465efa873ea3d6981f2084305dc8d33438d2bf15db2b971b906c3d40981c27b34818ed3542455dc7c25daf26a3b67c880a4b6c231a96a39720a2b188c8f74680cee43af21097e15302fd9ecaf69cafd95e0907ebedaa8675488998e03770fafd45009d4a5f496d428cbc1302f75fab917eb0afbab2087b82b3ed9b718b1eb3dedeb563a3d2f6d7c24a6652ff19a2ff54a0e1fd4c3d9dc6c3095773c11ecd6f1b2d1c82144827d5c80b776b19e218d498ddb0ed7d3fda32c9689f509178af1bc382fd892208b663daf8ad34416c2c17ad2bcf9da69de884fdc8a99a9bcf4e4da2f39f40555c5cd2b323c687bdf8cfd40667972453a9465d179ec38f032a8cbaef1285f8c4fa81b8a860042da22d48cbb915f721a272f5ae5de07b5163b5019d98358b8c670d28a197bbb147a7bc5ead8753b21de040e8bd6212816e6425be17f26bcb269eb6dfba63cacf7bd906e8ff0ade2f7129184dcf454ac754f14a6bcdc91124ddbb4d521a47f9e4447eab81314866ee02f68c2e23cb934405a21306c6473845fc18ae8db8988c4bb0ec45fa0bbe369318b81aabb57e8e0363842b348fbddc9d8a505f8fc9b9852656871545020c5fa2225acf8fe3b257822f99295f9e77d58103ff1e471b1a99cea3176870a55ce294a39a8415a060968a071dd7604d3134167180bcb0b2e18e8f0ccadc2a6c79bc78d8b608f1aa1633fe8aa685835ae175de1cf69bd363e8e50368323c4ea9bd4d5ec19f41a7b788c4e3005d0b2c9a9c00937d0994c2dcc958e438f5bef44395f0f36cbdb3164c733ab2ba0c1a473ff67796044c656650cc8c4f99ac271241ea974dc87c2a9d891cb2525923f1f31f03cf22ed27dd63127d3274ab49343e24d07c66555365e115b2dd5487e4e51d48290909174192ac58c29d2cf417c15d28b11c4de4855c3712982c99b628201fd49f41a896516076647306d5aa99c7b3bd63584d59d1905b14f8ed6beddf76c9b25697a57401329de0afeb2314cfa1eb0be7f5e1f0cac87f3fa3bc8504bea01688e5a974d53fac1537eccf6f884b10a0982d9e48af605db96d392063dd96586efab678ed6f74433adba0a9566e825125df8b80f31d93fc02f647cbe3eb6598c2f7f54417d6b597e1ff0f661abfb1885eee3ea9b657debd3cb418be718176511acb6668c86c25cc59b0e9bd66cfbab677316a3ca0207be67dff4cb5eaf00d91be8c66d15d523f31a9d73d53b1ee4eeaad17ff75c9b4e404219d7ae3a8bf7e690aaf7ed11a54ac9d3b2238e46b962df594dac5e0f3a68ea7d2461541629e724b3cf5d6713acc844d27000e1f8bf7822d29f490c66c36d1524bb006c835e8d0e903557e2265ef770d1126f3dbc5742354ce427f79a7f926564254bb3dc82d1e059805e3af35d08cffa06bda930d943b47cbfe4792702ab591f3b154a3dc851cfca13b15ce90501a934cee5ce19f2c516038f129886642aacfb5ab28e5f93904265876326eddc60d0ac9f96745295f6ebbe90d368687ca49fb04768053259fdeb5def6a2e8caea73de8b39fa21070e0935d0fa48225e7c5a13e1c5b3bb26645774f7514728d7a390439670fbf4e70dbfbf2ed787eecce1b7115a4b0bdf5cec21bebed2e2631c49d27b000d74a1f92be5c2475d720129a24f87038902fa3fdb53cefa0862a4e72ecb1fa5206dc738710e7b08a4f62470647a3e8fd14f7af360f180d4f3389a74e1bbb1b2df1c942e1f263064d3081749be6e0443ceeecf3f787cbbc9c0a3a97b2d2cb40c9cd4ec9892fe4f629a28e5363a77329b00211db25030dba843e931055f2a375a5ba923e7d693d3be6df4368f485e9508e877e34562e324431e9cdde701cf01777a9c8a59ef7614bf80713c922e7b45b0163f0a9a5e1c3e708a285b1ce5490b153646921587d3f2e946ece2faf032605c2974895ded2ccd899d33411219669c1e7103c39ce909f851a515614533014cefbd8f3af63c132f8dc21b4e0d9fce83b37d1699e2fbd3ba6e465e26629a9aaa672f4d3bdd3d9086145bc9fe598db276fd96145385e1517ac5034aca234e5d63005a5136d93ae338e5e8d4433bac1f4b24b82c81e1d9de3d16810d7e56e166024b19b68291c2c0d27f150e151739f7940dbb05bf0861298aa0f0627144759250abe6886d60c00e81ddf2c8ad11c95daae6b80332c4140a6731173f8451f102f91a177cb8f1ab3c2fe8b4aae5278dfdaf80b360747bafc05570f7077fc4528371e42ea34afd2ba9b633aa62bfe58628e2d271e817034274ee14bbe46e32d248582f72df0fa2446f3e237f00c8be4160cf0cf5ff55a935ccdcfa7cf446b117e6acb2b9821b16fc41d50dc060ed611d9e2b712a730de37e4a415c7b5a7d193f3231393f490507c29785f28f421c6ab9ea4a29b00f0fb6d7c6b531984b9beb6dbf9635f0de115f0856704794f531a22f1222796e4d87517b61b5d2f0161dcc2918d07e250473703d47e6fc89f98a5b6d550ff28d708bf3c0d76059b3898d3f83d065144f2698711100f7c8a9b1115059ba2843ba7f44b610aca0854999cc09b8f95111f7aa64ab034ac5f0476e0629bdbcbb7580a75c6b46dd5aa93fc67432329538aa3ec1ec2419d4454a7f8431f8316ae4556d7855ab9f5196e73bd20c978a869e89365c8646b803cd3c1c25b7318a2a47e0b331eea7d08cdbe1d1ca694c5153045d9e84acad52b1c736f1131cb011d25d52df6a8a26ece293d62e0afe8ce8d60f16e7ad2968dfaf1b64ab019a2010de7d5a8b4ebef954039c05c30e01d9620f7d8c45ccef40446e0c32b0d11f8d958182f64b962aa05719dd7a08dae75e50b0b3efb194340aa3232753f168ace0138daa5f8d3c59c0b873d404e8bff5223da402f46c70b38166b15b71db5b631f867eae6ff4f792b82ce50b02ef1303771a0b94a814fae0fd60900442b2dcde942258898a168bf5d6b56ffc9c310e6c3a6f6f25a97f74f6bbf3badd0e0b0b30985ce3b7da4ccea205047bf56fed8d4d120d39de68334d43f69866b7736e0196b77058f54c2b048905a23dbeb5904892e996c5a14a0bd55012f8d0f0d9f0e2a611da2e04ede168a749cfce69e47330e1f6ab5c83f1d9263406778401ab9cefe55602682f8f40b2c24e003d2f50ca9a3311ca11e370769a9ad411b458bc9a54e78dda1ec5a03a063e5bb9002ae712ac57d956b45c564d2d60e2acd61f83062b3a2b11a5cd45659641ced2665899012f973172bdeb210e666d8bc6344c97e3b56586baddf39105dadd533f09a697add240324c513cd1203a93ef80d80f15b7b26a27c7e424d684c58b6c7ecab74e1c14ec0c35d95c1bec02be1e9cc95d7f02efd43fe5e7da1b870c3462e28715ec6c853b23f31df566843d1e4b265c18704b61eea7e7d4d1074eb717ee8f0f37fd35426a70a18ce6b2a510be7c0e5b7f668202d8d1913681e90938e26d63f121ed701ee22d6c7f376e5f9e854ca9ead738b621b8d59ac3c0e682e52df920b8f742079d019a6159c5972c8ae164398e428dcffade0ab43003bed62a3c7df5cbb0208d5c0804a22fec835637b65c94d11661495709b8fddaa0d672581ddab6f6fa7242199ab2bae84d5f254772a92bd9a7cd877070c48bcac149509b2b4c2c840b7d1ce0c301d887c1525142ddb756c09119d2930f67bb879263cbfe557629fcd6937db4c3d1b297ab9d24c2c295900e92019d56ddc12622fdf2f2401dc7c4729bbbcd972531d2caf732e62438c3a91c33f3e48a18c41c5b0b954695e35cad43600d6d2e665c2d9bf1df8cee1e45cb75263e7feb67a02cece530bed119a40868ae5de55eb5d7930de24f9e5b6a36ff52ccdb677377ce492799c28270368fae9491b621c14eb20af4bebca50dd42355bc950f0c95369deef8a4bb3b1bc4d5f8f6319160079ccb9c78b0feef14b8e0b57db2ea7d6f8b52a5fb76c64e3782ae3111c003e396982dd95409bd90973f2473b08239dc125490a4acd825ef07c4d50d959549da3edc354757de8441120cf0748c2dffb2e4935dc530bc95afa36e36318965a96e220f5163060736678950e664219315718130b95cf40efbe826b7e6f21f0925e087f18df6b6aadb96b811c151d6c821572e84370b5399a2571a70bdaf11c2eb140f0155e2e7a0fe96c5ef476cd902ad13925e864d07d27640f1fc8410c21796af967555d141aa93b76bcd016560cf2080087ec2720715f0453b919c8bb03ecfa6f898abdf15e773b20101280dc1ad1c6c158c4c67dda69443d3e5210bb1570446ac55904c5f9f228e90b101927ab42c9e0eab75e13c9d1b09b72f017c6c2802a13175cd7615bf72770c111ffa8c5a6346e6d0b5577d7914ba986424b7a7a7996ce31e54c9a1626dc44933d3d195d01855cc3b6f51fa857dd8561b3437bb697b5c0b941d958c98b052eea270e4a4185dd124ec9537f54202ac889d87701a1e841291a71236ace2e9196dee5e10f881142ba31f7cfdd5459296d6d40e419a83b80e1a782668627c2197b3055d869b6c495ae56e3e45397ac31ad540987da5dc04db0b2c601096a14bc5761d6f1705d4508a1184260f11600b9c89370c30d50a1c1922b28e9c974219cb6fcae530655d2573caf37f727b22d1a660ea7127f0718819bf792e3064fb016718c22ad18c036a5ae06d01d6f2f30c45e438040ea69c62d8b4b1dd317ab3305ce235bc6c3a628e5cb6ac03524bd97f3d3f0296f155d4cda129e315cca3d75e9b0be854f10227a77ed8ec05b71c97b7a7cafde159baf277875213c71deb0abd6fc52ea830a0a99a9c928fde60e62f1d55a29c5701b552731eddf337b625379e3b2eed2e2a61f2047dfba4cb433126d41dff25d5cbdb62039170c85773867c8c86528b9080d9b2db6262109fd652ed0f42127012564a36b61a6017b0aeeb9ffe75cceb5a26b960031a3960944e97a456e4d04a725b07140118dd05c1a4a182bc6e18607f137c93fd58f5e208d852c35437b3d17906c46c375ec56652753d1027c0d73a67f7a40bf28668e5875a5f6d9cd3a8687efe13625cc013adbce1ca8b526bbbd9fa78e6d3d567f9ad1351cf9e399722f869177e13189832950180dd1c54c3097b061831bc822c3d45c13daabfb2b5e0876c04d6448db8ec1c54b69054325b2b84d636e14be601b3d4aa519dc2d704ac5a3c83542e37ab947fdf992e04219b376a3ecf81e2c07e53ca13c9d59365d54ea033e40eb3026de574359a81f94381ffb7151ba25feada0f3efa59ffcd4913995ff579e118a10be3f55c6abe74f1b8d0aa4cb2bf5c9191a0672b361bb699eaa96bd6ebad466dad30bfb9b5b02589daa25bf027be9a63127363e9503b6f8b286601304279288145f40432f24daa62d5aff0a5fdeef69b453456d856c918919dbf809df09af3e4206181fe687a4ed4fc2d2eae32b64e96dac67d45f3a053de7fd320ab1db02eb7fd6a565a7c03385d6bb50596175ac7f306d2147dced2bc56d1343ed72e47f1810d0f47eb71225142ea89737042f296e2b49d553d6b9fbfe5e64a62185ba69a282298cf7b051a3697241ddd02bbea38fc9881ba5986f9deb6ac46b4d3fded67179f6aed30669007aaf6f33f7f9ad022bee7a33f273b98940b4a45fd42f72b0607ab8a0bd368c3c71952b24051bd5436099404b8b744441e61d8ff03f0b2b65f4b441b350dfefa8c1d3c5215053fe4ac86e3507c697e1d4c9cdafdf3ad9188ace6ab8e72a31f05d281eec1656d0b74cbcb367673b372b869adc986fcca35fc2fbd879adb24424b9f464a52760561253cf392b5bdff91e5971c45e7d008cd9df6fc64c83db899429321f8977fdbe16d3b1961cfbf0ca3db1072ec0a94c245370343ca2813c1162b501bb5f0c79b70c21a1fa352817035fc5aa5626852b1db575d6541daf3c5552b94f8dc17214e10f0b2a6cae6dd79c2ac043fee19a15f81936146a64a70a36396acf8fcc6d20b21f2666332f1293a25b31f2a3d84c04c9899beb14658aba2c8d30acd98aa085e50d430b31e5d261b5a4c68a59af384750fefadb684f5ee4c7b2523dd28f1ec395927060d0be2d1af3c2d07be9c14d4e258fd473e6c71628108d117bad7c75c36f1df981153c5b45e32d6abb241da92d48662c56459cf2b93bf27de3de4b27ecb2abbc8f4da2cb7fb0f1ca56a2f2709f60f761c76b8797e134ec8d0d82c1818151f932f2860b159d88f0ca36498230e34b3a3689d9cb0a31889365c3a1696cc59c2777e607ef599045fe845aecbe7e45e9948c20175d75522d4468d9018c9ab1f4d8c490af8fe1180f563c11cf4b4c8ca526884c2cf8621c1e225a79ef753b39472ac84199fe62cc708934aef07a97c7950b7b68a552d187a061d7b067dd2f6e99959bddb33fc62495368a6224d84fd58342c78c743a2515936f155fb526bf6767054ddfb21347bf468e8ec3694b64b27030957c23c4a5b8607303ce22229c754c2efb24a05199bdd788446eadcc8c9ea9dbdd829d24a2ea08a3217a4b35f8bd859aea2cbcdd32319988becafa0a45c94dd1302722ee13a2a24d5060c295f87ace40bedead267708324d57a7f5fc736dc20d53bf08d3baffdd89cda2125f02542a52e16a94b3f8ae9ff88399064409dbba9bd9b342f7cafa71a1d2d0be079043216716c65def99cad33672974a3eb327885fcceab67c824a4d99162705bdec1e1887272e75c120530935c41b90b5e1fb0502b1e395f25e7e7069e55a20e09d5e517a35e8244ede8e6f98ec1cb5fb3c7cca2b25c8ffeb8ba74f54837bdb51fc000107e1cebe4e54d8ca34f7ef0eb032e82598c4d53f804bd925284e136e18d2acd57eb89dfe20fbf14718f1ee2e52de1436e88b35fe3da8d418b7fc6f7a5ad99b41674de19bee8dac5452b4add3e841176c94e5dbdf92c790d32f18abe662eff92c70af32abf20e0fa54bce5752fa94fde9233622b641c9c959d0f7d2d4a6d169d2c08e316bda9092e049bfcd1f4cbcc3332711dc74f5bea7192c7675ce5d31f321462f29c4bfbed5a377844c46b85e52e08603935b3854bd40d69df7bc96539c3c63414474536c711a328f11072b35a6a5c47fd8a825157c7392ccbf9192be6b165d8852aa4981af83434789c5d18e671f85ef97f12445f999198c7305c2bff9fb0e7f75d5f69b13bec14399166c6c157a89f46287595213dd6d2387df36a012cf1b2009e9dc49538484c5c65bbeede2dd54b4c482da9ac879c793cf20b450321b4a0996db05e929fb1da580f165199ef6b0045ea9fc9dbd73f18c890945fae08ff776640af7dad0f6f216fdbc67c6d70ba0989e24976973e1a56a8ca4f115be0e52f4d82c6205cf7ae0d38ccf70300dedbf3b7643ee3304d7f9c3edc980fdc48c6588a876ed2453e16477c554e9bb5dbab6405ca7ecd0e2ebfca1b90b89ea1bf019715d481135101d25f0ba02f11f1fd5a4e96f614737acfb829d7007c464a0d2a909219a121e1b91484f952a3602ea04f4cee43d65bb3ab7094181f751dcef8d7310d564435468c5d045de3312e878d9d961e1b519ed55554cf787cf74c630bf4ee1f65fd4e58f5567b25c0d44049a6697c8be86490421ab9af8ac54e892485ca9e378a8caf09a1a1cb371189644219643f895525ee6f935dd90cab3ef0189a55d746e7762cdda521b6abf2ae0a96b8c75babc6d37a74eeeccc11f957c8e678d81ceb95689534fb2440ef0d8ccd06221d3bd40955812496c30720487205e6faa69bd86b2b8d2ca9fa1a6e7a3d141525699df6b3c30a0f30f5649755fc511b44f24d43ffe236318ea0af2a3117b84cab0d70f00f4f20f4f46496bfcb7e31ba0aa7791d0148afdfcd7cc6a5b97732e71878778389f329d076827058c1ffbdd20e7282933c2dde3b8bb966dbc626a2c3c4f9bad1a5c36449414a3f466d603accd64d089d6743a4714ee2bf85fdfbcf8ffca6ad4272be11ac5969b4ddc27fa9038f1c5e5af7f8cfef4fc08fda3b7fecb0802ce1e804f767e94cebc9ed29619cd608477d1a3a8008ba2d6c1db71c593eab4fc9ec432ab6e906d650f630289b3c4628b3781bace2327b1a1c9fbdc8b345ddeb80b2f94ee3edd0362f8a1e29c406dbd663396c718bd7929d873ca7ac3b03c7d3cb76bfcaf1084bd3084a7c8e321e8d4c5e00ba5267fde528e628aeba99b85e4f10776cb78db2ff4523749457423a1412e21e090e3f0859d0b72e5220b35c6b8940dfce3104b6b20f1703b7fc9c4f61dc89c7ff979de9e9cf65c3b19402f8cf12ac181ba21e3357c526eb3bf335e4af4b1949236946d8750432eb71a89bc32f0900528767c38905f75313815dc714b1e73e95e40f58f065d5f8774a7e2ce61838a1474eea95ab22b61277c3f83e12bcc4bce69d7a8233f27bc42ee3b9ff1d2c764db5c9c3937a3ad5b33a2ff71f387cb6a0f4a297d0bf10bc639c6457a53cad2d5e7d6c414788e9b97101e1144a85a5e396d20c92e0ff5b6b86842ac36d6121ee5e28ba44e2077f3b1aff697535d88b66c73e6247e6e3bd970712f90202d5832fa301d3e36f9623a5ff6f0144853785f9c4b6c196997effddf25c39284e40efcb790b37d5e8def24b77a278c14a74a852a71b5ac93a93a929752f8ab94ced6e853c9089fc4948988642176994a3ffa311cc8a275f4c962ba267aa94d0b83c3038b4dbeba7c5fc2d4b72407d716bf5454c9e9ef73c84d8016d0356331ba0de7cabe407cd9e17c43db7f417f820a3abf177f4e32f5bf41a25110d44a5b6a7dc17348209a9d0b4ebebb3b14fcc30287ecc034e6934b5834809fba1fdcc17ef3499b5fddf32c1ae90a10cd8fc503eb2715f701e68a9ac1b62d567438c584d57e754043cbe8d67d58633a650a5adfec410aa68e1c880fd708a1d26aa964d7551a7608228b4e0e5fa47b3bfd8a402d20f721041f0e687fb7f251832789cbb2b83715ebabd0e3e2a8008ca7be3ac3d73bb28b89f25219edd0c0422f879cfdf21d6214bc4a3fc47b65747bbdd840f2449854d722714d3a7eb72dbdbcc0e813cc94540152a8648edcbb0df4f6971bb40829267cf4b099e0e297cac1f42afcb846361dc72f628e59f276dc26023b13a0e99864fa135e3f22373939044bd5009f5f879cda6c837517afc053e477e4e40265fd85934f1cf109d928eed5f84f35c96a4e965a3440a8dbdd2bd53d1121a1cbbacfe03fd9f8331261ed0bafaada38fd5ead9bfea0e761dc9b067013608985b21a20d715a059a5d1e32c07a035287e815591a65d3dfb022cfac44a9073f0cf974e247facf6abf21267c807a1033c9b5d86473df25dd64b5ba861b78f0d6475ef5b80e9abea2d095f66d6dc162b2a25a797b69f9c7101a08741a2b5cfc725bbb798c52e3dd207ae289698e8eaaae557bbea38e83fe91f86fb0238d3948ad37ad7fa7bbcad725fb88981d82e950c750cbdbf87ce0ee48e92291b1080f49a225c4f1625a1032366497e5f8ea9f09aa9a80dd1a48100e03e55533720562e5c2220d6853bafda2b36946b9e6e82357d13b2095314c897075fee0e35df43c02eeb9715571c89c2474718cbf14bebf68f16d45632ebed684b3b9c88a9cd5f99900a03d4480a1456b070794b37f1de4625d858b48a4ae49257d31a8de4d97dc95dc7e36e0563294ac323eb209091300b50e093eaa17de6ef3e662259b60de8516f22b5864f2377cb742844187d491ac88ea73c1778e25945c50ec0e38c2621ea9f6445284750a1f5822e17dce14f396eb64d586ee614297d0acc40d75123c3d00ae25fe97cc5d04ed76ad0b56bde87e3430c38bca5a4704f902bf53e5ecb779a15b6d32b22a3c343c20530c850d305dfbacba79668e22152048f6a26670d86c2c869476d5d8032270fd5cdb39e0a5c48d3574b574fbd6c0b9a0715ffdc152139249a34a946fbb958012c339348e60e2ba54d2ad5872215da3fb9790d45ce632c7588ffd3236d0ae7e12fb212f1833e5742f0560fa7b7df03515c683552a06437c35056f267f5d637c38053f38bab707517ac114fb9ed92ed79bc3fa0a54183c7a522cbe895a9b3d612a2a01d95a3f0d9398ca1c9cd12394c3809722d11782bfaaf9015a2d4bfce606bf4d7275ed1fdb1dd92312b3ef9f6a335b84c38c3d13eb73f68ddff3c9ef264f075f00f05d26be6f89756e84bdccdd437c8b9d36e825be60db042e9e4b64c81b60a13b3e1e3e291ef5b8e641057d96ea8d4fcc63bcee0400d435081fbd32dd17200defe99a2d435d2537c41076374e493b60690d1098caa8b3da3225fc71737496b2316704e3a94b796c42a2decfd7ef53a4cafffddb3f09998b395a442d01357acbdf886f2d05827c5b7c48630fc5473ecfa51e556c1e03459b2810788f16529f8e1ca17116762d3cdfdc4cb48daacc4962b2c7965fecca6f92566ada0ffb2b7c52d340d3277021947a11d2b7b731f2cde3cf50eeb632736377660c8a7327f60ce13e1c2b9e28db210e450b110dbd96f627c798fd32932bb23a74fb9cdb79443717d78186b3d21589cb0a4a04fcf0fda63af030b35d8d1a3e925c273a59d138ba38a12ae0543d95b6122b3747d013ec6c6c968fd1248177efc23002c9be9330b8f8a11e58525358ebb341798a1fe17af3ccaf290383ad3e103601987282f1c7907de41d007ce4ca8c108f60c48931fd9700a80281f5d8af0a56d2e48c4c1bf192c8f35801875bfd2c44c513e9a2055cf6c4a0a66b35391bf0fce3e73277a27c758babf774a19e3cfc187f8e867beb74436277a76d822355622c4f48fcd1066b7906706bea853fdf53c2762a87ff2ae03117c98f526227fe1a9db128a47b970dd2002f003803eeb060586146cb4eb205a89d6710d7f88fde11270d56e9080186118d9ef1274dd17129937329a271c71f9314f205713eefd7af9413c3c8523ba0d0d1820afc99f66da0bc4300a51e1d29c7369a417f6c29976e0b892e1bf6341614aebef05fa51f51e7429089fdd6a40ce177659d01c36a26f0ece0e04c8e59439ffde705999b3a30ae91cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
