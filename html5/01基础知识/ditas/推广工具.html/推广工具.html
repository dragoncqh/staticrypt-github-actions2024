<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b966bf48aeff05fb908fb2913b41cb9413a4e64a645d4681f799ec46d34fd1c46fb9e8c2d1ccc9af22c006cbafb574a74ddfd68d506dcd21d5c12c1efc4894d0c3b65799f2f30b3d23d5f12c4de67bd343c1801e78e9b3aa50b3a56eb33e22c90726693cbe5602437b6a99b476671fe167661be724da806520f35f04187d2195cbb24aa3b54bc0703b1ce49c054fa00168f11bfe936d442f92840cec3d88b269cd43c0a9100b4f42f97401afe0ab5325dec60429d1be1c674e0de2ce9c59f4a0ea18671c054b1306b0c128381cda78fc63754549ba23f8d43a7767a7a275cc9af13d79ba435b1dfca43ac37a3e3684b00ceeb3abef0e162bcb6ea6ac7068f09f87d38696f084d34afdc39c5ec9f4331602f2e4fb18c266b419a57ac0a40557b3d8b721f8dd53e2392895ed318af7df98caaa40cb1d8855cd3ba76b7b643a5181a54018c41e68179b6bb3ad43588eed130ec675abab1350aee1b87da1599b54bd4206e0771273ab09271fa73a26d64b23dff4a3d4e2ab5ac05c095d5473f0b549a8fb62a109a4166406670fde44105d137e0625f2023f172b66cc3a960583bafea4d5829bde102405df0fc9727aa719b267f9496123da54b856a0fc3122771cf4bda9d8cb314677d7a0f2f727af90f7e38ed172b617c78d57b9228f17d38e07c8f41fb41448bf929140a1fcb2dfab73ec2e9244bca3557ec7ce522779f70f8d2933558a92f9195bc1b3de108ed04312d9a97ef6f4b1fb09db1ef9357bfe5b6bc1d662f8e16118c0ebc6349eeb56fb732765c0a991989099214e81ab8fed674e2e166e0f7d41e4c64f5b2f239cc859bb3259cf4451e7d49d03b0213d4104ed3ac2ec3a18090a2f43d71a6723c165f297f4f12eebf6ef9b9c8682268b905a400d7067e27ea30643766b42577b4b69b1eb1161323f0e6b2cfb47a2d4d4020c24a4261d239ff96c61d08849ec7209c0c328577c6a76ce0e038aa8450eb2429d98b0969ae3c20a461c7854b9c3da0e6a8e3c3736a488479c163138ba6d3adb822cd950166f68c70a22ea139ad7282fa1f23b7a6c07b0bcc74ebac53381d1450a26ab35d69670b1b353b2c52eb7a03186410fa840d2b9ff5d48eb158a097cd21bfe9366684dc393828e2a0f5410804075133e64309cfde08f2424c44cd8eedab30f58b7babd9b3d1705f7bf9de2057b0b62bace0b35ab808722419e2fbbfc2171c3a5bf99bf3e1c22b9a6198a8b2b5109179be85ac77fe1babd77ae161e7df47584a933acd57beb1f09c5e730a61c74b03785bf92528a2ef67960af8dca4874891f6a40368ec013bc2ad50061206f30aa04fbcb218a9b60f79f6ae88050e8265dba9d0696774485ceeddb52e430eeca8d3af74c46b48ae63c634692ffa6de662a49ea3e59c1231314ad3dd3d30e341accd85b4f0df887e18f037aeafe551b06c4e1416d9182522dbb6a42de48d2da72e0c4a3f3b58c060b784523cdfdabe3eab1316c49fc1f48f8c033214bcb9007fbc1000c0683800859da25e77f6cbfdaa4b1f2e807d749da3db4db0a0fb5ff6b3150b8fff24fc32169f566feb950a96a20bf995a7386cf5fd823e8089fa64314a47642578e296ffd09bda2040a60a210279a85faab76db5c20e7cdb418985a6827f329597bf45685a4f88f5282db90e668253546b286218644de8f7c0ed4ed1041989b8da11d657afd21a87e2b5fb9ea5ccf03fad3ebe1d6b86880abe5c287b92e4ae82647a51775437f7ce912f92c967a9a27aa384e5d258c1ffdcf690ed545aed2289b03e2532e701feba2d48f2ee3da225780d09c1fbd5fafa233d0f9a9aec0c8eca21c0dc9fece374e33bcb05f573197b8062d4dcd751046f0b9438cad5b2730f144bc42927ec873c9c3d99d8d09ede5221eddf166788279ab3c737ca7591017d8608c53544fb20d338143e0401d60346bc269e7a862b307fa1397af5c7b5d1c65e25cd167927fdab3ef458d6d1cffe5db256d234f43a02f5d8aae1eadddb08518cd9d7fb67fb382b1de6a3ef180d654fa0df7b41584a1c2a68d3e296300961cc243b569e54080dfd869f4ad8aeb7ef36b407f0d395ea7d1d74f9b4536bffcfa9e9a3880b4f61c9dc6e6caccc268f8e59d77b5bf20615041e5c455ab903d9a2c23e49e953b000f69ddb6affa1b161d8fa74da87740f9ff3fed36f33364ea71e03978de1f72c8bb79a02313fd6ca22d6ac8b3a5daa8d71a7335addf2864173df85e1dc3ad5f07dccde395308aef35a9a14f3123aa117fc40ee48cc6a70a23c945cc48bbe112e38e713ab26ad3eb9d630a7d2abf05a66ccebf2e6521ddd38a644411121b1dafdde54b527f7f9d707fadb1944ac7aa1e61551b5a7d1db410e581aba4c377c1405cc3ea383971461dab37e6ea8517dcb181885a40f996808bf1c5799c6c2f868246f1b3782fc457e13e8070edf78a62c9cd7344447012275eb50d49e9487dcb6445d4d4874b8301d8fa772d1e2f7cce001bf2eb9e8aa3cdcc32b0910ddb052b2de2c1528f67e0de377a1fff62f38267fab64da49c17ff671b6db0616cb8209121a6844cae90d488871342b5e2b60156a0c36ceb53f9f2ac8ea6eb76042947ef70b58c84856bcf46c86e3fb43e75101fdb83624c1ecf70dc88fe529c8d761dbbdfc5abdbebf85a5d3c5417b849e2a30d9b98e5e6ac42da1c7ad340ee1d9e8f4443e80571ea475cd6549c1b5f5f4a684f1dd3816fb4d962e7362284b230bfae32e1a34b9dd061e75f1e3d59c3eb2fd1a4defb7b2402f57aac2c9e006045ab638b988379d74cbc2b37e17eb84be9616f2af993336bab671835a9fbb15d5005910fcdcd2cbede335cf2e4cfcb966f1156dff39ae6cd9f5be7514608f5722da6f341f212273c730fc1dc6f37ccc32663d5e4b45376e32e41e96777b4b8e9865ed2c83aee9aca5bb99ae4681d0efb16f0fcd59a6e24baf76f9c5039ff9ad090fc59298496654e9772df27a7a021e8a99bd6458396121f11f3a1dc29e228686a9d075aaed595e0b7357d9a5ba5734bd2a65af24e6d82c4c897152f29e19531cb161cf09d2f72a2847d9bb3dae424b9af3808cad85353ed9f5d6dda0929fa65b2b6228bfcb1c8f7055e116575843c8da36114a490c77046284a0e37dc78fc2720dbba610f6b970a10ede30c90500ac6bd2e99e01b7de72829d8e12269678c1ef745a77698e80cf72d434ce5c6a39901a70826c87f5f88c438814dc59f882aed302d5206c7e892576a341a1cfe2583ab3b9a174e12b1352e7bda8adc09a027bf6d182820630611bd6dc756597b0f60c2a3d97674bd99769a4b4dacac9d417ab6bc321e46c8846a43fabfb18abad93a1fcdd305f846d9587ccf3b50ad1d52d76d2dc9b8afc3d2b060b514f5025dafde835a4597cc436f554f34b57a98a412bf837ce37f24e932d6afebce43f9c2539df58e28428b0b813046f435f5032d5fba9ded1ae13a4ff06eb10d4996541d4e290bbff2a664d73066dfbd5c717245620f18403f529de010c17a63155d6a1942397d9c5ff6e05b258088ec4fe0cf741b3890bb4139a714b52d00ed54e1076b0a3f524fdf023ee4eeaa0258e645a0a2dc2c342a7cc049e5ef0defb98838a4d89e614482dce938a5ff97be48c75ed834b45e290eb3a348fa879d025ae2d67c6a8c876609664619f1b971a4021938f16290b75c4d6bc079129d95446e2469dc5fc14653ff44f4e8853f1fc02a432ffdccf10df8e9c2dbb51f0baa400e258e9d65cc40c00eae3f0491d0a39cb121f1aebcbe1574ff0acb56d9d8432a2ae8354e3d8be98cee114efb2e851353bb39cec9d500e0cd626697aa015a52afe42fcde29d21d1a87384fc5330731601599d409a0c05ec78b9e8db5024aea2f65e6845ea9b72e8cdb3199f8c8d64dae19e09c466f688db88a1d4fc61d953fb7eeca14d0e34c09373154c7dc4bfd0832f332b069424251c70e8b71a55a2f605d4a74a9a222e03728cc0194072004dfe0ce5e775492b9e04f73f5a21346acc905479e1f543860f257f70652287359c183eb3720846d07596da212e6a9bdb49dd1a021f164d2ef8c9a2b0d3a7c6bfacbe3031d0af728cb924e87ca28bb70530e4bbcb862d4b61736ffaa2ed22c9c2212ca654bc33a5172fdacac56768150464d9689dfe6ac87ab08d6941aa99e5706ea4cdc460f3f720a4fa401db96037a619f9bc83885ee660784d6559c80d688401b1c862e98457ae9fbf2df82ed77aed491f04b832405c3312b04f76e423245b82c8139f5d03f93770448be7058dd8f540a097a7e38cdd4ffd257c93c9e73e5ad4024ce2f9f4caebe6aabb84703df8d0374e9c0fee59712bfd886bfdda6d463420e78a092e81428c01ba7073d02280f354f7476c7a4ae14f6052ad08d9a166c47086faa8dc5aef3dbb38d29ad99097ab561817d91661c1917f877b86cd9e2f1d5ea9c9708af8a597007f91d952e88c0d48e274dd821ffd7063827b7f49b21af0323a41fa81f934768cda9a44ab0971f20991243ea486fe298a769a437363c48b5a5ba274a16321fb93bb8d57601157a99207d992425ee461fa30bb2e4a667f8fb9681e2682d30f5f46b2441c0190bca213ca3347894d2d19f854e8f299980b04ec7becfe4a06a23e0367926ba6f6ca6b4092ddea7045c9c940df8172710c235ccf06e70eb69b9ec95f61219d9f4bc658557bbac6987f1eb41542f991d6800724584d11e25b7c323deb064438d8214262ac98f39cfb1aa2b8dbbb536447253b17ab279227556c70d4ba10e47f3c582042b55b1ba5b5b13e8cda4d1cd50d6b847700b4e84814399af461b1b240261686d8391bfbd165c8bd1a2e9e13acda6ddfef2caa25ccaff21eb2e66ee0bf236a9bfc7ba96f2f283e0d42596e605a931e06dd24431755afa2a3301008d2fec8ff5add40601661d8f12b212cbba2785742c3fb06034a44415f24e55eb2d83ce3141b32d0783e684967ca1d2b44258c04208acf69e127ba24bad2addbea5bc84ec7aed1044e934e945afdb70e399c7ac4549fde89effbf70e10135d7d0ca26407c6f048a13e08e3ac7a56f4848d77fd6bd54fb23ccc71dfde8db5b2311d8c35e383706cabd1f4c55bf1c9f08d95532dd2f719e0d5fdc0ed994ac4063a0482856baea9b6d63848e5faa0c535ecab14d4fa05dd8a570c8bbf00e121b58b0971466db834a58c243f0eb5bd4fafa030d6aea1337ec4fda19fedf16e9f8b93a5c701d45c1e5dd150420e17b1db60a82c179d570e8a5b263fca894c3e3ab0c47114007c8fa9ba3fe2f9b5916efd4cc42888090aa8f6f7d4ee3426952b73ae446cfec38e3f1be7b6572ca2e08bb310bde8f9706935e2427b14205eb42bfd71975a3d0f41887566bd2f917e6990c0c0d9f397492c90552d1cc404d14096f8ce82a6fbf90ba2e021a78df692a6b7ebe6c45bd1a151de2ecc22ec7a209dac78358a154769f1dd57905a2c9c093b464edb890f1822894dad30bde3bb81fe2fc5778cbd2cd81def84a4e31bc3f604e4563645e6407c70e10ece5d1a54afacec2063038efe173ffb2e116b7bab8a92139f8e7dabcd1d82cddb0dc6f340e651289a744b03eaab3f7f6c37134be011c0fbbd46fe1bb14a51a41e40e625971e93cc44323a5990c99edeb17a765923f5260159169f7384f3203228ec2694efc96c9739ea4a0cd2dbabb7ce0d1cb5c9762844d40b13f1e58f5cdfd6a88e7ca7031dc8febf31bb7be20d9a612b57f534e4ad7d5c7486d8797e40997fd9ed340c7993d6928b978fe70f945b42256a2292cb00559ee5c61fa0108f148c1ebec80d792ed8ea06afd2f62e94722d08121fc20df2f36cc6e7fcffed9f40253b2e721f53f4b43c903b800e11000806768d6d4d09504774a86d947b069fa64e37784715ed6610c35e7fef3908b8dee2596eacb2e7b29b4c6a75030677d4f162ea62636e1490d38e335401f83626467a04f8f28c0e9899426a998b71b5fc3fe1dcebbcc3883dda9a8b4f2bb2561f980d6ad86622a1a5e80a96b78ecb2843220fa4dd165132989fda7261c9f5f1bb674f845511ff30a73e1c73fbd01fe9ed67047b5cf0240b58726a43478ab30264f986c7c14e626b119d0677518deb6d8162a80a057e10a0fd0f6a3ddfaed04789dcb06d6cf47f7dd5bbb2b9dad47cd1eb799d8d023e740fee1bb87b3c94e554d6436a78b563050792758a6bd683081fbf17cff76b790881f58c68b31f97f721f6313a5dd8622f58a37a543111b5ab7f9a08e8d10b4f610c550dce2ee165a1e7c291f3d564dc438525e9997aa50124d20000196106d0e4a6966c31488e71be8f78f4b416dc2fa3454c57ff021b9c7925d4abfe989c7f4005548b2a5bb17d3d36d048c9ac50ac535add57b911781001a2aecb3ffbf871b2f8285d00131fc5c24438a0bd33b80426dd305ac6dbf46f36aaa0f59cca8f87070877be8c6de0b498a589477b4466ee1564cd774a9b3a98105cefeccd2f6dad8015ec00f50d44e8f314de195383e38cf521c5c8d249abde65c418000cba008db96e185bb3f0f25cd8ef56a4cb194713a45c9c76ea506c3a4ada916864ad3222e499367be3944d18b6a0e6774321fb1e594405db1802a948ddbec0e7097269956a358f5e18cdf78f618d90fe3849f8b7e9fd39cc1d074106e1700fd34c1a9da928111d8fd426501bb3fb81d7a111491d5fe5933362f70c67a9b05bc238adc03705cabfa245e2dcb00feae1d1b34f2a9bf000d175f809fe24a400a15ce22da1766d9c7a3b9f8dfe2d23d75d8786f41ed8eb029b245b36d0c57526dfeafbb799399257c050336371ba40b838305b86ff05583936f9b1c4ddc0e978a4dc194243ed8ab1d43c2b2781b629a1c5d2a7d48757156c5fef2c02f49b9ed59848f5e839ee4758f58246c1721bfdf9cf4b7cc11bd305a78b9ccf01c81db8f564fe4096a811e0347b5cec08bcd4a6fd5a325ea38fce4dd1e4a9b59e58973cbc7dd011b7e5ca3922d6bbc80a742ac7baf4daa37f7b9199e7b7597387487a41f75c0b0d89238ca38ca9381c1f8799ed2b8681dd7db6e701cb1bafe4b53a04b90d36aae639347435568b55202a075a3b3b9e2c46893e85a1f476e38984769bc4be8055826885ae9b2e645103694e6cc54992a16c2ede0892e65dd254c62043a54005eb30553ab2937f036e76d33257a6e483c808de239d888af373638b65dd839624144a89453a87cd4e956a901a35e4e98a5eb88a4c45f3f2f789b9c03abee968d4ffac79cb4b61fb92817f95a81e8abfe6b631d48f84aacac796fb2a578c857b088cd92553cd2021669e121d90584e86004bfc5db55e459a4469a2a7ba96b3dcd2f6e110e3511c76cf56923344b0402907e760c277c939badf7c344c754aa562db8e78aa0dc9df40530cf8a6c0912d0e47a8baf6d456fcf0ad5c0760076556b5562f5005512c214770015cb863758e7c3212b96262236e3e70b2bbed5035ce72ad66d5ca554d0bec179ffc300b30b9632ff12a872b3ebf1af223d52e298d295ae5a8cd8a7ebb3ada5279046494f7e380a2dd19a96bbc95f22a384e8c193de6d304d6a2761eb37ab4ae1da896d58b566beb797f7d919ac3536a19c674334f69905d1caf1644af0cdc11048db99fa851b571ab512b01d74bfac570f6426cfc0eab49207301b6dcacc7f576da5dca8edea38e8dd662ced7d56da36524d653a1303941a777947d178131aa316bcf1d4df3a85cbada703266ddae8d2f67996b0b86559c7830a11834dc3222fd764202b1674a70eac557cbf6ee31074072aa10385cb487c598fd687e03ec54944b9c4ae76a65568e462acb0e70c3c0b2113a70c578be7bf7ebaa36deefdae52ceb51f8268d6c50e25454a1be34993c1c994d0489477624803cccc98af2be2fa14c7dd74d49c56e54fa373dffead3ebfc029d3ab4bd08cdd28a96a044f91dd3006e88ffeb82588d50c10ef47bb7a7f5aadf0f56eb171e3256d6bbd0357e2d4b96ef2c55b04a7c051d7ae37d0910809a65d0e0d8cc239a6a205e4048918c22ea86f198cff53bb03b45feeb263b61ad202bef109106add1decb892e9b991fc23f2012c310b67218af824c0c144ef1992b1c7731b53940d7a492209e202e6d95d489373ea75c7fb89831855c1961abc12a22214dfbe882f61f054874e400904b83e921ed09bfceae693d567947fc68ad3c01c9955e035e600b0cd39a935297f592c86679691e8dc5349870a2d18874f2e7e22062523b97296e928d2102d52fd27c9dd1d58a42ac81834badfa50387140cd37c10eae7506cb88c5c926f74675841be111a9b0834036e76f8a084df030175266f2b2170885ce36013336591806c8119da4c9fff08a18db2d9da50b0ef9f155c7b48178221d209d5eefa78ff6d681363ae4b55f9f848d335c3b9666a6df1c9d71cafdd498c5bfb8e8df481a2cb19602d13439cd7b6b3064aeb6075b4b2c21ec8bafe429a6f2c337500ef352ab6eeada64052ed22c4daa0e361e57ed36fc0875962d7f97a766a9b36ebddf525c7297fd864c053c20f256872726e99f58349ed0863b025bdba9f887a8c80dd665a8b7fb696a6f3abb7e09037657ba69670373e9d1907f310de2037c12c34cbe23794d20ec1b279db059b6248b06fb0a52b16ec5374d5b814384d9ed64775748f2bd8c0cba91bdac6a744833bcfb7f496fce5b13aadda111d790c6197af70a72e2455f474326708f91f53fa2730968813b443c82e43f4a0eaf1af6fafee6909533a2a33abe87d053a49e372ad0467fb00e74a705c66f791d7eacddd494ebb5d1cb11c1c09cbccc27edacd2a7373bd36f99156640b5b4f7aa4fa5804338c0f2c91970ef5ab74130cd4fecebe193499251882d900dede07d78602c82332080f60905ca95c096a724ab6900675a3205084423e484ef5067c0d726795c1956bcd5c85d897a4939724c314dfa9d5072af333cdf4e8674d51e7fb1b27f44439017a8fb2df89ba6eedffcf9e58c912b6016fb0064b457a88868aa647f03d449869247b7690bd6f5f010d5c13fa9037c42ba0ac27bf37f1d91cc54fc29c7b493a48a0e2545cfc86ac80288dbb343fd07f8b07dffa5b15bf403965c6e506095acf9c1f01a66c2bc534c97967467add87ec0535fe9ac861e3319870750b749c24b3fd1d74925525a54a59b1290378a664b3f47bb6a0556e82bde4139e99584c5adc440e351035ee48a08ed5d1060c386e6ffbad72c3d5d64c5b429c24a13981c473aa08d3d59712f34120dfaedc8348776cfce72e2c25b06e15ccb249b904d8450083e9ccdbbf7466218f0c33f29e173acc091015337f827e9fe67450c1deaa68ee48721b0589c8e1e34731a68f3d2cb7e20120bddcb049bfa1e0786a6c54d9cb99417a6123cae99228dedf22acdff1ea5f461ded67add784b91d3fa7fab297b9e31b574c357ca963a4e9a789c5c656d0178eac6054691c100945a5ab5d8ad12aa37b4319e21beea17631c04e3da53c1fde130b176c501618b4c974b3e3e081d63174c99260873841237826f6b3aeea146925707aaa98f58e90b2d1dcbcec0ebf5bf5456f63c9e590d167e71993ef503c02b028b457bb76b380d763a8df92f24c2a0e414137cd1c5971bf8e9651f839ae3427d790c7c6a1a4edbb57abb0f93b930d85612c6504adb9d92c642eecb6eb75d46e2840d1f5835ee3953e1d50e7881fde6b5355e353f2383e1f376ceac1508a69142a1920fac9a273bb1c693bb017a67d7248237b50264fa7fb824841fb3c13023f8248d27babd0d379b0eaaaba78e07bdca9587b1610405d028e143ea09786eedeb3f050072918b3ec194ad7d608aa6b0dd8c651986cbb22fe525ddba20425bce2473f325e4299307df1e2569258f220914102b10b0ab7fe39df48e59629461f5bb5857c1419b0b0b204efd5e4c1c989bd4242b9e2fec734562798e158c587923bf6274f8556f49fce44ca319ebd7d618e265a63eae33addc76c3468ba18f0d13e9043042b693168a7c38ee2ee05618fc721f24d7f6481005d973ea113ac991d2d7feee58f3e29c8ff82120f2edc88549a2606bbdcba6d738a7ca9125e6df992531c0a85e6419ef08adac743abf5b708a22c39017926f87e445212d0c423ab315cc02e87af2a6e1dc3e66f73b887c56b51503175d5f74a2baf82a52cd53dcd23b2dc0db71780d26567d084325838e4fe431ad12cbacdd314fe9fa0ab56706345dc6370701739a4d527dee57274a9a9c920754e700068bd580bc188a4b79fca1f730c682bb1e72050f374680fb6927bf20fb539a8d340fbb0c5dd8834d0867f0e912105219b3f7aa53bfc7353f5f1c8a8a199c68dbf66cc032d5dfddb6178b157d3ef34821bc43434e159f301c1048911902b707bccec5e6ed9dbbe9280b5a67014a85d8e156b82b799ed0fad94520277a7a73fe277a89329e8c3a9d906be63d0c2b38b22800974142a508a0368b843c843e3c08343c6334af75600b434e173d9c253d57501deea5f98bf8b8fe717b5f7b159165b8d7abf69911a8e54cea1791abe150445d9f437f288aa78e24281a044209055892ed44b294a03e5969e4cf1c6d9cdd9626766834f1aab34b3cbaa24bb2c4289fcfb36bc7ba7fe197a7cdfa4188cd87e432582a475be4d2a26e61a6e4324d97762d06a8780b6ecbab0a3ddd70ebeb289c5c2285291c5e88d8e845692584c0458e2b78f77d82e90ab944306761c4dd0c9c2ad6dc893a7656ec7551d00bb56c2c9d6efb91dd00f830419c77e8465b4dd87c8879d937133bedf7a491042f24a4516cbce43053395345a5b495d8b832ca291a6b5d407a36e5f0dcf62315f04e86d212675c8d9f1d23dea5290d4017dd0bcba7ae82819031e1c175b7d666747ec17a613d95df7a3b386375696c36d52ec749293b5134abb0971d027520018ee7abf94060c421e3e958867f3f1b6d1a3cc7f06ddbf23c883d68dc7b896f93dc5f02592945c470bdd887a2b3f3b30dfb97582942c22666a5707df4598d2e65b637f91ea63db3e30935dd84df98cf3cadba2abdbfecff5e10e8768e9ea3bd5ee1fe68243625bd96937f72fc3d7b82f656441552b606f77ba61219769f58fd046b457c3ffb66d1f17843f3d400d5600ae405372889a3e84307ab7efd089227a5350ad45dc163e9ba9e6de8aa915bdbf7e86c07a51982b3da5e5aaaf01db32ad1cbebc4a5a75a094c498540d1184ecde057ac33b805bd465ea49b9284cd723c42a5aa04b4f3804a812028c43e16392a62463bc9a902c07f9ccef2b446515063b97507df0984b9e745e8d9708a0c5c55c6e4549d6c0443a77a4b68cf25b5c4c1a8f2c568838c985d5acc919d158302fdbaf4daaa295170f610d492d66cd5e47fb40652699d21c99c1303818dcce80bf652a6623656eb6ab731351731bea837f28dd7887b892fd7910663e1dded1fca9b4eddc7717e1a7122ba119c19ca877a5feae2f8fe76a95f76c9462a9f8bb187d4fc67a7736c3be2d5312a13b734ff302aff1e7bf2b471b466a5fe53960fafde78ea54143d7f0e356de8e48f5a50565421826315a8df3445f94967a76bac910634bf5a3fc54adeaa0287fb11cf24a4c1679c8ee584039c485f3f4461bd88f332bcdd6fdfab088426652ddd7a0cd8c0252cb13b9d439e47d6cb4a5d8d870b05f502913c43bf478e480432bd6804e21ff055c01cd0671efce6a3d8d555be2c7bb7c16aae5c8c7adec3e4dbf8c580ae40b5634826bf8868f151b696d42a2801afb9c662711c247430f79cf543a541350b3f3f99679ac26200d504403f96dac44bacf9507a7b99cca8953551ca494edf1f69b65639b80a01d5742d66380e1cecc019ffc69d9f9d721a96d21678ed2610ee39296c140d5487fec3c49781e7473ee0954ebc7ca2696ff77bdf9803a88dd2f9238e522117469c0f8c45308ab318485a1e8114bd0f07d1dce490cc9145079e3f98bf9f2050cd08b746452882d3af7b993a91cae8e14439af65d836dbe76156f67675f63a4f32054c0cab827be79b410123a81bc60e84fda8409eeb7e50a56f7e3236a20654ce3871369ec33dc6b1917733d3e2157271ede33de10decc701b5e26ba896095f5afa2d344ea17a56cdc98ed11630eece91256a0d86e021e319bec2bff9cad01c89d8b5ae3a7effac2bcf30858f45756ee8bc7584e84c34d6fe6e2c7c32151bafd91cb196dc0551b4431917b81ff9ee6d7ab1ace410473f4b2c55fe43a9c938c8a5b879a77a8aa67c0b0013c1b31ff5f168ad36713ea05b99352fca83395ff54d0a5d8f9582e0f30b1d540e9c70ce0f3314eb4dfad700654aad77bb44f64abba7cb29fec6ac3fa7ed6ee1e292848bf8f94f4f603e42368086b4c10b4d61c33139309240f975116b103b43ee7bca17bcaf5412e0bb4be9f1ebdc82c442ffd60fe5d47919c64a098a0602d403e0d15f615d85f0b196cbc2e3062cd249376aa1b81ed853ba949144de5fa362ba484f9c576074dbfa029f43df33952826a844315504b13b77b0c75bd6ebf8e4e504e53648afecb0140c2cfd4a63055d5e98241c94f304160dd6e7f46d38654c8092deaa4c639c39b49df2c76e488da5e90fe0238ea48428914ae84b1238fa2ae18b2d12d3d6b399e1464d653be4a494b73a5dcd72d99fa097a1b24b97e966b26dc946fe862c5f5a08db65e37c50f2be91a5d4d9712f5119b635cc3aeb637dc486db702a8237756229f39bd9188e1961dc712f7ad6181a0255119fe1e42934eb41442b11e9d8c56ae42026bbbce2368ce6a9c5daa05ff302154cacac74dd9c1a810b5eed0f3fb526d752afca8a1574e75a567cf8f08099f6b739371f3b480610e32d28284426a7cacacf28cf85a6f440f2fa5f253d87acf5736d0f930f91d5d6d4a8fcce50751d70c01e07742754916f61ea960b58fcaf08014668e37c5f1517d0db0e7b28d13a4bc44576c2e5cc3f9d928d5af3b51b8b86821a4017309e244cc9536f4189cee0b5df9e2d99a0f473a5e3f044e2af678a04c8a7a969d541ed1436c8e612cb591fff94229bbaccf8573c1d7a4c14d352f207b89c4dad610cf23a27fd7e132fcf2e00f6ad5634539e84a89996a5aa48f5015a400f2375a82cd2e8c40763a253087e4b7ad624a448ab182a4e4a777c9ad88899d76231f0e8882efbe15e3e12bd2402d738f7411d47456a3dbb0eccf641229572c2e9fac5f9931f690fd93fc33fef71a6af2bd75aa55577148945e176c42808646c27d3abc60a7e7689395ec5ebbc5adf2da7515c351019322e9c2742f89788d8c4d6735862ddc9632557c70b5313758f0a6e961bd71bbf3b33bc1dedaa7b1af2927e0fa9af3d46ebd65b5af5eaf9c3fb4a07f7e8ca8f84c9692ccafdfcb69918fc699be6c982f84734a65179e331d0fae11b407cbb994592f3fb184d8dc135c9a11e508690eb3906294785a561b5cc39cc3901a86d41da313a1acbc296da2bf7438efa074acf93b107fea8ba8b454a7831df461af9b6d4f4aca51461d09ae67f0d6a5d3505b7832496f96cd9f132c8bfa1398cd11d7305c54ba669259a7831340c456d1f0d705a87245dd1ec1219edf12a520092573b37761974e535159d1024910a3069a159723fa724ab94efbaa3fa1540e3576e8bb74055e83061b80fe59dc619171525c2b45c20b940723ec7a7066aab98dcd32e7001ef51d665a91b9567c67af585429677f1f1192bcf75fdc51270b05d73520b43310a094e285baa66bb32a4731589f217ec226d22efd8f55262a5953c54b3a7cf803a47750a369f2b32f027be3cc554a4bde31f29c69d0e595403f7a6219bea196b04b9b02aa04ec6748e86a381cba703e1f8e0c7dd52966008d12f25a6a873ff809568f8d6f355c54273ea31ba449d4a411a43d0897f4361cd0fa0b9863cf6360d30413474d71c8b501944b4b5167b5bca9efaca4b3037bdd2b5272288b3033ad7ab2bdf4d54daf49ff396515e46c67a6a864ddced0a8117a724e4842f40ef61bdf36b607a32c57fb5fd376acefd00c1b7bdd161b058f46e1a336adcb7d04636c7500090e0c422936183752a2aeb87b69f34782ea9074668c04a0d6f4fec58ed8b29ce810d2e756977a90d294e520fa62c64e5ac09406722b44e11ded98337fcb4b9b0350dafe68b390dd28ad7df30960461729eee05d488b1acc99308377d179ab3845b7ed1e62311c54e370052ed4cfe7fc31f95deb6554d9bc7fbc6bdf78977eb476166e79cd6a2621c29f125578a5fab7d7d6bfadba718867de745f38cfa56bfa12be6710ae2033cb961f3e3cf15ebe3f2a792113b3a37cbd8c4c51aeb2c7eafeb118189b8b7c1a56c953381a06931c6420ce94c7ef7c60325c7b118cc2f50edec29132ec765457aba8c7824a4edc3b14ed27003aec514c5631f516a3cf16671209e6c0729f14daa5f7f321a20d503229b5a68be67df2f42a488577654df8340d376f0321c720f11cb2ad4db0ca105f0c893ccbf99d8a6349c841e040d9ba5077ceadfa70d11fe929d0ca68f510601194a81542bc4f13edd98c3c2c0eddd159ccf844335fcf7c05bb16c3fb3d807df407113d3db6151c910bcf60c0721813eb8b881abb49bf60c7bcce9131284d8f1420336d080082dbdd1bdb9c52dcd299e83a2c912dd1ac54085fee508f3451cf62cadd47cbcb254f7e5ab81f6b2b5d6e0d4f16df12ae4d10fc4aedbc2f853f37a5dfc4f14c9c815e88b7d5200a38d60ac269b822965dfdeea69fe214d6ccc60f793edaf2ae3005179079636d6206041dfc55ddcd7a4e3fe47d2b34b3d2d07a4d420b30c1f00812927cf393e104a077b9c7b4e84f2cc5990f72a74dd2523a52c87881e94f17e6390d9be9ddce78f723ac838e584764d73f83aee67ec22c01d2e88b52ccc84898d2fc79bfb8a5bb67727f72957599093d362071ed0fcfb8980d1ea33ad890fed5a62d339576cec3985a6c354c7bdfa65220d441585ac51d7fe3d877a885e27f11080ebdff595d25d62eb5887cef43d3eccc247535c1c7cef8b52921d5de355898128008e2edb6c136116e7e906116ce8a9432d6c34325eb9efbe4a8d68713fdfa4536f943ba7067b99609287cbcaa31f5ab4d82ba92ea793ddfd0830b3498cb943bbb2f351f554a678e43a3be0145c5d3c2f9a86366ed652f53412ac6304ddd604afa0e6bdad07a57594f4a040e45cb418aabd8f6b127a3944b8077d8fa11e33536b257a88be17158fb4455648f648e4b947f5c9300628ea0c0e690e7c81da40ab4a2fd12360d68af1a8270200333fcdada542e4c442a5620bf3b501e41386930a66a1505062b70e11c67bf55b4eea0d5a03590eccb0461668d421275012a34fc74a6c938f26da1132eee1d821724e9ccd2c13cf738ce08113bfaa1cfa6a49135139fa881835919e3592c565d031c636cc29a798e26a4d1bd28e06126f8d6ee666d8a76576df38fa817ee099be9080adcbd96aba23bb656aa8b9e19a7e776533d8d8bc7f21e20ae79efa36810b065796d7adb8ba40ff96e99151207a226d998e083cdd3e4d75411f1f9e7434097eaaae6c6ebe0b2a7374fbdc85b4452baf5aa77f1908966645bbe60b04c4aa1d2218ce68d5b698cc49eebed86f34b0eee855e5332c947bd6f53d9c5fd1a0d5166288b35a8aa6aa362db7ac0e9810ed5065aaac17ab7eee674c9e4aee121c60fb687a22f045b10d989eaac54ee6fe581feebcd32d8f0871f48e7a851c127977807844211d7cac9d5973796c87c8c45de003794b76d1f6769a1a0210ea0d99f8182b77263c35ece5f29bf419da4ed9f04bf7d03818daca84bb527756131a1d7589f4c8b7e5b9f7660ed353b41ae0e03b50cf6c5870a11bdda4e93db54da93fffa273c0802821b9be9f1a72c41531ee4eb5cfd71d2b9088cdc2444cedf113d9b80b867d9b1c95c794c51f0212e9f4577aa792834b52ff216e6722b0f431d4a6d6972793ecc99187118a3ec0c1914c52c8375b9525ef28d6e7cd4e610083d2226dc446cdb9b6b28f5800475530c7b7969d977249efde03c09617d736df4f160164e8a38b7c2b3db0ea6dc8e60db5eafa36c6d175e186db6c5d87d7b20b1fb0e2aecfb5904427eccd0d0a845ebaecc130ad20ba909ca8792a6db819b865e285dcf276474d100ff22c5b0d745ca01ad3eed8631421f918e04fe1c368ca794de6b0cdeed1281a9d8ef8f4cc3cb8e67241c1623121849a570f6c3155b58fe1fde18b6b24e0182b7a3531220f47e410a62a4437957fd5067a5dc4b941aaa56a0306861cb61b2de3948f83da90d59c7b743ea27b908ffb065e950d0441e9892d1751d32669c7e04c109d750d5ecf53191def6b19ddc8a47413277b0259d04ed72f07c4567bd440c636cdaff189c8f7c075997ffa20381a681c387df45d87f4eae66ec5736d364da014cf40e43d6f514663ebded17fdae9578a980b55287df27eccee7504c62211fcd399b58bd54f3246500fb9c8792a520679225527f979eee4a963ebf13c62d53b42e858cca44bd92b0a60d252eadf36092f4f727b9d6a385fc67470789d6e954a15b20ea740e1f22f2f7c4dc4b8825a9595468f0f243519ed6108d05b9a16d4740616d99ffe1eaa707aefd4da4a4c72f1cc20726c3e04abbcd0209ce2912cf9c90e45c95cce37f15615f43b679a5382042af46298d6c0cec0efb2649d410b7e7bd7c8dd50d7fdcd26af8d093bbbf43b1a0530914d5dcefa2e3a3eec4525cdb5418a9fb8fcd740573c84322c69ca2e022c5536e2034801c02c1973d11fd854626ceeb3f0bfa2db23710391cf32d81fcd82a8e8872fd8b2d0f591086e08e8867e4b62c0907612f291c951d279e3762c4ca2b3dafb1c2533be43f661c3e250170dbef9e72ff80646811fa70ed7cbbecf7a98b8d210c2734c89899666d491096a991e3d0df6ea5e99059dbb49b84a3021a4aff0c381cc8d08b44e83c8881486ac0a7d5f1720104025d2f4a9944b6a1d8efae4c405d56d9653bf83b268345f59f0acbb3f42b38b3d4791c7ca3cdf1255b822caf084895c56b66f8248e1bee365c2186a99e48326535f9f7515b5352b190f60c504d1a767bb3c9f2526f9b195c43a63f26571afaa5198a5205e487d8f2236a2a1404aecaf7a037ba718a5d619d5409c80ae3b351224663149a7f3abae85057c12fc552889e11768399425b62221cfb8de74b7a12757b4456ffd4cadb0e352c8390937ffc38d21a8bdbf7d73649334e2a2c8c12d9f801623cab6355e88f0a7de84a003df7e951a7b02231769e75f1001d8d5b4b277503478f92c44f83eb48bdeef6f55943a79c200835f3bcda929eb5a3e59ce4b95a74353dd2d1c8ea5fa1d368a71c0a4a4ba3e5f7c54a23c40a436d805561f017438f2875a65164c2930a267bf817310d8c6b23d81d8df76d3f16c1f4834ec624ed8bc36cc801770d9886b79acd1e0f7a284386b008ee6f9438469fac68122c6e9fe17ff61dec8d738f2ff35325b227c4b01d912754baab1fadeae110a83dfacc59a9a9ab4c4290fb04978716045506e4cb409e948a7e2a6f5b445dbd990c7eda3b8d204dc4c7d96817a1ad9bfad556e68ed0f0a211779e8cd2c1e99d5cf53e47f62e58b47308490166c4c7e0d8aae6f88fa910044417f88cd4d3e2e4f2bbc1c071c9f244c2bd6f5ac7551ea86ef338c14e32f8cc1188cb2703193146df70b2e4fa84787fb7c3960d45c6ee51ba22e9cab33f820c6372beee679544573a365e4b3821b8d70e628fe8a3c2f8916a345e55db15b17da2719e8b81f49d853979da19cb3fa1b3a4672bcb00cb9c9345553f53d74813cee4824356a836d1486480594495cca12ce3b84129ec5b951561a3b0d965109c125ed2050e924a3c4c3fac6ebf7ef5b29cea3c8d47cae5937722e594b4271b3b08d4276da5eeeb1367d79cf14cff387257f80c59df260f604bfc128d8e4381741a8b043e11fc146791f32b56288fea66a68fc657008f1ba8273f860323191c49cbe3507e3fa9a6b9f3e7032bd36c95988b5abf2ec83fbe462741ac0037cfc55d6a2c9e0f1bb06b26e06de88f0a66d8ab6a27bc3f0c5400e2f027b0d8de7760584bac2d578cbb875d3fecb43ea6b01b82e277154415e071c2555d28e2867669e5dc0c5814ac85c13b1fad4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
