<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f69604c757d5ae5d485401632ac96dcf68270ff51d65bb8c5e2930f540aa39f7368a6b2c158a8ebc509e335178f179aca6381a0a810efaaad09b05bb40184aacef8a5e01dc3b4baf0f56703793910e9caaed734badaf9e22118614af04006a8c7543600423c6740b64be5b6ccb4c6e3d500d01e67ce62bd2b0129439385b99c853b557aefa33e0d7539018b97ff5f2f4fd2e3fe5a8464e945a82d2a830560fc88ef4f203b9428fcb92085bc34f513750fded2bed0c6b2f56a5fada24720c25ebb2d5a6141afa4bc44df97cd9dd8b407333439df2cc277b2139abb7919cd064c5e613f8a150624b59f974c6c4b82670582086c28a918845f278b8e47002dd1af01306721c9cd1443d14ed5c8c982adf9fd5379dd2d733e9785528ac26cce449a51e5c95da516fc6f9103198dff9e62da6b68c50997c0bf326b496c399692a386410cda91269e8cb1289563b7031f4ba800a14df001d6be6431abc18d0a8cc8183c10d3378d18b3536c2968cf8bde81bc220f2e0c643ae5e40885db516f694488413fdc4c129fd351bf39f56ed9675f984749887dd5b5acc73b1f6cfbe65449b6337333113380161ba46f8b087be9a29a734c402c741afc238a229c9c5057f947efe6c2045aee3f2b01f91cb668ac9ffe1a354de5c9a0b3d372439782609d547701de0d795e0b76913337b2365e1bbc6e34e5bae3c4ce6fa64d013d530def196634d9313208e771324299d8d49a7612f64b0bc9e5d1af7bcec2601b377f8c348ceedbea89af9f968a5e2efb2fa6f75cea1621189bd4ff70e508d01d343a86ad8227d7c604e193b8ff33e178cf18e4b1c25831f21223f83be5fca6e97cf9b08dd274a570842f568b57bad047f7b5d39c39f42c54715cbeeadffee8a7b2825ea8c838d84702128c7f251d8d1b4c5bf0711d8a7214be82dc5beecb8bd1ded327effe7dfeb51477d3f69e02433e1d1a74dcec40e4ad94e7ce39f95bcc6378d90a2408eb7b07e5b0b2ef2994cc865860b5fbf1d2aca1b42afffe32fa8d3ef0a360722773affe2d8ff43ae76758bf3f1ea65c35a843143dfcec23913ba9186360ec273845f09b6018bc6d231422ab92b2d0c761775da0128de19b502d85640acf74a1f547bf4ccb13c1db6e5bb98d964adff4abf17d9f48b3d574fcde57e9dd683dd3e57a302d004b77cf75981e55633e0193094870b77ba791c8e7927841a59ede6a3b21d21b01a09fdccd1beb2c799cb449cd2ceedc0441a71fb381b0736802cbfbbc6689aea9812b3f4f6cd01c8af28c42dc7fa29396304096a464d131300b55760cd2a98bdaa2f4a7e0f37d29e2b7b24e2dcce59759d535410ac291f0cc9ad89e8ae881daf9d9905642de0c1a48fd7997e4a8d3f7ac9bf0319a9c8a3cd46d99d99024fa6b69396152c260f77a8de2f746ced28d7467d95979b7979da2d3ed92038070dd66c45bc1574c609b13c274bfdc2c60a4905e56d6dbf616aacbe8471d93253bb12ddf28e1897d63def9b5468cbdafb7e31179f480ab8c6e924c427c53b6794ba3012e89d3d598fe1a42f889a71be26d62dc6084f0f7f6fcf3c9d8ff3b8012f62a0236e61784d6168413a785a6ff21824571cfbb9423e7d7ace99edaf166c388eb3fe06abd05471e610bbb108391bb6ce254f7f31762d4ef5339e03efce820b335b57be1d8d5173bc4ae55638daa3a4548c6dd558e1adb45b0463692d46bae9690850d5cdb4499b516e11b5894df89eb63112515e008624d33d35f7169d64cf98dbfde4d56adf6e27194cf4c0d1b2f675d965ce43b69e2c9277ef4bd24b05e5566a61b69ce84534887aa177d6413a6b58dafec4767f0324f983b2a2927c7c3ff66e7780231daf92dee7f20dd696eb98f6d201dda90c8d31b7a6cf54a8b75c2e9d62748e24173e8f3470f7d59dfcfe0b70aefd943f1aa9898d208018bb37f5e4f606b19bf6a84215cf6a1014fbe09c75a11a3538a42ae9b4c220cbcc50f56f8c7d3bbb9550889abe68d7c6a50e151df2cf62d4e5cd608058df7ef0c665ed2ba75d64e2ccbc056236e8f40243d05e96c7796afe73da148a34e1c2ac0bc8c58431a675e54a0d06dd1fc3db179df58e4ff112d5661b23a8bc083021adc0ff7cd4ec4a8dd49948f56ca1432f7c26d768cbf0860c32bc75711729a132b84bb932cdf7a8d6d29214892f3495733a985458ec7ec68b79c098c2b075aa72a2445abe955d502cec8e6355c1ab25d1b4da104f318e1c798ba4723a075d2c7f76e3ff662946d79e8735de4622ccd8afca5eef4523d4c0c15b4977508daacfeaf1c4b9befed940442a6a7529b60b6cf81910382f9322eb6880fd2f0ed9a478a2848b3fe2e574d16051078a8642b82c1defdc056bf5f8e80e808a0993ac013f78870da935111d9075bd20b933a7a0d78bd6ede0833c02d396ae6b6d1d67cc0ea2cce24561bf8de343ecf1b04ff10b2dac241ccac420c3229ff8519ad4e1f78d7859b0b77c4091e8513602027b3137942acb034bf046e4380baded33a15e852cb08af3ed6eabcccbb7d6f363e50a800e35e7f9417e702ebe874d4ba451d722a883c08e920d42a5dd725f456765259f014a8baaeddbf1ebc0a9a603a74f4b8019414040d2cdd93baf69f966607776756f15f537647afb0d609bfa57e6c734e632d0634ccd7cb150aa5fc1ee9d6933e885e4fc8595ebe668b7ed423ec8be7c34484333db065e92fcae1ee8f685f6640d6cbbb9394449947354b6848440664074198557d746ad825b7cedc6c7f4c51d39052177d2bc5fea0e10906a118f5f2923c9286801e014665fd834a197c9da69ee5edf8e5c879d31185ba2a2aeec55aaff6c20e358365a13f93708a71f3b551e71ec62e4e2dce11cba277bf7d237a4854155e4c5f0ebcc137c21ba41903908ca7e19144959ca1f983cd41050fdbb50ee55a208ecb5988cd1966c3dd45855a28e396281f4e8e7b99a9fb65b40dc7bacdeaf880de49562e9e03c8d9fbdb8fdfffe3052a214fafbc06acffd1e75573f33234efb93845714e725dd8690b25bfc0880d349ec57e3d64fe0956d01c6a876195f0c5efc580b18ee04c62c48f5023315b538d279b8ff8f7557402923d79b4ad859db72b5ab1eace82bfa3f7e306557d96851cad78537567ede77b93cd9a3b3cb3070f2d4083c34ab207057f64a96b030e96f608fd2ea1add3720c615bd605a7e9c6f10866e72ed2aa0fa8a10b78d42326186bcc670edd97d342d9e07af7badc65d2a0e56fa5014ee290d271f24db8717ab48c4d08e0138db38639677202c35aa2800e6a3617ecd43efeb1372480d557e492fd43c45ecb565bc746a06e27e26c2bce3676189e3e00d6420d745a83373fea9c81cf42710a60bcb5c266d081e0fa7c62c0e5e7d595cb9b35c7e71acd941cbbdca67724919ddcb5ce766add90dbcdad10c1f566d7a38c95a28fffa9fc1674902dd5eb8186803f0f9c5306b105d44d5b857b2b964c8eaf0e318752304610737373be2f6d709f15175fafc3582e0d027c4c903ed1007008b5f11d5e4411aa045516499552fb54996ad8e5a1af71e038a1b315d933867e4491b1d0eb1f2c61612fbf1db48c5dcf6082051cb26a3304c79691f689c8d5bab42da4b05e1c78c8dd54bb38020797c0ff51a8ba1f326a7284ee13bccc1dd4dd9ec4b5aed2fd77aba790b1a8613773f6a1a810ea1b1621e89df7ed0e43303502688b11ac43fb9452c3d629d7b11a269c28fe43ce2071672573f565351fd9d8e2232adf2a4779b145debc9caf28b9554fec81931a20e48488f82204d2a56c6470cc2731b74774424442a3524f4b991472032b4373e9802ce3788f47bd82fdf5337aa83b64ff4aa7bfea33334ba239318dde836777d8ec3c5222a3df534e8f8827b2c530e9ffc63a2e2521e30609e6a060c0f708578b9ed342e3dbd6f7977cc35620bc6a6d7a2a8d475cbbd9b530a7bcb5b15ba2e8d063645a6908501746b0e294021d30c1ec108f9038e0e3120a5ab261df5448b6778a67bb223a16fe4649a9d34d4ef76272f293493c46a6c6596a071de715b3a8e8db6ee78fb89cd3ffaa2afb687a9d56cf6d0272e6f62c2dc1d5074fe4c0049fbe8c752baa46998a0f3eedd9a4607ba7ea57f945b242aa66ce2bf0390a74e469512c7543d6f131de8fa1cabaa7d05c7333c8534feecc8c83636c63ee9d8209a8fbe2b76412e62f25bf97c7c3feef1705ad666cb5c94980fa5e417afd942641605c0ff53a1d310717ae1c0f1faf8f01da8fb8b4f2645d8538b529a7febc922dcde35b65b798e6b6b6c281a3f489e85f25c3d2a2b7130e90fd8b728e678fa134bb454d8ca8dc23998477a209178f3e7f2da356d78c1a94701f727fe316ae6357f7c46f022c2cade5975042fe5be92eb1e092645751aef2e87df592b20482c055de665881eb897a66e0b3ec7770ee5cc23954e3afeb196f1c5dfadcefded28b3ee2d6f0ab7ca7d530e34379cf3288712e23bcaaeddb0ebf3f810c150f19f556ac79bbed84100c9e3340af5770cde8210025fa7ff361d71acaa0032ba6eca2a225efc6cf27ed07563662e6cc4a5beefff1d80fd965a2254192e78abdaa8dac32a6b2e83a16e531d5c24bef1be9d8665e9e6cd9f27d0ac6d71002c92acd424a704f870721a86922f1b600399afeda7e265b7b3f47591e5ee86784682248e67edf94ebe5be2c5ba2f2f06c5c132ba6e01526e64a4ea95e5dea3cde87d9e956dacd8ccfca158c27eafe4f3bc0796eaae3de7aac61c1ef28203d058ffae0f7ab7daac3d13321aafebf4c2ed8581d6b5148fe1cecc77dc584863bb1936722a3417201aa7f9bba43a2bc8d66155c53ff70abe22c976799fc315c74d184cd8a3401e3f56e2abe705a08c26f92c8341b214fb4df44b1f5281cc27a917de864e626af04e6cf02a96d59100eb5f0b36c91310e4a669e0da0c3ba24ac9cec22d6c7b37c4041466630f2875d391a383b4935299973e2bf24bff61b2f77272d677864c390d0ea73b23d77784545b258555a2319131223aebfae5de8fffbae29b3991a3597ddc3cde471fd981e9d3d001a3abea65c42ac1f8a3d0a5d95ca5fba94a22a1fa274b7115fc9fec87342618451222cf2c3d24136ff713a8da878a8584a2f00aabf11d3a50620b7e3d775f4a8e52eaa14bbd240fc48f27ca46e64bc10536fe6b404f44633ba1c5093b06d584f2b87ad4615dee3aac31fdd1c2127aab216fb3462f82b0bc34e58e8dae4badc9b3320bb50822d847bcc2e056ac2c927407d33250d366f802a7b2129f120f4275fe5465cd264bfcd0ecdad7f4c423006dac98807a40b612b03151291dfae085ce66cd0332b0efc246bf9ff6f6abcbb2676c22e0080b40d16feda39ca1a31fe6b53fff9931a581c91badcdedd90e4dd0b8785d7cb045cd8a0064b119e6066138e076ea507f508187baf72988c45d21cc03f75f93fd6993400db12e732950a42a9e8bda917edf7970c19a2410f432eb728c43d534a9684e9c504a1f0304005af6e1acfd49db95fbe327a6df4a5db979f2612d2a813903ad026cbf9c4f9a7ec7a78ad37bf59fd293ba071d6bc556b1f30da7971561930ea59d332104af313a9ec335367b303cc39ac4aafd8b6c231a090b79295aa08237377703ba15a57d6e213fc12133cb40a31e9d378f7ded7a3d77f462b22879271df7cc4550b1bffe6be7e8016c5bf72b3ae2bc83388a2a33211e7567b39c12a703ae2efb4130c9796682d998b149ec131a3ac82e59aac4857a778c1ea84d8a7728a0e45bbe830c877a1a1d21ae63e875d397c71166b4f32b951db1b06e0f0ab6e8041cffeb72fd6b34cf58b70666d7bf519d0a4197081f7f3ee561f4ed294e8213220993ae36ec2a036c332be056259d9d0653656d0cf14aba10d857431d153b01dd3225ebd882513132c4a74044495f2156d689a17a9842f17b822975ab526d209155653483f3dcbd3a232688eb3840f479539c95b9ca56abe09cd702d1df95c50d29f58b93aef38bb4cb16ddeaf8ab84d800f2526aca482c80519832bc3dfef5f3594ffdb19f0970c0005554dedd0e4eac1b2aa0323f4784f5eb52d545ca87b004f493c350da7905a1ce6d04a41b7e581bb84756bfc53749e12ee89ca16d1e38b45365caf7475a01b4eb0b5a1083790d8f231331c48f31055b1e8624b6b57a3f9e86880ca1cd60f969d3695a3b02cb525eecb355753a0e3a909dbe52a6eea1a14918485cf87e220861e9a6d6f23cc3a26ee76829de06cf585561d623a15b36fd9572325413f27fb032ab2d41ac7c1c08084d4d739884fac8694b8addb7d1b3ca2cd6e5def9027816f65acb8294b9bcf076330884fe8b90fb9662331e6ad8c5697296ce9eca31933cc7c9e3385da5d1790c8f016c7e6c6721b35b0fb93aeb5ed06daa2e6a48fb66cac259643fd54727a37665b5ee3f76d9094dfa6de106c7aa9192b1423c01599346a419a2cf1c3128c63d7c5c16eaf98aaad71f0cf97eab1358c189cb978047a43ff3cdcedd03de0cb5bafde0ea3fd6b073398d331cfac2272fe8fd37b0473ae2e58d4a9f94e86c8220a3c963ed2a1c240ee01ffb8398c247f36823411d9db6a3aecf725f66341398d485ea96a960d8699042a33c8055489d6bdcbdd9b27d0dd77c3c413c566c4f97d1eadfcbf40cbee1c8b45b509af3051800f01a86d9a39d10fcb141489d78c7c2b2b3237b1fd6da83a9beda52bedc2173d1bc1ba6392e4e26c00300a4bf0f7b790c1c40bd63e2e67e7f20f0dcd19f89d11d7bd18ae8ff614be927832f8f979df9448de602d4bd0713683a20fbb1da9b181984e5065d377801bd772a485a3e35c130e91cb1f9f7df7477139d5b2926f7a3b29cd301e2b5269e99f2732165608ffc55f25948e81f01d65b01846f93156d192064036d0ccfa9a3da1c00154b96e40feb64435b32442de788901ac8f45f13e503740bf16612f9a455548a802dbb7bf25211ec796fce6eecaf6274257fc7173c93bfca7586e0b281303ab2fcb4db76806e68308bc04674ef43bbe8fec48028da55cc4ef9897760430150e49674f89b001b6d27c50ada1d249f13860bb83b16c86da6781eed3c597917bcaac2197c0eaa18d3f6f31c0179d0219d50e974c4b3ca95308f3d228e8a58f06360e5ac10b93055e227a54891df67c8c4f5abef5a67c85765d1b27898a1ad8d50281266c9df6dd5a41de6fb7f059a2de52de76d90526ed75ef71f704b8b0f2baffe92cd71ecec37a35e3f45f23c2e6a374aed0ae059c44f51a51cfadb5f7a5b908a52ad84f38cae4ecc9d944ecde241fec0ee6b48c5e188fe603250f38e0637a12672c062811cfa5adbe654071e827aecd9a5774a9cb8df62e26153f7f3ace4a017e3db3e4ed42c8b113e7f3a5bf9b43504c3894778f26411872faf9e89e0c20bdf8741259cb75c6930be288051160e84202287b16b49a4e4fd123ea302f921c19564df2a4ba14f86ff7ef510704ab0fec1c58d24d8489b7f3f37258558a165b37a53937f2de9086418cd7927a6868b5dd07f6b759d470e0e924f436807bf402d9944df58c6c52adde9a8c74718daba6e22e57b077ee08ca0423464c9c32aaf00ed20db6cc562137ed9a991e4ecdbb38475c8b539a2313b1e976b206432ae69b2740102b9c25522af5e76689934cc70249e6abb6800c55935174efc456ff0b73797e50a54706998a31a06bdeb777128c338a1a9876eb1042a41d4e441cb6cfc395b8a4737ae2b77f201a86b3e82dfceb80f5144dc15046edb54f5f7dea6ed0dd68880432ca04ee84c95cab6f1ab51a4af0351a1bffd0f73479aa856d95ce2b72bbc06af1b9792c15608de5c2f0833488383ed4c825665e07e51c86a9e6f7c86667bfad85973d66792f3d89755dd0dba50edc4ae05358133c253707790c18a15527bac97f80674c8e953c487287f7609c8459eebfb0f9bec6ef5830645df19c7da99b0bc4d3d6e4cc1f9c0dcd8c9683a2715ddbd137eb816140a57425325590c95b3283251d603e329d1a30b06aca55efd76e2b4c4c511eb37767b1999b65f9029198c6e7dd203cf1124cfcc311d9f226c7ed38ea18240c79285bceab8299c45c2903bde65b21a66ca90ea7bebff1807256747f659da130ec5fd84e28f2c0084a882759be4700bb8391f53c982c10cd26361adacedd3538c67479bb849bb5c39e5faf1b69978119762260af159e9e3aa0c03b12bf9fb00ba82b14b5622c8c5b06886f5fa7899c86dc548ffda3ac8c778be746d1a21d42ec5af3b8c91bedbdf09a9a0bb95a01f5ddd55e04fde733fe09ad6654c44962f1d18b94b6f749c76ec038e193d7ba6d84446ebca7db18af0d7ce58554b255d088f90bf17cedaba8449d72343da79b0c62aa8a3061242ababe1906977c993ed722f915e167d49e90fe14394dac4a5409abad81ba3670b3f93c4236e0cfbe5049afb62c034db8169d1836274a606f222d50522239c9e959989d735475b33fc81c2816b6854d31a90423215963698267459c7ffe3a3ea2643a64e293aff082cb3ce6bba3dc5c015534aae6e565826a0e1aec7e87c4752797b9d9b211f033f216e3877c94c1b1f3ca26d3236218af18251b725480d70f898593aa9e37c06d034505cb163f78c6308bed68dfe9272d362671a7b819286e5ce5443c316931385c187d33c2fd9ebfdef6932312eb9853cc890a6cce42150b6b7fbab9df6558a760ea9a8a981fdf7c67c7e0d224609607b0e8f9b91f401754a5347b2fa00fce91d3bf80d47f0419aa4ac8b38f6137de838e091b7b3c4d0b7a3f2b797b26ffb22628ee7d2eb6eccd0769df7af7687a085d99897c29ed8f35c200c276b44a634b23d941c98d7a8f7271e44e0a9ca510e34ff32df45093e03414ecc38100334ce17231d139175298e252488d6b03be3d7a924332c6c2d2f38131c915164b97b4245d6a9f9b61cdc867fa3f19d76ef351917e205a89b3c31a619e1da953d0b24ffcd180ae44b6f81ba8da4a4d8089647fd32b1d816f7a9adb68311c0eb844a9a2a9c212e9874b66fe04c67399db9ff0309de045af41eff1e1a7f1fc3a3b887447ff5ca0d1445da7e10cd0502e15da061ecca37bbe61777ab1e3b7c56fb58e3ddca81fd39f33afc98c9d071bd7b387d885b02c4e5231a6a5d387bf4ef61d99102646c0befbfd7256f2a5200711a8304c443e19036a4fd0a888234471866b04c8f36710432c34b23b86b60ec0fc0cd58371eeb7cb34fa80708d9848347d8ddaac5f396c7eb331005318dae0f113a9196524507ea34abeea576a3a08bb5e82b7fcaf3ea7609ec15dec9f8ec56a7684186532db66ee90865bb62454bd8e799e9f052136f0ac2f53eee855ae610bffca738083d9ed109c5535f54acc01ad4413e4696a1acd5c0339401dc3dd5cd6c3a58c242495d7d9a164c3624fdab3bf4080133caccea0b018b4fd2cb0fa9b4439ff102a306132cef6980a4fbaed624b77ec8534c55d545c28cdcd94d89f5ab8ba05bb3234c7a9a2f8632c19eed3b43690ef3b0982d2776e16db39890d3ae786bfde5d659c173b5421064c9523b3c92aeaa6b23c5d2251b32075980a8f91caceaeb765ecd5adbce1e0870d3ca20f5f26ea6a8af2adac00aae7a4d08c11cb60adfab615765f71ab25d1319b98157221971140bf670152ebc2bd3862a570f2da5b3e638ec287ca4c5d9552689d112226e79b50f69799d5d72dd5381d75190e6d716d1806be47b16f41294543ac0586424983731c269a5baef374e58a0995c76e78b37b06edcf02e2302ae6c9479829065e99f54af84ecc87d2936fca7cc553d4361e69741c74c3663dc61dfecd9345216ccfcce692da43d6e5ee65750750b1a96a9e2783abae702f228e68301ee4fc2f590da686a970c1071979c3bbba330c9f09f23c88a877c96bec1310a123f431698b14a2fd2ea38d770e71827d8f55ee502fe11bcb1921f37a3e58419466c86b595c81aa2c6507c05dc46a6ce2eaacbe542d9797e124572a23399cf296118ab6d6e522f7873470b6194d85391f5d0a177fb4bde54a58bb1ca24980895d4c78869d4ffde4a9fc1b0425cf4537669a839d49a7c14a482471a44e50f24957a6a114cfefbd5f172f3e080aadb990b60b272c89ddcefa93a18cf733b9928dedc950729067426804b3cf4681d81b54eff0640ce43ec4fb858fe25b016779a21adbe48b943fc0b0cb9a3ef007c1790ec2e8c454d6d2b8057b48786821873834beafb0c1b038b40a6cd280649815c5d436f8f9a7d7069aa6865c57a3431d5f7029be1dafadea0f0343e5ecb3f5395f33cd8bd6d4cf850e36c6240402e770d46acb7f78abea5490bcaec614e84cbf53919c3ddd309918c1e616b98fa6c8eeb865b23026568eba65280895797b2f3840f080eac183c9773cd5dfe0be14472c86ac8b0579f71805f1ead77bde269d650588c12e675f70d603fae6d9edfc577f47fe12c480972003470f57830534050f6eb65658f6eacf57e1478ee08bebe9ee5c8f316d5895210b4949efb5e799b1854141601aafad94b643a4d453dde4fbcd4e1ceb3acfdffc37bd56cd02d995a599c51d66591df7250993a28ae31ef9a346b56b6dbd1ca719b49c8815c078c6fd3f55275b6750bd0e7eaa03cf5a31de5a86ec214b413e13657cbb7aee3b9d94744705ca683b2aa781b6bc3587b16892a1a580d541c3b8052a98351fdcac8475f12d0d95d692d0742b3003f3da0d2de7042e6981f14429afc46bd07466b40c9e33a859a80f5b31d3782dc25b25fb1831c89b2413650bf238c935659f67879bb0ecfeacd695d365ee25d7d889132a29cd49798b389a4ffe861144b34ce64c1aa2b36d6f826f43396d502253ebd190c8a9b30051899221aa377aad0ec6eb94762f565e3757751f2bec1203d1db8d9ffb3edebbfe60c5f0e703b177a6e37526735d21d79c7a5c52480089ccc4d9628a20874be2e5c10e1de865b1c57f1ca2290f8922fc2179d56484e18353017233e427a3984208c1070cdc042aad787712f4a4dfd557f3609cbe5dcf02de8ecf9bfb5eb84705fcea2e1ec5cc64c7b35b0c3c712d6e2b9ca7510fe255fd45d74c1c36177bc15bd548a6ce469838a3aab3f310c3b379c153e7e81be01cdbcffcf4a3626b5d8eb9ded0218fe19f118e008a3fda327cf585801202098b708d59a3f6c27ce234900c7dfc9d6e64dc85378f367ae3d0cdf1c8adbab84aa191eae4c41c8a98f6ca6359f70703253ebf42eb8f405e7ca001dbb7ba25bd792982ec64f62191fcf2178150582e120b48f055642b821d93a773f95f28ad2c48cb0f013ae0fcc99a754cf62be3078ce5c6aba9e9613a502263e237c4d98e8d88c9bbcd1bf09cc51a05ae8ef4cb5d2e9775bea9371aa9cd799b9c1ca1de95055ab07d8d78b83885fb86275692d34a0f0e7e657b9f24a9121f8de6bd57408c6d6c6997209d5161a80dfb1fccca12cf6d9b1171ce1a295b4981fa81a0b79a7940ec54370e49b437d87bff9199c43f8799bf89e85c269343a43a75fcd82ff3d92216e3adba43fe49591dd3337d0c7b5717925520f829dcb60c2af07c88ec213918f4c7ac70de9499237c5bb02423c093313ae619ed3fda579b621e0bbd6a43f69e61c95bc8f137e96de0ea10cd9380fe5cee612e2db7567d99dd681c4c5554129701d8b1521ffa274bf0c8e391c316462e505f304a9e5afbd8d621aa7267943f9b282a8473e9cdba4233339cecbbef65c78b016ada34c9c89314f5c3f95e92e18e70a36b4ea435e6f58c5de94435464da1335c8ca89a45f5c0d9ec82cd9c78bd20b11aaefbdef4344147149b49e777286fcc7481378a121ac63905d1c88a56f2246f1ba5b9804f00d8516d6fcca15e82eaab74b9961ffa21be3f274f31bd37f83d811dd9324ed346426f979948e45b04d337bc777a252ba4fc02115c49a4952baac3eec05fd33a18bdaf9e9e1c6c5883ba65db898d96fd6ee5773922d9c80b418bc3d7e119d42ac2936fe9df2f933e32760da6cbbb3c282c00a2823a9cb83f5ffedfd7d76f57515be9cb18952616899647c5e558b1bab538fd5f808dae2906ecb9e8a7232367502823ef87b70e5577f88d4bf1a435fd4f596a92557853b383bb8481c7e2ee8dbc85f625022c23a693292ed9852f3724abb5feb02d35ba41a8f8e9d5333fc1136c436df9aa593a0cad7021e07e51aceeafe599c5eb22415fddb57d03faf541dc6d6f531c481eac2ce3f07a828356ab2e90a0031eed9d6d0be016b3cccd11270121e5e67cdfbff8f131481e83359781ebb09f76788ea1bc64dd3bc3f45ec9e8708ba68ce93c59c2d1412ec845ee19752c186894b8725918d9afe259ab9396b112696e58c19c6c131a39e8f8393ca3d2cfb46f3ade1979b9556867bab30b7045aa10d4dc0c872fe08e2f1af5e5c14bbafa1a9406f5f5b36c97d86c8bc67d83ccf238c7395050791368d3383623d07d3fad79860728b2cc8c7db82a495b892bc39d287690c8346066d4ce123629309c85513b61522ae82332d7cf7169a6b1da949b92183ff4499b51ab75aaed3785d35abc6ea3a1439cbb62a27cc0a4cc051498bef1fa9a72c7aabe8ab29871dae461e12feaccea758016d8da39f185d132dd330acbd5dfe6aa6e2960462789deaf12a3927cdb7943c405e8523041d3520a97d425b4a0c99ef883fcfc62fc2a913e565344b0b7f7b7813129c134cd8c26856ebd2bdaf2f0beff0fba17ba58a4ded57c2b7a2477f6fe0c132804bb3427187829fe7cd67b34a6e40fef2efb2bed1ba4ea5ee6ad1bb0647bed1b2a2855eefec0a4dacc38df10be4eafaf42f2706c166a44e8c3b4f3b92a20a2592873c1ba6414d1bcff5c39df2e3e753d03e307215ce4afdc8f52dbdf349cc0d245557b1658094d84c8585479fdd2ff604cbd09079aae6193cd6c710bee6d73bf08d0a55e2cf8b9a8bf5acc537081467f43935fe885784bb299a00290f07818b00285ec1db233cd28ab0aa58ef19ee2740af354705319c6a2bbbafd26ac78dd31aba9a65437951c24e30af89e33e88696297c2c570cc82dff6d3e9f7c7a0c1f695dcdc03b497a6ee7a0c4c275d6649cb1340755f4a16f30661e4c361ebaf2591c019bcb3b53f4509f43baac4aab825fe9572d987872bec56b913b7584dc507bd0ab4e4b8ce5d19cb520f0a312b9542b0de0286c25dc2f03a527ad9c0fcbe060558aa30725572fae4c4c332f43e030d956e233e965ef3452814ab419f06a06387cc299b467f6b7fbd16a26e892c82fb0a7d89d1e587494a6e623c133f2d2e6c77cdb1459c026f0edef64811f32600429e4d282fd5f4d2424464dc49da82323da8a2d5a3e75d4a1a08e90871de6784999dd55077b005e92ffa1a7a33e8c8dabc5e7a33783b830101ba6029ee40da3cfc5ee82c1f4806ecb2e40c7b0e6cba327eac0e1a090719b3cbbbf20e12b3f4c28b135770fa3c607941374cef06809a948f0b9ddffa574cf1236782368072d7ad27fd4c66f2e6d050ff0e95821ec3efa6d0154d9a07991ea5ce93729ae7b79ddb5b50e78fe6dc69eaaa3e8bee6ceb54b993529464d58ca0c104f8171f6c2ac3273a2e3a0ac4f166d2e6b6ed18ef0a67d8370f24541c9f4a44013f6a893212877797d8558a1ddbaae8a7230498e5625ba76cd715849b1c3efc1849e5433433dbe1ec0cb906c8085f2b9b1117e41d4cdf3debe13724370dff60b1e1a516b254017ab308f6f01236cf2396c2f67e6075711c9af73cd9e29daeef0b847c646f5fd607f4f76d742974c83b4d1f34e2e6cc90bc352193ea22ebda7f6078c705a24b19abe4787cbc93ca3ce28f95a6d4780c4594b423552d0876336fc791bef5669dd8e3660fd71395058a48ff075fd45316f61cc91899dffe820d5bcb32f993d2fa3dbdad7bdf4dcbd47512a24f370bc7a9a5091c49166a5bc24ac8a7171eb44f8ce8924c788f3639fa8e975a022febf3bb1e325338dc5a7d3c7125d469f81496aff78becf8333a1820b79a30deabfd34804d4eb6544adee8a5fa8a459724ca4052b8f69438cf41b2d1022c925f632e2dc10568e3b4fe609dafc63a1957f0847f236649950671fca8f0298aaaa2a1da9faccfefe745a62827be3facf6518802d3c87b97ace27fd42607ce42ea866ba8ca1e40843cae7b82e41b78eb7c98fb93e41999c3669ccdb3a0ffe26064e03abf8d1a643ae950b4512f7f7beed9389cd02955f58522bab6b0006694a8b276a124a620aa86c3d0abb2664bcaf9255ac1ee47a92df662bbe6ecde23686ba8d7d666bcafef93a5b523dafab9cb7340dc6aa433902f8dfed59125519f86994bd3e2c9381365bad1b576fcec4d0845e55d5afea43f3b1d6fcdcae914018f3b2b5ac4b0b650ee473c6e8e3a6c4d4763c23ac0dc0c4b3825cacc6e040f48d5131474024384c6bee5116ed1a655fe148938a9b7f5640c0f6cbd3c2e25ea5e0005ca0bf0b4bc0bf77fb47cd71ad43c084ec720ab3dd3bbc9bebe9490493ed110e97ee8e6363af680068a54b17a8dadfe81c769ae8ac8ec133fce17f852b9c6e1ea06fc0e7f9e9117bcd0364823720c254a650e3071fcda9c0f1392d6e6d8f76be96cb3e869bb17609afc33778864c19f7794aad8838c618fd0c8ce9435badc1bed642f5cf638e023a95ae8435be1eacb22b2f81d2566187026f9031aee9afc33d4e3f18d72988790a2e795dd855e24b81e283bf01e6f60f1a26d60728ec70aa2a1db9cb5908ba0f47a98be552cfbbe6ef88ac2c8f03a9efde4dad1524908c3fd09e541da46fa87f994825e457923c7d5d4d8e5ebbf78bc2028214351a335682f1faae591862076cb6fe4bad186b61fcf68575056fe08d1c67bb53dcb5006365c2315ebe632c913a90ccacb314341de07d7dca404c7c19411da0afb5c7448ae7efdc8afe07d458b33917b781364092982f1395aac63c1d24bb6300e6d2828575c658d63ec868247e7a79fa921e55d0580fe9b680a8fa1c4eca14e7458005a02e093deeb9770531eed3cf13de6a654f231332e6aa41f4133d083dc06f619e26cc8bcd4645b4bfe3eda2b77dc805094fb0372e4423174cf06acb881f45fe9b01382eca8cb46c08f3109de99782031595224b936c2235b5bc9d7bf0b9a2eca0f7828ded64545ee4083c1d84908b01b571adb8d6b79be7b24020fc0e1803e287b5870e582a10784eb17554bbb802ccd4f5430707f9d19e7af38445a057c46ea801e00ab4bc0e916e77093ea856a723610818400253a10f3170720e569548494caeafb38d6ae7cf8aa77717a94be49b6c9bf433e0b210fab9da66f1524f49296b5f15c98af18e4467daefe002172145c1111dcecfba2b7e1e671dc8c96960e2d78ebc02b66e3be57a3b6da2a6a41c13ee90b92db9e84a17a9a6e268bb3a2a7433f9a93da3187cc7bb786c5ddcda6720349725cb879d98dd6c7b830eaa795068ba0722e0fbacccd1878ec48507ef928de7f87209a683e00ac4ebe533535218fa54174166c69865289cc4712646c53a4de9134720101e61d64c5009ff9b6315f3eb592e6d14b4408af33710bd6cd8c3b38d0b4462ad992d7c9039d1301773242d2390eb48c9370092a05dc69cccb507955907357f58834181942ee672a0f7723c63c68fb41da45a6a5ae029edd1ac2d5c07cfb00562dc894996a065db76ed0f43e3b41d7f83a7e5d262e65337e189f9bb60819848e53fa43746c2e924689dfe6e22b6933d0e562c7bc48f2639b07ae85662946ccd89e9e9860074ca4c7db82c0a839821bd99a663a468f29d1616ac974b80d096ff187b79f09e07fd2f885d220dcdfab8d7bb469576f21bbdb3b0e5b04a8d2e422fd2428f52ef07b1f44f39ff06546b42ec4b5c7e63b28b6e1b3209e632676ef8082117a7b0e1ab1d11627040a27b0d18bfcdd1c0b61cdf7c70709f6900486e3b968221159590aac740390e5692f4fd72837ec8f0653e8d138e91fc46a54813386a7d5cad8a67692b4e2c2edc6721c4f26b952d71f4eda939c9a33ef4b9daa90fb68fda6c54dc324d4c0220bbe63515426c6cbafb733c1fa52954edd4e4377f489f74351d5e151a4a56d1516e2c1a19fe1c0b36244f7d2dd3b7e7e6c4c785c743a93244d64a9d622dc3d28fedf11240443f7a0afe3bbcb1a9cafcd71409d38d24ae961dc42f884f62cfc151b8dbc75ea260698fbb3c7b04c2dceac83aa54c1e047bee3451014705eb810c5e7966c66bfb09520cb622af913c9c5710153c9556fbdb295f7352cfd1f1d6b32e93804575491b13f91dfc0547fe3e30a8bd4776d9366cdfba33e9e64f23eb2e78ebc17ca7a47837cde26ec35783c1659f6e81fb147fd465d4a06f27c89083c01f6134e4e693244262df627e5e09072d04ec6b2879bd62529e7d716c9cc99334dee6d4584cc9631c05e81b494758fd66565b4404bc9aea8a0b8cfa268b727cac69bcadb0cff17a6bbdb4c009964cc3f2c48bc37d6b48e345550993f2991f4db464d95e73105a5bf2b6d1719e93449177fc3aec64358b6913d2ad8b9079435ace415a07f1fb8f7528807008ff09a675ef6b7edea035b54c7e6e992c77132c85d697e8b6c0dff2932786bc616d2571ee55ca3bd1c6dd44ef32543dec8e57fa4b39a52de0ead3e58a3d37e8ddc6d02dcfe7867e7855e197b3a6cf735f7d3303d3e6cdecfc067d6e3add3c26947284490071e1bf29a0072e5b5e9119d99886ae1aad473b9e1384397e33184f6cb47bc2f6eb2befca00b759a7094a97cfe34e91692a84f59a513b90e07785cefc09abe89c751d6499475c8006767067bc818c366123736c31c518517476eccf26435688e06802037ae79eb43c06ec3d28821eb3ded456cbbb20fccadbfdc2b918c357f46aa074457280dce6a0c0d31e8d46f00700cbce10e8120f9ac431c894e0166b0af941c386f582b16c84cbc44e345363b313e00808822c4652aa544e993e3efe01cf160c7a8654b6ffce40fc8c58c09315ae307bb92d6da802904f139fae94d4ff13470720075035aae836d147fc46e8a4c89ec6ff9af7952700500307d387c7cb065c50442c9b74333a40b99ec1c103bad94b0f9c7ee45cc53688c1bcef6dd358124ce5c0f4e26a0a9fb68ffb04b8d57a7abd281e7de4690682510f4d07b2abbc1ff8c159a2d3c0c264a096a3bfc532da502e070c79f4ad4356c5685f74ad63a13f6a46bd07536dda1a0221badf9344362efa9da87c35f9c0170731669381c48d6e702091891878a4c232c6db6d861353e7d8f3f05846c30526a4bb6d20a917ea122d71c2cf4119d7f3377cff78bcecce12c8c1b38cba855ebc883afc2052eac6be843deea1662f1b4a1a8dd7203a56ee8ce0134543ad7dba8ab1c9fbf91b086bef60db5b5ffc99b431aff2b6f2022f8ae7ee7d7302e77e992140ed4767cdb03a8d62ee1fc77c34eb12eb4fb7cb4a9abc51721af3dc6368b125fbc52eb85bb10a616bd02b639f8a33d9a7527425a9af7a6bfab924205346ab5c7e2d75521d420e3ad88b7869f35985d25ae5dfe7bd7773a2c3992ca6b48fc46a4e74ecb6dfcc082724005aea5be7ca891ca1c5ed10c630d7d3a7cec4f0ad9b23eb35561eca8283508289dd0535f46cddf355d12edae10cab0e644d410c8b0e2dcc0e45aa2e1921a19991966e20764a3a6f3a8d07b020dca69f07f023375e25a5ff4365e235516d1f40a3f75af183b7879727f39f79f1bb2df36ba3421fd9f37e050d6e951b98e1b8b326e296e5504200f424de234ac223376452ba9593d31959af60bb930ea60898c4c602d5a4805cec2ce5167f13271f584a28ac46de1ed1fb941a95b7d34d5d1dae6ef4ec5970a756c926dafafa39630683f36748e6232da23351f79745266c62ff8eb2ed4510a3af6aff7309073ab55d8cfc09f74c9ed16c0493a432840d9177b74f749c5c1aa132787ee6e609ab627d48f401ea6a438f6357c5f4d2b936fbd06bbc92b4e1702f9bf4f1f72679fa073ab5136ada236e15a5680c436f5a092692da5afa8a2f64fab0b5918795aeac4b2a0c86a3cc8fb1d339119e431070d81ce0fcc3677a7fd1daa67669282489737081a9c3125cc55b2971a60d2d256437673a66bf8a05bff3b137140769af1b71a3a01bcbf1bcfda272414748336b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
