<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6add7b420c3a9d295e1fcd5f851c1f7726230349effe21fd89dabf78db7aa4d0f3a056d9b8341ae9fadb83eea668b2d06e0585be5be90cd177f9050cfce1af3bd83b89e0e1c9182d264b71c6849a3c50510ade68ed4281a16ed801b1d344d8d66cfcb8880e20fcd59078960782002678df53474926be613676017f1afce3377c92993e9b8826b30a3126d1a8b7fc84f3cd2ae630b6833f3eb0134c84004729cd784e8ec3b1a3e759aa7864b1ef8850340334ee9fc2d9435ae82495a0d265818f3e41d2909fd86e10a1270506c5c8576d607a88d1aa4081acd79dffbfb05ee34fee9010e0c3af40f9d576ad33f6eece59f28feaecdae1b81bdefa4d50eaee3d814e03a03c5aea0e98253d58da846b87be18f79f975885972e2891d360f093df9826ef1df40f5cef0325e05d8b03d9cf92e689ddb0e920b185fb05c874e678db71f670411b59b96cf7ba74cb4850ad35890f2634dc7e771b27d563b24603ee8d67a51c66d9280f04b3ecad874dad00c1638e0538298790ddf7278e2b07802c43eb9bc91e88d2308a2ee3ea5b85738f4fd65391328bc13ff7ec3c7273f38ba356ff55a724489b7150fbde9d4b93da9974994f691a3052a15e395b871a0860bb476decf8612f9ff304341ea809b676896d836e5bb91aafe9e800235a7e4c4d92a75e367223d6b7e3490f9d5532fa1ca6497f4990dd781bf4a5af5fef687e60d615f812b3702d76ec2d003fefd66b568c6c8a0ef14b4bfe893f420b7a5201ed6016dc729f24e4681d015c600b5bdc144eee6f69955b9f1f7d24ab3c34fa4b7f077cbc773b28a46e6e3af12eef4d637f400d3173733bb897bf3d50db8b4bf6d44a6a540005b411324f054173db614ba3c855b6f460e8a1e5d547d9927bebfa0d2cdc09d5677ea76cb0e6c4efbffd0970a83a26375d8b68ce057093d2464143178b52f7decfe4c95d8e466eee926c703032383c6530520202b673c1ff264dbcf32bcdc74b25e58b862e1e1936a92a344f06701626028bebc808e51a1c92a64f05a6a2f94e775fa33d6a888f9e9ff338b55331d808a3b13f7ea39e87bee2f8d91325399e2c5862bc30fd99e18fb517e8de8dcd47d5685d7c6a9753b9ba89b45b55ed46c2bd840606b7698c74754bf16a4b6508d5b2b7e098ac6cc5cdb8b59bae9025e36200cfeec629105b445b3c3446bf8b56ecbadb4df8c5dfb746fb8e921ed86e3414688c1979778da2f2a351f1f7e8f8d659e7a097383666b63cf7ce659462385ebd8c80ee662044cb7aea6fcd9ad3fea12a29faddddeadb962985b78e21eee4a709f81c5200ad92f961091c97a9c53fd45cf25ae59cf6b64c8efe6c612a2e357ba6bd1b55a49fcac47a44a2dc3a2ba9aa52fba410069b9ca7394ced93c3e51279e0c4f987fb782df19ecbfa20121de9f7685784366cbd2d939385737a2b25a7b2d82b4ad3b9b5502c7df016418a915f8359692c981567fc6571211bc313ef88df3e50194436d00ab1c45150cb057a24a355462d70fe34bddaa07164a63b6aa4470209d6733971de60b2372fbcbe23b849526d733b7d94ac08f767aedc334dc33e9d4875bc09ec9d62e937aea087cc6b4f1b7d24b7ba3c2b6a8ef55d5cae4014929b82a02998c562f41f944a424edb95842928105d90b04567d297af383f5dbd97f0376c1e2ba0d56c023e25b4114353c7dc229ba73c964bb3c65013f82fa3bd3a2f6f2a5f940a33f11beb3113f5a8133e6376ac86362821778f4388e8bc830e8a8f16e41b2ec064b17b3e7e77f96b1a7b0862cb1ff68fb9d94d1007b7462ea9bc790c56f376d0aebbb4dd6a78fc289309bf9f437e4d3f05f3bd92c30c0d8e76adfe858ff7ea52564416164e14388bc9e289421f4964d1dc1611209526513225de9cdfafb3ad2578e83ea27ba7f0cc6221eeb15db37a7221887ef1b225c1918bb88482285cf9bf063f71f4087f392fb05163ed169ab90dc16c556345908add58fe0192065f4053c714156de69670b495b84a934b9edcb24276970bc45029200ceca841d1a09b0092d15b6fa39fc82eac6710c643294eb74e70fa8f527f91f51391a1adb6b2434c5a9072eb0d7f1328ed7018fc207672ea820fce245e0761c4fc4f3970351ff437ad73f88a0cfe07c5428ca4dde27e7b8c8dcc67ccfeefb471701980ea0c21f4e35a69e3e374fc5aa66f0d835c537b2485ad0f15cf0378af02929bec410cfd05203ecd1093627c90bdb02e8ce5660332a16fb9c15afe7b06b646732081c59aa4019a11ce1f219c928f88b9d67a95c85937b972f8f83c37d26c305afd373b1b40ee502efc94ef1bd4b13bd1fc8f6632dbc6656f9896b63b3cdd3d33f50c798974163e32fb4def22ab38e21a1888b20c9d563837dfa5ece158c1dd9e1d569019962d80481737f8427b6f516f8d2fc813480cdf9fd1cd3ec7fbe7ca5ffa7780960cd4a743f62be568d00970aadbda656ee358f593aa85cfe853bcf1c04139a961d0af5129aabaad62e39f0ccd5002129208ceee70403bc1d6a362ce84e0e2b56047b8548cb83c63220781e7f8341a61fd60b610eb7027888194c8ce40def23c73ef26f3b462448742d6cce9451a67296b27aeaca5549c7a88e20feb17505771bd3dfdcea0a2c0b88057c7ab184ab043bd6d6f720e4653bf6b34eb38934d5038a89fe8ec945f36307b0960441018abfa37638429f562aa1ada6b03d5359bcb8dc4a1fd6f9bab6b1aee35a29e39fd04cf0ca4f5e23d41de6277afe3e8ffbe8732b48091c43d385552b92cb931615c5858d86e2ea309a86c7b533ebcd6265e724dd5f5cd3865e3e6ff824dc6d9e92856bf8edbfa7948ea93e910904e5a346c23dc57a93f3338bdf681404a4988e0b6b17ff6ebea8cfe12af8a053888bb871af34d41362d8dedebe19e9d72d02eb785084b00f096dc2cce051074e08206c6ea63a77870e800e34c11eb0f2dd352bcbb9c094fc9bbd4a6ca2b0a2ce600bda2c6265f8b6ed89ff139bf41209c93cc14c9a62fd687f32e343a80eb9dc18c4c72467441c0067dc71ada8b92ef84f741e34d72f0e939535bca7d7255d698b2942fada88cce8b9ffb69003dca8d3ec2d8a442373529fb00ab43deb5ce9ed62585873e19c6ff55faa75d89391a1a1fb320df6e98fbdc8998ff77690013340338d3932a224a405eeb59f9cc31604ccfd4d056392b462155a65cdf04901418ad08e19f349b350e64318eb30e9784db3f6f37aa871263345ca6f1d20a5e73758a7bdc81129ba3720bc24deb69db43b21cf2aac1ff57f628589e32940cc6e31f73d2e5484442171846d0558bd2c00affbf68ae3db422588679c89feef8e54f59d419a4b156a7464d2393c6afca33a12ccdb133c155aa051cd6824b693cc0b37a3ee3333fc82d485196396935a782e24289fb25de52c6a4e240642bde49da0ac1294f2747cf01d54dca7002ec6b23e067534dbf6fce1f138f50e2280708ce1d1007bb6df3ac9db2f440b94042029a99d9d55c10613f99ae03a3d36ad82f9af5889d5b5f6f7707728f898877422132d64524259ecfbb4411716a6261530de9a49f0944b4383ecda07e362914ff57fb3c9567a2ca56b36bc267bb85f45b527f888462bfac97eef163b42ac5bbfe09e63e585e0a5cdac2ffb02f121604d4be2579be0d4fb9c0fad1dcffc0017354ddf8b77ad62f6a1f96a209cfd9c5c585cba8090583770bc94fd2f48094a9cd70157109fc8e88b39ec5c9ad8519de484f0bf22a911db27189778f47fc3f1e55cb0aaa3188ae8526795be32eaaebfc3689dc1c67eb99eaa35e4e7ebd42fabb99f82be7a3383f752e94b48da0583b3a9035a3b13142f0747cb0bc5fbc5c79617d9ec55466e5d13ffe66ea3c30060d88db0c84061a230b84a0829d19358a3146c3958a740da3ab392ab497a0afe954358d647e7e7c900fac3861391ea185f16ddb23bd21868ebef6c329c8b1391a041eff24bb41d0a987f0f484fce077f368610d7b53782330cafefc8df8bcbc9e16ed703f0064405a24781b7d46443aea6afe4b37cfe7f12d4153f91ba9329c1a2db469cf87b5f3e5834790af599ecfd1cea3e25742bbcefaac4618b9220d60ae9437c5f6baaa75f0f909f0c10164a7e981d6981ae5a2c4773f8885fb6d1b60b64dc537666eead726d0c6650a8ebcdedbebf47d97678857c23ea4a928ff4c306db9d584af676ae339944a4120e4f2eea740ffc0c2ba4e9489512537c9d301e7c2fd83d8eb2e4f1833aaaac949d55ab23f1bf4b5a9fff3874809e3f3b84abef20ae9a7c106f6e6227dd65da7fa3c1c438e4a0b610a507c86b6e6439697af32f699b8060acee3a2e0bd6826571d87bd3a939bb44bfdb1404549e7f5b280d8892be438e095ac124039cb5ac851c416b1f717b0efc49af1fea56efed2315ccbf44422dfe4ac63378a29a97df3af3bcba30b3dc1773beebf2b6e523602200d3e74a96beabb8480dffd9f5bdcc11bc23c250955c2605fed35c5cf032b961ac36aeae93600871125ca8687da680736e484bb5ea76a4b64b51775529e349f4bdd826debd2df0b41ab672f3e12a14d8d9097aaffb5582845ef23b30fed562951521437712da0c3810771d2f57f461a4570caf451354a4037e2514f865fe8cbe3085e6cacd15759a0c27437c93ab378466aae33cd07de10fab51f44c6855e3c490a884cba49f5595332ed6f66f9ceef1adf1ab47749cfa0e0c552215e7d93e96d03b55e6c558acde9d372185f6112b4135981c1b4ff1140b0b3e7094e0ce6ed36c6920d1058a3a031fd63015dd46a8b1ad906aa312d4c4854ea9b551ebe943d38eb0b2211c7cf53c61f122652bdf288dfb8b767e53cbe114fff975638ddd19a7e593778d682b40d62bef4bbfb2d222e1d21ec699266dff18ca725d7189f84c1099a362547fea7934d4df7044376918614b0c3a476905dbfebf7473b8cc7b5783c29a1b9029fda3902dfe89bc786c88d08146564be5a64bc25b163928eec8d59ddf49e81eb03453dd630e2caa2431adba414b1be7f166b8cea2f9f7a8a512a957d64c5c8fe7cd015d4cfe982748a3ffeceed601405840d7eab65ec3cd69279ec96e0128d1a393d74baa23012a34147bdc9d6e551816f2c875072c53cfb169c5dd99da2764a5b67b556d79299024c74f4c9e90837f65fee2a8b5d60b7150b57a9ee88a35ef6f721e18d24c2f8203f871fc9cfe5a51716b1d544bc506ab429df2973f68a4e34a5c2ab515848dde4b088190eca5c87d453595bbdee0bcf829a1097d5828c344c189454a42ac814d4743095ef2eaa304127ef69fd17ba5f9d3eb972dfc7566ed5120d7cbc261e8bae65f42cd3205987d0caf550036ac1774330d4b492ad6aae7941aa1dfe46f9435b08105bec49f93e2002542a5309d4b1f40e11ce08c207c53ea29193949877544d151a88f4ce6d49eac32cada788b2e061bf047d307fd2613dca670d0314ea91c68660d2bc196460ef5e4f41efea125cb77c03b2b3aecf2af7c095862f3859515851d71e147d00830b76bc043cb0e85904e7dc3258837ffa04060305d64dd08184dcf6e98026ca18dd702d34d10e90e61c9a670fe9bd0717d298f8e1a5c3df16bf9466cfa933a13afeed15fb3a8dc293f882e219f834287dcfca1e9b1faa1114f6c658ecbd30adbb9c89e573f769d230c5efd0eee77e637e7b3bda5a2c584bf08d0c0eeb0875b2dc1e604a42bd3338b48aa9d5cfc34a78ac2d0206c127932e3e160326bce8d0740204deadc2b1fc03bb95d3b38a48c32e30235688ee9e6db17b032fc564db2908230ae5777022d01bb0cd9c1a6e6f7ad4d2eba943056cf625b6c840ecdf42e092941bb320c2a24f57072eccc6ae38cd3851e1c3cd977a67a782405cbdbc9b9d684eac189b9a45c57a840117a5c67801ae199dabef424cd0c315c7dd4b068d00d2a7b256a33b7a81de1b539b04add2506a53dc9c48fb47e4ca54484ba148872b8820f9113444c0d95868e0e6eba075a65d57282b4ccdebbf66d211a04ccf8340e46e7a115a5bf34fe733a5383a7bfbe6a8e4efd7d8ee8aaf6a49850e3a5c988dd153c4fb8af9f05a82987de7be590256f333ed5fddfcdf55f3fed15af0bb43b49c2dfa2d1e95bb78e9cd8a0b0bd956601c624ffc64e65f6468185d8a88148b9f31b3be92117cf68222b7689d3d725a513e45fdf270dea748e07afdc960fe4b9381c88f92cc9605056f053bc801c72e7bde14a8164f5e425168894ce2ff43f0d3e853a05becc9eca5a55aef8892e1930775ab0efedc42e1d395bf3868274084d1dbb6a0107e54ef0a225847319bffa9ce2394261ea920589b148f0aa83e0a949b8bb6a4a6043f01dab3b07c1e12acba4204f2fd71387a6e42f12336d6dc916dd56f69b7a2c2b32e33a910e690ee3c0fccbd03b67970b3c603ac656cc97a0da8dcc433e85ae668e538f7b8c4efc6ce375700d0cb5504d5288f4bfb5f9331e3a9b6045fc9c98683678c07f3e48cd95f60ee2e182afad8dcf0df640b822671fa23b57033d85a062fd409ef82f652a9fe48741768a69ea56d5af30b0e3bc141691fc2bb5cb19cac64a1bafd1140a720d1f4c8fe74c3017f432cae6ead1ed567b6495466bffbaa5f058ace48bc75c6590b2dc80007ac9f0d57f95e94a2cf845a65c55a6c6d00ca77aef99f677709d53380a0a5c2931414a23e5c050f4e0da391a48be49206120c9a52d5d11e5f2cdf2b2954e4fea325fc007035dbf213420093d85a9d5a32d9450727b9347856a8cdf7e91cfdcb9ca0a0248a92e1588dd220a40c94f6de2b616c9fd3fa8ff8fde35b18652752bcb7b457fc7210f0846982eebe28bb0c2d3a856b7109ec12957ed196a6ad1cf3d6aa534bab9e8b30aeb90f6b8077e2477bb38044e7ae7d798a071cb113484521ce9808490f6ea0361ada366a784d96f6751c6ba4e9578e47c820d4f8fb66860d492f576c903df486a93fd797d0e1d5bfd90041598cfab0017bdff8b843f10288afeae336254dda3e91d5d065ed32a0a7988d9a84f056b688bd3eecc0edf728c1494c69e3ae02db58769aebedfe13075b88293801c74d5ecef4a229e472a222107c5ba7996754d0a4fbd97071163fed25c9a0ed9d777ba101cb941eabc441c0417ea9b080a5b4942904a0427d687c8553a7129a0f7815760c174c13847825abd76d748719e4476355356e18b81d5b8837306739aa77a432557d1281a3d60b80fbfb5e1b334fd3fd856fb88dae3147685aae381d45788e0d4ca4a7c4654b3dbede0eb44e0c847a0db45dd297883bdebe3161909f2d20d8f96afb0e2a60c8bb5e1750a58045832ebb86fb964fac88dd57dad2cea19911aeb5305e7c59dbe04c72b796e7d710e5c00011525cd30e07f096a2c0b85b41dd8ae4816bcf699c1bb2cb064f1d62c4a97d11c9a415bd97baadba75d0a52d6018aa1f0349d81fa8a903059308e57f96c239611be76b0776821864ddcad751e4f0a0d9300d98e7b0b551e47895df37f76805cba2d04567e9a5467b244487488b47cc490ff8975c252d792b0845a59110e1aa36388c5d0974b5951be090dd7418bfa1705d280b0f0b7966c3c13f6b627e9f4f90d336c23f70e36960b45af75a1570a840149b40de336f3d5d707a37ed91bfe6342ddb9a193f7f56f5a17fd735dcb800562eb90401e502c5f792786550794958b300fa8275e1bf49e7a5bce497e5cb7b6b2e6f6ddf349b7736ee2477fa35d102f525e7a97e46c629b35df2f862d273a0725eff87b6dc5fbe8e4641092a4cbe67e654cd5e18c065edf1e0af69c038a31a3407572c38d6487358912922a637d9a97f3dc87be32c944dc8030a7f0603149901580da032d9b1e6ae60aac634e6fa0e41f9ac8e71eb6fbcf54e88ab0de6047b6a4df8bc1b7f26bcbe1c061a3a22ded03f41ecea7711b7e7ba2359d1879ca2d267751f9df159d99c0060cdb4f7e67d3f251b9ed4636c904b0db2c804b89b08112f9b74f12b43ab5950854857fa0f9fea87ab73d11622a2f8a68ce45f97f58389f739cc53364b766441f7930d61bd7f742df74ed1fc426f1ab7c162a5f781388b05e204202ade15ecd0a17c898c891f0b016d65bb4aa02809222dd86ecd11bcf587835e9e2e2aa19236b9640726e5bf3c347d5be703a6076f81640bf9397b1c468a75ab192eaed46b63d6e034856f760c17b55462951da4bcd5bf8f34546f41752ab6715738c5b434ada2aee676c83724e4f67d7eb36867b14a550f97476715695f857e960bfe0869f519b38c37895ef1f898cabcaca77e3d5c0242d49d198b00175d93fa6fd6782670eef73e33d30003256fdef6283c02a91f3366c6b1c0fa49a229fbb2573c618fd0df251bafce73ada781e6f6cc71f1f6561f0136f641b8c3de9d1b93dd7d06f5aa8925fd5e271252bce5e526f95d35cc13699df6dd2bca65c941e3a7399bcf526b2c1a950a645e66cbaaf5720d9e3cdb28ea3517b0493604b4980bed8a413dfc5e429ddeb8813a4e3dbd18294125556216687386cd1a9f5180c82001b87dfc05b10dee76094ad0b518e6d7dc1207d749a5597370d4a8d82ab7009345078d6f2271e2101c25b5464bf8f7d98d45c9a2b7863f8bc42c8393674f810e6cd667f01c1ad3cf7ed73f67dc93a308e94e0d65026b7c8fcd02c8cf5c7b805133e671ef910e1562ad75887484ac164c6f4587c407810e02aaad4f2acd7c53597fd2deba3308ae919c472659f9479cb85fcda8d7d452f734cced0bfea39bf7901c11dab19fffa94067d599f80283a61db96b0728874344a36e9a53af03f6a24ce7757ec32ff6eab809e2521c4cd07d6257250b04df0eb5ba856226f541ed4a24d3f71e45005552dc98de862ce9af9cdac4859cf155725aa5acd38b692c0b70ae3b0a283cd327f01860379e466a5477defd989d2c8828f54015e1568facf9d34bd22a91bd2b608b566f0ce3605a5a3dfddf473c48d0e3f7333be2ef9341d67b83af3b4999ad85064a1ed6525e003d97bb03f0840116a34f0f60064d7bc38e1c5af8558129db92c90ec88b3cda5b2c39232511b60181c53bef3a041cf0e26241387757bad5d5c6fd2a66e5ed9e0241f47582841399c5a0b0f47e8719f6c2654aa3f2be5e66734d12cd5358d10f88dff42afac24e136be30b2927a243e7149cb3cd3d92061a65b7eab9d1b3b840306efa0c46742d1933d5df653e66b41f40d22d77a35f317b3107caa6e583fb5b46fc760f51129997dd738fe6d0ace848fa99c9d7aa17f0844f618922ecdd98896f6abb98f458943a4e1543c9f00c4e4146dbc3294dfb3d59bf9e6567eed5034f84a5083f66c6d2278e56c5043576b3156ac55af2fc2d04af759945e910981015c17ee90069961f78a489366f832804f6e7ffa0ff12c87af44714fd697cdd91dd2a33bad3b78c1105e87d7fd2b06d5dd77cf393a936c4c9d03d74f546caa6ae9cd0bbf9803b4d8f7e4a26a3f7031d56e088590e16d33c636e7b47ae72550b42e84af6ff118ca1356a90ebc338e200cbdc5c9f2d4b4b176b56df10559c11aeabd8bd299bd8d3a5a3e6c00d300e14680202fdaba04e7fe421af713f6f8ea803b85e87347cf77459f63ec8d23cb95477fb95dc0bf54251c1c86fea0a254e7010b0ab7dc927ed2b8926d377c85e713c179d250f8db0e195f3e19362537d2dec3887713cda1724da172b44c1fd32c594c49f1794b692b232fb6b61b2bb8ead0342210c0b5c298e7e1bcdc0e6dd8f7ac244222ed5ab10b5ca978d0c962ddebee3a7cd7d6a567465010eca7315be5ffa0911240795df47bf2fdccd2a570799ad69bcce8173dccb509f663205c70f25b0a2f1a5ddd1763656414c4141667ea90395173ebfda5b9d320889ea0512c05b224f60faf61bb12be419a2f1d8b475fa0921b8a4c5fe8bec5f5d2fd4b8badf329bb7f0a6205d882ada2987b63d117f24a96591da81197b23a971306d7e049b2c230072ec819e74fa02b5760d11be539464471c824cc5e863294f4e1ce108e72c66e9ff804949c27432c441504e2c0bdc2662123934be3d671fbce53ac4f300a53b06a9eed6114db9353eebe855b076902b480d4eca3cbcb1b6eaa6acc65df64b2fd0ca02e3041fbeb997fd6cb40f1e619f5e1fa7267d6d0e89c555da876f024006761549c76bb2b9e7d3b12327b010535899c7414f84370827d8660eff9c98c943060cfaa9f31f6a528a3fa68babfe3a18a7ef8d0fa8d2b7ef3ac386b0b88bc820c8969a0d692d60e9a19dec630d54921bbcf544b7a9ad31502bd4b47a77f463b34eb3874c28e2548b77dc257360f20683d128f09598bbecff45d531f5ed237a98c6d5b998c15cb1282abc70fce7e339864a1222c24801fa19e214c404f9e8b1ce3799252c4e7326d635fd1d441fd0558733388b86a1b45116604a66bcf60aef3418c78829a3032280dd35e14f89d8eb0798d32b260a07790dc95a1b5a9a9687dedc7774b64ffd44cfaf80c345644f0990f0134cd4871fca8ab369629dca85af338f3c20cf1c545467b3b64bf4f2d3fd2ea12a1498e7f458b367fc475303400008542673b22dee47d290c29f1c6c5083996e21b9dffbc3ddcb669c093201708b942d7404cf7629e81d312ec9a05ea89609df32b94c4acfa9a158e2145f5c82b74be1623cbcfc5d51df5e0217801544f12bb27b27071e325bd2022a625abe2687225c670e6150bcfb27610e181e1266b1e4c35f50b8bde244dc7c3125b84adbe05d069b896c8e29b385560490fb2dd899f0054e2e2bb5364c79d2c476645f2b08c3557594222f6f663c8be04b8242481066057d3eb8e12b82a94d33f1831e148c94298fd36b4f80d5bfa875a9c5b4d1daeaa3428fde80cc7ebbc982871c005ae5baa593360e8f68c47e8b6d42a61ad57bd1915dc59151f133436c1d4f8b716cebaeb6b2552ce2192896ff394db422430b578dc536ef6f26e375969f26209769f25ea24639e130af6e6060257c5ad832b72bc3c7f9024c0b1915101eb047964acff603b6bbdce7739916e8d8149e25b68a89b58656493764705affd6026a2631f76b03105beb2a45421e7b7fda982e1f36b1d8a1fdfdcf756df2c3e0bcb5e24f44660275ca60e263f8316a9e795d16afe00df3eef171ad9931340ecd478757be78c20bcee979c9b4ae732b0f3d432bb1f86488936f614413e071269e59ec204831e9236401b23f32e1c81fb900e48dc6b99391e59b1d7f9b306accde137f2ba9ec752d9983529b6e1610509d1f05102e888425a9eb63fe3b0c4614996140267c94328bdefe373aadd7b3168384613f1df8f111ab9380b0073e7971ba86c853f6a61bb65f24b93b214ecdc90ca3ee8a9fe54a31e850cd121a12c4e84a566248712a8b5cc2c1f282ef80891b599b68d9bc121ec1b6ca165b4cbbfb9adff4133dc7bc12b40f47d2fc231990ddddc6194d7ea61a9c115cf8b7db50421af1714601f9a515985ec9609bd69999fe89b8f78e08a74adba64be03530ff704d8c5b3122fc772ac3a6aff299524ef1471584909a72c77851021708b9c52a323029f1de866ea72902cfd32c2e55d5fbb83fd69e24a104e04eacf249297f1460c217b51b7475978a9d2682ae3575aee8a12d5e91bda3657ba22126548c997dda2f07deb84ca42521b2ddedbd7ff6267c4888a9a57546b8ba5ba225b3f59fd4629b6b999623d81f108fbb911272846b27c8245e0c42c492715f5a57a21837d2060d7adb3d9b703709e66cc6418f9ad33347247052ba593dbf47974a8049625eed716579bcc35f812a2517240634ab47159f6033a26d5effe387279e6dc5b38c30c03074d18a87be43eb901c0267ae07bb6d532a7d7a685e68a9acc7157a809daf0f5f79aea7aa5fb547f5a5fdc112566ee8a003c4381b9e7ed641a1c1b1e5406f368ef1390d5fabc40a150f6458367c1f9ea31c7ed11f4f65f3f9d3a2057f11b517691b54f230485ca3c8111f96e549c510ad5434b8b0bd2a9abbded371c0d25a909edb6756cbdefb19022f9b8f7186ad02ad6bb80c2bafe3e504df80bd3af0bbebd8bcbee05c0e3ae81f5bbbd9592fee9c8a8e3edbf48f042f5f4015431d4b0b62c79b7f667c62f7db44332e7b04e8e4268de12add30e1afab6c8af41cf349bd75a429399f5781c9316e7a3c6f65cac8062ec021ba8ccc306f396c780df9b21da6ef70bcb4a4d4a4d42ea7edd8a73b65190010bc027d390c69c0d1e582a90dc57d0f3f785729345b5693dc3463b271baab0d1958ff36ec4e658c6d2c6a990c2e55b7d4ee777a84b651fe6b2105a9204cdbbfda36938641bd2d362d15febeca63458c80f483d2b573f8d92f36bf1a601f71d081b597a7777fcd0e02b996e8c983c08e24a9331dec90cb4058a77cccc41be35362e686c42404880b7c837ad6e68ac5f6e4c8b0062bc1b3414c48680b03d44bbb2f1c7dedf1041bde720c23aa1e2f63d868463b01493f37472618261e2cc15a30711cb76fd5f9001291d76bd7f44f8e8b18fc828906218e82de6c2d8d6fd52737843b285e62dae79d750ef94522053c419b51752b0e67ad52c1cf6db3698ea87fd4e68b713478dc6fdf35fce12bd8c515ca3fbab35dfa5321c64b56d6cf86bef2ba6df17286d25e5ceeea215894d661b43f080909aa5754d10ff899f9fc1fd7e8ba813a73094d3b1d466922587285b70d100e41b896acbbd2cd70b61b1bc46b63e6c6d5efd45fc69cc6d6604bc395c3114c42db24d49dc374fa364d0e21bd1fc35367279d8cee2ed8815dcac130ccf934953ad665452e07aa00a6494c0a5809a6387cdb0d2b7f9daf57a12f1679d35e03f2910e84db2148ee4f87ca18e603d15c5c247cad110328f5165f7b3805ee51ce0ff6fcc76b3ace361a2fd90c746fccb33859e0737c1e4c07b91cb9721ec077b8842c15dfbe8a7e7987f4cdd113cc76ca6fb7e28c3b440c54e870183f0e1902106cf6d15f10111eade1f8dc6708e4931948700e960acb4e8b3e047cf2b5ad29df509fb980ad49f1bb8d6d54bb5056361f00f50a9c964708480ce4beabb9b6278ef39544c0768321198723f8e16134d0be8cd16f8966af4250abbcb21659dafe8bb687ebbc8f483f9381ce5a83d6741e9f3bb24c3c97c2422dbfdcdad66b9c26cc15340b6b595240ca853612f2097e0eea04f2d92d4eeff22401dd1ba67859fd747fd823d883a0a643f791e0f70f05be54e446f7c7b5406d8f877f3d2ceedfa7fb76f8945f83349019c7b19688441da282ee7a8ddb18890078b04d1663a3fd712962c6b2b9839e5b846762a1e9909c38bd342438d233a79b906bdde1a57bb8eac4fe0d2537580c335ae79c48f4f9c6d0a8b256424e3160535c46fb25e82a60655ddb72dac1b39ee1d1427ef3d3d6c85d48a4069890ce3bee3b777404b1c4fb1d4321e8de9e99aa5b7abf1db4bd494826bf53a9b87b0cfa4973035ef045215a1919939ebe96a5379cf8a8bd9d9d440daaf68b4baac7d50eed9528b8cc57cfcf2b471558d5f27aa54bf2d0c07edba4a678538b869a37be24759bec8cadca3b85648812fbca0902804d443659a280152687a537e769d28a998d53312cebca454de90e33c76f86917e0bd2ec076bb069518ab1ad92b4f34dfb41ccb49dcc0bca637a0d70e0937293ef6e3f212fac15d105c330bc75d78f57ece76d46a4202c59a13c74811e6a843d3e230d1fd2464e3502554581c8bca43f396c918aa48108eeb5859bf6ec2d87594b0be469d03d3c972910863199923a69c98e06e89b0c36f9de9eec4fc8f259c1cd0f40de2be85b2ad52bab5781552cb9cdb3a60029d0ef0c9b6af7c4f2623c3c1ba874e517e7fdb6d955c78c67d2900d44a5443825bc41b8f538fc02774bef0ea1eb779c966fcad4e93240819b83cb20ca837fd25adbcc89f1b63ee0cc0a481058a62277be977b50b0e8f57451768ae85bcfcef536c52f40e8ebff8041fcbfb22b6d5eef788813f663fe5ad2d5c21a448a7eed122f624709b8f94ad3b0f632d46f229a3a53757ff04e0a2e3586109712aebb11fe1e95d067836b20bf6e9973efa46c4ed3eebd3f54f49d72cdfac419960e913cfc970d6606b63610a7cf6fb0ef04cfed8a16ecf3998bed4e15cfd596a2cc1ad12250b9b779d4da3a516de7b33366b657621b01075a089c79a51289a2d481a85ea84e2dc3cf31e6a3f6f488d68083d83940eb51842629c862185a905b84ef5aead86ce74f90e6a70884315d2a48322814d6c27d4473402403b31a9208e086ed55dfa7147619c873d691bbf89bd5a013927860a8db2d3c38a08ebb242bacf9b06c3e26ae2ea42b800c8f8140c34097b7f122b76bdae59144c0f6745f73cdc8261eefd3e384779bcbc907918f45fa567b8701256610503f12873db31bb74580e1619d00d0080425b6a1e29f4647d9b526e0cdaf95371f1fbd0342340b76b21904e84cfccf49aa8adcaf192f4aa36ab8253c84da2626582c26a4e9edf1e3db6b7eb3be5edac2f2ffc72a4259680fdfae0da2872107c3c91b1a537bc3a215d72d4a7b588191e6c75d97fca93f61c872412255861b074c71f25e96068cf04355c5e18d61bd554a7d7a8e9285ff3bcc630dddcc1245b71656a4f145250367be485c6ac95bd34180fca70c67d9b7b823cd497d719a9030a2c1b96b52062dae1353a917d3c8b4c0075382a516e59360258143744748a65913454079b3153bdf1ea732650505800cbb1bbf4cd630b2e30c74e3333c60ede8250b88b6b621a888fdc8a9b8ba1c3e9d66f61aad6da1c96da01648705fde29b982a47fc2d73233357e1444514c37508534fcf28139995ef89e92c346bb335e4130b1ca4e205df29464070ac6292bd1bf00f442e2e313b6cf82ce2ed06988ef8bb429352fa58f50bf8859505ffdbb908e548872e8fddbf9effd842588e5a6f36ee209ad7b2ba995ba5fc8c40c0ba9a494f882c7bca7e85fd199da9cc4ede44d9a38e2e2e55857d55a8fcc9a098a695cf5ff9d7e896a71c8b862d11f80a49dcd5f34fdc0a40ae13cb07c0254b661ee3bd7069f80549a9e6bfe6370fbb098f13f9ed8defbc7025d56945ac789ead4946026495baf873b2608953e484e7be78729de27e3b2be2a3a060bf615514d3bed4bd9e068bbf90dc9017b52398fb53eb8824733a396f22b166db644f45fbf86c870409a4c001d80046999d64498d83d9204d305c0523cee3e53af234f0f06d3e9ec2e5eda65d7e2edcb336ff178b93f191e6842251b55aa3cf66ea5e92134d588d17c657f0384fd3d4e770b1005688a54d3a1926294070b8a2b5c9373a1b2994b51353d0ba0d4a2016dc68babf800a442279f1e5aa6714d6f653370666ea8cc5a07d6a678274bb1709a69f93eb636517d68cd4b7d7fb3b23f4d8553387ec44f3facd149b47b1eb9483b70da62b6f82587c2b459b6c9529427b13fc064484f294d5b829a0c4858241dbb558746f0ea5328491cbc80bc5a1489d0d72f42e89b44f0605093ef158ab22f10035233e78ef54b303d24e2af7d830f0799e32f41717bdf591e30810d5d1eb44a53f72c1417c9449e42c3f5ccca01e70d46dd9f953ef17c808c6680524ef766182c82650ffbdbba6d095cba4eeb878e9795c17d0b3e0284deac0c5faf70fffab3b01567b4893bb5a8f22392e46de274d69f2f927dbe472661472d79e7acb7068aa656b48a19778929ea2255e95ec9c699fbe43b67be1480f05beab5d429f7018f9c482ef6c00aa64a41db0c04cf7b20437462675a5b05694a0b6da0d09a348f2bc05baeac3f94e591c10f0153d95da6782e8f35977d4e410c5ec3484340acd5a72b21d58362f1257162a52385506f532c831417c558d9d4432b3119a74b2719424904602cb35c0e1f61d3192f7a5fd5b39243def49d975659ab2b7e8bd8dc6e241acfb0f925d58c320fd1856853b7082776d7c54d6eff21995be1705ff5eb29c5eb253fec355684ecdb055d8fe165aad4e51cdeb4734c7778a4e68d7251d21dfc4d5e7e0e2ae2cf4de2fb229538262ad529788c9cf7c692e2588bd305ad8a733169983863a365d65be522b30028012a52333f90463ae2f673faa4054acda3b389dbdc8c081a54e3b3b251f587bb1cfb77d271bc2cd46cd9fc64a8845ebe1b2bc807c1790c210026d5a98d4416e15cd2668bb6fb68be2a032c577a460ee0988e02f89facc644aa2fc607151f9bac9ac196ca86a520fb1e812828c4fbddb884c3152f5ce70a7b58f54ee8858625e091817d4e2a0dd693f461c851de8ca3fcbb5d7859a24c09c3194245ffd8e38a3b6896849c46b3db6ad22f217e6442e94f328969c11d5c3e1dd5f71ad48bf96ac2d6bfebbe4100b6b4f179d7b620b5322a8c42635224100bfe6390d7476b1bed3fa1de736d2ccc16b0c217ddfc644719112794e50dc43cd6adc5b633a4a155fa3db0ec32b6ee70c436234d0fd32e9e7c6271683644ac9b11195dc5abc160365e1477385f01e7dd5b158047e5c3a4390562add7b638603fca605fc0d630aa45882aec6a9e5b9ae4e2a6ab95a6754d9a1940fc7f0d8ee043ef7dcd7817878c18ee353c94734ccad69a527d537ee4a6c3f1aed7f72723ae456ba06bf8ac4ffee0b1fff15275fab28894714a6c16c8d4f2eeacd0fc95dc61441dba522c2cd7f1137c4f8f63263280612e821a12154e3bcbecef29de68c99b69b569537e76a94bb07c12f19949d0503214321a0034b19fd67d06e21cdd22edf63bb5ecb2a58319ed6c6a2a898243fbcb86fef5ab68acfc490e2f841e935b25c1040b5f83867f6d2cf10bffd9547173eaffeadcf7bf595228222f8c5365f49670001327a743c1290dfb1ed2a5ac8d5540238fe2aee71905a6afd766601d0bd852722f5ae2272b0c5ecab8763a78446a7cbe43e06093f6f14c962fb8c2b3955600ee6bfd5bfcbbda66febd3ed4da2d73382fe37e1e88067561ab8986a1efc8c2d55d94f0b6b160f92b86fc948a9d3f93abbba7048e20bdca599907216e12442b54a6e5808a842e39536d76207f73804865083c85648dcb254d63cd55232c954de6e912364bd5a9f839db963de4a73874c2a8e83e2609a2e8b2458b015c806f5cbda8ad900b289748a090cf84824f3723456d8780e12752fc24ced31b4af69ed2f4669e935693956f567f6b710c39dab44b7b21953a6ee1d8ddcdd9f79da493f944cd0a832aaf9df67ef82a1e217203822b92403cdbf4e84f1d24aae0efc1e4fe6712a9f36ff2d0c87811dec725888361c07a4545a672a2d263afd57e4ff42ea03c8a396bb295eb5316e1f5b9c9e4933b65aa278578bafda58b469d933f5cc22717f7ca3e945f077b7e2789f7f4343dfa4bdfc4d538f3560c30b94ced0371b964f1662408dc9a05f68039bc5214c379e801d07d9e9579e8b653b4d13047a1297ae6c7a6376dfa74c4e252fd876404c25a25deff36d9427f8e65eca6cbc92928edc0b873e1f5df2d57966941479a3a4673c39ba0884856308352ceeff0739aab650b5a897241a5c464f9b12363d56ca0254ae63df02f1ec023858e410e9541e5bf3c8b28b17cb7a559c0d1c052192bbe4869badb4e3f0956bb06ce03a119290b42f6a57d535a6e1bb6632b75b2f991fe7736404065be82164c6a2e74b189f068033a72e5acadb3e90387416cfe69d6858f34466a83814e2dda791c479a8e077333d78eb8c8250bdc3f9d0cf85248515db8bd490f9b4a0a84b55b0fe097e3bc6110ce8a32c219a43a2c47eac860a0b887b8cd1fda5fc0185e53f2e866a455e5ddd1ad8f86e89d436b6493d90c5d263876eae1277ded0ee9c055dae46ad91635d5aa19131bfb6211a0d8906ad17833be6d9d31561f813eb44d3140310c3628a3eaaf4afba3450b60a14a0e8d733cda23b109d9a5c88fc1ff009ff6f661da6c2efadef35f3ff62f1c42620341fd49e2e50e89df098f9acdc6c61f50ea9e953e7b0b301496a4fb743a2d1658c76bb1e081537704f911dd88a964f74e8f81aed69f4584510be4e05a6c1627b463c88f7d98b7c54c142c781c2b5b6e593ac48918e7527aadb551d8af393dfc28c4ccf4e17847d019b55bd016ba437a6b9f5f965f36211c870cab0012f6b47732bce359250b4d32a926b6d7f4fa55752f228ccd5de938d4c454","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
