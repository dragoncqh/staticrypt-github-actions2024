<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"381cda35ac70b2a2b72bb51a9925db74a173fc882421bfca784266cd53f1cd3dc73c43a890de5c85db5e9ae821982224a47472d98848c56e1d32de7ebc71e5d352ebc213a94279799906e6440a50f9ea07d25ee7e645d53a238d4e388c87785390446e9cbdc8dc86d51d829f48525ca5ac96f3e0b810d6818465939b6873e7741260023d2690e6df08de5b89909fda6107e49e782d77475fec023394e4a88dbf9380646dad2ce27d5964b9c57d6c191a456d34b5a72c142ec9c41fc0ece31181ac66224a4bf47d4c4ca18bcdfd890d20a13ddb9c3387f168b93951b005eada46a3b37f9d821f28c806d1c6e2e7773f511f3ec6ecec0ee0e2e892e4d861299c96d9d6d76ae1a359a59ef81c641790f8e42e958398fb74a19ed0a3f3e7d9eef71c823543beb34bb7a48ca5f2eaaf47987349c3c7bb053127e67f783b2b368fcc9b11c1033ea2eb22c32c5d490cd4b67c709ced10005aa638e8223fc2588791eca4cb79bd5027c1bd1b5449bd9f84eede385b6985ff97935a78bc7380e71aaff757155200f668fb8a6e6551e25366b46d34827192d000d1d26136ac369507f39b3866be756098d40b8d0ea3bc69d445cbc63bd8a708fa006fbc711dc6c569edff3c7aeed8ebe414d9b11b4a9748ac37adce2df710fffbbdc5ecf5743aeffe48c104486f06164d2c538278ef3953c939c2de2fd010734ee7e6e2f4cd65cecbbb18ff37d34e85edc28d5f92b13e96e0158b7880ac8fa48d3edf6854fa0472c858d92963cc3b69ff2e070e349461d70d0d28ffd3260b816044bac5d9f3cda87ddfad967eeb51eab3b84c4de7e3efd4e4f850d4d53937700d9c59e5376a3b83808b28ea97effa995ebcd079881607039d329d8798becfa836b01cd7e01adbfea617a8d1612b89878f054b788ceae52c50ec259e4baf9424bd443825368b0770710482513013fd3f31ae66813dfb482e28f2d8fba2ba50fc8c66fc41b0dd71a73373ac0cfdc4f3678f85b33a996979e4bc7188893c62f62ea878a8ba9f52afae4c8ab1ca2a51d3c7d3a631716de86272b7c1491bd8ef170e16fce31f7134542c65c485e491452558994f169266c09b7adf4a14f09e431f9b5f156e4647e7e04c2baee06e357b9025851d160c342754ee631b88966e33879eaa0cfe013c9885cf3fc0aa19e5f153246d58074238de8505c8e1f16b98183d9b9250ae3ae74fdd8ba5c0e11de8dd37228d7a2414a0d3709b78c021b3e728d4a2629c88b17ab8473da37535f7549a53ad4516c57c1ff4e1bb9fa6ee71338cf340f211ba69ce405ae76650d5473f7116719a7c24233b8800f59b5918dedde8cda71de4a117988c90d0e7b48510e67aea8deec3621e47275591e881f8f36d861819cfc21ceed3685e14a7c3f5f2fa1e3e33d9d7e3bda78211d34affb16a260e9c18defb5fee1b1a0204f1834d9969bdccc7572481d21b2600b77e27a8f21347f3017a128deb3ba1b577e0732de621d4b5cc71dac19969d0123cd07fd3d1bc7120510f630b1532a8b1c9720bf30ca9416c902966366da86b481e8cd2154f2ae302a34e5a070738610e519c9ba61c2f752f2109598aa78014ae8fdeb07119f76b39618a07b018ba679365b2cd377ea97fe5a8b8fb37614de84720adfcae10ac2caad386d9ade5e1d03bcf28d7fc717447bed3a4259b845654e6ccc8dd79bce54743e540c15eea081ac0b532d274f60edf893e8c6456586406866821d59c3b80070da7f9f017e749b2944481539664a477d89a7062ed33d075bb4e2f004f934fe234e2e9e92f9874c7f6053c388447b13f33beb6938dae65d150ffa3d25cc47ca459bd8cec5937c5705521ece8184dfb29ab62bcc9c7ccec4a58de7375b5a5bc957acab2648c049516d7d95f1074df9f3841af07dead168d5bd86254aea24728bc8fe5a0212cbd99e818f0c56492f09d5d6020236f2ae0f9d352fde51a747f54dc4603b2f71a61c0b2d57de1215769f1684bbf01c20d1740e76a55118f4df4b0d55cf5b9b34d4d10c08794cef68cca223cfc3c3e06e277d393db1fa2b6c2e1050315a4b329a96fd18675862227c8aee02fe3142a6351a53e6f191d0323e86779cbdb2c682b2d115a9fdafbfc0e0aca0b5e94986efee6b3dbbc9da43e583cde2378910d006315bb35dbae19d0268d754555c4d85e3d9b78fb3d5fc3ce842792ad80c4e355aab20a5b495716755966b47f5faa5951dae1207e010094ec56d80064ce893866887d8256d219098338f01dce1329c93e3476b7b54de4fbe95cea145006bbade2851c7c782e156e44ce0d26af77ac7e39b01ab1cd6c71bacb095acdfc27520d1460c042d1c1bd3163173812d72b490c601c811fc90dbb5627bcdf8e43d43aca6f4df743c891afea4cf1519a2da09855f50e2d15e5c426aa02e209578a32c04281f849875dd2c5adfea5f13d98c1c9fb0bb10edd35ae481bf10be6cba9d09807435e4059bea2b1d99dc83822d19574e9b7e0f44794de2b9b5a6884cf794f30e0541b1876818906ada59ca38fca3469743e0ea03ab8a507da5c9daf041a7cffd5063ceef6c97040f3ef79c116189dacd6f7ac75e4fa70f9b44e184db84b1bb4ea7648843f86692cfa2b683ffb32752913152a848edb4df8010f7ef84e67812b5c81d5b82eff0afef2c7c92c8482919cb02a0cdd72dd4c9012503c01f8c6fe655db06f5cc19157f628a732a63317c85e13108f686ab1cc604df6cf17b2a58387c044a32accc1e39549880310ab87e38a128cea9f6612ed7fe7391103e602cee98023fd9022cec1ab9e940b7a923c455db6fec639c1a17917ca621d748b8d839728d7cc63a9b79e70781e552eec64e2beebd54fcd52042508ead7b14ef9ffcbb7a0baaaffc506b2170835fd87fdc125e2682c89deecedb2d3c5cce1a92224d16fc94f78b1770658364c4de9a08e7f62cf8bf0697218756da10aaabdd458f0f098474f14ba8db47dbe2842e6d00c0e65ffd690062cf49d4c0209d4525d46f661fa7ebc641b6ed9e86e9ae3c92df7fe203a78ef683477d2759975aba0255e7aca8b2da7466001fbc1cc4ab2edd6596bcceb02470d8ea7276262bfc793eb2c9ff3d04234566c41449f1b33a1f0b459f3995139f379a2c5008de6189c80edc686108c96677523ca30b6046c2fff9890fbe43770f9e23796168b1a859a31f6fc6a1925b6f6ccfb2f83a4c23da37d3fdf4d10e338148e8ec0f2a610c95425425d93818b924eb3e4beaf6b01dc0d552c57d54a800f70c6d093cf0a5648b7bd2248c8fc83f03b193e8b7142f21e5f94042bc340287adcb9eb66045f8a2f08982a568f35ebeb42aaeb390a7126989ee8d19a762761a77dd52a609e50df3c08b53a525689f1e69f978545d0fd3a62bbd680eb320e640fb2b153c981362126ee8b63ac49bbf53a68c0dfd2218c654b76744c2e12db29bbf77f3e3abeeab51029b93fcb5e56fe91c6961f6e9f7370e1f394e18acba45830b1d36d73bd9a04d64788a339fce90f928ace5013f96902c2893bbae4ab1446e5b1164914e87cfe7a8c803c6dff52e7d8ea2fbcee669266499ac39fc9d8936fc22616bd3f6398ee25f1d625e08f2aa63db6a8552e829142794e71afd062c4e16c57a4cdce08480bd1f769cd98eb3a4213a6a74a5e13ea25c5acc78a75aaf3acc5780f837219662e408bd6688f9824e19c9116ac9c73206a9cef2235c7135d0502e8e7247e5c6c1d1c5150a108ec7d0ea449842253ae3844f0b3cd657ea8dae645d51c6ae9851125ad1ea960ad193d7ac945328559890416a7075e69a9d37a9075ab380f683763ebbb76cb7a3a79f3d37004bc13389e604ffb01cf2d67b5b32d45d02e29c2b765cef0a0591bee8537a241e6c4da459b40c0daaf8ba26bbd78a214dd4ee75f3b7adfeb5cef6e75449cda97485f03fa792c94050d88e6258b4c28807e4f64ef460aeb16547a3fdb6de7941896902a4d8da2928f0ddd5ed4224b408746ab9298ffe61c98b9a4e154a14b60740f18851cb3a145b440b7794714e336adbe07b5fb0871f6893b9b149115a169272d6b0363f763bf3f36a757dc7ccb73d1ecf115ee61ea219c9a3ff2b63df727f57c0dd2c196365e4307a2471c357e84a271fb03d6c2b2bc973a3529eacc898213380fa0751f2a229475bb2ae0b20e9147ca15cfbf0ef7bb2ffa631374e7bf3c6da8e6bd2b01cd310249d6e94d599db33b56fee12d2cc287ef871a4864881bac0e1be0834561c02f85bc05347986b67d758da845001ab11bb660baa0d0514fc665ff948907217b876bf10187a83d5ef02e2b44eb7dac40bba01ff25c6b25706134b33069a5f6982fbf22d1b897ade844dfb4fe5e1b0cf089d0ee0635f372301cc66c3cd9bde80432a88ccbcf3ec5f3559e5b53aacb17bf5c0d9b2980acf259997dadd6e312847ece4fb1e5b817ff31805d80fda97f09e1355dbdf1fc4367ea6241b8cf855eb52a50673131f24b1994075269e0fee229f6bbf16e8277fcc389b90cac4475cd49c92811e7a784609d66477885f78af8577b838c9485aa46ab0b26a38a6a00096cd8c9cb22ae5647a100fc9f38b6a0f03b46ad90f32ba4c4f8108e69ccfae4ac42ad3b7ef02db2fc4ccf10bec0aefa1a13d3f318239b53e5b733ae4880852f5fcbdfa197c7b7d65ac84a596ddd683307dc5e26d307c98edc5c9eba8d13093d978dce7221c754f02b8038874d59f9f232e90d138c5924dcce3e4480c2d259ce03cf8821e5d139adc3fa59e1c67b5cc18c36b7e90081efcf3f9faaed6a31e2c0eaefd2864ae03c7f2bdc87c1f117371d26c50b288cc5b3023cd85b9ee999dc102ee6ddff672c864ae5716b0e0d634eff7b7b243fb4da89b29999e3562d8dbc45cae75f08773482781f94b58fbc3d1dba31fcb0d9015bdaedd4c1713533234c174521211e0db99a6a639c8e1d8fdf8ee0e05d45ad31cfe7861f621a8e2eb800fc8da41fe4b441d69f0d17c569768a234514a44f77ea19fa5f03f0068b3e59cf11856732d518e2029adf2851341ba93cf3ca72ab8a310244a919350c797ea3a9f07da0840e93077060eafcc7d313ebb4d8e29256d03a4a2c092e3bcb4377d75504184d75649137061d848871949c57110c7bbc415fcd030136281af490f46c77b554bd79e5d5af5c1ac9a667023bf2c432e2f0b3a89b61598c554be9a32ed8c7500aded9b522c662b43a554e772b13c91c5a53b6b644a7b27fbf595f98ade7746589e156a08520efe948ba8ccbf4722ddf7ef691c2d336328e37914a3d811b84d2d74a0b5ec2770f717fc177b5a87c811bab55521ca3a932694012886f3c30d650ded9bd9d96f982c06b21e5e2f56cfd009c293f10fe37d8c324fd38339168fa9ae7d3052702261ec10fb4a2ee4434761f24d50d3ecbd914ec6bf244adbbd36add0c7eadd642fb2eaf8aa9db4f1818458c561b381e29df5193d3e88c4db471fc7e861fcfa9557cc849315571b28aeef966a2b28f83d9fb7815dbd08c260a8fc0192b8e9493db6542b6bb1f68af381a341ba7401821e7171ab68849a9d90de0fa457367aa53120509bffd9b7d779687a396fead1c1c45314b4a917c4dd81dcd5286969b0b69223f386ec50d875c1a1fe5ff724b3118bee5e62227cccedfb4e72cbe76043d9ee1fd26905aa8536bc382b648dc0912faa1015eb3c05859f42673a785f4b532f50cb9e1c9bfd5ff9a2280385e0e6e4c8d67dcaea7d266830042f5b678d264c662c7a77b4a9ef57ae3fb8df461bef22a022dc74ffae5d0f8dffa1b58b5fd4f1f88b52a503bf3e7d13c71458efc35f2549c5d6d67080f3458fbd693cd32fce10880853944da419d3436fd12eb95ab5f30f75e817c9bffc3f9ce5cacef12a0a3b7d7c29ffe7416a54f1d90a68eca59b70675a6fb81ad714c5d1bfec28e5e6381cee9fbc591c2f7e7e7664078c8b4fa0020a081972b6d6273b1b30dd3deecaeeb4def1845975f0de4559f763bce719a2d999163fd9e5e5e7d215f4cc3eeebb26d6828ffee7b53ad15c67a2e6f8621844fa76bd770a19d5ffdc132ffbd04a0168578fa6287b3af59f744b5cc0752d76235021428f3bbbecfb947015244fc3042de7f82b053747f676b4e7c7dbf25d28bd8632ce87881f22aad2060f44b1fd6eb8a890ba4138393fcced8ec87cbdaa36ddec3626a41045917b80abf7c2cd0a7c6157d9f65b22e10ce4d40e7a5635f654aa0f4cf704560bedc2d75174c94ea002e857931d9cd2f4afb2263b41f9094553e66818d58737ee2bc7e458706f14c06f7bb7b2a9d2567fade8ac1e88f7b4a2ca3285c9fa8317f2c44f229e6ee97d79e0cd2519f7ae6105158c1e989226b5c04427663637abd3a4150b078d410d7029a62630174b8aa9619edc6c33faa3c3c051a1535b87c38a5ba926a363f790335151e33bf85f75eb5e600d342251fda44603011bd45069859480ad4b296f72d463968606d114469ee71e0fd7033afa91c0e460526e566a6d4b5a2c70ebfe01f1673ad36f32dd98bd599b897e7bb075748382a9c92830b853d1db562bcf0b6797a47d5ace00ead81018c1825086bb0d0f42f465e06aa491b38387aa4a702e1119570a5336821d13b7e6187daece689bee8446668e1598056901590aff7dac672b12cba176b86d70e11f77643662bdeccc15190ad568b93960748958746024c08a52508322f194cd2ef92a973bcb85c0419dd175a4b54bdc6a5412adae9d9c9b4bd69a9a3dcd6aa089b2e2a6afb23560d673e29872c74f80e137f1360cd8788512477bcf5b20fcbfe0d184baab7b81bab3646475b5a4cbff009444fcdc178cdd0896ac664d0a5453ee16577c13aa9b5d5f5a9c10632919574676736958647020aba26f94ad0716fa476cabeb515227497dba6f9d2d8403c92554dbef92890f182ca9d98b855ff2109ccfe6413fc7696991b388de8f0e1abcca0bcf2f57ef37d529db32ee28f486466e29b44beba1a2136b660c7a0479be76a4a33c642e72117523ac40fc4db728b1599a2caeb234df09e94b6ed93413e3396162809052c7fbeb25ae998425850c17ce289e767a3a66970b72f64f72812014536db2260f3c58ce5fbe2e2678f2b5411c01f0d4f43d0bb980c27c7f1258c27ba2875db9df827d08e212ed25ff192ab49a6ce82e40b97556e6da80568c2884b6889f13e8d713b319b6dab088b16cb03ee0b6bce58401985ed422fe6221b4cae2949f70ab390c74ca357b52f7b8f29462985e3165ce7f4413388c9aa7115f6fd827f51fb775b5bca62d7c5e67b919dabbe8ba7cd388f9180befda1ef7e587031dc54aec1c6b36e3089d87545fd91f7063cf959a61758723d3ba7df4e3979664d6749f6ad2a0c46bd661ff5f628205abfd7523125eb6b18719d0166cc195564f1542c96999936ba304c52921f289065f647dd4908aaa2a00c67316780d169ad1da69e767dfbdbcf0b1ca77a1f5a3e6f9db1eef9883ff3a7b51ffffa7f4043d331b5cb0bfb35c12c9b1fd95d739cdb1418950b82a41654fb5930024b5f5273011f1b60e18d908f2a141ab934d5fd3140f56be08bca45f86a016551d46becaef2354775a60742650fa25d5f20b9758d9c23f5092d44126a92c81ac505ba237241aa3d858b2dfa790f0d7a97beaa562c5f75f45e92ea182a78af79b84acf734c3f377015df9f7157375206a42b7af512118f214d134a5a88c079a20cc994942d31d29916b5bb54423cc5ade888acd74a8c79f3f3b1017dc5079a8da550d723028ae714728381867b48f10f4dfd47fe929c4d40d7a864d7d069e2903dff2f3b1b76f9f75e4fa322dce97d7fca9d3096cec8af487cd425012628c32d9d1cb76706c7e4f72490984381e98a692f7a9f6640ae7d89d892174f8ffca926f8ec0f875be0c97bc87d5850ee70a9681be9671570bb187861a08f27f43955f8152296fd008ca57ad9d126c1c5dee0790a909b853182bf362477d2da4ff938a557fca16274914716bdcc5784d215b34ad4bb8c1045e48cafacfb4bd9133f49479dd9f9a61841f0613acd1f95b8798fe381b757c09576624bfaed5caf3ec89754d182ba1b812009584b48d1fee4c95a5a4298330101b149964b7636f24f9eec2dc94aa874cc7f2b612c749f7832de0921be9f1f415a1c24685e2fc874688e7a4b679af82fb954faf7db9733ca3eb34175c1052f40022b64607c69d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
