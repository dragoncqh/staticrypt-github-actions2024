<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35f16f00415dd0601568e091959018acb622e06e279523c9cc9ea614eb2efa6e203684bb0371275558a935edfd380a8ed1372001f1d691570e7855abb2495bebe8da75c783746c0b18620f05c38e262d6515f0a196339f8569ec52e454ceec9804d205926cc79aacd16fd3465c3086f9212130a52c8c85a7bb5d633aaf9730bebbb9f014c88ff7d860f956fd73562803655f6232089f727d24492a4b471bee118a06fdaab5b06543ba544914a73dd5048f19eb3d29f8d3a4ebf9cdb0b80ba4ff51bc63122b5282ec43530fb3697d6ec7fd2b1d9db484f8c77fa8af204daf4c80acd6a7201850f76720daa618ee72b2f2dbf5c11329b58c030e72b477510204bf708040dd4ebfbbb0bb438eb18acb8471a5373f8ee5e1fff723e9b6d668656c182529633c07f5717ca0ef561fe8f898e60747c5f5efa7f477ce466c005d91faa952349e4c3d9ec5e1f099033e7f671aede5676baffa1aa3f3e5c030f2b2429d3c4483bf8a9bca9135f95ff2a1ab5b9a70b2a3ac1d116993b4c08425685b7a2a75f13bd7224c28269f914d43305aa929a33d0ca1e1c5dd0d0a63b46d09926581d36b0fded54f84d5becbba71be5ea4f0ca800fd677f2d7d6b4c91de7f8589ea62f0a06cd4c114d661fa2cdcd67bd4bc573cf4da264bf7a812dec77c826f3978747486770a65ecd029680cd2bd193c9ca1cd2a1f3cf4b1477ff7918a14290442d81edf68cc635363a87870af4eeb06405c69ca2c01768ed5583812c920d21d5640478670d10d7676d682b193d09540b96b3f7250d642bfea4f0fbc6ceeeb555db1964e3fab3b4e73faefdd0205777855b32b1cd778933ea9d46e779b2f6963806cd32bff274b51e3e274f1e452dbcec611f81f446cb7c54fa546a17c3b055e7aaead259ad360d037176fb59fd947a2a6612e27d429378adeae5d0dd690b823ad5447ecc4b72d720e2271aaac8aa983de2d39ccd7f70dae68d3f0b6476bb65d99bbcdddb040371e31269a3169d07591a5c0ec8792a2b2674fe87d49db904a8f6e40083cccc1f32ae39489a661cddd8f005043e72feeab3cb29380c31345e74e14b7eef830ffed297e2093848b757ea3c7dcf35729b5fff1ef88127c7a43df234a8fb36a968e584ee7a099198eba72ee0867e961292be8ff6962c2ff08d00238549ed42cf5ae0f80d86c5be4c6a0a378afac3f83d61f42b5c730ac22ff888f70ac43be53bebb556cf4c424a1880d9431d55a030108d709ad695e14e112890afa2620838599bf66309dc6155cdae9c2a01db8cf0dedf5b5b193565407aa8ac658111df44d9150b580f1975cd8148d7865552030a8541200b8137cdcd7acb7344e15bc90ad840f242e19487625b9fde3a266ce2ebb5678ac2fcd2fd45df66a356e45d64812d493f9537b7f3379866794f6d79e24757d1d1d503a0e6923bf9d3cc43743e94362f1d71af505c0d939418337c9436e9c3ff058bb1d97cf6c77d57c3db1d7ffa47b624087f8817a0301494029cb8ec090e483767889c2701a1a984bfc62972b8f4085f37534ece7de4c7585c1cb10494cb206d7deef7bf429dc675130a0cb72492cf3be5a833541dfa9481d6f7273518f4d6b8758d0b34e19e1c427a7364f0cf62bda9db667e9ac70ce2b6c5fcdb184098f96db118a44a31ae9d274983d08a27b921e5b0172dcb5bce869ff50ee14b81f8077ce7d8fe9c912f0b72f3fd11add63baf36e620c3555e8f1c1e6b08a370f1903ec0b8152b32682e3dccfe7452368dca62a7408c19905168972208d947b362a7e26dfa04f393b6822d593ec59de4bd4e666b2ce3643c42fd0619458aac8631847243b7b4c1b34f4610666f3b73a0b09a6b5c5c15269e975c611b7172d9a21c86bb1f339baccc559e9cb90e4342d48680a2ac27e0ac88c4680d55ed17e0056078350c42daa6516bb76535b09c39b2bfdbf76b1e244ff3150b766e8c9f6ac520ed6b95710b9f88efed5fe315a114b3b56575d7a52b407ae85d34128ac0268265de8055b01e4476f43c2c1c42bcede5dc33364c943d5dbb576c78088eb306ea74c942697941a23dc91f49c0737ae57159582fb4000c17f2364060ce34ef75a12a3de86034fda4d1adf7e7de39a72be106a479482587d4d568bfa60a83ee23a98331ddfeb47d17f743a40305d601aaed9bbed76b00071da6bbb00f515fac617525286534aff0445653ee6f06f6826ade78b14bbab51e361aa5319d038071679fef7bfb8fa9d5835e9211b5b6b030186e43344ee061c8821b16cd1bf9bb964d481e807a5dcd9704784c7b7c77658054630578d6ad1a8f44a22170995dc2ab0ff9d641999ad0f79648dee13f401e6160e842af4f04b09a37aec2b8de894aad4cb5d606d06e5d2ebb224afb03665bbcc5e8da64c293df682809ef7e646a8c97dbd0f152bb84c84ac9b755785f7141fdf28fa5d0315a16d62a365216a073c5230f0169551d16c32b35085e3d10d017747af498c64cc5f8fbf930d255da6836110d1f2a52b68ae56f9ef5d4aae38d0b2bcfa67752ae1f391e34af3496c575357abaaad36b18e7e7f5b3da197640f87c19c7e35fdc9c039ba2ba2e70bc3794570c02594200976593fb3eeee0de8d90c6a864e835524827f87183ae517a2233f7aed640415e4c8fef3ca93a59ba3d01aa461e8a0f2454949eef8216e2b319e2df54d74b111eaca5b225777699fcd889d36a66b8039ae809691be0f5a5808c64e6c740dfa234363f3ea0b7edcb1a1ea5c576c18bee4b3c868551e7ca63c8732b4cc0ca4d6844ec8fbb778e13eb37d498ef421b1287cb6b0f2ce14cf49c440af59150ab7117ff984ac25a425a01648176ba948f4546d742ca0b96f977620c7af379f1dd74db620cf5555edb5e504ca882dc3e88192d0b3ae48e14fb5f4d0d68093acf3d5bd2dbae7758ba862e01f9a2a357e530aafc0862af2a30a1d836271a14631e644acf5d33139bb882d24aa303930e94392dec9505a0d0987cee0ebe8faddebaf3264211e0c55adec7f3f9d754b64e8e49522494cd53279e1a15cee487bbd4d82c1531d8ff44f5b9255b57fd22057dcedcfaf9bf49f78755ba602ce7fe0bc42b2410a55d73d88f5b58d1eaa2ba00176ca714d690c8708646b6316eeadca973b548ece8ed46c910d44ecbc913a306d06390c6d04a72493ad103af33c5a4908539a053bee97f77b0de6263059e60041baa3d4100d460811b5d6bccba55fef2c0380c2ccb5020d260dc34747eb71b5109a9b0bc20232603e46dab07460951edaedd101f0edc7b0bf045e850e630aa3e52e1b43edbeb45b3410cd49b55ec9f9cf8cb4fb0818a48aec974d7610bf2f28370cf113ac21d89e0e8dd362523b047a36dc958dde6e935151644b27589fd2fcbc4b16f14f194499b8d0fa6d728703fd836c123765ffe035809d1ef07009262878e8683e059d5598c7973d6682722013fd1ce330c34cfb1e7cd1a08dc57b9d81811a593a67455f859bf4553f719201dd7e4a9ceaf89c86d3982c60d8e7f009cc39c8e87964428a5c7d4f5e86248b8147f2699b38dc6d204d09281bfffa5d3a6f0703a1f61c85ca4c970a52f166238e5671df43fab3a0d1b1457a120cca98ac74c04d551cd2a256310c9ad1d2bf98ec02b1dc812580de0b34039edd60da86a0a653995d060a1231d94b7655a294bd803a52e5a75853a892812b14fc5cad092b194f83e1659c70a5c14375aba247da45db04b88b42863864a3c8bd5dbbfd97f42409ca14e9b10b299e30eb1f3ea21eb29385fd06788fc2d1ca6d1d23e1ba15994e57b878909bc0bddbe3c147bb61ce5e16989e8afa37fed4896a82f4070738b7dc2137818e028376a39eae300460af9f3889dabb4194b0bf3b41404b39397703932f7fd7e63df11988ece9eb1ce1dc60b43e641d3a7ee12a0ef169a1d8c11164fb3ffd4d1f3b350bacee2d5e1757ce011bfc2005f05264c941eff5a4b180a25c15e3caca1e7c4d2a1c2e2e3dc03ab11b03263c2131afa067dd072bc215956be89ba9c9ed39d64f731585e0a4742ab65e1cb751180b20c39bface5eb639a6626c9ba50323e95211675a9098b75c31722dca0feb6cf13d218f579dcc52a4297df2e3d71092ac839ebb7a5eae8dbadb94cbb91fb226af08e162a851b2a289b2f3ebb41a8298bb0b0aa04cc92c2b7ca3fca42b8422f73887ed189db9495519d1a806e778e470b8012864d48b4ee092f371d1bdeca07a410bbe6867f0bdbc762da82b2a8180738564b585aca18559ad783e69ae3def717011a0b3f5b2d0e6af2c7bcfec49b2c2a5be68109b077d487830ada259b425d06c10b72715949cfc65f6c1e039f08f7114d1e0cadb061f3b42294657fd1af82ae769fb8c714a35978709f31b6863d1d0137bf7c2195f87b82a435fc8e8aab9f0267d1d0560f7cbf791c9cd0197d3753962cc7c3d29a75c7a81fe5b3f6af5bbf8d1f113e21af91a29f37a78c9024ba0b222a13c12e83471074406f43c7746ecf3255fcb3ab7b67b3b924604cadcd3736b6942dfb9c99b2b132b30a1af3bbf4dd37871d75332c5069ed1a1af66420842b9c02b336eb204f20f03bcec08bcb64b26cef6fbfc97839e55f9a6b6b51bb3e5bf7f43721da717c81ca0d29e4f8c1d235c0d11eef4f1c6ba8e73e72332309c915206a7a99fc1f40126be7dc41acafbc7aad181f26e9d6ad340607320cc3af21ff47554323565e54834632ea42725409077d5cc7acd9fe6ded9e7e8287948707166c8e2846b06a232d276ff6b28dbb21e51c35a0025c907ad69ac1f12bdecde0412c86c983ec0f90019bdb3dc2fa2eda41da5d54b724e813882d69a4d2f2081b9f96f192561bcc95b6d5e2d9c31ad3dafedf275102b4bcfa77998f268d7de83daa4f939bb8601dd73f4b84a6a201d63997c5f07ae7b2fc38166fc1ec3695184553ad67318761ad6182f9e59596bd166488f360c8b5534552371a20f781b24a335c3aee85e23071b70332426b690762d9eba705cbf005251d26b31d9b0f5842050d4e913b7a60a16ea9d73b63420bfe25855c51bad8dab08b6c5e67830ffce2bfc73ba83183736e7896ee432d7e17f0f642929c599023990f0479383aaa315bc60c691a0bc91a686c66f0f2471cda2aa80c4ab8b03d940f9fe55c21f66d16ab1396d64ccb96b260a21fac62ee2dc642d939af8ed1d9cfe8a2c69ce226a375f626e47daf60151cd1b35830c293a3d7dcf974c2c3b94aa7cbc5c79af5a12c13d46e837cde04e89e0b58a4be411e85109723eb93054b71a11b7001c1a7a4115d3caf15a1415106c7f9e5b550776e2f93d9e2a0c81eda043f2e814e8b6fcf05f2588c9cc07c844b4c5b0ad1b017a726d45f0bf2d464b2fdbb5c0c3e4bf6f1ff3ad8ad7b38fca91bd1d71506a934c77b38f975a3101876d658b45e87c0dfd6a904be728290b42fa339d61cfc4afe77959920c41f9d26e1fb9e064a8be1ca7f103b6b776ca4090bd58edc2fd805763fd33940de1890157c26aa9ad0cf71f4623d18112f51ee72e8fba87766e091bec9c6806dad1b90b7b0bb373269c65cea46e067d143f3e830558d5dcb0d0abe6c528a7e0bc691d109891e43361c974189341239f8135a54ded9dc0aff95ee74f0bcf15cb330fb24d3695f70b8fe6a75d6df536991a8c35620074729d58219dfaaadf66cd5f873b5a2aba06a4c52d5304e48f025544a3b7309e2902179834160a78345a696d61c2c74f06c8d218298825289d0b8a78d1f5922470a6a0d35b8793da034a17b5a16b805bccd91e6fc1603ba010cf213f0f1fbe6bd48ccb7e7f72d1df0557c8c58fd82c1db0b57b382d0ad50749a15b0a4ef8d94788b310ff7acfddd876cde3d143149d4aee6c13a13fcd47a6fb94a7f10d367221d22e34caf8839972dfeff7a1a9426a416b6121ae2dc10291de8737309730c44d6e42ab6414822ec3f75411b771f5a89a9d73136ec4c2c381942f198e361ccdbfeaf7cb5a3538ea9175622cbf31b2ad0c153936a1f436b27947c7a8efbb4082f8590e74b357c408ceb082cec906df875c84ccef2569af7b9be84833cc95b4faf39b333fdc4e743b83e0416f0fd72c913efe46f27bc6f41201452d171d10bac0799f9baac991af42eefb4658b015b145b6e9c0c7b5a15c752632c0fd3aa955f3d26f7f9c4d49c5f8aaef159ec0f20e8fad3a4109f57883eccf997d731161f2e0f0ac8bd7f02bcc39e2a2eae7180bc193adfcc5e59652ad5f80264cf15935e2b3ab32db07b7d80dce351c9a4a1b1ee1815140d3507aaca374e13ce231c4eb61fbd38afa3b4076ede06d087e2c7cccaffb2e8277f0ed2a02a17f2968acae8235e69f344e6a8f8b03d1d4f9b6ae6fe650ff6320a5c9b9018343bb086045235b38e95c43af08d3714e84d77a9834540da073382da561cfa47c2c8ce72c6ed795bc83c0a57e17464390e053f12e88556c7ed54a2574f960b50a8a4cfb8756ad4a477619d43fc21d59f3435cda30a5c7779e05a7915fa0f11073e9bea87896523b3ea9aaebdc458224ca511c31c53b6d9cbaa7d4fc0c436a563decb0db8af70c1b3d41adce3fe3d378058e7cb01c3bbf4b5e58c27b35b192e0e45e3b55c13ba081c1c92b74e6021fdffcdf1e59fe0e2a336d6af1760d5681874533d5666bc77c6ec93d521c25b5c074f61f5132bf05120538252f2a77eadbffa51964c6eeac3438436cd088eba9ad9d39e5ddba61c08d097a489986b33c01869ba405d4756cc1cfb274bad9edc4db9510d73e2644a1407f8375e17b7f2618980b85fe4c420e25aad2d1fd421e87c33126857448e560c7fce02f8fd41d1bda9ee64743db9db1e43e0ad3e42b06eaf41446082a498297ee3798a75a9e8a42c04fa05763447807535e7f8cf67ff15e81b9c75f4537d7c42eba49b55da2ff82379fca7c489de838951a79a4946cd13885a77adeba3d30155aef9f15496b86c4499789d1d38d11040732c92628a6a2df908703083e77fdbc60af5ac417d1a68faf3f43475bc44e54522cbbb42b0ce61e407f037d295bc94da038c2977775994d69f5f588fddb49cc7917e9f75e5aa96d8bd8fbe8a0ef54882269abe833ae8025b3025fbdcbdc934582837509d7835f2971d7e8c9a0819b5d6a27514a0c09507d731fe0c68f08b7441758a4265b37aae68ff769b8e5805f427a6fc9915bbf71d723b14dc378737582746409815af8efdf12fb5806e3c81a6077748e850ba0ec4ff89616fac32b3c80a5bef15b2df766b7681eb4dfad4f710dde1b110ab365297da1511fef0e1a4e58d522e79496e57246962a5961f4bffa7ba7ece6afc4b62dabf8e8871a964eda409dfe3a05e3e1a434ace07bca7ab02208247216fd0f7df3ed04e7f60b82139594280c8970afea1022a48fca27554ae2ec1c5d13c11ba44e571b2a15a00039fb144c6ed56261abf96dd7f13775791ce8353f30eff3add5a8a5dc7086d5756f341f557153a68700eb6e9de449bad0d4b50a7acb20a40cc55b2aeaac80497a4072b8fc9bbb15f38ee92f91c5be4abae066f648f0e9f8b81b8f225dd01cc092bf91213d3e185966052c4ed6cf398dbb6386bae474af3722a57e7234e1f09986d86d745b7a84cf0f201afb616163d0da781482a707f4be52bcbed14a922c30ff5310332ba71e23b2080fd1d1d05a4dfa49ccd8415f7d0618b28df37e4c459c92b6850140f2530900f57f2a7580c36f98fa75accd8e0fe06b42b6a8069ad8ff4919e1d8f360e34ff91eea550d3ab75c9e0141d68db140624762d34d33ed7c93104603546c6e253bb32afde4994fa26629676c2eb94472221ead32f295602f1d0b173e8f56fcb3a47f812ee86e5f8cb7b4ace0b3b6a13f6bc48736aef712120aa0e872b0bfda64ebcf4bf26f621eeb09bfc1d2c54098e795e50719b0971f5ddf7bbcce4e1308c594152b7f196c3f58385d49f2c548add6c67dd66e849574c5cf1a395d69820d859f4b26551942510c2ff57d8b86818abc2d7380bb4e2083efee280dff10e1e10ac7f7efdd9b9057be26680a3c0031d7dca01e9847d8089923c91f985cc35a89118ae3ef2c330345866bf4985c5d36cd957ae47de275e8528747fe70b682600a09646ce86f8da627be31b9496941314f9515ab95c65a75553f1531687e386bf226c50fe05a6a3499059dddfe377e6232e0e2cd2677eae58484365d5cbd46753870fb3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
