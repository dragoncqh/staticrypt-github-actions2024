<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56a6e136316ba898c9e5cb47c6c38c908d7a9d78255c7019fd3e7dd8f25518775d52800d2518ca33082f7db2b6a3c27e0cdbb8e927f84f7b2e379f532cbfa08f6dae886c937d578b81c3dc95028d8735bb11d9ae80a32ad9de28760a60a81f48509d19d0420e6e259193a2f493556bfe7a1c736ec17084e726703bda8d11247f0af6b999976320d7eb0c5d8201cc1b2509c6459b8f1c6167b07644f0b2fa87badcf44887364b7f5c1d4b5f51fe13233cf8f4303e2540f4618b8670c70c20de2167801a7fe41f90548d2c9a711c1f6c8918817b96d8fd8ebe2d97a8a7f655cacc3e12405655fa0204d932e8cc094a1ed70455f160599c146def282b1dacc5b52a6c4d229d3635523b9a5ef986eec9ba0e9ef538eb2bc8c11c6691c3311e63dbb42c639154c202497e629e49d4e857d1b1fd76b36890e9f20a3ba05e52b569afcf97b809bedaeb0acf9f79b16ec48e9578868a7d3c81f92c18b5bb30956c419861fbc676166d91a8a792e53d1bcf2657a6e3a32fb601ba505952bdc0997c799295982e7c32011a7384c3235043551c87fe2a99d1a9163bcdad3b99e09a0c493692ca0ad29a779302ddc710dfd089b179b3c60f179f4a535c0271cf2063b1983d4ac7eb11dbc3385c637080b19495e3816fbeffc40e2d700b0b8a99d16751413c5412775b99f8fffac280f40ab76f6e4b227001209c7b34cce17ab549869dd980a356665b53f495802342d8a7b3fba802ba336515053534b8731e7d8163683f0314a0d8222ec09d8451588be073422c39c9e386f449bf89120a3dc2c067455e8d0b6bf2cb86ea295b114e485ab9f15ae8ef1fb4bd7e4de2ed7fac9b0ed77be26bee56c7ada1556ab187dbb432f13d3c9ad11c340e9df8eb843ed2281a76c9f6df016b52922839050cc63ecb1cab3a3f6dbf5d756529ef8e095d77b53a6c26ee794c3dc5d5ea0f8e5d33496239ba59d6285abbf71afc0581adc14c523e050a2d2223b5d8acc183f310ca5d7489b5bbe51f0bbbe24686e036ea1e560a1aa3ef532afdfe05410ce5a5dfc9bb3b229c9545f48aa8ac5166be80ac0843defc6cc095338692437707be521c75f5afcb45b216ebc74fb1d68d153f9bdcc665ba935a9efb62090e0e7c2223bf7c06a460079b94c887c9cf30204f2726ec0899636e0b5e838040c8932f71d92e01428e92b8f0b575b75470149a1ae049d7047722d464fc3e97320131abf4d250e71d586d5cd19d92f415e0c173558e23073b6bdb5407d5795eb8b8e595b4946ceec4a16cfdf69bddfe046e086f42f7133f1059d6aabab2488ced308f8c7e37384eaaaab102c5711b2673b830fd6a09a8739780b7829913a85c18a29124572b96d32951aa31c666af1a3ddebd2dde491b654d011feb2a970959078ddcbdca241b7098c48a3f57baccc508821dbdc0dd844453b557a37f24ac9eb3a3c17276e5d5007b6a20b645d2c02bb660b67bb3b246d22006c5f94abca26b82bb62b9ae71f9b0c387b32ea22a90844922c3cfe45d7841bdf41f47133e8fa24503336b8cb35d0e6242c8e7b87374d7aabe32cfb254f64c563f3d12bd72da8438fb630a8cbc9a0028a4064db4407054d40db0b6e243dc1f64923dfe30ffad38bcb3f9f45a9dda912e9c7388934a124c766452ff851e8c7bf1e3499ec34e7f50e0ebc251d78f4a1d16734e838d4793cc6113e7e12dcfe99fbebe4bfaa78079bd45e11aa744d0c7c29800d728f00aacdc24c032d9229c9a03c645cea8032c53e1876199f4a46ee3fba1f37ca2c9e662294d01abda00377ed561300acbd054badaa7658581cfd72f39b93d1bca32eaebbfa59dc11105b90d920bdea08c15f52c6581b6073977501a09b2db3b9f5cf3a7c50f36a28420c39dde493103226b74e09a3fd4a501145e92a48a472230d669cfd3438c705cbc9524ce362394bf9f76d156ea4281cc47df9b8f73f1dbcbb71fd2badc2824d121fe9e8ef5f070a35b5524acd7d77bbe42422e86fe6b8f1d771d2486ea5107908aac172ff5786f0e80679841e357f6f59732cc61ede125b914d38b4907d69d7bce765e3c0cac882d350367af196a28ca13c1791592447ded613ad62a5e63912620c534aef2b6f77eaa8288c77f17dffc260525e258d7b77448a6bf60cdb7ce711c6d50ba38675d9c37f64b7cd7fa31eff2b973b22437e07209cb3c27cf2edcda2d42e1d0cbc289f1be6f4c921994e43ac54b97d3f950bee29fee56595f05f7e775cb4ca95a423fe4e6f01a600d71568e06885958dbf1f1fcb1ec31125f29cf488d91428d6cccf141b40907bc5847a8412db6dc8b3d90d9191518e3e6c0ea87f024d85f824936f92006f133118a50a4916fe50559a4d4ffc15e0645c91942c9b8c41b0904d51647b96655d7e03718e6cc94b8f0b6187acfbe2fb6cd77fef80fb5720a0e5ad65f2c3205275c06160577fc6e15b2af4b448d1b0792ed1094bd47b8171079ff013dff92abfb8d4d4212ce1bab07ff792aec6484c20c9d12223db75c97d36516bf475ec80cc2599852cccdd15da2bdef85acc6e1f91a0e33a98d4eeb3e246580db86d86b287c6f37b7f030120e5629c017b3634d116debf7af36cb9eec4ee345458dc001df6074461c330c31539c3c4f18aba5bc79fb651c620a29e9190db45fb230862192eae0a172644e518e05ea9c8c79c034e5970f7dca886e9b1781e435c2db89408d6b8ce4f9824901feba06713b3f11d1b222c2cc31328c905c617df2f7270f01627cd94053e2c8308d6cee5a05b2483d31ccde3001ce41438fa2fb90aaf9d2f89d4cf3f76ae7b238b599e3d8c883c7a53e68f5565c63f08bbc47d9ed9b41e7f0beb1d43c9d9a011ce6cabd23de26c01a88910249a352d1e1aa6275f3c865f74f054be139956b794b1e30bf073a3b774c156e6132c68b483737d845efb685638d9c598dc20d0ab691a1229262b529abea84c0a38b41b60401371e8f2f8ed03f368125aa7845b39789e465ac0b2b0baed2db8bf558d061b1785e669bcc6f8ec2135908f1c928b83414113ef37cbd17be870b677984c41ec8b5c65c3fbe373ffda78208d3ac7515fe8a63d243ca4bda1611f3871513d8655f0f7dbb419b52ca97decfe008d4d7e5f990f1c14301b6378a1ee2e620e6b1bfdc71e6ac01aefb8fad692aa7528b2c8e8967a3ffca0e537dbbaf79dbc5bd9d2ac026f647ee5ebddd2d12b0ec471ad7ae826e2ec846a6be3c78201f1d509b511087efa1af4325079c5bd31317fece740185405e40501f21d87981464e865b83f01bb9366965d1555302fc2f14c23fbc6eab622fa7d12e8f71ca84f1f0df6c94e682e3a21020bc8d71d068493abb899c8b9cd820ba4edd487a086dc66b2abede83413c156608a1551abb571c43bc88075ba0e3ea38eaa4b13eda074fe3998f71bf1a6873decd1b41cf7063d102cff69c2ea31a2d8849abbba560ea6948b4cea8aa2edb54ee9b6d591d3b541fa0ae25d8ee0ceae004fc47addf72bdc78159243defdcac7cd55b0f9b313d7a7d130644c356173311eb547d5fd0bafb3ccac6d74ea18df004c10b3fce2982e9ec667eecd6ca1b25c11cb1fb8895fc51da7cb3459a759a6a3c43babf7d972df54dd9697d696a184c8f0f69e577c87a36f217696d6b3d0320454073950de63c28c28aa7f6a3c71a15cc0e0aa0bf0f53f16b0fa9e1a8028afcd726923cefce1f07bf3c96d2ed4cc86e83764cbd98946fd1f65b9f77b6c3b766197260d33d6fa216372e4e8774ab399d374490bdeb687e1c25b9e87ef53cde71676f893a868c4b66bd90f88168846247044d162b72cfbb90bd9e2433a62cdcc3f40d156635f28a8adda414ce7b9e58eb42b2452f4221ded5cce22184af257dd1c64f90434d7ab9ed362a2bef98b6376efd6816bfa74ebedce63fa84ff467fe528b25b3b1cb0b27a8eaee242ee48be3dd514ae8a8b04cef95a32f1841106ad524438b0f2fb8df3302f5a427b532635833baecd22ae3b0a345ee855629ca321b06aeefc5f69d9777f2755b4addbffd6088607a126cbcac58d59b68a71c3fb5dd5d6102ecf83608239e6fd5187bdaeeba441a83c827bf3528a653bccd2e3e65e232acc8f1415682e56146ad72175a116c5a29d4e95379f6da8a5a043d3a848ab3f7e171e6277aa1c51e16e0209ac4f383dc55e1a1d0d029d77c9d227e9bc3ccfe8f6af761ddbd6253cab021bf6717419e263dbbcb7308fd73672b220bdab1a1cdc68d75c72b6e94be03ca68eb92583fe7b093d9fb97a9293aad636ea7cdce3cc0a39b3e1b8cbcf5cd46660ffd9780b561ad3e24fa5483c46acd76c2188def8aa475d7b3742b5b7a1a551b37f07c6c178845d47f74814864d117f7e5086eafd1ab56976ddababd62699971ce225f055be716980c3247055336a4f7717287f0537ae09c0b6b4579e06aff73dce37717fbeda6cc864734723ed9956b0c10265ef227cf0f313ee2173403d8e423c9324af5e58a183a161e4860bf8a915ef798924bd225aae549590c46a6bfee82de2c8532ec01ab02d072d8821cc04b56cb3c132b0b0ee954827d362691e19f08906c56f058ccfc4824ad2eeaddaac3a6bb675edd3646dfdbae3658a065daaf58864d2b8f3b5b82a99c61a1445216ab7524248a7f012391b4055dd968012c28ebd41e2620c197ef35e9d42e0df20f0330560d68f26e11f8cb1b1b5c0178fe319b7338f5d76541c4e1edea9e7848b321a171c4bcc7ce578eb09204457d36c51013b54d3c00fccb29786129e6c9e8d1f2f9d78349b7c43ef35c21a66066464fd2ff25e177253a1dda58037a7eb9b90c7b4abc17c91c2c323b80c4d3b262761b5edfb3a6cfabfd40ded9f893d1541d8298452475bf6f43ca630a01ca4a983f14acb20ac19b9ad1aa8e7c84cc14b0d3a99f36e7a8838a5dd0c24858d13250baf6647bc9fc609b95c242c68b2c33f6c5c67b0fbac7f40e781ab0b231bf4d20a2229e7de0840c3201a5b0929a192165b8e3f1de00e3cf738f0f4f47c14b7744601c03faf378da1354b30a71407362d2eeb9b228d61d5a1f09f7744236cab645327f56f9f732b74365b86a8aca35329f90d375a7315b57d635401d448f231c6e8a909446f081b1b871097363e30e255d52c59a01bb9d059387c32fbdb3bad4ef14d00f92194691ff855984fe6493b318fcb55a9dd108ff64cd2b2d6c82360cefbe9e22496a91eab85280e68477d237e3ebc5e1a3ddd930ceced51c34d047bda5461dc374a77e96e9d264604218feddd8461616ba6acafb4ef8acba401a4df93fe912429f177f6afe7358dea03bf76088d77cff2038764e245372d42ba242867e8d97ce3635ca5bb2760d42db3e6e23b8421966b9a757e1c28d3560fb24493dfa8fb4bf957bf6e784e40d33208f0934ccaf2a266431c59564dad1c981f72158387fc9057f10b0216bc16828c2d408fa4ab3192f8555f63fc59ea74d42f6263cd71a41ebe3c2f284df19541d17d79e6ccbbb5732141686df841f6aa3c73150da6bf5d7208d7240e810a9c0c12c98cb6cc8f505d5ea50d9d3a12a36ce9b4fa744a8acf9889f72a544a697c84970e61bc2995314422c17326858a73c6d6d45d6b94d43d0791c68f22df5aaf66663685df0b8b88502c41063b1b20173eafd1ad432f1d94000c6428fdc9664afad0293ddbb38aae1bbf42802b2f8c8915c8d5849e0e696d58c271fbf1c8f381b2556f66f4173f78012db2f54b4d95b57b4ef8d34b145b4ed7296b2856044b5e145ccae4d2bfa11c47e8efb6a3515635dd97af1078034f208f80564f4e0ce81141752c8313ba7dd18c7b7873bc7a35c0e9fea8680209edbbeef83edadda2628657636ba62cd783504e73985b66b686a134a6e791f9c1e52c25b68b7834604db63d2a8a39591a7bafe25b82c9135b6dc74fa2c0d7b7ee15b8cd5b9f206406928452f28349ab552bf7960085c3e281636eb97229ff3289d11315247959749df568a6e3925eeca1ce35eaaccef7892f7f2ecc72b0e769c9e50f9a820239fc5dcbac31f8376dfd4618d564347eb4b30ba166db718e76f200af5a70da6a6d84bb3654b463f9eb5e6d66cd65fa30f946675ecccb39ba4e87b815db95f83221c87c12c9792427a0e86c4a6aa67a852ee34bba9431f366f06c1e1c08437367ae78acd13dc337cbae7c3acde78cc7459e6d54231c9555e8453aac5772a0d85cb7c10863b01f457b1bea1a574f80efc6e011c62a7a9dce229680c778846b97ae238262862ec5245ba90bdf347f3f91bc64f4b485558b86f542d8b7fbd14f055866cbea8b4dc327ddc26060e70fa9820a6fb201834228ce071a4a12e52d0ba7f49ccbef716b5d46988815c939431eb08dd8b95381eeb5eaba29892981bba7a6d02afa3971f1aea713d53ef56bc80d7ee57f3da5aad9cfe90363587967fe59eef9bae6e469b1e75219d59677556706c0008b238c45d8fe9e828fefeb2e110b193a1d719d10f862626cc16e70548e93007a4b2c30abc808cbac20dd4befc7c7489254e3632f58eb107abf178ebb18d3112fc2d615fa59e998ba92951aa38852e6231836cf564ef42a5f3ef4d6567c1bbc6100d5686b37a2b2977f094be296b2b0182b15e27ad91d1461973008c091f30b7f0399c87580ffaed6c0828a530f3c96f066fadefab24a4dac6db6b555ebab1620d2bd74fe36893bb4a428946cdd9c1931652363e72705bb824f03f27c2c7529c4ac948c82baf443d767ec577fac07f5c4d5972fd54aaaac0a5cbf465c8e653eaa042fa304d8c6001f067a87748239ffb86dd3f19ad4c91652613ff6318db2aba7c2920a4df9cdd29adc307ad1b5c3cf73339a7a65c7a57ca7b62d01fceef4b9df7740ce26856c40bdb5bd19c3dc80cf8c62a08eca89e111f37c04ad84482f4d35fb877dac08900a8ed7607a6ac80eea145ba643c3984e3d4b8baf0142f5da36f71fc0a60c8493c1211c84064829ddd5784ff10455c41da6b6acc28e6b76f7a3abb0d9f71df008534416d6a404d785247b506d1a62a0f562d3516f6819e967e697b5a20fd05428cd86173f44fc45b7865000febe3de2546c0eea4d8985377b6ab5872e85be20e90a0ca5155c003092e709805aaec331df7356fbbce46148afba1458666002f07220dc09393222d2bfa4a12cc7aa6c7e1b864ce77514e8196e211b8083131df907fd5ffeac5c74c574badc8d63dc4e2bc6ebb9a65422adb7c2ded3e5d6fe3947604b2096c8d8a3fdf09bc529f536d9da59960ec18a5c31546934f21824c40f25e326c1b2cec8808aa953d400734ed30155a03e44fb3a88c51354d053fa5511ccc0079a55c2ab6105b4d4da39055b78c6857ebfff9914330f35335aa5ebd40ddf46eafd97dcd3a7e14cfd58b7a2d86e5cc59eacca4365b6e8a9b414df03bc9f5322271bf169e2d3091fcb95a6d020311f943eaabec9f4bbab9b5cd9b2a27f5ea0114dff25f645563ba0c949bb26b0de447709664c78aab47bd95f110993f57d5e8a1ee5a4dd7928597679ff9abe083ba6bfc9a8a7bab82a2f38c4646adf24dd48343e382e5c25bfd481a03b6a3ded64b87e1f7b306d5017ad5674426ece704df96b4a19a18c0a30a8dc64e1446b7bf090a0f8e91ef7374090e9eac37048c98399430bff6bb01830ee5c63c6fd87e352e8b94c403584acc10a5cf386d0637d520632d794ad25601416aacf7e907f42f9870997220ecd7a2e9bc470780e5ae33274028a6f5e9b3cf070cfe71100454cf36111a35cdb7cb5f502cc6606b9a6bb47f8be2e9f7117d6ae8648abeb07b318a8bd2d5f13ac3e19ecfff8f73ef0a3f4753affd31690188c871dd058ea57c03c39993e2c82469f3c7f746a1f5815ace6f81a2f1b2bb747868ddabf57b7ddd5ebc29e05e4e8007573fd20c0c479ed525b959a78f776b941b414ba463bacfbc8592b5391918754109e985af643078e0be2a232fe644faeae0ef1227745aa853632bb836802a4b76968f9233f0677ef499bce4ec6112be337f79ea263c2051695fbb5ab682b2040d52d28db457963d537da7330f879225be3da0410ecf41129f905cff6a14fdd0728dd5e12e2b9c0829220e53277a30c4c1a0bc7c0b74bbc64e16b1973ffac621e0621f1278c04bd3215553603fc687287f57a6ca2e61ed6f297591e3fd87c1fd6664cb1104a92e0d28e973ac84a316a71cd7a239655ab3a563","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
