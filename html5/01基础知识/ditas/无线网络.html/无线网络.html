<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6aa43d999ca0ffa6a0cc1ad7c591f860061108fbe9111c42da0cde74e97877685a8b4c650adcb1bc5e3f3d37372d86b4d44ea2309abe04801a3a21da25b5c1ef7c0558787e651524b5dc27e7acbf3510c53157d0531978e690c8ffb2d4fd92a86970ab013e14673c1d28d6d0ce52dd92f8f257b338f2d56afeddd733a67becb29491580de255a340b8c4db9943e97211a2431472dda167ca8cdea453bb0d0ef7fefb33c95b488736e99d3d41fed1ea871d02742186cc7ab85b4259f645f7103b9196b0e981bcaa370b985dd9450cc9bf02ab4232a7bbb303651976c21241368780f1f32cd95455ba7864f88277282d96b0afcd11c40a5ef08f9e8317723da47c7752bf0a920319fb1e732266920bbca96e1b5ff8de723c4d62801daa8fcbfa29c28d4194c49bb53327a3b6ca70a644ab18a1f19515e21fd071cf48254d8ba2f7065072bf5af49dac37d9a1aaf95d27c5b66b7dedbd3164bd70f62c0e9e5dbbe0c681d799edfdfdc927ac8c938b61d064f5b7c479d0abe6fcc4a641edf8be80cc2d3bced3fd0d28ac649d2be568af885a9e0772e9e52e502c27d63a3ab4b66efc61537991808c01b0f5888ee8d642bfcdf8f27b187fcd84a6fa08985fc0f9449541979c4bd7ea0ea6cd76080c148932dfb319339008b829e82f18c98da45eb26944fe42d9da6f8f14b55078ef052f8ea95f4854a7c806c654f3b7b9d12919817c4f1d0b0367d2bff1365e24a7476757db2cceef7a6b4a5d984c3be570ef1e84815d1552ccac6b60afce4de50a9c1c13a475690841ca70da2635202cd0ac4f227de3b517dd889633f2832156347fe19f817446bc8361294bfd78ecb75d29387560c29c79886d8e4a2581446fac187b35f6b605c56324add657680d1bfa07297bd5695084a81ed3e0932a75c25df608a69fca0ae392890d44fcd65bcec741e753025d2f8cd13261ae6e550cf8fac903f51bc4d64beeb3b5a261846f8ad8cc476fb1e7000c9ce5abe3737f646f745ecea497101a6bee44d139672578204d295010b471c0f8f65c05bde0448cb30a693ef6c261736e89069ab68328085af579652dac3d2d96290509d077aae1a7c34d241ccb2562014521912cf26dd26317213dd5eeebaac2bf3fdbcfa3507350f644c535b2120d7fa4a797a0bc2d0c00de5b2f364439120cbaf90bf7d9cf1706b1e6c9ba0f358c8ef186494143f30e26c546309d7e555c58b6e246aa82e621871d3635bb0efebb9e5d18d0a5c20e622b671a296eb779bfebb8a231b07ec911fd6529f33d8ac81c47dc31b8fd013c28704a85d109f050eabac735e3ec1b842fcdc3092cbe8cb42dafa0188a2d8b00659e911ae602a145f8b7bc950178732c948df6805f115bb1cf44d54922aba7df50e28ff071b5a3f84f550abff93028f2ba83636d19524025407549d5a7d577df558abe1e6b495b0875d45abfabb78bc4c65f60976da3d1c20c6be64b2c7917c7e37df8cbb2ec637a992dbe5f6211e636fe3dc2960ce7d2ccdfb2443b396b88608a0403658ee392a1a6f3ab7edccc89e46f83f6c1c58ad582c3d6f160946c03b9c129fd704bc774f04263e65b303e983bd2dacbfe8c2cba0b0df611d7fbdec45465ddfd7641b9d86d618e89ec512c189dd3ce7ae6e66f99f8054c0a47d2fda186ababd028accef063e12718a861b181f99e9af8b5d722c3c4a77cb26ab93a3b8818eb995d9580d9f49a4974f923d78cf435b528486aca8221c5bf30fc070fcc67640e438dd85d09f0b4470a5db2c0ca80ad8312a8a783a0af4fec3d254af946e18851f1612ebd3e6fefac52a2d7416a988926031ea197598db0cf5485930ba09a91a8b192dae3c67a2694be86a7bcf398838d6c323e9d7a69eb9a756fa4799b29dcfb1be71e39c4806dd4cc2ecd16ff0f1607bac12169b65276d16fe37858a2c486cbc4643b075665603d7e5583d3579a77f371ef6a3cd662a21202ce0b11dbbfaa0ca07face4c363fa037c46788046b92ebb6bc922cbdde5751ee802a69289d5cf8c7e9a56ba0b58f5684cef95a2508f39a619a6e9e804acef4ca3feb8ce6bcd49bdd9b0e3dedc4139c33a17f6d0cdffb395b89cd4f90dcf6877f9994288d5859b4143991054dcd7bf2b46736c196705b2ba52e4cba1081898dfa05f7f475f3b9aaf67417fabf267debc21b7489301bf070ab304c6a7ee39cf02fe228d0763e23ed058f3278ae55b0cc8047fdebeed555a02c94c63934c855fe1c1229f40819c977dc03017005bc8c076eafd81b14860316d1b9fdc454fa50eaf5b8749256e38aacada6606ef3e0640563eb4d2fdb22cd4fb8152072ab896c59d38deadc7a7ac298a1936a1e0ed882344a640b4429fd5ccd501f91b21ca3f570056530397ba573712352f8ed275a20ef3a48f0fbe1391ac3ff8c17a1d85814d2954c22d1b743fc749cb20db2f80f420afc776c62c5867e570bb94a189fff917695597803b63f7a605af831b57e5a6a7d9288d6949a71b2507dabc4661861219409d00c0fd5970a2e5320bea031889c13015fa68e2dc29d88a55cbcd4d4285c19450512ea8b6a5e31be96e0283599a6e77871f5e5871b79563d3fc7f4548d38050230f3beb27e7a608b6723a998c2866c19b92bb5c933d911b4ce2f5a93fc2352f12ceb019b65eac71f83b82c90876d45d6bbb29834e38fa7e084ef746a5f364a8f2d9441170c94c58e8530e21f5ac5221038e942310ffc8faa18be87775f8e285d676ddc150c75708adf779fb24d96f9994c1a3d3fe8773ef103ca8fe31ff5092b3e457fb67b145b8d6b41ee9701a7b7888276bd6e5e07a99383f462a6aa09cb6c134b34601757a64c6e115569030299d96c37b947f06a2c7e1d591816392d790955404d0aa26eb8cb5c8fa44cd4878f8a9c24f7cb1437c69e396b15d8028f19b80f1cd535104b3fdf5a10452a8d0ff0ab0072726d53d952c42f91d9d1ab77550697be4fabba3b28b391e4a39ed88661c72d60dd529f2567637e45c98cf4ee3722dae7a50084ca6eb728afb6e51505bf6ea875235e06f1b9431ccfb12d866483f5129901b44f82aed8692f7c0352f44eaa5cb6e37c4cdbc664d04862d5cd2f35ee8bb7e9e32c9cc83c20bfd46faa08091c84e2c7312994fb72b889836d98675a5dad17e5f535f27ef2ced5a7c0cd11b8c2e5d4b07e5f854b010c8f1717924b4f9463b5fd8eb5a5dc71c5fafb818f8ddada57814539f065496c74e7fd153c4981a15fc8bd74a27c5841440a51dd2fd9d3c6127ac0f161edbebb6f1ddeabf992ca36b94aa60f2b95d0fde41eed051fa28372a67a060e2e04002557844edefc9d44955f803a471b76c5272c9c835cb3afa8333933eb24e65b1c7e0f2b3a91e57a52dd11250318344fc04969f3d441fef1eaa8455c6efcabf476801ce159ddd00bfcdb31111dc586cee7e877d91cde1d13f295b38c815a90a53fe07c2095147a95c05d593d935aa1fcba02e7299a1dfd2aa2ca317e3a86b42bbd8a97ff4e949c527c5003d8256c4f8391d218a092aad35acd206e11c91fab58192378d0ee1329c04c573223cef2be28257b08deb57084fd45baace864b7d5d98799a4638ebc623c80de9f8727a517935d27846ea5abe299f259f2221854f09607bfcc270ee42dc485f5e9e303c5bc68d1316792f5ab57d04afcdf132207cc0db92b73fcea48883631c95374fe6fc100553e7614a0bf60b784c7a182f78d307707acfa929000478496762c9ee7e4924fa6c7a948664f564e60579d6f291873ea2bbe10b8882b5f676003f22f33b18f60912e23ba0ecb1c8da6a661cd41164975b7416d5a21c7dc97718b96b32ba476bc374cd6b0ee69ca3004e12c61b7d2294d5b662cbf464ced2c7648ab64beb7679ae7c4a0408310accf61eafb4f60a5a27c978ce21fa51d86c8b923933033a2e8212537aaf15ca4baf65b679622ea38c3fd76077643aa91d9f0d2ddbee105210b38f9709ccb950d681a34b6886a066d4ee6b789d918ac30a1e0103219bcbe59898bdf41308251ba0adda2657bfd9b346cae879e79b4fdf5511c645e5ad043e8edd0623ee6b190b9a947ecc02938c4d5606db87d031773334a9c75b80adcb0705ac90bfa34fec6a43dec4a506c25347a8821001fe51e950ed53710b8fb0e19dbec343a30a8f062f31894834101ab1839a49c43b95d4d184438c0591038c397b25348936d8929ab401f48d284617e1f5ec4e6a2c1a8bca511ee08c962e37b6476e399d966cbf5ec8e46c2dedec4f6d24908205abd3d243bc12d3d480d42943c9dc2e9ec074ba77d1eea0a3bdfbbf178e98b5c673171bfbf55a9de256850ab64f6fd2f288ba7f93a07cea302485120d4432be1127c8935d3c36a0d118e8f559ba5bc9971677dfd48ff167429d1f95677455e8c5190b8173d18bce66537066f4b52eeb9c6df7419b6a1e897e3a80660f49fb342ece4ef1168ff4ed59224623696a0b04c417cef224f6ab15c8c4fc047deb1aba7d13b59aa0592396e7e7e90309d2c24c5147c3bc27c207d1231d68281845a0a45542e2fbcf06f978d6cfe74b3ed25792183ff97d2703af9fea886415f47e7c31472a8c950b0b33f06c420d73536649a62140e3a3570c95f34eb20aceb73af7aa8dde7cb41b20811b8c31ce6af30d19cac29363160c6650f34606d9b02a8588ac93eea16ef4ee60c06e55b2c8638f6f495ef28c07312ab21cfe7b05eea9c1cc6554a509bd5d9521cd2a52e584ba2bbf06fd1d0b4fd76043ffff211d4080d372f7e2266792594f2b98b25a82cb930b622786a0d2f2d7af9c330f4f559481eaafa18233e208c5371fc99fdd72e85973e1c7160eb23bc982ab0b1dc162469074af7b76b9ebfe886e2477d7efb5c985ea3e184f91c7ae6bf9e8c0c1e4cffef2715e46f80d04436fcfdc057fcb38b9c916351eb169aa7a7fab4c36155e744194941b7d1c0e241e0ee5396abb2777b61ad6656095e06763985f59a6c6e19ca32ac44278cb40bd7c613be27461741e1c1037659db39e64ebba13e129ad796de632d3fc989d980aa855b610110a44d9a522bb6c7bdec8434f0074e9e328dce3135b3a8ddd7395270f27a1073064cb56f9ff94f3f3d32077c9c543320be3e01982c88e0067574bcdaae68555695d43f30fa9ff8c12d094ca68c5aa90dad5b6333056c200aafb449996c6897ce8676445bac5af4ad34d7fe163d01e7006eedeab7603036cf21c766b5c0c978cc4f82cbc4018c1d789f797f87c75175c803df26fd1fb6a6438cb2e6a1d67f177b260185a2cadb458aa806fb92a4ed648a8f1e25affa05bd531d67d721e68221190b365dd00bc9f5d31a2cedb137e25335792d4dde41f0c00939c873fb3e8c3a66ed98db514b1a8cae9bab45e22e6bbf731a2cac4ec47b9209d2f1b103b11c3cd8b5a71360f9bcf5e2cf47649d143413fede074be7c294d3ec200d4dfdc32ee2d03b8f2f8c1d5ff79f402a5d4318378a863dd7bb23e3537f9f753397e483bac5b7e9652bdf4a1309e4b40f9d8df35c597f10b0cd038d2cf57454e6f0b188f7c6058b71acb310004cb629f34deb9b5df2b9516e4e902a1eabfc6a6878b5efd69fb3d2f0ca599f53caea6ed826f8b9000ab0162e33f1d25f422b7c45d1a26f673cd53d61ada2c8c4ef945d7178e4ceed717962ec54d088c2716a8c96dfe041ce0f6df1c202edb514364287757dc5e8778c2182efcb7ace0befe5127b73cc29766c8ee25cd266d0476e122a351f71ac574f22f785965da750aefcee81f6674eec8280752aa7591d0b9c2ae323f9fe87e9057eb6418120beef888684f45be6a6cf00c762df53003f8743385dee5f9bc5a90439f082ce4c56ac21506a89eea6eeaa42b45f8b27e0d40df614dd1e40583d01d59774d96d9ff6b2fd8c5699099ccbec489a6068d71803be5dbcea0276104adb7fe4c1eebc750d00636fe9178e44ca9ead8ee95feba2f910dd705ce3b559de932d0651c45524ce6f48194b366455682af4a1861c7a0957b5646f8141a50c10004de0145c95ff0a826e65163b6f612e8cbf9245bd859c554b85039419757f95ca87351ad7fdf9c3ce3229de03eb347a8fc82c67683267c605ec09a628929e100f696c847de5d83587d2c2fe3be31c98f88bd5f82ddf7423cedb2df0db27a3109523020a928feacbbc8dc7331e57d22c7548d1e1a3cf900ca9a75c41c8809e642f9fc49c3bc6e1f3094c8113e15454f07554816e98a16ea2415dcc2503ec5b92a0a43557169ac12f4372a7b5e141db06dc2b69ee84c420ccb72122fb19244ff92592c16985e18c3a599e19aef1b7ce4a8803e89764e965ada07499925fdc255af451e1c54815ed7a71488baa9f67736e03f009dc779afc49cdaca185d636223d5aa67c276db716617ade4bd503d3ed2f6cfa465b757e5fbc5ce9c582a93de8b871259a14c1cb12f78d91e31bad52af6af393eac43774a73aff657a5761b394037128ec26d419883369d1bc78668c2cfc40d368a05c08a0cedc62b77412f4959b96008984336caf2cafcdb64e8e6d7f4146e95618ae7316057176f275f049b17638b46091f6f217f8c6a9b5d90b6c28125a54e569ff2454a5c0a82ac01720ca8f176dd123f7ab2274ee4e9a2ed05ec75bde88a9295c41eee8619441b2fe796c44a6c5b555787d07505cd53f28c11f4c485df5706834c8ba9e833187a88dae55153112320fc7d4e038e0386a963ae6ea7401622e27f3f3b6c1ddc6f0fddecc3d018c93c0a4d3e3fbf25755ad9314a975d380b9f7817956447edfe62f1e0f86e15ecf1a48f848cffef65583d170e27b58aa0d70d8f66252ca38da6fd1d5cc3f5d6600a043944a9d0cf5f6831500b3e90a308c1e9b2835a41ccd852f9605d64bb0b219c62b3110d7ab9bb22cc4ce15bc5337650d9a14d02bab9ba61e2b8173da1e25c17f20a056943de4ad6e244606f0a6cd1703d300a2a9574b0e66838c9b08a4b4c5facc9e5ca0169edf7773917ea34f2210086d7fe209895236a8750cf4254673094fc1b3cf464e70299e08bd90e86dec9321e40ed342351a27b2994141397c5b995d4ca119c3773901e78c4d3aaf525a927a7415c7ab3295d7eb4ff40ee2d097c4b08a7c8eadc6cd013fc1335a95b89a65558ea34d4c59403f8f4cbc80b545bb24cab9a7bbe5808704ace04f9929772280055e3edd16959429f5cda337768964ef286527854f7143a72de09d4118233d95ecc7ab74df15e498ffc8808981b27b843fe38d9bc4cd3e3fc6a26b3d612ca11223443236e0623a0511a0e7d1b4c2c066efa403bb0f7b36d0b57b468ab0b2f1aba24cf442d83e658a7f4cad6517e6bf94fc297378334741a18c88bd905594975ff5a7d9919c09b359471dcac4f283c9eae74e6740e6a60cd45a4ee33680037cd9be1cbaab8005610a4b11be37cf33921ecf0bbb2ef9dc49e5252f66b4163195a8e8c16a08e07149a63e370029d98a26000b1e24273f6ef1f7f3b24b8e0cfa08bad344a1a82c53f8cb0c34bb4588284c20d8ac8817082da76de96b2eef4de20dd1a43c5182b5de77256578519e272a4b3f7f00dcfa0c8039f01b1e3bfab142a87c170bbee72507e48a6cfc3045f4ea11ef8e63c5136f105a5135aa39ee823962a77b550a2675daf4a9db84d772fbea84bde68d2083b06b8f27312c5ab677397d8a3bba49a48f70c25eb45dfd31cce5f91569bd35c6c9e1ea63f2f7247be2c7098507e51436235eee75cacc35d0d1d935f75dc38f82cfeaa0fa310901f87a66e86d05ef2c04fd2f52af62e437ecd3995fe6e186da49e4a4bc3bcdaf9697540f3222d729a98fb36472e2bb220d72aca8291ca3ff68a83c073fbbad4005be36551b8dd3372d1c6603d85a67083dcb226bd9b6be3c7d1f645dbdf1f8479ff4c0e98ed02927c019e1006d570ea760cfcf485b70486db84acda29165e0e73cef2b262c844c21be23dc7032d5a40e2ff07bf871103fa034a18b746172131a0354f9325ed3ff714f44a9e9388b514330c8f4e9f808aa4a4a0dfca6a880440918d9a0f881f4e41c81b1c230d889f584278d8d2f9547e14d864fd474607578cad8aa14a3891889cea724d7e2555e0c6e4836399113aabe72cb688dc90447373d91e75bf13db8695ff7c11ed66958dc654ca08415fb3748b2d96251e70c5521a9945e95fd89831b38a61d3a81df0e4d59d43cca2c599ed7345f0d8e56b50b6202efd03a3dbe8e91a6a394e6f08c330778cf6fb0c7922f24a446677f2cddd678c6955d5ea4935a069a767fb3b2d9176e3ad76c6a54958a50cc2b61ff365d41552c9f786bb1e015816b46669c5e207e637c66fc8db2dd38c021f02f1fbc024859c7371e04c909eaad0b17b1a28d587851c1c7615ea96b5b236af28c12c01a78dce60202f7aa30bbfa0298537ddc9bf741e74d6dfecd06670b2ca112f699f83af402759ca048bbc31b768f3d5a7fc338cd7cd423b6aa7dd315b127ea83c9c3a7578c5d4593837766b88113a4c2c1013c3f2900aab42009c4eaff407ec2519c23856b7abf3c3379f67a9ef0bb04a6201b4b88bb3218834923e00af54253f7d22cb16fb1329462b329e1007d804cfb60003f71d8919c98c440ecac8730b821f5503e3844e876e2ba8e97c5ae243f41a993f52fe88737f694363f776a6b20406a3199cc22b69d4c1afd27c6a32af8b421f9093b8459c2f733d6954b71e5d720a9e819462000d1e9f734fdf7a699c469077013a87ec73c0c5424d42d092eac05ca3fc14090261a52ea71b98b6d70510c5c168958517d38b552bf09a4532b2285193fc94c6dce516fa1b8a5ab2cfb1a80c17027a1c4861fef38be6aeb1dca558d94f8fdcaf49a4a169a6bc3022dd06b6bc2f3c96bf00d5f3022d0bc609632468c3762061244fdf273ba21ba6cce35da6215e9f94d82752f6b174c60a30000714510a7581e3cc89d33c3e8fb6b3a08b5a1261e7f9f328262feb158070fa551781d1a18fbe87dfe24c0e6b6ff44dfebb082cf4f5db481a89da3c76219b3a189be5b4577ad660b412dd13f1b8ab90bb044f19d7a043db630ad5ff0d232a51e0d5d82eba337fcdc0436594954335553267c1e876910615d4fba31024eb25f2a05aa5b3e68369ca46614c3c1b9fa4abf2ce532689dc86dd8fb59d17937e104e9685761c79d6fc909ba6fc2903ba7523f588071f676221770024d159821caf66b0c90c23b7cea91d44b9000fe51a0b5b53fc31c8553a42590075923595e837105519bd9cf55a393b3ecd1c1a8dd9b09fb313627ff0119048d8c51c4641d4fd3cf32c72a3f7e18e84ac4af80e4f02fcca4ed6a120492dc9d8b9e70daca216af25e9c8bf6534e0d28f82e60e35144a5d58bb9b1656da6162b3b9859b7d3e1c0930d784d998369aa2c93278d5db17f5973c2a78c354cc7a7c791f1c2f35888a6d8e67d3491792ed7ef9c0c56167fa583d1d077d9031687053ad2062f3ca0de8d6796b19ec5bd4dc9a2319cca2854cde899bc57cd3fa3eaa258f2bec86e56a7b28fccd57b231f7edb85a33c39298431a56a5c6858262e9ba46d99069aabec6fa567d9409a546da0ad7500bbf1d3b7e847ea023f430cafc0ba59480784ede1e167d2979c48bed2913632e2b098185bde3a0232a1f0f1d6ff27856a8b4922a70a3b9a519f4b73e1782037942035fa198b156f707847cde3b93b42fe21447243af2bc39b9c9a2c8456d8796275e3f851c646de5ee728dcb1b925bb30b79ddd0ecc6327a25f8e3b6d52bde3d158eb10540e277af11843a3d7e843781ec16cc4dd084cdd00c2381dc63030efaeded700bc1336482f36640f27bbe40d9cba8f44ec0b5b83436acd1160789bc7ea2c016dde753826793916ce12a01f051b888cbef5a0f843bb747f6597166689fc105122bbfe2759b9e7c14e61efb96e1d6c1d8b9a35096827cf8a3afc2afa6571d917e192da87dcd195286b9f7ff07b667ae6f8cfeee3979659031f2c93a3767810d83ea96d062ef318fd751b04165893e0d11dd54d78350576c17705e7639c88c3746b937c06650df3c8a1dc4098f8b16fc2f0220721980d182b3fa302d1f472bfa3eea7497f1d9d140c49ac038ee5e360916402bb54c7313a87a17732d238bb61cc204535fb2cb379c50bc8eee2434177fa90528db412610cd1105812b2d56f605309639b08ac4c6272a115b747b14da1904a8cd7cef3566a27ccae096ae0a31cbcbabd3cb50b031378b8431546bc56944c77afe310b487c27c52b439b98a301de9d9d41cbd0e6314778b7ec0d045b98b2adcce349519e57b5d3eae3a55837bc96aa3889bf0fbcf108a2d30d066af39ff75136a0076a03e93d8811ac63a795e23a5199ddb434a142050947e2925a36421f37357edc26375c62d3332ba637cbe45ae2424bf3b429d32e220648c1086b52f794bc84813a869a7e85fe661f6b5c64e92f549020ff0fbe5a2042647df727139c880444ce9ddd96246592585a2ce4861389733b88df19e4a04108dda43158c6c038471419796e18c0a30299f286363542152fa598a46106a090c54005424fb890ab82ffce6531ad0e019b45e2534b516add8c84ff5612207856622afcdc93fb6a0148fd77f068ddbdc5673cc2a625a29c0a327407d2b61c7bd3ba92061f3575ed5c9f05332b7b573d70f2f78bd09b66e14db8d97ea8222b67cfbd6e27339769e9cf83118afd8c21d5042b892d2f8c43577728a467d984f3c92b560a5c2712c3ca7579442f8332620e5ae68ed63d761e53afbf94daf185e57adfa276a0738b0e2128278e33b755a28f9f71628505d83617ef2faf2bc52286ed47ef167ed9eaa2b9507479add21396a894f0a45d1afcd02096df65794a7f8520038eae9a3ec6147994c02a47e5c87beabd765220288b531000d2e1a02fff9910f8c1815c02bdfce595fa9ae5ae7cbf4865075ba2c49251f831f11844b5790dfe84eb0b3f67774adeb53642245f38cd35b6f00dbefeb0bc7889029add1a8c18cb5c09a8b13b1dddd53961734516a6840d2aca58feedd4c72a89e7c2147bd014e2fe6f4a228141f9d96f8958906f1ae5e1a0d9fe06e952e2cf2803f5bd621bfb975cb319f128d675e8c83ce2c7eb851c2450117b010f32933ed8650e105721e9e932c4067dcce0ccb0aba30afd80c0f2362ac053c1a13af0b976e2da43b5164aeeb3d09aa31493acc133123605c95198b281b83e79d0b3b00dadd305d62b5cff1df76d9f3d8e718420b2617042fad3c0df9b3efa9e5ccdbbbf59f3d54d38b247cab50cc83b04db67001292dbca3ec613aaeec9c76763986b2f8470d3a8e16990fad6f3eda87ca85b01cdcb4f499688391c32f2e3f1fcfefc7de1263d1d31050bd15d2d9ad8c95878e93a9ddce4c7cd53437ab47c91a5c334337ee99366321c8c69977823c09d2f3590e08527884cf3b699a64f57f98ef3fc01d4e9e7c9c59a08c0ba64303e6c5afc2aec9b7c7da677118a4a79c3f3cdb56833a933dba49c67ff1c3866eded2980566f8af08a8d873278f901a4c9018e6f75e32c4bd72624dc316a525fad9625a74548fbdd8737900a74de307a8528a51209d89fa018e89ab075fda8bd47f8591f1ae6f55267335ca25bf2e1b57cf64ab82067a414e66a4d9e2acfacdcaac43c87d6969efb31b7765281e7dd7e3d6d0bc844921194dfd025477a35c8f6d4783710cec064c61b08596d609d16017828f6ebdf94e5d295fee801e5e53bb6b760c35bdf89338c8edbc59f931cb23009e4975f1ed7c2e735c57d23b834f8dcdb48f8e077fc4a1722e528e1e865474ffe9619981f8fa336eaa6d835719f7bef526684eafc03e9285fa2156caeb82a01ac8c30b8160c1baafe7ff00dd8c8e068a41edb40d8abe1a80fea3c854f4fb81251537decae6aca5c0e5c2cc03da64ebb7f393568760016504b2b6144f0efa7bbea6a1e22660afd22fa591b9bea3e2132db636a45ff2450dddd9e0f84fb82613a267d071712d2bcce87e58404fe83e0c29e7b1c3d9f1862ea292bc603f2683af0f968134da3b24b763efc71bb665928e3efffc48de8a2329871ffd3b4326ac93f4f9e9484748840d29c141635fa4cc3eaf7797c0771daba50c201c7a23ee67f4114b6ada24125cf759a802b7a18bc10d2f9a5587300b32df41427693d4971502575b0a29ad1a9a4c6e71f0bb1ea9bb2f138e2c112c8bcb47cec9df09a9a399bf605260b10d767ac2df16b2a9ea4cc77015a705961f563fdd16d52df141d61c67449b850611734ea5b867304972cba02acc850b3b0a9a8223616a5015c477a1c2133e00a23d0cbf97f62a965f3b29a70e6e6882ee6e7255bb0d6a4f61ca31090e615edee0d1e15f9d9b9a94affed8c69e2bc1b18e1b4a1ddc57012d64c8b0589b7b5a677e18a67d63697d790259f983f55dd56e460ed48c281ec2b53b0daf0327f4d6e38c11b976779af1b32d71d6df9397da682f095fb1fdd63d30517c714b80f34d2d8615df75800e0c087b2aa4db32655a3939622506ea11838e59eb0d8b7a6505456f6900f319c16072c07437eb06966c710dddb4261faa7a09bdaee402cbe4988a2c03586ff6b2c9b2aaa6cd85308348778c8c6324fb7446ba772aaa064018c65bb19042bcdf87f0f426ebf887557ffe5d2d44cc214942ae98f61b1e966b70994e8d856a3634e6e02eec156d845dbfc08e8aa65bf3cb5c788819bc44d9ded5619b624e640ecab7fadae6c3e09667f13f461f14a454c4dda66ea108a58d7d0a7bd861b34b919dc5399d76f1a43a90e87bdd42e9f0bce980bf719a2acbb391831e3adfac6a3c5977cc75e86a2ea832a696a1473c8991ae378a5adfd3c5ca994776ee5b2f3a2f0bf5a88a2e1dbb7828e97675f6c6da8a872b2f675d2a1028aef3bbd2486a21399070023a03771c69091192f7ce624fa3d3daa435c7e1eac78729f5279f5360793c363a4c9d60ce7209b2ebed860adba901ee99da8f1940410a7ae5230dafdc543285a4466eba57c289039d7176ccc3001e419b2d2efefad3c15bc4b4f9551a50d8ce60017617c110388a25b082b44fda3ac6ea3c2bf3377b5ed8eda53a6b0bb1ec5fe6166d51f7259ed469b736217b77841467eaacbaa10214a90b6ed115838b172022e1e3cc33d6ca14bc868f6cd571ddd815d4412c230040bb7f9a5025d10fc202394e3a24ed7e49cb69d6ef9cde4391187dcedc4261599ddef9c199cfa30ef5f5f05367040cf2952c9a803b149a7bb9227ab82d104b0f9a373d2737824edfc24fac71de5c1d6e23e0ab887cbc4d5f84571868a8bfcb42c049075369dcb2e89f1872707e8bab97a16cc6a4745e759e976124c0c1a3d2b0397c1f52ee251caaf2041aa8251ef9047907939b8945d5d1a0292cee064cd79cb6c63622268a578a0b9b66adc988607082a6e7c8f95091e53f44e92ed9c2a99747c39eb5ea152ab6857447afa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
