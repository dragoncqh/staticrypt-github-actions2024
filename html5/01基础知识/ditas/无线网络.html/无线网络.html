<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3140cd785e5c47c69312c3ef568b5a87a870f5a896318a56967dca0b78350910364d89de81e80e70745d030a734742f97305baad6fc564fb04ccc38414df76980ad125f62eb3d9b34c7051c72cc4e91ecc33dcda4d97b5b7668e0ee20bf89af340cb9a7e519097c97c49c1cdfce9e18b44af943beb6241e760291eb365991f195f89e05096a2623d79e14f9319770c21007ba824a5508686ccb008ea79f663ea6cd013d6c10cc00e1a0cbcbea49579e877caa303d240c9826df5af52cf3f725c9e337554a093ea7daf3634827ade6c227effaa8d6a100db780503fa3efbc9199d313fdf5f6a6c50ecb939a157c2e604fb6f2bf1d2a701ba9098f15e99f0772434e820afd6e92654643050f58965c7c6149b10eb88ac140deeb0f1ca8f219bb1a65ad6ddad4dc91c8ec8970e7dc5e1112fa2ce3b5b6acf2dcbd4465bfb58237e70db19d9a8d504d26a178c446e3a8065556ab1fd99da2fa82d8bdd147a46656db42fdc7a27b4d889b4b0b8f12394bca9fea8547781802878e6b126acfef7cae9af198720e3166269dd9f0ec8fe12d0d932ba65874dbb7f26ad7fdb476d1d97b8995a4e2900f71c8b9aac95419814a3835c5073607ff16ccf1e95878a662479dd0fae0b1ed4e724ee74c0b47b98ca0e903ade0aebba4af8dfc1cc28ec2a6378880c8600dbb70d74a3d723d8ceeb194e7d7e180133ae2c6447a6d17fc6a745914269ee5788160dc1e992230bf31e72fc832642267e1200f8b2eb4c951e43e5a8e362fdbeea375f644fa122646b17a34e6e1cf9ed848fdfcbe19fee5bdb534ba9e9d184162919a320e0654a2e95be18b33ca2bd295b2ad87476c85d81390de63359a57008e80fe688cd703fefd5d2cc34c6a84177656e2a315179f7f4a0054761919a50d99b263e7d5cd5972e950336aad95f3df376a361ea73a5c25d15ea81732e2e4265ac31d43b59f3cd32f71fbf4a405689f3a2ba530c0fa898e16acf9be533cca365f07a5d48b1cdb678d291df3a7f56f7013e48ecdcd1d023557a82c039d560ef8851ed4c9e79c3c3a5cdc044dced6a57bac1c898c1de56d9775fa7ee0f78bcd09687d3326a645d8a94ccfe2be3634d0568ce9df6496303881b702bd4b1a23925884cd39fbbb3d0ab520a949f70a6d9c41fcd201e0c48528e6eea98866727162ef6aa5e1cdfce274a5a1cff80a7496444d3d8e2a034bbef02e17bf90e5038e28d7bd8fd6a600415d6e6159b15e9b0ee3d61fd186b171eff8e7453d53401f74eb32944a0fd1c9f87f4dc0d8804b67fafef7d43fe0a2b9765aa719227a627a587f9303684b1b82af5f79c669fa3b72ab05d41eac730a3cadfaac0be51134da0b8b8cd1fa93d7e052f14b8f09effcc59ea929170be673913284a5ce563294d1cbff53f9163390f1a0b915be0dc9ebfc6716919a48cf2ffcd495315490c86d34ab4a175ad882d92c5a4d7bcf46067a64497c111e57f86116e88813866d5fe39ad66b8431bd0f8b3ec6f13edd4f65bc0373deb29ec4f785933b5f5a50016bf87cab2fa9a91974538f2879961c07b66fe526951b1d1a6d04bc4d188fe313654fec987b1310afb6e2520cecb69ca96ed9b74d6ba07029ae3e8a12ac3e5cc0a0be0f7191563560db63d68f471f4624c9942988d6219dcb4adc5928c07dd5f251cb6f815fad9d360f369fc3d9b00282517921ffc04c632030ff35d12113a85df189ee8290615e2b6db6985027d90205ae5d2c280a149e0d521525415a0a8ea560edea8453dd3755ab55d6f18441997def9cabd1b0661f93fc897b533d5f654ac9779f8deca310cd21b54310409fd5273d40e0eea329b2109f9f9038bb26e44d7b49c17dbffcf379f700532c0182d2f4e382d24f7f42ddfd9c620e4cbd1c5bbeda6e9699499e459e156e3b4fe96882e85da6b94b78257e5e518614254bdd731fb3d8778fec864a7f516aa2303b9fdce0de7a581bdd32a5544fdd5155cbcdf3de7d616c940b979e94908f8f587306a5a1a9d97ce8531b0a1355dbe5844c56be0a95083fd5c7da2ae168701be5a9eed35ea9715aedc070cd2192bb44cab4e91429eb4ce4e9cabf7cb1d8ffe9a158ededed8ad69f5047bdcc5f1b483bbe13f55539d5c5be7c0d8d7d029fdc481269ad455b9c74d9572ab11708365881bc4ab38363e7d2f18c36e41316e2b0d7369e001fb50790b97b6f0ca5939a588d66eaa63582ae3a5b979164ef2e0b49b55dccfab6e9802c4bd59db8607b7a71606c7fd01f1193e7c1c7d30c119f9d7347a9a58f48ecd58718b791d963c9dd30cb1d6468bb0e7d26b91ffcc9c61648bcc791f771c5dc1ec3df2e2029bb49404e5eac2e6b6ba32b8ccc440caff2896b6733daac71182b4b92f9a1e33e6edfbece26c15f3cf915c364b8ef00aaf020b11e7f1744b984031cfadbd4d6a4696709cbf15d5ce3328398efc158024db35df882cb7e68b2ff2793a5d3a463520def4908227fe7874835e665ec5bb98a6a457f69f3edfa970cbdd2b824a5d4080318743f96d6f2f60abc275c4e745d1f676c991dd3b4df60702600aade9cdb833f403d3a6004f3587ce2b621b9fac46bdecb421398c38e7b896fc7587d441a851f8ebe39fd80c7add6af94edebddd06babc2a2ea8abe5af9bbb43a8e689ecaa34b9683eb8db0c2d11f2d859279a403ed22cb6b7c1079dc0e35c2aeba7c09d45504a9b7f325f583cf180b2d5249c9c1ed3eba58d48a8c5f11bcc0414efc7dd90e30853b3d6e90b802cd236e336eee1c0add5f17e6c9127f9ae4731be0a10111046f3c8cee9a68140d2bcebe4d4eac2d05bc584d58448aadafbd8055324cc587c16b913259c44e80917d1634becc306e3a4b2a0d96fed6963da163accb0313c60d01b5071346ddad81a11748c47f2ab91e47253114c815154f8f86f3787fe0d7a23d713c84ec1b1777ef88dc9def08773949591861e18fdb7e3e9911c93604acd441326700dc2ccb3454acf282444f94584e890299d3a88b056a6eacd563c1c488b3ead05841325975f896e5f63f7ac80f43ccea2b2d0d6b14472b06a74bab67ed719b0e828b14a6d2d14dfe4f47a44aa5d41e2c8d36fc894b71e2b5ec1566593fda3aa265d0b1e0a0db4f6a5420ab47de4b3739119629972b7f5cc6989b2b5fa399a2ee6eb4b24deb4ffd01d16b3ff945cc68d6e4ac6a2cb6f9de24ff604ca2ed750d5b1959eb4c87de43f2e63cfe2d0d87de559a6e0fbfdb959e987e46949c1934022419f4a270d821a2bd211ffa7b287d1fd75abdc15d034776584947594a521ed987ef28bbdb0dbb27362f429b0f13472f4edd38868574f2149291d8b368467f6479de18408b6c5dfc6b846998b25a3fec3e638e502387a8b71857e7015b6c79ee639a46a596b467cd78fd0bf004477f560e25732ef015c5cee65c9195d4a4d2c1c81068376fca668e8fe35b4c70a44119cdf1817e4117d5715a8e48c81366e9ed66ecb7e01a15103fd2c093392877ded460f25898b66c95c4da92e3f02fa7788883c51a4dd8177a5c4b134658b6799f6b3d003d5491f166af63e9bf55e4c1651fed273e0639240b20f2517cc4a7049331e50dc1ec4692c7861ef9fbd7e39fe43a2964b24795b0a4cb8e2b80a096696540b685fb3651d17c0ddcfaac6bdb43bf0f8abfc1a7d6f1795543e8add30554414d4be4e43c42b2c5e04ed7c11a79f78f86f2cae4d9ea47cc5ec78c0c4d2aced8e1a554eddc6c61dc5f02b11b894216e8454cba87543038bbf04c3affdd8f5a4719366e6e559926a8a58b37ae6b9e89c457712ec91d6e4620a61c57fa05a324093c87de9c77da7a2c1f76ec4b54a5aa7c00070bdea8e865bc2ad51a5eafd946fc0165bffe1544dbeeef742cd9c68e7eb608889a5a426c3affa69fe25a38dee3f6658ae605a5aeff2a93b71de6b75f8035b3df56a0a01b386d0371d26175fcc07f0eaa8ebc699a58b1f9d629e98bcbb02d3440753e5806b22b744ef8d7067609445c0622659327559a599857d78465e0d85dca30a6739aad4d408337f601d5628bfa9d0dedac4c96d02e4cc44bd3a941cf6bdbfa5f53648a94fadf438dd8a3d1bf083e49a6b35c7fd470ee322ea0892e3e04f0e2a1c9a047e6289e619f5b59a3042721e81f6623b1b5a91e5af94de42652d29e4114458ee0935fad060a79d7e231190fa0ec57fe8d6292a6571ab0a0256ed9fb91ee34376e2e7db77e5a24a015a89a0d94677d7258a4c9a3101c6fa25ebd7ef9e1d7673a585787f36dac7fbb66ddeb5e8d3968edff8d048943b5c943e317cdf335378134d11306f5d1f0528c99e5172a4d3ab468be8348631adb4063c15e1953b40a786b16895f35c26a0ccc7f922cc87360b8db930651075845522a55b7cde555c53d6ea15c3861618d830d1c08a2a0f5b1e4f3e9ca8eeda1b85a5ba490bed34ef383ae067f753dc46f38fdc374c80d4930a3952f0f0b6f686f5d9a188597f669d7b5951a35cc3b2ee615176538a00bbb7eadb63b9a7534fde1143398d9c57f0da3fb163d96a42a6c689f769fb6b3fa4da78fe020cad3024d873d257b555a5d284c9ed342e2e3906a9bcf0a0dd1f20d88b65bfbcb2160d5da31fbef03025c3739c39fa2a6b81173e8526d65dfef67f507eaf7d5bf523e95b002e736008ef51af94108a69bffd63e036c16a71dc24aa9a6023cdf9e8854a7e5b46da82cb51504de323522f11241b2794c9e3d77de3623603baccf0f4eea7897906004ce9dfb82b289256f422b573acbaf5015b9405e99fa17e46ab56f3e657dd34e9655c8be381ecb52f618bc80e0ca156983d49b45191f057b9218e12f5bd479951dbe2693be7f45ebedf6407c9817cf932854a340305ebaa3f8775cf3448e22e00e879f83357e095c4bc51769b78338a8caca96af4b9ae0cae3a924589ae85945dcb7e37b1eb4c90733159b53eec846f0c904eb24f2c372579bae53d0543a3be71139bbbcbe3286d756b16b8e7f6f7919c343b34c4330e1985f6a45699ab0e0bb2629177764d8c89c34479fc0b534208ea20427c7971c89ea69fd753acf200e5714b8578cae35e529d816cd459c6b7eaa825cc08a0e53db5b87810bce9f5275c6c19a8e060766b4f35664326a0541b2974ec9e5396dbfb2c27ad8c350e7b0d8fbd8ea6769458406710c18a1907cef873e215eb5a36b876ef4077745e0417c8ddc876378ea0cd6d538ce0d3e636aa527f78dc56b7c0f942531fb74376bc72949b257c89fcf203796291815cc8b89a001941d9606500f78db686e3ff07e735da5d886aaabef20d5474d25bce85050172b0205c24d58edd7870e45adcbb81c0f09865b61ff45ad4ee6a2d97c9a6385de5c508718862ac399b2de4ab0c82c268e0d0956e8b01bd432e9e6774f64526f332c4ae901ac59be7d7f4c787ffa1f7142e8dff82df67cd04cb56b4aab684f8f26c71d68f600fb8ef5a23fe29a9fbf2b37342451018bb65cc401083130aae4fb4d68b1cb3617aa1f84da07c959bb4b0a46cee9d5b6564233b511234ebf91e98795494bf2f4161441a570a1d622955e2fefcd37b30e7ddcf5808a1ae50489f3803bad54fa788f176eaf5699626871e1cd6b12d9e994c2bc2b6741842566dc100e0d0c5d9178af768e1dfc78945a9556d0223a6febb6377b551e71ddfc129f688d50dd5ab18507c119309b5e5001cb2336cd719977013c57c27e231fc46488dc508b394f761d0c76a863c03b0a077537338417349529fef9719870837f0e1c73ef22801c2cdb830317f7c73325f28fce52f46608716438806f0b87da285e0633f6e962dbe92cb554801d379d8077dc53a266111f7c4c7068ab34ade9cba4d8ead7d0d1612caac974e3d62dc95d651d5e3d2fcade314f7feded0746eeae33b6ba633dfbcaebcf1a10d0659b0f8c580f80df705bb2b222bf82dec7e351e298ef28ce7742b606c2f0b975712023f630c4851fc3099b2e740ca41096a3a72fd51574c791ea8ed036eb3d72b9c608cf529349d35bb9917abca72818823acd18efc0bd22030feac2e51e44d76ab5a59b0a71bc41a5f3f9e8eda03f9c1e1c91983c230b993e5e8f219d43c489fabdd655fdbe22a7d0117baf0f21bb005f3ec222279048bf2bd30f63ba8c6b721a98a9b069a9557b2969a0fb50333c8670047efa890a09bb34e919baf3811578d64988fe3b7b91c0fb98e46736b56df96df9017b19b9fc89df130fd4961cbc4787ca992b00f027feb791f5768ee0f9a8ed150323c9fa9ff574e5cdc40d9703554967ccf88a921662bdee9b1f3e8fbe9569bf745c21207736674fe6388d50dc4f5d8eff34b15336429af6619028c6f4652b66b0204230066411cf4a54c0d6b0ef57683adddd2f3adb36b37f362d7c10b4db0a2c715f9ad798df9052d863e6da4ab970887b12d47ab932a854e5cb2a4b6246632d28e437585f6330dfccd57acc955442e8cfd78f6d120cd86c649797aa5fe4b35cb6ed1eef5b4030fdd7f6e4feccd05775b05e703db1176bb650eaf1f42748233538bc0f2f01de0e0808edf7550ef54a9bffdfd13bde89fe05f26797a3d5e87f35fba50039ab25be4680ea33ead3205d859d8fe067aefe73cc72522e0f91e98d298206eade7bad89a244b920daeb1e015213850f000f21aadfd93d073968d3530baa8c8fce774bf5cc5e0ea0323bf4724a7a2cf35feb59c4665bf8afdea3d15821528178016b4967edd2a62c15edc5b8172060b3a14c2f71024b3402f756c797fcdb7db9623f4acb7b44c3881e6c870efb44a47b6358def142d8941efff2baba8d4b72aa57f911fb28834874b9207495d52564f219d4200812f64de7d9e4a1187fb2c1b737391268e720cd9d128f881d9ff6cae84d184b382c43f93ecc5b9cb37971b4906754653a4c0c8476bb36396626f991e1b0ab5b8c185bf6ef2a633630a023d24d6bd4805ef681afcb2b78f795e5d79cfd02adb21bc4353229546bb6a7571823ce39dcedb61d725ecb1566f94a7184a7cd89225642e463958ef18a9e8aaffa9e6febb5e441dc9273fa7393c4c6d2df406c05a4ffd1b7c89d20f88e35f83e12b4bc7f62db99fdcc0aeba019c7e89905a1526ac1b49dace9dae386e8cf7683aed34d2bc6c14221928845c8fe6badad54aecad19629a0a92db763955733c1f335fade05fe274875a615147578231740036e38b7d2cf0beee30ca84d63907512ad591a063c137d132f57c248fcd1140052268ecc9e378050025ae40333757581ce1a86c49ef8e4e8790f9c34d9e3714e1f1c80be09bd5f78964c48c3645a196b380a91efc27f57b8934450d447b652c75a625c2d12835e11216e56f86ee1a8f9d55aa2e0ecd4c43d2b8875219e249cc27509db842d9f1ea98cc0028ab66ae3c7696db46a144771b2d4eccaf8e685423e5ea16452dbdfd61838c8580e5e3139427673258a70645aad55dfddb44382ec04161bc4c567a4281a4cd38dbdb59b8980a881fb5fb79d40b15a460355bd8afa43ea2a2fe9c1e6c45b9d1b87197be0813add83601ad718d616cc2b0bc9bf694b82b9f1a7a7e26a49cf397b55632435019beb4c8d4cef62b07adfbae9ddff118e4f9e06de7b922c920917814e75d6e1ae50b2da5c3ab781c5bdbb3dc70f8f4257c80538a119a13c08afb49a34693e7abf30dfcc8adb54c8929b272349961c465322b4334f13a2ff67277866808d218970ca185b9b2b73f5e4a0cab2b8ae3e89b70620cb13c97a3fefd6240dfc9ef695d79909c83213529e0b971e0e0941eec96174823502397680a4c91ba38ea7663572bb45423554b6576b4c5e28984f47be2714714342d22d2157c590c4932111b05a441f931c2559ddab6961d708ca706e85d22cf24d32f67697c0db68b354741bc271ac492aa8967a562566e911877574e1179a92d42e95f6a93124cf7cce3775b5c7011082720c55f50c531a5f8bd8d47b00b6e1236d24c6462769e268a740e1a6692a1ab5847e6bb9e26f1d192bbd7a5c60003563e85576eee8541756e1c9fff6937aadb67fbafcd0c043b3282e4dcfcbd74e59de23c6220da840f8db8186c4500643c408e687b022973af4eb80ca1d7009d216f29c34ed79eb5caccbc2be2a4a486efc182d7899689de8f6c9c98d7a0e6135611a67ea7ea224ccb3d8089f4a373ce72aa80e898617f3d396675699c2434dc6dd66388f9283692404aed5af109920cdbb12d9ea9ffce8b637c8d560f9c7ab58f34ca1399f2f0cfcd3c9516417f1e6f39c00173b8358100c14ac12ab5ea0488eb5b3be02ccd006b922de988243768881759f623d65368e5001f9658ca9714c4d16103b60416dc6166df99c2f83605757a51da48ad2597907242931f795d50a93324f919ca9a24583f4c8124ab73656aa6ef9db11352a0ddc6947940fae5f03cac4611d316ab10b7078ca5a89791ceee077f0b66875fc465bf963b5ffe8f447fda4d2e2a6fb79b948126565ddbac73255f0afe427fb16f69be39169708817c2e8185aecfc3495e2ea554e26c259840ece486a6af9dbf06908fb38863ca8563254e9fa7cb3c7197c3aacc51926dcd3560de9aeb9794cd19c07b549a9701cac731dd761731a1d9f8a504b867dc94ddb49a5edf38e450a7c325916d422eaf521bea495ee81a5866d1c9a50d64a9e702091cd834f107d6ae542891cff5d1e1f6f5b7251d709eb74ec3488e1f1148d1e16ca6255ebe3d5be6180329e76e2d2b86e29f5818af196f1af7476653defca49f094aa65fb92351f21326e40227ce6e2b488e7381ca5d72280fd2de19cdd674e00bdc3d5691661cc4dfa46f7d59e96a599826a04297e230148b2b765d36e77c95751fdbe9cb4dd322aa6d676c6b20e73506022ed0a1354a71e3677185b4573f45de8c8697f683ef5fec773fd4ded1039baff00dd2d045e802e154f54b7c65cd0626fe55c301a7e81737f5a3715406f5c28dc809139ac1e77e027edb9c3f983f1a3b9d901806ea6aa8457ed2b6430ecc72ff06f42468a1e9e560be323de44593d3cf7f9acd8ec43abaa5fdf4632cc39522ec47de7ef39d5e06e519fe05a0c6190f791670dcacfdabe41600d827de698bc35f27cd081c428d3d92d102e741c566401625707b6e91a6c68234c5de450e308f0913f31a93df100926610ec60307232b0460c6f5c2d4d1f6cad065196bcf96c16235ae6cef192de51812e29c3cb2ae6a00f522eb6e166a6184fa878a8f7f7f35d2561609fcfe4d6530f25b30a42c7ebef6634954342f976fd6e27b40db71ca353da2ff62e3e2378a849ea57c1b6a27fef964510a09bcaa83708f732a8ff937300cd69d0a092fae1405c4e8a325eb6c1594ff557b8531897fdf826961fffad8384f1ba3f490f80dd2c45995700bc062a6f666ce80867f062058b34a0b3c1ab24639c41f0b5633406cced093056e06710139c2bf18a906f8ea7c1a4a2067db7a7e333137d78d24f5ce5cf98b39cefdd026e81057d82ca674fc079b174c3ae667bacaf045a44a4bb15d98a8a26927aa80d85265662fafd674e99d047d38ddd6598dbe54235e2936513d9af5154d01b3b939436b99083a0369ba8fc80ed0dad2360156d1c5de64d59067f79664920d52fd44a496318b67a472dca4b9d572ac09a4c9f50cc7fc9e0c99e3ed33fc32cfcee2ea095c6ab3777c36fa3a51653cfbb8aa7a0ce094a867b70ccd21c726e72ddc2decfb595102fd8e51e492879f077e2d3113d256af7f594fd91b0516980894ac1f3e228fd8fea9d1df7ea4a6988bf305fd55d7ca5544b6bd76bce4a13711acb2332db3b19aedd333c0edec6a5815980ebd0050b781b791f0624b2c3d287c6fbc4315213ceb91abd0c29b35228406ffe975d1f126fecae4ec60fa1afbae322b46d978d7565f186bf82b667a40fb30a153adb7cd3506f8a4c14b8ac77d41dc8d8114569ed0d155e5f8d96462cd3deb820d50ddffee6984a83812361b172de11d3579ffd3f80db144f5c14a08a8f91c5100277537b5cd8b4e4398bacf9b3c38c7162a24ce972f4ca91298f8c3857fe7561672a901ea800420ba71b80c28a15c1ab254dcac098079f1eae938eae9e958c273c7d6ec362cecfde56514d20f60c0ffee2b6b029f624c87bea1ccef8f6ba5d6474da1de49f512d480b68e49f6c04f9a59b0a9bcf0813c08108e8d49aad4a0f17a8f34d081fda6de5123af1c4aefdd17cee8260578f58cb22a8871deeb91137b127f031750319815a2fbd9ce12b11f9cdd2ea2ce7a4f468d1b3bd108d2f1624f0ec1d53cb9ac1f15d649b100afc250a6821796892a97e70a84229e088bb1ceb4dbba45e4282a1b0e5ae0319c8143b6cd5892d3680b0a6d5d2645302939b8a47b974a0f4dbbae746a142066d0e6181e58debb44d2daadf30222449fa1904b2aa97fae02309b386de6d6deb33777b78f7e9650994bb3d362ccebdba8f13f53c23929a9b4588a55464114de190b82f75b4985ef00db5dca88588262f922c8dee534f9942bcab7680366ee47f150e7cd6813b00bdedc8cdb463e419122d43519358dd74402cb83b4f33ef0056f50ee78d84e49e2549a6a414c0db5275125a3b8376fb0bf7911e07156cd1ebf45814b0286e12bab49929086e143fd4ecd971ea709a8f39520f5276a65d20d5da1ac3defd3fb355707f4390da421337863ed00a0c378a0975bd5d1cf6b660b4d498fa7d0e37ff517f40e0f1e1fb14a242f72f262f49dd38c556cc8c62e4584b99751abe2730e05cec177825743dea8bb3badff7bf3c00eb7b5af1de8677a7094ab926d70422adc7e2976c5a57c286bf8291d3581e5afb274ce75ce55ce1b4cb88601c4f938e476a4c59cd181999700064655603e871946193fec7beabfc76d295b0b09a803964348acaa771f109b71a41bda6005b7f9058a0c2b4422034b0ba87631c17c473d7d10bd15ac183d65b5faaaf9410c0bde36e632efec3f627f5f332eb9ca527d846d339f69f4b81382258c2a250972ad5a93400fe4b0d697dd53f36808c73db8462d391bfbcdd11d9c2c9f444467a9e7fd06eae9047292d7fdae5393afcd1fe882672a41712ffc18ec42311f0d9dba65528a1faef43deb856124367a672f9f2d7030f781bee50c8b0082aa4a39bec1f7d84245ff08b33e2f6ca6e3e70e320b71a575c20afc09a1831976382a6a09fcf511cc4bf328aaaa8c1ac43db16a6d230c51581aecf599a6de3edeb3505b43cb25325d114d9b6357426ebdd7c22ca304c8a2868e1f10374187639d4211e4596cd42500c61824444faa9c1d8ed2bc4a1bff7411335a5701c88ad49b85a74b720356463bbb8300ab3091c4688db87af566714fc6cc282d09d3557d381228d0a1ea08bd9cb111f46960a95ea9f0d20b0e41bf36b890b99b4f14065310438618a876d4679b215441e3cbd1af4b6e16701bb50b3ebd2a8dc7abaa7774b1584b7c7b45290580079374ee41f7a86875658d22902ce66f4f911043cc68bcf613b906f37a3ff2272c116d1354d9502678adfe6a0101e820d24e9b8cd63a80162287672343ff3b688031e38a386eb80a35ea2334f33ba72effdf6fd29acd1618c819d76b669095caf7468fb5c8afe7da4ed4d418e85df58759e0cf4140e766d6b782dba08f47c54427768a1689d16a7707652c885b55b87c25d8a4fd8d174c4142c806c0b55283ed24053ad6e0e38269221cb233b963ac4bee1b2452b1b8e1023aae097023496d0606e89ebcb5cb9c6e54d174647b35d78f7d0bc9b5961d865af63305c3638912494387a3b0bf1f531c067e8f6d02410ac6d3b557644af4c67eb938f8bb3807ee41714c4aaab8e5f898ca3d5aa1035ad59b585b98d75da44095942389e485e6aed38ef9c12d29d0925c6114df66c04688a1dbcc0402e95c4e3a8b7b3ab87a7f410019d912ae2f1014c83834c56c92981866cf5f487e6a0e4cc8af3a7300893dc06aef6bbc88e735df4d8fdf3029f4911830765d3ba13d43d9de28d181330b1997342301a441903724e101637b1a5fb2be850176301fafbb42b72476710fa1e91fcf4dbc8d6737536a05e193fce2891eb9297e582c1de063108ca8defe00514bcd35288be98fc0c668a35ce6ab74438bbb2befcb01aacd41581c1de203a49f93bae000062f5b99957bd4648e4f64fbf0b60fdd649c5d523118ae9f0910a59f72c6b429f4eb29a1f37b7a0a2000c8f3124b3ffc74811379bd74c7572cb5e4e1306b18650521d91760404ead654d505bea0239a82ab8ddd8c67c9c010b604d3d0971a8a91142d50bc4a9b34d08a75697c68c0c10d27005700e24dbea8f35715cc77d1dcb783fabea4ffcf7e03d89b0ed410c12e25811497f266d962813c5e46a105bc1fd7c12b6c47c68e624e0a0c0a5a05043cd62196406aab66d14db8fc8f67e0ddc417807b28e486d6b038cfddb9e0272b14a2ff5b13b6b8fc886a2f1fc49a44d539d19feefa00c9a8517ab9b3e70c790c1c0eac27e17c4b9e3ef894927f9a6c568183349b19b8ee47755a99adf1a6aa326534f5d6f7653c4bec194a662fa87e76ec44aa3bdd1c8226ac68eeb86f604e6308941b65e18e2c33a65c359878bee7c51a2b07cc146f9f2f0680f5acb78e7d0d8dad8f86347fe49475446b087715ef103f5e12a64b5da0faa2ca7229db6606dc76546d6aae03a653c8b47f0daf453c1fcccfe69a2c5ddf601174179735870e61d94ecf5bc7cefc9bfb0b41a5eb1269d270d2e52f25032328838fce185be46266a4189016e32f810dad36f585fd3fd62f6d812fbab462b313d83448c18df1bd213541d1136cc3214f47ef03b630640cfd0db2afecfdc97dd5e641513765306309e32447a8a16536d446697f6d3514aeac2d89ea0d1c979412d8eb20e06c602b60dc6763767e33407eae9bdf649ce9e0dfd8e3c460263e252c59b64530269fc0d50f671087c9d3708390559def2d46fd4bd6942693d9728c54a0253c5a06b3f1b2e1421ffc60bfddaca97029e9020e109899fd2124b96abd7de43d0e46c75471eef9a53a64084059aa74fe9a146cdcf5993c747c28ce3b95813516dad7ffc568600041d9b0b11400f4809d5437f6b92ba6b362e32f6e72db625d888347815cfb1b39c9412759230fd5e736ca8a5bd990bf338736bbf617582fd71717521c600d4a3af3c2c329b00d2695ddb0acc4d8b93ba64985d6e71148cd41547ea0f66fa0fef0d8869da7a348c584550fc0d4a634e06e24bbb09dbdb113d08b18d5548ee65bb1b0efaf589d1faeadcad6c810ac6d54c6e9f44863f1a22f8c2ce28cff88ebd5feca1555a0cb3a85bf3627bde77ed47dc5a96a7906dcd7f7b115a0098c9a76f1370108e96f977c7165c5a35d510539db3700ef3c20e6b16cdba5a4548b509d0766ff7f0c1367af4eef5a1ff6929953dc4cc4ee3cfe8fd4e4562b242a6c440556db0b61961ca45380d5521e8d06149c463eb9e1fd79259afe3b3e4b71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
