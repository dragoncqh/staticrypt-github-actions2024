<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ebd4f39d4aac7b8a9bfcae25f23878bb1ec85c15dcb1d6d8a5d7f7f3836015fca30976bc89d35d7234282c82f08a4bb109b47f3d162615ea344db7556725e310964760eb50ac5e1e7beded77613ac9d3f6ccc77a69e30fa23414cad28fbd2bd700adfabbde3ae002ea7ce99c089cb4232ae38187ac58aedbd38452e61a11af21e03620c8b7330a1d0bbec2f89d419b15179ad3133ee2e9700c68d72ce4751c21f3cadcd731455c17b4ec286508d9a7b0a73267a8710d49680132fd345c51ee4a47bdb83d80903eaccdd321f8ae0406e2ff96c56c592da0036f96213c85b59320e0989815712e3e582f85c513285c74e95cd359a8cd79197b7dbd9b528cc23888b8a08fca4a19f0accbd2cbaf995b5b1141e6e1b214449cd9829e196c6d314af42d96bb321d28228540736fba046923f141742629176b1f8fd8a9c4b99cf3dced5661bd2f7b90d113748eb15fadb18ec68444e186f148da2521b161cc611607589bf4ceb2c9bd941825e7fa3becc0bb7c8452c0a5b75d5cd0f23e1f5805e75f495870d3eaf4808c19f4a8cf4b0abd8dba2ed2d523163a87a47c733fdfbdec59bf2c19779a99545a3fc3987601da37be272676956bec319af2cbb69cbc511f1c78b4b68b563e47ee144ed1f8a8b19c2f055162bae2f731d8155b063a8cdf8849ae6652c1fa77514ce5c826624baa94fd176b261499b24cf22f0aa997952c465fc8f466447ef8c9ca7b38a5f86943d0c50fdfe1469e099b0cf707e4f4577dba929adff2bceea0242164fa9f5949c76fab90ac7b6af385b6ddcc2dbf67c9d3c2d17ca3862740b3a4578ae9363275fbaefc3dbcf33662fc85f084c94b0ec8b4f6be58bfc0e9be8676dce8687c8b4decd1a9f3f9bc69c5e2f3e04e2f4d57029ef31aebb5e6e3b66bfddaba59b2de28c14f744b09d8d6f10bc30a64e6c17d0720213eca1511426bb217bf7b0d6504d33f69ac6259c685715d3a461e08aab30046dbf35c0bcbab328118c07617e155a1a55a58b0ecdcd38ab6084d3742ce31ed89d878f52e6f971e3f6ccdf737ed933233e855986a87a05a764048f561955cf9c53e1b0fffdb01cc88f1cfe4ab8e693b86a202359fe68cf9ad9926c28776b65ec43fe18552da989062033b5c79228c7abbb241904936c3ef4366d4fb24c3942089e81f01baafd3d0acb0aee1e113eeda65c2238f8789d56aee239b2c6951b4f4ed5364ae085653be0b52ff1e359a10af75b417f147e83f98ff93109498b5b5d552f4b9e9ee34f7f33836d77a4bd5a76f9c98e5f441227596f2c2f8486481a0bb0415e26587f4265a0425bf52bf1f0e169dc56be3d5ec0d2f08b6f77dbbb5ee95a26e9ce6c1d5eae29560eb018c6e171a304ee1182da57bc947c48aa8b0fd5a25b26fc224ea1bbf0c3cba278fd41df96e8d75f404311251a59714cf3fa9565bcbcd1b7ffae4ed2c88cff50682e945db55662b4229732e59c891036e8dc9e64631c743cdc4377d1955ed5989d638f1200301fb95563ebd8619b92a0c953b47f382264130ad4027a6d26af72b927bdf467170d1cc0152266bd3c53643c53a4259feb2baceb44b6898aa9cc7a62cc7c39fe012acb1b7d007a16c443172b9da1eec7972ce5e470f94930407d0f4e658e46ea3c8a5ce041dd761d66a99912470a97c5b112fe077d2d810f9dd0e1e44b19643d26828f4ba1689e018634d8d6069b3501e75957bec1d49ef79e0552a264dfbbe325c91c1260df0e985eb1383a9bdf3b15c15e30ea627790623e81edec8e972621fd2759e244d54c649c379dcb6d536062c9b30adbccfed51b7a8eec67af484dd912c6d21828f73f46a7180ea77864cb91c057ce6e3209482452a7e1ee1d22fdea9ad1a6fe9e07d2878dfb20d0a16248d8a395960ef9139811236ced798eb3ef56a7a06b599f9fda5ccdf4a5e186a94ad8dd09758411775362d0659f91b2bd88fe2b0eee8fb00940ca0d1a357ac93208fe6f683a5bda16a8e3149c06850db9a0205c325ac708f7bc5bd621d4478ef4f1518af72759da47fcca7ec77d37c1e557cbe007f7e3552bb96509731738093ef40a48b363dd73217fdb9c4e556f779e39c69308394e9029e0e6e8fcc8a68dbd2ca7cf2b27a3350143947067e2998714ed4d8843324dca9dfc8ac58d47169af45ce76a4623217cbc0b183ebef717523e98383feb18283a57eb7a82e445d30470110414d58617527e2c13919dc91182ff5607c40980a49035956910569d8a4a3a5737a090422519f3eadcb3f693eab7b03f47d1024a7d68581b47dd39986592335463b3e7571e46685217d8ccb38c24ced625e9d2b3aab58ab4b521b00ff911390db1e6e8618edb9c2efd30b1e941e14da5792555b076b1f1cd143541cb0973e3489e29f511c930a91c32aec60cd38064a9f0dbef2becfdcdfaf21342b4039bc96666a1c4039804e9e5cbcb73b2b55583593579d6231f4db8fd0af1022238cd7361fdda8ededc5417adaabe69ea93262038fadce0ef77a86572ff3baa1ddd9a8b3d15c208134d69499d2228eb94dce894554fb4b2847646892034e89ed22583e80c86adeb212ea55427293161921cf93d32cbf3bfae75393a79d14a1c5b8a01b35a9f7d07027493e3d8d9c32e444aea44cc0c41be42becf21288484319aa671e9cb940890e23f46551ab94c72b862caa1595e71f77891199b02887712e59dd3e6a01319a79be5dc6d9a7a39517e2f24ec61fe15e8a802d0c1bbc501dc45a9ab8cd3a931f1d2a3f4f0654d45b0e6e6b101b02e678e8f816b69727190366dc2a09d0fbb5bd62997fadf61e5ee333d14c5a0ff5a6b9504cae89e9b6f079594289596639c93d0a1f93730f5b531a527605e74a650eafcaebc5d9bc20a1893d848f17035a2f913727beae3fa93cda7a913deb546673d27ddaa6552b75507e30bd6e98ef33ade04a6347eb54330bf683a5f5a755f94a7019c51f6ad75c46946ef5edcc59e966debedc5f46ff10f12395bd5ed57a668bf66108033838c7aff1df802d3754ce2797550b7b00f4e2d55dfdad3a57c6653949abdeef97cca972d2dd476ae6c0bdcab5484ba873a69a4aaf502e2a85a512c50c80085c27a03e4739c022151bdc8d269fff68e43de8e9b501d7fdbb6681cc81586e01d13cce7b433b3a6bea389623e38bcfb0fbbaf83177e016514633be195a721ef798aed384d4ad2124a72cc563b21122ccd9688cd4c48dde20a19fe21518a9c0b8e7b1735f02b4c8a0052d1573a5157fc1ffd7bd80f3528f15c1e607298724d180acec04c706e869fda2049f8748a6508f6a972fec71b7a6806b165b921cad32b0179b83197e04c41834f66b6d7c577f43659d4eba1c7858f8fb3aae89504e032fc3ae04cb11ce8b4a3059b544fad763f965c5d21f1708b1709e5772bd12d944d113a73c4bf6fc2c54f8f0cb9cb25f862e1b952969d18a1024f3c116c561802c4b15702bd8cce3bd1a51a4849475215fead7dff2352353974250fb6f10101685d9677e7e7c7f13b72b22e8c877e8fb6bc55ceb71d3ef8a0d3936574a4e936123893cfa6e749ba8024767de2b1c3fc0176713fa7f75ae3279777aa427f2a10cd657b87839155475c1be7d9dcce43e91ea4cf99e5c6c22ea4fe43040bb75d5f2e1f3ca24459b920864e6563f2e82be1188ea7b1d5b5878e163a92ad22dc07f93fe108338240787c5dd753339f87d66aaaff2a298113a53f50cb2aa45a6c5da4b217020c2d08c6f546734cb14eadc99216c77d4d283958b8ce880e675202fe357718bf8c3d45b62e442a6576c292ee33716bbe5afd1044059b7a6e16067a14224984f9dfd98692d6c99d69b1a84317d97fadaf9e9563b82dd314cb51795264c5eb3a46bea5566ea994ecbda03700471ac5bf9eb6170114c5f4785a993a9460b2b560c8e128f287f4d8cc3b9a0e631ecabda77f772be48b04084da420ce65bf67ca2ccc3a5b1f5ba4f29feec088a0f3271fe3e3e67ea37075d643161671eb6c47c90f231d2d0c2f2be360cf40d32d5d5414e6599a35619490a0579a89399f08414c197d409e1c44f92b4320e8a82edb9e161ee4c051f40f0e7b44c27da67e92095e63ccd04008f2f56bc350ee0985ea2602fb76f4a0ef37f5b10bf42fff21a7c4422f46290557625471e136cd23cd34d6a664bff6d128af0c9b1a06e6b26e4cdbf64ceaf4c45e419ef87a9b1fa58edea2c6c950c8aa6c585ef57bc0a269ebc01aae5ee3e9a10cad3d6b03cdc5d45a52002f438d05420381346cd3963fe3f57e10efb5c044cc12bf1464959adc46341a2d5ef1fde674b9d91b2f6e95150a12850303f06b7fb88ba11601566595812dbe6a24044d189cef2472597008a3f0c210e9ff0a3a1c8f72eb41a2f92ba85522b056230c7e89e4249384423581e79aa3ddf8341eb2eed47387e49d93e8e4a985ece68844eec53e48a482eba434730101c935ab902945c94194a5fad5175be193f0099fe713d461fd3647f4172a2c275e814dbf8c02fff169157172bb083eb1d6f0d494a36b6ef6ff3d806d8bb3b3e532a3f9373624ea3b731dcdbc35a355ffc4e96787cdda10f4a38cef5e31e3d04401ee35b422053f00bde6f42809a400a523865e5b669833b88503f6bba125487a70cb900d52ce68b2dd6c55c1dc43a12e339dee47d6a0bd5292b8d58faeaa8d6cd47ab6e43d1779ea70681e96245ead6a921f8c8c6a262bf4afbc6b5e1fb2569522a0d11770ea931b25a4effcdd17f729d03abcd40d67070d844883b20ee52b8dd47fc7d03ff1b791c4f8880d0ace4a179f2c1ce593ed75466d7346fa798558aae12477a94238a4fc871dbd13e8cbf92ff58dd54e0f0271a79c2e560835cced1f152e9a780693e4889ebfc24e8b903c97944a0c855ccc6afa2ce42853dfe8e8d4649363acc7661a07c171549965b04b6a46c67d9278c99745bf0f26bdb13203a6f562ae37af0490a93476838768c8fea0f386cf32e4aa3f89ad710e6ab9b31b1f9b9fdafdaca4c5310e43c307c8b8f23cb2e7341a0aa620767f92bcc46a60fba23fea82d44814559740d0e2ac2f2711d74e5f1b06efe4a71512628775070c82d75984eed81dbdeaec10766271c4085f3715ac6fa939418b7649f34ab024b6942d0441d5c0b3d5f69df0aa30d9ab6c0300824dc9c010c80d64f7903cec99033331ed692f00ea49b7549a20e6358100fcbd00b0ec829e4675f77720c2ded988eba0b7ff09ab84856b88d93d8dcb37b99daab3258a84254c86e147120d4dda46d2ef0446f73f799c67492bae6515a981b18371f48ae7a66e901ac1b5e4799857ece5bc711125827875af6b092bb431dfbb7b047a205ed0b7ce9b33df0a4c7200e870b7f93b9cb0d29f27326f190ec47cbf98f439aae267b114d0eb019ad17bdf1b4ab6007b48f596bf2b69c2017da17b0d3a6032521b76880ba258e584a41a0a0afe96d58e560f4a0d6beb8e04ef35553dd76643e25d4bed6e10078860a2ca9a05c2a1031041c5ba5eafe22a7470a84ecd232bb39f6c4e89dbc25358a64060f8ad3271c686c082039d5f2a53750978902a39d4ef61e3392eb60359a3564c5ab7cab4431a2fdf92b1deb64b2e8d03fe27b19766dde15292dfe668078bddbcdc241332ca05f848184852985cc178ec346a7e16f9046732fb8f9d1aa13859bdbfc80fb3421ed6a50e9dfdb41f94c2923f0958a09ca4556ac86b72cdf5df2a4c3ad26e177bd4e65c62573749358bb84c93b6e7c81f1016d2dcfd161facc9e990ad8eb0aaa75b2adac3f7abf28bb2ec077356fc198b4a9a2410cbf06e6387f0cf8d54a1a5770b631b4397d12f6a98c6c2e92e3feabf0df7dd59563064494b7ce3a976deb911221eb2aad7aefd14409cfca52f5a5c6f7caacfe6dd6b2dc53109fbb591c44935d0a562a893a276b18c519493e7402fe3e8f91f4ff734f2dcb95ed86e8c994d6b4792a8850a9ffd51db342c5f7b0c5bbfd6057c1e8ac9054223ab822d5109df657ee47d3b1d742732d10c40be6acd66548669c7dff090f7b71f709f9d10e3b54548f4fe55795528c6acc359c33dfad95508e7ffb1753d848f8231d77d6d9cd964c46e024747d5b7fa0cd5f1c680bdec71d3024add52ac1cd713c664691c2e140bfd106945c9ae3efad3d1cecfd7b4c146d2c8971f1b457301d45158a84cd533e3d486018645128f2fc3667e68d3cdc62d84c3e71ebd3a7e5084911de450087be6684218a6e133c13d8d950f8b0e3361a253fe9093b46a8bd7377963aa9ade5ae6e971cc0bddaaadb838693aac80792a3378b28e8382deac28ae7a35d68b552b61c4cdf3e0c2bbe93af1513277eac28ef685609eebf40e903b9fcde0435dfa0cfb6b259a6d9862fe80f80e144c3e53eec44bde29e29f4e2547b851d54bd07d7c4b4fa8444469da2cf1854824a63bba2d57b4a9559de0334cf764f85c1e7c79a2602b818564f3ef2ec330ef6a8d33c17272f07b627644a593e3be256a1be60764846dfd61586c1acbddb9393bc09aa99985e13816620a1f50498e9c6affba62444306d0710f785ff1c76e5f9bea865e00057d8c5507538c1c79e5cdf97deea3cf4fd940b20adcb5788b8740e01d6f0236e90c49b4c8ab8ea5cd3d50719da67332dc45d03e7bc7f7d526f029d39c4c640cee83e23f68b0a39c9e749c72167f588bfc4e3b68ea5f326d4ee84a8b247d879ac2ea641746eb3ad1c7e0a20b97029e114fd05e6517eb5ff8097c2492343740a3c177037a681dac3641a88df774c5b6a5ae07948b6c8177613f478f9fa89a8863513376f36353e87fcd49571477d9f0dc606a607b4e5b15b336cd2903b9c6058462c7f1cb788368bad6edc17d373efef94440f202aa5e126a5a5c8a3dae5e9982f762e1efa40fb27eddb56546201b7ca0a1a98ac54e581b3ac6c00fd498dffe8f0483cb0cb26e27da88e1e50e9f64b0521f047dff2348cf4dd63f3ddcea793273458519f39940aa040b9b822d92d798d0c64f6890df4413bc991000c19c577776deaead216fe2f7e03bd6cfa3dad3dbcada7c6c3a6277585b41aa1711df934d122e95d24733a93fb584b3043ac678decedb5029b52c82bf6e81a38cc04a2d22389da31974cdcd48d134b9e3bc51e048810322d008592054f067373efd5a254c86009a83129b6b4a4aa552ed3565ddfc4237522a41638178876719f100d3c2936aa6ffdc4716ff8c698b446c63ad4d2bf17351645f187e9142a27d9bfb145ad9185cdc8d9a6ce943f8ac0ab59cdbdfd2ac18e101df437d1032387c416fed2d7d75ce548a47653efdc3aa69abf640390296bb3be56a3fc5cd1577646e238f555a400838f1fb3e5e422d71f3503b708f545a8dd0c7c3028923514985f37c5f5fa1cda653d9ea3a02cb1822c0a901b5a16c4621502ef9e7b5909dc3c77894e8ebe46723f57bef14a1282b35030d8713cfbd35f487aad9522a8615ca87975132686bd69b93fc35aa43636923d382ac55cd7258a948ec9c971d6669d0fc723b930286e6facccc368293e9cd9bcc53073ddd910b29b21b73e1d5d2c70500cf7457db074674014966a7c5587f7604d0d9ea078eb22f0bd9fd2b15e2c9538bfdb397934e4910799151f2f0b5941a572883caa60e7e2f923481cfcf2685cd5eb958610ef19112d3e3526297c714ba522c59406369d98b08ff6fd3cddb42f3693a46eaa67f70e3e6cb2ce26e1f6d26f450dcd954bdddc29b732423d942b6d5a326e9bed7c02f4c80f4cfb74c82b5d4f67f0c58894338f2faf7bc0d08796ff1f9b4259cb10eb2549dacaa62f58a1a5547381074e66f89131e0bbccc709adba2a68d27ae1258facb37ea0cc0d2b22f21276983888a7f784ae06a5a3007164d2e88c482e38b90937912b5cb4741fd7c0c8c3eb94da80ca318c788f72960f0fd568c8dc37d9ec735bd9cca672077d49c881f4dc7ad70b7d55675be2834ff9724f3f256ef0bd16e89ea118beabc4290db45797af8152befa7198ad70e810bc3d1cf39b062397b6bdbd80268affc3e7803d519a05b7f5009f33f867884415e9ae948c5fb8f1ecdef16ade2ea60a449ab64c06e3eeb290b0d81ec65fa630e8455949c9fab5aa37ec11691f411af7c3c54cdd7d9dbd9f08ec1a3c98acdc1ba912d6f0bc3991a14fe09304c55a102e5f5d069186e612d7e9b4dfe4796b215f26a980095843a8221a89f9b13f9a022dd6105af0916d72afd461ec8288775c14bb9fc5f4fa60eae4254d4366ef4026c43cc13e3282c12a3b504812b76c85f6df354d6689116e242b279a39a29da4db1f10bf2f8c5b5c35c73df9d025b79a754e1f8f9a3aebd0eedea66f87af381c795d7ae8c5cfaccdaed5b004413ecc72fa927360643f75856c4f337170c58d85ad109c1f39bd75c685c9aca23b68bcc96db04b622305ccf09167055db3e4d4b44f01b637713d7d1e6efdeaa83a7b91bdd1f14544aacbd90faab0feb05b27497c0330a78be6b93f49d00936de60895dfd7ce9dafde7f0e4b32db7c121dae66947e20f8cba91368a1ea549cc06f4187eba2e03bd2341055f99c122f4ad9a1a1c1c43dd5a21023d546ac67cfc92f36cc225b62a9454d0aec2ffb2f45dcd0253474898ab4e3677305c31247116369ba55251f5d5bb9f8c91c4d424ec169d940754a9245f5536b9520bbd634d7795d43241fc95716c24b181e95bec03f6be44843e7d8d6fcc2f31110ff0f82704f3b1f4ebecbb7b5362dd9c1c121b0d0d0d52e6c892a4331cb0c1caf225b4eda9a3993baf04a849d4a8ec6caa70e4f1b490b4142289f26ead0bd5ff735112a49454a7c241570cbeee7f2c133028a044a96401b19bd52d7a51daf9470d7a9ccef09699035cc6b3f9ea0cf5200b11e3d17e7767a886ee7bc4e96160ec14cce84aa760ef7fe12fd80d452dfa025e1ac4d0f00b6712e4f462870ba466a119e42878f380996d129b95f3ae8dea78daa4750ca36f8cb9522fa18466967ad6598281ab932ae1d6b3bfbb2e9efa676c96e5b48ae0f4a8963d092547843fa07973e2c7a0d7265e924bc5893eeed1b9636a9adabb5cd3e41949de29c0c8c2238771cb449b53a7351b6894dbac243ed718db8c8b6c46a777d711875b234c72b88ffe89b2a6c81e3d644426a5e14ad58435554de687130e2a5f423e214a1525ec2fdeeabd8b3ebfc6e1a35906f3bff410b5f40137c785cba8cd3dcca1efd4c5b06e88854d789b0759a5254f43dd06de5d1f04f82f800397a19fd767ed3da54953b82548f8d38af7d922f4a188c602e44f991faa7ab0171e32bd3c2ec6c0050c7985fef81428b61d1be142a48a063b2caa8c8e9ce34abcbc88106dabc41f82af10ee9e7b0e616d035abdc93f8ea2deefda8e04d3c59b4f37bd510c2a3c43ba538cebbda65a77221f8e68016e0106034d95fdb02db655ef304503fd60ef249c82fa93f05b52cdae2aef098a78568dc29d792ad8496aa6eaeddbc9d9ff6468fe6075126bf9d4937bd441edd38d3430f41f7470cddf41301e8237f266885f12cc8e14af679a7fddf61ba2998889f5cdf993e07bd450b60eec498dddbd62e6403323c66042ce35142f61999538f34eb62323c1c711da54a85a4cdf1eed54b25b6aa946d4bdc24dbbabd29971ad8ff26ed48b79710bdf00788e3bbf93a35a2396642f46527fc1461f6bb256d6bc1f57fb6007f5d48d2b884f3ec0100ade5ca5aa0de7db95bb420c5f0c26aa723a8c66af354637349a1b188c31f8d18b0d2fe6472c80787e910ef6ed4d4428f2b628ef52335130b2eecd72b4b329c18b70f209e53645e34c5c29b7a39d2230d3369605fedf19d24f4c5afa504dbda0214cad0cb051dbe8bab54404d9d1bd19205cbd54c274e7c4f4849160a9f2312c745f53ec5e111601be045d11577e4f39733fa485041fa4186809d198e5fe7176669b14d4ca5d132e9414cf199fa8e226001c225c176cbb1de6776b3f1ca36e395018bc2310008f64d8931662f9381e6d7d304b23d566b10d574c56cd77cac2b4c6d0d52450f3e70d3277e49faab39ab3aef9012567f1a29d647ff4a620f7cd20cf4554aa43a5091d4105f37848fc784954a6fd9e031f812349253f6e9e24b090ac7d067e8888d4f73f9576347be1a91e3b18bff5e38e507e46206f5327a6c2ec08e28ac8f87b2ad363bfb92a610d2c3c6af07e877d8a5c11b8651eda2f6cf043faaca3ef15c29f1d56c91d11fbee9df4b7e5e270599c6818324dd2224f8e189bf8a1baf637aea70a2c70bdd3d096d081c367cdd427c3bc6eff9e268a2511ec2ab12374ae46419309e5b86eccca017285b885548e8beebbe1a528207373f5bc0022b8c0ddcb1735567b7a5aaeef77d83fa2f75e50e335d77802fc5215f77f37cebb9a98b5501872b1a6d172a7e3f61c0d5f1ac379da90ab863f925c5a9ebaba3a304786a61df862263fe4ea2483dd4928190540d228c36f42f5fc97eacfd83ffae314b2a45b3155334257553986523204cf28f852a48cd6e339fa7ab714aeec12ea398621f5fd3f0cd48a2c44233cfae8523736f8f31ef5b0b92192e648d72eb9ff371eed695845c0a595cf44c1820a684ea50eba16dcb200f009662107c004e6ef74fb04aeedd0130c8a4368d4cea81f452e83f67dc5022f51b8b3cb30b80c3b298472ab422d310d1f870166f514b7181822b8dfce057938994938b5b83df0414f98cf30fd0093556cd593da37a4d19689bce80a9e0da15b9b066349cc1ff173b65bed415a181d3532d4a6aaf18ddda043fe814c4159bbf5ad341c8e907bf91f49a4a94c8601bdf3544799a82f14fdb8402425dfd111072d417fa3ac0b8afe5cfee4a52e245823846c6c56440758ebbee5429f0956f09a9631d7015d1a4547f8d02a6ec0cc89450b46c0c6ea0e3696cade630abc163e4f3defd7ec789d7ce02d2d88cf8f814b0888a279988543620ab6bfd20ec3fc216e9f01d6d13675e33896391c0533397e3f8a69d5d34a207163f6106dc0bbbf20fc85c8d01c275910b0b954ddbc10ef395618d0d362e532fee8a1a19a3b8e50397b6d51e0fc4416f51b47fa1437d1a3fa88021a43643ed3091f06eb3169c0c43319faa21f662faa9191f7636fd63c349a435101be8090f5ae4ad12d2faea86f3e0e52b752eaa2c8047663329bb19f1445eea3d83b9f10cd47573fb4454691dd3831bd4be4285f1bab9fafe16d4cba9414cd102ea057cf73c17753f6aabcf9f572b5a3ecf2a678f4114a68cd6a23a23e3485849c8ccf100ebe51b1b93e1cf7c1960d191c3d77b239447151e550cef7d5eed3d02133d910fe8bf1053b9a2f5a7f0930400b20b1959acf8b05bb500e438652ca93deafdd3368af4faf4433fd8e3f562c3603d82cf9902345a49ac6d7a631fe5015320bee57d838f756c59a0f0d61d07777142ff6d0fd567bd629c9f5fdcdd5e21f47bee3d6649a2365e4f0de7d45ff6eb000c8c8501df28bc04227c981a6bf5c4243e6f2386bdd90de6d2e64e5eabcf53da5e1f1e258c19147fe77f8b0ec9b26d3f5add065387145631a14357bab2472f754700297a8c8063e7f397a8fbf57ae782016753483339e88618686c2f76670835c1f543b0bec9da796e0db5d09b888dcf42d5d9e3b4cee5a2ec61627a0971350539152c7edec4c8683ebcde406649c23c423e01c664aebb8784863055a314e69ec07641204a4bd09c0ae3fba68392f18aefeb3e2d62b9071769641f2c0de86bfb99482a3eea2736fe2473f4d478cd4efa6c4ce1293c77df57fda06a24cc50a1390552e95fe212f9098b8808f402b9044aafaae988167000f63eebdb08819ef9409e55cce070550b018b9ad619c0e5f24816ba7fcdf0f4fa7ac1d2894654eeaa64bcc9ca1b3b0649140c72344091957d19579c9e68f4ba807eab36675fd3e5b5261e5288d994efaaaaef30414b0d6d7b40c3b30c97d945f42e81d8ae1c6fb6d5de7a8eac2628513818159762fc20ebbb999a052390ffe4fd1ef1628fe8e2bf4290964f39fe6de7f83986974a4eacaaac67419aa439f0cf4356a3b7211fbbb43636fd9d29e1e1c60f4792808710051cecf58a492f34847ea95cd380536c155ee73e6376480cd0d693abaa52d26465cb4996721975e6cb00ce72dc561bb48ced5296c41f202f0947b98b6c0cc0bd76768da5256c6d5365c4aed9c379a8375d4729f242f811a9e3ee734982b34c2fc2ba05daf2b955f9f887e1850a78ce53d1d8d52f9624cb334a1d5ee3f1dd418f18238577a55b5486117175dc6658b939b9f452de3007af1f170a031459b9d5b91d339c934ba288fa1d0d54cd402c6d435a7863dd1df6b2f04aba91fa7b83a0525e51574f4074ec9127f98b1d5cd3ed3790a89661092723359be044d27d9eb1c68e60577609a6a8123b853803a2f1d15c5499f4b20cac3c12ee4e83d989e998ba2b0fcc9af921ee42459b3d8801d2c5c48c05a143a3c3c6989772863b9a95dd13611905d905f68b631afe3cdee39147d750cfd417ca7bf692004f0b1e4847faa07e10542e4f0f1de7a7b4ef0826b4d1941673ddd7021b3983e6df1c8d15d3c73cf92c2caf9fd1abbf5a96c04ba8e8d23b603234f1d13b888ea48bfe684397f4bf8935d2fe36e6a2a00a37f84cb96f20f980330e266b1b0e30d1b834d435e9d024f312b2e82a92f12862e96a0dc2f4432b3fe6e065fad3b1a380cca5d5a81dfcd12d559a5e941f4df794df6078d4c6b4a6e8d12b8c7662593e290598f46e5f43d396c4764e9f4616ffb5ac342a15929f034c3a0c1b8a5974b9dbadf9837218064738bd8bec748817a29cf95fbb589754efac22a8577ff9caebe86622de876107b1b9a724958aa38dcc34c5aeb37713eb9f10229a4fad9ab9041fb65b6ebd5e7d3b682f37a4bb337f76b90ee9f6fe140101627f7b2a625c29434bde7b19d36683f2b830012a54a0964ffecea351dc5623b7666a977ede987955e78f376c129208519b75739e66e5db6ce3b52167979a3e91ae9c9ee3f26f9191105975bf0f0ac9e8e6ebd6789440928572838e7f85db88612b54138ac62627a91ee839148969b61ae6339e5f1e5ef2f9de97a5e0949e71f674165701f2db22c9d29b442bad9697f3e2b257c2e4d62aa98d0627bb93ce61db40a9e941c4af2a135de2d52d99a64251dbc9726767fd388c4aedb4c746f61ae8e404df793974693bbf28da572a53388d993549c790224a3a0cc5019f00f2516c6b654ee35365f837eca9649b3861ba97476a8874e9fe7702455cf28a78a6f5452c74d84a221ec2d27100e0facd7941661e2249328ee0a628dc99bcfb231f2d0463126b77c534fca2336e6b5e040ce15e19f92f3d3d33ce95b15898f5adbf15606d0ddb52d1a9788fa94c7445a98c4c5de6f2ba59c30668abacf1b34251bdf3666ee67044883da6dbadeb7137138aaef4e0f3f273cba26e9c6aaef9f764e87fa62b45","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
