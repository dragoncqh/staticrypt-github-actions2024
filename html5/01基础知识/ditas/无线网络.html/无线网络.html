<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad676dd564b4f5657c481b5c57ca513ab6a6a0449b8199389b7efbf38a6a22a45ef9a5a4d4d8649a0afd895934c469fbb18c26c68fdb022718f14e7cd6b5fe70b07829395b7f46deb0b756d9f4eb2113ee8351733515493d9abdced1b9a5332b6a571324fcb0591663dfd6c7c77c9c5a81361ca98834e4fa3af0a8f6638c618e2b5abb5e86bdc079fb3ada73a17d78b216d0ae2a6a33b07670f534f452b735581b3c591de1a5e6d5a666254df2a0188140d5d066e50a3a3e5fd2eadeae2476571d6b1cda00f9affed9d019a6990a6e8affbae55fa654aabc897c5cf63a74dc090bfb7510df861df9123eb547b90df6a605e69a620ef79c52d9598e8ac2118c347d40bd40a0fc7b392cd5217d6e73c962a9dcf4e00d8275ea4ad5d05732658aa9159553e912f10eb6581c4b83a7671934bc79afb5a3b4c38e047f3ff89cab13a2123b329e25e2e005265c7fbb87b1199cac39db1e35fe6f7bdcf0b85279a93727d459db33603207143d828b6dad99253b57698a7d55cab1bac23ae34955319db37ce81e66f1f9c2f6b5afa1c78861954e7ae874b0d4b08623d3781e1944aef1c943638efd2ffdc2da4a593fcd66bbd2b6dc2561dcb859242c7e6fd89b29d8527dab2f2e834621c287d5e1bebd67bb506c942cce797f6f32c69cfbde1a55331c96e768981445f653c2fecb20fc8f930854289a781535624759c1a6f604e2741681415f487b841490457541d0abc8e6e6f7025f1901abbf2002f6e25b571acb813da2a1b9ac9ff708ffc5f7154800f1f7d6244d7bdd63300e84b2bfa42f75ab5a1967db9529e769b92789d04e65077c16e1f58d6ae695d95e25275b0eb62e0061f0787cee626bb0442ec717cbdfac7bc1a42731d134a6cbf4dad09978bcb3012dd8127808a54968bc20bb6825904b27476d2982f4a91dad5191be5f63b9448db6299ba6a084366e1d02d33a90bb83719a8b0c994ea7b313f3cbcccfb0f5e2c86c5344e3b289a5540376191e7a2b6bcd93cdbd28315e182ccbe92e27e3a91ffc434e424f544d5472ef59fb24b6115a2829b4838c9f10da177e0d262e4ce8e934d4d590eedb7a86570e4f4c5032a18c53c239a7c7c40cc9555c425df80cdbe2e53f0a304fa3b9654c5b5646c7ca9cdd785dc7976607118db34de4d4eaaeba3c7884947cdb5accca649f8d0944d5f33202d79c11ef0f8ba6be9eb14c437c68d5fe091110a013977a07fb2e07b6c512f172558cf2d8f2a8e738db109b1a440707a908beb9cde68ac315ad3dc3310ede75c4bcf8a09eb0a49993887cd5d85341a325222fd39ddeed38e098729e33987c70f5a8dbd01cf63655708108272bebe53f667af1d2a7b488540ea7a2630d644c1c14b06409488fe87c55d8c9dba5e87fb46fee61d1f97d5d530bb8ce36d321183475288b7e3c228e73168d17b1ecc97e52a362b5952f92b0c4a6b10121918ecd1e7dcbf52575c8da1a86982f017ea53b97461aff84379cb5964b56629251c039a112aefd59f0467dc042306f03f73db623263d07ccd67038bf1fdd8b20720a55778c1f71f4581a247e157a54a6453bf188553ed69eab2efbfda506778397f1ca32a015ca00918bb910bd373b03a46a70c77125a4381c336bf7ff9bb146dc705d3d82b30c0b2a9fd03b60de9014b4671926b9de87a753b75a5843f53d8e0899865847d94725a56e00909eaf00fce82af2eee3976ac1cef13880ad3ba6cbc57810cc236e2268a3479b9a34becb1b162fb6de13fbbbe89e2ca01007f4051a87492bbbc27792db4dbce7bc03bb50963297ee59731f7e157aacbf08fe3c8b6757cbf178acb134c10f4a8cbc29ffa97ec671de97c54225fad9b078fd9a0e892c04bdedc3cee2711a826d70b5edf6be6bf6e7b97266ac0ea2a2b303d2903bdcb2548b7585a767450008a777482a884396fc3f49f017e87ecf53e1fb45a197f34b89d8e1c59e4bf13e84891986c855e70f827101cdf4da14ce34a580b658e6c9ebfdac25d551b2a7c64f944cab0e3df4a8012fd9400d774f04cc37a7b9d04c78dbf324404f77d60a4372d94f06ce535e92b30818d109d6184924474425708dc8c92cc799922fc62f7bcc2bced72bbb773e28857ab7965027b3c99962dd8ef63e099b3fe5f50c14a11bd62e9bab6b4f815de15204e06811de79d6c84fc82681fe0230df4e1465117508d137114c16bef25a5d054e50aeedd109cc78feddf648604f9d8735361bf231f55ed2a8754c301c71ffbee5701587b8ac8613fc41c80ac7157f1b5374c1336ca53f17b6a4a2a85914ac57fdac072064608fd1eddb829feb17c26ba78c05da809e20f3c9b2f3c5bdeaff8f4c7317132de669791f07158d2713a25054483ad978867e78c21a1a5d63455c03a7ad90d6be7f21a9ce7d7a631988e8d5852100a5f632f18f884ba4fa9459d21bc5351ac8f6766fbbfaf7ad465f7cded01c6b7082f3582e766b3d890680c7507858b79c1c84b5f33dc9a34931d8033dde9185e81c8b962886cae791e550a7bd8b9b7db11c05b198c002dd2131ca39cec8df2c7a3b86f81f6ff8702cbbf8165cb8b1c89a398da58d231107f97294f7dd92fa4cb305bff946ba80bac0d8422b06e54261e46e7f691b9540ded7cc214feb36929f293b6b6479fc2567b55cbbdd34c37fc50569006ca9235c6e466ee5e4211c9818e61990d6e58585c3b47bd3e8475bd10c03e1919f7c847e6ed3722625b162219857fc48e68c27c17f2e76d541fff7f3fb076744b8fd96a8db2d95f7160821890950b3138ff26beb0f1b623407bfd0e1af6b317dd0e2de91a8b9908782ce930b1011e2bf70f3aa9fe005e951a331bdd57d84242c68a81400bf656d3eb4d67d2c7a25e92e83ed149b0da5934a2923320a6e177dd4ccb34a12f1ac0839a5c1b9f08433275a228b2004ba9a0fae536102ad74d1612c969879b72afddd76a7bb560c30a7796d4e7b79c5c3534c6f52577226bf08c73cc1f5fbacb0a484b0264352bbe2a73fe97e990974f38b7547cc4659c1f91e4f4a3505d9306d3524a6e95a3dba9853f6dd237669379dc3c34623d8a218789ab92dc3318e58c7016ef6d4f3812dd02d216528aa1433bc2fde3030c7e0675cb3250b265f558a87365bb4d89ea9141b002abf9c5a84cf6abf63a4cb19ed92bb2da1a150504b60fb7f6bef5038889ddb61053ceaba01ad7c88f6b352a5d58bfaec82b269ec08a133ba6e6c50b73f574cf48533d9a8a0d587327e02d3bce96ca157913277db9b42d5f1264d09d198412e6a88839eaca2ad5611536484e38d3fe80803b7a3948e1265a9f972adb4f01587164373a098ea49a89fb8742510e609c994e1eac2f9520ff70e6f99cd08733b258ca547568234c679e299e682f3e079494685c6230bbe243e338c6686e659f82be79e9f2bcc6962ac310761494a5be651dae67dd1cf0ea676bcc9305fc10f59b418951714c06661e944ce41da9b557b35a8b10659e4b940305f503ce4b83a2e3cca237bff4578fb465003c9f034856b13629ebe9b03f38d64f05e9f20e01cddf11a4d10d2a895c01b32d5cf5b91c6d6791a111e3b637d24996f67e503c0578c1928492b36a9e8fc5fffbf85cbcac48ebdaa053cc545f995b797e9e10c05cf9fc8b60fae720fd16304b58099a8e14175babcc6b38c2e13d0da88e839edc3b1e2f74d8f1183d6fa77a475532b05550048d8206cfa931e7f804a0c86f95709b0f24154a47d0b3ee5a2abb53f6f462688f30f2981eabf239daa6d92242ac32bb872c897ebaa642adfcb7d93edf2f8a7b0ed061fc00b5264839bab886977a03b3902880ff1e8a2b262f99a2d76c8496933ae124d1a98ff07219fcfe51720e24cae031b99346ad7189e6dac124d760cd2f6fd3f2440de2d74bea048fc245a80ee20b55d7fdd0acb33cca5f0ff49154a71f070db2fc7d940330b1ff59e648072320104563e43728bc1fef3e99ece3df0866d504e0183c0a537b7339414865e670aab902f8c1aa143fbec37b006a14e6bf3f523c3775c9e3be2bb34d33eea8c9a0a7eff06836a8b87db66aecdf14624c3b5b9bf7634a68b252edf83a343e871899a92f77eae7172f4444ea92577507a9c64c318cfecf57bb99aaaf590f37ed240db34e51fbc06e7ff09e2791cf1aee221fbf0f2b13b54f5d09c136a4f9ce536bb9fda487946dae418b5de7c7606f1822866b935abc7ecc2b608069e1cda2c1588eb2afcd41e248a57afb4fe2cf7276de7632453907f6b6471c71996623d3c2dbb13642f892241337c40f109a84fe0201ac8eb44cdabc95f8a34fefae120b35a095c0f81506ca390f71d0a906a0d80474b93c9fe1635b4e4d98c28a35d9f0a2f3e2776d24668b783d150b37c398135a4e39aa96b394974a6526a628db82313b1cc3d30b2f7561b2ff3cc9711b60e433b458c02b34553650434a1d911d24cd7fe2e184d9f8e7a27c95933aa420a133f2ccee2eb6d22fcfe89a18ab7c774379563e87b5a81047fbd2e5ee2f8581276990eb9a41fe9b768cdd34678f86751c47b97f752141f579fc997e1f22fa5b465afc5a65117153f15ff0a1053eb87352b321e931845f80156400df7859fc860513768c3f9826ad898a5be174d45550d0ce6d078094db37bf45efc5a692ae71aedba64f056da7a17c358bfe23609c3edf4513749dae40959b03cd5519b527708d6a864f886f1cc0e1417791e4c0aa7974c66aa37fd4c4d813ec006869ad9f1b7a81ee5bd80c376b4eaca0d1ece4aaaefb1bef4f9cf72c9281b77b1829c56f1cf17f84b73d29e45e6fe35fe42ad74840502bf8bf657a0fe302d81dec7a92590fb07c617788307ec4b0becc1cbf20e758f726d2ffdc58122d58910a2608f59f3d047b84e6a6959767756a284efc1ba0a785b99568dc5400135fcecd5bebf340b6dc5f5f3f26ce9ff7ba526e6ebaa515c5406d34b2211a3e3aad77f42aec48253fb7acc56bb473ca7dbadbf6fe488985eac535f306b28ca27470d0b1147e4be90c294496d136e15c58d82fc1dc0e36db5e0d8d1e64ffc38da81170cec0df7836316613e9a08e34c041c7efb6acbf3e3f403016e06af58a629faeedd05c63f83750af01df53b9cfbebd8858a39b301f36e5e22dcd3637114ea3f2f2dc783b46973a3b405336956627d2bf03144611a8ea0f93a6e706163f3eaa977d0f0f9abb7ecd080251b7f2d4d049adc51482ea17df34781ecfac3df674b3e7fa1e255977ca45e668762562b6ef5017220bc2592bda98dd68f66c1d94994e6368a3715dc8ca70bcbfae35335022add55a5dfd22630a3dcc1d08fe622555854521ff331942c95c6987fdacd0e6d35e87cdfedd7ddc4691d273cbd94c7ccf3a5d9806342a7e62e6ad0781663fd62c49f4672bac85941d8a94a0bf7d302c623085885115681ff5b7dd65502529869c5d8336ec29c046a91fddf961f4379d0835afa856e2268ff2b9afa41d98591579d7fe8161f7e24d6491fe7d2cc26a814d77a590e6f2455290bb1bbf08dd65d8ed0df76f41265e873550548acbf80a69399745ab75d1cc84f512b7e8ae2c691eb456b53bd11bcf2d0fbed7f06dd9c928932ea54e011b2d5759e9b7fd4056a501fed604c6b8f1c0525ba7a31f5b20315a51da1e0beeb40429211818a212dd16968bdebc83c5f2101539414a624c6a7dc1481d93d1f69a036d5128303e6d47674b6f05ca302c1994e3a83ed97d374b0d25e0016103cc81e0b4281dec6be7a1c1c59b1d594f1d4da71ad0c0251397f15c09ea3160d9bd5616a6550ea7f62fe64081d45f1202a7b5ad53b6fa6fcf55a7e8d53a9d46e4d1c1b0b5dc69a5a233eccb1006c540dfed160e1b608e21fbd3490d85f590a0005335104d58952436670c018f7367e4ccefba6cb6da59f0dca81b7a97f02bd473dd25d3e349b7933b49ca9832e929d1f5796dba854980e65763900d552736fece452924fe38c720c7fae5a67564ed7b16e8ffe9f3f6a2f2ca0f104b40b4dad2a609b9414f1132d156ad561d9c5f5e5da38352827f29b523fc02f181818d3c6cb02d7755b25548bf20420b5a7296eecb1d67855ffae7acded574779926ce42c89cd4fbb97e148bb3df8f743a55c2a9c7e316ebce575e937d77dcc1f2f1e4ed2ac23734be7c6ce5493a95cdd145f9ba66b27305c6048f7b297f6743aea3ad3479d06d8af0fd58a04725a294c16a8e17e28c366051cc43310d5c9e1eaddfb153d68f0e030ae86d32fa72e1bbdf11f67a206778005bd65c1d8a450cd40476a2998cbc95bf94569dafe67d44be6b81175fb842d9159f9bc8283fdaa04a09a5c550818f46d742a6f44a50b10db118b274bdedf1de8fb98eb9093cb22b510f85015f12e28ca1f4d7ebd779e528fc9f68ace4b0f6f010fab4ed7a24259061c1d8b8382b380006d8aaf41347d55f58354d3e9072beda634be896f19c897bc2d15337bd346058155ff5da45b3afee8cfb36335719baef8f8af3392d8cebb1d5115bb65c3304090c65b5a957d40fc773aa35135dd0938898a6fd3b583e64dcdeae73d9ed0c77276aa46d17d620252f4e7104d2ac7d15f6bafd3086fbf5602a1e14f43312ccf98fd6557b0de8df567f9ec80eb7bbddd586d91ef1db5aba4d0828060a9b2e2cf2ab9866e0ca46ffb8758c661c12aecec5beb777a6d94be83d06f9bff66b81bdffed6067f426d08ee6a5613ec21f1ca3b67a8d8d00ecc8480974be0be2dd5d3d72b2aadad59d19d9e873d4f32ee4d7f35341d2096dc4703ce5a8fa0966fea6b2a1dcd8dfce3a594baed8a9f6bbfc894131b04f2ed325f350cc1825e435a7ea44c82adff36a4683d0fe2b8a60bd3a9699a4d793eb4f386f46bed8bb09f5d559026458daed260731d432258364334e1e4905de98f9ac14be5fb5129aef48baea10c3e79214fcb4013f7b14821816ec64c567e54d1ca225a88a39e25df8b5d4e03c9bcb26883d51b27027bf3e5255f2e788392476f31b5d2fa7b05644095578c99a4ecf5f11f4bc62584625c28575d92e12b741588988f468ab7a47cbacec92344c3203bbc2a77ee08aa3d10af789fa26d4d69a7c08afd5dba1d7886b1cf204bec3ec360638c24c6eeb1c7a4c250a9c67c774633b7d65fd72c953073dec7bf6bbd8d40c2425b3b6d0684b20500af2db5980924056e306fce56f7c00d3be66cf2a7caf98b2521250b88091f99705c61e8f3bd362301117de546ce6d31f7f7ee177c71917ac4a75d3a0c6265e5ba1b7ddb48e08561ffbb120f090c62a8e55e92f053284d8a7b196790ebbdc359a961dc90d3e961dc0f99800c5772a46ea1f350bd339868873a8bb6e4fc6dd267e7db6d82ba588398c40bf436be7b6af7cf55a00b346c75caeb84e7d7a87810f97eb462eea5613c59b5ba99c29119e0fb0914d24f56ddb03916c74c81cf7a76d61a9ee8efa3d2435357357254919390f772ac8d7b58f2f6ca7234e44067ea2d4ab6e9897ac2f2423d0fdb2bf3869f5e2abd47109131f8e4d22dba52c2b52a82515142993ca93d2b8c1ad8fc883d06031e0368acb870dddf8fdcad91afc344608040b8b887f36d105e7c2d4400f86d44f1e216bc349d47e79d87a76b26c8f4e372fc6bae7536b88b1f327425053293701b6715df223dedf1ae9760f1a6aab6ed2de7b63b6e6981026a7b8dfd596835dde74a1f0d8f81716271fd1a39b4265a01a8e02e3eac0a28994202c08af326f7eb2943f207d17365dee2743adc01942ec921fa3384477dd0edfa72f3f455497f476afa3b30013259860c776b5404e24faad5fbdc21a3b936ddc04e8e9541d8cc794a92739e093281d6ee4f79d4c9c99a5643af13245398d7a9d0c1b4cc945f0268ab8c52bb24dc2541c245c0a884c43ce479a019ff5dea168342eb76e5178c8a29ac379d9959ef5544f11e8eaea2aec5adafe20c8e931411433d83b9886e0e411edf955c7826efa6ee2095d826164861d3026478b4f6421eda33d1d46f57dbd5d13d478c8b3b12f4d5ee6c007649990519077d5fb3daf17a8a69b8c80725a6197aaf67d42d3a6d7137ec4eb5f463a78bd1e30368b4d36acaa872227bf65985f5dce98be2c9fc159625e2ca20e56e83b2d995234689433b9beee71dca5b0bb01f0abf78e940235ad671e8d839622dc45790400598dedd0f3c8caf275c1bec40e1ae11a76475b0569906d676c5e45a8343d8d91410eeb0b79ace15254d9ba0a077b3e264c6d27a70b0ed4a89e3bdf52142274f83f6ebb7e9522be2a687dda9a309347ad051cd4672a5af572309640592d8f0a4c7b9df01e08d01fce3037a6494fd721085d02faff91c748888379d4a7d74680a6492b95d3718a36329d907aad4e845ba59c57279229efc6d6a0a244f6887b2471544f24a6f8fa413a4e08e5ec4c8354a9eff0f7e00e4d6d2574e0fb28c5bc706e79fb2597d187299ba446a2fdaa2a2e0dc6c7e9f3b44288eb20543e986db30c12bb5d1eaf82ccb832ab679a6e82266525741189f49d933e46e4ae26b76902752f60e50f06ff30b73dbdf755e305fa88456b5421badf049fd32e5cc28da01d8faaf38a71c68e474c003421e5edff47cc9b814b84f8f370416d3519c835edb055993d9451ed892b3d139b75a980ffc2e8862de8b2f27487003ecb318349ec194beeb21ee7e444fc188c4e430e3c2d4955d3eff2c48937b9b848e71078a9cb6cec9cd78eb89660ebc4a25920074af821437bdff4acb8b1906d6b25cb0831c941f9baf3d353ade382c2be02b22973531ae66b1e4a47fa021f94dcf44bb02872168fd59dfbd2cdd1d5c4ccdfb36973b9cda352ac3a27cd55495824a82b9cee316e40f4946de476aa204a89e49a69443598dc8158776c088ec96107c7f45dd28b0b8c499573b008006a378d925f035d5b433a84ec18b85189b860e02421573d5cc0fbf8c1993591851773ba2a23a7124da47995735825356a4d9bd109cf9e22d85014d78f433828490b9cec1386562fac14ca019fee557efe0b5ee63719d5f9e22887ee085964b2747f3f98fdfeacc4ea54a66f9b4e1b346449838d2469f3135467a03e170805c7dea95bb5cac31158496d131c3386ffea4158b1e642a45ae2e355e157e63107fb8d1c4918a57efc17b42588bc58065cd27983dc3d66ba96c7757452b1d6cb21650f5324a55b19a1d427de444311dea17b617dd348d44aa8979fd48b8415aac35c6f02dbdda4949c3ee157f843a35668f58a4a13ace85d2e149aa6f0543dee7e377587e91896ac41ec6278c1a2216fe1c3aeb30eda0f7b327e2e679ea270f9181e5ad777307b79c2be4e28e1365e2dbeda89bc3527c882b059fc58b3f7a560997c9b73a231b18c7c3b79dbaf984a5106411ca214ae89c06366514ef22def3c6185da1ab18637f797d78de06774f7ed67e19ab30e97b41b86da5de5db8c4f794068e49decccd6d98a63b82bd0cb7c3d16faa7fd3058bec5872d5f010b2481b202b2c11af78821cde7c39e676109d54ee47319e59c3ffdb7dafd0d147d972d527dc1e5bf3ee37fb76013f33e0944f928798cacf5abb50a6584b19a36a309b403482aeed3463d48ec618361a33ce8165b2af17d22d0120f6eb417a6ded54fa40d73064f44415f80e8a9482a8bf3af20549b89edb7a14644d6122aa588f96bb3652c9316ac61b1baac8a6238956d3a1056935b05ea038ac3edb16baf0cc4746f561eacb41a2aaadee805e311469092643d3365734cbc468b217c6d82016fae4fe749298fec8ffa5e8e1c7eff09dc2408ae32d713b4b7375753bcb8264616db83acf1ce989610dbd3e18a9767ebfb34d032003c8b0d1ce08a9cbec5696f356c51a85a535f25ecc928bbce066d849cb394cba85ff20d2aa11afe0a39a2278548fe8493289ea34cda441911546e5fdd04d7d7fc691ba773fbb56db5add21bbfd43d37ccec385167368491c2af1dd7573f35e74fda5aa89889ec5a6dd17083f32f7da8492ae7dbb70675811e913a2bc726c25c5ef6c0bb358868dd02b704242d01bae5ff6751a3cc133fce64c438376d7788425a92ff8433bef5fbe0629468d31d974206e90a2357591af1c1980a05fd00d0810a271e3c551b1f5c1a120ac3536bc1914974292cf6901e0d864ff19d3330ef1551b7b99b350929110a3d95f7df3cccbc9aa1f22f6fc608e4c254d209a651b170cc6bec5b6eb4a68ad3521bb6f6f824d82d9630d874e1dc082e0e2b6fd7603ad3106ccf504d636f82f23901ab02d97cee594899f6642017b639bfe5bab0b453587a1f25419ece44565e87df7291f34faff329e191afdde338596dd04eef04f4859d179f8a950d2c182326a82c92d6cca944688555f62dab6cac108822e48aa349c5243727388f2815e827a5deeda358128b0ba9a68a6cea3e50dfda951e282952d361e09dccf12b9b81fdba72d396e94bea65e4782a394718a4e7eba516b53473c8289b8fe4d93ebd629e5cc4e32eec45c4ae77d03260bfa75cd27ebd66208bbf121eed49516d647df3ea90e0bfcefb5357c741181595495bd9b8bc34f30911eec67cf5fd29efb64a299c6e8142d266f558c7b8bb95276c4ce60b61cd9c23291b4576410b35829fd2aa70e4672bc7c8baf4df75e02550c174c389d7d1fe093e643435cce66db0f49385cfbb9d00c2627ee318f1f1589d7beba2d7ca15235f500c084bb39e4c40228901258b89edfa863b816447701766e889569f52c8112187ecb8fb2c566bc386e2c5e2b96af93020e49f3b968f3215ecc2a358def72fb8dbf6d28f1caf02e3b4a394c7102f47f8bff3c74408147c0a3aeebaffbf245366b12b7a3c27d42f8c62f31f5450a56ebcf2a8536e24e9af3e3d939709e94f3fc86f2eada769db34998c357948fbe88dda1a31b5d213f53035f9a1a8d09f9819766ef852d61a78cc65c90ec092570d86792194ef0de4096c7b87c196f9cd0e9dac4c243c7df2b29ea47b11ff501e1f9e2730913c4c00c11283952909d2a30c6257c79e12d239b9dfa7ac580c651585c30620c78662e5d51688caa326193c79b082520e0f38aa083e62ad3e0bff114e4ac21caa9f31cf2ed1ec77e8a01bae3b05f76960dd331692e3f537fed88d0e81838be83082bbd10b40e2e4774aec4f261856de9c7458ebd59123ba436276b521ce73faf6d5f791b1ed89b6166263b5c4ccde2b7f7ebe4312e1e6af235213d46e0323523a815671009ed4861ae235843639bd7fa562963b55fc2cf6eeb2326815576df80f87a3e5155e7a26108747be38dbcbcc577a02d5e5ba030801317e0814b5b34ce22b00a9b89e093bafb6cf3b1c583b76b13104ea7a1b6723038213d85b419662297559e512a952f2dabc80adfae43f4fa02718650dd9f93b38820ea447cdaded118db2d24090a80be117323fb4633e04213dd3f3e828553887486eddecf2e86ad1eab3cff96f8ba22b32b0228631bf8975edf2f928a5913de263089ada5e0c15ffa2b9ca8547e3566532fa5a48e810ef8bc584bf70936d0180e013922f78ecd2d4671485d05726aa179906e96d18c612b5d00ee2e656605c5078c8ad072cad739b78dbac09401184134367afcf8a18f59698518d5ab2f82049c605476616349adda788e89fe2b386865d60ff345c08a8b969d6628a360a6b43f0e8dd3f85ab927821399e11f40d59f0534b78a8aeba245c5b4e3b6c4b169301ca81bcdf7b72bfc3e783f49d37e99b950a84b10fcb230b885ac9d006217239c070ca91e578e7371db9f75e6198c4f8eec0add0bb4de36be82de2e8862ecc81fddafe93140cef25da0be62211218ce5dde7cf41e5a2b82fad0dff22d214aabdef03c4d069c5383822d32b12f174c678dc8eb5bfd93903f9f8ca8ffdcd359ef95e8e0f3f6a4ce00683b2d6c0d2de637873e0b511dba5f89751dfe74b0295f29d78b2bd7f130ffc202772d4adc6382dd268396b21df7d5cee5f0426fcfa0baaaca76f1ffada27e1573fde054dc261a747eef0b2b5cba6d38b3485ade4d37489c845dcaad54f8e98a0f3649a7910b607ab8c09bad40ce22b31ea58de5efdea5ba4df46517c4e04216e16fe787338f98713a38a181c62f912a0087ec3ef0e57010235f33092a5acd7912e9b231c8fed5e64c54af62bba7c3ea817c8382ae85a8c00ca00b28983e3d999deafdb4dc698b717f4febcc415b6c0c531ab0a7fcba28cd409c1ab74103dbb37bf1b65caf6a3e6d1e71ffcfc81989493f5c6b37b587132f4592909b60764b7e172a9628029c799da5e4a1bb4f7d111ca545fbe0269815efeb24d66322fa3d79c8ed40233481abed2f4a4ffc1fe055d575a42129260240ad6a6407bd8e1333a6eed21b2c8614c4629efaec755cd2bf5a4965c1ddc5fc6cf7c428f7c6e6a65942870401d242e280ab448582cca1df1c6e3462b78613ccce2150026389ad8bfc0229c416104bd334954af7432ea606b47e99d351bc8d6abb207e749379611d8ba27053024f243d5da3f2c7cfef2b61088861aa4b2c9100ec5e0747878c6143af7c23ba49c520b859b45618215781bb44aa2f3944aa165ca30136ab7df42bb55a26f1f9d58ccfe3c265be69cdad6829f079f740b25c9993db4a38934034d0c269706a0c431754dc58ff6430b421a3ad8f0f81c056cd8a252a83572ee22ae4e7d279ff25f7c2c0cc885a820259818f64b55fff9e227babe15668158d99ffaa2709a57a409e8cc5b82cecf3aeead7b29e07ddd0e9e9ccf5dd4fc857be57295fb7e329f4cd43c4df985da6f40447eade6e65a450b5d6813c52062ad91e5889e5f034f62e17122ffbaa9ec59d723dd2b968c6facfdf18a85862397898e3ad52664e7c3e8c373284c48d0fa39a302444cb5455a82d68294aea313156ef7dd3cb46ee65c1af9a192ae85dc7ba40b1f0335c037c8af8eb014f90d66f23cdf7f1d19751f47d28c9ab1c0d8e40e8d6e5a4924bdf90c010475598bb779f6410408604f42f0042bb1b3291c1a7c1fc8167d9e548588c7b59220e8a8252bbc1a5969fbc7b01bc402176610ee89b0465e0ed3ef4095966142a70cd1fdf55af38d4746fc583059d334d1c0adaf32e79d11c1ddc3d956327a8587cd4a1de6be8c28214d05dabb308006c9d9926b1548a34433929db40afb0e938919f02378900de6cb24ec9a54f415927147846bbb022a1ebf5fa23a960227232c65bcb73829b50b9b84b62e8d2522e182223a5216e0bac98984ac1465990bf9cc28bf585c051c775498f085b721bf9846c9f1ddb93df74a391b1ddbed896bb56f822137f6c48738df9f30273a4e8bd23db26a0eba02539dc1907a6c425988598661b5e2b878d4fd37e0cd94e2a49a73552e7194a8a8d445e9c5fcd0c0ba6585904995b57b2da472dc8a2bb21a70e5f15e0ddf3189802ffd04de13cbbd2a2467aae92fc0b0b6be808fb4963cb57c03010261d829403c7596048d248bc1d587e6c0ac2dcad2e2e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
