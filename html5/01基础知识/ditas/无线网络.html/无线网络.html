<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3081deff1e0510706f35c2189c77084fe123079fd56b2ab58dc4869ef615b5e4392f819007ad85b707c1fee065a15f613672b86fba060a1f3f47673cd59d632e75c6a83f00841bda2239e40cde251b6d5be4330a534e8be0f1d7ff21aaf2b1804cf26891a40b4b134e995a0414f4bee7ea3985be7bb69f8efada1d689f00c1604ab6d3e3f27e4887e3d715d99947af15ea2d43d805c4ff51d01b2dbb2ab7daa3b8c5d2a340366a144ef4b363f7f19ba0c2865ec216be37ce5a8aaca27f2945f1a51bc9e5c3240e94c72b113910fe82c6fde09d22da3d740286b4be072bc84ebe4fb0fd67e870473dd841eaf4476e03bf1f1dbf9ef796b636657250816ad04fdd34443d7c0f4fc6697ceed971cb61f1ccdd58e81326371e0a90ec14eda10a763646c7fb63f2655df9285cb5ec24693636dcab2eb427f099412b7fe0bf7031a10c895808ad23159dd4aa2a758a422ce66ca5145c40586043d5c89ad3ca2b0fa5411147832ab35088f2d5ef23598dfd8dab42abc44b4af0d73c95d0609fa67bac25a7688868b4342d1d83f83778a2714fe91e2f62719bb3492298256ab35eef06042aea3334f059a091ecf9ede87ca57ee38fe609d44d3c91d628e5a7d1075bf3f13c34310dd5178c06684b3673254c1224b530c04b2dc7870f6b7454caf7723c8ce069f0235482b133dc37a0c8249c4db0442cbb3c86d6d59793820243b3cd4a2060ced48eede87237661d088dd356c6601b2d7db6345dd3da354ad8fb4a69cb42d78fcec06af8398c9d4a425c65b4c1b93a89abc1ff8683521ac4de2b8f9f6fc45badf7187f2c52dcb4bb440497f113884a44148da0111c605fd87cf1268cd8ecb2fe508031785b1113f9e49369ad7f11108473918147fb82f1cbba40dc327232b91f6efd5759b23d60ab58da1e3159f2b3ec065a7d0c66acc7260f6d5edf67eecdc848b7e7bdca5af8fb62853ae776d08887b583203faeb24522ca7d0ec93801a905cb146747df0ceac5d7f58145fb78f625a584112e19d0e71242fdba1006ddaef50cb455f86969d75034fa22134306bb33560d1fe4bb1f8f88a3464734744598df4c185bd3ff9f74a00f055b1bf59c65ec3c27b075ef9bc9e7bca48d3e8d66af9e0f24efdf43e17cb443ba08cd21d3217c5832d58e0dc4c5e4eb979e78cf9c25d57056d87333e9ca0f94c3321dc1ecd0bae517ec154f202dde9ec3ded53978fe55eeba7341c8477a740d696ef499840a0deff50415329173c0d50f209ffea25cbf33c794f0611485d8879dd7245ca98324e0f677cff4d7730c0bee2e12250f4517dfe14019c7aaed11efb9ed6fafc9c1afed58b4696a678c3cea45d970a16ade791f9d48f8b59902d504a348307dd3b75dec11ea666e01292990460f115b46f2ee0a14e868df8b6968ea1dcca5f2c0c204e777ab09b4316f3d9420b950c8cc06e81210a3788d1a48f6aa2fa4a6c12e8cc2bed26b2777fc0692b39121f7ed7d372a03fb55c3bdf68d366ff1f91db2bf370e3936664aee6f88582e16a278ebc55b1d49a614e44c0f43bfd2c7b038572eebeca9b10b05efda357a665f7058b580199328949a839e7b0416d5d863e74514e84b700731f3da75d97d71379b261a94dfd83ca5b3cf3e0b49b219f8d047553bad2c85aeea016054d52c6bb5abdec3f9a616d822953b22edecbe66d9b7d886948643f5691e50231d810676256edcbe97bae2d4668ef066c6178cccd5fe808af312531e779044cb11ab2f658bf0dd878e1fcdc736d80aa8da73d2e5e62245ef9bef34e706c58f0c5a4014add5ba43047b3c3ac0de8cde1a45465377ac536ac49326f20252ca809f926b36979404b344238648687173b9321f2a0dccb8640f49dee5281c230397af5b4fdfc8fb551b02ca675d6065f8d7b472d068448cc8cf0e5799a36e32551f4a0f8ccbabc86c84ec30ed0e84f0a23b9cb54de9a8face79bd76ef424d0047c46f70dbcb9e3a7ff391224b6985a9b01afb1e09e3152eb9b1b286501f6873bdaafc053ec3309dd299fc44ca3657afe4e8ada7d7325b95bbcccf874055270410161934f5403c24a90afdf3999fb932b973016bf69fc8cce579347bde76a17023a31786c2123f80b6b9c30622221bb939c7405d9b69f7b6222b3cc6c6d7a88f9ab9a7c4d81f89b63d4c6d834129649b3bdb8dcabdcc798972e04817e890ed4d0c7ed17d1455f662de96449be1ddd62dccf85cd72fbd6aa868828b70ab0800644b7596cafa46dd07c454a6ae5461935440f15301437fbf6f8ad9578f752c3c578d1c93b3341c29b61f07febd1e31ce901a0aec220cc579d70be616c16538a304ce9c440a900c0445688b9238e654fdb44c8b4a2b66ab09d2dfb31a913a3d4b1ec99520c3bafe63b1f688d1f1e701f5a97b5b607c043bb43bf3f69b3d1ef088553fde2d7bb03ec847331376b5258daec6f767db7df1af2a59e78f94cd731111ad28ebe2c8a7eb34fc42b2d74114dad2b5ff3a2fa82515d6aa9d3af08da16485ca6073f15339be6a35f6a0e35dda8178809b39f920e5a0b077ec5db50251b80855e575676d330dd24432cedc0e1a78b1ee09e718af72eb8a01ecf63d42a15425119a9acff5391447f6671df5db3373f2ad2f293d26a3a5e05d52c9c2429563abe2055170a724042b4005540bd4ca28b917c9dd95df6fea4ac4aa47bc2bee8f87c4df0bd64678a0a5876f2a1e797018a35a475cd25b7e8bdc0c70c357f527c2aef492d555e1aa909e5cd13112d63650b0e5452d49aa4ca4ebf48a3281b346c22678b30d65a0819e1288ca411d445d8a4c8665f85a4dc1f2304f45591152367cf7623b283402e9ce10b46858b27d89427634399fd27881a7bd45ee6ad76a7d05efd3b0a736a779467fb4572ed572aee7d9cf63edd992aaf2280184f0ebceb64f6750dba4c25f82114c5c1db06f199d976b04080cd3e17378caa17351b392c861d937c673ab601a4265762fe4c6efb8db6c0b3a02424820f15d61c7babf3b4520921627c560d6d30142cbb0345a84216a8e3ecffc43660225b1074af2ea3bbd26af7e39e1083b06e1318412e414b41be95509bb2a69c90b7bc65bc896d5bb188fb792f4fb4e8b96886639bd1c34344636190597cedd6267172b5d37187dfb1cf4b368bf6b96b872d22f06f0d48a57cfc8ae6d8ffc3e6652d40a3a1a4fb1ceae9fc41016fa4adde182325cf0357b404233c9a9c8736e34c79e10dba36df47e0b27dca459b26b0a764ab8659dce7cd1f2cdc69363629e0fd8bd7ddb055569f8c4c6de0f82ab0dbe2373aefcb1d17640fa6cfaf8724272a2671d567195c182277c8bcad55882c2e1f96013458adf4c3cd4ef6fd2b29bb3b0769fabc2cf03f843a2fd6d0d4daf6c283bffbb9761727bbb2083876f7258f38957ef4c7dc9cb834449e1894b5e5ef3dcffb095d7eb39b7fd34cade01dfdc8b8e7664ee4f7841f0e63c2dee59a89b69aa8180685eac90a442d3876d75ad48593238da831fb948ee2d2366b46acf2565bf202025819ef2b82c0a64677f63d1403a62dc803c2bf60ffccad28d352d46606301977855119ee0f6efe9f61dcf152fa6fe74a0eba8b1e39edb26bb215c0c392ff12fed6b10edfe91cf50d5dc7f4ce3d91c3797301c8e98d8a1ec4741b939daf49d0d56af31043d5e8414dc0f2f30654f553d6e4f2031f9e2ea8424bc3eb5074361d0fd5a22c0ba0fff7454866674c340463f436320719939f978d7bca8ec695b678141296858861a0e7fa43e5f396a83375ebb3cf2b43c59be25e75bb6eb98a33fb27ddb8f92cc341e1b0b05c64123256222ad151940cdd6de241adc2347bf89fd8ee3e8f37ebe586b117e28a50fa98eba87fc2e58c44da145af0dcd8b84c54496a9d30dc32b0e83e89dd74f2517db0664095e390703a5ac7851b0ec97deef3f24f7631cc4238728eecb787201659009fe5f99839ee6387b464572e187902868a200160147fd253cd443cf5061f1efac3a448929e2d039ccf0fc87fdd4247b7d5f5943485840e5a54f55011065e2b0226e91083f252ab0706dc09beaa2dd60a2ad28671259a6344d3eae22823397703271a704154033ec733d27d8cf74a0742199fa8978ddedf2be2a77f8e0d4cd2170c2a42439d2109e8875dbc1a3c925ce3295dfde0fa667deb68eaaec9cb545444dd211b205287c1d6a048debc56e14539cd6bccb5f10cf4cbf9f5ce5f3818fdfd40ca0ced70d80e3df16dacf03d7da2f7900a3bb7132eb14ac1f82f18002d0dab43df872d99dacead0f93cf3c925aad51009756ae1d202d3697b51a52520f4e196507c7db1e207aedaa8922e91897480f98a2cfdeb87a8a2afcb82a76170b46efdd295f9d2a65d0ea6cb2cde10154451a4ce6ea2b879891cf16ca0538cf74ef32732ed28b449f28d20d4e90c64752f2973f81e8f45690f4e08afa5ffcbd607eab0834c5120a47686c7d04ee8a7c593225a1ba080908a90b9d73f80d215ddc7506e9b3bdaf52a24ccd6bd3b46e49d210f83c70f80c07d7ff903724aafbf15351edf5b019829c2051b8a4fc2ccdd47380b0c8ae9faaab4794fdca1e3553ac83ad789b3eb3053696fab05fd716a59a199fa09d74877323d11e41b89b741c7426741bb1b5f658fe1699cb1271fec123ef2e1add872da86ebce8323af991dc551e7c0f65458e5fe9860a7fa799b6e546b0c5ac90429b48e7d16b68a44f9025f906bbc19760c9fe2e3710134bc581595dca3356fb3ad439bbd3c01011f3bd7bb52b800ca0f516912e02dd5aba7794ddd3a245ce3a751b6061ae007171c5e291257a1b570aa91d99f4f97b932b1e21d139973d5a6bb7328e5f09707b5d664fe2727851c2e22bb6c8ab07a098c33d8a2edbaee94f14e86faef940e8bccdbbc57e03db3b9ca291764d8c0e418a6fcaf7b5d23d733bfa074a16e10b75eab92b2b24c8f96eec5452dcaf8f04ad362b65944f6168bf77236c1cf3c76fecfdcd7709bebe8e502176f0afe82e4609b42be6488d786e6d6cc5e839adda1bc9457c40a2a56cf2d8083ec6bc412db58c44f745aab2a0fa417bb97639277bf6671b128dcbf9242fde44565d90f6d2b01195304a0dc5e42c85025dd0a6613dcb5dcf290d183d52b34cf6c76b656ad7f40a3af6c8f365864b2cf13cd808d4a22fa83ca04f50653cb6dad98169651b33c3fc2c532bdbc2f2d642fdffd5dd77865ac19100efce055ee368fd3f1d25ee978f28d8d193a13feee4a8a0ed63fba52cee23631c84454b9dbf9686d9ca8a54e1bd942f77c3f1b8c585cf68ec37fbfd667d7443765b23a9339b42e4cef65888ea713e345876c28d34c80cb2c5c2fa93c503047bfcad991092cb37085727e51597ab148ed7cc1df3923668752246d944d1b77dd9f17199f394010a981127d58cc160ca15b561e81280d32210b985e77e6534e59e2227cd1a38115e4c28faae5b94c80e5beda38a0dfc59a1f6339b6e3d4d5834d38e6ea9c2cbd476f72d23385c866ef8acf85073a6d048de782158d11127f2576acc43a4d443fbcba6deb7a77e2ca197930bbdc97fb78bcf4d8b4a2237b2c0975a1d9d81fd8c324f1cc6c785dcbccb4ae6b1b73be67c5c587a8513242748fdf00c9fd8e5da1621aedbfc427338ddf2970e20e249a67f87c059a81a0f6849b48d53d6b7106f23128bba3bf2a870adf62f4393dc29382b3e681c1fb73c8a872aef57cfdf17177c3db78763b2e5fd8e50c013114e162b7d3261f0ad2706e084ab33c4cfc31050250733d8fd641c062b038988f1f056fc8e1b21ce28a2a0eaf1eb32e321b3f34560ff69de1b1c9ddb947dc9268f90588f871facf18a817159e0a9624358d08ca815ba2a9dea3f2dcbadd2c82ccc66968d795351d0ad847a1aff40e4529f15ae2447cf497bff2aa2b0d2e4b5d7ca510cf1dde2a821e32713832566adf7c21b08a89554784a5a5f6d36b52cd1d178db8314daa2edd83c9e580258cc660f913e76f7d82510da11e5b2c883d8b85a0433fae38887994e2fb7515f1b9186eeb5ca20851916845d002f5ef9ddf3df8282e8c70c99df05f73d4c837582b3140f32ecdc8291b0f8decd4102a6aff4a226c067ad9a84d5ef33aba924a1d05f71d4b8d12f074ca95594538af29a810ec794c668020aa9a0984d9d2fc8827b1e9188db927deca5ecea51d0bbb5cbf8ffc7953d46ac3f90ccaf7e3b81ed843021b0a6ea11dd3e08396de6fea3d03eb1300cf79ab4a60f0dfc1c691b19b6b8cd806e245c82917e96a97e4f31c6e6be55ea3d43a1de143084ae41bf25f74b9d736c171c73e38fcf4b184d17b9b3e328735eb51a0965cae588a5076d989125db2baf20e0e283088a5eace373557afbf1ce9ae069c3ff8ebd60dff1d122e42e16686f724a5256f8782265c8b140847eb8b5972b295c8abf9b20fe006a58fa8f6370d3287477c36782ff67259635420ff5063ca657bf04dc038b7d4243cdec8f1428a9aed0662eae3c7591e1f3a14449598409bc88e75d5d94486877266cf05a94594cb5526f87827bc5b682d82d49581589c9528463857771482dd41b9273a96f2408fb2f7a13fc2b7ccc4238320a05366785a3328e7d9c4fba3d663575d31805c5fe305a09acf9efa2a1032cd0578e0323735bcef9160122ad8e888b9163cc083e1d9f60447dcd346f683d940d50192e6ffe97789ab9a67311c8c5151d5eef9fcfc6100ec3ec9ba27337b87ac8b5b2ee90e6522121ffb4dd62a5e55362993ebf446f36e4feb6754b0a4d846cfc38ebd591295b4eff12112ee1a25b7afa90f8033771cd5dc35c9838f263f05249ad12498c2b8ced35d917271b5b7a04be47e3d9dd1acb7cdc2c70c310b13cf189b1f934d3e126208740851ee679fd5a25792b36cbc586cb1283f62ab1b9b7cde06b52b45ced0cd3576dee59f04f0bb0fdedf3c2bc098424a008e30fbadbf01ef74294291f67a655a7a91481b1e2644de65a1be576788e1cabf6cb35ca6ad20fc7336f5b8d0015852db95b5ce541de65f4bf09733c5fc2cce9a7d21b1d6828bc6015fa552faa5274b8b02a0750f267b7cc988e1806f8f2dfc5e833bf34ddedb9104e1252ebd73afd9a0221bf4dd8d487c6744ac2f210cdada8e7fe1c5168311f11598ec9ed55b66210c33eff6b7c74771268702d7d2c304d82f887599b2917da03807cd0fcc78fa6f7f8faa88cee71d3482272f02f2e486ae96e0332777fba55bcd0e76716d6f57d21fa2fbb9df4d352eaadf0eb65f402810ce115b254bda93316bbb77913f887282c4b98a5aa2d5d004341eae9ddae6184bb815abb0a428bb786f278d6b6176809b4f67c3a70265da8c7d248fa3c2fa8e1e92804ed983f2ed36ba5c1211c6e19317074dd24305e5d0dcbeb9bc8eec774fdc1d8f525bbd1d067d900bed817c070e1034f3dc6a83cc304b7b508985fb8dfb14b10be4d1a0025f2499cf71d0f195502960c5a4fa63b152b0848bdf305cad6866bc15631da4ae9e3da6e337a086f159c1b8bc88ed2a1e77d2d66464321e6292d3ba282bee6c7edf63648007c71132570bb8f5d0f79ca23d6726a5162172b67ec2d0510018eb97d556d30a289e5d2638cd7c72f599c5207e5cc231a59b6eb8f75a0daf7146eaa33307b0a498e792778ebdfaeabbacb90fff5714944008d46ae5df2263cf2f1da31966870066eff082e5a146614c42e0c8bd180e9a2880e6366eb83fe7a05b66002e91cf5cc167235b991a19327563c4bce0e157269994844642611a9fbea95c4023f182a452363ca47ca368dd4f0d43cc5b61525fbac0b69df10d965badd11326aefc9d25be454de41db289bde143966eaebfc9a137df5f21aabbfab454accd751e04bb332d03b6e2ed606ef85f0fd8e51f24b9be2fb5276aec2adac8195ab673d1e6d437e12f1a98a15bf8b22ff41571fe760e078bfbdc8e54e0eae257b48e05cfc66ee3d8698ed5c7843021a1694c399562ec821f0667d458b3cdeb592881955bf9d891e17ed6956c716eceb3478e90dbb88dd50e9c691a69dc8e6e9ee92d49750e120e33ed6fe69e77e472c136f8d7cf556dc29d268dee969fcc839657f01f4e1d7f01e00ba5429d967f134f143de5dcec18bdbfe524cae9fe3d706c5533d67643da848fed44bd482a1c6ff24040d7bc2e91789c95941bdba1e4c48abf1b2286835ed496cc4139859086bb840d51f3109ffb08bccae3e414b911ae0dfb477fd91f183de58d8dea482c66966c22952e0f78ea4b19276cb31a4a0b24b32fe4f298a2ed0fa8e4643cce7109f9f703383f48d0163b74f5bfac0fde7489c115ef2551c29f055027fd62aa39fe04d1c67e471a2316a16709af0a329e54d40e7baa1c0b65777e96ab4327c9140d4cebf0025ae545bb0501c519441293b56d23735f5219785e7397a6de026f05a7b95b5c85f37968811dd3acbe437a0f85c3684cefd3d011282115ceb80c31503bc57840312bfe8aa7c8336d44980409598f672b26148b8c96c1f658be4fe0566dab11f5a25ec20c1def682ff32dcc9f1295471479605d45e45a8fb5706a0bd810258c435b9a792518d2e52b042b82d591bf5adcbea2dd2cb6b58b41b9af1451f6bc4d6109b2b319c06939477203a712f041697e18d0a45963a34054ef6734c93e37dabb1191490789f28e78e3e4fa50c66a799eb570c1f62e6dd9623bd8d871ee68de872155bf8c34aaa274bd1f53ded63731bec7862e2e7d815114cc2b1506905411a0f8b55bd37897d04eb4ebb2a9aed208f4e2469342588783cecc4cb91f0cd2fe68f1d8834eabd75e0883e445333e1ce394138b02fd549f928fd0b489f616ece5c4b69d82504d00a049bc9f2746c60df6ef472d0d07afd3a3a4aed7d46a2f0f239a630054911f24d3a22854e09aeebd6146c78c9e1f0923f0b189191223bb40c5cd3214ec9cdcab697ffe2d5e35b8962568981a9f598f14a968507e4aada1069e22532d8fc41b34d2f487f9e2d98d499236e02a7ed50b6a0119831f0b5bb6f986cc401282faf8eb1d157a96acb17d28523e671d1f6e250a2d419def65a557366d4eb8a5ae90ec7ef5bd95af42598677d0755953f1dfc13fbc772d0e0cbf403f3a0fa2ba36c8597d155dbd4a81625d3def49fcfa8e5bada2c7d54bc66c4e77f1aac8c844478b795026aed35d12d15604a1662a39134440c1a12c396d52bd3f21e8f31c968974844f6fde13fc369860099dab15e805cc8053db3fe733a1002508fcc942a09bdd6dab13f49f205b22e873bdf6768113f7fcd142ef1478a5a354110d547e03de2383f747bf4d132033e793b15211c565fb43a60709e6512423eba61cd218bda657deacfcc4ee58746d4f96878ad42c674aa6a7e61eda6cc2a1fc321893280b4c19e95162b90f467f43db7070f9f426a68bd7b46d0a3e80385ddd399a3bc1d9e0a9b848b102a9dc12e1d5b9b65c8f87ed390cf7452bc5508e0eb4d118c606fcf49e06179499e3fb0ae8b013db617c4d1bd5fce41792528e81803d00d1fb80b0bd1001036ea7f2bae820f4e1378b02140b095e171f48a974edbf0aee58586355ffd69b13c462a383a03332257e00a2a1dbe559f0d0d8a1702b092abde852a2a7aa7efa3f9d2d9dc1fcf33aba22c6c0b620f4fe081f6286e18e920a7434e4013c69fd1c130ac13d13d34c98a460098422d5b2fc4ecfbb1040d1eb560e5c656d8b975c39a8923db3b7d717704892c073e4e6e5ac9bf5c492654e11950f2fa220f584490d89b310b34c950fd8bf3392e12b69843475216aa535d02f8f26eadb7c67b7e89c87f9f56dcfe655ee3f986e30cfb1ca2d186de8c10875990573d7e2e47e16bf671d2d42422740c4da96220d5426cf39c3afae55ec8a258ebde04d812d341718ce8874abf15e45e7651dfd5d47802e58417561c502cd7573a14d70703231a441656c98333a290d50f3a39f8e3a85010eb99a37e2816e39c4cbe2c8b5b076c7e9f72498c1d906d9b22363db5674f47d1b8d0691c0a11b9fbead829cf60bcd4a2db38f792172beb208a6f91b91ab0036485a0fee480ca59c1beedf9c5a7b46dad2c433bdfdab2830b09ff57ee584e1a7ff48d4df30d9f380d6bdb79a3e7856da5597c77568ae14f6a5e7252e7bff09ef312f42e669a29ebe9ac31511c0efd26e99977fb480a9333bf86c7fdea22376eb79722d7c93a0465dcbdafb5cb5e2bb5dba9b5b26244c87766c7e0da4a093da89eb2c060bd468116e20a06becd9b76efa34a38fb378afbb46c8c044db8ea3dc29afc5f2870f03a18cfa58bafd2a0c90bdd34e1bc7b881823d9726cec95ca1d6e1308b4e1aae2b0d0336d756eced311baaecb683076cb8b49a817c5a75c97e73d11e167c4b2575fe151d9b22f1901ae38e3333e13745ccd55c06ca16724f01c5254e19fed165e899d0ec3a1784e475a1d125eeee2870a1d0449e7c28fe473ca6bdf98144bb40a9b75f03506555b813d64aea01d4bd4a5b32c36773b62bcaf9cf3ecafaa4d9d1f55c83c8b4d7f18c77bfcf21d887f954ac5ab0a32bde04c839fe4b2ed2bc5eec675c2f3f114cc32586b4383be183cb5fcf9c613e6137db7701c6b3d28f6effbdc06f71205e3cd9c7f5dcdc3f5dfba25cff72056b0a589cf1b5eec14c87888a5e5dbd95b0305e53d53fcba7ba85b0f80d4c9d143411af1618ccac44f89ae669c76d5990d2b4cf5c3af5cb9aeb8b7cca9acb0bef0a882d39c6baf28a4173a66358f7a83d33bd1be000b85225a51bbc77212348407e95affdf0775d08be90836663e530df82fb1cdf44e2ef18d6218086c0417b7c2a7093edd18a5f49e3364816b5483b7910388e46157e5154359531929930682c5c8f71d228e65474fa053ea86262da9ed8d18377e7404c02b5b68a7c29be03079ae3e079c4a237b11b97014cf45d6c7ecb45e272efa7b4334900d0735b9e4688cdf46948a383a7ebfdaf09c258a7e7e65f57ad20ae7e02fe503f1a60e3734ddaecf444f5a8567b28ac32bd20b118560b839e7618e168e4d285d7a511581fe078827d4e55db5435cbf5ef3ecf264b7870c06e3fc4d6dee99cac38cea992ea8f07cfe15cb4679bd4a24a664dd0c8d359f8a15ad14a559f9c55a87c2f780a8447a8c02bbdebfc2c6a2a65654e7df1b39270016c9109d3caa32bd23f995adfee84d7e0447d4ceef2d032c2531351c5e6c0148391e729c3724022c81543029806eff3195d1e2fe34546d2c517b688267a1a446904328b6913eefc675557ba9f2f7d31c0a68959f88360a648e5a7b25d19b637f5349811662d00cb3d1476aed303f6cc20773c9e518212086431eb7efb5c625ab8edd849c0f1d539d20805bafad6b2a59451e2b2137d05a343dee9a8145cad57c862f7e73859e494fb11340cb9095504ad1f26944acb23a0c7a50a2edb98035eaf17588ac5cd7fdc76c3b9e2992ac0df042af97a753c39998f081600137fdbda9f289a21f0263ec187a01f6f3851fabbc8560a51be11d30da9fae517d27fc64319aaa6aa896166909472c7afac15dd236a6bbcf7bde1bfc5919aec85a63459531ef06481c0a7e7f37f9f54882195e1403e312c75ef21399d9d2d51a803c4a6d84531451173a617276f4f6c3d72c2d276a7ea28fec95ba64b77ef9e907bbd7c7c74e8e0003a764b3cb0eadb4f2ff65b046234ba6a13bf42598d5abe3b199538b5373561d27dce7ed1ff2c90208c193e02826612a51d738856aff314ab56269f1d3f69bf3e7410073f5ff1631caeb40d355671cfe1b4756dcbeb61be11aa1f33387d14200212a66ec5864169ba1c1035688c89688a1efb8cca293a938e72a39c45de9cf319f0277163f895663125c90a9ebb13b0b40b0ba79475513ad4bd220f0620362d8ad1e5e3de208f0e6a4ffcd77c282e6c897fb5a0bef1915d317c890a35ca7660e71a2c875fa0a3027779507de03b3757d42b6bd15aa9d7712e2cadcd25a74a55cb76c7f48bcfdf8894059bf54771dbef8ac5eaebdba74b27d87eddcfa03673071e284ae6da5093357abbe16f4119e0eaf7bf2d42d0a713a32716277c87a93fe06a62bf1e955eb15238328de552d221ac7122f8f4634ea53f587c7c715b6e73a5f21c1e1b195ef26091e8609a0f89ff1a110a0538647598cb091c0f64181ae07616a6cfcf98af4f1f782d2436b0df6b1d2f9b0b9875eb05aa86883f2acbef05d3dd047f04a1aed065f4df8cd69ef6f014ad4ce0340019ed610f5d5d824905d26f9cbb30e28a02d5dc115e287c1a5e61bf44b61327960db7bdb8aacccb9795ddc21d78763ad9849e7b091056961ae955234aa8064e2a02b068d41e302c3b91172df10a86c5f85819b3d9a879ff04660fe274f1c631856ec85de241291c3f400623242f0617dedf3b3bd20a5be92f61f1efced3e0bc57acd28b535286b927390e80fbc33698dfb2c34ad035e033ff85503f0ffed301e1780a88e9e13ce48283d58ecaa2afc6f805259c0d11749ca2162d4f8dbf805be8d5daf953ebd66da2e33d9204ac94e3127fd1a48d4c28c23f0bf180c16619d1c4df844e5e5ae4823206e4c6a2633f6f91566db6ae825133ab9043c94294d8eafa51286b62c21a379868dd10f48ce4215cda279b9b1c8ff779aa9640deb1c0bec4b16b5969f601659af886e53fb9af996f3df04f1eba33beacad704563eaf6306a881e388a8781ec70847fdc5970ec78a357989f00d8eb07b443a7a586b04234003336036908f95bbdc9f1dd07b22896f039a07d8888f7b08cee84c63ffbb544ecd167adc16ae566687738b2a324b8ca477b2a50b9825a0b68d79b765b7a6056e88891e61ebd12a9e5800b426d6928a18ca8d7abf99ec12a07343315cc74744c01374a6ee0aa132f794a6b3286bf1346d2ff1f18c7b67a2065a49023d92d4a504a13bf0a84ef95ecb2edaecee2d52ddee33841f7a3fc278e8c0a193a83a34aef2e0534685420c2ba7cb603532d19baf1f3baababb364427dd912c7c68a076f0c9b9cbc444a3a6a9568b87cadc4ca8d3c75575450dd86b204a59e8b1eb00cb329615e0e00afc2907c311503a6d89941d62cbc777878bb7843929f394f8c8f30995f5ce17b5dd772f090bf6fa8b0d3fb67e980203927afc317d512019e74b4d42ccd0e41937578d985a7390a880710f879bb88ba3309f9c8217747eaafeebb0f1b55e57d60dd3f7350e2e6355ab0c35c601e7c5e96cfefe56630da74477a7252a805084fcc8f6f5785cd95ccbffaed8563305f2a8a29aafeeb2a51043a462cc22889249a036d9fbfdd750c3eaa713db0c0062e261a469c3ebacf4b3470b2cfde49f532ed7645bbdde810b1a9596192b050a2b9a48089336b811d0b8a74749d506c16af1899f275cfdead822ef5affa2f336a30b89dcff9024c28a29008046d64ee85fc414311087202d19b35a48e66c41177c2db1dd4848d38802e5a44e3104455442a8eee4637eed08d62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
