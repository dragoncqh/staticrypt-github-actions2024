<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7abd675190e4c57d9cb0546dba40b52b589a178e1f279f2421ba9a9edefef6330aaf4e56e3bbc1c85b52213dd14feff4a2f9be92a2aaca6370269c905860ea6b7f37925d9aed0fbb0cc8648f22518c50e00dfd61905659c5e4cce61514ff6766c8f485543746b804e045e0e7ef615ae430516b4e9ae8cbca516eabd412a44823d12a887e8ec1f7372dc98a6d8cec42cf8fb8fa8e67b474e0b5308c40aa507071f7f6e70bc73997f8a3b47a5a00b5abdb49d46da8a2e16c4ed5c034ee7df636cd1a38cb424826eed851e81378d358b9f12614aafd309ba8f7b5be324a0983c4dadd3936fc5450ebf309f706f5b619ece78f6291959b06dbbd732ee1e6d2ae0b5e568927033bba866f3f7f0c5ba1783567e515ffd1738cec29321e854bf1f3e7346a9a3fd7967410c8ee455ae17585247bf2ad75d9cea928bff3d74a4ab1a7bb8fadf0029d9a0410ac047c171c90ba6e2a5932714be73481cdd46787ebd6aaed7e3ab7c210c183ebbcefbf157bc9527405b6a063f8585b8e3b71e231c705165c4ec25da57564c129b94154f2c05f35901ba5779e2df70a6511cf44bbb6e1d638368553f9d8ad4bfefe5a72fbfe95dee7e732385e782b2bbb109512af56e5c4ef73f98029db1f8c9b1066b9afaacb13d8335ed062fab9ca87cdcb826b9ecd053234f25c87c7ee100c687ff4140e3e968487385b6cf84da9f5d020775ae41acf5812a6808f4d4725fd6be58f5f39f0420502a512cb73e12c68f61ab258ee2810eacd671c326c5df7fd9a07acd4b4e430394abe6a7d6ead02bc5c9b77efafd4dfc0e0f5510725fc55e11d6d4049578cdbc4a7ba0e97ec8feb330a31daeda86a534fd7e75761ae60d8f3fdcf6f6e91906802493a09bcdb6b52a5673779037a69c648ea7eb76ec6c417ccd325d5d6b1e3e203af00dd93eec1b855c6822baabb95e7490c610baac74e880eb7d97e79581ea9fab8a67c74e7e909d8b089e2f82491e3bcfd6411a22e47281b4c5200b4137be1e4890eb5b934d8015691bd823601a617d796db95c0b5e6789b65dc073a446dcfea9b07d804c6379fb989896fe78ffd32a1248437dc67ed79f886e85b384b060896837eaafc247e8de8044942341d55881a0621c9bf7f2060329c4c1e6e40b9dfa46b3387950ea85575b474379693b06999084b0d176a5f059cb3159421e9b437bf89c91f61ca486258dd8ec1bc0144ac3bb952432337bf82b419a01d11d1f356d902295e60e3da7175497457c2ea4e087e6e2f7a60620d103d87c4eea26a3c106d234905fb11d2a35c03e96aca6e73d7337a5b95de7de143a587f482746f08323c252557498b1f5eceb18fd302a27722bb66296f15988e5a5259f2bffd9586f853083d662421ec931bd543f9347e3a034444db7870b01b5f9c3d51c76837a7ea0723f0c67cadb62b3bc2364d9c6ded64ab024d9b5d37804c0905dc5411adc8695f255f0e097eb4536e3a729b2c0c8c8f2eb520d27c05a4ac19e9dc90ec5a1ddcecc2f8af88b5f7918324b3915bdb07afc4e36405372d6e1ac5ed7dd46f5eb21c9b0881ef0d1b0a6b7b32d51c85e9b41f19878c6643182f2245b9b62bc30a4b3370bc636b5595e847a616bd74ba5c39a631dd96109597801c07013c9dd2a0927fbc517d6267c79e121ab7b663b08a213990abd80b0686b888d6062b2f75eb8b631dbfdd63d0a2ea4ab9f99ca40fcb3bdb07e60ca17e5aa1f5504ef8d3039ef3535e3c2db1cf73cdb40d17be961e80ad6fc2444055f139cf99d361f2198530757cb969d63f8883a4c9a819b881b34ac86bafadfa8bd7b87eecf19c7be6947eb6539f357d541567d47b69cf6b25b4431b1313b6e199b26897946368ba6f8aaddd8b31cc719bbeec6db136cb978d4bf97a2b94c1803467183d0757a4daf8c7023f708354c6908cea3aadd3dac28c2fdf07ada43a95ab70a1e48976789b6ee82a8a8558692b892dfaaaf9009f96e5a92d9a05e5e3f3cd8a5c487da28c6ce18c5a0fb212a7212add3255f49f3602d90aab3d9d73d3b8a35edffc66c3ec01ab2ffe52b5dc8636e144cae4bdc4100cb6fcd15735f07a351a696ce4f1d5582953105a8e0126d146c285fd81157a534145440a2176c06021a255c69c3e429ef3e1dceaf63a874a6a80aeeae88b582c3f27eba6c6b53c42a0341f8a3a71e25806076bcb08da7aec8898bd6a5fd8ff31b52f48e91f48387867e012dc33cde9222cc08aedab088edad117737b593f65d9234b5089805c4f58acbf5e2ec9ba26675e41128fb9779121a3b418dab96410a77b4a9ed19cfc8e1d5a91a147a0ff335b407b10dc899d1c1840bc489254475e45409c6289025add26b99a31880ab4c057b5c6940e517a280b1e5c33fce6b5332156dd6491c848f34b9e1b877b10606b5858c14472b59fd724db1c5ebba71e849d77828a7980bc31b8103b08f253dbfb4af25e6959a669f60eb3a14673d9757a080809c87cf3122d142086f0b3faa6223a4705287a759e9c08a8e5ca3a52d7db1bbcfb723850a8ca05053f70003ced03d693141d87e0bde16bd5a015a10366c31bab6c8d1ca4db928695491a1826ccc47ab320d9252ca7b575e61221aaa33b4389b861317a7bdd5201b357dc21bff2a0a5f803d9b2786e82852166ce7ae3a0eceef81cc81e5cba8929445efcc460a8f1ff3921ac4432615409a141c08f76f51ccd6bb3da36ed4ae87add1da4474c3857a95a0a2c889f87d3b34eef46e247fdb78aab01606bbd5dfa1dcc8d08efe4ec4ae1a8e4fb68c45eaf58a6d8b1577f4269248b4b7674d873331fd0e7e5c625362b95b13be65ab396eb6c4c6519ac1b54cf8c5d59e1a42a0608717cd7484192b1f71d8f2bb033e0caf28eaf8fbdcbb786b9342fa273ca2938d37ddec38de17a22022d131f045cf9d4582161ce8c60dd4006a2ec66f5938e05c25ee58d4b09fd9d0d4a3b8fe8d7111441fdb0b1c4c7f87d8cd8548991b5d72f9ea8b1734f7199391089a509c8a14e2c59ca79ef2e6f8dbe8f1f677c8b74d792e2329def7877cfd3c7b103df20c7ebd0cc52b94b7bfa3733e7cd12133bb9b3dd73f29ca0d64933c1e35639567835b77b3b7935014b4b8f9d5fdfce706816a4c8aa27fa8e6cdfd88e9866a7a00f34b7f2bc97968539eb2c5402aeca4f1df640624c2ccb8e6e87d36bd311f79145922ddf53772f00a1d2465dd91dd9e6dfa7f2f7da410c552299ea50a6dfe5acf1f1312d6a656c51db0e84e90bf840b15dac2ad8735c2506d7405ca594aabc5a4fac913dba8d9d13b0327360cd54baa63f5bd4e39aa1d96f1bd587a25b1342c861c4e80ba769ed6e6b3adb069c1fe1e1b9ce34737eb80a0b46730bea683adfb052e91e781abf6f2fd3f86d3297acdc91c90de944b2a9eefbd99b0b1f7a37ecd2015b736413cd84a86e5d75d287e48b547405e6a6f23f6fd8ae6c2335e5950c39b53fabd52b8eae9e719c4dbbb7e83b9ac31b066d6852bceda2c59a40d7fb6604d4814166ec5054354132f048d1741bb906e6a93d306988967158cdb9012724fa56f44ac49aa33bdb3b3e9ce11cdb2dead810633ec7ff6454c0dc472540204dc3820f9decf760d9d5485b68036654d4b249d3fb922c17b8b5b5265623ff2109e9cbe3dcf68393ce028ce0f2c9dd5450f527c444ad25f2a639c4d145479e19efa319a71af8fd6647ae78f4dd7f7719eeb1cf39b40358cfdb98feb075fd0687afa79f4581a2b4831a5058d298b65b795ca94c21eb41b796f9de4ad0d0836f81075a5807ec99004c12fb21c9c25c73fd6a99cdee4251635f52767fe742bd5db6f9b42425af8a16c6f67b73f5e72b08b611b26bf9c5a11036cc77841d5438e859a1c3ed210f0f6b0a70d973e9158250a172d4ec8907da82a14797c45986c84ca45766d74152659bc4dd37c0bebcb6cec97d890e88e497fae04743c502b1f1f3aec390ba8c37fdb150074f644b11dde81652f01e24928b65195e49f0e4ad15c607f3b54aa63bb9e2cc3446a5370af7972db3e94264017fe60c14f561bd3ad3ee14c0bfaa3b5a99df1ff2808e8172f1eb1f82594387dc48d28b1b5f620f359234a3982612ff4c113516bdd0667c244be1a34923e7887c89799350304e0f91db8e5f062afba92c416d9211d8fca54af7adcd03ce7e514d60456d0b889fe80be511635abbe73a2d0c2b7ce063c8d0802ed410f646fd089fb1d01a48736844d26ed9722e5c0cf41241f7e985a2cc88317ea3da3a9e2c6536b6b4a699ee33a791e53a945a4fd5fc7bccf4a6f416db9848d480f78513c953f2e2b7ff4c059cbb78bcb121c4c2b32390a8a412d86e1f9f7241e30aefbce34fe7d12d7a63eb21c25e9809ddd0e7bcb1d91836f86e36d1d11fa897ad349477a4dcbf2a29dabd12802f6978f59783861b84822db90b16f7c796502e0ba22d9eeac192e5a254017151a5de8b42a6db9a5a16d58c717c2493506361e312514acf4a60e6d68404166eb18bfa3a4ee3246f54e51707c3b03ef158c10f9a5bbea4eb542c7bb022e54c95f2716bc69c7d9c7a4b9c837af61e6c90c03f4a1a8bf31542acbbb0a933e924501e98a6444dffa24a0060f21c199639c735a1bfec4edb1f63ef64b8159910a8280947b81bb560f6d69cb38ade37e10130fa75bc6df2af0dfe4fa56c3df229380719e78e539ee602d3f57f2694dd1406f3ac83766fe0478d8856ada3ffb153e38bae459ca141b3da33843db54d93e1174552abb0532af6143e5e4713c66bbe9e236db54310d5a70927e2b1b9ffef98635a273921826e96b85727ec03657c6671c75c1e8edbc24633a0c96a5c88ceac3e3c67a8609999fd5b148658aa9c3dcb6b139e719cc457a98121678816d1453649eb1af65a99737980222cb5355f7166390cfe7453eeebe49af68352e8012fc68114da87d08fe647b1e371b2105b42312b01f831d4bce5900e26a417055868b9bef4704ce39efc2b8ebbc21668695d775d9ae5bc416407631a4930d8779f022459a897648c2f4a4081f0275d60ad5697d10635d17e3dfafd34ac44ff8e84205c2345851350cf2fb0e81f97e99c0074ee3cfbe107125f0571efd64026f2dfc94a244889fedb7635dfe7ae3d003ec97941a72efa39391d44e87a4416d0dbf5e37af5b73008f6390005ce80bce01691a4eebf31affd62448b6df1b47d034fdab58815482b5976db44912664e23b90f451f5305bcce5e2592fca1e18fb3fd46beab900841269b9c08838bb44522c0031acbcd32f504fd355fad91e275271a946bd859a624fb73fd2e913520eba048bbd6b1b905f5e67c0089d6b34b3d5e44fdf816faccb3e3ca90a8158c494947bc3f6a0d0265ed83ead1bdd4df4f5cc32179a94548154873489ddf9299cac45252c7254268c5883f3729913ed25c6e555784e13dd5b3a99ba19530bc979c8299c786c5d993c4641e8dbad23cdecf6a407325c17487dd37311a90c63917d54501a1b564959b41d165309753ef62cab67a3219c4e5aec25727c0ab9eb7bb4262a2533b31725750c7deaf8ff463d9b87bbf0fdeaf5bb0579f9d78c19242847808660dd6f45c7eed6d49ad4f8298381442c602319ab1f9a625cea8be71bb14ebef58b732885d23e6e0bf2588acc06c7c19abc80f6410f1032837b922717b20da78c84c3e36095fe9ef6ed049ba0a91289aa9322c444185d67184104783f61a832243f653b919371da79d65c60278e56d55917f994c3a48391e7479d4dc2064a841ea693b767390bbf5e4f6b48672eecbcde444e3bd2c30d6b026462d135fe2a2850b435fc4873bfe6a681b19d17e39490976fd7ed526e578363bf0494ef402460852208d979195952242deeba61e23b2a7cb5a901ab0b0ba2de6e7eb0225ab9981f70dcbef3aa01dc838e4252c820c4e094c0a398c580735861637b1bda874a594a5e30e405894e4247d259e6d366c26b7b087ba45f4b4e09c16050c47f71d681637a05f9a1a4422e416f81cc3505a873673f64bde6bb5b1242b0f14aa7c1364189e735ba10674c4d81c85e5ddb62c76cccfc6a6695d019671a05bf6275fba81f327c2626fd683949c17724b02776b6ae73133bc515387429bc0b09adbd5fb784f94fc33a2e0349c8e2f670be865179177657539b06d8c2fe97c6347316d80260e9645e85290dccfff2459d37fb8bdea75bfce1fe89e44a95528029ef6bae9ec7f50e480719637e9a77cebc5491e9a1ca8220ea8ae1d136dd9b4b79bb45545a8d03f5118f0cd33de6fd25b4fef24bedcdd11099f318d7340231238b4398f3b3795de5d8c191be1e67726d0c707fed1c990da4b97911d1eb7cbe261ac029dbfdca7d5666993ee5f0e3ba84a3f4484d78282f57e44ae79a4f9f2890cf15d9971185802003197b8ab156b9c7609aa59cfc31162f122af5a6485068b3160d7192fb9d25847a9e04ab63d011a48d91778a062b324bb689e9124f4b11538569e8f0794c0dac37310ac9ec2d925de50595195807deaa923ad36575edf083d39b660a905a8c4dcfc0c3753217cd0a4f35d220de8445ffb9415b3efa187e4af69ec16017d4297d5169bd28d6ed42dbf13043199ed9c7ed0f64ecbdaf0c6b24e71f6e9e923dd9b35f1b77afac68b44990110e05f147c59158be26551cd7fa007c18f4401cb0af41bbd0ebbffe5fa8971135211087dbe5b1f5e7fbb7e798ec1fc5fab7578c6ade810d4ca93b01f14c8c8aff9e61e8350598195aed02d3410abb57c244ae0d2e2bcb57f0bd922545d67c8a12f6bc58ea6cc57d5982f52cb136436efa4e4ebf43bf15cc4dcc10d8ba85e9a126805786c71bfa2ea4afdfbd601ec2aef4cc92546cd9071f04cae0e80f0e2ed7cbe13b025b6fb8a7b101f03a6a0d826b273e9f093fd838e0d989569e644b3cf3d12894a0c3ca630bcd25314c3b4a5ae06073efe273f9fb83024699b1069a219dccb1a384197b6a0ce4529e40ea318ef7255584b5c762f6da80924bd95df173e757a465f0dbfbeeb0f4134d9212f6b15f32afc663aae5d7af9331747d4017c1260ceedb25eaa8f7a2dedd010fb3d9671b4e63b6cd273d6ccbcbb2dc401debb13f353447cc29e03b1c27bcf01c3061fdfdeca701ef7283cd7e617b3b6b44f8e283790963f204e541e6426612778c4f64bdcfb71d20d59ca4b1e9ca404f563b74a31f55c3fca3c9b6d8800c1270ef4f9af99f4eeb17df35a20ee3b4df0b00452fa26fe050ab62148e36a47bb4bb52a0a9a4da39dc9bd5c78298153fa0a976db323b48a34f63368194b1cdbf0766f03d9a3440e50ea47f737226bc4e1e1974d2e056901913a3445367750e91041b70f4932ecb12354a778b42d8f03e3d6a73cd5c68a02cd821314ca6d2eaa6db9f79c587e5751d2a9b8b88b1fdec8767197cf74cd0c6f2497875068bc50b413c22fd9fa38a5961c0420de5aa36ee551f8277b9f7478df5f1304e367b5b470d79043319c219943967ac7e2de7edc4799e9b7caeb3e16ecb91c4b56546a17dc88bd6e64399051e5c0eb1bfb7ab65b72c5c1c194b72b0cf95d94b2d2faa7537b14270b78869f6f91e46f2acc5112d8c07be09800b0f493f5a81c064b104df33992c3250fdafd5014211e36819fbdbb3bdb9cf2d8834604e1c6a81492365bf9825930c6b637defd84f3546de4c2eaf532628cfa3324aaf619dee4011e2d1fc2439b80634cfef168bbc99a3b84ce28b19a260b6db4d56d54bba88dbd0f105f172615500814a3f4eab33f4743e5c76d95239c112f0ebdad7dc972c85a292ca78dee510c63595b0f1748789d33cb118a73f03abb88f79fd53a7f146625a79bbc92ec21d257531e613216dd9cb74e9f5dba0f072a816b5496eb5cb1f6632bff6c676ac851f7206b639eda0be074f951e20b020433b5dadcf7915ee33f1b48fa0921f3adf8396b1a2d427489e95dde0120425efe81bd80a997445634d1c7ce6da11e0d004d2822c3e64df4e928bbb659af55063539e1a6f8e86ca96bd4a06182180f7e209661adab1dc29319751a5130e3c3889042a12f91d82fe070d1673de986f1c4a1eeabe9d5ade952fad9fec6676fdb54bf28e9998586c3373a6cb86ea9fa47cf5efc1f1cbf71792629b06c6624daf2537c29735b937207609be2cae649fee3d784b1ecde434cb1a107885d3e29c28e86f4ac0cc5e6eac876d7a06e591a951b8a24a7bbb8c226e8b8ad35c93503b2ac5e0534f7b2eb9d3cd978d680336a1bbe76dddbe6f156e6e074031aaedf7947969877541e0175cc1826b2f56c0398045eb25d74578277fef4a0ebf59615d81a14060460657425f4ed010fd0a37fa0f59847c565d3d8b7dcd16d21953cb8524c6eb74e5efb842618af44ebdddbf10c62c1ae360f12692c63f38e989f35bca3851fa9a4668d6478cce53af9f7455ad8ed1d4720f13710c4d39acd701a2e36115db9dfbb8f99db137cc2077308175d60896a0d3b564911a81943fb892c395bc1e9be75abfcf8871d9b7d1a51cf341879c7bb2780ea9e39e63fca31881886f9a178d9651a963ef70ac2a993b95c52d645e52ff03a45870e5bb042f7d78cd64df7e512467f8c4cec48f7f0e253e9c147068b2a9a5442b607970cd9ff6889b5a5323b2bb39b038045d07681b405ea484960192426fb7710240c2054955cab057ae3b4045d0612513422ec7fc16ce42627b9c555cfeaef08be8c10e42fa6cfaae9874bfa1fedb575e90c0a77da58753a2dc31f5dba97e351be366166246bb540bc187bfa1914b8069e171b1a370de885c2e537c32de69e8042447a52c6ba93108ffcbe773e0d053080ebd512bbb63504c417f0d3cb8997600e9bcf23fb711724065d50681287a6883c5d9a7330b6e082eb1cca9938567d30ef3087fc26b42f045b36b0e087b45e9b0fcc7c1f4be64c8adfa4bbc3343bcc42d44965b8fd986e5fc0f2e454926eced8f16bee6aadc722a08a9f204c42a08f4c1b9432f21bf7a38dc1449d8694b5edaa91b8bb85ad0d755d2023f1db03b1ed8bcb914df3558f50541411fad4d56705f4dbd2b2f8a2eb461c0a22eef1e8ba5c29605451ee66bf0d5b27aabaa4c53e9d2697b49f697d8ecd84fb03a4bc79f4b5c14e50e687df97fdac5606d6fdc51d8b9a9caa66bc8eb985d8d7e6287094814afc8b09a03a365ef9a249f6ca9fee84aabb06f2b1f92b8b7cf33660a9f595559659866a0b2e9592cc7e6a5a49053cb3502b4ceb55ca533c93911fa6df1b6f5618f39fb6773b7069f2fc3f44b37ff58e4a6776fafeceff04258703abce119a6ce988f1e3bdc552d3bac26f465eeb5802a98c1f479fc9fcc6fb079b27cd21f1e20e83da58d7a917becc060d4ed4934a655ac482c3d9e202f3f451f848e2225fbfe94a0a893d550d40155ea0dadcf75945e2235cb38770828235c407914b1c1ff10f230c00f2c5de6e7d0c6be2b85fff52efec19a59d920a012f74874ef166905868f491c374823a1eaa7adc6710a45cb483dd735f4edcd873e5f4561bd0040d6b2bf9034157306428d26196d57f56861ef86e18beeb3a84086523e89e409425cbc9e74086e3e4f84f673e6a47ad3fa00a6b7e71e810ae4432a19ac7d1f58fff2ec2b28014471fa092e649e1aa76d2c756888ae51ca9133a351bd88afb29a773fc4e2378ca188095949347041ba93e77a3bb2163bb6b624bfd345572ae45e8d6929c9eb6c33f9c19d04ac9cc681c4f9e98b96c058babdf5a2203c8a1f48dcd35695832c76221c67f1029eacfe7360ed90f4372680df07dff88850060e5b68d4c88a7a63cf041611c2ff1987b1cc936233","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
