<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"861d2ec98536f0b9096a935b11b7abf763f10c7c4aa362a9596853ad13686c83170a6d5f1afae91f2d74b3c3c5b9f279580dcf6df727b160b054e60d279a85e18219f1fe036005807324ac138b80f010915575796aa0e8bcd0f8a15d1e06c7d3c43ea9a93691523690f4a991d0c7c9b8e2b965f43e0ecfb06845f875933848c9bb61c0ffd5c5835dd8cf1bb44c110ddb627d0c851b01184752329dadc5b9d321a80a5b358274151fb47ee679e8025d3c62a3d1341eec829697f7288e841fc64b78ed6e3c3287c585ef11e9ed4c9655b18d5731958f756893da1e7bf00eb0986545dfe663e8f7a0162b9bf492f371a4927665fccf12d8e1c8610bd3d0ce0d7150e88680a96f039f0d93aafa912cfa3365a782c5fc3cff1c196ee0b93c4329d5391e011fb65c27d6fc4f5f8200030453a43207185241a8796827198c1ce63151a2f3f4988968e22f3ec3fc695cff56ef0d0af6a235fd2995584f155efffab2093c720264bf209dfcce950fb3ecced2fc6ca7b20b640b766a303de1229fb368f7ad47329e201edb8c4e8a7a76c71865492968c599f412fc42742824f6718240d27d1e4a54935fa7b1206fb515c1b906ab2221f96ba9832c8f76fb436acb610d0ae2b6634adedde4bf150a3c33a991daf1938f543549b9416038909d27355909d71372e241cafac5c5256309658480991e6848b7cd8d8a34a81a74aba88bc0fbdafd11572583269387356b6292209ffb6d30875f5ad9f88da64f183674b693242bd7e3a563c4698245d8d6f13b9c0aef58ce42888f3df80cf93e8e596506cd1bd996f7f3decf65c4e0111a5da68313ac96855e0fe1d26b1ccee4de49e67e1992c5ed0053de034497b95843f559785c3b894be62af0658a13ac1ccdfbb3fdef83c5cd802cb948ac2c38829565b4af3623a1bba772c2ad24a19a919aa374bcbe4b0987a78858b3b89f8386aa611b59fbd1ab2d087001f77eb2879a7b70643e6056de9a604648b7dcb44aa675a127c30d94456832f0e564b6e9dfc12acd7aa3d2d2e076076d0d6ae60442752c970898dcb90e0e2bdc16db9ad8b2486c09f96aecdf600166013067525e93d1e04fe0c9055f730a1319cc262a2ba010c44cc38b08bd2516d51c0b79220aeaa5cc80b1e29e56f6643e9c4d5529774a1aa2f8fbd1b776a6f72da2f455cd334af77d09cb35eb410bfc34cd8ab25ce66848424779d69f21d3e29e4e9ff5b20433eb3e5c6b3b282e42eb5261d67d2e2ea9daf8ecb3f2689e728086a3fba22e73bc16379ac49334272a83ce51646a4454b5f4db6509535522b055a9b9f4a8db5cb662fa9afac826409252b05b818fabffce6f5c7897f9f74e8b220b1763c0a6b8955681931764a19a3172edc4c4fab2ce0db4b430d3e95e5f3720de2df882d434496750b3dc1ab62156853641e3388307ac3f62236a8d16228832f4200dde2281e563621fb96ad7770542774fea1f7ceb24aa43a18831fadfa899812c5edbfdfa0d285df7e6b771dd50f7d164f7cfdb355f8aafa002bf66e025416bd26ff82bd65da1768d1523341982dea4668debb0c239a348bd9cf76ffad2c7520ea866fc33c9caa751fdd675bc2355c4127ae908c9546949ecce543e4d2dd347f2677e8ba03f684c6b2b0fb55d8b5924bd5eaee07577bd1280dfc7333e7d2f37a9c46ce17b09d0448cb639966011158268ed2127df4eaffac6923ccb6317310baae8cdef71584db012ed94d33c57cb77aefc11e869324f11067fb8532241220dfd94c1cfda8e02c237d82ff8fd03b3e74c796fff064acbc55fdf9ad5fc2e6554314bf4f8b2f065ccb8f394fb86433b8f5b48fcf7033aed62984231ef87524282d89046d4257234b76de19d81ce663811e517df5e69e9710ac3267ca3c9c4de507a49a2bf6070ea2fb890e7d7b892068f325f4c639ec99551352b57eb7616cb12e9999c10d69f976c8af30b05b39682580ceca665da9464835ff80a75bb2321ae663acb33cab237a53505c887fb26f6d6c5809c1ff00dfafb67a070081a64dc8ad1cc903cc4b68af4d63f494617add2d54a6eabdebd90b8360faa7bf5e347d6cc6a9583c90384aaac3ef9a8186c36b1684bb895fd461863930354a7f578c3b3d79f58dc07a58d80a60a282963d05b6cc3bd0fa40cfc36a6fbf14ccc84852425d9dd1e4793edb05a2515dab9139ddbbf5d6c26befb5e8065238083598a485928b8c9dd8ab6b66b88ddbd68242948f926ce0023adbe10e1746d15961d65cf71cd15e225af7eb1ac858fd23517bbb7c3195e95ab56fa82779058d3ac0df84c54e6cb1c4a51cb0c42602c6d38157ca46c1f0121e08e82b701c62129d3ef72de450ceb9d9a16ea145222c2318e391ce15cabadf8fb1206f0e2bb0a0d74ee60092547ad39d6040cfb16f4c6b8dcacb0a1d5ffde6e4c5fe138c88399afdf1bb9a8fa2c73ff771245b4a32ed93212c800c444f6f78a472d9ba9041f45a7da5861e1cd01b9325e0557f7b52571e9b1eda679e4da0bc95e70fd61ac904738d0a6fd1172570ecc324fd614c128db1127f4b9119c70adb7d3e13786f0ccde99787da08b7de2e7b32148dc8618fdc676788bf599a4bb7f7e6971dab10a9b1934cbccceb978b9c1bb7c675be85e28cdd8603e7c92f85c6b9c7fa2c2a40d1cd06c7fa08d21fffb8dcc0d0cc6ea5804055942dec39ebb4f595db5b987adee7c154adfa9d3c76b0faef123ed49c5827909d357bb0c207a73fac63ce31a6863d11110d6624f9e0cc579c0a7f5a3892896a3dea41a1679692698de144434e8f9aadebce8e3b4e1370c70b3d160d7d2d79db8a2f33abac93f8b41852362634e14bb2cb489f00f3a35cc8d5860635271b644d44b540cdd1c7479a3dfcb09390f258b5bd2163c24d623e0151742d0c4b5dec290364d88164dd5afc68bc5c42cc820923a49504f65b11ff9d04aedba61ab65cef3c7bea1e92ec16dde4daa5b4d9a2e0574af5212fc616fb8c363a991aa99e1ccd9b04865205a809223d526b7151c91437ba5a4e90bc75de07115e7f263b51aa00e0be4470413f257b21236a9380a580ef8f052a9eb991f2f0cf5913e5ab5bc03e53e6c8be8c6fa5296ddf8d84e8d2b20cb255af4b5a153c21e559988fc66191d80e31ce7942e6692fd028c219bfd5bcfe3258acd45991c4ada46884c9d98ed68b5c6466447f01addb56b6774c4c24b4d1ea3f87cbb94eebb8a004f3feba598ecd560860ee76e9d80a6c1a4f5fe4067d69f6a72cef951327bbe261a9b7e1e22e45dc92fab64d9bc4c53bd37ebb181c6f5fc3eb691633c6f28dc8dd80251f8616eac29c860b43874faf209d3ea86790c294babffefacb5fcadd42c961fa0d2cb7dc433281aa1f25139385736714ed5807daf589226d5af22b336b03a4ac313ede28e60be57ad313ff165dfd4d0caa9087eb83fb88ad8d16af49dde36fde8046cff98ae03c55dd504c73976cad7719a7c0c9de2ec0870e0f6c1b88afb3f7d60fad11ddeec538a05ec17d6c16e7c101c8132ac5bd2293a95b470aa8f222284cf21b75761d752721fbc1922f6ede406a0bd3161d56d97a6c04f261bbf7c5c1068aaecf1af6e32a1d09c5160ae4344df06e7d7a587366389f0461af2395855402c787d2dfe30d0bf467ce520cd71b5aa88dcbcfc108884cc412ce03ce03e1cc74aaa9114a9aa527264c0000e5d1d2d48bc345633bb7a32be88fdcce236e722f6cce9fc8f8e9881ab83a4a31a6ed7c25e6fe345e1e703e4f1e2324479fe323ea264cce4d0ef125d391f40703024c4f573f81de199f4d71945968ae14cdd3b4b549e20fba60eda66fbdb1a16d4e814f428fce3b6948017579dad6109ac74e43a22f6924d667497818f18f0aafb9aafca0e95f9351477f8041589427ae1969818820b1da87f4d7cdb6d26727f180f1e721464b0f6ce8343c4854de3d68689def0330d0cc7b888eb7e70dc2d954a93443bca17738dee9688f76bd27e4f43540efc771cda55d2f0eb20d5eba6ea758a609ffad29d6a9427af7f3744c44a6617d70e4d16d4c880de2a9ad128e3207db2eff0f4907ae11e22724cc1451d087a9a80b2d2933fd767685c05d4056eb48276df3b4b3679af32d851400c23e7880270d145cc5b214432ab9e33184aacdc1b9dddab1ece50753317a0c2638b5f16f9edeaa294e9127b43d011109f1d204cc25451be22770b19c50bcf532c4cd98b10f79238efbc0e4898a5d2c5ac91a7a0dbad0a539c39375969ece769e36dc77b6a4a04fb0f5730c699514112ec81afd12268d9d47187abd6399335fbe84f3bd87c0cc243b60bff8c0ccb9882427b352d406025601b09d827300e58c3eaa3bf13ca2b5d855aea1a0adcd77b15c66a401b542a2bc2aa92e90c6c5a96a72c28197d161ff24d11ab73b2ea8c1abc5f49871e7371d1f089090b595658527034379b2d9eebc2b8c32851dce6cc7b83d3ca36a4a9418aaa0c9d464bea667b01a27b26d41afbeabe65cb1d18baab248756db16f3278f13ef7fbc82d50760812d81d0c3e064b8bcac94b1c61043ba04599e40021981689b97b8b9b5643d27058b4774912317a62fd6f70b598607d79b543c01e414933be84adb7f81976d4819828023d145bd28b4e6cb2f94e31b78418c5131f31c9d6f3cf476f5b2847cd5292fbfabb1845fd2dcb6b203a4598f09c833b78ecf52a79b1ac39e96046060494d808910edbe56dbf694af0609fc065809a8fc84e118fa046398a2e3284a0b172b1e99e9cefa3613e634902ece5c7758a28996f51a792baea791bbfba2a898cc1d602c5704f72d2b0734c7fba63026d99f933bf78aaeadde17f1586eaed11d97fb27edb3295a21bf24cd0b098593d4389615fa4ee90d3552af03bc92b904e399718bba21ca851a0a5ffc6ff589ed1fedd4362d0d281f54d065a98d0df0336c7cd4c50e3feaa303de0395077d01d10a32bc09bf4c778cb592804919aba9c2e4e0b31123840a6bcc38162f1cf6198af8695c98e1a7b98044fb494097f8052d40f4a2b15fd7d514084023ec164d90ca3af1964d4355b6b5ad15d3f723ab93ee20cb5d637b5e9f6ba144dbc88106770915cf057fe8225bb6211f14fd8395a28a3eaab3ee5c680a555a1d4793d700248b02cd2fc2d185aabc9d72df34e9d9f2157209f0448e78df9383245c55af9f1f8f73ac7a12f08cd0889bb34d70721d658e3585cf6779f27d82b260639e0f1f87f83b9f5d717eda3bc4ab06f4b3a6232e2dde108a4632d55cf12889314f2b2df7eef26d833ecd283a5d312a0675087402b7dd11849dc37d912c3e86b5ed5ec44eaf883da9031fa878cc42653cfeb98d1aa6768d109d12219ced310b2b50ed75d0588b1b0ea94e8d00cf4c6795b35d6f06e9a5081fce85e9d4350eee1bd0b54884405407bdae4003a70dcd980ae1360b3b92dc13b42a1c337665d55b857d4285129ffd36be5080f1dd8456a8fa8068a97e4775224b35a2ebac26b3b7c125f6d8a65fe7b1f86835a2ce8db9e9ac77daf32ee6e9ad70cb6683eceb07aab28f55de2880d671b6a5bd39e39be4623a340b9c4e41907594d18f0b2a49b1be2bdb64f0ad1e79902153f699b54e0d92f5c05eb3f6f1be51ba803188ed92feed43ef5f4b3818c38b29073a9ef79716f9650179e344fce8293399504ce359636827a31bfae7ea00d5bff2194b143906c39b71045b0a81a57bb49e642395735c0bffcb5afe0d6114cc686b0d985b6e0b1de00cb0bf4a2e9d5ee67e84f23f96b81f34be4a844a855a45d56c52991f25842ee8e64e138a0c700d3cac65b6d8dbd154168bf9ed7ec9a685c7317ee59939ef816dd6348e35873a418894009313510fc229f7a2d5d2754c64d0af02ca0b0e7f28721eecf89e5df07afe8316b147a9dccd781bb1b6f7312d674272f20fe5c8e7dc28d35fc79d5ce25b485ede48b6e1aecb67b1d216c3ae5af994833a849fae50638161bf076b3474cc6ce2f1e88e5c67ae85343607d355d1ac6c10289591eee37026110ad4703721295f68f3ed6dcbe942dd45acd28d3a2858bd1b9da2bedb5c7b76a8e9649db7318141c0b3d502bbf1f35115ceb206903400ba39e49c037b9465eabf5f1041a6a19c460c6ba3f2d13dbb4577380332274d158c65eb54ad79b4c21435884b23e903b5fd16a1eb285c0333be5e77966eb2e3626dfa63da65231c4d2cc83a89cc45e30e2b3f94dbb901348d2420d1b802b4ee5d25b97a869320a84df5e8b6b5630ac366c5cdb98847ca20ccd5a66d9b6db57d1f5c04840c00965b1a3fee822c85fe5772321283c47cbea05d65a15a54a16bd167f7fc7e0d6fadc4b4b4fc6f98fa6834dbe173828c5963fdd557af88674c7deb4c52fc358c2082685ac98dcc8479ce51141134b35b1b92fffe00b7cfd85ab09aa63a947c4e0eeb90f23f94255a04d8b78c20432cab07da158e788b8c0cd8b08017a6b7f0deff757c22ea3352b3bba0e2cf3ad0024ba5d17c88e029d9d8f423ef74b278ad8c6a90e6451ed6c076527eeb2dcd590701e4ee45747588c2b50ce40f7724537cee828ea9debf4d322cff7612523ff3e244da5eed9637b99873ee3aa0cfabd42bbaabb03668f1de5b33d9a95feb01742c7afad5d50889e0bcba374c14f174e0e0588f0967cbceb606f2631654ffbd22ecf38240513d5d6defcaa3e9f44be87bdf40bba99214ea06d71436aab84c9f9eab10572819d9ae8bb24cadf11d2960bb302f8b17aa55fb1585ab5e45ffe31c4b754efc69e7ebd6988ea79de62ce5ebc2ecdfa87c166c6b620028c7dc42f5b462c41d9b51a4638560e83c94f4f213088a5b237aef52728cf7acddc76eec90963d9eca15723b840211f3d1b9051cc4de50fb1220c8f3e15628eb9c3fcf7feec7d89f8175f15058d67e0c539025566b3e21270fa163a6df06211a66554914f93eaaf7e069b304b85572c250a55165d6c5abd83f5b8b908b1f1624f8d99e7062a04e396736f970033b6540efee1e31695ce18e85f5d88108a4091922028ac00b34a525a800d4e9b7154be3554198f0c17e145da827caf3a99d623188edd119433ade5ce6e18e6a849d86699f533be4dd66449e15302e1650694ba9e72a98aabeb118576c401ee66c0a7ed302d9f4f54c407435549cc72a81bdcdcce8cc5b2a9294ecd24312519e3717683f6bcd19ba5e79d315ca0d9f9ade84d7564cb0efc9cbf29afb32aa386a9bde4c10f8017d77b4191e9425ecce329cb5ca92215011f1765fb5479a7bc521f5add0c3bf5058db18ad2721c10db4e4b7d87cac95329adf655fa3eb2f29b57860ec55795c442d2c3b1e8d0268d4eab3368505324799a6840f969355dfe277a982dd2ff3c26b1d7c99ce381e020fbfc6c97f6c6ebb5c1614dbb0334dcb2e5b00cf935cb2b1dd2a44be5b10058cb882f4930b3715b9ad3acfb257ff7c6f853d01fa3849b1bcebae7e9fefab397bd173955ae3c139e25ec7b0c814abfc0f7d7d1da973532abc24e4723078632b81c2782248d6c650ab644e0526fb53011ba83b405269ddbbfefe0107d1aef0ed2902f760c845640877c1675954348d79d8ef04c08264ca1d9e70795a13b3e429ee8fce8f690f26d1c55ed4945f043bcb911b87aaa5f3c45255107eaab15c800ea067930aed153ab946d47ce027eeb28bf1a3070c5477bd651268473579eca0b776e443351fcc873323e2228756fafbe10ebba29e267d617b724d83ab1153ddcdfa07d9cf7ac1acc7ae27c96b858699410db24a0eb8f07af5a481d1b63b98deb0231e6c13377db7c4c97458d60e3c4d9715006334504e51b1c05fa1fb9dac4549834c3a3cb85f70466ba29eceaf37a3bcc3aca812f46fc4534489fd57042083c04911df15c2a04167c10d4526a262b42e9b72d00668eee7d9068064d3c6f884fcf36328f528e1c19d7aab68eaf1789c53eac07574755a86ed0fad9c8335b517db3576bcb28530c5756a535a450cd8baf2bfcb971488d3f1895ea7a38a6420ba27639f320ed2d06e320d9073d3a68c880768c011ae1502c17ca97900611ce79f1cf23ebc89159eb0c65d59b17084b9fede8728227addc41ede30f0b660456dd225d5f63a22591e9b699b6ed798e37d7de329765426fa0ca5974b25118a1383f1c13b31ba99f89ba9238693128a2d473f2ccbf648ddd2e76c173fe80c3ea25b027b7b1da0a6bc0a5da824d14f8d0896a6fa2f4456a8bdeee716972899634873e4bb58eda63a909809a1caa245c233982a4539665ea0b471e8525cd6fd35d0fa40d760558e17b9f474d1094716a2fd64594a655cde931b2ff4f00486947da340d1ccc89c76f44eecbe659f965d1905a964bc797d9b99566471f54188c502d9d0ecb0ffa23220e736c7ef5d56f07302a99437a19b92ea10be491bfd09f7285d3e5908699a6c11a1bd192bfce53b00d339cd8a9eb7c2f18f0bd172413838f6bdcff12d02638df08d5ce3660ea390233ea8287b6f9e2f1d8bd9408774742d243ae25add66b9d9b5d5b2941a1ee92de95f16eb1cd525724e50a8c30e5fa00e85b9f6dfae3bf4f927f2a5866a7f600cebfa1ae0058c35c2de6e792505eced046296af0c52f0d9db2dcaf617e71b683055f5f44136aa05a19e8c806b5daeaeebe75a1d5e788408b82da3c139358dc73357bd24434f013109aba452a74b7a7c277f273bba96c5f8a4d8b481d79349c8c560b521f8e1bdc0db0ab81e8dce58ec1689cb8afd5d4b87c468cbb49a6165433ca62a64a20a64a7ab4aefb98449eacac0ef2a9883a6540f4a7cb048b9c448742343c5d443cf4fcf8af9ddc1ccfd0453c84b36921ac24d4ed3aa3688da5e1343b1d42e911e207e57b7bde24b8d1cc89e2bcaab1cf80a9e678a8e1d6bbe9e9f38c69038478cdc3d08caf4a6a136086e5a18e8f10be5aa3c7284872f7319902f9a29d15be876ef2c20d4c926e766d32d0e1db7b6f40b056124d0624f13e432d16e3ad48dd448c0d9c4ae3e511f38cece8e72547693904fa60f71448359a1f8884bd2dc7eaca750244d219db7c98c287fdae4411b8e8ad941dc222b4c8e66d7744f47b306602056648ae51db106513cf4b4b4e4e0982b08ec6e06050ea0973db1fdc477ef84a72e18c82950faf36d5940f4df89beca92688be5746b134f7bf7409c59e787c8bec5aec3fbce0362b042bdb0c06effaaf86c2588c2f8274aa0d9fe9cc5d5f1893d916c78c12a6d4c919c47c8e87ecd44781f0ec0d8c993f56770610670b4ed7725422156f0d15ae801af0523018c8bdf6b08b1e060aa9f2b83c2fbdde2c1dbda2613e7d4aba2da637a0a40f10bd21557d74e8cf1af944f9f291ce6038458f1faa6df075f691c71806ede16d784578196769b6db3ad4b6eaab6d1a2e1b9cfd3145b1068988fe06a603bb6dbec5c70938b8078188cd7e3ed75b0cd6ece4e6fe5556118e1181c688098c4d2ff3d919560078a525f7f9ccf31b0897d514150305ec3acac39ce11e82594ca125fa091cdf2cc591292174ca993adf821043c5c92a316b83db10d3f5ff5555ba06ef86543dd69c2a5a35994fd2903a66847f565ef30f03e08ef1830cbf1c6aab38ca479e492d9b9d26b99334227d3afc6ee32ff8fb1eb4e71147a2a4db30d990e2cc759960de32ac666d53a15fea43c6fa5fc977ef6e8ff1e820b36cd795b5dc5ca7ad5a448dd901513087049dda1bea88099ef63863d3a68961217d89f071b2023d2a9b0f3a8c73736916d33a7e345932d0c578dc850dc8ac77ad5d8c1e847cb8e6d4908e754a9ad3bb0622543c4226eceae10d967e3fd019df3f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
