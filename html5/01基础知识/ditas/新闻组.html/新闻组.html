<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2597bf61e74c9b9a8a4453579d0a80e3650ce8e4a0fa4ae99c265327a297626bb61107b2b1b6a7c0524f2717d72747043ec7a410222917b234cc3f7ccb2d50434a5c3d3dae81eaeefb21912509fe25ac78f5cffe10b4cb7fa5dbe54f2c2608f5d4cf813fbf5a1771296a57d4a7e12e93b74327f0a0d5e53f06d20e3e18a474a15ffb2f423a5b40e52eed083a5851f0d5f1f6346509246852fbcd82ca4334837a15e28a58e599f5d0a7e1e02ab30824d5d43fb1896f7d594cf205bf654807cca3bfd2377f04b1f048cd1aa8adf46ff4924ab471327c1268a59b26b7c218c03b750e88e479b4246c1608188d116b89895ba914e12ea5791007df4e4df2b5760ba79bcb5ee16b66187903f6633fa7e9a6c38adf1a4260cbee900332ae480362725e550b5f7f455fa162b26ef1633ea144a3f5a526c46004c7ecfb02f0ca34fa62c2aae3a43e58f0460fff27ea96b6f6720cca07b78559db3a959155c3712b8c03599914f1d9a446ca5bdfac4f987d7c64cc844b9aeeb97efe313a2a83f6cbe766870ebd90c20c9d01913555e26dc3187171c0e5f35bac62024f7be0c2900b2af2fc561e689528bdf8b4ba6b16b618edaf37cd6e5f5e5a8cb0fe40c330fb7be60b3184c353aecce178c1a41544ed78ffd3035dc1b9e5560b69bb86647ef992cda97d54d444c7bc4ba9f732bcae6aa9e79822e3442492e753411c23b6a17a4ad32c9def861f2576b5cef80b44f2da7b4eede7288336a3b8e3eab3b1558b6501ab344e4a9d14f3fe5b34004157e8cf562ce7be96626a4a2fb34f1f245a66845740a993a49037022845c4cc33c28b30ac5dfdbf3c5d184c4fc5c38e873156aa6ed6229552cee1e8195c601dc754ce62c2d3fa137bf82aea4bc9e523ffbc1162af9e81a5ab87ef5eb309310d4dbdc7fffee8b931f5d10141e6ff12785b99bb8c7a3b4fd839a37e2f1bcfd0fde70642e787552b418d55b4979e758373e353d2929cb1db4e0c04b32632ca044a7c706b0c520986d8ed2bb046c0eae5af480e4b9e124d57cd379a4cad0ff4f674a2b7982168f4966da171130f0c42662405888c73a935803db4ab19ab7e5337849f0bfdd7de03f346ee0082fbbd7a1bd3dc65d36df73ea8924df5efc30bf511dca51086e9555f4b9c027101162713a146a0809cfef819db20abd3c40a7d3bf76e5f4bb9e60d5e80883cc5c4154b3ee0c00f52c0d676141da6aac240e188e3bfe87889c368afad716903892737e70783e180b15c7bb6a27b18030a211fa23323d6b483c1bd8b0773739c17d9b7a475ebeb785fbcb41f6e6d059f217ac56783a7e9e9d2c74269eb4f3a8c174f0af16047698a07c98d86424593691636abebb250cbdbf6dbc97f62aed00029905efb6615fc3fedc02d0cbae02a3b5da342e0509318ddc2fde688e130b96c183977bad15ce925d5923f4499a0b069f4985f8335cf730806a1e0ce71bc47ffde14b77d5b10789a10e7eb544ede7d6967803153ffc0d7e1a447e8c63d051ffe90504fe05591a968c92d407606aeaa58992ca5680e7dc20c981f80f9530f33c895aa42367688f8e5b6a4952ba1e7c04e016cc28ef80c3ae35857a578b78c895656e310b96b166e456480d49a1d184399f7b08a482d9bb85061aba5ad5550892363624546f5b8521202bc34842183d1d80132737cb915e119b61872979708c37045004d013f0c15b0d99e67bd235160b3d429db815e7ce1e31c23383d1ee4fd14f5dd44fea12013a9a0e87376a647ac6c684e24a67d421f2e2d4b775d7429dd038e1cc783cfec6890e3da8e709d19593937044bf9b3f30bb05bfcfefbe288ad77efa4147a9f1a463699aed00c5cd2d686b2faaa24e0ea94fa13601378cd1415b814c45d932f30678f12c52c81eed06629cc97d5db5b2c3096ea241ebc11a25d49740bda63e3c47b718817b0649c2da0ebfe5d27a99a90024432c1bff5c04a0de274036cc5d17173a63a8298be89217d1b697c8d917cbec6b3fa62688b3430acca2066c2aff7eb916ec6c21d0467a7078c969c0fea670ec534741f7ae3a84c5f0eb915d4c013e926c65260c04e0fd8ac13c0f19143e23049682660dce8ead5ed6a5bcfd64ecaf0f7af04ced07701e7c12cf00b0f7ef6684b90c3d97cdfa6ce2ed4c657f6dfe0bcc2a01313ebd787470486e93582bef724a5cd473b50701d5c21aed59c804d307ae5800aac7c9fe7eb46a4045ad8df2adb54c95ee41b4f50c0c15bcc742dd91e3c84bcf7c6aab7ebf4c229656e3b7d22af23da619cd19f4feabba843512568477ec646581d339684183ba42718d4fa8f9cb72b7419d152105d2a9192430579d9e902f613476710e43b64fc913cb8d2ef04b5f7ec135b7e02c569c85f4f6545a3b38279b420bb88f662e45904cbdccc636f887df3109653f9acc988c3719aafc20478c8c35653955af6353ba81b070547e80f268c8b202b2942f638b490cf38f18f21063d6ab8a06285270b71786ade151bf303c6a268a405e99a33da125303457689c91ff41b84646c5f64f21e60e10784d10006979841f1a8f39b7b2c4503928d5f5ab45ebeb83ba460399d379e212cb4eb77c30f970084f2cfee5f256d023c9c3a257268e4e10ec570dac8dfc271df2233402629c2940e329e6e6f17ca0c5cdbcef8b1e4d75ff0d172e3e956cd7b620ba9c571eb29cfbc1ef7ea1b39442818a667d22ba43c44265614c3651a498530e25206f55d25747ce4e8a4e0b3e1102d8a8174d441605d9a8c6ee9096415cf2304cf3d55b816e5e8de1056cc0d794109adf62f0ba2a756ed50e6e08ee511de05eee4da932d89a199209a9ded96ef709366f33c829b426abb4958b982f30bed21ccf48cc4d71c8c3f1ab4e530a5008adcb6bcbaee2b4f3f3845bf8783a69a72e9c5894a689d4e2a5ec182f66c1fa810c18811b66f40699b59ec00ebf1e4ed62f0d732655abf72a8747dd63b3124b77f55554566aed3293d03e95ed1d6bfb80566166962e3d7e4a46022fce9539e782f4ef5275103d1ffe0c43b31f9a25d0a2bc7a995584fe3fe8687efd21959a71aee1161d37db83f836dde045adde05d124fbaec052281e19bb2fd58251b57da6479b00254509ff810b42d8032a51f51c001e15c538dd89add6c6dabab5695d815fc50cfee81dbd63afedfc5b06b6bb214f9c7edd26bb9865f9bb5dbd1c9fdfce7de5bd9cc1b97025787ec58d901293e216d4448e3a438daf9b0fa1cfaefd42575b8c821a871fcaffc191173329b0cebe9e12c71efc8857be035fe4129336e413c419811196624589651d6ace76c173875754995484fb9c91f9e25de00bf1d44c680a47987960b085741b55a927e0e776146aad42f2bb544e53de5a14ee1f12716f737cf722bb8edb6849c1b0eb3dceaf0ac5d6e608b4eb873fb003a7df5f935c0dcbe650b73f2fd502d0b2d22b1adeeee71fb777f76e1bd3063680595fe05d74d1b99010d994b7949141ad9a926efde92d2e77cc20eb676a667caab9dd31eb79a37f2a9989893b25b65059ed3d149cd884968a3978c2c8ba962b8e8c94f50ca8fe33afbe64c73e5455dc47a1612b287178fbecb28194a1b5d9465db5abb7254273ed90fb586d8a8f029e9572a5e7ce534ea3018a84b5bb9578fd44a59e9f19f0f8d14da8a3a04a96692104f26c085b8d6dc7cefb3339bec58bbcda9d85041a6fa3db854ef8cdaa4a1cd6ce00cb6c8c52718b7cf24d750b2c30034d7c92759d3bf2060880afa74d0e07d81ccb4e6f12208f655c7f1e4a6b364d6629645851912b4ecdb007cac51a0cbac60094a9f21fb82304eb48bbf676b2de129318e02984d1782f94be6b55d63cd8b1ef5e422be136bc96cd8e0346349d5ed7acd6dc1e0d84a3746d02706fafad63bcb58adc7389b96b3392e2b1ba9c6eab1c82dfa13be2ebdbcf6043c10900083efedb981d5e956616e01bd4ed09fcc1770a2a74e2d4542880c776ec6fe196fe3989a47cdd1f35e26a1800658522e587097042d8a5561db6c72f0cc8b4fcbb4ed883f33e9d83d74cba05f7a33c22b884459f1f32597baf21abd8eb44328e96066f98a9bd2ba625295795008a188412d4d90181922aab221fe14983be86ee20c3704cec24bc8ec188b3ffbe9b87db6a9c14bcb1e3200458bbadb20a1903e4d4cf4b6919026e52843cae01c5966e1b000c25e6ee41599f6ad13e5a6af31ec0c3f014b95e3bf5ec8371a2a8ccf48cbd9741a246008ae15a10e52d5fb10c93475f8c096a6a56e7a54bc532d17bd2bac709f0d44113eccd329a549986944240f4aa2b784c46082cee25c04fbbfa2504683a9abd248ba7631dd3912509d313c1f2099638acd177d73262d028bc49180bb11c03c8fb62c814333142ca634382a3dc1d0ef138f0a8dd8d7bd57947f29d718df5a953ae9276d4a90ac3b16fb4667154ee48d3f96b0b55174e1a45b1214ad08fc76e3b7a32e21e54c02d39ab4ccba113a42be59a886be98c875a862d69cbc7c8cf5fe199629095a46f9d304289ba145c0a0f0c78e1f175b9687394ebb3574e50356044e6249c0fa2b456e9a8b64e635ca04829c78f3530c793067515406882f3def2bcd9681a1b965547784d1ab2e468dcbdb3649bf53277a197197c821aebdcc18491a91b7ecf9b7b1718b524912f1caf239b6468fb224358ad255b5e6500542c973117fd9cd0e7cf9f84e1451f4d41a8637a452be96a53cf548aa9ee4c4986af1ce21c002209ccf67aac2f6afe9e51a949a88f63da9655240978035f971a9d03237fe20d0481e248f5edc2ca648185ae2499e38da28ab8a3060fd62fd517cd88c3f5eeccf13e77ddad30cbc275ea77334153f99feadc66cb20a3dd95c35a9cf8dc61c6cea33977910de2947e690939dab9cbf489b32169f63a4eb64cad8a69ec9538db2b7bfa41d9527400ca82b3921d346c5bc0ca263cf547d006f391dd65c3b820d871258461de44743fed72262aaaadfe27c859c4a8f6edfdc953e0c2fb774bbbd4d117c40b4250321c5291495e0402eacca882a4e580c70b4203cc8ce9af0b48dec2fb35fa67437cc6bd6d89067fe58de20f6e0e33e24a8655b8bf6e41af2534d572bec670fce34eb5eb7251310fa982cc79bb9b2ed527e43bc58b6289df8da54930039631f29cb303679911a34b9a33265fd1ea8d5848cf84e6bfc7a9416b56cb7da171256825eca00a03175e219a5e8084b422934657ef9040a00ef6317b0e36d9a8864298c07490cec246b6d6c86ce75b754d657c9d08c7d201973c4d34bf33b4813c87b4e0aa55c567843b6c31d0b1c2576eaf00fa020831b4e31d64d6f40289ffeca80b1f98f040405eb2136ac5a06643bf9dedc84893e2bca08d7f1ec9d3cab958bcb25eeb6656583eaaf7a034b21631df6d82c915ebfd1c993af3662ae84a73c8bff9b8439ddda049052ffc4ab0374593752f1a853ea33ba6185acae29d8fe0dcf543375348f1c11371a44123399a6175741ff3c82991e84516ef5da4e76a4aff87b24c5176a7e45ad897b98a155b08962aa5c566e1d9a7c2fb9f45bab7687bbdd0af616b1a43b8d1e8b9ec720851e9cc01a045f507cd9c06e06b678f64cc97ce7854ecc0435836effb1faed700e04b3742104d5ee98f7d3fd4bdf37c5d1a58f0207b99a955c4a5cdbef94439b32c9975c5311e68e2cd73358199dbc94998bb8b60052593801b010d0ae70543f51a727932cb25cd35fafe563c920b8bf1990b2e9897a9030acfc97fd0dea0c8afd89a7a7ccba0a73126cf97863be16a3e3c72b979a90825c076f39dc171e9a5b41a7fd0e66c9d0dd5e0ea1f8819fc0e67978920f8fdfa97a6ad23b61517c9fc9b905d30a84a8d642e0b197347a691689f34a36eb193537450935aeec8e6be8e04f546e464466906359f91f4d4f0ea4d11068957a69eff146e96b3cfe61c464ebdd4e827b57ae6a4e5cf16c8426ea4b9d666522184d4d5f0c11ba5282e53ecd5b2e055bb6ae4248b15aca5fafbeff334b54911f1a48c8ea0f046ab302704d8252af1c2b986fe0cf595a62d9dd9495774903b632486d0e5a69ffd8edbe7f928a53b139b2aa3dfeb7b519e50d53a658ad4b0471f9502b7ad15192a8472345e52987188401e6f437114c160cddbbaf0405008915c60d8b59819a6822d0832ef7eaebabdafa7f0dee43e1836b19c931fede6a330154b509c5a5b7105501df384cdb206240e814b7c5747ce9c774b4abf63a330a431ce83168c212f49b9e2b4ac0d39609bba55f54a1faf687c1c7b1cbdd010831cabb439c2866652b3ade539d6ec77f6ae8e3d74233ae7f3768bfb1238b2ee530376fc3241a1adb9576e44ce7384719be784bc77ba32d3dd8c187c044e54c1664d797a6aaa7834914ec2aa338dcd4ecb9dc9f0928c94f5bc0287040f1aca863921fe38d275aad128a2e68718c1f5eba532ac9496e64b18a3644e61c42e208513bce7124cce635fe30ad6ae5dbc932370cd8a3c5314eb39c7a6be45f254c2d923500d59b40873dc56c03812d0e1235f110421f7b6d321e73f4cfa1293fc344d1ef329ddffa0f289f7f5557a67a88928d926ba0d18ae28a7b56c0c10d8d83969124d1653310f5f2f1ab0727b81ff938fe1822d0a7da005ce94b62463489b7326194535d88e0f7db87e52ff5741d96f4864fa19f58aec2e344dd94446a2f6e8ecfafea0625a415fab032d91627e47d5adb3a740eac297e5b072dd59aa2b78683aa8c53071f9623697f6ccdf117e0afa45dd3825a2c9d56c561de34410a0bc43e8ab5ed5d1bc40b31bcdfdbf3bc28584603fbefdd3f78dc9a3a155f688781860448cdb79e6eaf3086f25febfcf049f7689ac2573064c6510ac7fb6a4e45ec3d1e3b17e73e34d4c5fe9a08c17ad1bddc4dd92af738c12fac389d73cb16c3fd14ab506365d725dd5a521abf2fea1406623ec9f39a8d6446b459b0b81151e030fcb38f430aa29b44c90de2bd940bb53744769c78e896fbb044f257fa31f732464ff075bf565b26a7ec2515e130b0b376cd8645d02ab78d79d0959bc2f56aedd3ef8ec9028c039017ced3ca620ea78f784fc897a6384a5d4adc7b19fc31445d59cb2afd4141f4566443f561c129758740731beacfb29d47f58b314dea1e5c8bac469ce18ba9977fd10275d151c6ab5156925c1eb9430a663029c4fa08b8f684b7b1e5d6f8eb3e82d139da72be60c0b25d081191c1a0f781052266249b4c18738e10d8b2143cca1efb053242bde8ca695e4cea109cd85d862602664b8dcf3f2af9e56c304993593e6662dc843bcbf5b33739a6afd1447873553472a14d704d7bd5b8cc87600213e1fdc3ff5a6929b48bfb04b7c1827df3060c1c008c06d0521825f9ac5b39a0cf5f4fe9f738c4a8a1cd74ccab0a074d92efa6a9e0a32ea6894ec601332a2941fd7ee3d14c6dede444d1095a9ac2ee8eaf9f0bff27f049b2463576b5dc46a60861f40e1552280e9e02be7728016b1f13f67120183b9ba756e75cbccf00ba6f5f84caf83c2c81b27e1e91f56331cba550e2c2416bac3549449d4ebf879e68dcca1c817c8cbfb0e567012869f23fdf0524e48d882801f16d5f1d319ab24583182f9a9b65666841ae649ed49cdb3f4dc1375eb5b4373c492e5eb53df451df51726afbd88fb14177d749b65bbe082b63c0c956f2d8f67e63edde3326f8582e42fc17d575fed11c029773a6f109cf756fa76bb301022e81dafe15cdfa369cba4be674e9ecc07dcd4985736af57f5486eefc6d4896c1d0103af85fdc7cb9cdc20a9b4a646f08c7dd3e03b7baa24b57e9f04cb12492ee75a5ca5d389072a1fd088f098bb5a7fafe6a44822b6ef03e7601948e9158869d9fe5fe8b4efe4ff9366fdf3c3f033c6f601b8c2f3644b46372645b8df947f7e6f53fa03ec59f30a4f3c23d71487c5e246cf25aa019448db383f07e33d7704eb70723bc0b023e3e9ab14fb81d1de8f12f74281c6194353df1a550f2497eb35cf5653e17bf2592d59b1e4597bdbfe83255a05c396921242087c78e14e159f7c58a84a26c0f287a3a59af6692c2dc3da149fefa660961c8d23d54fde21a0a313f8935b4ecd1a7c39ce9bf489001e8b9f1e51bea46dd6b9769fe636bf4572d1ab12967638d05d1e5cf1f794989107b8905bb8eab43db777ddb81669840fcbc16ff8358d054f464b42096cb6e0bc9ffe5c1e652fa68309d9c09ef40730fd7a74ba21e7821cea94a7d5f748f63b222732fb960651fb0a941a1713817e17acb1ab499a70c8f5b37a8f5700495f6515d0eed87c188180bc08fa2e553265bf48f9f001c4a8c94c2874a24494f3efd67bd83b4b5a7d80723bf45ceb8b1bc268457f7c3c932224f8488c78e9f29fb073c9d894e109ffa38041ef569d67723b286dfa63b5786b75b854928474668486dde1a2f3581eba37b973b7b1f9971bd9e348936ed03cc9da31db7856b883de6f69991ede9c9c81ed698161c594b6f19394e85d1fa152ff70297eb48661cad59c183d9dbf3f2c4d23f78b33a9d343bcc3031f4d9494fb4a9a9f32c7c2290a22cf96e1e5abf93bbb498bd89a352a60d3795451c7ea970dce97eae7afa7995cb74398d1eaebaa3cba82446b78de72cb6707ad26ec61696f5ddec032a6609e2d5082b21eb844b6999e581d929afd2e741d0629015f96dd657c86335e43d54334ffd00c5c9619067418a06105d585531d25cf814ce3358869c499e6fac5cd659d2b92aee4f06df8dc90566ce0cb31492c6c3091d64724c212e3bab8c90ff5a3d4dcc939d719e3beef081267125abcdfb4f1ddceff7919248f59aa7eea30e3389dfe78b1b854eb88c43a0f0f4cf741f5c5275de7c7607ca46ff43c0b3d734a8b78ff8360e9c3b4fc03fd0d4e9f98177fe0af8d131ef76aea5ae4ffb153ddf473a116dbae62a75807cb559fdd7964e0ce4030a7e1ea9115b048accfc2206cd566d915677388c627b1a70a671352024ae00fded4c1b10fa605429b2d06aecf389f0fc85a88232e7a27e96e5aace299f6606e5aeda87f468d69e66d446092c9d632c878516259beac6b675196074223cdeb4e15c09dd07131b5f3ff0d448b7ec3a8952f426afd723550ee8f641416baac9e1dab442b263fb520c96dea1ffd5956d31ee7d9854178c06cf5dd4830dac6738f97db840ab35706cc80b6dafe19ffaab8b0304e7a4f389a084004e9a4af0403fbe73d9ec2430437c19ef25305f5e66224f7013641290bc091f11ef44307847ec66e5884315ce276fe0aa4109785975899174c378b3e00408103213d36a6055be5b06ca9d34d315683c699cae0e5c4d26db8efc27c1a3bf1976786b59b43f82afa265a03826ae3ccdf0c2f1e1d44612336aaca21b8f9327e2556dfc481d402c8908fb9fe3a4cc5480256c52f3bb5cae292f7f97e8aa8dbffa8d55cde779f4c72b1ef6025abdcbf3fbb8a3a0f7414be0457df33d980b9cbdb8674487eab69a3fc09db65d5aad946fc7feb08f746b5b558ddba7baabf38aa1fdbc866100e4f3a3c1e7ef5a901984d3ddad028b3bfc710ee49da7ddfd6e769c0020f766438235fa7785d978f23845a74a10ac309c96ba69a08ce8b27dcf746c030bbba7fd92b4b82e94136d027a4db59505dcc8fe229b8f621507482a4c92eb1bf8d2bce0744156c0cde0730371bd977a871c4abc41db2d4bbfebaefe1e82c49f4a6548471c4246e244fcc0d9de6f450e7621682f8acf00ce6c5c7d551c0ed12c8df153eb6cc1bba374581405faa6ef77f19116c455fcaaa2c20fd0114b8ecb95adb1465f6440c167cfa7640f455b2f01","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
