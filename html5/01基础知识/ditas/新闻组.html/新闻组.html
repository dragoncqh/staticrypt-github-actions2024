<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c140dd040231d76497c0df6d37c614256f83cb6a70b43cf2393016cf91938aff08ada6189f06cdf381a0af17962775284b2b3e6909c8c6075609a7a79b8825eb7e64d7935be52ba80009dd1ccfdb30707b8d10ebda8707037ca2fcdd48f15f605d47394e8d1b8967101085c24987a42ec9ab82ffc0e9e5d253243f48f4efa01476841267fe5853c8cf5cb32ca5b808486b5c026e373feee8a71d398335800953794e65d0fc55a0e3790324e8f960a6398b5141218b89d909cdfe54d95b357c89e5645fce667d50056dd55102b966afdb45cfd605914a87e0bf4f8dc982311959ed8a109c6f8d3bf8630028e9412740a5a78fa0bfc89150b20755d0973bd666a1b3d140f27173a700014188c4935608eaefbd214026743252e11504b45d2eb7aaed3147f4b2b5b44d92db4f58b3b404f879bb9762c6e5734a63c5ef7431127c8eebea13349b9eca5734d7166638cfdeac345a21bbbe20bdbdf80d4a1a65632a59aaaf2f2e4cadab7329b4896968110c4063f091774417451b96b13fd306b7496d393da0a00d86734fad39fedd4f639f1fcd2fb9dabe88ce76c60dab7274ecaa8044c0b3284283f2724d5345981a5b0e6fc30f64dffe3b2e98d6da3c58a265d04d727fbc1a9da8b8b113c6b9b3d693bb73415e2858fd1e462306f8652d4acc75897cd58bf4aa5511d347b14b45afe68b0cb27a03d2e5e08e4078be46edc29eeadeb8975cd7e0c46f6f405a7b77aae83d5bbb7d27084a38c5cbf1505908ecc7a568f1f550b35b66ec3288c8a2f173a3c1722514af1a75be291315c239f7eddd9bf11f6c015f327104bff352fa55e2cc37d4bafd209971782a76407151e808e8d800da4e1656ec53a59a5de2a349863dcd4e0ea8366010175e895c3c8574e96fbab24aa29db448a3df6dce7883f585488f3c47a7bc236510944deb71dfc4ad1717b1715cc9e0daf9d108907a646cdef305132601bbf90159c8c1ea19fb3c2fd99f0ba78de9ecf357ca9722d41a518976f0a18cddcbc54e7029f80183f2e12c531bb70f09d2223b110a95294dc1a18b0e7ee01c27f777481f3632249322cf7e259541308ceae4913bf576c9801a0e287afe39b4611bcf6ad1f48772d1b0450fc017f39258f7a90581b4109e51d86bd8a3acf582e2fa00d157eb78e7c911487116938c15af7b05ee801620a3b68436b580ffcbf5935d9cd02aa4ddac513035a7bcefbc5fb0d6b2dc48a4f5d9ba305a10d8f2706d5ea3e4dd3b211659ee70af4ac42707e4f0b5e3da9394970a384329e8a94842010de58d179267ad7ee7bd00c1aea0bb6d11baab55bb412c8796ccf2b3274abcdb3fea7a324398dfecec37117bf46bdbcd05a26955730062d4afbfc7dcb2f9e4c774d5d2b93e6bf076b19826dcac2abad158a01d924745829e6e9471778bd955e347e9a11068f86aeae49a7c6a10892bc7c480555e35670d3843e38451365828fabae8651f213f0b1cf90cbf9b51aa01899613a74d47af7af132b72f35437b1ea4d0bb576db97b2da23e1ab5984493b0d488b7b71b55943c5dce714bb9734eba4ab243aafd386ad27bec4be1dedfbb771015c35bbc977f0ad471dfc387bf2817fc632c644cd54ad8ac8a09024c8e84f550b5e652d2289c85cbd56b2eb1a7df78978a0d81253615132ac73c672836af18fcf22b411f952e83953c296c5b585ad302076d5a87adf2f45cbd659023ede2ac25684c90628ab662f07fcf3a6bde3a112476a040eb47d1ffe49b399dfa1e58c637d75b64611f2e2682a23a2180b5a641e188ab542ceb02e035f70b60cfd30ccc0209d0578a050eeec9eaf6528b3fcd1cd8b0d0fba2837ce6cea7e777813d09f9657570f96ae974058f91ef9c68c6404845e52666708f779d15efa942e7728b4dc33126946ffab68b332ecdb8ff46cb55798c6559b10b8941e8c9e684c09898b87ec04743a622f5eb410169243cd76a61ed2b3ec58ace39cc4f7f2f16ead4d29b0faf766d8bc813e8b028131439fd7cd31863c74a2d3db4a648fb3cb6446f7cf5c582f2d597cbef1ac67b91e2d7e6b1c7a50dd707585e4860e1491abefd378b5f075c66037c060af10092d42087fee6e5c9e84da1010dcc77e5f8b9b0081575b6fecf59d57999b87a1bcdde453c0c2638a0c1e66b6239e17096b8ba87b53345c6dc6733b0eadbbf5a88ef9095b4c441f25a8eebffe36dd02ce907f86696b60dee427ed3e87f0eaa4c5505f5b3aabb6907449c290c682e737d7868b667d82a0111dc503986814517a1cce5b2321d19540c6179c17c1e33b8c2643f9e1b681bf77b871bc22cab6b634222f73a1643ab8ebacb5553f425e7b2a55c8092ec21173496d0199dfeba7e0dbdd13a02ef0f803210d19481d41676a4b611f95818d8761f01e466e40c808dde44395b82b2e8b6fe3d9c2f23a9ef04f55ab6a3afe15b9317055c17ccc84466fd05de3e24d8cfa670b20921c86a8c2ace161d3f501681ec713f6f5be01688f646c8f519a080652f5e2de0d5f5e04d7b7ebf5e2aae930b39177c4cccb7306f50891b29b719ec7de3e77e619379c658db59d05f8669464bb389d3096b0703c3b30a40dfdb7d0d1441ee3aab92ab7e6b14d3a712c8742e0ddee6147bdf45ab3459330c94e1716fa7c7ce0e1952a890b60302837b0d2f5f457f8b6e21e48019a14ab30a4b00fabc13b113d5aa4017daa16c540e9375e5555b49539609115a17583626360fc3ae0d4c593094fdbc60006b7649cec9816bff8a5af9ed67d4ac947f376cef63cc7d943e29cf301ddd92c75a1f94401c591f4cf9da675f0dd957e869571684800a35d8f76a1b2d07ddea55fad5134be7c43a600d005dc9a942537cb173ea98163398637ec03b85ade42be7f427ea98b758273e643e08bda66f1b6a42fedbdb2a169a228cd7ef9682dc944c2901c2b62f2982587f5d13d6e68a9d155930f81e6c311420b5e7ead7e4251b1a957668e322fb180db554a954a8616f22e59b87ee4756ed3f0a58c8f25314eaf54e813a85d1e7f3637c9ae7c5359194c9465e8cfbc0f4020b4af879f0216f8f234cf73ab381a12deed0eb143f68ae7cb7bfa827b91f6b53ea6eb278c842e72066d671ba67f91c4b70934d292f03f5a565e48a1f2a9ae58b24fae903fe8e784c0bc86d6b2f5ebfddcb02492e346bef371c4e4f23769703929210e456d61395f447926dec79b8e78559ba7f012d46a099dea5b9386ff217689db5dae8be00428ffc67a9e8f7b42ede4a8adf8b353bbefbbfda83db76fce0b33700b73fa7220ee5ba8c8219ff34a76bdac5d779acd7e28b751efb5e6e55198aae3091f513f67ce94d7c959808976829e6ea4026ee30990d9080f497be1c6b2c302e0b79e505bf8b874c8319aa174a8a158fa779349d061f627acb17980e1fb635609248b9b73604bb979558b3de643dfef9f699e34abc305941ce38de6ae6a9929655d35aa75550ce350e03bf77edbcad5690fc544dbfdfa191415eed94763812d75520726ba184ba3e3ba4238b93fe4509552ed6b45a321187dbaea0722f134fc14bca49a5f5522474ed6bf08f58eef7aa864cbe0f5dcb142b34b6b3e0a46aabad5907649bf04c09d4f0db6551759586e2bd9005440c95f9b2b373e7ae6e262adc7546f295b7a58960588cc0c023f878ce3c04b71865ec0509b6edd1612b67241b0707576c46fe31f76dc7e318695a9a81492b02eb9e6fde0e01faa97c755ce6df62a3efd6c62c9088485e4a86c9571d50275e6387484a1d5a03dfb0fe45bc37410a378cabe35ef78ce28ce5374d15a63c9b6f6402df726b4b2d5d4fd2fe3e4669738d34b9655b7f80eddbdeb9b212419073b2b39cdeb3df4c2a6367910ddda98123635e14b5cce62e0e9e3da3d61d3b32febae6c80668ae6f63e23f006d1778549ea3bc861d24561c10783b0a972ba3e900a7c09388a0fe75c5405a37171be5684aca4558560aade51815905787efd3d25ba2a6026c1c8340ff89909825b53155bc7c84da75390dd0f2334b98f9f1a5f79f18b62a4cf4bc3b426d784d6da933a133e0229c37d1fdf70d7411547d07546bc281f7d295e7c7aea61551d4ecf6f70471c59b0bdd70facfcf2498cb5357d0ac40a346984bfa3cfa5a626b3cd9183dce672423d190b30aeea0a8e97a815a2494d818ab3c187010bb80802be8de75a850bfececdc27a064617d4c6fea13b60598d3b8e96ff37fac9ab2feb5dfd8541f8707bd70fc5b1006facd0e66fb7f4c7fe4451342d28bf30aa772ba45514d293ec385215aba2349d0f5a3e794b73749287029804881e8abd5fe0020862e6b8109f43d60d0d6a494897468f206144397e5cb466d9e310e282ac817900195d50f3ca6fce6bb9631caf2f9bd0788aa10bea8b365cb2a3f8fa2ac5513c83a020ecc902d485af23afb14bdbe597b3ebe9b300886fc4c17931da42896c586588fc4cd0271b86e0fc76c0dd98202bcba923ceedd1cecd786043f66dd0b43e62ca7fb0385dea50fda841fc02276041f45eebd4adbdce4e2b71d86eb9ac5ca71d6cdd457d2efd5997dec2bf1d8085672e8876ce9cf2fead9d6bf7208acf19315a3f81a3d8e42ae1c041d536e69a6be16bedce10dd7e9ae32f0b7b09375515c6e472f77c8a2d80f1e367d515e752b9f9caa9198a00a01e7a69e1578bda4e9d9bd7f3730883ebf6c8a88626bf3ed28ecd5c9b41906b3a7a52135c4cae03124252169ab1da6c73237c3ff6a37c0928294e2cb67cc8c0ca9b0d0d1c8c3cd7fb4afbd7dcb482bd55b752a1a8511cffe56e7c93699ccd8fc59855dabe1604d67b54240f6c4003989cbcc0bc1b8081c55437c4053bf074ff6cbf0a00bad88cf63b3a7fe3a3046b9a6f09e5a48def4a761dd5f4eaf3b0c8bac1c56b2d7bc31ad54866009c02ab33e6a1853dedcb4929ea7e3fe6fd39a733a42c88c45ffa087e4204639768b48980b529173c0ceb5dacee449688872ad5f26c0712e20741de3453eb06856d5a88b079e37b995bfbe1f5dc2fb2628e6d8f3a40c36541dc00c098df6825a1be42d852941bfa0df657a6f153ab829a1a5b45ae421ffe7ae8bc440879fb694bc2dbf6e013a883e8ac8414f615f97dcee564bfc53d560f56ab729c8f5694e9c5d3d245b2b4b5bcc2d4ea867ac5566a8c5101c310c3f5f76662ffacc79cfdfe7230396d5470788721a10d234c203ee14cf3e7c6b26d22ee29fc521ab3c26b9ab6168b969ad5f345c0ad5fc1d50a752cc571dab9a0681b42e93496b65352f393b7508347be76cb00e752d066d90cdc515c88ad27bf8265a9c13773002d09724ff015e9c2a129545ff863ec3fd0566bc9a8cb0a3684d6d39c02240466ccf8dd089daf7277027c3d807dcf491ca908d883c028e0abb18af5396bff532cc70c1ca35f0246602d1f5441ccc05e24f283272e59a45713641fceece7852236a8c41538290faf17dba96b25bc5585102cef3aa144ee0cc0ceeb84eff10a87838b90d2424f41481b23a8e2bb63824bcd4197a1f9f1a501115a0aff048b9e0f177704ed493580b804657bf66089b62913a7d17885b2a08376f945f06be7155ddff85522c3c6abdf36efda69900277e4dd4b50f1c3961627deacf8e4c846a3867312af5c9d9d81b31dce91c9f4eec77298831903f85a4bfc394902266931540ca2fa56384a7494edc48097732a008e4f92f0594b20705f083f9bf8c46ca1ec771d6652ecf1dcba0a8e1f939427c78fb126617392769f3c650c9d2f052cf1e8d89dac93d5e4933aedcecad10b080e4c13a3e2827ada06e47c09c719f0aa39c00bfcbef0ceaced82c98470c3d3a4bd8c8bf8581475d0e20108d634effbd11edc50de697f2d1909780db60b1680c00a35f0b6d6825eaf3c459f314695d101eb9766028cc4c92fc179da1bdddd36da86cdb90c4e342472dcaff2556d150eb77983160902864461d857a6f2c04825906477ff47536c7825386b559719bd467cb7eba4a98d928656841673996e4462d7f9e5db17f3b184c77571c6850231636f2b5eaca653611acc9f26d8d92b81de101a5b9fe9782380d9931f63047e83e7e4ce2f92161a3f7808f8bf289378406bea5e53c10360ba22c3391bf3d01d336ee00477e03b3d4973eda54e22e56de1a3246590ffc8bf7fae789450ea716b56b75cbe1cba722a9185b7f9d45cf47cd78691861499c7991b9986ce4125b96bf068c963e1fe647e9f63d4c842cd4e8fe48bcc783011aac5f35d9f00219607fa0d84d171f1e64b1e277caaafadc3378dc5ec8edcdb99115c989cbccbcdd5360ffb79056f5fc35e60d03dce41d37bcf9318a64009f309153407cd3f0391f4cf29dc4c29d01ce34dea63b8041e5489edce8abccceda4b5e7fc49969fa20421ae65ce2544343319c52f1f8f936c81a25e09aa407f009b4ad75483ae9467d5ab8448160cce1f9059951a6d193b88653128fd1b53cb24b7bdaf285ee45044057e69a3c060f2e70d4f90e60f38f672003eeee8163ee5203ad518e474d4ec228abcf4fdd1d0685821758ee1d3a28461a43379be973de20face15a3803d5e9bf6e50689d39f37d8f19cfd97e4510fbf053b85c740684fc626af92fef13210cf27a4b0bee9b76387a545990284f04d42ea9f3d29aea7a50ef6b69ac4d04bac49203c061f5c62c2502a54f424d4632c315fecd3d212c669a3c69c83db8b966d93613e503e8719acae137fb5d3f3ca3ee0392dc0527dffc7e762ef8f7fcf92a0206161f245744ac398365bc510a80468972a96c4d8f839d4ea73433daa93f26c55b0ad36b054b0d863e01162c2504444e8223d225ab25efdd87207d3f0c57460d4a3805f794474d0813281cf86730b0d9d5b32913d0dcce1f01b332318059450fed7cced52fced18346695145ca801225735ea0459fbc85a308d214ee553699e1da8ead4534441dbe662b399ddec4f9417919ec6f42b54e3509e1fcd61a7788bd96731bcea21e3f76125550b3f5e796dbefdc031f00b50e5f7f4e6f26c654c97af5e20df5e07e28b36d594cc132dab7a238bd9bfb2ee90ea551c322962aa5698506affc779d29cec0bb9f47d9c199f04d2d6bcc9426dbdd760b04c5d0d9201c45db353bd04e0ab6745959d5944369a24075fe64abf0bf9b0e06a2927d4239aef6c765666439ecae33868f4b0daa0fa3b67e85f47bc8a5cfa19c8878011dc1709b4165b3fe3a82b850a09b8319b888e80d227a60741d9e1b5d182e431c648f1fbf44cb9a285c539506fadca106710fec45ce7e2b73a9667ac28edfb1f59ca8f35627bbeedea4c0054503e19b07962918017aa5efc61559b818bc4e867bca1333f9d8a5677235373004d71c3b598c9ff27af41e7420033c2ca01e37bed3ba4d327362ea13d50fe1d071fa1a65f95f28618ce4cdf9584691bb1a56b950bfae1d6b2dfb4bf2a52b980d83ff30fa6277207a1bc87c2f145ab2db6c0e18206b3298657f170dcda63ccadfe6402a8ea618e2021798655acb25e8afc034ff96cab28ee100f2b61ab049c6bde75a1e471263edb9434a886710b0b1feea32e35cbb98e0f996dd1b4fab528682ff44e012a56c93967e0eb2343a2eb52e7c30a7e625eeddceb47f31f1ee6d723b11759991b1e1afd33549e72d86abed6f339bcf808acea857fc80372a578ccd5a96863928c3c5f3cbeeed769a512826b0b39b808a78b6df8f89593fe4dd7b36b052058b394a47351b80c6edcf3279b792b954d2aea727200e8043e4ac362f24ace130da03b60d58c4a6ea2ce551a5119bcbb2f6d799bba26069b8a40278c7153734ddc088a206df6ecb1d4bbaa211a2947bbd5c474f54b9bd997c5a24c864dd9540b31b50b3ebe390214cf1dad6618a1521ca44507816e2a0c41b7b66eaf7ec7f441953163eeda79dd09437b3f4ba2bca287621bba989fb5474952a04a72904c5648e70b37b81739cfe59289ae5a5b4715075dcbea622620ca6074e2b0d9426ff2083eb3e89ccfa885cd9e7ef074e62f8f0aeb75f8544d10c9e144c8359122cd37a9afe47c15ad9ece468b97e0f8d84fcd91579e0a2795141e6e1c0074c442ba5e8a90e4fcaabbedd93bda68278bd33b918ad6bc6b35308c59b836570c3db612cfe6096bf6a01072ea665864d0991b55780693514818dd581525df1f551d2c02a9681a514d7735583a245d97d6880959d67be31a58712535841ab9ab67a091684765a4623c1b927f519c57d7ece85c8272f54868896a696c16f793450a10f5eddd63372f6e9d849f02fad35294f95505a10602ac2365f429cc0544d758c5d49f9c53b1bce776061ee4127b19fe1a076d32dafc99587ee19563165c65a4404dadf98735468d65cd4ca3c1a3b2be0193e6821a817dcb4511d627aae58834c8146063b544d1a9bc9225d25936b0cd629b05b6d39f6662821580ade84e76cb14340e971cb1b119952ea9cfaf964414c001ebdb712b65c9029d549fb748d7b85d24e455094ba018eac7790412d52caacd110f4731c3913ecd360a427015f45e4de84a7a405924de4bb69c996830a17c4741a3138c432548258d6bf908f7cd58e1d298ba144450bbb81dbf2189d7bd65d5a657ae7d3818333dd78d853eb8739c73b0c0389d2d305ac61271312d9b08164b9e1bf18f51282bd3eb46677c936e7af50f32e535497abac171385b0c01e3e94222b5219df17eb200c0b3735c42108152aa76bf2cdf4bd6a245e999b84de28eac769c058b6458a9f3b5c4fb496c60c3e97b0fddd9aac8ae5856788ac64f94bf09231630160d31ced0c41dc7d501245042fef51864e2639c28dea339317469a6c7add3c23306ad916ba10581fe8076bf0c871ccb498fbdd092d80fd2578fdd6b1a2e1fbb163f5d9abcc693651ff6757d4201561a68f346247594e95906298ddd0823e545e915fc948d399fe17e0595675aca42255277607b0aa049e0a25ec4cf561bc7cbfb84e8a64035914b79d3c4041b0c080af9629fc8bea9a88f740ed030c032c0b4008b574162915807991ac0e3ac8f020c408346c358b5e4d365b81eda28a73597093634d15e24bb07d9a4c2ae63aab02324a5f0fecd492200f9c547bc5ad98e875abd798212b83a2507ceb808145bed71f5d4bb22ff0dfe891671d8d6b42c3858781458c01782dbd96dfd572da0af0ebb33d3bba1674de48e5ae61b00a640c82bf69a9101d59b567cfd4632f35747fb333eb6a2fb9a7722ca81b8d8d326befe48e7ff92c91eb2d476c859d914319f3045aaab9668554aa7ac4de9e02e13d4676bf0c92eb5e16d651a54d6dcc20ad1bf09aafd5199901d8c6c526cd9fc1064b20d457650ac2355038e0324edc67c1d4dc59d00c1700912edb309500196ff8d7a423b9af8144b9e97fc16c72dced23809fec05836cbd7501967d3c2cd36c8a0c67bf48c5d915f9a8511dd9e7fe0d87a8467b332edb5914c488e8965430fc637515ca1ef38e6e9c9edd6d85ae4d08fe79e5aed6a398f93db9ad1a46f56b459d434faa44edd497a9ca01f8a397ba92fe3891019f915d807a0413738bb965e5d13a231caedadcf424821723d15d86acb1d1e753376dd40417e01e85ad70ddc8e26695a94fa04f0536622e1e761bb2f87d5d70444f27c77fd36b78a9320bfbb803f3d47038d3427f38f401e14ae267ef1539fec57d2ad44292dda0bf99ce735ff48b663d02cfccdf4cd47282fff9227a282b4e57df99a1f22c8b345641f1787e1811b10ba35c3f0021619100f0a490b1fdcf66a45dc235110833d808a3db4ca9a1ddae4d79df0b4725cf5f71e0f480e0d3a3f6c976a04","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
